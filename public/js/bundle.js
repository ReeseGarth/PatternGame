(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// This file is autogenerated via the `commonjs` Grunt task. You can require() this file in a CommonJS environment.
require('../../js/transition.js')
require('../../js/alert.js')
require('../../js/button.js')
require('../../js/carousel.js')
require('../../js/collapse.js')
require('../../js/dropdown.js')
require('../../js/modal.js')
require('../../js/tooltip.js')
require('../../js/popover.js')
require('../../js/scrollspy.js')
require('../../js/tab.js')
require('../../js/affix.js')
},{"../../js/affix.js":2,"../../js/alert.js":3,"../../js/button.js":4,"../../js/carousel.js":5,"../../js/collapse.js":6,"../../js/dropdown.js":7,"../../js/modal.js":8,"../../js/popover.js":9,"../../js/scrollspy.js":10,"../../js/tab.js":11,"../../js/tooltip.js":12,"../../js/transition.js":13}],2:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: affix.js v3.3.6
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options)

    this.$target = $(this.options.target)
      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

    this.$element     = $(element)
    this.affixed      = null
    this.unpin        = null
    this.pinnedOffset = null

    this.checkPosition()
  }

  Affix.VERSION  = '3.3.6'

  Affix.RESET    = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
    offset: 0,
    target: window
  }

  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
    var scrollTop    = this.$target.scrollTop()
    var position     = this.$element.offset()
    var targetHeight = this.$target.height()

    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false

    if (this.affixed == 'bottom') {
      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'
      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'
    }

    var initializing   = this.affixed == null
    var colliderTop    = initializing ? scrollTop : position.top
    var colliderHeight = initializing ? targetHeight : height

    if (offsetTop != null && scrollTop <= offsetTop) return 'top'
    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'

    return false
  }

  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset) return this.pinnedOffset
    this.$element.removeClass(Affix.RESET).addClass('affix')
    var scrollTop = this.$target.scrollTop()
    var position  = this.$element.offset()
    return (this.pinnedOffset = position.top - scrollTop)
  }

  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1)
  }

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return

    var height       = this.$element.height()
    var offset       = this.options.offset
    var offsetTop    = offset.top
    var offsetBottom = offset.bottom
    var scrollHeight = Math.max($(document).height(), $(document.body).height())

    if (typeof offset != 'object')         offsetBottom = offsetTop = offset
    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)

    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)

    if (this.affixed != affix) {
      if (this.unpin != null) this.$element.css('top', '')

      var affixType = 'affix' + (affix ? '-' + affix : '')
      var e         = $.Event(affixType + '.bs.affix')

      this.$element.trigger(e)

      if (e.isDefaultPrevented()) return

      this.affixed = affix
      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null

      this.$element
        .removeClass(Affix.RESET)
        .addClass(affixType)
        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')
    }

    if (affix == 'bottom') {
      this.$element.offset({
        top: scrollHeight - height - offsetBottom
      })
    }
  }


  // AFFIX PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.affix')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.affix

  $.fn.affix             = Plugin
  $.fn.affix.Constructor = Affix


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old
    return this
  }


  // AFFIX DATA-API
  // ==============

  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this)
      var data = $spy.data()

      data.offset = data.offset || {}

      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
      if (data.offsetTop    != null) data.offset.top    = data.offsetTop

      Plugin.call($spy, data)
    })
  })

}(jQuery);

},{}],3:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: alert.js v3.3.6
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-dismiss="alert"]'
  var Alert   = function (el) {
    $(el).on('click', dismiss, this.close)
  }

  Alert.VERSION = '3.3.6'

  Alert.TRANSITION_DURATION = 150

  Alert.prototype.close = function (e) {
    var $this    = $(this)
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = $(selector)

    if (e) e.preventDefault()

    if (!$parent.length) {
      $parent = $this.closest('.alert')
    }

    $parent.trigger(e = $.Event('close.bs.alert'))

    if (e.isDefaultPrevented()) return

    $parent.removeClass('in')

    function removeElement() {
      // detach from parent, fire event then clean up data
      $parent.detach().trigger('closed.bs.alert').remove()
    }

    $.support.transition && $parent.hasClass('fade') ?
      $parent
        .one('bsTransitionEnd', removeElement)
        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :
      removeElement()
  }


  // ALERT PLUGIN DEFINITION
  // =======================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.alert')

      if (!data) $this.data('bs.alert', (data = new Alert(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.alert

  $.fn.alert             = Plugin
  $.fn.alert.Constructor = Alert


  // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old
    return this
  }


  // ALERT DATA-API
  // ==============

  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

}(jQuery);

},{}],4:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: button.js v3.3.6
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = function (element, options) {
    this.$element  = $(element)
    this.options   = $.extend({}, Button.DEFAULTS, options)
    this.isLoading = false
  }

  Button.VERSION  = '3.3.6'

  Button.DEFAULTS = {
    loadingText: 'loading...'
  }

  Button.prototype.setState = function (state) {
    var d    = 'disabled'
    var $el  = this.$element
    var val  = $el.is('input') ? 'val' : 'html'
    var data = $el.data()

    state += 'Text'

    if (data.resetText == null) $el.data('resetText', $el[val]())

    // push to event loop to allow forms to submit
    setTimeout($.proxy(function () {
      $el[val](data[state] == null ? this.options[state] : data[state])

      if (state == 'loadingText') {
        this.isLoading = true
        $el.addClass(d).attr(d, d)
      } else if (this.isLoading) {
        this.isLoading = false
        $el.removeClass(d).removeAttr(d)
      }
    }, this), 0)
  }

  Button.prototype.toggle = function () {
    var changed = true
    var $parent = this.$element.closest('[data-toggle="buttons"]')

    if ($parent.length) {
      var $input = this.$element.find('input')
      if ($input.prop('type') == 'radio') {
        if ($input.prop('checked')) changed = false
        $parent.find('.active').removeClass('active')
        this.$element.addClass('active')
      } else if ($input.prop('type') == 'checkbox') {
        if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false
        this.$element.toggleClass('active')
      }
      $input.prop('checked', this.$element.hasClass('active'))
      if (changed) $input.trigger('change')
    } else {
      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))
      this.$element.toggleClass('active')
    }
  }


  // BUTTON PLUGIN DEFINITION
  // ========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.button')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.button', (data = new Button(this, options)))

      if (option == 'toggle') data.toggle()
      else if (option) data.setState(option)
    })
  }

  var old = $.fn.button

  $.fn.button             = Plugin
  $.fn.button.Constructor = Button


  // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
    $.fn.button = old
    return this
  }


  // BUTTON DATA-API
  // ===============

  $(document)
    .on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      var $btn = $(e.target)
      if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
      Plugin.call($btn, 'toggle')
      if (!($(e.target).is('input[type="radio"]') || $(e.target).is('input[type="checkbox"]'))) e.preventDefault()
    })
    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))
    })

}(jQuery);

},{}],5:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: carousel.js v3.3.6
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
    this.$element    = $(element)
    this.$indicators = this.$element.find('.carousel-indicators')
    this.options     = options
    this.paused      = null
    this.sliding     = null
    this.interval    = null
    this.$active     = null
    this.$items      = null

    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))

    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element
      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))
      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))
  }

  Carousel.VERSION  = '3.3.6'

  Carousel.TRANSITION_DURATION = 600

  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true,
    keyboard: true
  }

  Carousel.prototype.keydown = function (e) {
    if (/input|textarea/i.test(e.target.tagName)) return
    switch (e.which) {
      case 37: this.prev(); break
      case 39: this.next(); break
      default: return
    }

    e.preventDefault()
  }

  Carousel.prototype.cycle = function (e) {
    e || (this.paused = false)

    this.interval && clearInterval(this.interval)

    this.options.interval
      && !this.paused
      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

    return this
  }

  Carousel.prototype.getItemIndex = function (item) {
    this.$items = item.parent().children('.item')
    return this.$items.index(item || this.$active)
  }

  Carousel.prototype.getItemForDirection = function (direction, active) {
    var activeIndex = this.getItemIndex(active)
    var willWrap = (direction == 'prev' && activeIndex === 0)
                || (direction == 'next' && activeIndex == (this.$items.length - 1))
    if (willWrap && !this.options.wrap) return active
    var delta = direction == 'prev' ? -1 : 1
    var itemIndex = (activeIndex + delta) % this.$items.length
    return this.$items.eq(itemIndex)
  }

  Carousel.prototype.to = function (pos) {
    var that        = this
    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))

    if (pos > (this.$items.length - 1) || pos < 0) return

    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, "slid"
    if (activeIndex == pos) return this.pause().cycle()

    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))
  }

  Carousel.prototype.pause = function (e) {
    e || (this.paused = true)

    if (this.$element.find('.next, .prev').length && $.support.transition) {
      this.$element.trigger($.support.transition.end)
      this.cycle(true)
    }

    this.interval = clearInterval(this.interval)

    return this
  }

  Carousel.prototype.next = function () {
    if (this.sliding) return
    return this.slide('next')
  }

  Carousel.prototype.prev = function () {
    if (this.sliding) return
    return this.slide('prev')
  }

  Carousel.prototype.slide = function (type, next) {
    var $active   = this.$element.find('.item.active')
    var $next     = next || this.getItemForDirection(type, $active)
    var isCycling = this.interval
    var direction = type == 'next' ? 'left' : 'right'
    var that      = this

    if ($next.hasClass('active')) return (this.sliding = false)

    var relatedTarget = $next[0]
    var slideEvent = $.Event('slide.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    })
    this.$element.trigger(slideEvent)
    if (slideEvent.isDefaultPrevented()) return

    this.sliding = true

    isCycling && this.pause()

    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active')
      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
      $nextIndicator && $nextIndicator.addClass('active')
    }

    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, "slid"
    if ($.support.transition && this.$element.hasClass('slide')) {
      $next.addClass(type)
      $next[0].offsetWidth // force reflow
      $active.addClass(direction)
      $next.addClass(direction)
      $active
        .one('bsTransitionEnd', function () {
          $next.removeClass([type, direction].join(' ')).addClass('active')
          $active.removeClass(['active', direction].join(' '))
          that.sliding = false
          setTimeout(function () {
            that.$element.trigger(slidEvent)
          }, 0)
        })
        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)
    } else {
      $active.removeClass('active')
      $next.addClass('active')
      this.sliding = false
      this.$element.trigger(slidEvent)
    }

    isCycling && this.cycle()

    return this
  }


  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.carousel')
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
      var action  = typeof option == 'string' ? option : options.slide

      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
      if (typeof option == 'number') data.to(option)
      else if (action) data[action]()
      else if (options.interval) data.pause().cycle()
    })
  }

  var old = $.fn.carousel

  $.fn.carousel             = Plugin
  $.fn.carousel.Constructor = Carousel


  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old
    return this
  }


  // CAROUSEL DATA-API
  // =================

  var clickHandler = function (e) {
    var href
    var $this   = $(this)
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) // strip for ie7
    if (!$target.hasClass('carousel')) return
    var options = $.extend({}, $target.data(), $this.data())
    var slideIndex = $this.attr('data-slide-to')
    if (slideIndex) options.interval = false

    Plugin.call($target, options)

    if (slideIndex) {
      $target.data('bs.carousel').to(slideIndex)
    }

    e.preventDefault()
  }

  $(document)
    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)
    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)

  $(window).on('load', function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this)
      Plugin.call($carousel, $carousel.data())
    })
  })

}(jQuery);

},{}],6:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: collapse.js v3.3.6
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {
    this.$element      = $(element)
    this.options       = $.extend({}, Collapse.DEFAULTS, options)
    this.$trigger      = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
                           '[data-toggle="collapse"][data-target="#' + element.id + '"]')
    this.transitioning = null

    if (this.options.parent) {
      this.$parent = this.getParent()
    } else {
      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
    }

    if (this.options.toggle) this.toggle()
  }

  Collapse.VERSION  = '3.3.6'

  Collapse.TRANSITION_DURATION = 350

  Collapse.DEFAULTS = {
    toggle: true
  }

  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width')
    return hasWidth ? 'width' : 'height'
  }

  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in')) return

    var activesData
    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')

    if (actives && actives.length) {
      activesData = actives.data('bs.collapse')
      if (activesData && activesData.transitioning) return
    }

    var startEvent = $.Event('show.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    if (actives && actives.length) {
      Plugin.call(actives, 'hide')
      activesData || actives.data('bs.collapse', null)
    }

    var dimension = this.dimension()

    this.$element
      .removeClass('collapse')
      .addClass('collapsing')[dimension](0)
      .attr('aria-expanded', true)

    this.$trigger
      .removeClass('collapsed')
      .attr('aria-expanded', true)

    this.transitioning = 1

    var complete = function () {
      this.$element
        .removeClass('collapsing')
        .addClass('collapse in')[dimension]('')
      this.transitioning = 0
      this.$element
        .trigger('shown.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    var scrollSize = $.camelCase(['scroll', dimension].join('-'))

    this.$element
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
  }

  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in')) return

    var startEvent = $.Event('hide.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    var dimension = this.dimension()

    this.$element[dimension](this.$element[dimension]())[0].offsetHeight

    this.$element
      .addClass('collapsing')
      .removeClass('collapse in')
      .attr('aria-expanded', false)

    this.$trigger
      .addClass('collapsed')
      .attr('aria-expanded', false)

    this.transitioning = 1

    var complete = function () {
      this.transitioning = 0
      this.$element
        .removeClass('collapsing')
        .addClass('collapse')
        .trigger('hidden.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    this.$element
      [dimension](0)
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
  }

  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }

  Collapse.prototype.getParent = function () {
    return $(this.options.parent)
      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
      .each($.proxy(function (i, element) {
        var $element = $(element)
        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
      }, this))
      .end()
  }

  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
    var isOpen = $element.hasClass('in')

    $element.attr('aria-expanded', isOpen)
    $trigger
      .toggleClass('collapsed', !isOpen)
      .attr('aria-expanded', isOpen)
  }

  function getTargetFromTrigger($trigger) {
    var href
    var target = $trigger.attr('data-target')
      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

    return $(target)
  }


  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.collapse')
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.collapse

  $.fn.collapse             = Plugin
  $.fn.collapse.Constructor = Collapse


  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }


  // COLLAPSE DATA-API
  // =================

  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
    var $this   = $(this)

    if (!$this.attr('data-target')) e.preventDefault()

    var $target = getTargetFromTrigger($this)
    var data    = $target.data('bs.collapse')
    var option  = data ? 'toggle' : $this.data()

    Plugin.call($target, option)
  })

}(jQuery);

},{}],7:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: dropdown.js v3.3.6
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-toggle="dropdown"]'
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }

  Dropdown.VERSION = '3.3.6'

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = selector && $(selector)

    return $parent && $parent.length ? $parent : $this.parent()
  }

  function clearMenus(e) {
    if (e && e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function () {
      var $this         = $(this)
      var $parent       = getParent($this)
      var relatedTarget = { relatedTarget: this }

      if (!$parent.hasClass('open')) return

      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return

      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))
    })
  }

  Dropdown.prototype.toggle = function (e) {
    var $this = $(this)

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    clearMenus()

    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $(document.createElement('div'))
          .addClass('dropdown-backdrop')
          .insertAfter($(this))
          .on('click', clearMenus)
      }

      var relatedTarget = { relatedTarget: this }
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this
        .trigger('focus')
        .attr('aria-expanded', 'true')

      $parent
        .toggleClass('open')
        .trigger($.Event('shown.bs.dropdown', relatedTarget))
    }

    return false
  }

  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

    var $this = $(this)

    e.preventDefault()
    e.stopPropagation()

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    if (!isActive && e.which != 27 || isActive && e.which == 27) {
      if (e.which == 27) $parent.find(toggle).trigger('focus')
      return $this.trigger('click')
    }

    var desc = ' li:not(.disabled):visible a'
    var $items = $parent.find('.dropdown-menu' + desc)

    if (!$items.length) return

    var index = $items.index(e.target)

    if (e.which == 38 && index > 0)                 index--         // up
    if (e.which == 40 && index < $items.length - 1) index++         // down
    if (!~index)                                    index = 0

    $items.eq(index).trigger('focus')
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.dropdown')

      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.dropdown

  $.fn.dropdown             = Plugin
  $.fn.dropdown.Constructor = Dropdown


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)

}(jQuery);

},{}],8:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: modal.js v3.3.6
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options             = options
    this.$body               = $(document.body)
    this.$element            = $(element)
    this.$dialog             = this.$element.find('.modal-dialog')
    this.$backdrop           = null
    this.isShown             = null
    this.originalBodyPad     = null
    this.scrollbarWidth      = 0
    this.ignoreBackdropClick = false

    if (this.options.remote) {
      this.$element
        .find('.modal-content')
        .load(this.options.remote, $.proxy(function () {
          this.$element.trigger('loaded.bs.modal')
        }, this))
    }
  }

  Modal.VERSION  = '3.3.6'

  Modal.TRANSITION_DURATION = 300
  Modal.BACKDROP_TRANSITION_DURATION = 150

  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
    var that = this
    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

    this.$element.trigger(e)

    if (this.isShown || e.isDefaultPrevented()) return

    this.isShown = true

    this.checkScrollbar()
    this.setScrollbar()
    this.$body.addClass('modal-open')

    this.escape()
    this.resize()

    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
      })
    })

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade')

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body) // don't move modals dom position
      }

      that.$element
        .show()
        .scrollTop(0)

      that.adjustDialog()

      if (transition) {
        that.$element[0].offsetWidth // force reflow
      }

      that.$element.addClass('in')

      that.enforceFocus()

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

      transition ?
        that.$dialog // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e)
          })
          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
        that.$element.trigger('focus').trigger(e)
    })
  }

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault()

    e = $.Event('hide.bs.modal')

    this.$element.trigger(e)

    if (!this.isShown || e.isDefaultPrevented()) return

    this.isShown = false

    this.escape()
    this.resize()

    $(document).off('focusin.bs.modal')

    this.$element
      .removeClass('in')
      .off('click.dismiss.bs.modal')
      .off('mouseup.dismiss.bs.modal')

    this.$dialog.off('mousedown.dismiss.bs.modal')

    $.support.transition && this.$element.hasClass('fade') ?
      this.$element
        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
      this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
    $(document)
      .off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
          this.$element.trigger('focus')
        }
      }, this))
  }

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal')
    }
  }

  Modal.prototype.resize = function () {
    if (this.isShown) {
      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
    } else {
      $(window).off('resize.bs.modal')
    }
  }

  Modal.prototype.hideModal = function () {
    var that = this
    this.$element.hide()
    this.backdrop(function () {
      that.$body.removeClass('modal-open')
      that.resetAdjustments()
      that.resetScrollbar()
      that.$element.trigger('hidden.bs.modal')
    })
  }

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove()
    this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
    var that = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate

      this.$backdrop = $(document.createElement('div'))
        .addClass('modal-backdrop ' + animate)
        .appendTo(this.$body)

      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false
          return
        }
        if (e.target !== e.currentTarget) return
        this.options.backdrop == 'static'
          ? this.$element[0].focus()
          : this.hide()
      }, this))

      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

      this.$backdrop.addClass('in')

      if (!callback) return

      doAnimate ?
        this.$backdrop
          .one('bsTransitionEnd', callback)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callback()

    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')

      var callbackRemove = function () {
        that.removeBackdrop()
        callback && callback()
      }
      $.support.transition && this.$element.hasClass('fade') ?
        this.$backdrop
          .one('bsTransitionEnd', callbackRemove)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callbackRemove()

    } else if (callback) {
      callback()
    }
  }

  // these following methods are used to handle overflowing modals

  Modal.prototype.handleUpdate = function () {
    this.adjustDialog()
  }

  Modal.prototype.adjustDialog = function () {
    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight

    this.$element.css({
      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
    })
  }

  Modal.prototype.resetAdjustments = function () {
    this.$element.css({
      paddingLeft: '',
      paddingRight: ''
    })
  }

  Modal.prototype.checkScrollbar = function () {
    var fullWindowWidth = window.innerWidth
    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8
      var documentElementRect = document.documentElement.getBoundingClientRect()
      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
    }
    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
    this.scrollbarWidth = this.measureScrollbar()
  }

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
    this.originalBodyPad = document.body.style.paddingRight || ''
    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
  }

  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', this.originalBodyPad)
  }

  Modal.prototype.measureScrollbar = function () { // thx walsh
    var scrollDiv = document.createElement('div')
    scrollDiv.className = 'modal-scrollbar-measure'
    this.$body.append(scrollDiv)
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
    this.$body[0].removeChild(scrollDiv)
    return scrollbarWidth
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }

  var old = $.fn.modal

  $.fn.modal             = Plugin
  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this   = $(this)
    var href    = $this.attr('href')
    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

    if ($this.is('a')) e.preventDefault()

    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus')
      })
    })
    Plugin.call($target, option, this)
  })

}(jQuery);

},{}],9:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: popover.js v3.3.6
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

  Popover.VERSION  = '3.3.6'

  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
    var $tip    = this.tip()
    var title   = this.getTitle()
    var content = this.getContent()

    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
    ](content)

    $tip.removeClass('fade top bottom left right in')

    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
    var $e = this.$element
    var o  = this.options

    return $e.attr('data-content')
      || (typeof o.content == 'function' ?
            o.content.call($e[0]) :
            o.content)
  }

  Popover.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.popover')
      var options = typeof option == 'object' && option

      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.popover

  $.fn.popover             = Plugin
  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(jQuery);

},{}],10:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: scrollspy.js v3.3.6
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // SCROLLSPY CLASS DEFINITION
  // ==========================

  function ScrollSpy(element, options) {
    this.$body          = $(document.body)
    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
    this.selector       = (this.options.target || '') + ' .nav li > a'
    this.offsets        = []
    this.targets        = []
    this.activeTarget   = null
    this.scrollHeight   = 0

    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))
    this.refresh()
    this.process()
  }

  ScrollSpy.VERSION  = '3.3.6'

  ScrollSpy.DEFAULTS = {
    offset: 10
  }

  ScrollSpy.prototype.getScrollHeight = function () {
    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
  }

  ScrollSpy.prototype.refresh = function () {
    var that          = this
    var offsetMethod  = 'offset'
    var offsetBase    = 0

    this.offsets      = []
    this.targets      = []
    this.scrollHeight = this.getScrollHeight()

    if (!$.isWindow(this.$scrollElement[0])) {
      offsetMethod = 'position'
      offsetBase   = this.$scrollElement.scrollTop()
    }

    this.$body
      .find(this.selector)
      .map(function () {
        var $el   = $(this)
        var href  = $el.data('target') || $el.attr('href')
        var $href = /^#./.test(href) && $(href)

        return ($href
          && $href.length
          && $href.is(':visible')
          && [[$href[offsetMethod]().top + offsetBase, href]]) || null
      })
      .sort(function (a, b) { return a[0] - b[0] })
      .each(function () {
        that.offsets.push(this[0])
        that.targets.push(this[1])
      })
  }

  ScrollSpy.prototype.process = function () {
    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
    var scrollHeight = this.getScrollHeight()
    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()
    var offsets      = this.offsets
    var targets      = this.targets
    var activeTarget = this.activeTarget
    var i

    if (this.scrollHeight != scrollHeight) {
      this.refresh()
    }

    if (scrollTop >= maxScroll) {
      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
    }

    if (activeTarget && scrollTop < offsets[0]) {
      this.activeTarget = null
      return this.clear()
    }

    for (i = offsets.length; i--;) {
      activeTarget != targets[i]
        && scrollTop >= offsets[i]
        && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])
        && this.activate(targets[i])
    }
  }

  ScrollSpy.prototype.activate = function (target) {
    this.activeTarget = target

    this.clear()

    var selector = this.selector +
      '[data-target="' + target + '"],' +
      this.selector + '[href="' + target + '"]'

    var active = $(selector)
      .parents('li')
      .addClass('active')

    if (active.parent('.dropdown-menu').length) {
      active = active
        .closest('li.dropdown')
        .addClass('active')
    }

    active.trigger('activate.bs.scrollspy')
  }

  ScrollSpy.prototype.clear = function () {
    $(this.selector)
      .parentsUntil(this.options.target, '.active')
      .removeClass('active')
  }


  // SCROLLSPY PLUGIN DEFINITION
  // ===========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.scrollspy')
      var options = typeof option == 'object' && option

      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.scrollspy

  $.fn.scrollspy             = Plugin
  $.fn.scrollspy.Constructor = ScrollSpy


  // SCROLLSPY NO CONFLICT
  // =====================

  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old
    return this
  }


  // SCROLLSPY DATA-API
  // ==================

  $(window).on('load.bs.scrollspy.data-api', function () {
    $('[data-spy="scroll"]').each(function () {
      var $spy = $(this)
      Plugin.call($spy, $spy.data())
    })
  })

}(jQuery);

},{}],11:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: tab.js v3.3.6
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TAB CLASS DEFINITION
  // ====================

  var Tab = function (element) {
    // jscs:disable requireDollarBeforejQueryAssignment
    this.element = $(element)
    // jscs:enable requireDollarBeforejQueryAssignment
  }

  Tab.VERSION = '3.3.6'

  Tab.TRANSITION_DURATION = 150

  Tab.prototype.show = function () {
    var $this    = this.element
    var $ul      = $this.closest('ul:not(.dropdown-menu)')
    var selector = $this.data('target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    if ($this.parent('li').hasClass('active')) return

    var $previous = $ul.find('.active:last a')
    var hideEvent = $.Event('hide.bs.tab', {
      relatedTarget: $this[0]
    })
    var showEvent = $.Event('show.bs.tab', {
      relatedTarget: $previous[0]
    })

    $previous.trigger(hideEvent)
    $this.trigger(showEvent)

    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return

    var $target = $(selector)

    this.activate($this.closest('li'), $ul)
    this.activate($target, $target.parent(), function () {
      $previous.trigger({
        type: 'hidden.bs.tab',
        relatedTarget: $this[0]
      })
      $this.trigger({
        type: 'shown.bs.tab',
        relatedTarget: $previous[0]
      })
    })
  }

  Tab.prototype.activate = function (element, container, callback) {
    var $active    = container.find('> .active')
    var transition = callback
      && $.support.transition
      && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)

    function next() {
      $active
        .removeClass('active')
        .find('> .dropdown-menu > .active')
          .removeClass('active')
        .end()
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', false)

      element
        .addClass('active')
        .find('[data-toggle="tab"]')
          .attr('aria-expanded', true)

      if (transition) {
        element[0].offsetWidth // reflow for transition
        element.addClass('in')
      } else {
        element.removeClass('fade')
      }

      if (element.parent('.dropdown-menu').length) {
        element
          .closest('li.dropdown')
            .addClass('active')
          .end()
          .find('[data-toggle="tab"]')
            .attr('aria-expanded', true)
      }

      callback && callback()
    }

    $active.length && transition ?
      $active
        .one('bsTransitionEnd', next)
        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :
      next()

    $active.removeClass('in')
  }


  // TAB PLUGIN DEFINITION
  // =====================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.tab')

      if (!data) $this.data('bs.tab', (data = new Tab(this)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tab

  $.fn.tab             = Plugin
  $.fn.tab.Constructor = Tab


  // TAB NO CONFLICT
  // ===============

  $.fn.tab.noConflict = function () {
    $.fn.tab = old
    return this
  }


  // TAB DATA-API
  // ============

  var clickHandler = function (e) {
    e.preventDefault()
    Plugin.call($(this), 'show')
  }

  $(document)
    .on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler)
    .on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler)

}(jQuery);

},{}],12:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: tooltip.js v3.3.6
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
    this.type       = null
    this.options    = null
    this.enabled    = null
    this.timeout    = null
    this.hoverState = null
    this.$element   = null
    this.inState    = null

    this.init('tooltip', element, options)
  }

  Tooltip.VERSION  = '3.3.6'

  Tooltip.TRANSITION_DURATION = 150

  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  }

  Tooltip.prototype.init = function (type, element, options) {
    this.enabled   = true
    this.type      = type
    this.$element  = $(element)
    this.options   = this.getOptions(options)
    this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))
    this.inState   = { click: false, hover: false, focus: false }

    if (this.$element[0] instanceof document.constructor && !this.options.selector) {
      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')
    }

    var triggers = this.options.trigger.split(' ')

    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]

      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }

    this.options.selector ?
      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
      this.fixTitle()
  }

  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS
  }

  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      }
    }

    return options
  }

  Tooltip.prototype.getDelegateOptions = function () {
    var options  = {}
    var defaults = this.getDefaults()

    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value) options[key] = value
    })

    return options
  }

  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    if (obj instanceof $.Event) {
      self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true
    }

    if (self.tip().hasClass('in') || self.hoverState == 'in') {
      self.hoverState = 'in'
      return
    }

    clearTimeout(self.timeout)

    self.hoverState = 'in'

    if (!self.options.delay || !self.options.delay.show) return self.show()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }

  Tooltip.prototype.isInStateTrue = function () {
    for (var key in this.inState) {
      if (this.inState[key]) return true
    }

    return false
  }

  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    if (obj instanceof $.Event) {
      self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false
    }

    if (self.isInStateTrue()) return

    clearTimeout(self.timeout)

    self.hoverState = 'out'

    if (!self.options.delay || !self.options.delay.hide) return self.hide()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }

  Tooltip.prototype.show = function () {
    var e = $.Event('show.bs.' + this.type)

    if (this.hasContent() && this.enabled) {
      this.$element.trigger(e)

      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
      if (e.isDefaultPrevented() || !inDom) return
      var that = this

      var $tip = this.tip()

      var tipId = this.getUID(this.type)

      this.setContent()
      $tip.attr('id', tipId)
      this.$element.attr('aria-describedby', tipId)

      if (this.options.animation) $tip.addClass('fade')

      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement

      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

      $tip
        .detach()
        .css({ top: 0, left: 0, display: 'block' })
        .addClass(placement)
        .data('bs.' + this.type, this)

      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
      this.$element.trigger('inserted.bs.' + this.type)

      var pos          = this.getPosition()
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight

      if (autoPlace) {
        var orgPlacement = placement
        var viewportDim = this.getPosition(this.$viewport)

        placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'    :
                    placement == 'top'    && pos.top    - actualHeight < viewportDim.top    ? 'bottom' :
                    placement == 'right'  && pos.right  + actualWidth  > viewportDim.width  ? 'left'   :
                    placement == 'left'   && pos.left   - actualWidth  < viewportDim.left   ? 'right'  :
                    placement

        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }

      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

      this.applyPlacement(calculatedOffset, placement)

      var complete = function () {
        var prevHoverState = that.hoverState
        that.$element.trigger('shown.bs.' + that.type)
        that.hoverState = null

        if (prevHoverState == 'out') that.leave(that)
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        $tip
          .one('bsTransitionEnd', complete)
          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
        complete()
    }
  }

  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var $tip   = this.tip()
    var width  = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight

    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)

    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))  marginTop  = 0
    if (isNaN(marginLeft)) marginLeft = 0

    offset.top  += marginTop
    offset.left += marginLeft

    // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0
    $.offset.setOffset($tip[0], $.extend({
      using: function (props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        })
      }
    }, offset), 0)

    $tip.addClass('in')

    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth  = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight

    if (placement == 'top' && actualHeight != height) {
      offset.top = offset.top + height - actualHeight
    }

    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

    if (delta.left) offset.left += delta.left
    else offset.top += delta.top

    var isVertical          = /top|bottom/.test(placement)
    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

    $tip.offset(offset)
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
  }

  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
    this.arrow()
      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
      .css(isVertical ? 'top' : 'left', '')
  }

  Tooltip.prototype.setContent = function () {
    var $tip  = this.tip()
    var title = this.getTitle()

    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }

  Tooltip.prototype.hide = function (callback) {
    var that = this
    var $tip = $(this.$tip)
    var e    = $.Event('hide.bs.' + this.type)

    function complete() {
      if (that.hoverState != 'in') $tip.detach()
      that.$element
        .removeAttr('aria-describedby')
        .trigger('hidden.bs.' + that.type)
      callback && callback()
    }

    this.$element.trigger(e)

    if (e.isDefaultPrevented()) return

    $tip.removeClass('in')

    $.support.transition && $tip.hasClass('fade') ?
      $tip
        .one('bsTransitionEnd', complete)
        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
      complete()

    this.hoverState = null

    return this
  }

  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element
    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }

  Tooltip.prototype.hasContent = function () {
    return this.getTitle()
  }

  Tooltip.prototype.getPosition = function ($element) {
    $element   = $element || this.$element

    var el     = $element[0]
    var isBody = el.tagName == 'BODY'

    var elRect    = el.getBoundingClientRect()
    if (elRect.width == null) {
      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
    }
    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()
    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

    return $.extend({}, elRect, scroll, outerDims, elOffset)
  }

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :
           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :
           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }

  }

  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
    var delta = { top: 0, left: 0 }
    if (!this.$viewport) return delta

    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
    var viewportDimensions = this.getPosition(this.$viewport)

    if (/right|left/.test(placement)) {
      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
      if (topEdgeOffset < viewportDimensions.top) { // top overflow
        delta.top = viewportDimensions.top - topEdgeOffset
      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
      }
    } else {
      var leftEdgeOffset  = pos.left - viewportPadding
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
        delta.left = viewportDimensions.left - leftEdgeOffset
      } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
      }
    }

    return delta
  }

  Tooltip.prototype.getTitle = function () {
    var title
    var $e = this.$element
    var o  = this.options

    title = $e.attr('data-original-title')
      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

    return title
  }

  Tooltip.prototype.getUID = function (prefix) {
    do prefix += ~~(Math.random() * 1000000)
    while (document.getElementById(prefix))
    return prefix
  }

  Tooltip.prototype.tip = function () {
    if (!this.$tip) {
      this.$tip = $(this.options.template)
      if (this.$tip.length != 1) {
        throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')
      }
    }
    return this.$tip
  }

  Tooltip.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
  }

  Tooltip.prototype.enable = function () {
    this.enabled = true
  }

  Tooltip.prototype.disable = function () {
    this.enabled = false
  }

  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled
  }

  Tooltip.prototype.toggle = function (e) {
    var self = this
    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type)
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
        $(e.currentTarget).data('bs.' + this.type, self)
      }
    }

    if (e) {
      self.inState.click = !self.inState.click
      if (self.isInStateTrue()) self.enter(self)
      else self.leave(self)
    } else {
      self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
    }
  }

  Tooltip.prototype.destroy = function () {
    var that = this
    clearTimeout(this.timeout)
    this.hide(function () {
      that.$element.off('.' + that.type).removeData('bs.' + that.type)
      if (that.$tip) {
        that.$tip.detach()
      }
      that.$tip = null
      that.$arrow = null
      that.$viewport = null
    })
  }


  // TOOLTIP PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.tooltip')
      var options = typeof option == 'object' && option

      if (!data && /destroy|hide/.test(option)) return
      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tooltip

  $.fn.tooltip             = Plugin
  $.fn.tooltip.Constructor = Tooltip


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(jQuery);

},{}],13:[function(require,module,exports){
/* ========================================================================
 * Bootstrap: transition.js v3.3.6
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()

    if (!$.support.transition) return

    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })

}(jQuery);

},{}],14:[function(require,module,exports){
(function (global){
var createjs = (this.createjs = (this.createjs || {}));
/*!
* EaselJS
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2010 gskinner.com, inc.
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/


//##############################################################################
// extend.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Sets up the prototype chain and constructor property for a new class.
 *
 * This should be called right after creating the class constructor.
 *
 * 	function MySubClass() {}
 * 	createjs.extend(MySubClass, MySuperClass);
 * 	ClassB.prototype.doSomething = function() { }
 *
 * 	var foo = new MySubClass();
 * 	console.log(foo instanceof MySuperClass); // true
 * 	console.log(foo.prototype.constructor === MySubClass); // true
 *
 * @method extend
 * @param {Function} subclass The subclass.
 * @param {Function} superclass The superclass to extend.
 * @return {Function} Returns the subclass's new prototype.
 */
createjs.extend = function(subclass, superclass) {
	"use strict";

	function o() { this.constructor = subclass; }
	o.prototype = superclass.prototype;
	return (subclass.prototype = new o());
};

//##############################################################################
// promote.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.
 * It is recommended to use the super class's name as the prefix.
 * An alias to the super class's constructor is always added in the format `prefix_constructor`.
 * This allows the subclass to call super class methods without using `function.call`, providing better performance.
 *
 * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, "MySuperClass")`
 * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the
 * prototype of `MySubClass` as `MySuperClass_draw`.
 *
 * This should be called after the class's prototype is fully defined.
 *
 * 	function ClassA(name) {
 * 		this.name = name;
 * 	}
 * 	ClassA.prototype.greet = function() {
 * 		return "Hello "+this.name;
 * 	}
 *
 * 	function ClassB(name, punctuation) {
 * 		this.ClassA_constructor(name);
 * 		this.punctuation = punctuation;
 * 	}
 * 	createjs.extend(ClassB, ClassA);
 * 	ClassB.prototype.greet = function() {
 * 		return this.ClassA_greet()+this.punctuation;
 * 	}
 * 	createjs.promote(ClassB, "ClassA");
 *
 * 	var foo = new ClassB("World", "!?!");
 * 	console.log(foo.greet()); // Hello World!?!
 *
 * @method promote
 * @param {Function} subclass The class to promote super class methods on.
 * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.
 * @return {Function} Returns the subclass.
 */
createjs.promote = function(subclass, prefix) {
	"use strict";

	var subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;
	if (supP) {
		subP[(prefix+="_") + "constructor"] = supP.constructor; // constructor is not always innumerable
		for (var n in supP) {
			if (subP.hasOwnProperty(n) && (typeof supP[n] == "function")) { subP[prefix + n] = supP[n]; }
		}
	}
	return subclass;
};

//##############################################################################
// indexOf.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of
 * that value.  Returns -1 if value is not found.
 *
 *      var i = createjs.indexOf(myArray, myElementToFind);
 *
 * @method indexOf
 * @param {Array} array Array to search for searchElement
 * @param searchElement Element to find in array.
 * @return {Number} The first index of searchElement in array.
 */
createjs.indexOf = function (array, searchElement){
	"use strict";

	for (var i = 0,l=array.length; i < l; i++) {
		if (searchElement === array[i]) {
			return i;
		}
	}
	return -1;
};

//##############################################################################
// Event.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

// constructor:
	/**
	 * Contains properties and methods shared by all events for use with
	 * {{#crossLink "EventDispatcher"}}{{/crossLink}}.
	 * 
	 * Note that Event objects are often reused, so you should never
	 * rely on an event object's state outside of the call stack it was received in.
	 * @class Event
	 * @param {String} type The event type.
	 * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
	 * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
	 * @constructor
	 **/
	function Event(type, bubbles, cancelable) {
		
	
	// public properties:
		/**
		 * The type of event.
		 * @property type
		 * @type String
		 **/
		this.type = type;
	
		/**
		 * The object that generated an event.
		 * @property target
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.target = null;
	
		/**
		 * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will
		 * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event
		 * is generated from childObj, then a listener on parentObj would receive the event with
		 * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).
		 * @property currentTarget
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.currentTarget = null;
	
		/**
		 * For bubbling events, this indicates the current event phase:<OL>
		 * 	<LI> capture phase: starting from the top parent to the target</LI>
		 * 	<LI> at target phase: currently being dispatched from the target</LI>
		 * 	<LI> bubbling phase: from the target to the top parent</LI>
		 * </OL>
		 * @property eventPhase
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.eventPhase = 0;
	
		/**
		 * Indicates whether the event will bubble through the display list.
		 * @property bubbles
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.bubbles = !!bubbles;
	
		/**
		 * Indicates whether the default behaviour of this event can be cancelled via
		 * {{#crossLink "Event/preventDefault"}}{{/crossLink}}. This is set via the Event constructor.
		 * @property cancelable
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.cancelable = !!cancelable;
	
		/**
		 * The epoch time at which this event was created.
		 * @property timeStamp
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.timeStamp = (new Date()).getTime();
	
		/**
		 * Indicates if {{#crossLink "Event/preventDefault"}}{{/crossLink}} has been called
		 * on this event.
		 * @property defaultPrevented
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.defaultPrevented = false;
	
		/**
		 * Indicates if {{#crossLink "Event/stopPropagation"}}{{/crossLink}} or
		 * {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called on this event.
		 * @property propagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.propagationStopped = false;
	
		/**
		 * Indicates if {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called
		 * on this event.
		 * @property immediatePropagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.immediatePropagationStopped = false;
		
		/**
		 * Indicates if {{#crossLink "Event/remove"}}{{/crossLink}} has been called on this event.
		 * @property removed
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.removed = false;
	}
	var p = Event.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.

// public methods:
	/**
	 * Sets {{#crossLink "Event/defaultPrevented"}}{{/crossLink}} to true if the event is cancelable.
	 * Mirrors the DOM level 2 event standard. In general, cancelable events that have `preventDefault()` called will
	 * cancel the default behaviour associated with the event.
	 * @method preventDefault
	 **/
	p.preventDefault = function() {
		this.defaultPrevented = this.cancelable&&true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopPropagation
	 **/
	p.stopPropagation = function() {
		this.propagationStopped = true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} and
	 * {{#crossLink "Event/immediatePropagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopImmediatePropagation
	 **/
	p.stopImmediatePropagation = function() {
		this.immediatePropagationStopped = this.propagationStopped = true;
	};
	
	/**
	 * Causes the active listener to be removed via removeEventListener();
	 * 
	 * 		myBtn.addEventListener("click", function(evt) {
	 * 			// do stuff...
	 * 			evt.remove(); // removes this listener.
	 * 		});
	 * 
	 * @method remove
	 **/
	p.remove = function() {
		this.removed = true;
	};
	
	/**
	 * Returns a clone of the Event instance.
	 * @method clone
	 * @return {Event} a clone of the Event instance.
	 **/
	p.clone = function() {
		return new Event(this.type, this.bubbles, this.cancelable);
	};
	
	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the instance.
	 * @return {Event} Returns the instance the method is called on (useful for chaining calls.)
	 * @chainable
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Event (type="+this.type+")]";
	};

	createjs.Event = Event;
}());

//##############################################################################
// EventDispatcher.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * EventDispatcher provides methods for managing queues of event listeners and dispatching events.
	 *
	 * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the
	 * EventDispatcher {{#crossLink "EventDispatcher/initialize"}}{{/crossLink}} method.
	 * 
	 * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the
	 * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports
	 * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.
	 * 
	 * EventDispatcher also exposes a {{#crossLink "EventDispatcher/on"}}{{/crossLink}} method, which makes it easier
	 * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The 
	 * {{#crossLink "EventDispatcher/off"}}{{/crossLink}} method is merely an alias to
	 * {{#crossLink "EventDispatcher/removeEventListener"}}{{/crossLink}}.
	 * 
	 * Another addition to the DOM Level 2 model is the {{#crossLink "EventDispatcher/removeAllEventListeners"}}{{/crossLink}}
	 * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also 
	 * includes a {{#crossLink "Event/remove"}}{{/crossLink}} method which removes the active listener.
	 *
	 * <h4>Example</h4>
	 * Add EventDispatcher capabilities to the "MyClass" class.
	 *
	 *      EventDispatcher.initialize(MyClass.prototype);
	 *
	 * Add an event (see {{#crossLink "EventDispatcher/addEventListener"}}{{/crossLink}}).
	 *
	 *      instance.addEventListener("eventName", handlerMethod);
	 *      function handlerMethod(event) {
	 *          console.log(event.target + " Was Clicked");
	 *      }
	 *
	 * <b>Maintaining proper scope</b><br />
	 * Scope (ie. "this") can be be a challenge with events. Using the {{#crossLink "EventDispatcher/on"}}{{/crossLink}}
	 * method to subscribe to events simplifies this.
	 *
	 *      instance.addEventListener("click", function(event) {
	 *          console.log(instance == this); // false, scope is ambiguous.
	 *      });
	 *      
	 *      instance.on("click", function(event) {
	 *          console.log(instance == this); // true, "on" uses dispatcher scope by default.
	 *      });
	 * 
	 * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage scope.
	 *      
	 *
	 * @class EventDispatcher
	 * @constructor
	 **/
	function EventDispatcher() {
	
	
	// private properties:
		/**
		 * @protected
		 * @property _listeners
		 * @type Object
		 **/
		this._listeners = null;
		
		/**
		 * @protected
		 * @property _captureListeners
		 * @type Object
		 **/
		this._captureListeners = null;
	}
	var p = EventDispatcher.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// static public methods:
	/**
	 * Static initializer to mix EventDispatcher methods into a target object or prototype.
	 * 
	 * 		EventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class
	 * 		EventDispatcher.initialize(myObject); // add to a specific instance
	 * 
	 * @method initialize
	 * @static
	 * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a
	 * prototype.
	 **/
	EventDispatcher.initialize = function(target) {
		target.addEventListener = p.addEventListener;
		target.on = p.on;
		target.removeEventListener = target.off =  p.removeEventListener;
		target.removeAllEventListeners = p.removeAllEventListeners;
		target.hasEventListener = p.hasEventListener;
		target.dispatchEvent = p.dispatchEvent;
		target._dispatchEvent = p._dispatchEvent;
		target.willTrigger = p.willTrigger;
	};
	

// public methods:
	/**
	 * Adds the specified event listener. Note that adding multiple listeners to the same function will result in
	 * multiple callbacks getting fired.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.addEventListener("click", handleClick);
	 *      function handleClick(event) {
	 *         // Click happened.
	 *      }
	 *
	 * @method addEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function | Object} Returns the listener for chaining or assignment.
	 **/
	p.addEventListener = function(type, listener, useCapture) {
		var listeners;
		if (useCapture) {
			listeners = this._captureListeners = this._captureListeners||{};
		} else {
			listeners = this._listeners = this._listeners||{};
		}
		var arr = listeners[type];
		if (arr) { this.removeEventListener(type, listener, useCapture); }
		arr = listeners[type]; // remove may have deleted the array
		if (!arr) { listeners[type] = [listener];  }
		else { arr.push(listener); }
		return listener;
	};
	
	/**
	 * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener
	 * only run once, associate arbitrary data with the listener, and remove the listener.
	 * 
	 * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.
	 * The wrapper function is returned for use with `removeEventListener` (or `off`).
	 * 
	 * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener, or use
	 * {{#crossLink "Event/remove"}}{{/crossLink}}. Likewise, each time you call `on` a NEW wrapper function is subscribed, so multiple calls
	 * to `on` with the same params will create multiple listeners.
	 * 
	 * <h4>Example</h4>
	 * 
	 * 		var listener = myBtn.on("click", handleClick, null, false, {count:3});
	 * 		function handleClick(evt, data) {
	 * 			data.count -= 1;
	 * 			console.log(this == myBtn); // true - scope defaults to the dispatcher
	 * 			if (data.count == 0) {
	 * 				alert("clicked 3 times!");
	 * 				myBtn.off("click", listener);
	 * 				// alternately: evt.remove();
	 * 			}
	 * 		}
	 * 
	 * @method on
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).
	 * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.
	 * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.
	 * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.
	 **/
	p.on = function(type, listener, scope, once, data, useCapture) {
		if (listener.handleEvent) {
			scope = scope||listener;
			listener = listener.handleEvent;
		}
		scope = scope||this;
		return this.addEventListener(type, function(evt) {
				listener.call(scope, evt, data);
				once&&evt.remove();
			}, useCapture);
	};

	/**
	 * Removes the specified event listener.
	 *
	 * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy
	 * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or
	 * closure will not work.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.removeEventListener("click", handleClick);
	 *
	 * @method removeEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.removeEventListener = function(type, listener, useCapture) {
		var listeners = useCapture ? this._captureListeners : this._listeners;
		if (!listeners) { return; }
		var arr = listeners[type];
		if (!arr) { return; }
		for (var i=0,l=arr.length; i<l; i++) {
			if (arr[i] == listener) {
				if (l==1) { delete(listeners[type]); } // allows for faster checks.
				else { arr.splice(i,1); }
				break;
			}
		}
	};
	
	/**
	 * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the
	 * .on method.
	 * 
	 * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener. See 
	 * {{#crossLink "EventDispatcher/on"}}{{/crossLink}} for an example.
	 *
	 * @method off
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.off = p.removeEventListener;

	/**
	 * Removes all listeners for the specified type, or all listeners of all types.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Remove all listeners
	 *      displayObject.removeAllEventListeners();
	 *
	 *      // Remove all click listeners
	 *      displayObject.removeAllEventListeners("click");
	 *
	 * @method removeAllEventListeners
	 * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.
	 **/
	p.removeAllEventListeners = function(type) {
		if (!type) { this._listeners = this._captureListeners = null; }
		else {
			if (this._listeners) { delete(this._listeners[type]); }
			if (this._captureListeners) { delete(this._captureListeners[type]); }
		}
	};

	/**
	 * Dispatches the specified event to all listeners.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Use a string event
	 *      this.dispatchEvent("complete");
	 *
	 *      // Use an Event instance
	 *      var event = new createjs.Event("progress");
	 *      this.dispatchEvent(event);
	 *
	 * @method dispatchEvent
	 * @param {Object | String | Event} eventObj An object with a "type" property, or a string type.
	 * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,
	 * dispatchEvent will construct an Event instance if necessary with the specified type. This latter approach can
	 * be used to avoid event object instantiation for non-bubbling events that may not have any listeners.
	 * @param {Boolean} [bubbles] Specifies the `bubbles` value when a string was passed to eventObj.
	 * @param {Boolean} [cancelable] Specifies the `cancelable` value when a string was passed to eventObj.
	 * @return {Boolean} Returns false if `preventDefault()` was called on a cancelable event, true otherwise.
	 **/
	p.dispatchEvent = function(eventObj, bubbles, cancelable) {
		if (typeof eventObj == "string") {
			// skip everything if there's no listeners and it doesn't bubble:
			var listeners = this._listeners;
			if (!bubbles && (!listeners || !listeners[eventObj])) { return true; }
			eventObj = new createjs.Event(eventObj, bubbles, cancelable);
		} else if (eventObj.target && eventObj.clone) {
			// redispatching an active event object, so clone it:
			eventObj = eventObj.clone();
		}
		
		// TODO: it would be nice to eliminate this. Maybe in favour of evtObj instanceof Event? Or !!evtObj.createEvent
		try { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events

		if (!eventObj.bubbles || !this.parent) {
			this._dispatchEvent(eventObj, 2);
		} else {
			var top=this, list=[top];
			while (top.parent) { list.push(top = top.parent); }
			var i, l=list.length;

			// capture & atTarget
			for (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {
				list[i]._dispatchEvent(eventObj, 1+(i==0));
			}
			// bubbling
			for (i=1; i<l && !eventObj.propagationStopped; i++) {
				list[i]._dispatchEvent(eventObj, 3);
			}
		}
		return !eventObj.defaultPrevented;
	};

	/**
	 * Indicates whether there is at least one listener for the specified event type.
	 * @method hasEventListener
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns true if there is at least one listener for the specified event.
	 **/
	p.hasEventListener = function(type) {
		var listeners = this._listeners, captureListeners = this._captureListeners;
		return !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));
	};
	
	/**
	 * Indicates whether there is at least one listener for the specified event type on this object or any of its
	 * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the
	 * specified type is dispatched from this object, it will trigger at least one listener.
	 * 
	 * This is similar to {{#crossLink "EventDispatcher/hasEventListener"}}{{/crossLink}}, but it searches the entire
	 * event flow for a listener, not just this object.
	 * @method willTrigger
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns `true` if there is at least one listener for the specified event.
	 **/
	p.willTrigger = function(type) {
		var o = this;
		while (o) {
			if (o.hasEventListener(type)) { return true; }
			o = o.parent;
		}
		return false;
	};

	/**
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[EventDispatcher]";
	};


// private methods:
	/**
	 * @method _dispatchEvent
	 * @param {Object | String | Event} eventObj
	 * @param {Object} eventPhase
	 * @protected
	 **/
	p._dispatchEvent = function(eventObj, eventPhase) {
		var l, listeners = (eventPhase==1) ? this._captureListeners : this._listeners;
		if (eventObj && listeners) {
			var arr = listeners[eventObj.type];
			if (!arr||!(l=arr.length)) { return; }
			try { eventObj.currentTarget = this; } catch (e) {}
			try { eventObj.eventPhase = eventPhase; } catch (e) {}
			eventObj.removed = false;
			
			arr = arr.slice(); // to avoid issues with items being removed or added during the dispatch
			for (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {
				var o = arr[i];
				if (o.handleEvent) { o.handleEvent(eventObj); }
				else { o(eventObj); }
				if (eventObj.removed) {
					this.off(eventObj.type, o, eventPhase==1);
					eventObj.removed = false;
				}
			}
		}
	};


	createjs.EventDispatcher = EventDispatcher;
}());

//##############################################################################
// Ticker.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * The Ticker provides a centralized tick or heartbeat broadcast at a set interval. Listeners can subscribe to the tick
	 * event to be notified when a set time interval has elapsed.
	 *
	 * Note that the interval that the tick event is called is a target interval, and may be broadcast at a slower interval
	 * when under high CPU load. The Ticker class uses a static interface (ex. `Ticker.framerate = 30;`) and
	 * can not be instantiated.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.Ticker.addEventListener("tick", handleTick);
	 *      function handleTick(event) {
	 *          // Actions carried out each tick (aka frame)
	 *          if (!event.paused) {
	 *              // Actions carried out when the Ticker is not paused.
	 *          }
	 *      }
	 *
	 * @class Ticker
	 * @uses EventDispatcher
	 * @static
	 **/
	function Ticker() {
		throw "Ticker cannot be instantiated.";
	}


// constants:
	/**
	 * In this mode, Ticker uses the requestAnimationFrame API, but attempts to synch the ticks to target framerate. It
	 * uses a simple heuristic that compares the time of the RAF return to the target time for the current frame and
	 * dispatches the tick when the time is within a certain threshold.
	 *
	 * This mode has a higher variance for time between frames than {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}},
	 * but does not require that content be time based as with {{#crossLink "Ticker/RAF:property"}}{{/crossLink}} while
	 * gaining the benefits of that API (screen synch, background throttling).
	 *
	 * Variance is usually lowest for framerates that are a divisor of the RAF frequency. This is usually 60, so
	 * framerates of 10, 12, 15, 20, and 30 work well.
	 *
	 * Falls back to {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}} if the requestAnimationFrame API is not
	 * supported.
	 * @property RAF_SYNCHED
	 * @static
	 * @type {String}
	 * @default "synched"
	 * @readonly
	 **/
	Ticker.RAF_SYNCHED = "synched";

	/**
	 * In this mode, Ticker passes through the requestAnimationFrame heartbeat, ignoring the target framerate completely.
	 * Because requestAnimationFrame frequency is not deterministic, any content using this mode should be time based.
	 * You can leverage {{#crossLink "Ticker/getTime"}}{{/crossLink}} and the {{#crossLink "Ticker/tick:event"}}{{/crossLink}}
	 * event object's "delta" properties to make this easier.
	 *
	 * Falls back on {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}} if the requestAnimationFrame API is not
	 * supported.
	 * @property RAF
	 * @static
	 * @type {String}
	 * @default "raf"
	 * @readonly
	 **/
	Ticker.RAF = "raf";

	/**
	 * In this mode, Ticker uses the setTimeout API. This provides predictable, adaptive frame timing, but does not
	 * provide the benefits of requestAnimationFrame (screen synch, background throttling).
	 * @property TIMEOUT
	 * @static
	 * @type {String}
	 * @default "timeout"
	 * @readonly
	 **/
	Ticker.TIMEOUT = "timeout";


// static events:
	/**
	 * Dispatched each tick. The event will be dispatched to each listener even when the Ticker has been paused using
	 * {{#crossLink "Ticker/setPaused"}}{{/crossLink}}.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.Ticker.addEventListener("tick", handleTick);
	 *      function handleTick(event) {
	 *          console.log("Paused:", event.paused, event.delta);
	 *      }
	 *
	 * @event tick
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Boolean} paused Indicates whether the ticker is currently paused.
	 * @param {Number} delta The time elapsed in ms since the last tick.
	 * @param {Number} time The total time in ms since Ticker was initialized.
	 * @param {Number} runTime The total time in ms that Ticker was not paused since it was initialized. For example,
	 * 	you could determine the amount of time that the Ticker has been paused since initialization with `time-runTime`.
	 * @since 0.6.0
	 */


// public static properties:
	/**
	 * Deprecated in favour of {{#crossLink "Ticker/timingMode"}}{{/crossLink}}, and will be removed in a future version. If true, timingMode will
	 * use {{#crossLink "Ticker/RAF_SYNCHED"}}{{/crossLink}} by default.
	 * @deprecated Deprecated in favour of {{#crossLink "Ticker/timingMode"}}{{/crossLink}}.
	 * @property useRAF
	 * @static
	 * @type {Boolean}
	 * @default false
	 **/
	Ticker.useRAF = false;

	/**
	 * Specifies the timing api (setTimeout or requestAnimationFrame) and mode to use. See
	 * {{#crossLink "Ticker/TIMEOUT"}}{{/crossLink}}, {{#crossLink "Ticker/RAF"}}{{/crossLink}}, and
	 * {{#crossLink "Ticker/RAF_SYNCHED"}}{{/crossLink}} for mode details.
	 * @property timingMode
	 * @static
	 * @type {String}
	 * @default Ticker.TIMEOUT
	 **/
	Ticker.timingMode = null;

	/**
	 * Specifies a maximum value for the delta property in the tick event object. This is useful when building time
	 * based animations and systems to prevent issues caused by large time gaps caused by background tabs, system sleep,
	 * alert dialogs, or other blocking routines. Double the expected frame duration is often an effective value
	 * (ex. maxDelta=50 when running at 40fps).
	 * 
	 * This does not impact any other values (ex. time, runTime, etc), so you may experience issues if you enable maxDelta
	 * when using both delta and other values.
	 * 
	 * If 0, there is no maximum.
	 * @property maxDelta
	 * @static
	 * @type {number}
	 * @default 0
	 */
	Ticker.maxDelta = 0;
	
	/**
	 * When the ticker is paused, all listeners will still receive a tick event, but the <code>paused</code> property
	 * of the event will be `true`. Also, while paused the `runTime` will not increase. See {{#crossLink "Ticker/tick:event"}}{{/crossLink}},
	 * {{#crossLink "Ticker/getTime"}}{{/crossLink}}, and {{#crossLink "Ticker/getEventTime"}}{{/crossLink}} for more
	 * info.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.Ticker.addEventListener("tick", handleTick);
	 *      createjs.Ticker.paused = true;
	 *      function handleTick(event) {
	 *          console.log(event.paused,
	 *          	createjs.Ticker.getTime(false),
	 *          	createjs.Ticker.getTime(true));
	 *      }
	 *
	 * @property paused
	 * @static
	 * @type {Boolean}
	 * @default false
	 **/
	Ticker.paused = false;


// mix-ins:
	// EventDispatcher methods:
	Ticker.removeEventListener = null;
	Ticker.removeAllEventListeners = null;
	Ticker.dispatchEvent = null;
	Ticker.hasEventListener = null;
	Ticker._listeners = null;
	createjs.EventDispatcher.initialize(Ticker); // inject EventDispatcher methods.
	Ticker._addEventListener = Ticker.addEventListener;
	Ticker.addEventListener = function() {
		!Ticker._inited&&Ticker.init();
		return Ticker._addEventListener.apply(Ticker, arguments);
	};


// private static properties:
	/**
	 * @property _inited
	 * @static
	 * @type {Boolean}
	 * @protected
	 **/
	Ticker._inited = false;

	/**
	 * @property _startTime
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._startTime = 0;

	/**
	 * @property _pausedTime
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._pausedTime=0;

	/**
	 * The number of ticks that have passed
	 * @property _ticks
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._ticks = 0;

	/**
	 * The number of ticks that have passed while Ticker has been paused
	 * @property _pausedTicks
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._pausedTicks = 0;

	/**
	 * @property _interval
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._interval = 50;

	/**
	 * @property _lastTime
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._lastTime = 0;

	/**
	 * @property _times
	 * @static
	 * @type {Array}
	 * @protected
	 **/
	Ticker._times = null;

	/**
	 * @property _tickTimes
	 * @static
	 * @type {Array}
	 * @protected
	 **/
	Ticker._tickTimes = null;

	/**
	 * Stores the timeout or requestAnimationFrame id.
	 * @property _timerId
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._timerId = null;
	
	/**
	 * True if currently using requestAnimationFrame, false if using setTimeout. This may be different than timingMode
	 * if that property changed and a tick hasn't fired.
	 * @property _raf
	 * @static
	 * @type {Boolean}
	 * @protected
	 **/
	Ticker._raf = true;
	

// static getter / setters:
	/**
	 * Use the {{#crossLink "Ticker/interval:property"}}{{/crossLink}} property instead.
	 * @method setInterval
	 * @static
	 * @param {Number} interval
	 * @deprecated
	 **/
	Ticker.setInterval = function(interval) {
		Ticker._interval = interval;
		if (!Ticker._inited) { return; }
		Ticker._setupTick();
	};

	/**
	 * Use the {{#crossLink "Ticker/interval:property"}}{{/crossLink}} property instead.
	 * @method getInterval
	 * @static
	 * @return {Number}
	 * @deprecated
	 **/
	Ticker.getInterval = function() {
		return Ticker._interval;
	};

	/**
	 * Use the {{#crossLink "Ticker/framerate:property"}}{{/crossLink}} property instead.
	 * @method setFPS
	 * @static
	 * @param {Number} value
	 * @deprecated
	 **/
	Ticker.setFPS = function(value) {
		Ticker.setInterval(1000/value);
	};

	/**
	 * Use the {{#crossLink "Ticker/framerate:property"}}{{/crossLink}} property instead.
	 * @method getFPS
	 * @static
	 * @return {Number}
	 * @deprecated
	 **/
	Ticker.getFPS = function() {
		return 1000/Ticker._interval;
	};

	/**
	 * Indicates the target time (in milliseconds) between ticks. Default is 50 (20 FPS).
	 * Note that actual time between ticks may be more than specified depending on CPU load.
	 * This property is ignored if the ticker is using the `RAF` timing mode.
	 * @property interval
	 * @static
	 * @type {Number}
	 **/
	 
	/**
	 * Indicates the target frame rate in frames per second (FPS). Effectively just a shortcut to `interval`, where
	 * `framerate == 1000/interval`.
	 * @property framerate
	 * @static
	 * @type {Number}
	 **/
	try {
		Object.defineProperties(Ticker, {
			interval: { get: Ticker.getInterval, set: Ticker.setInterval },
			framerate: { get: Ticker.getFPS, set: Ticker.setFPS }
		});
	} catch (e) { console.log(e); }


// public static methods:
	/**
	 * Starts the tick. This is called automatically when the first listener is added.
	 * @method init
	 * @static
	 **/
	Ticker.init = function() {
		if (Ticker._inited) { return; }
		Ticker._inited = true;
		Ticker._times = [];
		Ticker._tickTimes = [];
		Ticker._startTime = Ticker._getTime();
		Ticker._times.push(Ticker._lastTime = 0);
		Ticker.interval = Ticker._interval;
	};
	
	/**
	 * Stops the Ticker and removes all listeners. Use init() to restart the Ticker.
	 * @method reset
	 * @static
	 **/
	Ticker.reset = function() {
		if (Ticker._raf) {
			var f = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;
			f&&f(Ticker._timerId);
		} else {
			clearTimeout(Ticker._timerId);
		}
		Ticker.removeAllEventListeners("tick");
		Ticker._timerId = Ticker._times = Ticker._tickTimes = null;
		Ticker._startTime = Ticker._lastTime = Ticker._ticks = 0;
		Ticker._inited = false;
	};

	/**
	 * Returns the average time spent within a tick. This can vary significantly from the value provided by getMeasuredFPS
	 * because it only measures the time spent within the tick execution stack. 
	 * 
	 * Example 1: With a target FPS of 20, getMeasuredFPS() returns 20fps, which indicates an average of 50ms between 
	 * the end of one tick and the end of the next. However, getMeasuredTickTime() returns 15ms. This indicates that 
	 * there may be up to 35ms of "idle" time between the end of one tick and the start of the next.
	 *
	 * Example 2: With a target FPS of 30, getFPS() returns 10fps, which indicates an average of 100ms between the end of
	 * one tick and the end of the next. However, getMeasuredTickTime() returns 20ms. This would indicate that something
	 * other than the tick is using ~80ms (another script, DOM rendering, etc).
	 * @method getMeasuredTickTime
	 * @static
	 * @param {Number} [ticks] The number of previous ticks over which to measure the average time spent in a tick.
	 * Defaults to the number of ticks per second. To get only the last tick's time, pass in 1.
	 * @return {Number} The average time spent in a tick in milliseconds.
	 **/
	Ticker.getMeasuredTickTime = function(ticks) {
		var ttl=0, times=Ticker._tickTimes;
		if (!times || times.length < 1) { return -1; }

		// by default, calculate average for the past ~1 second:
		ticks = Math.min(times.length, ticks||(Ticker.getFPS()|0));
		for (var i=0; i<ticks; i++) { ttl += times[i]; }
		return ttl/ticks;
	};

	/**
	 * Returns the actual frames / ticks per second.
	 * @method getMeasuredFPS
	 * @static
	 * @param {Number} [ticks] The number of previous ticks over which to measure the actual frames / ticks per second.
	 * Defaults to the number of ticks per second.
	 * @return {Number} The actual frames / ticks per second. Depending on performance, this may differ
	 * from the target frames per second.
	 **/
	Ticker.getMeasuredFPS = function(ticks) {
		var times = Ticker._times;
		if (!times || times.length < 2) { return -1; }

		// by default, calculate fps for the past ~1 second:
		ticks = Math.min(times.length-1, ticks||(Ticker.getFPS()|0));
		return 1000/((times[0]-times[ticks])/ticks);
	};

	/**
	 * Use the {{#crossLink "Ticker/paused:property"}}{{/crossLink}} property instead.
	 * @method setPaused
	 * @static
	 * @param {Boolean} value
	 * @deprecated
	 **/
	Ticker.setPaused = function(value) {
		// TODO: deprecated.
		Ticker.paused = value;
	};

	/**
	 * Use the {{#crossLink "Ticker/paused:property"}}{{/crossLink}} property instead.
	 * @method getPaused
	 * @static
	 * @return {Boolean}
	 * @deprecated
	 **/
	Ticker.getPaused = function() {
		// TODO: deprecated.
		return Ticker.paused;
	};

	/**
	 * Returns the number of milliseconds that have elapsed since Ticker was initialized via {{#crossLink "Ticker/init"}}.
	 * Returns -1 if Ticker has not been initialized. For example, you could use
	 * this in a time synchronized animation to determine the exact amount of time that has elapsed.
	 * @method getTime
	 * @static
	 * @param {Boolean} [runTime=false] If true only time elapsed while Ticker was not paused will be returned.
	 * If false, the value returned will be total time elapsed since the first tick event listener was added.
	 * @return {Number} Number of milliseconds that have elapsed since Ticker was initialized or -1.
	 **/
	Ticker.getTime = function(runTime) {
		return Ticker._startTime ? Ticker._getTime() - (runTime ? Ticker._pausedTime : 0) : -1;
	};

	/**
	 * Similar to the {{#crossLink "Ticker/getTime"}}{{/crossLink}} method, but returns the time on the most recent {{#crossLink "Ticker/tick:event"}}{{/crossLink}}
	 * event object.
	 * @method getEventTime
	 * @static
	 * @param runTime {Boolean} [runTime=false] If true, the runTime property will be returned instead of time.
	 * @returns {number} The time or runTime property from the most recent tick event or -1.
	 */
	Ticker.getEventTime = function(runTime) {
		return Ticker._startTime ? (Ticker._lastTime || Ticker._startTime) - (runTime ? Ticker._pausedTime : 0) : -1;
	};
	
	/**
	 * Returns the number of ticks that have been broadcast by Ticker.
	 * @method getTicks
	 * @static
	 * @param {Boolean} pauseable Indicates whether to include ticks that would have been broadcast
	 * while Ticker was paused. If true only tick events broadcast while Ticker is not paused will be returned.
	 * If false, tick events that would have been broadcast while Ticker was paused will be included in the return
	 * value. The default value is false.
	 * @return {Number} of ticks that have been broadcast.
	 **/
	Ticker.getTicks = function(pauseable) {
		return  Ticker._ticks - (pauseable ? Ticker._pausedTicks : 0);
	};


// private static methods:
	/**
	 * @method _handleSynch
	 * @static
	 * @protected
	 **/
	Ticker._handleSynch = function() {
		Ticker._timerId = null;
		Ticker._setupTick();

		// run if enough time has elapsed, with a little bit of flexibility to be early:
		if (Ticker._getTime() - Ticker._lastTime >= (Ticker._interval-1)*0.97) {
			Ticker._tick();
		}
	};

	/**
	 * @method _handleRAF
	 * @static
	 * @protected
	 **/
	Ticker._handleRAF = function() {
		Ticker._timerId = null;
		Ticker._setupTick();
		Ticker._tick();
	};

	/**
	 * @method _handleTimeout
	 * @static
	 * @protected
	 **/
	Ticker._handleTimeout = function() {
		Ticker._timerId = null;
		Ticker._setupTick();
		Ticker._tick();
	};

	/**
	 * @method _setupTick
	 * @static
	 * @protected
	 **/
	Ticker._setupTick = function() {
		if (Ticker._timerId != null) { return; } // avoid duplicates

		var mode = Ticker.timingMode||(Ticker.useRAF&&Ticker.RAF_SYNCHED);
		if (mode == Ticker.RAF_SYNCHED || mode == Ticker.RAF) {
			var f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
			if (f) {
				Ticker._timerId = f(mode == Ticker.RAF ? Ticker._handleRAF : Ticker._handleSynch);
				Ticker._raf = true;
				return;
			}
		}
		Ticker._raf = false;
		Ticker._timerId = setTimeout(Ticker._handleTimeout, Ticker._interval);
	};

	/**
	 * @method _tick
	 * @static
	 * @protected
	 **/
	Ticker._tick = function() {
		var paused = Ticker.paused;
		var time = Ticker._getTime();
		var elapsedTime = time-Ticker._lastTime;
		Ticker._lastTime = time;
		Ticker._ticks++;
		
		if (paused) {
			Ticker._pausedTicks++;
			Ticker._pausedTime += elapsedTime;
		}
		
		if (Ticker.hasEventListener("tick")) {
			var event = new createjs.Event("tick");
			var maxDelta = Ticker.maxDelta;
			event.delta = (maxDelta && elapsedTime > maxDelta) ? maxDelta : elapsedTime;
			event.paused = paused;
			event.time = time;
			event.runTime = time-Ticker._pausedTime;
			Ticker.dispatchEvent(event);
		}
		
		Ticker._tickTimes.unshift(Ticker._getTime()-time);
		while (Ticker._tickTimes.length > 100) { Ticker._tickTimes.pop(); }

		Ticker._times.unshift(time);
		while (Ticker._times.length > 100) { Ticker._times.pop(); }
	};

	/**
	 * @method _getTime
	 * @static
	 * @protected
	 **/
	var now = window.performance && (performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow);
	Ticker._getTime = function() {
		return ((now&&now.call(performance))||(new Date().getTime())) - Ticker._startTime;
	};


	createjs.Ticker = Ticker;
}());

//##############################################################################
// UID.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Global utility for generating sequential unique ID numbers. The UID class uses a static interface (ex. <code>UID.get()</code>)
	 * and should not be instantiated.
	 * @class UID
	 * @static
	 **/
	function UID() {
		throw "UID cannot be instantiated";
	}


// private static properties:
	/**
	 * @property _nextID
	 * @type Number
	 * @protected
	 **/
	UID._nextID = 0;


// public static methods:
	/**
	 * Returns the next unique id.
	 * @method get
	 * @return {Number} The next unique id
	 * @static
	 **/
	UID.get = function() {
		return UID._nextID++;
	};


	createjs.UID = UID;
}());

//##############################################################################
// MouseEvent.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Passed as the parameter to all mouse/pointer/touch related events. For a listing of mouse events and their properties,
	 * see the {{#crossLink "DisplayObject"}}{{/crossLink}} and {{#crossLink "Stage"}}{{/crossLink}} event listings.
	 * @class MouseEvent
	 * @param {String} type The event type.
	 * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
	 * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
	 * @param {Number} stageX The normalized x position relative to the stage.
	 * @param {Number} stageY The normalized y position relative to the stage.
	 * @param {MouseEvent} nativeEvent The native DOM event related to this mouse event.
	 * @param {Number} pointerID The unique id for the pointer.
	 * @param {Boolean} primary Indicates whether this is the primary pointer in a multitouch environment.
	 * @param {Number} rawX The raw x position relative to the stage.
	 * @param {Number} rawY The raw y position relative to the stage.
	 * @param {DisplayObject} relatedTarget The secondary target for the event.
	 * @extends Event
	 * @constructor
	 **/
	function MouseEvent(type, bubbles, cancelable, stageX, stageY, nativeEvent, pointerID, primary, rawX, rawY, relatedTarget) {
		this.Event_constructor(type, bubbles, cancelable);
		
		
	// public properties:
		/**
		 * The normalized x position on the stage. This will always be within the range 0 to stage width.
		 * @property stageX
		 * @type Number
		*/
		this.stageX = stageX;
	
		/**
		 * The normalized y position on the stage. This will always be within the range 0 to stage height.
		 * @property stageY
		 * @type Number
		 **/
		this.stageY = stageY;
	
		/**
		 * The raw x position relative to the stage. Normally this will be the same as the stageX value, unless
		 * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.
		 * @property rawX
		 * @type Number
		*/
		this.rawX = (rawX==null)?stageX:rawX;
	
		/**
		 * The raw y position relative to the stage. Normally this will be the same as the stageY value, unless
		 * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.
		 * @property rawY
		 * @type Number
		*/
		this.rawY = (rawY==null)?stageY:rawY;
	
		/**
		 * The native MouseEvent generated by the browser. The properties and API for this
		 * event may differ between browsers. This property will be null if the
		 * EaselJS property was not directly generated from a native MouseEvent.
		 * @property nativeEvent
		 * @type HtmlMouseEvent
		 * @default null
		 **/
		this.nativeEvent = nativeEvent;
	
		/**
		 * The unique id for the pointer (touch point or cursor). This will be either -1 for the mouse, or the system
		 * supplied id value.
		 * @property pointerID
		 * @type {Number}
		 */
		this.pointerID = pointerID;
	
		/**
		 * Indicates whether this is the primary pointer in a multitouch environment. This will always be true for the mouse.
		 * For touch pointers, the first pointer in the current stack will be considered the primary pointer.
		 * @property primary
		 * @type {Boolean}
		 */
		this.primary = !!primary;
		
		/**
		 * The secondary target for the event, if applicable. This is used for mouseout/rollout
		 * events to indicate the object that the mouse entered from, mouseover/rollover for the object the mouse exited,
		 * and stagemousedown/stagemouseup events for the object that was the under the cursor, if any.
		 * 
		 * Only valid interaction targets will be returned (ie. objects with mouse listeners or a cursor set).
		 * @property relatedTarget
		 * @type {DisplayObject}
		 */
		this.relatedTarget = relatedTarget;
	}
	var p = createjs.extend(MouseEvent, createjs.Event);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
	
// getter / setters:
	/**
	 * Returns the x position of the mouse in the local coordinate system of the current target (ie. the dispatcher).
	 * @property localX
	 * @type {Number}
	 * @readonly
	 */
	p._get_localX = function() {
		return this.currentTarget.globalToLocal(this.rawX, this.rawY).x;
	};
	
	/**
	 * Returns the y position of the mouse in the local coordinate system of the current target (ie. the dispatcher).
	 * @property localY
	 * @type {Number}
	 * @readonly
	 */
	p._get_localY = function() {
		return this.currentTarget.globalToLocal(this.rawX, this.rawY).y;
	};
	
	/**
	 * Indicates whether the event was generated by a touch input (versus a mouse input).
	 * @property isTouch
	 * @type {Boolean}
	 * @readonly
	 */
	p._get_isTouch = function() {
		return this.pointerID !== -1;
	};
	
	
	try {
		Object.defineProperties(p, {
			localX: { get: p._get_localX },
			localY: { get: p._get_localY },
			isTouch: { get: p._get_isTouch }
		});
	} catch (e) {} // TODO: use Log


// public methods:
	/**
	 * Returns a clone of the MouseEvent instance.
	 * @method clone
	 * @return {MouseEvent} a clone of the MouseEvent instance.
	 **/
	p.clone = function() {
		return new MouseEvent(this.type, this.bubbles, this.cancelable, this.stageX, this.stageY, this.nativeEvent, this.pointerID, this.primary, this.rawX, this.rawY);
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[MouseEvent (type="+this.type+" stageX="+this.stageX+" stageY="+this.stageY+")]";
	};


	createjs.MouseEvent = createjs.promote(MouseEvent, "Event");
}());

//##############################################################################
// Matrix2D.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Represents an affine transformation matrix, and provides tools for constructing and concatenating matrices.
	 *
	 * This matrix can be visualized as:
	 *
	 * 	[ a  c  tx
	 * 	  b  d  ty
	 * 	  0  0  1  ]
	 *
	 * Note the locations of b and c.
	 *
	 * @class Matrix2D
	 * @param {Number} [a=1] Specifies the a property for the new matrix.
	 * @param {Number} [b=0] Specifies the b property for the new matrix.
	 * @param {Number} [c=0] Specifies the c property for the new matrix.
	 * @param {Number} [d=1] Specifies the d property for the new matrix.
	 * @param {Number} [tx=0] Specifies the tx property for the new matrix.
	 * @param {Number} [ty=0] Specifies the ty property for the new matrix.
	 * @constructor
	 **/
	function Matrix2D(a, b, c, d, tx, ty) {
		this.setValues(a,b,c,d,tx,ty);
		
	// public properties:
		// assigned in the setValues method.
		/**
		 * Position (0, 0) in a 3x3 affine transformation matrix.
		 * @property a
		 * @type Number
		 **/
	
		/**
		 * Position (0, 1) in a 3x3 affine transformation matrix.
		 * @property b
		 * @type Number
		 **/
	
		/**
		 * Position (1, 0) in a 3x3 affine transformation matrix.
		 * @property c
		 * @type Number
		 **/
	
		/**
		 * Position (1, 1) in a 3x3 affine transformation matrix.
		 * @property d
		 * @type Number
		 **/
	
		/**
		 * Position (2, 0) in a 3x3 affine transformation matrix.
		 * @property tx
		 * @type Number
		 **/
	
		/**
		 * Position (2, 1) in a 3x3 affine transformation matrix.
		 * @property ty
		 * @type Number
		 **/
	}
	var p = Matrix2D.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// constants:
	/**
	 * Multiplier for converting degrees to radians. Used internally by Matrix2D.
	 * @property DEG_TO_RAD
	 * @static
	 * @final
	 * @type Number
	 * @readonly
	 **/
	Matrix2D.DEG_TO_RAD = Math.PI/180;


// static public properties:
	/**
	 * An identity matrix, representing a null transformation.
	 * @property identity
	 * @static
	 * @type Matrix2D
	 * @readonly
	 **/
	Matrix2D.identity = null; // set at bottom of class definition.
	

// public methods:
	/**
	 * Sets the specified values on this instance. 
	 * @method setValues
	 * @param {Number} [a=1] Specifies the a property for the new matrix.
	 * @param {Number} [b=0] Specifies the b property for the new matrix.
	 * @param {Number} [c=0] Specifies the c property for the new matrix.
	 * @param {Number} [d=1] Specifies the d property for the new matrix.
	 * @param {Number} [tx=0] Specifies the tx property for the new matrix.
	 * @param {Number} [ty=0] Specifies the ty property for the new matrix.
	 * @return {Matrix2D} This instance. Useful for chaining method calls.
	*/
	p.setValues = function(a, b, c, d, tx, ty) {
		// don't forget to update docs in the constructor if these change:
		this.a = (a == null) ? 1 : a;
		this.b = b || 0;
		this.c = c || 0;
		this.d = (d == null) ? 1 : d;
		this.tx = tx || 0;
		this.ty = ty || 0;
		return this;
	};

	/**
	 * Appends the specified matrix properties to this matrix. All parameters are required.
	 * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.
	 * @method append
	 * @param {Number} a
	 * @param {Number} b
	 * @param {Number} c
	 * @param {Number} d
	 * @param {Number} tx
	 * @param {Number} ty
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.append = function(a, b, c, d, tx, ty) {
		var a1 = this.a;
		var b1 = this.b;
		var c1 = this.c;
		var d1 = this.d;
		if (a != 1 || b != 0 || c != 0 || d != 1) {
			this.a  = a1*a+c1*b;
			this.b  = b1*a+d1*b;
			this.c  = a1*c+c1*d;
			this.d  = b1*c+d1*d;
		}
		this.tx = a1*tx+c1*ty+this.tx;
		this.ty = b1*tx+d1*ty+this.ty;
		return this;
	};

	/**
	 * Prepends the specified matrix properties to this matrix.
	 * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.
	 * All parameters are required.
	 * @method prepend
	 * @param {Number} a
	 * @param {Number} b
	 * @param {Number} c
	 * @param {Number} d
	 * @param {Number} tx
	 * @param {Number} ty
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.prepend = function(a, b, c, d, tx, ty) {
		var a1 = this.a;
		var c1 = this.c;
		var tx1 = this.tx;

		this.a  = a*a1+c*this.b;
		this.b  = b*a1+d*this.b;
		this.c  = a*c1+c*this.d;
		this.d  = b*c1+d*this.d;
		this.tx = a*tx1+c*this.ty+tx;
		this.ty = b*tx1+d*this.ty+ty;
		return this;
	};

	/**
	 * Appends the specified matrix to this matrix.
	 * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.
	 * @method appendMatrix
	 * @param {Matrix2D} matrix
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.appendMatrix = function(matrix) {
		return this.append(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
	};

	/**
	 * Prepends the specified matrix to this matrix.
	 * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.
	 * For example, you could calculate the combined transformation for a child object using:
	 * 
	 * 	var o = myDisplayObject;
	 * 	var mtx = o.getMatrix();
	 * 	while (o = o.parent) {
	 * 		// prepend each parent's transformation in turn:
	 * 		o.prependMatrix(o.getMatrix());
	 * 	}
	 * @method prependMatrix
	 * @param {Matrix2D} matrix
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.prependMatrix = function(matrix) {
		return this.prepend(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
	};

	/**
	 * Generates matrix properties from the specified display object transform properties, and appends them to this matrix.
	 * For example, you can use this to generate a matrix representing the transformations of a display object:
	 * 
	 * 	var mtx = new Matrix2D();
	 * 	mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);
	 * @method appendTransform
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} scaleX
	 * @param {Number} scaleY
	 * @param {Number} rotation
	 * @param {Number} skewX
	 * @param {Number} skewY
	 * @param {Number} regX Optional.
	 * @param {Number} regY Optional.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.appendTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
		if (rotation%360) {
			var r = rotation*Matrix2D.DEG_TO_RAD;
			var cos = Math.cos(r);
			var sin = Math.sin(r);
		} else {
			cos = 1;
			sin = 0;
		}

		if (skewX || skewY) {
			// TODO: can this be combined into a single append operation?
			skewX *= Matrix2D.DEG_TO_RAD;
			skewY *= Matrix2D.DEG_TO_RAD;
			this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
			this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
		} else {
			this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
		}
		
		if (regX || regY) {
			// append the registration offset:
			this.tx -= regX*this.a+regY*this.c; 
			this.ty -= regX*this.b+regY*this.d;
		}
		return this;
	};

	/**
	 * Generates matrix properties from the specified display object transform properties, and prepends them to this matrix.
	 * For example, you could calculate the combined transformation for a child object using:
	 * 
	 * 	var o = myDisplayObject;
	 * 	var mtx = new createjs.Matrix2D();
	 * 	do  {
	 * 		// prepend each parent's transformation in turn:
	 * 		mtx.prependTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);
	 * 	} while (o = o.parent);
	 * 	
	 * 	Note that the above example would not account for {{#crossLink "DisplayObject/transformMatrix:property"}}{{/crossLink}}
	 * 	values. See {{#crossLink "Matrix2D/prependMatrix"}}{{/crossLink}} for an example that does.
	 * @method prependTransform
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} scaleX
	 * @param {Number} scaleY
	 * @param {Number} rotation
	 * @param {Number} skewX
	 * @param {Number} skewY
	 * @param {Number} regX Optional.
	 * @param {Number} regY Optional.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.prependTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
		if (rotation%360) {
			var r = rotation*Matrix2D.DEG_TO_RAD;
			var cos = Math.cos(r);
			var sin = Math.sin(r);
		} else {
			cos = 1;
			sin = 0;
		}

		if (regX || regY) {
			// prepend the registration offset:
			this.tx -= regX; this.ty -= regY;
		}
		if (skewX || skewY) {
			// TODO: can this be combined into a single prepend operation?
			skewX *= Matrix2D.DEG_TO_RAD;
			skewY *= Matrix2D.DEG_TO_RAD;
			this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
			this.prepend(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
		} else {
			this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
		}
		return this;
	};

	/**
	 * Applies a clockwise rotation transformation to the matrix.
	 * @method rotate
	 * @param {Number} angle The angle to rotate by, in degrees. To use a value in radians, multiply it by `180/Math.PI`.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.rotate = function(angle) {
		angle = angle*Matrix2D.DEG_TO_RAD;
		var cos = Math.cos(angle);
		var sin = Math.sin(angle);

		var a1 = this.a;
		var b1 = this.b;

		this.a = a1*cos+this.c*sin;
		this.b = b1*cos+this.d*sin;
		this.c = -a1*sin+this.c*cos;
		this.d = -b1*sin+this.d*cos;
		return this;
	};

	/**
	 * Applies a skew transformation to the matrix.
	 * @method skew
	 * @param {Number} skewX The amount to skew horizontally in degrees. To use a value in radians, multiply it by `180/Math.PI`.
	 * @param {Number} skewY The amount to skew vertically in degrees.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	*/
	p.skew = function(skewX, skewY) {
		skewX = skewX*Matrix2D.DEG_TO_RAD;
		skewY = skewY*Matrix2D.DEG_TO_RAD;
		this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), 0, 0);
		return this;
	};

	/**
	 * Applies a scale transformation to the matrix.
	 * @method scale
	 * @param {Number} x The amount to scale horizontally. E.G. a value of 2 will double the size in the X direction, and 0.5 will halve it.
	 * @param {Number} y The amount to scale vertically.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.scale = function(x, y) {
		this.a *= x;
		this.b *= x;
		this.c *= y;
		this.d *= y;
		//this.tx *= x;
		//this.ty *= y;
		return this;
	};

	/**
	 * Translates the matrix on the x and y axes.
	 * @method translate
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.translate = function(x, y) {
		this.tx += this.a*x + this.c*y;
		this.ty += this.b*x + this.d*y;
		return this;
	};

	/**
	 * Sets the properties of the matrix to those of an identity matrix (one that applies a null transformation).
	 * @method identity
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.identity = function() {
		this.a = this.d = 1;
		this.b = this.c = this.tx = this.ty = 0;
		return this;
	};

	/**
	 * Inverts the matrix, causing it to perform the opposite transformation.
	 * @method invert
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.invert = function() {
		var a1 = this.a;
		var b1 = this.b;
		var c1 = this.c;
		var d1 = this.d;
		var tx1 = this.tx;
		var n = a1*d1-b1*c1;

		this.a = d1/n;
		this.b = -b1/n;
		this.c = -c1/n;
		this.d = a1/n;
		this.tx = (c1*this.ty-d1*tx1)/n;
		this.ty = -(a1*this.ty-b1*tx1)/n;
		return this;
	};

	/**
	 * Returns true if the matrix is an identity matrix.
	 * @method isIdentity
	 * @return {Boolean}
	 **/
	p.isIdentity = function() {
		return this.tx === 0 && this.ty === 0 && this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1;
	};
	
	/**
	 * Returns true if this matrix is equal to the specified matrix (all property values are equal).
	 * @method equals
	 * @param {Matrix2D} matrix The matrix to compare.
	 * @return {Boolean}
	 **/
	p.equals = function(matrix) {
		return this.tx === matrix.tx && this.ty === matrix.ty && this.a === matrix.a && this.b === matrix.b && this.c === matrix.c && this.d === matrix.d;
	};

	/**
	 * Transforms a point according to this matrix.
	 * @method transformPoint
	 * @param {Number} x The x component of the point to transform.
	 * @param {Number} y The y component of the point to transform.
	 * @param {Point | Object} [pt] An object to copy the result into. If omitted a generic object with x/y properties will be returned.
	 * @return {Point} This matrix. Useful for chaining method calls.
	 **/
	p.transformPoint = function(x, y, pt) {
		pt = pt||{};
		pt.x = x*this.a+y*this.c+this.tx;
		pt.y = x*this.b+y*this.d+this.ty;
		return pt;
	};

	/**
	 * Decomposes the matrix into transform properties (x, y, scaleX, scaleY, and rotation). Note that these values
	 * may not match the transform properties you used to generate the matrix, though they will produce the same visual
	 * results.
	 * @method decompose
	 * @param {Object} target The object to apply the transform properties to. If null, then a new object will be returned.
	 * @return {Object} The target, or a new generic object with the transform properties applied.
	*/
	p.decompose = function(target) {
		// TODO: it would be nice to be able to solve for whether the matrix can be decomposed into only scale/rotation even when scale is negative
		if (target == null) { target = {}; }
		target.x = this.tx;
		target.y = this.ty;
		target.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);
		target.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);

		var skewX = Math.atan2(-this.c, this.d);
		var skewY = Math.atan2(this.b, this.a);

		var delta = Math.abs(1-skewX/skewY);
		if (delta < 0.00001) { // effectively identical, can use rotation:
			target.rotation = skewY/Matrix2D.DEG_TO_RAD;
			if (this.a < 0 && this.d >= 0) {
				target.rotation += (target.rotation <= 0) ? 180 : -180;
			}
			target.skewX = target.skewY = 0;
		} else {
			target.skewX = skewX/Matrix2D.DEG_TO_RAD;
			target.skewY = skewY/Matrix2D.DEG_TO_RAD;
		}
		return target;
	};
	
	/**
	 * Copies all properties from the specified matrix to this matrix.
	 * @method copy
	 * @param {Matrix2D} matrix The matrix to copy properties from.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	*/
	p.copy = function(matrix) {
		return this.setValues(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
	};

	/**
	 * Returns a clone of the Matrix2D instance.
	 * @method clone
	 * @return {Matrix2D} a clone of the Matrix2D instance.
	 **/
	p.clone = function() {
		return new Matrix2D(this.a, this.b, this.c, this.d, this.tx, this.ty);
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Matrix2D (a="+this.a+" b="+this.b+" c="+this.c+" d="+this.d+" tx="+this.tx+" ty="+this.ty+")]";
	};

	// this has to be populated after the class is defined:
	Matrix2D.identity = new Matrix2D();


	createjs.Matrix2D = Matrix2D;
}());

//##############################################################################
// DisplayProps.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

	/**
	 * Used for calculating and encapsulating display related properties.
	 * @class DisplayProps
	 * @param {Number} [visible=true] Visible value.
	 * @param {Number} [alpha=0] Alpha value.
	 * @param {Number} [shadow=null] A Shadow instance or null.
	 * @param {Number} [compositeOperation=null] A compositeOperation value or null.
	 * @param {Number} [matrix] A transformation matrix. Defaults to a new identity matrix.
	 * @constructor
	 **/
	function DisplayProps(visible, alpha, shadow, compositeOperation, matrix) {
		this.setValues(visible, alpha, shadow, compositeOperation, matrix);
		
	// public properties:
		// assigned in the setValues method.
		/**
		 * Property representing the alpha that will be applied to a display object.
		 * @property alpha
		 * @type Number
		 **/
	
		/**
		 * Property representing the shadow that will be applied to a display object.
		 * @property shadow
		 * @type Shadow
		 **/
	
		/**
		 * Property representing the compositeOperation that will be applied to a display object.
		 * You can find a list of valid composite operations at:
		 * <a href="https://developer.mozilla.org/en/Canvas_tutorial/Compositing">https://developer.mozilla.org/en/Canvas_tutorial/Compositing</a>
		 * @property compositeOperation
		 * @type String
		 **/
		
		/**
		 * Property representing the value for visible that will be applied to a display object.
		 * @property visible
		 * @type Boolean
		 **/
		
		/**
		 * The transformation matrix that will be applied to a display object.
		 * @property matrix
		 * @type Matrix2D
		 **/
	}
	var p = DisplayProps.prototype;

// initialization:
	/**
	 * Reinitializes the instance with the specified values.
	 * @method setValues
	 * @param {Number} [visible=true] Visible value.
	 * @param {Number} [alpha=1] Alpha value.
	 * @param {Number} [shadow=null] A Shadow instance or null.
	 * @param {Number} [compositeOperation=null] A compositeOperation value or null.
	 * @param {Number} [matrix] A transformation matrix. Defaults to an identity matrix.
	 * @return {DisplayProps} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.setValues = function (visible, alpha, shadow, compositeOperation, matrix) {
		this.visible = visible == null ? true : !!visible;
		this.alpha = alpha == null ? 1 : alpha;
		this.shadow = shadow;
		this.compositeOperation = shadow;
		this.matrix = matrix || (this.matrix&&this.matrix.identity()) || new createjs.Matrix2D();
		return this;
	};

// public methods:
	/**
	 * Appends the specified display properties. This is generally used to apply a child's properties its parent's.
	 * @method append
	 * @param {Boolean} visible desired visible value
	 * @param {Number} alpha desired alpha value
	 * @param {Shadow} shadow desired shadow value
	 * @param {String} compositeOperation desired composite operation value
	 * @param {Matrix2D} [matrix] a Matrix2D instance
	 * @return {DisplayProps} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.append = function(visible, alpha, shadow, compositeOperation, matrix) {
		this.alpha *= alpha;
		this.shadow = shadow || this.shadow;
		this.compositeOperation = compositeOperation || this.compositeOperation;
		this.visible = this.visible && visible;
		matrix&&this.matrix.appendMatrix(matrix);
		return this;
	};
	
	/**
	 * Prepends the specified display properties. This is generally used to apply a parent's properties to a child's.
	 * For example, to get the combined display properties that would be applied to a child, you could use:
	 * 
	 * 	var o = myDisplayObject;
	 * 	var props = new createjs.DisplayProps();
	 * 	do {
	 * 		// prepend each parent's props in turn:
	 * 		props.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation, o.getMatrix());
	 * 	} while (o = o.parent);
	 * 	
	 * @method prepend
	 * @param {Boolean} visible desired visible value
	 * @param {Number} alpha desired alpha value
	 * @param {Shadow} shadow desired shadow value
	 * @param {String} compositeOperation desired composite operation value
	 * @param {Matrix2D} [matrix] a Matrix2D instance
	 * @return {DisplayProps} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.prepend = function(visible, alpha, shadow, compositeOperation, matrix) {
		this.alpha *= alpha;
		this.shadow = this.shadow || shadow;
		this.compositeOperation = this.compositeOperation || compositeOperation;
		this.visible = this.visible && visible;
		matrix&&this.matrix.prependMatrix(matrix);
		return this;
	};
	
	/**
	 * Resets this instance and its matrix to default values.
	 * @method identity
	 * @return {DisplayProps} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.identity = function() {
		this.visible = true;
		this.alpha = 1;
		this.shadow = this.compositeOperation = null;
		this.matrix.identity();
		return this;
	};
	
	/**
	 * Returns a clone of the DisplayProps instance. Clones the associated matrix.
	 * @method clone
	 * @return {DisplayProps} a clone of the DisplayProps instance.
	 **/
	p.clone = function() {
		return new DisplayProps(this.alpha, this.shadow, this.compositeOperation, this.visible, this.matrix.clone());
	};

// private methods:

	createjs.DisplayProps = DisplayProps;
})();

//##############################################################################
// Point.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Represents a point on a 2 dimensional x / y coordinate system.
	 *
	 * <h4>Example</h4>
	 * 
	 *      var point = new createjs.Point(0, 100);
	 * 
	 * @class Point
	 * @param {Number} [x=0] X position.
	 * @param {Number} [y=0] Y position.
	 * @constructor
	 **/
	function Point(x, y) {
	 	this.setValues(x, y);
	 	
	 	
	// public properties:
		// assigned in the setValues method.
		/**
		 * X position.
		 * @property x
		 * @type Number
		 **/
	
		/**
		 * Y position.
		 * @property y
		 * @type Number
		 **/
	}
	var p = Point.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.

	
// public methods:
	/** 
	 * Sets the specified values on this instance.
	 * @method setValues
	 * @param {Number} [x=0] X position.
	 * @param {Number} [y=0] Y position.
	 * @return {Point} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.setValues = function(x, y) {
		this.x = x||0;
		this.y = y||0;
		return this;
	};
	
	/**
	 * Copies all properties from the specified point to this point.
	 * @method copy
	 * @param {Point} point The point to copy properties from.
	 * @return {Point} This point. Useful for chaining method calls.
	 * @chainable
	*/
	p.copy = function(point) {
		this.x = point.x;
		this.y = point.y;
		return this;
	};
	
	/**
	 * Returns a clone of the Point instance.
	 * @method clone
	 * @return {Point} a clone of the Point instance.
	 **/
	p.clone = function() {
		return new Point(this.x, this.y);
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Point (x="+this.x+" y="+this.y+")]";
	};
	
	
	createjs.Point = Point;
}());

//##############################################################################
// Rectangle.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Represents a rectangle as defined by the points (x, y) and (x+width, y+height).
	 *
	 * <h4>Example</h4>
	 *
	 *      var rect = new createjs.Rectangle(0, 0, 100, 100);
	 *
	 * @class Rectangle
	 * @param {Number} [x=0] X position.
	 * @param {Number} [y=0] Y position.
	 * @param {Number} [width=0] The width of the Rectangle.
	 * @param {Number} [height=0] The height of the Rectangle.
	 * @constructor
	 **/
	function Rectangle(x, y, width, height) {
		this.setValues(x, y, width, height);
		
		
	// public properties:
		// assigned in the setValues method.
		/**
		 * X position.
		 * @property x
		 * @type Number
		 **/
	
		/**
		 * Y position.
		 * @property y
		 * @type Number
		 **/
	
		/**
		 * Width.
		 * @property width
		 * @type Number
		 **/
	
		/**
		 * Height.
		 * @property height
		 * @type Number
		 **/
	}
	var p = Rectangle.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// public methods:
	/** 
	 * Sets the specified values on this instance.
	 * @method setValues
	 * @param {Number} [x=0] X position.
	 * @param {Number} [y=0] Y position.
	 * @param {Number} [width=0] The width of the Rectangle.
	 * @param {Number} [height=0] The height of the Rectangle.
	 * @return {Rectangle} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.setValues = function(x, y, width, height) {
		// don't forget to update docs in the constructor if these change:
		this.x = x||0;
		this.y = y||0;
		this.width = width||0;
		this.height = height||0;
		return this;
	};
	
	/** 
	 * Extends the rectangle's bounds to include the described point or rectangle.
	 * @method extend
	 * @param {Number} x X position of the point or rectangle.
	 * @param {Number} y Y position of the point or rectangle.
	 * @param {Number} [width=0] The width of the rectangle.
	 * @param {Number} [height=0] The height of the rectangle.
	 * @return {Rectangle} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.extend = function(x, y, width, height) {
		width = width||0;
		height = height||0;
		if (x+width > this.x+this.width) { this.width = x+width-this.x; }
		if (y+height > this.y+this.height) { this.height = y+height-this.y; }
		if (x < this.x) { this.width += this.x-x; this.x = x; }
		if (y < this.y) { this.height += this.y-y; this.y = y; }
		return this;
	};
	
	/** 
	 * Adds the specified padding to the rectangle's bounds.
	 * @method extend
	 * @param {Number} [top=0]
	 * @param {Number} [left=0]
	 * @param {Number} [right=0]
	 * @param {Number} [bottom=0]
	 * @return {Rectangle} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.pad = function(top, left, bottom, right) {
		this.x -= left;
		this.y -= top;
		this.width += left+right;
		this.height += top+bottom;
		return this;
	};
	
	/**
	 * Copies all properties from the specified rectangle to this rectangle.
	 * @method copy
	 * @param {Rectangle} rectangle The rectangle to copy properties from.
	 * @return {Rectangle} This rectangle. Useful for chaining method calls.
	 * @chainable
	*/
	p.copy = function(rectangle) {
		return this.setValues(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
	};
	
	/** 
	 * Returns true if this rectangle fully encloses the described point or rectangle.
	 * @method contains
	 * @param {Number} x X position of the point or rectangle.
	 * @param {Number} y Y position of the point or rectangle.
	 * @param {Number} [width=0] The width of the rectangle.
	 * @param {Number} [height=0] The height of the rectangle.
	 * @return {Boolean} True if the described point or rectangle is contained within this rectangle.
	*/
	p.contains = function(x, y, width, height) {
		width = width||0;
		height = height||0;
		return (x >= this.x && x+width <= this.x+this.width && y >= this.y && y+height <= this.y+this.height);
	};
	
	/** 
	 * Returns a new rectangle which contains this rectangle and the specified rectangle.
	 * @method union
	 * @param {Rectangle} rect The rectangle to calculate a union with.
	 * @return {Rectangle} A new rectangle describing the union.
	*/
	p.union = function(rect) {
		return this.clone().extend(rect.x, rect.y, rect.width, rect.height);
	};
	
	/** 
	 * Returns a new rectangle which describes the intersection (overlap) of this rectangle and the specified rectangle,
	 * or null if they do not intersect.
	 * @method intersection
	 * @param {Rectangle} rect The rectangle to calculate an intersection with.
	 * @return {Rectangle} A new rectangle describing the intersection or null.
	*/
	p.intersection = function(rect) {
		var x1 = rect.x, y1 = rect.y, x2 = x1+rect.width, y2 = y1+rect.height;
		if (this.x > x1) { x1 = this.x; }
		if (this.y > y1) { y1 = this.y; }
		if (this.x + this.width < x2) { x2 = this.x + this.width; }
		if (this.y + this.height < y2) { y2 = this.y + this.height; }
		return (x2 <= x1 || y2 <= y1) ? null : new Rectangle(x1, y1, x2-x1, y2-y1);
	};
	
	/** 
	 * Returns true if the specified rectangle intersects (has any overlap) with this rectangle.
	 * @method intersects
	 * @param {Rectangle} rect The rectangle to compare.
	 * @return {Boolean} True if the rectangles intersect.
	*/
	p.intersects = function(rect) {
		return (rect.x <= this.x+this.width && this.x <= rect.x+rect.width && rect.y <= this.y+this.height && this.y <= rect.y + rect.height);
	};
	
	/** 
	 * Returns true if the width or height are equal or less than 0.
	 * @method isEmpty
	 * @return {Boolean} True if the rectangle is empty.
	*/
	p.isEmpty = function() {
		return this.width <= 0 || this.height <= 0;
	};
	
	/**
	 * Returns a clone of the Rectangle instance.
	 * @method clone
	 * @return {Rectangle} a clone of the Rectangle instance.
	 **/
	p.clone = function() {
		return new Rectangle(this.x, this.y, this.width, this.height);
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Rectangle (x="+this.x+" y="+this.y+" width="+this.width+" height="+this.height+")]";
	};
	
	
	createjs.Rectangle = Rectangle;
}());

//##############################################################################
// ButtonHelper.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * The ButtonHelper is a helper class to create interactive buttons from {{#crossLink "MovieClip"}}{{/crossLink}} or
	 * {{#crossLink "Sprite"}}{{/crossLink}} instances. This class will intercept mouse events from an object, and
	 * automatically call {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} or {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}},
	 * to the respective animation labels, add a pointer cursor, and allows the user to define a hit state frame.
	 *
	 * The ButtonHelper instance does not need to be added to the stage, but a reference should be maintained to prevent
	 * garbage collection.
	 * 
	 * Note that over states will not work unless you call {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}.
	 *
	 * <h4>Example</h4>
	 *
	 *      var helper = new createjs.ButtonHelper(myInstance, "out", "over", "down", false, myInstance, "hit");
	 *      myInstance.addEventListener("click", handleClick);
	 *      function handleClick(event) {
	 *          // Click Happened.
	 *      }
	 *
	 * @class ButtonHelper
	 * @param {Sprite|MovieClip} target The instance to manage.
	 * @param {String} [outLabel="out"] The label or animation to go to when the user rolls out of the button.
	 * @param {String} [overLabel="over"] The label or animation to go to when the user rolls over the button.
	 * @param {String} [downLabel="down"] The label or animation to go to when the user presses the button.
	 * @param {Boolean} [play=false] If the helper should call "gotoAndPlay" or "gotoAndStop" on the button when changing
	 * states.
	 * @param {DisplayObject} [hitArea] An optional item to use as the hit state for the button. If this is not defined,
	 * then the button's visible states will be used instead. Note that the same instance as the "target" argument can be
	 * used for the hitState.
	 * @param {String} [hitLabel] The label or animation on the hitArea instance that defines the hitArea bounds. If this is
	 * null, then the default state of the hitArea will be used. *
	 * @constructor
	 */
	function ButtonHelper(target, outLabel, overLabel, downLabel, play, hitArea, hitLabel) {
		if (!target.addEventListener) { return; }
	
	
	// public properties:
		/**
		 * The target for this button helper.
		 * @property target
		 * @type MovieClip | Sprite
		 * @readonly
		 **/
		this.target = target;
	
		/**
		 * The label name or frame number to display when the user mouses out of the target. Defaults to "over".
		 * @property overLabel
		 * @type String | Number
		 **/
		this.overLabel = overLabel == null ? "over" : overLabel;
	
		/**
		 * The label name or frame number to display when the user mouses over the target. Defaults to "out".
		 * @property outLabel
		 * @type String | Number
		 **/
		this.outLabel = outLabel == null ? "out" : outLabel;
	
		/**
		 * The label name or frame number to display when the user presses on the target. Defaults to "down".
		 * @property downLabel
		 * @type String | Number
		 **/
		this.downLabel = downLabel == null ? "down" : downLabel;
	
		/**
		 * If true, then ButtonHelper will call gotoAndPlay, if false, it will use gotoAndStop. Default is false.
		 * @property play
		 * @default false
		 * @type Boolean
		 **/
		this.play = play;
		
		
	//  private properties
		/**
		 * @property _isPressed
		 * @type Boolean
		 * @protected
		 **/
		this._isPressed = false;
	
		/**
		 * @property _isOver
		 * @type Boolean
		 * @protected
		 **/
		this._isOver = false;
	
		/**
		 * @property _enabled
		 * @type Boolean
		 * @protected
		 **/
		this._enabled = false;
		
	// setup:
		target.mouseChildren = false; // prevents issues when children are removed from the display list when state changes.
		this.enabled = true;
		this.handleEvent({});
		if (hitArea) {
			if (hitLabel) {
				hitArea.actionsEnabled = false;
				hitArea.gotoAndStop&&hitArea.gotoAndStop(hitLabel);
			}
			target.hitArea = hitArea;
		}
	}
	var p = ButtonHelper.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.

	
// getter / setters:
	/**
	 * Use the {{#crossLink "ButtonHelper/enabled:property"}}{{/crossLink}} property instead.
	 * @method setEnabled
	 * @param {Boolean} value
	 * @deprecated
	 **/
	p.setEnabled = function(value) { // TODO: deprecated.
		if (value == this._enabled) { return; }
		var o = this.target;
		this._enabled = value;
		if (value) {
			o.cursor = "pointer";
			o.addEventListener("rollover", this);
			o.addEventListener("rollout", this);
			o.addEventListener("mousedown", this);
			o.addEventListener("pressup", this);
			if (o._reset) { o.__reset = o._reset; o._reset = this._reset;}
		} else {
			o.cursor = null;
			o.removeEventListener("rollover", this);
			o.removeEventListener("rollout", this);
			o.removeEventListener("mousedown", this);
			o.removeEventListener("pressup", this);
			if (o.__reset) { o._reset = o.__reset; delete(o.__reset); }
		}
	};
	/**
	 * Use the {{#crossLink "ButtonHelper/enabled:property"}}{{/crossLink}} property instead.
	 * @method getEnabled
	 * @return {Boolean}
	 * @deprecated
	 **/
	p.getEnabled = function() {
		return this._enabled;
	};

	/**
	 * Enables or disables the button functionality on the target.
	 * @property enabled
	 * @type {Boolean}
	 **/
	try {
		Object.defineProperties(p, {
			enabled: { get: p.getEnabled, set: p.setEnabled }
		});
	} catch (e) {} // TODO: use Log


// public methods:
	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[ButtonHelper]";
	};


// private methods:
	/**
	 * @method handleEvent
	 * @param {Object} evt The mouse event to handle.
	 * @protected
	 **/
	p.handleEvent = function(evt) {
		var label, t = this.target, type = evt.type;
		if (type == "mousedown") {
			this._isPressed = true;
			label = this.downLabel;
		} else if (type == "pressup") {
			this._isPressed = false;
			label = this._isOver ? this.overLabel : this.outLabel;
		} else if (type == "rollover") {
			this._isOver = true;
			label = this._isPressed ? this.downLabel : this.overLabel;
		} else { // rollout and default
			this._isOver = false;
			label = this._isPressed ? this.overLabel : this.outLabel;
		}
		if (this.play) {
			t.gotoAndPlay&&t.gotoAndPlay(label);
		} else {
			t.gotoAndStop&&t.gotoAndStop(label);
		}
	};
	
	/**
	 * Injected into target. Preserves the paused state through a reset.
	 * @method _reset
	 * @protected
	 **/
	p._reset = function() {
		// TODO: explore better ways to handle this issue. This is hacky & disrupts object signatures.
		var p = this.paused;
		this.__reset();
		this.paused = p;
	};


	createjs.ButtonHelper = ButtonHelper;
}());

//##############################################################################
// Shadow.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * This class encapsulates the properties required to define a shadow to apply to a {{#crossLink "DisplayObject"}}{{/crossLink}}
	 * via its <code>shadow</code> property.
	 *
	 * <h4>Example</h4>
	 *
	 *      myImage.shadow = new createjs.Shadow("#000000", 5, 5, 10);
	 *
	 * @class Shadow
	 * @constructor
	 * @param {String} color The color of the shadow. This can be any valid CSS color value.
	 * @param {Number} offsetX The x offset of the shadow in pixels.
	 * @param {Number} offsetY The y offset of the shadow in pixels.
	 * @param {Number} blur The size of the blurring effect.
	 **/
	function Shadow(color, offsetX, offsetY, blur) {
		
		
	// public properties:
		/** 
		 * The color of the shadow. This can be any valid CSS color value.
		 * @property color
		 * @type String
		 * @default null
		 */
		this.color = color||"black";
	
		/** The x offset of the shadow.
		 * @property offsetX
		 * @type Number
		 * @default 0
		 */
		this.offsetX = offsetX||0;
	
		/** The y offset of the shadow.
		 * @property offsetY
		 * @type Number
		 * @default 0
		 */
		this.offsetY = offsetY||0;
	
		/** The blur of the shadow.
		 * @property blur
		 * @type Number
		 * @default 0
		 */
		this.blur = blur||0;
	}
	var p = Shadow.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// static public properties:
	/**
	 * An identity shadow object (all properties are set to 0).
	 * @property identity
	 * @type Shadow
	 * @static
	 * @final
	 * @readonly
	 **/
	Shadow.identity = new Shadow("transparent", 0, 0, 0);


// public methods:
	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Shadow]";
	};

	/**
	 * Returns a clone of this Shadow instance.
	 * @method clone
	 * @return {Shadow} A clone of the current Shadow instance.
	 **/
	p.clone = function() {
		return new Shadow(this.color, this.offsetX, this.offsetY, this.blur);
	};
	

	createjs.Shadow = Shadow;
}());

//##############################################################################
// SpriteSheet.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Encapsulates the properties and methods associated with a sprite sheet. A sprite sheet is a series of images (usually
	 * animation frames) combined into a larger image (or images). For example, an animation consisting of eight 100x100
	 * images could be combined into a single 400x200 sprite sheet (4 frames across by 2 high).
	 *
	 * The data passed to the SpriteSheet constructor defines:<ol>
	 * 	<li> The source image or images to use.</li>
	 * 	<li> The positions of individual image frames.</li>
	 * 	<li> Sequences of frames that form named animations. Optional.</li>
	 * 	<li> The target playback framerate. Optional.</li>
	 * </OL>
	 *
	 * <h3>SpriteSheet Format</h3>
	 *
	 * SpriteSheets are an object with two required properties (`images` and `frames`), and two optional properties
	 * (`framerate` and `animations`). This makes them easy to define in javascript code, or in JSON.
	 *
	 * <h4>images</h4>
	 * An array of source images. Images can be either an HTMLImage
	 * instance, or a uri to an image. The former is recommended to control preloading.
	 *
	 * 	images: [image1, "path/to/image2.png"],
	 *
	 * <h4>frames</h4>
	 * Defines the individual frames. There are two supported formats for frame data:<OL>
	 * <LI> when all of the frames are the same size (in a grid), use an object with `width`, `height`, `regX`, `regY`, and `count` properties.
	 * `width` & `height` are required and specify the dimensions of the frames.
	 * `regX` & `regY` indicate the registration point or "origin" of the frames.
	 * `spacing` indicate the spacing between frames.
	 * `margin` specify the margin around the image(s).
	 * `count` allows you to specify the total number of frames in the spritesheet; if omitted, this will be calculated
	 * based on the dimensions of the source images and the frames. Frames will be assigned indexes based on their position
	 * in the source images (left to right, top to bottom).
	 *
	 * 	frames: {width:64, height:64, count:20, regX: 32, regY:64, spacing:0, margin:0}
	 *
	 * <LI> if the frames are of different sizes, use an array of frame definitions. Each definition is itself an array
	 * with 4 required and 3 optional entries, in the order: `x`, `y`, `width`, `height`, `imageIndex`, `regX`, `regY`. The first
	 * four entries are required and define the frame rectangle. The fifth specifies the index of the source image (defaults to 0). The
	 * last two specify the registration point of the frame.
	 *
	 * 	frames: [
	 * 		// x, y, width, height, imageIndex*, regX*, regY*
	 * 		[64, 0, 96, 64],
	 * 		[0, 0, 64, 64, 1, 32, 32]
	 * 		// etc.
	 * 	]
	 *
	 * </OL>
	 *
	 * <h4>animations</h4>
	 * Optional. An object defining sequences of frames to play as named animations. Each property corresponds to an
	 * animation of the same name. Each animation must specify the frames to play, and may
	 * also include a relative playback `speed` (ex. 2 would playback at double speed, 0.5 at half), and
	 * the name of the `next` animation to sequence to after it completes.
	 *
	 * There are three formats supported for defining the frames in an animation, which can be mixed and matched as appropriate:<OL>
	 * <LI> for a single frame animation, you can simply specify the frame index
	 *
	 * 	animations: {
	 * 		sit: 7
	 * 	}
	 *
	 * <LI> for an animation of consecutive frames, you can use an array with two required, and two optional entries
	 * in the order: `start`, `end`, `next`, and `speed`. This will play the frames from start to end inclusive.
	 *
	 * 	animations: {
	 * 		// start, end, next*, speed*
	 * 		run: [0, 8],
	 * 		jump: [9, 12, "run", 2]
	 * 	}
	 *
	 * <LI> for non-consecutive frames, you can use an object with a `frames` property defining an array of frame indexes to
	 * play in order. The object can also specify `next` and `speed` properties.
	 *
	 * 	animations: {
	 * 		walk: {
	 * 			frames: [1,2,3,3,2,1]
	 * 		},
	 * 		shoot: {
	 * 			frames: [1,4,5,6],
	 * 			next: "walk",
	 * 			speed: 0.5
	 * 		}
	 * 	}
	 *
	 * </OL>
	 * <strong>Note:</strong> the `speed` property was added in EaselJS 0.7.0. Earlier versions had a `frequency`
	 * property instead, which was the inverse of `speed`. For example, a value of "4" would be 1/4 normal speed in earlier
	 * versions, but is 4x normal speed in 0.7.0+.
	 *
	 * <h4>framerate</h4>
	 * Optional. Indicates the default framerate to play this spritesheet at in frames per second.
	 * See {{#crossLink "SpriteSheet/framerate:property"}}{{/crossLink}} for more information.
	 *
	 * 	framerate: 20
	 *
	 * <h4>Example</h4>
	 * To define a simple sprite sheet, with a single image "sprites.jpg" arranged in a regular 50x50 grid with three
	 * animations: "stand" showing the first frame, "run" looping frame 1-5 inclusive, and "jump" playing  frame 6-8 and sequencing back to run.
	 *
	 * 	var data = {
	 * 		images: ["sprites.jpg"],
	 * 		frames: {width:50, height:50},
	 * 		animations: {
	 * 			stand:0,
	 * 			run:[1,5],
	 * 			jump:[6,8,"run"]
	 * 		}
	 * 	};
	 * 	var spriteSheet = new createjs.SpriteSheet(data);
	 * 	var animation = new createjs.Sprite(spriteSheet, "run");
	 *
	 *
	 * <strong>Warning:</strong> Images loaded cross-origin will throw cross-origin security errors when interacted with
	 * using a mouse, using methods such as `getObjectUnderPoint`, using filters, or caching. You can get around this by
	 * setting `crossOrigin` flags on your images before passing them to EaselJS, eg: `img.crossOrigin="Anonymous";`
	 *
	 * @class SpriteSheet
	 * @constructor
	 * @param {Object} data An object describing the SpriteSheet data.
	 * @extends EventDispatcher
	 **/
	function SpriteSheet(data) {
		this.EventDispatcher_constructor();


		// public properties:
		/**
		 * Indicates whether all images are finished loading.
		 * @property complete
		 * @type Boolean
		 * @readonly
		 **/
		this.complete = true;

		/**
		 * Specifies the framerate to use by default for Sprite instances using the SpriteSheet. See
		 * Sprite.framerate for more information.
		 * @property framerate
		 * @type Number
		 **/
		this.framerate = 0;


		// private properties:
		/**
		 * @property _animations
		 * @protected
		 * @type Array
		 **/
		this._animations = null;

		/**
		 * @property _frames
		 * @protected
		 * @type Array
		 **/
		this._frames = null;

		/**
		 * @property _images
		 * @protected
		 * @type Array
		 **/
		this._images = null;

		/**
		 * @property _data
		 * @protected
		 * @type Object
		 **/
		this._data = null;

		/**
		 * @property _loadCount
		 * @protected
		 * @type Number
		 **/
		this._loadCount = 0;

		// only used for simple frame defs:
		/**
		 * @property _frameHeight
		 * @protected
		 * @type Number
		 **/
		this._frameHeight = 0;

		/**
		 * @property _frameWidth
		 * @protected
		 * @type Number
		 **/
		this._frameWidth = 0;

		/**
		 * @property _numFrames
		 * @protected
		 * @type Number
		 **/
		this._numFrames = 0;

		/**
		 * @property _regX
		 * @protected
		 * @type Number
		 **/
		this._regX = 0;

		/**
		 * @property _regY
		 * @protected
		 * @type Number
		 **/
		this._regY = 0;

		/**
		 * @property _spacing
		 * @protected
		 * @type Number
		 **/
		this._spacing = 0;

		/**
		 * @property _margin
		 * @protected
		 * @type Number
		 **/
		this._margin = 0;

		// setup:
		this._parseData(data);
	}
	var p = createjs.extend(SpriteSheet, createjs.EventDispatcher);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// events:
	/**
	 * Dispatched when all images are loaded.  Note that this only fires if the images
	 * were not fully loaded when the sprite sheet was initialized. You should check the complete property
	 * to prior to adding a listener. Ex.
	 *
	 * 	var sheet = new SpriteSheet(data);
	 * 	if (!sheet.complete) {
	 * 		// not preloaded, listen for the complete event:
	 * 		sheet.addEventListener("complete", handler);
	 * 	}
	 *
	 * @event complete
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @since 0.6.0
	 */

	/**
	 * Dispatched when getFrame is called with a valid frame index. This is primarily intended for use by {{#crossLink "SpriteSheetBuilder"}}{{/crossLink}}
	 * when doing on-demand rendering.
	 * @event getframe
	 * @param {Number} index The frame index.
	 * @param {Object} frame The frame object that getFrame will return.
	 */


// getter / setters:
	/**
	 * Use the {{#crossLink "SpriteSheet/animations:property"}}{{/crossLink}} property instead.
	 * @method getAnimations
	 * @return {Array}
	 * @deprecated
	 **/
	p.getAnimations = function() {
		return this._animations.slice();
	};

	/**
	 * Returns an array of all available animation names available on this sprite sheet as strings.
	 * @property animations
	 * @type {Array}
	 * @readonly
	 **/
	try {
		Object.defineProperties(p, {
			animations: { get: p.getAnimations }
		});
	} catch (e) {}


// public methods:
	/**
	 * Returns the total number of frames in the specified animation, or in the whole sprite
	 * sheet if the animation param is omitted. Returns 0 if the spritesheet relies on calculated frame counts, and
	 * the images have not been fully loaded.
	 * @method getNumFrames
	 * @param {String} animation The name of the animation to get a frame count for.
	 * @return {Number} The number of frames in the animation, or in the entire sprite sheet if the animation param is omitted.
	 */
	p.getNumFrames = function(animation) {
		if (animation == null) {
			return this._frames ? this._frames.length : this._numFrames || 0;
		} else {
			var data = this._data[animation];
			if (data == null) { return 0; }
			else { return data.frames.length; }
		}
	};

	/**
	 * Returns an object defining the specified animation. The returned object contains:<UL>
	 * 	<LI>frames: an array of the frame ids in the animation</LI>
	 * 	<LI>speed: the playback speed for this animation</LI>
	 * 	<LI>name: the name of the animation</LI>
	 * 	<LI>next: the default animation to play next. If the animation loops, the name and next property will be the
	 * 	same.</LI>
	 * </UL>
	 * @method getAnimation
	 * @param {String} name The name of the animation to get.
	 * @return {Object} a generic object with frames, speed, name, and next properties.
	 **/
	p.getAnimation = function(name) {
		return this._data[name];
	};

	/**
	 * Returns an object specifying the image and source rect of the specified frame. The returned object has:<UL>
	 * 	<LI>an image property holding a reference to the image object in which the frame is found</LI>
	 * 	<LI>a rect property containing a Rectangle instance which defines the boundaries for the frame within that
	 * 	image.</LI>
	 * 	<LI> A regX and regY property corresponding to the regX/Y values for the frame.
	 * </UL>
	 * @method getFrame
	 * @param {Number} frameIndex The index of the frame.
	 * @return {Object} a generic object with image and rect properties. Returns null if the frame does not exist.
	 **/
	p.getFrame = function(frameIndex) {
		var frame;
		if (this._frames && (frame=this._frames[frameIndex])) { return frame; }
		return null;
	};

	/**
	 * Returns a {{#crossLink "Rectangle"}}{{/crossLink}} instance defining the bounds of the specified frame relative
	 * to the origin. For example, a 90 x 70 frame with a regX of 50 and a regY of 40 would return:
	 *
	 * 	[x=-50, y=-40, width=90, height=70]
	 *
	 * @method getFrameBounds
	 * @param {Number} frameIndex The index of the frame.
	 * @param {Rectangle} [rectangle] A Rectangle instance to copy the values into. By default a new instance is created.
	 * @return {Rectangle} A Rectangle instance. Returns null if the frame does not exist, or the image is not fully loaded.
	 **/
	p.getFrameBounds = function(frameIndex, rectangle) {
		var frame = this.getFrame(frameIndex);
		return frame ? (rectangle||new createjs.Rectangle()).setValues(-frame.regX, -frame.regY, frame.rect.width, frame.rect.height) : null;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[SpriteSheet]";
	};

	/**
	 * SpriteSheet cannot be cloned. A SpriteSheet can be shared by multiple Sprite instances without cloning it.
	 * @method clone
	 **/
	p.clone = function() {
		throw("SpriteSheet cannot be cloned.")
	};

// private methods:
	/**
	 * @method _parseData
	 * @param {Object} data An object describing the SpriteSheet data.
	 * @protected
	 **/
	p._parseData = function(data) {
		var i,l,o,a;
		if (data == null) { return; }

		this.framerate = data.framerate||0;

		// parse images:
		if (data.images && (l=data.images.length) > 0) {
			a = this._images = [];
			for (i=0; i<l; i++) {
				var img = data.images[i];
				if (typeof img == "string") {
					var src = img;
					img = document.createElement("img");
					img.src = src;
				}
				a.push(img);
				if (!img.getContext && !img.naturalWidth) {
					this._loadCount++;
					this.complete = false;
					(function(o) { img.onload = function() { o._handleImageLoad(); } })(this);
				}
			}
		}

		// parse frames:
		if (data.frames == null) { // nothing
		} else if (data.frames instanceof Array) {
			this._frames = [];
			a = data.frames;
			for (i=0,l=a.length;i<l;i++) {
				var arr = a[i];
				this._frames.push({image:this._images[arr[4]?arr[4]:0], rect:new createjs.Rectangle(arr[0],arr[1],arr[2],arr[3]), regX:arr[5]||0, regY:arr[6]||0 });
			}
		} else {
			o = data.frames;
			this._frameWidth = o.width;
			this._frameHeight = o.height;
			this._regX = o.regX||0;
			this._regY = o.regY||0;
			this._spacing = o.spacing||0;
			this._margin = o.margin||0;
			this._numFrames = o.count;
			if (this._loadCount == 0) { this._calculateFrames(); }
		}

		// parse animations:
		this._animations = [];
		if ((o=data.animations) != null) {
			this._data = {};
			var name;
			for (name in o) {
				var anim = {name:name};
				var obj = o[name];
				if (typeof obj == "number") { // single frame
					a = anim.frames = [obj];
				} else if (obj instanceof Array) { // simple
					if (obj.length == 1) { anim.frames = [obj[0]]; }
					else {
						anim.speed = obj[3];
						anim.next = obj[2];
						a = anim.frames = [];
						for (i=obj[0];i<=obj[1];i++) {
							a.push(i);
						}
					}
				} else { // complex
					anim.speed = obj.speed;
					anim.next = obj.next;
					var frames = obj.frames;
					a = anim.frames = (typeof frames == "number") ? [frames] : frames.slice(0);
				}
				if (anim.next === true || anim.next === undefined) { anim.next = name; } // loop
				if (anim.next === false || (a.length < 2 && anim.next == name)) { anim.next = null; } // stop
				if (!anim.speed) { anim.speed = 1; }
				this._animations.push(name);
				this._data[name] = anim;
			}
		}
	};

	/**
	 * @method _handleImageLoad
	 * @protected
	 **/
	p._handleImageLoad = function() {
		if (--this._loadCount == 0) {
			this._calculateFrames();
			this.complete = true;
			this.dispatchEvent("complete");
		}
	};

	/**
	 * @method _calculateFrames
	 * @protected
	 **/
	p._calculateFrames = function() {
		if (this._frames || this._frameWidth == 0) { return; }

		this._frames = [];

		var maxFrames = this._numFrames || 100000; // if we go over this, something is wrong.
		var frameCount = 0, frameWidth = this._frameWidth, frameHeight = this._frameHeight;
		var spacing = this._spacing, margin = this._margin;
		
		imgLoop:
		for (var i=0, imgs=this._images; i<imgs.length; i++) {
			var img = imgs[i], imgW = img.width, imgH = img.height;

			var y = margin;
			while (y <= imgH-margin-frameHeight) {
				var x = margin;
				while (x <= imgW-margin-frameWidth) {
					if (frameCount >= maxFrames) { break imgLoop; }
					frameCount++;
					this._frames.push({
							image: img,
							rect: new createjs.Rectangle(x, y, frameWidth, frameHeight),
							regX: this._regX,
							regY: this._regY
						});
					x += frameWidth+spacing;
				}
				y += frameHeight+spacing;
			}
		}
		this._numFrames = frameCount;
	};


	createjs.SpriteSheet = createjs.promote(SpriteSheet, "EventDispatcher");
}());

//##############################################################################
// Graphics.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * The Graphics class exposes an easy to use API for generating vector drawing instructions and drawing them to a
	 * specified context. Note that you can use Graphics without any dependency on the EaselJS framework by calling {{#crossLink "Graphics/draw"}}{{/crossLink}}
	 * directly, or it can be used with the {{#crossLink "Shape"}}{{/crossLink}} object to draw vector graphics within the
	 * context of an EaselJS display list.
	 *
	 * There are two approaches to working with Graphics object: calling methods on a Graphics instance (the "Graphics API"), or
	 * instantiating Graphics command objects and adding them to the graphics queue via {{#crossLink "Graphics/append"}}{{/crossLink}}.
	 * The former abstracts the latter, simplifying beginning and ending paths, fills, and strokes.
	 *
	 *      var g = new createjs.Graphics();
	 *      g.setStrokeStyle(1);
	 *      g.beginStroke("#000000");
	 *      g.beginFill("red");
	 *      g.drawCircle(0,0,30);
	 *
	 * All drawing methods in Graphics return the Graphics instance, so they can be chained together. For example,
	 * the following line of code would generate the instructions to draw a rectangle with a red stroke and blue fill:
	 *
	 *      myGraphics.beginStroke("red").beginFill("blue").drawRect(20, 20, 100, 50);
	 *
	 * Each graphics API call generates a command object (see below). The last command to be created can be accessed via
	 * {{#crossLink "Graphics/command:property"}}{{/crossLink}}:
	 *
	 *      var fillCommand = myGraphics.beginFill("red").command;
	 *      // ... later, update the fill style/color:
	 *      fillCommand.style = "blue";
	 *      // or change it to a bitmap fill:
	 *      fillCommand.bitmap(myImage);
	 *
	 * For more direct control of rendering, you can instantiate and append command objects to the graphics queue directly. In this case, you
	 * need to manage path creation manually, and ensure that fill/stroke is applied to a defined path:
	 *
	 *      // start a new path. Graphics.beginCmd is a reusable BeginPath instance:
	 *      myGraphics.append(createjs.Graphics.beginCmd);
	 *      // we need to define the path before applying the fill:
	 *      var circle = new createjs.Graphics.Circle(0,0,30);
	 *      myGraphics.append(circle);
	 *      // fill the path we just defined:
	 *      var fill = new createjs.Graphics.Fill("red");
	 *      myGraphics.append(fill);
	 *
	 * These approaches can be used together, for example to insert a custom command:
	 *
	 *      myGraphics.beginFill("red");
	 *      var customCommand = new CustomSpiralCommand(etc);
	 *      myGraphics.append(customCommand);
	 *      myGraphics.beginFill("blue");
	 *      myGraphics.drawCircle(0, 0, 30);
	 *
	 * See {{#crossLink "Graphics/append"}}{{/crossLink}} for more info on creating custom commands.
	 *
	 * <h4>Tiny API</h4>
	 * The Graphics class also includes a "tiny API", which is one or two-letter methods that are shortcuts for all of the
	 * Graphics methods. These methods are great for creating compact instructions, and is used by the Toolkit for CreateJS
	 * to generate readable code. All tiny methods are marked as protected, so you can view them by enabling protected
	 * descriptions in the docs.
	 *
	 * <table>
	 *     <tr><td><b>Tiny</b></td><td><b>Method</b></td><td><b>Tiny</b></td><td><b>Method</b></td></tr>
	 *     <tr><td>mt</td><td>{{#crossLink "Graphics/moveTo"}}{{/crossLink}} </td>
	 *     <td>lt</td> <td>{{#crossLink "Graphics/lineTo"}}{{/crossLink}}</td></tr>
	 *     <tr><td>a/at</td><td>{{#crossLink "Graphics/arc"}}{{/crossLink}} / {{#crossLink "Graphics/arcTo"}}{{/crossLink}} </td>
	 *     <td>bt</td><td>{{#crossLink "Graphics/bezierCurveTo"}}{{/crossLink}} </td></tr>
	 *     <tr><td>qt</td><td>{{#crossLink "Graphics/quadraticCurveTo"}}{{/crossLink}} (also curveTo)</td>
	 *     <td>r</td><td>{{#crossLink "Graphics/rect"}}{{/crossLink}} </td></tr>
	 *     <tr><td>cp</td><td>{{#crossLink "Graphics/closePath"}}{{/crossLink}} </td>
	 *     <td>c</td><td>{{#crossLink "Graphics/clear"}}{{/crossLink}} </td></tr>
	 *     <tr><td>f</td><td>{{#crossLink "Graphics/beginFill"}}{{/crossLink}} </td>
	 *     <td>lf</td><td>{{#crossLink "Graphics/beginLinearGradientFill"}}{{/crossLink}} </td></tr>
	 *     <tr><td>rf</td><td>{{#crossLink "Graphics/beginRadialGradientFill"}}{{/crossLink}} </td>
	 *     <td>bf</td><td>{{#crossLink "Graphics/beginBitmapFill"}}{{/crossLink}} </td></tr>
	 *     <tr><td>ef</td><td>{{#crossLink "Graphics/endFill"}}{{/crossLink}} </td>
	 *     <td>ss / sd</td><td>{{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} / {{#crossLink "Graphics/setStrokeDash"}}{{/crossLink}} </td></tr>
	 *     <tr><td>s</td><td>{{#crossLink "Graphics/beginStroke"}}{{/crossLink}} </td>
	 *     <td>ls</td><td>{{#crossLink "Graphics/beginLinearGradientStroke"}}{{/crossLink}} </td></tr>
	 *     <tr><td>rs</td><td>{{#crossLink "Graphics/beginRadialGradientStroke"}}{{/crossLink}} </td>
	 *     <td>bs</td><td>{{#crossLink "Graphics/beginBitmapStroke"}}{{/crossLink}} </td></tr>
	 *     <tr><td>es</td><td>{{#crossLink "Graphics/endStroke"}}{{/crossLink}} </td>
	 *     <td>dr</td><td>{{#crossLink "Graphics/drawRect"}}{{/crossLink}} </td></tr>
	 *     <tr><td>rr</td><td>{{#crossLink "Graphics/drawRoundRect"}}{{/crossLink}} </td>
	 *     <td>rc</td><td>{{#crossLink "Graphics/drawRoundRectComplex"}}{{/crossLink}} </td></tr>
	 *     <tr><td>dc</td><td>{{#crossLink "Graphics/drawCircle"}}{{/crossLink}} </td>
	 *     <td>de</td><td>{{#crossLink "Graphics/drawEllipse"}}{{/crossLink}} </td></tr>
	 *     <tr><td>dp</td><td>{{#crossLink "Graphics/drawPolyStar"}}{{/crossLink}} </td>
	 *     <td>p</td><td>{{#crossLink "Graphics/decodePath"}}{{/crossLink}} </td></tr>
	 * </table>
	 *
	 * Here is the above example, using the tiny API instead.
	 *
	 *      myGraphics.s("red").f("blue").r(20, 20, 100, 50);
	 *
	 * @class Graphics
	 * @constructor
	 **/
	function Graphics() {


	// public properties
		/**
		 * Holds a reference to the last command that was created or appended. For example, you could retain a reference
		 * to a Fill command in order to dynamically update the color later by using:
		 * 		myFill = myGraphics.beginFill("red").command;
		 * 		// update color later:
		 * 		myFill.style = "yellow";
		 * @property command
		 * @type Object
		 **/
		this.command = null;


	// private properties
		/**
		 * @property _stroke
		 * @protected
		 * @type {Stroke}
		 **/
		this._stroke = null;

		/**
		 * @property _strokeStyle
		 * @protected
		 * @type {StrokeStyle}
		 **/
		this._strokeStyle = null;
		
		/**
		 * @property _oldStrokeStyle
		 * @protected
		 * @type {StrokeStyle}
		 **/
		this._oldStrokeStyle = null;
		
		/**
		 * @property _strokeDash
		 * @protected
		 * @type {StrokeDash}
		 **/
		this._strokeDash = null;
		
		/**
		 * @property _oldStrokeDash
		 * @protected
		 * @type {StrokeDash}
		 **/
		this._oldStrokeDash = null;

		/**
		 * @property _strokeIgnoreScale
		 * @protected
		 * @type Boolean
		 **/
		this._strokeIgnoreScale = false;

		/**
		 * @property _fill
		 * @protected
		 * @type {Fill}
		 **/
		this._fill = null;

		/**
		 * @property _instructions
		 * @protected
		 * @type {Array}
		 **/
		this._instructions = [];

		/**
		 * Indicates the last instruction index that was committed.
		 * @property _commitIndex
		 * @protected
		 * @type {Number}
		 **/
		this._commitIndex = 0;

		/**
		 * Uncommitted instructions.
		 * @property _activeInstructions
		 * @protected
		 * @type {Array}
		 **/
		this._activeInstructions = [];

		/**
		 * This indicates that there have been changes to the activeInstruction list since the last updateInstructions call.
		 * @property _dirty
		 * @protected
		 * @type {Boolean}
		 * @default false
		 **/
		this._dirty = false;

		/**
		 * Index to draw from if a store operation has happened.
		 * @property _storeIndex
		 * @protected
		 * @type {Number}
		 * @default 0
		 **/
		this._storeIndex = 0;

	// setup:
		this.clear();
	}
	var p = Graphics.prototype;
	var G = Graphics; // shortcut

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// static public methods:
	/**
	 * Returns a CSS compatible color string based on the specified RGB numeric color values in the format
	 * "rgba(255,255,255,1.0)", or if alpha is null then in the format "rgb(255,255,255)". For example,
	 *
	 *      createjs.Graphics.getRGB(50, 100, 150, 0.5);
	 *      // Returns "rgba(50,100,150,0.5)"
	 *
	 * It also supports passing a single hex color value as the first param, and an optional alpha value as the second
	 * param. For example,
	 *
	 *      createjs.Graphics.getRGB(0xFF00FF, 0.2);
	 *      // Returns "rgba(255,0,255,0.2)"
	 *
	 * @method getRGB
	 * @static
	 * @param {Number} r The red component for the color, between 0 and 0xFF (255).
	 * @param {Number} g The green component for the color, between 0 and 0xFF (255).
	 * @param {Number} b The blue component for the color, between 0 and 0xFF (255).
	 * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.
	 * @return {String} A CSS compatible color string based on the specified RGB numeric color values in the format
	 * "rgba(255,255,255,1.0)", or if alpha is null then in the format "rgb(255,255,255)".
	 **/
	Graphics.getRGB = function(r, g, b, alpha) {
		if (r != null && b == null) {
			alpha = g;
			b = r&0xFF;
			g = r>>8&0xFF;
			r = r>>16&0xFF;
		}
		if (alpha == null) {
			return "rgb("+r+","+g+","+b+")";
		} else {
			return "rgba("+r+","+g+","+b+","+alpha+")";
		}
	};

	/**
	 * Returns a CSS compatible color string based on the specified HSL numeric color values in the format "hsla(360,100,100,1.0)",
	 * or if alpha is null then in the format "hsl(360,100,100)".
	 *
	 *      createjs.Graphics.getHSL(150, 100, 70);
	 *      // Returns "hsl(150,100,70)"
	 *
	 * @method getHSL
	 * @static
	 * @param {Number} hue The hue component for the color, between 0 and 360.
	 * @param {Number} saturation The saturation component for the color, between 0 and 100.
	 * @param {Number} lightness The lightness component for the color, between 0 and 100.
	 * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.
	 * @return {String} A CSS compatible color string based on the specified HSL numeric color values in the format
	 * "hsla(360,100,100,1.0)", or if alpha is null then in the format "hsl(360,100,100)".
	 **/
	Graphics.getHSL = function(hue, saturation, lightness, alpha) {
		if (alpha == null) {
			return "hsl("+(hue%360)+","+saturation+"%,"+lightness+"%)";
		} else {
			return "hsla("+(hue%360)+","+saturation+"%,"+lightness+"%,"+alpha+")";
		}
	};


// static properties:
	/**
	 * A reusable instance of {{#crossLink "Graphics/BeginPath"}}{{/crossLink}} to avoid
	 * unnecessary instantiation.
	 * @property beginCmd
	 * @type {Graphics.BeginPath}
	 * @static
	 **/
	 // defined at the bottom of this file.

	/**
	 * Map of Base64 characters to values. Used by {{#crossLink "Graphics/decodePath"}}{{/crossLink}}.
	 * @property BASE_64
	 * @static
	 * @final
	 * @readonly
	 * @type {Object}
	 **/
	Graphics.BASE_64 = {"A":0,"B":1,"C":2,"D":3,"E":4,"F":5,"G":6,"H":7,"I":8,"J":9,"K":10,"L":11,"M":12,"N":13,"O":14,"P":15,"Q":16,"R":17,"S":18,"T":19,"U":20,"V":21,"W":22,"X":23,"Y":24,"Z":25,"a":26,"b":27,"c":28,"d":29,"e":30,"f":31,"g":32,"h":33,"i":34,"j":35,"k":36,"l":37,"m":38,"n":39,"o":40,"p":41,"q":42,"r":43,"s":44,"t":45,"u":46,"v":47,"w":48,"x":49,"y":50,"z":51,"0":52,"1":53,"2":54,"3":55,"4":56,"5":57,"6":58,"7":59,"8":60,"9":61,"+":62,"/":63};

	/**
	 * Maps numeric values for the caps parameter of {{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} to
	 * corresponding string values. This is primarily for use with the tiny API. The mappings are as follows: 0 to
	 * "butt", 1 to "round", and 2 to "square".
	 * For example, to set the line caps to "square":
	 *
	 *      myGraphics.ss(16, 2);
	 *
	 * @property STROKE_CAPS_MAP
	 * @static
	 * @final
	 * @readonly
	 * @type {Array}
	 **/
	Graphics.STROKE_CAPS_MAP = ["butt", "round", "square"];

	/**
	 * Maps numeric values for the joints parameter of {{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} to
	 * corresponding string values. This is primarily for use with the tiny API. The mappings are as follows: 0 to
	 * "miter", 1 to "round", and 2 to "bevel".
	 * For example, to set the line joints to "bevel":
	 *
	 *      myGraphics.ss(16, 0, 2);
	 *
	 * @property STROKE_JOINTS_MAP
	 * @static
	 * @final
	 * @readonly
	 * @type {Array}
	 **/
	Graphics.STROKE_JOINTS_MAP = ["miter", "round", "bevel"];

	/**
	 * @property _ctx
	 * @static
	 * @protected
	 * @type {CanvasRenderingContext2D}
	 **/
	var canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"));
	if (canvas.getContext) {
		Graphics._ctx = canvas.getContext("2d");
		canvas.width = canvas.height = 1;
	}


// getter / setters:
	/**
	 * Use the {{#crossLink "Graphics/instructions:property"}}{{/crossLink}} property instead.
	 * @method getInstructions
	 * @return {Array}
	 * @deprecated
	 **/
	p.getInstructions = function() {
		this._updateInstructions();
		return this._instructions;
	};

	/**
	 * Returns the graphics instructions array. Each entry is a graphics command object (ex. Graphics.Fill, Graphics.Rect)
	 * Modifying the returned array directly is not recommended, and is likely to result in unexpected behaviour.
	 *
	 * This property is mainly intended for introspection of the instructions (ex. for graphics export).
	 * @property instructions
	 * @type {Array}
	 * @readonly
	 **/
	try {
		Object.defineProperties(p, {
			instructions: { get: p.getInstructions }
		});
	} catch (e) {}


// public methods:
	/**
	 * Returns true if this Graphics instance has no drawing commands.
	 * @method isEmpty
	 * @return {Boolean} Returns true if this Graphics instance has no drawing commands.
	 **/
	p.isEmpty = function() {
		return !(this._instructions.length || this._activeInstructions.length);
	};

	/**
	 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
	 * Returns true if the draw was handled (useful for overriding functionality).
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Object} data Optional data that is passed to graphics command exec methods. When called from a Shape instance, the shape passes itself as the data parameter. This can be used by custom graphic commands to insert contextual data.
	 **/
	p.draw = function(ctx, data) {
		this._updateInstructions();
		var instr = this._instructions;
		for (var i=this._storeIndex, l=instr.length; i<l; i++) {
			instr[i].exec(ctx, data);
		}
	};

	/**
	 * Draws only the path described for this Graphics instance, skipping any non-path instructions, including fill and
	 * stroke descriptions. Used for <code>DisplayObject.mask</code> to draw the clipping path, for example.
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method drawAsPath
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 **/
	p.drawAsPath = function(ctx) {
		this._updateInstructions();
		var instr, instrs = this._instructions;
		for (var i=this._storeIndex, l=instrs.length; i<l; i++) {
			// the first command is always a beginPath command.
			if ((instr = instrs[i]).path !== false) { instr.exec(ctx); }
		}
	};


// public methods that map directly to context 2D calls:
	/**
	 * Moves the drawing point to the specified position. A tiny API method "mt" also exists.
	 * @method moveTo
	 * @param {Number} x The x coordinate the drawing point should move to.
	 * @param {Number} y The y coordinate the drawing point should move to.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls).
	 * @chainable
	 **/
	p.moveTo = function(x, y) {
		return this.append(new G.MoveTo(x,y), true);
	};

	/**
	 * Draws a line from the current drawing point to the specified position, which become the new current drawing
	 * point. A tiny API method "lt" also exists.
	 *
	 * For detailed information, read the
	 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#complex-shapes-(paths)">
	 * whatwg spec</a>.
	 * @method lineTo
	 * @param {Number} x The x coordinate the drawing point should draw to.
	 * @param {Number} y The y coordinate the drawing point should draw to.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.lineTo = function(x, y) {
		return this.append(new G.LineTo(x,y));
	};

	/**
	 * Draws an arc with the specified control points and radius.  For detailed information, read the
	 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arcto">
	 * whatwg spec</a>. A tiny API method "at" also exists.
	 * @method arcTo
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} radius
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.arcTo = function(x1, y1, x2, y2, radius) {
		return this.append(new G.ArcTo(x1, y1, x2, y2, radius));
	};

	/**
	 * Draws an arc defined by the radius, startAngle and endAngle arguments, centered at the position (x, y). For
	 * example, to draw a full circle with a radius of 20 centered at (100, 100):
	 *
	 *      arc(100, 100, 20, 0, Math.PI*2);
	 *
	 * For detailed information, read the
	 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc">whatwg spec</a>.
	 * A tiny API method "a" also exists.
	 * @method arc
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} radius
	 * @param {Number} startAngle Measured in radians.
	 * @param {Number} endAngle Measured in radians.
	 * @param {Boolean} anticlockwise
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {
		return this.append(new G.Arc(x, y, radius, startAngle, endAngle, anticlockwise));
	};

	/**
	 * Draws a quadratic curve from the current drawing point to (x, y) using the control point (cpx, cpy). For detailed
	 * information, read the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto">
	 * whatwg spec</a>. A tiny API method "qt" also exists.
	 * @method quadraticCurveTo
	 * @param {Number} cpx
	 * @param {Number} cpy
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.quadraticCurveTo = function(cpx, cpy, x, y) {
		return this.append(new G.QuadraticCurveTo(cpx, cpy, x, y));
	};

	/**
	 * Draws a bezier curve from the current drawing point to (x, y) using the control points (cp1x, cp1y) and (cp2x,
	 * cp2y). For detailed information, read the
	 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-beziercurveto">
	 * whatwg spec</a>. A tiny API method "bt" also exists.
	 * @method bezierCurveTo
	 * @param {Number} cp1x
	 * @param {Number} cp1y
	 * @param {Number} cp2x
	 * @param {Number} cp2y
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
		return this.append(new G.BezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y));
	};

	/**
	 * Draws a rectangle at (x, y) with the specified width and height using the current fill and/or stroke.
	 * For detailed information, read the
	 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-rect">
	 * whatwg spec</a>. A tiny API method "r" also exists.
	 * @method rect
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w Width of the rectangle
	 * @param {Number} h Height of the rectangle
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.rect = function(x, y, w, h) {
		return this.append(new G.Rect(x, y, w, h));
	};

	/**
	 * Closes the current path, effectively drawing a line from the current drawing point to the first drawing point specified
	 * since the fill or stroke was last set. A tiny API method "cp" also exists.
	 * @method closePath
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.closePath = function() {
		return this._activeInstructions.length ? this.append(new G.ClosePath()) : this;
	};


// public methods that roughly map to Flash graphics APIs:
	/**
	 * Clears all drawing instructions, effectively resetting this Graphics instance. Any line and fill styles will need
	 * to be redefined to draw shapes following a clear call. A tiny API method "c" also exists.
	 * @method clear
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.clear = function() {
		this._instructions.length = this._activeInstructions.length = this._commitIndex = 0;
		this._strokeStyle = this._oldStrokeStyle = this._stroke = this._fill = this._strokeDash = this._oldStrokeDash = null;
		this._dirty = this._strokeIgnoreScale = false;
		return this;
	};

	/**
	 * Begins a fill with the specified color. This ends the current sub-path. A tiny API method "f" also exists.
	 * @method beginFill
	 * @param {String} color A CSS compatible color value (ex. "red", "#FF0000", or "rgba(255,0,0,0.5)"). Setting to
	 * null will result in no fill.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginFill = function(color) {
		return this._setFill(color ? new G.Fill(color) : null);
	};

	/**
	 * Begins a linear gradient fill defined by the line (x0, y0) to (x1, y1). This ends the current sub-path. For
	 * example, the following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a
	 * square to display it:
	 *
	 *      myGraphics.beginLinearGradientFill(["#000","#FFF"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);
	 *
	 * A tiny API method "lf" also exists.
	 * @method beginLinearGradientFill
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define a gradient
	 * drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw
	 * the first color to 10% then interpolating to the second color at 90%.
	 * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
	 * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginLinearGradientFill = function(colors, ratios, x0, y0, x1, y1) {
		return this._setFill(new G.Fill().linearGradient(colors, ratios, x0, y0, x1, y1));
	};

	/**
	 * Begins a radial gradient fill. This ends the current sub-path. For example, the following code defines a red to
	 * blue radial gradient centered at (100, 100), with a radius of 50, and draws a circle to display it:
	 *
	 *      myGraphics.beginRadialGradientFill(["#F00","#00F"], [0, 1], 100, 100, 0, 100, 100, 50).drawCircle(100, 100, 50);
	 *
	 * A tiny API method "rf" also exists.
	 * @method beginRadialGradientFill
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
	 * a gradient drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
	 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
	 * @param {Number} x0 Center position of the inner circle that defines the gradient.
	 * @param {Number} y0 Center position of the inner circle that defines the gradient.
	 * @param {Number} r0 Radius of the inner circle that defines the gradient.
	 * @param {Number} x1 Center position of the outer circle that defines the gradient.
	 * @param {Number} y1 Center position of the outer circle that defines the gradient.
	 * @param {Number} r1 Radius of the outer circle that defines the gradient.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginRadialGradientFill = function(colors, ratios, x0, y0, r0, x1, y1, r1) {
		return this._setFill(new G.Fill().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));
	};

	/**
	 * Begins a pattern fill using the specified image. This ends the current sub-path. A tiny API method "bf" also
	 * exists.
	 * @method beginBitmapFill
	 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
	 * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.
	 * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of "repeat",
	 * "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat". Note that Firefox does not support "repeat-x" or
	 * "repeat-y" (latest tests were in FF 20.0), and will default to "repeat".
	 * @param {Matrix2D} matrix Optional. Specifies a transformation matrix for the bitmap fill. This transformation
	 * will be applied relative to the parent transform.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginBitmapFill = function(image, repetition, matrix) {
		return this._setFill(new G.Fill(null,matrix).bitmap(image, repetition));
	};

	/**
	 * Ends the current sub-path, and begins a new one with no fill. Functionally identical to <code>beginFill(null)</code>.
	 * A tiny API method "ef" also exists.
	 * @method endFill
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.endFill = function() {
		return this.beginFill();
	};

	/**
	 * Sets the stroke style. Like all drawing methods, this can be chained, so you can define
	 * the stroke style and color in a single line of code like so:
	 *
	 * 	myGraphics.setStrokeStyle(8,"round").beginStroke("#F00");
	 *
	 * A tiny API method "ss" also exists.
	 * @method setStrokeStyle
	 * @param {Number} thickness The width of the stroke.
	 * @param {String | Number} [caps=0] Indicates the type of caps to use at the end of lines. One of butt,
	 * round, or square. Defaults to "butt". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with
	 * the tiny API.
	 * @param {String | Number} [joints=0] Specifies the type of joints that should be used where two lines meet.
	 * One of bevel, round, or miter. Defaults to "miter". Also accepts the values 0 (miter), 1 (round), and 2 (bevel)
	 * for use with the tiny API.
	 * @param {Number} [miterLimit=10] If joints is set to "miter", then you can specify a miter limit ratio which
	 * controls at what point a mitered joint will be clipped.
	 * @param {Boolean} [ignoreScale=false] If true, the stroke will be drawn at the specified thickness regardless
	 * of active transformations.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.setStrokeStyle = function(thickness, caps, joints, miterLimit, ignoreScale) {
		this._updateInstructions(true);
		this._strokeStyle = this.command = new G.StrokeStyle(thickness, caps, joints, miterLimit, ignoreScale);

		// ignoreScale lives on Stroke, not StrokeStyle, so we do a little trickery:
		if (this._stroke) { this._stroke.ignoreScale = ignoreScale; }
		this._strokeIgnoreScale = ignoreScale;
		return this;
	};
	
	/**
	 * Sets or clears the stroke dash pattern.
	 *
	 * 	myGraphics.setStrokeDash([20, 10], 0);
	 *
	 * A tiny API method `sd` also exists.
	 * @method setStrokeDash
	 * @param {Array} [segments] An array specifying the dash pattern, alternating between line and gap.
	 * For example, `[20,10]` would create a pattern of 20 pixel lines with 10 pixel gaps between them.
	 * Passing null or an empty array will clear the existing stroke dash.
	 * @param {Number} [offset=0] The offset of the dash pattern. For example, you could increment this value to create a "marching ants" effect.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.setStrokeDash = function(segments, offset) {
		this._updateInstructions(true);
		this._strokeDash = this.command = new G.StrokeDash(segments, offset);
		return this;
	};

	/**
	 * Begins a stroke with the specified color. This ends the current sub-path. A tiny API method "s" also exists.
	 * @method beginStroke
	 * @param {String} color A CSS compatible color value (ex. "#FF0000", "red", or "rgba(255,0,0,0.5)"). Setting to
	 * null will result in no stroke.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginStroke = function(color) {
		return this._setStroke(color ? new G.Stroke(color) : null);
	};

	/**
	 * Begins a linear gradient stroke defined by the line (x0, y0) to (x1, y1). This ends the current sub-path. For
	 * example, the following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a
	 * square to display it:
	 *
	 *      myGraphics.setStrokeStyle(10).
	 *          beginLinearGradientStroke(["#000","#FFF"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);
	 *
	 * A tiny API method "ls" also exists.
	 * @method beginLinearGradientStroke
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
	 * a gradient drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
	 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
	 * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
	 * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginLinearGradientStroke = function(colors, ratios, x0, y0, x1, y1) {
		return this._setStroke(new G.Stroke().linearGradient(colors, ratios, x0, y0, x1, y1));
	};

	/**
	 * Begins a radial gradient stroke. This ends the current sub-path. For example, the following code defines a red to
	 * blue radial gradient centered at (100, 100), with a radius of 50, and draws a rectangle to display it:
	 *
	 *      myGraphics.setStrokeStyle(10)
	 *          .beginRadialGradientStroke(["#F00","#00F"], [0, 1], 100, 100, 0, 100, 100, 50)
	 *          .drawRect(50, 90, 150, 110);
	 *
	 * A tiny API method "rs" also exists.
	 * @method beginRadialGradientStroke
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
	 * a gradient drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
	 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color
	 * to 100%.
	 * @param {Number} x0 Center position of the inner circle that defines the gradient.
	 * @param {Number} y0 Center position of the inner circle that defines the gradient.
	 * @param {Number} r0 Radius of the inner circle that defines the gradient.
	 * @param {Number} x1 Center position of the outer circle that defines the gradient.
	 * @param {Number} y1 Center position of the outer circle that defines the gradient.
	 * @param {Number} r1 Radius of the outer circle that defines the gradient.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginRadialGradientStroke = function(colors, ratios, x0, y0, r0, x1, y1, r1) {
		return this._setStroke(new G.Stroke().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));
	};

	/**
	 * Begins a pattern fill using the specified image. This ends the current sub-path. Note that unlike bitmap fills,
	 * strokes do not currently support a matrix parameter due to limitations in the canvas API. A tiny API method "bs"
	 * also exists.
	 * @method beginBitmapStroke
	 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
	 * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.
	 * @param {String} [repetition=repeat] Optional. Indicates whether to repeat the image in the fill area. One of
	 * "repeat", "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat".
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginBitmapStroke = function(image, repetition) {
		// NOTE: matrix is not supported for stroke because transforms on strokes also affect the drawn stroke width.
		return this._setStroke(new G.Stroke().bitmap(image, repetition));
	};

	/**
	 * Ends the current sub-path, and begins a new one with no stroke. Functionally identical to <code>beginStroke(null)</code>.
	 * A tiny API method "es" also exists.
	 * @method endStroke
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.endStroke = function() {
		return this.beginStroke();
	};

	/**
	 * Maps the familiar ActionScript <code>curveTo()</code> method to the functionally similar {{#crossLink "Graphics/quadraticCurveTo"}}{{/crossLink}}
	 * method.
	 * @method quadraticCurveTo
	 * @param {Number} cpx
	 * @param {Number} cpy
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.curveTo = p.quadraticCurveTo;

	/**
	 *
	 * Maps the familiar ActionScript <code>drawRect()</code> method to the functionally similar {{#crossLink "Graphics/rect"}}{{/crossLink}}
	 * method.
	 * @method drawRect
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w Width of the rectangle
	 * @param {Number} h Height of the rectangle
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.drawRect = p.rect;

	/**
	 * Draws a rounded rectangle with all corners with the specified radius.
	 * @method drawRoundRect
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w
	 * @param {Number} h
	 * @param {Number} radius Corner radius.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.drawRoundRect = function(x, y, w, h, radius) {
		return this.drawRoundRectComplex(x, y, w, h, radius, radius, radius, radius);
	};

	/**
	 * Draws a rounded rectangle with different corner radii. Supports positive and negative corner radii. A tiny API
	 * method "rc" also exists.
	 * @method drawRoundRectComplex
	 * @param {Number} x The horizontal coordinate to draw the round rect.
	 * @param {Number} y The vertical coordinate to draw the round rect.
	 * @param {Number} w The width of the round rect.
	 * @param {Number} h The height of the round rect.
	 * @param {Number} radiusTL Top left corner radius.
	 * @param {Number} radiusTR Top right corner radius.
	 * @param {Number} radiusBR Bottom right corner radius.
	 * @param {Number} radiusBL Bottom left corner radius.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.drawRoundRectComplex = function(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {
		return this.append(new G.RoundRect(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL));
	};

	/**
	 * Draws a circle with the specified radius at (x, y).
	 *
	 *      var g = new createjs.Graphics();
	 *	    g.setStrokeStyle(1);
	 *	    g.beginStroke(createjs.Graphics.getRGB(0,0,0));
	 *	    g.beginFill(createjs.Graphics.getRGB(255,0,0));
	 *	    g.drawCircle(0,0,3);
	 *
	 *	    var s = new createjs.Shape(g);
	 *		s.x = 100;
	 *		s.y = 100;
	 *
	 *	    stage.addChild(s);
	 *	    stage.update();
	 *
	 * A tiny API method "dc" also exists.
	 * @method drawCircle
	 * @param {Number} x x coordinate center point of circle.
	 * @param {Number} y y coordinate center point of circle.
	 * @param {Number} radius Radius of circle.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.drawCircle = function(x, y, radius) {
		return this.append(new G.Circle(x, y, radius));
	};

	/**
	 * Draws an ellipse (oval) with a specified width (w) and height (h). Similar to {{#crossLink "Graphics/drawCircle"}}{{/crossLink}},
	 * except the width and height can be different. A tiny API method "de" also exists.
	 * @method drawEllipse
	 * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}
	 * which draws from center.
	 * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}
	 * which draws from the center.
	 * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this
	 * number.
	 * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.drawEllipse = function(x, y, w, h) {
		return this.append(new G.Ellipse(x, y, w, h));
	};

	/**
	 * Draws a star if pointSize is greater than 0, or a regular polygon if pointSize is 0 with the specified number of
	 * points. For example, the following code will draw a familiar 5 pointed star shape centered at 100, 100 and with a
	 * radius of 50:
	 *
	 *      myGraphics.beginFill("#FF0").drawPolyStar(100, 100, 50, 5, 0.6, -90);
	 *      // Note: -90 makes the first point vertical
	 *
	 * A tiny API method "dp" also exists.
	 *
	 * @method drawPolyStar
	 * @param {Number} x Position of the center of the shape.
	 * @param {Number} y Position of the center of the shape.
	 * @param {Number} radius The outer radius of the shape.
	 * @param {Number} sides The number of points on the star or sides on the polygon.
	 * @param {Number} pointSize The depth or "pointy-ness" of the star points. A pointSize of 0 will draw a regular
	 * polygon (no points), a pointSize of 1 will draw nothing because the points are infinitely pointy.
	 * @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point
	 * directly to the right of the center.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.drawPolyStar = function(x, y, radius, sides, pointSize, angle) {
		return this.append(new G.PolyStar(x, y, radius, sides, pointSize, angle));
	};

	// TODO: deprecated.
	/**
	 * Removed in favour of using custom command objects with {{#crossLink "Graphics/append"}}{{/crossLink}}.
	 * @method inject
	 * @deprecated
	 **/

	/**
	 * Appends a graphics command object to the graphics queue. Command objects expose an "exec" method
	 * that accepts two parameters: the Context2D to operate on, and an arbitrary data object passed into
	 * {{#crossLink "Graphics/draw"}}{{/crossLink}}. The latter will usually be the Shape instance that called draw.
	 *
	 * This method is used internally by Graphics methods, such as drawCircle, but can also be used directly to insert
	 * built-in or custom graphics commands. For example:
	 *
	 * 		// attach data to our shape, so we can access it during the draw:
	 * 		myShape.color = "red";
	 *
	 * 		// append a Circle command object:
	 * 		myShape.graphics.append(new Graphics.Circle(50, 50, 30));
	 *
	 * 		// append a custom command object with an exec method that sets the fill style
	 * 		// based on the shape's data, and then fills the circle.
	 * 		myShape.graphics.append({exec:function(ctx, shape) {
	 * 			ctx.fillStyle = shape.color;
	 * 			ctx.fill();
	 * 		}});
	 *
	 * @method append
	 * @param {Object} command A graphics command object exposing an "exec" method.
	 * @param {boolean} clean The clean param is primarily for internal use. A value of true indicates that a command does not generate a path that should be stroked or filled.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.append = function(command, clean) {
		this._activeInstructions.push(command);
		this.command = command;
		if (!clean) { this._dirty = true; }
		return this;
	};

	/**
	 * Decodes a compact encoded path string into a series of draw instructions.
	 * This format is not intended to be human readable, and is meant for use by authoring tools.
	 * The format uses a base64 character set, with each character representing 6 bits, to define a series of draw
	 * commands.
	 *
	 * Each command is comprised of a single "header" character followed by a variable number of alternating x and y
	 * position values. Reading the header bits from left to right (most to least significant): bits 1 to 3 specify the
	 * type of operation (0-moveTo, 1-lineTo, 2-quadraticCurveTo, 3-bezierCurveTo, 4-closePath, 5-7 unused). Bit 4
	 * indicates whether position values use 12 bits (2 characters) or 18 bits (3 characters), with a one indicating the
	 * latter. Bits 5 and 6 are currently unused.
	 *
	 * Following the header is a series of 0 (closePath), 2 (moveTo, lineTo), 4 (quadraticCurveTo), or 6 (bezierCurveTo)
	 * parameters. These parameters are alternating x/y positions represented by 2 or 3 characters (as indicated by the
	 * 4th bit in the command char). These characters consist of a 1 bit sign (1 is negative, 0 is positive), followed
	 * by an 11 (2 char) or 17 (3 char) bit integer value. All position values are in tenths of a pixel. Except in the
	 * case of move operations which are absolute, this value is a delta from the previous x or y position (as
	 * appropriate).
	 *
	 * For example, the string "A3cAAMAu4AAA" represents a line starting at -150,0 and ending at 150,0.
	 * <br />A - bits 000000. First 3 bits (000) indicate a moveTo operation. 4th bit (0) indicates 2 chars per
	 * parameter.
	 * <br />n0 - 110111011100. Absolute x position of -150.0px. First bit indicates a negative value, remaining bits
	 * indicate 1500 tenths of a pixel.
	 * <br />AA - 000000000000. Absolute y position of 0.
	 * <br />I - 001100. First 3 bits (001) indicate a lineTo operation. 4th bit (1) indicates 3 chars per parameter.
	 * <br />Au4 - 000000101110111000. An x delta of 300.0px, which is added to the previous x value of -150.0px to
	 * provide an absolute position of +150.0px.
	 * <br />AAA - 000000000000000000. A y delta value of 0.
	 *
	 * A tiny API method "p" also exists.
	 * @method decodePath
	 * @param {String} str The path string to decode.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.decodePath = function(str) {
		var instructions = [this.moveTo, this.lineTo, this.quadraticCurveTo, this.bezierCurveTo, this.closePath];
		var paramCount = [2, 2, 4, 6, 0];
		var i=0, l=str.length;
		var params = [];
		var x=0, y=0;
		var base64 = Graphics.BASE_64;

		while (i<l) {
			var c = str.charAt(i);
			var n = base64[c];
			var fi = n>>3; // highest order bits 1-3 code for operation.
			var f = instructions[fi];
			// check that we have a valid instruction & that the unused bits are empty:
			if (!f || (n&3)) { throw("bad path data (@"+i+"): "+c); }
			var pl = paramCount[fi];
			if (!fi) { x=y=0; } // move operations reset the position.
			params.length = 0;
			i++;
			var charCount = (n>>2&1)+2;  // 4th header bit indicates number size for this operation.
			for (var p=0; p<pl; p++) {
				var num = base64[str.charAt(i)];
				var sign = (num>>5) ? -1 : 1;
				num = ((num&31)<<6)|(base64[str.charAt(i+1)]);
				if (charCount == 3) { num = (num<<6)|(base64[str.charAt(i+2)]); }
				num = sign*num/10;
				if (p%2) { x = (num += x); }
				else { y = (num += y); }
				params[p] = num;
				i += charCount;
			}
			f.apply(this,params);
		}
		return this;
	};

	/**
	 * Stores all graphics commands so they won't be executed in future draws. Calling store() a second time adds to
	 * the existing store. This also affects `drawAsPath()`.
	 *
	 * This is useful in cases where you are creating vector graphics in an iterative manner (ex. generative art), so
	 * that only new graphics need to be drawn (which can provide huge performance benefits), but you wish to retain all
	 * of the vector instructions for later use (ex. scaling, modifying, or exporting).
	 *
	 * Note that calling store() will force the active path (if any) to be ended in a manner similar to changing
	 * the fill or stroke.
	 *
	 * For example, consider a application where the user draws lines with the mouse. As each line segment (or collection of
	 * segments) are added to a Shape, it can be rasterized using {{#crossLink "DisplayObject/updateCache"}}{{/crossLink}},
	 * and then stored, so that it can be redrawn at a different scale when the application is resized, or exported to SVG.
	 *
	 * 	// set up cache:
	 * 	myShape.cache(0,0,500,500,scale);
	 *
	 * 	// when the user drags, draw a new line:
	 * 	myShape.graphics.moveTo(oldX,oldY).lineTo(newX,newY);
	 * 	// then draw it into the existing cache:
	 * 	myShape.updateCache("source-over");
	 * 	// store the new line, so it isn't redrawn next time:
	 * 	myShape.store();
	 *
	 * 	// then, when the window resizes, we can re-render at a different scale:
	 * 	// first, unstore all our lines:
	 * 	myShape.unstore();
	 * 	// then cache using the new scale:
	 * 	myShape.cache(0,0,500,500,newScale);
	 * 	// finally, store the existing commands again:
	 * 	myShape.store();
	 *
	 * @method store
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.store = function() {
		this._updateInstructions(true);
		this._storeIndex = this._instructions.length;
		return this;
	};

	/**
	 * Unstores any graphics commands that were previously stored using {{#crossLink "Graphics/store"}}{{/crossLink}}
	 * so that they will be executed in subsequent draw calls.
	 *
	 * @method unstore
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.unstore = function() {
		this._storeIndex = 0;
		return this;
	};

	/**
	 * Returns a clone of this Graphics instance. Note that the individual command objects are not cloned.
	 * @method clone
	 * @return {Graphics} A clone of the current Graphics instance.
	 **/
	p.clone = function() {
		var o = new Graphics();
		o.command = this.command;
		o._stroke = this._stroke;
		o._strokeStyle = this._strokeStyle;
		o._strokeDash = this._strokeDash;
		o._strokeIgnoreScale = this._strokeIgnoreScale;
		o._fill = this._fill;
		o._instructions = this._instructions.slice();
		o._commitIndex = this._commitIndex;
		o._activeInstructions = this._activeInstructions.slice();
		o._dirty = this._dirty;
		o._storeIndex = this._storeIndex;
		return o;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Graphics]";
	};


// tiny API:
	/**
	 * Shortcut to moveTo.
	 * @method mt
	 * @param {Number} x The x coordinate the drawing point should move to.
	 * @param {Number} y The y coordinate the drawing point should move to.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls).
	 * @chainable
	 * @protected
	 **/
	p.mt = p.moveTo;

	/**
	 * Shortcut to lineTo.
	 * @method lt
	 * @param {Number} x The x coordinate the drawing point should draw to.
	 * @param {Number} y The y coordinate the drawing point should draw to.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.lt = p.lineTo;

	/**
	 * Shortcut to arcTo.
	 * @method at
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} radius
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.at = p.arcTo;

	/**
	 * Shortcut to bezierCurveTo.
	 * @method bt
	 * @param {Number} cp1x
	 * @param {Number} cp1y
	 * @param {Number} cp2x
	 * @param {Number} cp2y
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.bt = p.bezierCurveTo;

	/**
	 * Shortcut to quadraticCurveTo / curveTo.
	 * @method qt
	 * @param {Number} cpx
	 * @param {Number} cpy
	 * @param {Number} x
	 * @param {Number} y
	 * @protected
	 * @chainable
	 **/
	p.qt = p.quadraticCurveTo;

	/**
	 * Shortcut to arc.
	 * @method a
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} radius
	 * @param {Number} startAngle Measured in radians.
	 * @param {Number} endAngle Measured in radians.
	 * @param {Boolean} anticlockwise
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @protected
	 * @chainable
	 **/
	p.a = p.arc;

	/**
	 * Shortcut to rect.
	 * @method r
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w Width of the rectangle
	 * @param {Number} h Height of the rectangle
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.r = p.rect;

	/**
	 * Shortcut to closePath.
	 * @method cp
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.cp = p.closePath;

	/**
	 * Shortcut to clear.
	 * @method c
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.c = p.clear;

	/**
	 * Shortcut to beginFill.
	 * @method f
	 * @param {String} color A CSS compatible color value (ex. "red", "#FF0000", or "rgba(255,0,0,0.5)"). Setting to
	 * null will result in no fill.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.f = p.beginFill;

	/**
	 * Shortcut to beginLinearGradientFill.
	 * @method lf
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define a gradient
	 * drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw
	 * the first color to 10% then interpolating to the second color at 90%.
	 * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
	 * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.lf = p.beginLinearGradientFill;

	/**
	 * Shortcut to beginRadialGradientFill.
	 * @method rf
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
	 * a gradient drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
	 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
	 * @param {Number} x0 Center position of the inner circle that defines the gradient.
	 * @param {Number} y0 Center position of the inner circle that defines the gradient.
	 * @param {Number} r0 Radius of the inner circle that defines the gradient.
	 * @param {Number} x1 Center position of the outer circle that defines the gradient.
	 * @param {Number} y1 Center position of the outer circle that defines the gradient.
	 * @param {Number} r1 Radius of the outer circle that defines the gradient.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.rf = p.beginRadialGradientFill;

	/**
	 * Shortcut to beginBitmapFill.
	 * @method bf
	 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
	 * as the pattern.
	 * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of "repeat",
	 * "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat". Note that Firefox does not support "repeat-x" or
	 * "repeat-y" (latest tests were in FF 20.0), and will default to "repeat".
	 * @param {Matrix2D} matrix Optional. Specifies a transformation matrix for the bitmap fill. This transformation
	 * will be applied relative to the parent transform.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.bf = p.beginBitmapFill;

	/**
	 * Shortcut to endFill.
	 * @method ef
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.ef = p.endFill;

	/**
	 * Shortcut to setStrokeStyle.
	 * @method ss
	 * @param {Number} thickness The width of the stroke.
	 * @param {String | Number} [caps=0] Indicates the type of caps to use at the end of lines. One of butt,
	 * round, or square. Defaults to "butt". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with
	 * the tiny API.
	 * @param {String | Number} [joints=0] Specifies the type of joints that should be used where two lines meet.
	 * One of bevel, round, or miter. Defaults to "miter". Also accepts the values 0 (miter), 1 (round), and 2 (bevel)
	 * for use with the tiny API.
	 * @param {Number} [miterLimit=10] If joints is set to "miter", then you can specify a miter limit ratio which
	 * controls at what point a mitered joint will be clipped.
	 * @param {Boolean} [ignoreScale=false] If true, the stroke will be drawn at the specified thickness regardless
	 * of active transformations.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.ss = p.setStrokeStyle;
	
	/**
	 * Shortcut to setStrokeDash.
	 * @method sd
	 * @param {Array} [segments] An array specifying the dash pattern, alternating between line and gap.
	 * For example, [20,10] would create a pattern of 20 pixel lines with 10 pixel gaps between them.
	 * Passing null or an empty array will clear any existing dash.
	 * @param {Number} [offset=0] The offset of the dash pattern. For example, you could increment this value to create a "marching ants" effect.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.sd = p.setStrokeDash;

	/**
	 * Shortcut to beginStroke.
	 * @method s
	 * @param {String} color A CSS compatible color value (ex. "#FF0000", "red", or "rgba(255,0,0,0.5)"). Setting to
	 * null will result in no stroke.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.s = p.beginStroke;

	/**
	 * Shortcut to beginLinearGradientStroke.
	 * @method ls
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
	 * a gradient drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
	 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
	 * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
	 * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.ls = p.beginLinearGradientStroke;

	/**
	 * Shortcut to beginRadialGradientStroke.
	 * @method rs
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
	 * a gradient drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
	 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color
	 * to 100%.
	 * @param {Number} x0 Center position of the inner circle that defines the gradient.
	 * @param {Number} y0 Center position of the inner circle that defines the gradient.
	 * @param {Number} r0 Radius of the inner circle that defines the gradient.
	 * @param {Number} x1 Center position of the outer circle that defines the gradient.
	 * @param {Number} y1 Center position of the outer circle that defines the gradient.
	 * @param {Number} r1 Radius of the outer circle that defines the gradient.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.rs = p.beginRadialGradientStroke;

	/**
	 * Shortcut to beginBitmapStroke.
	 * @method bs
	 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
	 * as the pattern.
	 * @param {String} [repetition=repeat] Optional. Indicates whether to repeat the image in the fill area. One of
	 * "repeat", "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat".
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.bs = p.beginBitmapStroke;

	/**
	 * Shortcut to endStroke.
	 * @method es
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.es = p.endStroke;

	/**
	 * Shortcut to drawRect.
	 * @method dr
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w Width of the rectangle
	 * @param {Number} h Height of the rectangle
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.dr = p.drawRect;

	/**
	 * Shortcut to drawRoundRect.
	 * @method rr
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w
	 * @param {Number} h
	 * @param {Number} radius Corner radius.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.rr = p.drawRoundRect;

	/**
	 * Shortcut to drawRoundRectComplex.
	 * @method rc
	 * @param {Number} x The horizontal coordinate to draw the round rect.
	 * @param {Number} y The vertical coordinate to draw the round rect.
	 * @param {Number} w The width of the round rect.
	 * @param {Number} h The height of the round rect.
	 * @param {Number} radiusTL Top left corner radius.
	 * @param {Number} radiusTR Top right corner radius.
	 * @param {Number} radiusBR Bottom right corner radius.
	 * @param {Number} radiusBL Bottom left corner radius.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.rc = p.drawRoundRectComplex;

	/**
	 * Shortcut to drawCircle.
	 * @method dc
	 * @param {Number} x x coordinate center point of circle.
	 * @param {Number} y y coordinate center point of circle.
	 * @param {Number} radius Radius of circle.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.dc = p.drawCircle;

	/**
	 * Shortcut to drawEllipse.
	 * @method de
	 * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}
	 * which draws from center.
	 * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}
	 * which draws from the center.
	 * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this
	 * number.
	 * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.de = p.drawEllipse;

	/**
	 * Shortcut to drawPolyStar.
	 * @method dp
	 * @param {Number} x Position of the center of the shape.
	 * @param {Number} y Position of the center of the shape.
	 * @param {Number} radius The outer radius of the shape.
	 * @param {Number} sides The number of points on the star or sides on the polygon.
	 * @param {Number} pointSize The depth or "pointy-ness" of the star points. A pointSize of 0 will draw a regular
	 * polygon (no points), a pointSize of 1 will draw nothing because the points are infinitely pointy.
	 * @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point
	 * directly to the right of the center.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.dp = p.drawPolyStar;

	/**
	 * Shortcut to decodePath.
	 * @method p
	 * @param {String} str The path string to decode.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.p = p.decodePath;


// private methods:
	/**
	 * @method _updateInstructions
	 * @param commit
	 * @protected
	 **/
	p._updateInstructions = function(commit) {
		var instr = this._instructions, active = this._activeInstructions, commitIndex = this._commitIndex;

		if (this._dirty && active.length) {
			instr.length = commitIndex; // remove old, uncommitted commands
			instr.push(Graphics.beginCmd);

			var l = active.length, ll = instr.length;
			instr.length = ll+l;
			for (var i=0; i<l; i++) { instr[i+ll] = active[i]; }

			if (this._fill) { instr.push(this._fill); }
			if (this._stroke) {
				// doesn't need to be re-applied if it hasn't changed.
				if (this._strokeDash !== this._oldStrokeDash) {
					this._oldStrokeDash = this._strokeDash;
					instr.push(this._strokeDash);
				}
				if (this._strokeStyle !== this._oldStrokeStyle) {
					this._oldStrokeStyle = this._strokeStyle;
					instr.push(this._strokeStyle);
				}
				instr.push(this._stroke);
			}

			this._dirty = false;
		}

		if (commit) {
			active.length = 0;
			this._commitIndex = instr.length;
		}
	};

	/**
	 * @method _setFill
	 * @param fill
	 * @protected
	 **/
	p._setFill = function(fill) {
		this._updateInstructions(true);
		this.command = this._fill = fill;
		return this;
	};

	/**
	 * @method _setStroke
	 * @param stroke
	 * @protected
	 **/
	p._setStroke = function(stroke) {
		this._updateInstructions(true);
		if (this.command = this._stroke = stroke) {
			stroke.ignoreScale = this._strokeIgnoreScale;
		}
		return this;
	};

// Command Objects:
	/**
	 * @namespace Graphics
	 */
	/**
	 * Graphics command object. See {{#crossLink "Graphics/lineTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information. See {{#crossLink "Graphics"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class LineTo
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.LineTo = function(x, y) {
		this.x = x; this.y = y;
	}).prototype.exec = function(ctx) { ctx.lineTo(this.x,this.y); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/moveTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class MoveTo
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.MoveTo = function(x, y) {
		this.x = x; this.y = y;
	}).prototype.exec = function(ctx) { ctx.moveTo(this.x, this.y); };


	/**
	 * Graphics command object. See {{#crossLink "Graphics/arcTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class ArcTo
	 * @constructor
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} radius
	 **/
	/**
	 * @property x1
	 * @type Number
	 */
	/**
	 * @property y1
	 * @type Number
	 */
	/**
	 * @property x2
	 * @type Number
	 */
	/**
	 * @property y2
	 * @type Number
	 */
	/**
	 * @property radius
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.ArcTo = function(x1, y1, x2, y2, radius) {
		this.x1 = x1; this.y1 = y1;
		this.x2 = x2; this.y2 = y2;
		this.radius = radius;
	}).prototype.exec = function(ctx) { ctx.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/arc"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class Arc
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} radius
	 * @param {Number} startAngle
	 * @param {Number} endAngle
	 * @param {Number} anticlockwise
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @property radius
	 * @type Number
	 */
	/**
	 * @property startAngle
	 * @type Number
	 */
	/**
	 * @property endAngle
	 * @type Number
	 */
	/**
	 * @property anticlockwise
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.Arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {
		this.x = x; this.y = y;
		this.radius = radius;
		this.startAngle = startAngle; this.endAngle = endAngle;
		this.anticlockwise = !!anticlockwise;
	}).prototype.exec = function(ctx) { ctx.arc(this.x, this.y, this.radius, this.startAngle, this.endAngle, this.anticlockwise); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/quadraticCurveTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class QuadraticCurveTo
	 * @constructor
	 * @param {Number} cpx
	 * @param {Number} cpy
	 * @param {Number} x
	 * @param {Number} y
	 **/
	/**
	 * @property cpx
	 * @type Number
	 */
	/**
	 * @property cpy
	 * @type Number
	 */
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.QuadraticCurveTo = function(cpx, cpy, x, y) {
		this.cpx = cpx; this.cpy = cpy;
		this.x = x; this.y = y;
	}).prototype.exec = function(ctx) { ctx.quadraticCurveTo(this.cpx, this.cpy, this.x, this.y); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/bezierCurveTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class BezierCurveTo
	 * @constructor
	 * @param {Number} cp1x
	 * @param {Number} cp1y
	 * @param {Number} cp2x
	 * @param {Number} cp2y
	 * @param {Number} x
	 * @param {Number} y
	 **/
	/**
	 * @property cp1x
	 * @type Number
	 */
	/**
	 * @property cp1y
	 * @type Number
	 */
	/**
	 * @property cp2x
	 * @type Number
	 */
	/**
	 * @property cp2y
	 * @type Number
	 */
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.BezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
		this.cp1x = cp1x; this.cp1y = cp1y;
		this.cp2x = cp2x; this.cp2y = cp2y;
		this.x = x; this.y = y;
	}).prototype.exec = function(ctx) { ctx.bezierCurveTo(this.cp1x, this.cp1y, this.cp2x, this.cp2y, this.x, this.y); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/rect"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class Rect
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w
	 * @param {Number} h
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @property w
	 * @type Number
	 */
	/**
	 * @property h
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.Rect = function(x, y, w, h) {
		this.x = x; this.y = y;
		this.w = w; this.h = h;
	}).prototype.exec = function(ctx) { ctx.rect(this.x, this.y, this.w, this.h); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/closePath"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class ClosePath
	 * @constructor
	 **/
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.ClosePath = function() {
	}).prototype.exec = function(ctx) { ctx.closePath(); };

	/**
	 * Graphics command object to begin a new path. See {{#crossLink "Graphics"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class BeginPath
	 * @constructor
	 **/
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.BeginPath = function() {
	}).prototype.exec = function(ctx) { ctx.beginPath(); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/beginFill"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class Fill
	 * @constructor
	 * @param {Object} style A valid Context2D fillStyle.
	 * @param {Matrix2D} matrix
	 **/
	/**
	 * A valid Context2D fillStyle.
	 * @property style
	 * @type Object
	 */
	/**
	 * @property matrix
	 * @type Matrix2D
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	p = (G.Fill = function(style, matrix) {
		this.style = style;
		this.matrix = matrix;
	}).prototype;
	p.exec = function(ctx) {
		if (!this.style) { return; }
		ctx.fillStyle = this.style;
		var mtx = this.matrix;
		if (mtx) { ctx.save(); ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty); }
		ctx.fill();
		if (mtx) { ctx.restore(); }
	};
	/**
	 * Creates a linear gradient style and assigns it to {{#crossLink "Fill/style:property"}}{{/crossLink}}.
	 * See {{#crossLink "Graphics/beginLinearGradientFill"}}{{/crossLink}} for more information.
	 * @method linearGradient
	 * @param {Array} colors
	 * @param {Array} ratios
	 * @param {Number} x0
	 * @param {Number} y0
	 * @param {Number} x1
	 * @param {Number} y1
	 * @return {Fill} Returns this Fill object for chaining or assignment.
	 */
	p.linearGradient = function(colors, ratios, x0, y0, x1, y1) {
		var o = this.style =  Graphics._ctx.createLinearGradient(x0, y0, x1, y1);
		for (var i=0, l=colors.length; i<l; i++) { o.addColorStop(ratios[i], colors[i]); }
		o.props = {colors:colors, ratios:ratios, x0:x0, y0:y0, x1:x1, y1:y1, type:"linear"};
		return this;
	};
	/**
	 * Creates a radial gradient style and assigns it to {{#crossLink "Fill/style:property"}}{{/crossLink}}.
	 * See {{#crossLink "Graphics/beginRadialGradientFill"}}{{/crossLink}} for more information.
	 * @method radialGradient
	 * @param {Array} colors
	 * @param {Array} ratios
	 * @param {Number} x0
	 * @param {Number} y0
	 * @param {Number} r0
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} r1
	 * @return {Fill} Returns this Fill object for chaining or assignment.
	 */
	p.radialGradient = function(colors, ratios, x0, y0, r0, x1, y1, r1) {
		var o = this.style =  Graphics._ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
		for (var i=0, l=colors.length; i<l; i++) { o.addColorStop(ratios[i], colors[i]); }
		o.props = {colors:colors, ratios:ratios, x0:x0, y0:y0, r0:r0, x1:x1, y1:y1, r1:r1, type:"radial"};
		return this;
	};
	/**
	 * Creates a bitmap fill style and assigns it to the {{#crossLink "Fill/style:property"}}{{/crossLink}}.
	 * See {{#crossLink "Graphics/beginBitmapFill"}}{{/crossLink}} for more information.
	 * @method bitmap
	 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image  Must be loaded prior to creating a bitmap fill, or the fill will be empty.
	 * @param {String} [repetition] One of: repeat, repeat-x, repeat-y, or no-repeat.
	 * @return {Fill} Returns this Fill object for chaining or assignment.
	 */
	p.bitmap = function(image, repetition) {
		if (image.naturalWidth || image.getContext || image.readyState >= 2) {
			var o = this.style = Graphics._ctx.createPattern(image, repetition || "");
			o.props = {image: image, repetition: repetition, type: "bitmap"};
		}
		return this;
	};
	p.path = false;

	/**
	 * Graphics command object. See {{#crossLink "Graphics/beginStroke"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class Stroke
	 * @constructor
	 * @param {Object} style A valid Context2D fillStyle.
	 * @param {Boolean} ignoreScale
	 **/
	/**
	 * A valid Context2D strokeStyle.
	 * @property style
	 * @type Object
	 */
	/**
	 * @property ignoreScale
	 * @type Boolean
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	p = (G.Stroke = function(style, ignoreScale) {
		this.style = style;
		this.ignoreScale = ignoreScale;
	}).prototype;
	p.exec = function(ctx) {
		if (!this.style) { return; }
		ctx.strokeStyle = this.style;
		if (this.ignoreScale) { ctx.save(); ctx.setTransform(1,0,0,1,0,0); }
		ctx.stroke();
		if (this.ignoreScale) { ctx.restore(); }
	};
	/**
	 * Creates a linear gradient style and assigns it to {{#crossLink "Stroke/style:property"}}{{/crossLink}}.
	 * See {{#crossLink "Graphics/beginLinearGradientStroke"}}{{/crossLink}} for more information.
	 * @method linearGradient
	 * @param {Array} colors
	 * @param {Array} ratios
	 * @param {Number} x0
	 * @param {Number} y0
	 * @param {Number} x1
	 * @param {Number} y1
	 * @return {Fill} Returns this Stroke object for chaining or assignment.
	 */
	p.linearGradient = G.Fill.prototype.linearGradient;
	/**
	 * Creates a radial gradient style and assigns it to {{#crossLink "Stroke/style:property"}}{{/crossLink}}.
	 * See {{#crossLink "Graphics/beginRadialGradientStroke"}}{{/crossLink}} for more information.
	 * @method radialGradient
	 * @param {Array} colors
	 * @param {Array} ratios
	 * @param {Number} x0
	 * @param {Number} y0
	 * @param {Number} r0
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} r1
	 * @return {Fill} Returns this Stroke object for chaining or assignment.
	 */
	p.radialGradient = G.Fill.prototype.radialGradient;
	/**
	 * Creates a bitmap fill style and assigns it to {{#crossLink "Stroke/style:property"}}{{/crossLink}}.
	 * See {{#crossLink "Graphics/beginBitmapStroke"}}{{/crossLink}} for more information.
	 * @method bitmap
	 * @param {HTMLImageElement} image
	 * @param {String} [repetition] One of: repeat, repeat-x, repeat-y, or no-repeat.
	 * @return {Fill} Returns this Stroke object for chaining or assignment.
	 */
	p.bitmap = G.Fill.prototype.bitmap;
	p.path = false;

	/**
	 * Graphics command object. See {{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class StrokeStyle
	 * @constructor
	 * @param {Number} width
	 * @param {String} [caps]
	 * @param {String} [joints]
	 * @param {Number} [miterLimit]
	 **/
	/**
	 * @property width
	 * @type Number
	 */
	/**
	 * One of: butt, round, square
	 * @property caps
	 * @type String
	 */
	/**
	 * One of: round, bevel, miter
	 * @property joints
	 * @type String
	 */
	/**
	 * @property miterLimit
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	p = (G.StrokeStyle = function(width, caps, joints, miterLimit) {
		this.width = width;
		this.caps = caps;
		this.joints = joints;
		this.miterLimit = miterLimit;
	}).prototype;
	p.exec = function(ctx) {
		ctx.lineWidth = (this.width == null ? "1" : this.width);
		ctx.lineCap = (this.caps == null ? "butt" : (isNaN(this.caps) ? this.caps : Graphics.STROKE_CAPS_MAP[this.caps]));
		ctx.lineJoin = (this.joints == null ? "miter" : (isNaN(this.joints) ? this.joints : Graphics.STROKE_JOINTS_MAP[this.joints]));
		ctx.miterLimit = (this.miterLimit == null ? "10" : this.miterLimit);
	};
	p.path = false;
	
	/**
	 * Graphics command object. See {{#crossLink "Graphics/setStrokeDash"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class StrokeDash
	 * @constructor
	 * @param {Array} [segments]
	 * @param {Number} [offset=0]
	 **/
	/**
	 * @property segments
	 * @type Array
	 */
	/**
	 * @property offset
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.StrokeDash = function(segments, offset) {
		this.segments = segments;
		this.offset = offset||0;
	}).prototype.exec = function(ctx) {
		if (ctx.setLineDash) { // feature detection.
			ctx.setLineDash(this.segments|| G.StrokeDash.EMPTY_SEGMENTS); // instead of [] to reduce churn.
			ctx.lineDashOffset = this.offset||0;
		}
	};
	/**
	 * The default value for segments (ie. no dash).
	 * @property EMPTY_SEGMENTS
	 * @static
	 * @final
	 * @readonly
	 * @protected
	 * @type {Array}
	 **/
	G.StrokeDash.EMPTY_SEGMENTS = [];

	/**
	 * Graphics command object. See {{#crossLink "Graphics/drawRoundRectComplex"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class RoundRect
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w
	 * @param {Number} h
	 * @param {Number} radiusTL
	 * @param {Number} radiusTR
	 * @param {Number} radiusBR
	 * @param {Number} radiusBL
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @property w
	 * @type Number
	 */
	/**
	 * @property h
	 * @type Number
	 */
	/**
	 * @property radiusTL
	 * @type Number
	 */
	/**
	 * @property radiusTR
	 * @type Number
	 */
	/**
	 * @property radiusBR
	 * @type Number
	 */
	/**
	 * @property radiusBL
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.RoundRect = function(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {
		this.x = x; this.y = y;
		this.w = w; this.h = h;
		this.radiusTL = radiusTL; this.radiusTR = radiusTR;
		this.radiusBR = radiusBR; this.radiusBL = radiusBL;
	}).prototype.exec = function(ctx) {
		var max = (w<h?w:h)/2;
		var mTL=0, mTR=0, mBR=0, mBL=0;
		var x = this.x, y = this.y, w = this.w, h = this.h;
		var rTL = this.radiusTL, rTR = this.radiusTR, rBR = this.radiusBR, rBL = this.radiusBL;

		if (rTL < 0) { rTL *= (mTL=-1); }
		if (rTL > max) { rTL = max; }
		if (rTR < 0) { rTR *= (mTR=-1); }
		if (rTR > max) { rTR = max; }
		if (rBR < 0) { rBR *= (mBR=-1); }
		if (rBR > max) { rBR = max; }
		if (rBL < 0) { rBL *= (mBL=-1); }
		if (rBL > max) { rBL = max; }

		ctx.moveTo(x+w-rTR, y);
		ctx.arcTo(x+w+rTR*mTR, y-rTR*mTR, x+w, y+rTR, rTR);
		ctx.lineTo(x+w, y+h-rBR);
		ctx.arcTo(x+w+rBR*mBR, y+h+rBR*mBR, x+w-rBR, y+h, rBR);
		ctx.lineTo(x+rBL, y+h);
		ctx.arcTo(x-rBL*mBL, y+h+rBL*mBL, x, y+h-rBL, rBL);
		ctx.lineTo(x, y+rTL);
		ctx.arcTo(x-rTL*mTL, y-rTL*mTL, x+rTL, y, rTL);
		ctx.closePath();
	};

	/**
	 * Graphics command object. See {{#crossLink "Graphics/drawCircle"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class Circle
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} radius
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @property radius
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.Circle = function(x, y, radius) {
		this.x = x; this.y = y;
		this.radius = radius;
	}).prototype.exec = function(ctx) { ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/drawEllipse"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class Ellipse
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w
	 * @param {Number} h
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @property w
	 * @type Number
	 */
	/**
	 * @property h
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.Ellipse = function(x, y, w, h) {
		this.x = x; this.y = y;
		this.w = w; this.h = h;
	}).prototype.exec = function(ctx) {
		var x = this.x, y = this.y;
		var w = this.w, h = this.h;

		var k = 0.5522848;
		var ox = (w / 2) * k;
		var oy = (h / 2) * k;
		var xe = x + w;
		var ye = y + h;
		var xm = x + w / 2;
		var ym = y + h / 2;

		ctx.moveTo(x, ym);
		ctx.bezierCurveTo(x, ym-oy, xm-ox, y, xm, y);
		ctx.bezierCurveTo(xm+ox, y, xe, ym-oy, xe, ym);
		ctx.bezierCurveTo(xe, ym+oy, xm+ox, ye, xm, ye);
		ctx.bezierCurveTo(xm-ox, ye, x, ym+oy, x, ym);
	};

	/**
	 * Graphics command object. See {{#crossLink "Graphics/drawPolyStar"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class PolyStar
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} radius
	 * @param {Number} sides
	 * @param {Number} pointSize
	 * @param {Number} angle
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @property radius
	 * @type Number
	 */
	/**
	 * @property sides
	 * @type Number
	 */
	/**
	 * @property pointSize
	 * @type Number
	 */
	/**
	 * @property angle
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.PolyStar = function(x, y, radius, sides, pointSize, angle) {
		this.x = x; this.y = y;
		this.radius = radius;
		this.sides = sides;
		this.pointSize = pointSize;
		this.angle = angle;
	}).prototype.exec = function(ctx) {
		var x = this.x, y = this.y;
		var radius = this.radius;
		var angle = (this.angle||0)/180*Math.PI;
		var sides = this.sides;
		var ps = 1-(this.pointSize||0);
		var a = Math.PI/sides;

		ctx.moveTo(x+Math.cos(angle)*radius, y+Math.sin(angle)*radius);
		for (var i=0; i<sides; i++) {
			angle += a;
			if (ps != 1) {
				ctx.lineTo(x+Math.cos(angle)*radius*ps, y+Math.sin(angle)*radius*ps);
			}
			angle += a;
			ctx.lineTo(x+Math.cos(angle)*radius, y+Math.sin(angle)*radius);
		}
		ctx.closePath();
	};

	// docced above.
	Graphics.beginCmd = new G.BeginPath(); // so we don't have to instantiate multiple instances.


	createjs.Graphics = Graphics;
}());

//##############################################################################
// DisplayObject.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * DisplayObject is an abstract class that should not be constructed directly. Instead construct subclasses such as
	 * {{#crossLink "Container"}}{{/crossLink}}, {{#crossLink "Bitmap"}}{{/crossLink}}, and {{#crossLink "Shape"}}{{/crossLink}}.
	 * DisplayObject is the base class for all display classes in the EaselJS library. It defines the core properties and
	 * methods that are shared between all display objects, such as transformation properties (x, y, scaleX, scaleY, etc),
	 * caching, and mouse handlers.
	 * @class DisplayObject
	 * @extends EventDispatcher
	 * @constructor
	 **/
	function DisplayObject() {
		this.EventDispatcher_constructor();
		
		
	// public properties:
		/**
		 * The alpha (transparency) for this display object. 0 is fully transparent, 1 is fully opaque.
		 * @property alpha
		 * @type {Number}
		 * @default 1
		 **/
		this.alpha = 1;
	
		/**
		 * If a cache is active, this returns the canvas that holds the cached version of this display object. See {{#crossLink "cache"}}{{/crossLink}}
		 * for more information.
		 * @property cacheCanvas
		 * @type {HTMLCanvasElement | Object}
		 * @default null
		 * @readonly
		 **/
		this.cacheCanvas = null;
	
		/**
		 * Returns an ID number that uniquely identifies the current cache for this display object. This can be used to
		 * determine if the cache has changed since a previous check.
		 * @property cacheID
		 * @type {Number}
		 * @default 0
		 */
		this.cacheID = 0;
	
		/**
		 * Unique ID for this display object. Makes display objects easier for some uses.
		 * @property id
		 * @type {Number}
		 * @default -1
		 **/
		this.id = createjs.UID.get();
	
		/**
		 * Indicates whether to include this object when running mouse interactions. Setting this to `false` for children
		 * of a {{#crossLink "Container"}}{{/crossLink}} will cause events on the Container to not fire when that child is
		 * clicked. Setting this property to `false` does not prevent the {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}}
		 * method from returning the child.
		 *
		 * <strong>Note:</strong> In EaselJS 0.7.0, the mouseEnabled property will not work properly with nested Containers. Please
		 * check out the latest NEXT version in <a href="https://github.com/CreateJS/EaselJS/tree/master/lib">GitHub</a> for an updated version with this issue resolved. The fix will be
		 * provided in the next release of EaselJS.
		 * @property mouseEnabled
		 * @type {Boolean}
		 * @default true
		 **/
		this.mouseEnabled = true;
		
		/**
		 * If false, the tick will not run on this display object (or its children). This can provide some performance benefits.
		 * In addition to preventing the "tick" event from being dispatched, it will also prevent tick related updates
		 * on some display objects (ex. Sprite & MovieClip frame advancing, DOMElement visibility handling).
		 * @property tickEnabled
		 * @type Boolean
		 * @default true
		 **/
		this.tickEnabled = true;
	
		/**
		 * An optional name for this display object. Included in {{#crossLink "DisplayObject/toString"}}{{/crossLink}} . Useful for
		 * debugging.
		 * @property name
		 * @type {String}
		 * @default null
		 **/
		this.name = null;
	
		/**
		 * A reference to the {{#crossLink "Container"}}{{/crossLink}} or {{#crossLink "Stage"}}{{/crossLink}} object that
		 * contains this display object, or null if it has not been added
		 * to one.
		 * @property parent
		 * @final
		 * @type {Container}
		 * @default null
		 * @readonly
		 **/
		this.parent = null;
	
		/**
		 * The left offset for this display object's registration point. For example, to make a 100x100px Bitmap rotate
		 * around its center, you would set regX and {{#crossLink "DisplayObject/regY:property"}}{{/crossLink}} to 50.
		 * @property regX
		 * @type {Number}
		 * @default 0
		 **/
		this.regX = 0;
	
		/**
		 * The y offset for this display object's registration point. For example, to make a 100x100px Bitmap rotate around
		 * its center, you would set {{#crossLink "DisplayObject/regX:property"}}{{/crossLink}} and regY to 50.
		 * @property regY
		 * @type {Number}
		 * @default 0
		 **/
		this.regY = 0;
	
		/**
		 * The rotation in degrees for this display object.
		 * @property rotation
		 * @type {Number}
		 * @default 0
		 **/
		this.rotation = 0;
	
		/**
		 * The factor to stretch this display object horizontally. For example, setting scaleX to 2 will stretch the display
		 * object to twice its nominal width. To horizontally flip an object, set the scale to a negative number.
		 * @property scaleX
		 * @type {Number}
		 * @default 1
		 **/
		this.scaleX = 1;
	
		/**
		 * The factor to stretch this display object vertically. For example, setting scaleY to 0.5 will stretch the display
		 * object to half its nominal height. To vertically flip an object, set the scale to a negative number.
		 * @property scaleY
		 * @type {Number}
		 * @default 1
		 **/
		this.scaleY = 1;
	
		/**
		 * The factor to skew this display object horizontally.
		 * @property skewX
		 * @type {Number}
		 * @default 0
		 **/
		this.skewX = 0;
	
		/**
		 * The factor to skew this display object vertically.
		 * @property skewY
		 * @type {Number}
		 * @default 0
		 **/
		this.skewY = 0;
	
		/**
		 * A shadow object that defines the shadow to render on this display object. Set to `null` to remove a shadow. If
		 * null, this property is inherited from the parent container.
		 * @property shadow
		 * @type {Shadow}
		 * @default null
		 **/
		this.shadow = null;
	
		/**
		 * Indicates whether this display object should be rendered to the canvas and included when running the Stage
		 * {{#crossLink "Stage/getObjectsUnderPoint"}}{{/crossLink}} method.
		 * @property visible
		 * @type {Boolean}
		 * @default true
		 **/
		this.visible = true;
	
		/**
		 * The x (horizontal) position of the display object, relative to its parent.
		 * @property x
		 * @type {Number}
		 * @default 0
		 **/
		this.x = 0;
	
		/** The y (vertical) position of the display object, relative to its parent.
		 * @property y
		 * @type {Number}
		 * @default 0
		 **/
		this.y = 0;
		
		/**
		 * If set, defines the transformation for this display object, overriding all other transformation properties
		 * (x, y, rotation, scale, skew).
		 * @property transformMatrix
		 * @type {Matrix2D}
		 * @default null
		 **/
		this.transformMatrix = null;
		
		/**
		 * The composite operation indicates how the pixels of this display object will be composited with the elements
		 * behind it. If `null`, this property is inherited from the parent container. For more information, read the
		 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#compositing">
		 * whatwg spec on compositing</a>.
		 * @property compositeOperation
		 * @type {String}
		 * @default null
		 **/
		this.compositeOperation = null;
	
		/**
		 * Indicates whether the display object should be drawn to a whole pixel when
		 * {{#crossLink "Stage/snapToPixelEnabled"}}{{/crossLink}} is true. To enable/disable snapping on whole
		 * categories of display objects, set this value on the prototype (Ex. Text.prototype.snapToPixel = true).
		 * @property snapToPixel
		 * @type {Boolean}
		 * @default true
		 **/
		this.snapToPixel = true;
	
		/**
		 * An array of Filter objects to apply to this display object. Filters are only applied / updated when {{#crossLink "cache"}}{{/crossLink}}
		 * or {{#crossLink "updateCache"}}{{/crossLink}} is called on the display object, and only apply to the area that is
		 * cached.
		 * @property filters
		 * @type {Array}
		 * @default null
		 **/
		this.filters = null;
		
		/**
		 * A Shape instance that defines a vector mask (clipping path) for this display object.  The shape's transformation
		 * will be applied relative to the display object's parent coordinates (as if it were a child of the parent).
		 * @property mask
		 * @type {Shape}
		 * @default null
		 */
		this.mask = null;
		
		/**
		 * A display object that will be tested when checking mouse interactions or testing {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}}.
		 * The hit area will have its transformation applied relative to this display object's coordinate space (as though
		 * the hit test object were a child of this display object and relative to its regX/Y). The hitArea will be tested
		 * using only its own `alpha` value regardless of the alpha value on the target display object, or the target's
		 * ancestors (parents).
		 * 
		 * If set on a {{#crossLink "Container"}}{{/crossLink}}, children of the Container will not receive mouse events.
		 * This is similar to setting {{#crossLink "mouseChildren"}}{{/crossLink}} to false.
		 *
		 * Note that hitArea is NOT currently used by the `hitTest()` method, nor is it supported for {{#crossLink "Stage"}}{{/crossLink}}.
		 * @property hitArea
		 * @type {DisplayObject}
		 * @default null
		 */
		this.hitArea = null;
		
		/**
		 * A CSS cursor (ex. "pointer", "help", "text", etc) that will be displayed when the user hovers over this display
		 * object. You must enable mouseover events using the {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}} method to
		 * use this property. Setting a non-null cursor on a Container will override the cursor set on its descendants.
		 * @property cursor
		 * @type {String}
		 * @default null
		 */
		this.cursor = null;
	
	
	// private properties:
		/**
		 * @property _cacheOffsetX
		 * @protected
		 * @type {Number}
		 * @default 0
		 **/
		this._cacheOffsetX = 0;
	
		/**
		 * @property _cacheOffsetY
		 * @protected
		 * @type {Number}
		 * @default 0
		 **/
		this._cacheOffsetY = 0;
		
		/**
		 * @property _filterOffsetX
		 * @protected
		 * @type {Number}
		 * @default 0
		 **/
		this._filterOffsetX = 0;
		
		/**
		 * @property _filterOffsetY
		 * @protected
		 * @type {Number}
		 * @default 0
		 **/
		this._filterOffsetY = 0;
		
		/**
		 * @property _cacheScale
		 * @protected
		 * @type {Number}
		 * @default 1
		 **/
		this._cacheScale = 1;
	
		/**
		* @property _cacheDataURLID
		* @protected
		* @type {Number}
		* @default 0
		*/
		this._cacheDataURLID = 0;
		
		/**
		* @property _cacheDataURL
		* @protected
		* @type {String}
		* @default null
		*/
		this._cacheDataURL = null;
	
		/**
		 * @property _props
		 * @protected
		 * @type {DisplayObject}
		 * @default null
		 **/
		this._props = new createjs.DisplayProps();
	
		/**
		 * @property _rectangle
		 * @protected
		 * @type {Rectangle}
		 * @default null
		 **/
		this._rectangle = new createjs.Rectangle();
	
		/**
		 * @property _bounds
		 * @protected
		 * @type {Rectangle}
		 * @default null
		 **/
		this._bounds = null;
	}
	var p = createjs.extend(DisplayObject, createjs.EventDispatcher);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
// static properties:
	/**
	 * Listing of mouse event names. Used in _hasMouseEventListener.
	 * @property _MOUSE_EVENTS
	 * @protected
	 * @static
	 * @type {Array}
	 **/
	DisplayObject._MOUSE_EVENTS = ["click","dblclick","mousedown","mouseout","mouseover","pressmove","pressup","rollout","rollover"];

	/**
	 * Suppresses errors generated when using features like hitTest, mouse events, and {{#crossLink "getObjectsUnderPoint"}}{{/crossLink}}
	 * with cross domain content.
	 * @property suppressCrossDomainErrors
	 * @static
	 * @type {Boolean}
	 * @default false
	 **/
	DisplayObject.suppressCrossDomainErrors = false;
	
	/**
	 * @property _snapToPixelEnabled
	 * @protected
	 * @static
	 * @type {Boolean}
	 * @default false
	 **/
	DisplayObject._snapToPixelEnabled = false; // stage.snapToPixelEnabled is temporarily copied here during a draw to provide global access.

	/**
	 * @property _hitTestCanvas
	 * @type {HTMLCanvasElement | Object}
	 * @static
	 * @protected
	 **/
	/**
	 * @property _hitTestContext
	 * @type {CanvasRenderingContext2D}
	 * @static
	 * @protected
	 **/
	var canvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"); // prevent errors on load in browsers without canvas.
	if (canvas.getContext) {
		DisplayObject._hitTestCanvas = canvas;
		DisplayObject._hitTestContext = canvas.getContext("2d");
		canvas.width = canvas.height = 1;
	}

	/**
	 * @property _nextCacheID
	 * @type {Number}
	 * @static
	 * @protected
	 **/
	DisplayObject._nextCacheID = 1;


// events:
	/**
	 * Dispatched when the user presses their left mouse button over the display object. See the 
	 * {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event mousedown
	 * @since 0.6.0
	 */
	 
	/**
	 * Dispatched when the user presses their left mouse button and then releases it while over the display object.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event click
	 * @since 0.6.0
	 */
	 
	/**
	 * Dispatched when the user double clicks their left mouse button over this display object.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event dblclick
	 * @since 0.6.0
	 */
	 
	/**
	 * Dispatched when the user's mouse enters this display object. This event must be enabled using 
	 * {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}. See also {{#crossLink "DisplayObject/rollover:event"}}{{/crossLink}}.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event mouseover
	 * @since 0.6.0
	 */

	/**
	 * Dispatched when the user's mouse leaves this display object. This event must be enabled using 
	 * {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}. See also {{#crossLink "DisplayObject/rollout:event"}}{{/crossLink}}.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event mouseout
	 * @since 0.6.0
	 */
	 
	/**
	 * This event is similar to {{#crossLink "DisplayObject/mouseover:event"}}{{/crossLink}}, with the following
	 * differences: it does not bubble, and it considers {{#crossLink "Container"}}{{/crossLink}} instances as an
	 * aggregate of their content.
	 * 
	 * For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over
	 * shapeA and then directly on to shapeB. With a listener for {{#crossLink "mouseover:event"}}{{/crossLink}} on
	 * myContainer, two events would be received, each targeting a child element:<OL>
	 * <LI>when the mouse enters shapeA (target=shapeA)</LI>
	 * <LI>when the mouse enters shapeB (target=shapeB)</LI>
	 * </OL>
	 * However, with a listener for "rollover" instead, only a single event is received when the mouse first enters
	 * the aggregate myContainer content (target=myContainer).
	 * 
	 * This event must be enabled using {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event rollover
	 * @since 0.7.0
	 */
	 
	/**
	 * This event is similar to {{#crossLink "DisplayObject/mouseout:event"}}{{/crossLink}}, with the following
	 * differences: it does not bubble, and it considers {{#crossLink "Container"}}{{/crossLink}} instances as an
	 * aggregate of their content.
	 * 
	 * For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over
	 * shapeA, then directly on to shapeB, then off both. With a listener for {{#crossLink "mouseout:event"}}{{/crossLink}}
	 * on myContainer, two events would be received, each targeting a child element:<OL>
	 * <LI>when the mouse leaves shapeA (target=shapeA)</LI>
	 * <LI>when the mouse leaves shapeB (target=shapeB)</LI>
	 * </OL>
	 * However, with a listener for "rollout" instead, only a single event is received when the mouse leaves
	 * the aggregate myContainer content (target=myContainer).
	 * 
	 * This event must be enabled using {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event rollout
	 * @since 0.7.0
	 */
	 
	/**
	 * After a {{#crossLink "DisplayObject/mousedown:event"}}{{/crossLink}} occurs on a display object, a pressmove
	 * event will be generated on that object whenever the mouse moves until the mouse press is released. This can be
	 * useful for dragging and similar operations.
	 * @event pressmove
	 * @since 0.7.0
	 */
	 
	/**
	 * After a {{#crossLink "DisplayObject/mousedown:event"}}{{/crossLink}} occurs on a display object, a pressup event
	 * will be generated on that object when that mouse press is released. This can be useful for dragging and similar
	 * operations.
	 * @event pressup
	 * @since 0.7.0
	 */
	 
	/**
	 * Dispatched when the display object is added to a parent container.
	 * @event added
	 */
	 
	/**
	 * Dispatched when the display object is removed from its parent container.
	 * @event removed
	 */
	 
	/**
	 * Dispatched on each display object on a stage whenever the stage updates. This occurs immediately before the
	 * rendering (draw) pass. When {{#crossLink "Stage/update"}}{{/crossLink}} is called, first all display objects on
	 * the stage dispatch the tick event, then all of the display objects are drawn to stage. Children will have their
	 * {{#crossLink "tick:event"}}{{/crossLink}} event dispatched in order of their depth prior to the event being
	 * dispatched on their parent.
	 * @event tick
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Array} params An array containing any arguments that were passed to the Stage.update() method. For
	 *      example if you called stage.update("hello"), then the params would be ["hello"].
	 * @since 0.6.0
	 */
	
	
// getter / setters:
	/**
	 * Use the {{#crossLink "DisplayObject/stage:property"}}{{/crossLink}} property instead.
	 * @method getStage
	 * @return {Stage}
	 * @deprecated
	 **/
	p.getStage = function() {
		// uses dynamic access to avoid circular dependencies;
		var o = this, _Stage = createjs["Stage"];
		while (o.parent) { o = o.parent; }
		if (o instanceof _Stage) { return o; }
		return null;
	};

	/**
	 * Returns the Stage instance that this display object will be rendered on, or null if it has not been added to one.
	 * @property stage
	 * @type {Stage}
	 * @readonly
	 **/
	try {
		Object.defineProperties(p, {
			stage: { get: p.getStage }
		});
	} catch (e) {}


// public methods:
	/**
	 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
	 **/
	p.isVisible = function() {
		return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0);
	};

	/**
	 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
	 * Returns <code>true</code> if the draw was handled (useful for overriding functionality).
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,
	 * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).
	 * @return {Boolean}
	 **/
	p.draw = function(ctx, ignoreCache) {
		var cacheCanvas = this.cacheCanvas;
		if (ignoreCache || !cacheCanvas) { return false; }
		var scale = this._cacheScale;
		ctx.drawImage(cacheCanvas, this._cacheOffsetX+this._filterOffsetX, this._cacheOffsetY+this._filterOffsetY, cacheCanvas.width/scale, cacheCanvas.height/scale);
		return true;
	};
	
	/**
	 * Applies this display object's transformation, alpha, globalCompositeOperation, clipping path (mask), and shadow
	 * to the specified context. This is typically called prior to {{#crossLink "DisplayObject/draw"}}{{/crossLink}}.
	 * @method updateContext
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D to update.
	 **/
	p.updateContext = function(ctx) {
		var o=this, mask=o.mask, mtx= o._props.matrix;
		
		if (mask && mask.graphics && !mask.graphics.isEmpty()) {
			mask.getMatrix(mtx);
			ctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);
			
			mask.graphics.drawAsPath(ctx);
			ctx.clip();
			
			mtx.invert();
			ctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);
		}
		
		this.getMatrix(mtx);
		var tx = mtx.tx, ty = mtx.ty;
		if (DisplayObject._snapToPixelEnabled && o.snapToPixel) {
			tx = tx + (tx < 0 ? -0.5 : 0.5) | 0;
			ty = ty + (ty < 0 ? -0.5 : 0.5) | 0;
		}
		ctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, tx, ty);
		ctx.globalAlpha *= o.alpha;
		if (o.compositeOperation) { ctx.globalCompositeOperation = o.compositeOperation; }
		if (o.shadow) { this._applyShadow(ctx, o.shadow); }
	};

	/**
	 * Draws the display object into a new canvas, which is then used for subsequent draws. For complex content
	 * that does not change frequently (ex. a Container with many children that do not move, or a complex vector Shape),
	 * this can provide for much faster rendering because the content does not need to be re-rendered each tick. The
	 * cached display object can be moved, rotated, faded, etc freely, however if its content changes, you must
	 * manually update the cache by calling <code>updateCache()</code> or <code>cache()</code> again. You must specify
	 * the cache area via the x, y, w, and h parameters. This defines the rectangle that will be rendered and cached
	 * using this display object's coordinates.
	 *
	 * <h4>Example</h4>
	 * For example if you defined a Shape that drew a circle at 0, 0 with a radius of 25:
	 *
	 *      var shape = new createjs.Shape();
	 *      shape.graphics.beginFill("#ff0000").drawCircle(0, 0, 25);
	 *      myShape.cache(-25, -25, 50, 50);
	 *
	 * Note that filters need to be defined <em>before</em> the cache is applied. Check out the {{#crossLink "Filter"}}{{/crossLink}}
	 * class for more information. Some filters (ex. BlurFilter) will not work as expected in conjunction with the scale param.
	 * 
	 * Usually, the resulting cacheCanvas will have the dimensions width*scale by height*scale, however some filters (ex. BlurFilter)
	 * will add padding to the canvas dimensions.
	 *
	 * @method cache
	 * @param {Number} x The x coordinate origin for the cache region.
	 * @param {Number} y The y coordinate origin for the cache region.
	 * @param {Number} width The width of the cache region.
	 * @param {Number} height The height of the cache region.
	 * @param {Number} [scale=1] The scale at which the cache will be created. For example, if you cache a vector shape using
	 * 	myShape.cache(0,0,100,100,2) then the resulting cacheCanvas will be 200x200 px. This lets you scale and rotate
	 * 	cached elements with greater fidelity. Default is 1.
	 **/
	p.cache = function(x, y, width, height, scale) {
		// draw to canvas.
		scale = scale||1;
		if (!this.cacheCanvas) { this.cacheCanvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"); }
		this._cacheWidth = width;
		this._cacheHeight = height;
		this._cacheOffsetX = x;
		this._cacheOffsetY = y;
		this._cacheScale = scale;
		this.updateCache();
	};

	/**
	 * Redraws the display object to its cache. Calling updateCache without an active cache will throw an error.
	 * If compositeOperation is null the current cache will be cleared prior to drawing. Otherwise the display object
	 * will be drawn over the existing cache using the specified compositeOperation.
	 *
	 * <h4>Example</h4>
	 * Clear the current graphics of a cached shape, draw some new instructions, and then update the cache. The new line
	 * will be drawn on top of the old one.
	 *
	 *      // Not shown: Creating the shape, and caching it.
	 *      shapeInstance.clear();
	 *      shapeInstance.setStrokeStyle(3).beginStroke("#ff0000").moveTo(100, 100).lineTo(200,200);
	 *      shapeInstance.updateCache();
	 *
	 * @method updateCache
	 * @param {String} compositeOperation The compositeOperation to use, or null to clear the cache and redraw it.
	 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#compositing">
	 * whatwg spec on compositing</a>.
	 **/
	p.updateCache = function(compositeOperation) {
		var cacheCanvas = this.cacheCanvas;
		if (!cacheCanvas) { throw "cache() must be called before updateCache()"; }
		var scale = this._cacheScale, offX = this._cacheOffsetX*scale, offY = this._cacheOffsetY*scale;
		var w = this._cacheWidth, h = this._cacheHeight, ctx = cacheCanvas.getContext("2d");
		
		var fBounds = this._getFilterBounds();
		offX += (this._filterOffsetX = fBounds.x);
		offY += (this._filterOffsetY = fBounds.y);
		
		w = Math.ceil(w*scale) + fBounds.width;
		h = Math.ceil(h*scale) + fBounds.height;
		if (w != cacheCanvas.width || h != cacheCanvas.height) {
			// TODO: it would be nice to preserve the content if there is a compositeOperation.
			cacheCanvas.width = w;
			cacheCanvas.height = h;
		} else if (!compositeOperation) {
			ctx.clearRect(0, 0, w+1, h+1);
		}
		
		ctx.save();
		ctx.globalCompositeOperation = compositeOperation;
		ctx.setTransform(scale, 0, 0, scale, -offX, -offY);
		this.draw(ctx, true);
		// TODO: filters and cache scale don't play well together at present.
		this._applyFilters();
		ctx.restore();
		this.cacheID = DisplayObject._nextCacheID++;
	};

	/**
	 * Clears the current cache. See {{#crossLink "DisplayObject/cache"}}{{/crossLink}} for more information.
	 * @method uncache
	 **/
	p.uncache = function() {
		this._cacheDataURL = this.cacheCanvas = null;
		this.cacheID = this._cacheOffsetX = this._cacheOffsetY = this._filterOffsetX = this._filterOffsetY = 0;
		this._cacheScale = 1;
	};
	
	/**
	 * Returns a data URL for the cache, or null if this display object is not cached.
	 * Uses cacheID to ensure a new data URL is not generated if the cache has not changed.
	 * @method getCacheDataURL
	 * @return {String} The image data url for the cache.
	 **/
	p.getCacheDataURL = function() {
		if (!this.cacheCanvas) { return null; }
		if (this.cacheID != this._cacheDataURLID) { this._cacheDataURL = this.cacheCanvas.toDataURL(); }
		return this._cacheDataURL;
	};

	/**
	 * Transforms the specified x and y position from the coordinate space of the display object
	 * to the global (stage) coordinate space. For example, this could be used to position an HTML label
	 * over a specific point on a nested display object. Returns a Point instance with x and y properties
	 * correlating to the transformed coordinates on the stage.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.x = 300;
	 *      displayObject.y = 200;
	 *      stage.addChild(displayObject);
	 *      var point = myDisplayObject.localToGlobal(100, 100);
	 *      // Results in x=400, y=300
	 *
	 * @method localToGlobal
	 * @param {Number} x The x position in the source display object to transform.
	 * @param {Number} y The y position in the source display object to transform.
	 * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. 
	 * @return {Point} A Point instance with x and y properties correlating to the transformed coordinates
	 * on the stage.
	 **/
	p.localToGlobal = function(x, y, pt) {
		return this.getConcatenatedMatrix(this._props.matrix).transformPoint(x,y, pt||new createjs.Point());
	};

	/**
	 * Transforms the specified x and y position from the global (stage) coordinate space to the
	 * coordinate space of the display object. For example, this could be used to determine
	 * the current mouse position within the display object. Returns a Point instance with x and y properties
	 * correlating to the transformed position in the display object's coordinate space.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.x = 300;
	 *      displayObject.y = 200;
	 *      stage.addChild(displayObject);
	 *      var point = myDisplayObject.globalToLocal(100, 100);
	 *      // Results in x=-200, y=-100
	 *
	 * @method globalToLocal
	 * @param {Number} x The x position on the stage to transform.
	 * @param {Number} y The y position on the stage to transform.
	 * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. 
	 * @return {Point} A Point instance with x and y properties correlating to the transformed position in the
	 * display object's coordinate space.
	 **/
	p.globalToLocal = function(x, y, pt) {
		return this.getConcatenatedMatrix(this._props.matrix).invert().transformPoint(x,y, pt||new createjs.Point());
	};

	/**
	 * Transforms the specified x and y position from the coordinate space of this display object to the coordinate
	 * space of the target display object. Returns a Point instance with x and y properties correlating to the
	 * transformed position in the target's coordinate space. Effectively the same as using the following code with
	 * {{#crossLink "DisplayObject/localToGlobal"}}{{/crossLink}} and {{#crossLink "DisplayObject/globalToLocal"}}{{/crossLink}}.
	 *
	 *      var pt = this.localToGlobal(x, y);
	 *      pt = target.globalToLocal(pt.x, pt.y);
	 *
	 * @method localToLocal
	 * @param {Number} x The x position in the source display object to transform.
	 * @param {Number} y The y position on the source display object to transform.
	 * @param {DisplayObject} target The target display object to which the coordinates will be transformed.
	 * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. 
	 * @return {Point} Returns a Point instance with x and y properties correlating to the transformed position
	 * in the target's coordinate space.
	 **/
	p.localToLocal = function(x, y, target, pt) {
		pt = this.localToGlobal(x, y, pt);
		return target.globalToLocal(pt.x, pt.y, pt);
	};

	/**
	 * Shortcut method to quickly set the transform properties on the display object. All parameters are optional.
	 * Omitted parameters will have the default value set.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.setTransform(100, 100, 2, 2);
	 *
	 * @method setTransform
	 * @param {Number} [x=0] The horizontal translation (x position) in pixels
	 * @param {Number} [y=0] The vertical translation (y position) in pixels
	 * @param {Number} [scaleX=1] The horizontal scale, as a percentage of 1
	 * @param {Number} [scaleY=1] the vertical scale, as a percentage of 1
	 * @param {Number} [rotation=0] The rotation, in degrees
	 * @param {Number} [skewX=0] The horizontal skew factor
	 * @param {Number} [skewY=0] The vertical skew factor
	 * @param {Number} [regX=0] The horizontal registration point in pixels
	 * @param {Number} [regY=0] The vertical registration point in pixels
	 * @return {DisplayObject} Returns this instance. Useful for chaining commands.
	 * @chainable
	*/
	p.setTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
		this.x = x || 0;
		this.y = y || 0;
		this.scaleX = scaleX == null ? 1 : scaleX;
		this.scaleY = scaleY == null ? 1 : scaleY;
		this.rotation = rotation || 0;
		this.skewX = skewX || 0;
		this.skewY = skewY || 0;
		this.regX = regX || 0;
		this.regY = regY || 0;
		return this;
	};
	
	/**
	 * Returns a matrix based on this object's current transform.
	 * @method getMatrix
	 * @param {Matrix2D} matrix Optional. A Matrix2D object to populate with the calculated values. If null, a new
	 * Matrix object is returned.
	 * @return {Matrix2D} A matrix representing this display object's transform.
	 **/
	p.getMatrix = function(matrix) {
		var o = this, mtx = matrix&&matrix.identity() || new createjs.Matrix2D();
		return o.transformMatrix ?  mtx.copy(o.transformMatrix) : mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);
	};
	
	/**
	 * Generates a Matrix2D object representing the combined transform of the display object and all of its
	 * parent Containers up to the highest level ancestor (usually the {{#crossLink "Stage"}}{{/crossLink}}). This can
	 * be used to transform positions between coordinate spaces, such as with {{#crossLink "DisplayObject/localToGlobal"}}{{/crossLink}}
	 * and {{#crossLink "DisplayObject/globalToLocal"}}{{/crossLink}}.
	 * @method getConcatenatedMatrix
	 * @param {Matrix2D} [matrix] A {{#crossLink "Matrix2D"}}{{/crossLink}} object to populate with the calculated values.
	 * If null, a new Matrix2D object is returned.
	 * @return {Matrix2D} The combined matrix.
	 **/
	p.getConcatenatedMatrix = function(matrix) {
		var o = this, mtx = this.getMatrix(matrix);
		while (o = o.parent) {
			mtx.prependMatrix(o.getMatrix(o._props.matrix));
		}
		return mtx;
	};
	
	/**
	 * Generates a DisplayProps object representing the combined display properties of the  object and all of its
	 * parent Containers up to the highest level ancestor (usually the {{#crossLink "Stage"}}{{/crossLink}}).
	 * @method getConcatenatedDisplayProps
	 * @param {DisplayProps} [props] A {{#crossLink "DisplayProps"}}{{/crossLink}} object to populate with the calculated values.
	 * If null, a new DisplayProps object is returned.
	 * @return {DisplayProps} The combined display properties.
	 **/
	p.getConcatenatedDisplayProps = function(props) {
		props = props ? props.identity() : new createjs.DisplayProps();
		var o = this, mtx = o.getMatrix(props.matrix); 
		do {
			props.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation);
			
			// we do this to avoid problems with the matrix being used for both operations when o._props.matrix is passed in as the props param.
			// this could be simplified (ie. just done as part of the prepend above) if we switched to using a pool.
			if (o != this) { mtx.prependMatrix(o.getMatrix(o._props.matrix)); }
		} while (o = o.parent);
		return props;
	};

	/**
	 * Tests whether the display object intersects the specified point in local coordinates (ie. draws a pixel with alpha > 0 at
	 * the specified position). This ignores the alpha, shadow, hitArea, mask, and compositeOperation of the display object.
	 *
	 * <h4>Example</h4>
	 *
	 *      stage.addEventListener("stagemousedown", handleMouseDown);
	 *      function handleMouseDown(event) {
	 *          var hit = myShape.hitTest(event.stageX, event.stageY);
	 *      }
	 *
	 * Please note that shape-to-shape collision is not currently supported by EaselJS.
	 * @method hitTest
	 * @param {Number} x The x position to check in the display object's local coordinates.
	 * @param {Number} y The y position to check in the display object's local coordinates.
	 * @return {Boolean} A Boolean indicating whether a visible portion of the DisplayObject intersect the specified
	 * local Point.
	*/
	p.hitTest = function(x, y) {
		var ctx = DisplayObject._hitTestContext;
		ctx.setTransform(1, 0, 0, 1, -x, -y);
		this.draw(ctx);

		var hit = this._testHit(ctx);
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		ctx.clearRect(0, 0, 2, 2);
		return hit;
	};
	
	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * <h4>Example</h4>
	 *
	 *      var myGraphics = new createjs.Graphics().beginFill("#ff0000").drawCircle(0, 0, 25);
	 *      var shape = stage.addChild(new Shape()).set({graphics:myGraphics, x:100, y:100, alpha:0.5});
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the DisplayObject instance.
	 * @return {DisplayObject} Returns the instance the method is called on (useful for chaining calls.)
	 * @chainable
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};
	
	/**
	 * Returns a rectangle representing this object's bounds in its local coordinate system (ie. with no transformation).
	 * Objects that have been cached will return the bounds of the cache.
	 * 
	 * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use 
	 * {{#crossLink "DisplayObject/setBounds"}}{{/crossLink}} so that they are included when calculating Container
	 * bounds.
	 * 
	 * <table>
	 * 	<tr><td><b>All</b></td><td>
	 * 		All display objects support setting bounds manually using setBounds(). Likewise, display objects that
	 * 		have been cached using cache() will return the bounds of their cache. Manual and cache bounds will override
	 * 		the automatic calculations listed below.
	 * 	</td></tr>
	 * 	<tr><td><b>Bitmap</b></td><td>
	 * 		Returns the width and height of the sourceRect (if specified) or image, extending from (x=0,y=0).
	 * 	</td></tr>
	 * 	<tr><td><b>Sprite</b></td><td>
	 * 		Returns the bounds of the current frame. May have non-zero x/y if a frame registration point was specified
	 * 		in the spritesheet data. See also {{#crossLink "SpriteSheet/getFrameBounds"}}{{/crossLink}}
	 * 	</td></tr>
	 * 	<tr><td><b>Container</b></td><td>
	 * 		Returns the aggregate (combined) bounds of all children that return a non-null value from getBounds().
	 * 	</td></tr>
	 * 	<tr><td><b>Shape</b></td><td>
	 * 		Does not currently support automatic bounds calculations. Use setBounds() to manually define bounds.
	 * 	</td></tr>
	 * 	<tr><td><b>Text</b></td><td>
	 * 		Returns approximate bounds. Horizontal values (x/width) are quite accurate, but vertical values (y/height) are
	 * 		not, especially when using textBaseline values other than "top".
	 * 	</td></tr>
	 * 	<tr><td><b>BitmapText</b></td><td>
	 * 		Returns approximate bounds. Values will be more accurate if spritesheet frame registration points are close
	 * 		to (x=0,y=0).
	 * 	</td></tr>
	* </table>
	 * 
	 * Bounds can be expensive to calculate for some objects (ex. text, or containers with many children), and
	 * are recalculated each time you call getBounds(). You can prevent recalculation on static objects by setting the
	 * bounds explicitly:
	 * 
	 * 	var bounds = obj.getBounds();
	 * 	obj.setBounds(bounds.x, bounds.y, bounds.width, bounds.height);
	 * 	// getBounds will now use the set values, instead of recalculating
	 * 
	 * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its
	 * values if you need to retain it.
	 * 
	 * 	var myBounds = obj.getBounds().clone();
	 * 	// OR:
	 * 	myRect.copy(obj.getBounds());
	 * 
	 * @method getBounds
	 * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this
	 * object.
	 **/
	p.getBounds = function() {
		if (this._bounds) { return this._rectangle.copy(this._bounds); }
		var cacheCanvas = this.cacheCanvas;
		if (cacheCanvas) {
			var scale = this._cacheScale;
			return this._rectangle.setValues(this._cacheOffsetX, this._cacheOffsetY, cacheCanvas.width/scale, cacheCanvas.height/scale);
		}
		return null;
	};
	
	/**
	 * Returns a rectangle representing this object's bounds in its parent's coordinate system (ie. with transformations applied).
	 * Objects that have been cached will return the transformed bounds of the cache.
	 * 
	 * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use 
	 * {{#crossLink "DisplayObject/setBounds"}}{{/crossLink}} so that they are included when calculating Container
	 * bounds.
	 * 
	 * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its
	 * values if you need to retain it.
	 * 
	 * Container instances calculate aggregate bounds for all children that return bounds via getBounds.
	 * @method getTransformedBounds
	 * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this object.
	 **/
	p.getTransformedBounds = function() {
		return this._getBounds();
	};
	
	/**
	 * Allows you to manually specify the bounds of an object that either cannot calculate their own bounds (ex. Shape &
	 * Text) for future reference, or so the object can be included in Container bounds. Manually set bounds will always
	 * override calculated bounds.
	 * 
	 * The bounds should be specified in the object's local (untransformed) coordinates. For example, a Shape instance
	 * with a 25px radius circle centered at 0,0 would have bounds of (-25, -25, 50, 50).
	 * @method setBounds
	 * @param {Number} x The x origin of the bounds. Pass null to remove the manual bounds.
	 * @param {Number} y The y origin of the bounds.
	 * @param {Number} width The width of the bounds.
	 * @param {Number} height The height of the bounds.
	 **/
	p.setBounds = function(x, y, width, height) {
		if (x == null) { this._bounds = x; }
		this._bounds = (this._bounds || new createjs.Rectangle()).setValues(x, y, width, height);
	};

	/**
	 * Returns a clone of this DisplayObject. Some properties that are specific to this instance's current context are
	 * reverted to their defaults (for example .parent). Caches are not maintained across clones, and some elements
	 * are copied by reference (masks, individual filter instances, hit area)
	 * @method clone
	 * @return {DisplayObject} A clone of the current DisplayObject instance.
	 **/
	p.clone = function() {
		return this._cloneProps(new DisplayObject());
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[DisplayObject (name="+  this.name +")]";
	};


// private methods:
	// separated so it can be used more easily in subclasses:
	/**
	 * @method _cloneProps
	 * @param {DisplayObject} o The DisplayObject instance which will have properties from the current DisplayObject
	 * instance copied into.
	 * @return {DisplayObject} o
	 * @protected
	 **/
	p._cloneProps = function(o) {
		o.alpha = this.alpha;
		o.mouseEnabled = this.mouseEnabled;
		o.tickEnabled = this.tickEnabled;
		o.name = this.name;
		o.regX = this.regX;
		o.regY = this.regY;
		o.rotation = this.rotation;
		o.scaleX = this.scaleX;
		o.scaleY = this.scaleY;
		o.shadow = this.shadow;
		o.skewX = this.skewX;
		o.skewY = this.skewY;
		o.visible = this.visible;
		o.x  = this.x;
		o.y = this.y;
		o.compositeOperation = this.compositeOperation;
		o.snapToPixel = this.snapToPixel;
		o.filters = this.filters==null?null:this.filters.slice(0);
		o.mask = this.mask;
		o.hitArea = this.hitArea;
		o.cursor = this.cursor;
		o._bounds = this._bounds;
		return o;
	};

	/**
	 * @method _applyShadow
	 * @protected
	 * @param {CanvasRenderingContext2D} ctx
	 * @param {Shadow} shadow
	 **/
	p._applyShadow = function(ctx, shadow) {
		shadow = shadow || Shadow.identity;
		ctx.shadowColor = shadow.color;
		ctx.shadowOffsetX = shadow.offsetX;
		ctx.shadowOffsetY = shadow.offsetY;
		ctx.shadowBlur = shadow.blur;
	};
	
	
	/**
	 * @method _tick
	 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
	 * @protected
	 **/
	p._tick = function(evtObj) {
		// because tick can be really performance sensitive, check for listeners before calling dispatchEvent.
		var ls = this._listeners;
		if (ls && ls["tick"]) {
			// reset & reuse the event object to avoid construction / GC costs:
			evtObj.target = null;
			evtObj.propagationStopped = evtObj.immediatePropagationStopped = false;
			this.dispatchEvent(evtObj);
		}
	};

	/**
	 * @method _testHit
	 * @protected
	 * @param {CanvasRenderingContext2D} ctx
	 * @return {Boolean}
	 **/
	p._testHit = function(ctx) {
		try {
			var hit = ctx.getImageData(0, 0, 1, 1).data[3] > 1;
		} catch (e) {
			if (!DisplayObject.suppressCrossDomainErrors) {
				throw "An error has occurred. This is most likely due to security restrictions on reading canvas pixel data with local or cross-domain images.";
			}
		}
		return hit;
	};

	/**
	 * @method _applyFilters
	 * @protected
	 **/
	p._applyFilters = function() {
		if (!this.filters || this.filters.length == 0 || !this.cacheCanvas) { return; }
		var l = this.filters.length;
		var ctx = this.cacheCanvas.getContext("2d");
		var w = this.cacheCanvas.width;
		var h = this.cacheCanvas.height;
		for (var i=0; i<l; i++) {
			this.filters[i].applyFilter(ctx, 0, 0, w, h);
		}
	};
	
	/**
	 * @method _getFilterBounds
	 * @return {Rectangle}
	 * @protected
	 **/
	p._getFilterBounds = function(rect) {
		var l, filters = this.filters, bounds = this._rectangle.setValues(0,0,0,0);
		if (!filters || !(l=filters.length)) { return bounds; }
		
		for (var i=0; i<l; i++) {
			var f = this.filters[i];
			f.getBounds&&f.getBounds(bounds);
		}
		return bounds;
	};
	
	/**
	 * @method _getBounds
	 * @param {Matrix2D} matrix
	 * @param {Boolean} ignoreTransform If true, does not apply this object's transform.
	 * @return {Rectangle}
	 * @protected
	 **/
	p._getBounds = function(matrix, ignoreTransform){
		return this._transformBounds(this.getBounds(), matrix, ignoreTransform);
	};
	
	/**
	 * @method _transformBounds
	 * @param {Rectangle} bounds
	 * @param {Matrix2D} matrix
	 * @param {Boolean} ignoreTransform
	 * @return {Rectangle}
	 * @protected
	 **/
	p._transformBounds = function(bounds, matrix, ignoreTransform) {
		if (!bounds) { return bounds; }
		var x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height, mtx = this._props.matrix;
		mtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);
		
		if (x || y) { mtx.appendTransform(0,0,1,1,0,0,0,-x,-y); } // TODO: simplify this.
		if (matrix) { mtx.prependMatrix(matrix); }
		
		var x_a = width*mtx.a, x_b = width*mtx.b;
		var y_c = height*mtx.c, y_d = height*mtx.d;
		var tx = mtx.tx, ty = mtx.ty;
		
		var minX = tx, maxX = tx, minY = ty, maxY = ty;

		if ((x = x_a + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }
		if ((x = x_a + y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }
		if ((x = y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }
		
		if ((y = x_b + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }
		if ((y = x_b + y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }
		if ((y = y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }
		
		return bounds.setValues(minX, minY, maxX-minX, maxY-minY);
	};
	
	/**
	 * Indicates whether the display object has any mouse event listeners or a cursor.
	 * @method _isMouseOpaque
	 * @return {Boolean}
	 * @protected
	 **/
	p._hasMouseEventListener = function() {
		var evts = DisplayObject._MOUSE_EVENTS;
		for (var i= 0, l=evts.length; i<l; i++) {
			if (this.hasEventListener(evts[i])) { return true; }
		}
		return !!this.cursor;
	};

	createjs.DisplayObject = createjs.promote(DisplayObject, "EventDispatcher");
}());

//##############################################################################
// Container.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";
	

// constructor:
/**
 * A Container is a nestable display list that allows you to work with compound display elements. For  example you could
 * group arm, leg, torso and head {{#crossLink "Bitmap"}}{{/crossLink}} instances together into a Person Container, and
 * transform them as a group, while still being able to move the individual parts relative to each other. Children of
 * containers have their <code>transform</code> and <code>alpha</code> properties concatenated with their parent
 * Container.
 *
 * For example, a {{#crossLink "Shape"}}{{/crossLink}} with x=100 and alpha=0.5, placed in a Container with <code>x=50</code>
 * and <code>alpha=0.7</code> will be rendered to the canvas at <code>x=150</code> and <code>alpha=0.35</code>.
 * Containers have some overhead, so you generally shouldn't create a Container to hold a single child.
 *
 * <h4>Example</h4>
 *
 *      var container = new createjs.Container();
 *      container.addChild(bitmapInstance, shapeInstance);
 *      container.x = 100;
 *
 * @class Container
 * @extends DisplayObject
 * @constructor
 **/
	function Container() {
		this.DisplayObject_constructor();
		
	// public properties:
		/**
		 * The array of children in the display list. You should usually use the child management methods such as
		 * {{#crossLink "Container/addChild"}}{{/crossLink}}, {{#crossLink "Container/removeChild"}}{{/crossLink}},
		 * {{#crossLink "Container/swapChildren"}}{{/crossLink}}, etc, rather than accessing this directly, but it is
		 * included for advanced uses.
		 * @property children
		 * @type Array
		 * @default null
		 **/
		this.children = [];
		
		/**
		 * Indicates whether the children of this container are independently enabled for mouse/pointer interaction.
		 * If false, the children will be aggregated under the container - for example, a click on a child shape would
		 * trigger a click event on the container.
		 * @property mouseChildren
		 * @type Boolean
		 * @default true
		 **/
		this.mouseChildren = true;
		
		/**
		 * If false, the tick will not be propagated to children of this Container. This can provide some performance benefits.
		 * In addition to preventing the "tick" event from being dispatched, it will also prevent tick related updates
		 * on some display objects (ex. Sprite & MovieClip frame advancing, DOMElement visibility handling).
		 * @property tickChildren
		 * @type Boolean
		 * @default true
		 **/
		this.tickChildren = true;
	}
	var p = createjs.extend(Container, createjs.DisplayObject);
	
	
// getter / setters:
	/**
	 * Use the {{#crossLink "Container/numChildren:property"}}{{/crossLink}} property instead.
	 * @method getNumChildren
	 * @return {Number}
	 * @deprecated
	 **/
	p.getNumChildren = function() {
		return this.children.length;
	};

	/**
	 * Returns the number of children in the container.
	 * @property numChildren
	 * @type {Number}
	 * @readonly
	 **/
	try {
		Object.defineProperties(p, {
			numChildren: { get: p.getNumChildren }
		});
	} catch (e) {}
	

// public methods:
	/**
	 * Constructor alias for backwards compatibility. This method will be removed in future versions.
	 * Subclasses should be updated to use {{#crossLink "Utility Methods/extends"}}{{/crossLink}}.
	 * @method initialize
	 * @deprecated in favour of `createjs.promote()`
	 **/
	p.initialize = Container; // TODO: deprecated.
	
	/**
	 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
	 **/
	p.isVisible = function() {
		var hasContent = this.cacheCanvas || this.children.length;
		return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
	};

	/**
	 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
	 * Returns true if the draw was handled (useful for overriding functionality).
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache.
	 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
	 * into itself).
	 **/
	p.draw = function(ctx, ignoreCache) {
		if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
		
		// this ensures we don't have issues with display list changes that occur during a draw:
		var list = this.children.slice();
		for (var i=0,l=list.length; i<l; i++) {
			var child = list[i];
			if (!child.isVisible()) { continue; }
			
			// draw the child:
			ctx.save();
			child.updateContext(ctx);
			child.draw(ctx);
			ctx.restore();
		}
		return true;
	};
	
	/**
	 * Adds a child to the top of the display list.
	 *
	 * <h4>Example</h4>
	 *
	 * 		container.addChild(bitmapInstance);
	 *
	 * You can also add multiple children at once:
	 *
	 * 		container.addChild(bitmapInstance, shapeInstance, textInstance);
	 *
	 * @method addChild
	 * @param {DisplayObject} child The display object to add.
	 * @return {DisplayObject} The child that was added, or the last child if multiple children were added.
	 **/
	p.addChild = function(child) {
		if (child == null) { return child; }
		var l = arguments.length;
		if (l > 1) {
			for (var i=0; i<l; i++) { this.addChild(arguments[i]); }
			return arguments[l-1];
		}
		if (child.parent) { child.parent.removeChild(child); }
		child.parent = this;
		this.children.push(child);
		child.dispatchEvent("added");
		return child;
	};

	/**
	 * Adds a child to the display list at the specified index, bumping children at equal or greater indexes up one, and
	 * setting its parent to this Container.
	 *
	 * <h4>Example</h4>
	 *
	 *      addChildAt(child1, index);
	 *
	 * You can also add multiple children, such as:
	 *
	 *      addChildAt(child1, child2, ..., index);
	 *
	 * The index must be between 0 and numChildren. For example, to add myShape under otherShape in the display list,
	 * you could use:
	 *
	 *      container.addChildAt(myShape, container.getChildIndex(otherShape));
	 *
	 * This would also bump otherShape's index up by one. Fails silently if the index is out of range.
	 *
	 * @method addChildAt
	 * @param {DisplayObject} child The display object to add.
	 * @param {Number} index The index to add the child at.
	 * @return {DisplayObject} Returns the last child that was added, or the last child if multiple children were added.
	 **/
	p.addChildAt = function(child, index) {
		var l = arguments.length;
		var indx = arguments[l-1]; // can't use the same name as the index param or it replaces arguments[1]
		if (indx < 0 || indx > this.children.length) { return arguments[l-2]; }
		if (l > 2) {
			for (var i=0; i<l-1; i++) { this.addChildAt(arguments[i], indx+i); }
			return arguments[l-2];
		}
		if (child.parent) { child.parent.removeChild(child); }
		child.parent = this;
		this.children.splice(index, 0, child);
		child.dispatchEvent("added");
		return child;
	};

	/**
	 * Removes the specified child from the display list. Note that it is faster to use removeChildAt() if the index is
	 * already known.
	 *
	 * <h4>Example</h4>
	 *
	 *      container.removeChild(child);
	 *
	 * You can also remove multiple children:
	 *
	 *      removeChild(child1, child2, ...);
	 *
	 * Returns true if the child (or children) was removed, or false if it was not in the display list.
	 * @method removeChild
	 * @param {DisplayObject} child The child to remove.
	 * @return {Boolean} true if the child (or children) was removed, or false if it was not in the display list.
	 **/
	p.removeChild = function(child) {
		var l = arguments.length;
		if (l > 1) {
			var good = true;
			for (var i=0; i<l; i++) { good = good && this.removeChild(arguments[i]); }
			return good;
		}
		return this.removeChildAt(createjs.indexOf(this.children, child));
	};

	/**
	 * Removes the child at the specified index from the display list, and sets its parent to null.
	 *
	 * <h4>Example</h4>
	 *
	 *      container.removeChildAt(2);
	 *
	 * You can also remove multiple children:
	 *
	 *      container.removeChild(2, 7, ...)
	 *
	 * Returns true if the child (or children) was removed, or false if any index was out of range.
	 * @method removeChildAt
	 * @param {Number} index The index of the child to remove.
	 * @return {Boolean} true if the child (or children) was removed, or false if any index was out of range.
	 **/
	p.removeChildAt = function(index) {
		var l = arguments.length;
		if (l > 1) {
			var a = [];
			for (var i=0; i<l; i++) { a[i] = arguments[i]; }
			a.sort(function(a, b) { return b-a; });
			var good = true;
			for (var i=0; i<l; i++) { good = good && this.removeChildAt(a[i]); }
			return good;
		}
		if (index < 0 || index > this.children.length-1) { return false; }
		var child = this.children[index];
		if (child) { child.parent = null; }
		this.children.splice(index, 1);
		child.dispatchEvent("removed");
		return true;
	};

	/**
	 * Removes all children from the display list.
	 *
	 * <h4>Example</h4>
	 *
	 * 	container.removeAllChildren();
	 *
	 * @method removeAllChildren
	 **/
	p.removeAllChildren = function() {
		var kids = this.children;
		while (kids.length) { this.removeChildAt(0); }
	};

	/**
	 * Returns the child at the specified index.
	 *
	 * <h4>Example</h4>
	 *
	 *      container.getChildAt(2);
	 *
	 * @method getChildAt
	 * @param {Number} index The index of the child to return.
	 * @return {DisplayObject} The child at the specified index. Returns null if there is no child at the index.
	 **/
	p.getChildAt = function(index) {
		return this.children[index];
	};
	
	/**
	 * Returns the child with the specified name.
	 * @method getChildByName
	 * @param {String} name The name of the child to return.
	 * @return {DisplayObject} The child with the specified name.
	 **/
	p.getChildByName = function(name) {
		var kids = this.children;
		for (var i=0,l=kids.length;i<l;i++) {
			if(kids[i].name == name) { return kids[i]; }
		}
		return null;
	};

	/**
	 * Performs an array sort operation on the child list.
	 *
	 * <h4>Example: Display children with a higher y in front.</h4>
	 * 
	 *      var sortFunction = function(obj1, obj2, options) {
	 *          if (obj1.y > obj2.y) { return 1; }
	 *          if (obj1.y < obj2.y) { return -1; }
	 *          return 0;
	 *      }
	 *      container.sortChildren(sortFunction);
	 *
	 * @method sortChildren
	 * @param {Function} sortFunction the function to use to sort the child list. See JavaScript's <code>Array.sort</code>
	 * documentation for details.
	 **/
	p.sortChildren = function(sortFunction) {
		this.children.sort(sortFunction);
	};

	/**
	 * Returns the index of the specified child in the display list, or -1 if it is not in the display list.
	 *
	 * <h4>Example</h4>
	 *
	 *      var index = container.getChildIndex(child);
	 *
	 * @method getChildIndex
	 * @param {DisplayObject} child The child to return the index of.
	 * @return {Number} The index of the specified child. -1 if the child is not found.
	 **/
	p.getChildIndex = function(child) {
		return createjs.indexOf(this.children, child);
	};
	
	/**
	 * Swaps the children at the specified indexes. Fails silently if either index is out of range.
	 * @method swapChildrenAt
	 * @param {Number} index1
	 * @param {Number} index2
	 **/
	p.swapChildrenAt = function(index1, index2) {
		var kids = this.children;
		var o1 = kids[index1];
		var o2 = kids[index2];
		if (!o1 || !o2) { return; }
		kids[index1] = o2;
		kids[index2] = o1;
	};
	
	/**
	 * Swaps the specified children's depth in the display list. Fails silently if either child is not a child of this
	 * Container.
	 * @method swapChildren
	 * @param {DisplayObject} child1
	 * @param {DisplayObject} child2
	 **/
	p.swapChildren = function(child1, child2) {
		var kids = this.children;
		var index1,index2;
		for (var i=0,l=kids.length;i<l;i++) {
			if (kids[i] == child1) { index1 = i; }
			if (kids[i] == child2) { index2 = i; }
			if (index1 != null && index2 != null) { break; }
		}
		if (i==l) { return; } // TODO: throw error?
		kids[index1] = child2;
		kids[index2] = child1;
	};
	
	/**
	 * Changes the depth of the specified child. Fails silently if the child is not a child of this container, or the index is out of range.
	 * @param {DisplayObject} child
	 * @param {Number} index  
	 * @method setChildIndex
	 **/
	p.setChildIndex = function(child, index) {
		var kids = this.children, l=kids.length;
		if (child.parent != this || index < 0 || index >= l) { return; }
		for (var i=0;i<l;i++) {
			if (kids[i] == child) { break; }
		}
		if (i==l || i == index) { return; }
		kids.splice(i,1);
		kids.splice(index,0,child);
	};

	/**
	 * Returns true if the specified display object either is this container or is a descendent (child, grandchild, etc)
	 * of this container.
	 * @method contains
	 * @param {DisplayObject} child The DisplayObject to be checked.
	 * @return {Boolean} true if the specified display object either is this container or is a descendent.
	 **/
	p.contains = function(child) {
		while (child) {
			if (child == this) { return true; }
			child = child.parent;
		}
		return false;
	};

	/**
	 * Tests whether the display object intersects the specified local point (ie. draws a pixel with alpha > 0 at the
	 * specified position). This ignores the alpha, shadow and compositeOperation of the display object, and all
	 * transform properties including regX/Y.
	 * @method hitTest
	 * @param {Number} x The x position to check in the display object's local coordinates.
	 * @param {Number} y The y position to check in the display object's local coordinates.
	 * @return {Boolean} A Boolean indicating whether there is a visible section of a DisplayObject that overlaps the specified
	 * coordinates.
	 **/
	p.hitTest = function(x, y) {
		// TODO: optimize to use the fast cache check where possible.
		return (this.getObjectUnderPoint(x, y) != null);
	};

	/**
	 * Returns an array of all display objects under the specified coordinates that are in this container's display
	 * list. This routine ignores any display objects with {{#crossLink "DisplayObject/mouseEnabled:property"}}{{/crossLink}}
	 * set to `false`. The array will be sorted in order of visual depth, with the top-most display object at index 0.
	 * This uses shape based hit detection, and can be an expensive operation to run, so it is best to use it carefully.
	 * For example, if testing for objects under the mouse, test on tick (instead of on {{#crossLink "DisplayObject/mousemove:event"}}{{/crossLink}}),
	 * and only if the mouse's position has changed.
	 * 
	 * <ul>
	 *     <li>By default (mode=0) this method evaluates all display objects.</li>
	 *     <li>By setting the `mode` parameter to `1`, the {{#crossLink "DisplayObject/mouseEnabled:property"}}{{/crossLink}}
	 * 		and {{#crossLink "mouseChildren:property"}}{{/crossLink}} properties will be respected.</li>
	 * 	   <li>Setting the `mode` to `2` additionally excludes display objects that do not have active mouse event
	 * 	   	listeners or a {{#crossLink "DisplayObject:cursor:property"}}{{/crossLink}} property. That is, only objects
	 * 	   	that would normally intercept mouse interaction will be included. This can significantly improve performance
	 * 	   	in some cases by reducing the number of display objects that need to be tested.</li>
	 * </li>
	 * 
	 * This method accounts for both {{#crossLink "DisplayObject/hitArea:property"}}{{/crossLink}} and {{#crossLink "DisplayObject/mask:property"}}{{/crossLink}}.
	 * @method getObjectsUnderPoint
	 * @param {Number} x The x position in the container to test.
	 * @param {Number} y The y position in the container to test.
	 * @param {Number} [mode=0] The mode to use to determine which display objects to include. 0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.
	 * @return {Array} An Array of DisplayObjects under the specified coordinates.
	 **/
	p.getObjectsUnderPoint = function(x, y, mode) {
		var arr = [];
		var pt = this.localToGlobal(x, y);
		this._getObjectsUnderPoint(pt.x, pt.y, arr, mode>0, mode==1);
		return arr;
	};

	/**
	 * Similar to {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}}, but returns only the top-most display
	 * object. This runs significantly faster than <code>getObjectsUnderPoint()</code>, but is still potentially an expensive
	 * operation. See {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}} for more information.
	 * @method getObjectUnderPoint
	 * @param {Number} x The x position in the container to test.
	 * @param {Number} y The y position in the container to test.
	 * @param {Number} mode The mode to use to determine which display objects to include.  0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.
	 * @return {DisplayObject} The top-most display object under the specified coordinates.
	 **/
	p.getObjectUnderPoint = function(x, y, mode) {
		var pt = this.localToGlobal(x, y);
		return this._getObjectsUnderPoint(pt.x, pt.y, null, mode>0, mode==1);
	};
	
	/**
	 * Docced in superclass.
	 */
	p.getBounds = function() {
		return this._getBounds(null, true);
	};
	
	
	/**
	 * Docced in superclass.
	 */
	p.getTransformedBounds = function() {
		return this._getBounds();
	};

	/**
	 * Returns a clone of this Container. Some properties that are specific to this instance's current context are
	 * reverted to their defaults (for example .parent).
	 * @method clone
	 * @param {Boolean} [recursive=false] If true, all of the descendants of this container will be cloned recursively. If false, the
	 * properties of the container will be cloned, but the new instance will not have any children.
	 * @return {Container} A clone of the current Container instance.
	 **/
	p.clone = function(recursive) {
		var o = this._cloneProps(new Container());
		if (recursive) { this._cloneChildren(o); }
		return o;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Container (name="+  this.name +")]";
	};


// private methods:
	/**
	 * @method _tick
	 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
	 * @protected
	 **/
	p._tick = function(evtObj) {
		if (this.tickChildren) {
			for (var i=this.children.length-1; i>=0; i--) {
				var child = this.children[i];
				if (child.tickEnabled && child._tick) { child._tick(evtObj); }
			}
		}
		this.DisplayObject__tick(evtObj);
	};
	
	/**
	 * Recursively clones all children of this container, and adds them to the target container.
	 * @method cloneChildren
	 * @protected
	 * @param {Container} o The target container.
	 **/
	p._cloneChildren = function(o) {
		if (o.children.length) { o.removeAllChildren(); }
		var arr = o.children;
		for (var i=0, l=this.children.length; i<l; i++) {
			var clone = this.children[i].clone(true);
			clone.parent = o;
			arr.push(clone);
		}
	};

	/**
	 * @method _getObjectsUnderPoint
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Array} arr
	 * @param {Boolean} mouse If true, it will respect mouse interaction properties like mouseEnabled, mouseChildren, and active listeners.
	 * @param {Boolean} activeListener If true, there is an active mouse event listener on a parent object.
	 * @param {Number} currentDepth Indicates the current depth of the search.
	 * @return {DisplayObject}
	 * @protected
	 **/
	p._getObjectsUnderPoint = function(x, y, arr, mouse, activeListener, currentDepth) {
		currentDepth = currentDepth || 0;
		if (!currentDepth && !this._testMask(this, x, y)) { return null; }
		var mtx, ctx = createjs.DisplayObject._hitTestContext;
		activeListener = activeListener || (mouse&&this._hasMouseEventListener());

		// draw children one at a time, and check if we get a hit:
		var children = this.children, l = children.length;
		for (var i=l-1; i>=0; i--) {
			var child = children[i];
			var hitArea = child.hitArea;
			if (!child.visible || (!hitArea && !child.isVisible()) || (mouse && !child.mouseEnabled)) { continue; }
			if (!hitArea && !this._testMask(child, x, y)) { continue; }
			
			// if a child container has a hitArea then we only need to check its hitArea, so we can treat it as a normal DO:
			if (!hitArea && child instanceof Container) {
				var result = child._getObjectsUnderPoint(x, y, arr, mouse, activeListener, currentDepth+1);
				if (!arr && result) { return (mouse && !this.mouseChildren) ? this : result; }
			} else {
				if (mouse && !activeListener && !child._hasMouseEventListener()) { continue; }
				
				// TODO: can we pass displayProps forward, to avoid having to calculate this backwards every time? It's kind of a mixed bag. When we're only hunting for DOs with event listeners, it may not make sense.
				var props = child.getConcatenatedDisplayProps(child._props);
				mtx = props.matrix;
				
				if (hitArea) {
					mtx.appendMatrix(hitArea.getMatrix(hitArea._props.matrix));
					props.alpha = hitArea.alpha;
				}
				
				ctx.globalAlpha = props.alpha;
				ctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);
				(hitArea||child).draw(ctx);
				if (!this._testHit(ctx)) { continue; }
				ctx.setTransform(1, 0, 0, 1, 0, 0);
				ctx.clearRect(0, 0, 2, 2);
				if (arr) { arr.push(child); }
				else { return (mouse && !this.mouseChildren) ? this : child; }
			}
		}
		return null;
	};
	
	/**
	 * @method _testMask
	 * @param {DisplayObject} target
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Boolean} Indicates whether the x/y is within the masked region.
	 * @protected
	 **/
	p._testMask = function(target, x, y) {
		var mask = target.mask;
		if (!mask || !mask.graphics || mask.graphics.isEmpty()) { return true; }
		
		var mtx = this._props.matrix, parent = target.parent;
		mtx = parent ? parent.getConcatenatedMatrix(mtx) : mtx.identity();
		mtx = mask.getMatrix(mask._props.matrix).prependMatrix(mtx);
		
		var ctx = createjs.DisplayObject._hitTestContext;
		ctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);
		
		// draw the mask as a solid fill:
		mask.graphics.drawAsPath(ctx);
		ctx.fillStyle = "#000";
		ctx.fill();
		
		if (!this._testHit(ctx)) { return false; }
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		ctx.clearRect(0, 0, 2, 2);
		
		return true;
	};
	
	/**
	 * @method _getBounds
	 * @param {Matrix2D} matrix
	 * @param {Boolean} ignoreTransform If true, does not apply this object's transform.
	 * @return {Rectangle}
	 * @protected
	 **/
	p._getBounds = function(matrix, ignoreTransform) {
		var bounds = this.DisplayObject_getBounds();
		if (bounds) { return this._transformBounds(bounds, matrix, ignoreTransform); }
		
		var mtx = this._props.matrix;
		mtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);
		if (matrix) { mtx.prependMatrix(matrix); }
		
		var l = this.children.length, rect=null;
		for (var i=0; i<l; i++) {
			var child = this.children[i];
			if (!child.visible || !(bounds = child._getBounds(mtx))) { continue; }
			if (rect) { rect.extend(bounds.x, bounds.y, bounds.width, bounds.height); }
			else { rect = bounds.clone(); }
		}
		return rect;
	};


	createjs.Container = createjs.promote(Container, "DisplayObject");
}());

//##############################################################################
// Stage.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * A stage is the root level {{#crossLink "Container"}}{{/crossLink}} for a display list. Each time its {{#crossLink "Stage/tick"}}{{/crossLink}}
	 * method is called, it will render its display list to its target canvas.
	 *
	 * <h4>Example</h4>
	 * This example creates a stage, adds a child to it, then uses {{#crossLink "Ticker"}}{{/crossLink}} to update the child
	 * and redraw the stage using {{#crossLink "Stage/update"}}{{/crossLink}}.
	 *
	 *      var stage = new createjs.Stage("canvasElementId");
	 *      var image = new createjs.Bitmap("imagePath.png");
	 *      stage.addChild(image);
	 *      createjs.Ticker.addEventListener("tick", handleTick);
	 *      function handleTick(event) {
	 *          image.x += 10;
	 *          stage.update();
	 *      }
	 *
	 * @class Stage
	 * @extends Container
	 * @constructor
	 * @param {HTMLCanvasElement | String | Object} canvas A canvas object that the Stage will render to, or the string id
	 * of a canvas object in the current document.
	 **/
	function Stage(canvas) {
		this.Container_constructor();
	
	
	// public properties:
		/**
		 * Indicates whether the stage should automatically clear the canvas before each render. You can set this to <code>false</code>
		 * to manually control clearing (for generative art, or when pointing multiple stages at the same canvas for
		 * example).
		 *
		 * <h4>Example</h4>
		 *
		 *      var stage = new createjs.Stage("canvasId");
		 *      stage.autoClear = false;
		 *
		 * @property autoClear
		 * @type Boolean
		 * @default true
		 **/
		this.autoClear = true;
	
		/**
		 * The canvas the stage will render to. Multiple stages can share a single canvas, but you must disable autoClear for all but the
		 * first stage that will be ticked (or they will clear each other's render).
		 *
		 * When changing the canvas property you must disable the events on the old canvas, and enable events on the
		 * new canvas or mouse events will not work as expected. For example:
		 *
		 *      myStage.enableDOMEvents(false);
		 *      myStage.canvas = anotherCanvas;
		 *      myStage.enableDOMEvents(true);
		 *
		 * @property canvas
		 * @type HTMLCanvasElement | Object
		 **/
		this.canvas = (typeof canvas == "string") ? document.getElementById(canvas) : canvas;
	
		/**
		 * The current mouse X position on the canvas. If the mouse leaves the canvas, this will indicate the most recent
		 * position over the canvas, and mouseInBounds will be set to false.
		 * @property mouseX
		 * @type Number
		 * @readonly
		 **/
		this.mouseX = 0;
	
		/**
		 * The current mouse Y position on the canvas. If the mouse leaves the canvas, this will indicate the most recent
		 * position over the canvas, and mouseInBounds will be set to false.
		 * @property mouseY
		 * @type Number
		 * @readonly
		 **/
		this.mouseY = 0;
	
		/**
		 * Specifies the area of the stage to affect when calling update. This can be use to selectively
		 * re-draw specific regions of the canvas. If null, the whole canvas area is drawn.
		 * @property drawRect
		 * @type {Rectangle}
		 */
		this.drawRect = null;
	
		/**
		 * Indicates whether display objects should be rendered on whole pixels. You can set the
		 * {{#crossLink "DisplayObject/snapToPixel"}}{{/crossLink}} property of
		 * display objects to false to enable/disable this behaviour on a per instance basis.
		 * @property snapToPixelEnabled
		 * @type Boolean
		 * @default false
		 **/
		this.snapToPixelEnabled = false;
	
		/**
		 * Indicates whether the mouse is currently within the bounds of the canvas.
		 * @property mouseInBounds
		 * @type Boolean
		 * @default false
		 **/
		this.mouseInBounds = false;
	
		/**
		 * If true, tick callbacks will be called on all display objects on the stage prior to rendering to the canvas.
		 * @property tickOnUpdate
		 * @type Boolean
		 * @default true
		 **/
		this.tickOnUpdate = true;
	
		/**
		 * If true, mouse move events will continue to be called when the mouse leaves the target canvas. See
		 * {{#crossLink "Stage/mouseInBounds:property"}}{{/crossLink}}, and {{#crossLink "MouseEvent"}}{{/crossLink}}
		 * x/y/rawX/rawY.
		 * @property mouseMoveOutside
		 * @type Boolean
		 * @default false
		 **/
		this.mouseMoveOutside = false;
		
		
		/**
		 * Prevents selection of other elements in the html page if the user clicks and drags, or double clicks on the canvas.
		 * This works by calling `preventDefault()` on any mousedown events (or touch equivalent) originating on the canvas.
		 * @property preventSelection
		 * @type Boolean
		 * @default true
		 **/
		this.preventSelection = true;
	
		/**
		 * The hitArea property is not supported for Stage.
		 * @property hitArea
		 * @type {DisplayObject}
		 * @default null
		 */
		 
		 
	// private properties:
		/**
		 * Holds objects with data for each active pointer id. Each object has the following properties:
		 * x, y, event, target, overTarget, overX, overY, inBounds, posEvtObj (native event that last updated position)
		 * @property _pointerData
		 * @type {Object}
		 * @private
		 */
		this._pointerData = {};
	
		/**
		 * Number of active pointers.
		 * @property _pointerCount
		 * @type {Object}
		 * @private
		 */
		this._pointerCount = 0;
	
		/**
		 * The ID of the primary pointer.
		 * @property _primaryPointerID
		 * @type {Object}
		 * @private
		 */
		this._primaryPointerID = null;
	
		/**
		 * @property _mouseOverIntervalID
		 * @protected
		 * @type Number
		 **/
		this._mouseOverIntervalID = null;
		
		/**
		 * @property _nextStage
		 * @protected
		 * @type Stage
		 **/
		this._nextStage = null;
		
		/**
		 * @property _prevStage
		 * @protected
		 * @type Stage
		 **/
		this._prevStage = null;
		
		
	// initialize:
		this.enableDOMEvents(true);
	}
	var p = createjs.extend(Stage, createjs.Container);

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// events:
	/**
	 * Dispatched when the user moves the mouse over the canvas.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event stagemousemove
	 * @since 0.6.0
	 */

	/**
	 * Dispatched when the user presses their left mouse button on the canvas. See the {{#crossLink "MouseEvent"}}{{/crossLink}}
	 * class for a listing of event properties.
	 * @event stagemousedown
	 * @since 0.6.0
	 */

	/**
	 * Dispatched when the user the user presses somewhere on the stage, then releases the mouse button anywhere that the page can detect it (this varies slightly between browsers).
	 * You can use {{#crossLink "Stage/mouseInBounds:property"}}{{/crossLink}} to check whether the mouse is currently within the stage bounds.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event stagemouseup
	 * @since 0.6.0
	 */

	/**
	 * Dispatched when the mouse moves from within the canvas area (mouseInBounds == true) to outside it (mouseInBounds == false).
	 * This is currently only dispatched for mouse input (not touch). See the {{#crossLink "MouseEvent"}}{{/crossLink}}
	 * class for a listing of event properties.
	 * @event mouseleave
	 * @since 0.7.0
	 */

	/**
	 * Dispatched when the mouse moves into the canvas area (mouseInBounds == false) from outside it (mouseInBounds == true).
	 * This is currently only dispatched for mouse input (not touch). See the {{#crossLink "MouseEvent"}}{{/crossLink}}
	 * class for a listing of event properties.
	 * @event mouseenter
	 * @since 0.7.0
	 */
	 
	/**
	 * Dispatched each update immediately before the tick event is propagated through the display list.
	 * You can call preventDefault on the event object to cancel propagating the tick event.
	 * @event tickstart
	 * @since 0.7.0
	 */
	 
	/**
	 * Dispatched each update immediately after the tick event is propagated through the display list. Does not fire if
	 * tickOnUpdate is false. Precedes the "drawstart" event.
	 * @event tickend
	 * @since 0.7.0
	 */
	 
	/**
	 * Dispatched each update immediately before the canvas is cleared and the display list is drawn to it.
	 * You can call preventDefault on the event object to cancel the draw.
	 * @event drawstart
	 * @since 0.7.0
	 */
	 
	/**
	 * Dispatched each update immediately after the display list is drawn to the canvas and the canvas context is restored.
	 * @event drawend
	 * @since 0.7.0
	 */

	 
// getter / setters:
	/**
	 * Specifies a target stage that will have mouse / touch interactions relayed to it after this stage handles them.
	 * This can be useful in cases where you have multiple layered canvases and want user interactions
	 * events to pass through. For example, this would relay mouse events from topStage to bottomStage:
	 *
	 *      topStage.nextStage = bottomStage;
	 *
	 * To disable relaying, set nextStage to null.
	 * 
	 * MouseOver, MouseOut, RollOver, and RollOut interactions are also passed through using the mouse over settings
	 * of the top-most stage, but are only processed if the target stage has mouse over interactions enabled.
	 * Considerations when using roll over in relay targets:<OL>
	 * <LI> The top-most (first) stage must have mouse over interactions enabled (via enableMouseOver)</LI>
	 * <LI> All stages that wish to participate in mouse over interaction must enable them via enableMouseOver</LI>
	 * <LI> All relay targets will share the frequency value of the top-most stage</LI>
	 * </OL>
	 * To illustrate, in this example the targetStage would process mouse over interactions at 10hz (despite passing
	 * 30 as it's desired frequency):
	 * 	topStage.nextStage = targetStage;
	 * 	topStage.enableMouseOver(10);
	 * 	targetStage.enableMouseOver(30);
	 * 
	 * If the target stage's canvas is completely covered by this stage's canvas, you may also want to disable its
	 * DOM events using:
	 * 
	 *	targetStage.enableDOMEvents(false);
	 * 
	 * @property nextStage
	 * @type {Stage}
	 **/
	p._get_nextStage = function() {
		return this._nextStage;
	};
	p._set_nextStage = function(value) {
		if (this._nextStage) { this._nextStage._prevStage = null; }
		if (value) { value._prevStage = this; }
		this._nextStage = value;
	};
	
	try {
		Object.defineProperties(p, {
			nextStage: { get: p._get_nextStage, set: p._set_nextStage }
		});
	} catch (e) {} // TODO: use Log


// public methods:
	/**
	 * Each time the update method is called, the stage will call {{#crossLink "Stage/tick"}}{{/crossLink}}
	 * unless {{#crossLink "Stage/tickOnUpdate:property"}}{{/crossLink}} is set to false,
	 * and then render the display list to the canvas.
	 *
	 * @method update
	 * @param {Object} [props] Props object to pass to `tick()`. Should usually be a {{#crossLink "Ticker"}}{{/crossLink}} event object, or similar object with a delta property.
	 **/
	p.update = function(props) {
		if (!this.canvas) { return; }
		if (this.tickOnUpdate) { this.tick(props); }
		if (this.dispatchEvent("drawstart", false, true) === false) { return; }
		createjs.DisplayObject._snapToPixelEnabled = this.snapToPixelEnabled;
		var r = this.drawRect, ctx = this.canvas.getContext("2d");
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		if (this.autoClear) {
			if (r) { ctx.clearRect(r.x, r.y, r.width, r.height); }
			else { ctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1); }
		}
		ctx.save();
		if (this.drawRect) {
			ctx.beginPath();
			ctx.rect(r.x, r.y, r.width, r.height);
			ctx.clip();
		}
		this.updateContext(ctx);
		this.draw(ctx, false);
		ctx.restore();
		this.dispatchEvent("drawend");
	};
	
	/**
	 * Propagates a tick event through the display list. This is automatically called by {{#crossLink "Stage/update"}}{{/crossLink}}
	 * unless {{#crossLink "Stage/tickOnUpdate:property"}}{{/crossLink}} is set to false.
	 *
	 * If a props object is passed to `tick()`, then all of its properties will be copied to the event object that is
	 * propagated to listeners.
	 *
	 * Some time-based features in EaselJS (for example {{#crossLink "Sprite/framerate"}}{{/crossLink}} require that
	 * a {{#crossLink "Ticker/tick:event"}}{{/crossLink}} event object (or equivalent object with a delta property) be
	 * passed as the `props` parameter to `tick()`. For example:
	 *
	 * 	Ticker.on("tick", handleTick);
	 * 	function handleTick(evtObj) {
	 * 		// clone the event object from Ticker, and add some custom data to it:
	 * 		var evt = evtObj.clone().set({greeting:"hello", name:"world"});
	 * 		
	 * 		// pass it to stage.update():
	 * 		myStage.update(evt); // subsequently calls tick() with the same param
	 * 	}
	 * 	
	 * 	// ...
	 * 	myDisplayObject.on("tick", handleDisplayObjectTick);
	 * 	function handleDisplayObjectTick(evt) {
	 * 		console.log(evt.delta); // the delta property from the Ticker tick event object
	 * 		console.log(evt.greeting, evt.name); // custom data: "hello world"
	 * 	}
	 * 
	 * @method tick
	 * @param {Object} [props] An object with properties that should be copied to the event object. Should usually be a Ticker event object, or similar object with a delta property.
	 **/
	p.tick = function(props) {
		if (!this.tickEnabled || this.dispatchEvent("tickstart", false, true) === false) { return; }
		var evtObj = new createjs.Event("tick");
		if (props) {
			for (var n in props) {
				if (props.hasOwnProperty(n)) { evtObj[n] = props[n]; }
			}
		}
		this._tick(evtObj);
		this.dispatchEvent("tickend");
	};

	/**
	 * Default event handler that calls the Stage {{#crossLink "Stage/update"}}{{/crossLink}} method when a {{#crossLink "DisplayObject/tick:event"}}{{/crossLink}}
	 * event is received. This allows you to register a Stage instance as a event listener on {{#crossLink "Ticker"}}{{/crossLink}}
	 * directly, using:
	 *
	 *      Ticker.addEventListener("tick", myStage");
	 *
	 * Note that if you subscribe to ticks using this pattern, then the tick event object will be passed through to
	 * display object tick handlers, instead of <code>delta</code> and <code>paused</code> parameters.
	 * @property handleEvent
	 * @type Function
	 **/
	p.handleEvent = function(evt) {
		if (evt.type == "tick") { this.update(evt); }
	};

	/**
	 * Clears the target canvas. Useful if {{#crossLink "Stage/autoClear:property"}}{{/crossLink}} is set to `false`.
	 * @method clear
	 **/
	p.clear = function() {
		if (!this.canvas) { return; }
		var ctx = this.canvas.getContext("2d");
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		ctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1);
	};

	/**
	 * Returns a data url that contains a Base64-encoded image of the contents of the stage. The returned data url can
	 * be specified as the src value of an image element.
	 * @method toDataURL
	 * @param {String} [backgroundColor] The background color to be used for the generated image. Any valid CSS color
	 * value is allowed. The default value is a transparent background.
	 * @param {String} [mimeType="image/png"] The MIME type of the image format to be create. The default is "image/png". If an unknown MIME type
	 * is passed in, or if the browser does not support the specified MIME type, the default value will be used.
	 * @return {String} a Base64 encoded image.
	 **/
	p.toDataURL = function(backgroundColor, mimeType) {
		var data, ctx = this.canvas.getContext('2d'), w = this.canvas.width, h = this.canvas.height;

		if (backgroundColor) {
			data = ctx.getImageData(0, 0, w, h);
			var compositeOperation = ctx.globalCompositeOperation;
			ctx.globalCompositeOperation = "destination-over";
			
			ctx.fillStyle = backgroundColor;
			ctx.fillRect(0, 0, w, h);
		}

		var dataURL = this.canvas.toDataURL(mimeType||"image/png");

		if(backgroundColor) {
			ctx.putImageData(data, 0, 0);
			ctx.globalCompositeOperation = compositeOperation;
		}

		return dataURL;
	};

	/**
	 * Enables or disables (by passing a frequency of 0) mouse over ({{#crossLink "DisplayObject/mouseover:event"}}{{/crossLink}}
	 * and {{#crossLink "DisplayObject/mouseout:event"}}{{/crossLink}}) and roll over events ({{#crossLink "DisplayObject/rollover:event"}}{{/crossLink}}
	 * and {{#crossLink "DisplayObject/rollout:event"}}{{/crossLink}}) for this stage's display list. These events can
	 * be expensive to generate, so they are disabled by default. The frequency of the events can be controlled
	 * independently of mouse move events via the optional `frequency` parameter.
	 *
	 * <h4>Example</h4>
	 *
	 *      var stage = new createjs.Stage("canvasId");
	 *      stage.enableMouseOver(10); // 10 updates per second
	 *
	 * @method enableMouseOver
	 * @param {Number} [frequency=20] Optional param specifying the maximum number of times per second to broadcast
	 * mouse over/out events. Set to 0 to disable mouse over events completely. Maximum is 50. A lower frequency is less
	 * responsive, but uses less CPU.
	 **/
	p.enableMouseOver = function(frequency) {
		if (this._mouseOverIntervalID) {
			clearInterval(this._mouseOverIntervalID);
			this._mouseOverIntervalID = null;
			if (frequency == 0) {
				this._testMouseOver(true);
			}
		}
		if (frequency == null) { frequency = 20; }
		else if (frequency <= 0) { return; }
		var o = this;
		this._mouseOverIntervalID = setInterval(function(){ o._testMouseOver(); }, 1000/Math.min(50,frequency));
	};

	/**
	 * Enables or disables the event listeners that stage adds to DOM elements (window, document and canvas). It is good
	 * practice to disable events when disposing of a Stage instance, otherwise the stage will continue to receive
	 * events from the page.
	 *
	 * When changing the canvas property you must disable the events on the old canvas, and enable events on the
	 * new canvas or mouse events will not work as expected. For example:
	 *
	 *      myStage.enableDOMEvents(false);
	 *      myStage.canvas = anotherCanvas;
	 *      myStage.enableDOMEvents(true);
	 *
	 * @method enableDOMEvents
	 * @param {Boolean} [enable=true] Indicates whether to enable or disable the events. Default is true.
	 **/
	p.enableDOMEvents = function(enable) {
		if (enable == null) { enable = true; }
		var n, o, ls = this._eventListeners;
		if (!enable && ls) {
			for (n in ls) {
				o = ls[n];
				o.t.removeEventListener(n, o.f, false);
			}
			this._eventListeners = null;
		} else if (enable && !ls && this.canvas) {
			var t = window.addEventListener ? window : document;
			var _this = this;
			ls = this._eventListeners = {};
			ls["mouseup"] = {t:t, f:function(e) { _this._handleMouseUp(e)} };
			ls["mousemove"] = {t:t, f:function(e) { _this._handleMouseMove(e)} };
			ls["dblclick"] = {t:this.canvas, f:function(e) { _this._handleDoubleClick(e)} };
			ls["mousedown"] = {t:this.canvas, f:function(e) { _this._handleMouseDown(e)} };

			for (n in ls) {
				o = ls[n];
				o.t.addEventListener(n, o.f, false);
			}
		}
	};

	/**
	 * Stage instances cannot be cloned.
	 * @method clone
	 **/
	p.clone = function() {
		throw("Stage cannot be cloned.");
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Stage (name="+  this.name +")]";
	};


// private methods:
	/**
	 * @method _getElementRect
	 * @protected
	 * @param {HTMLElement} e
	 **/
	p._getElementRect = function(e) {
		var bounds;
		try { bounds = e.getBoundingClientRect(); } // this can fail on disconnected DOM elements in IE9
		catch (err) { bounds = {top: e.offsetTop, left: e.offsetLeft, width:e.offsetWidth, height:e.offsetHeight}; }

		var offX = (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || document.body.clientLeft || 0);
		var offY = (window.pageYOffset || document.scrollTop || 0) - (document.clientTop  || document.body.clientTop  || 0);

		var styles = window.getComputedStyle ? getComputedStyle(e,null) : e.currentStyle; // IE <9 compatibility.
		var padL = parseInt(styles.paddingLeft)+parseInt(styles.borderLeftWidth);
		var padT = parseInt(styles.paddingTop)+parseInt(styles.borderTopWidth);
		var padR = parseInt(styles.paddingRight)+parseInt(styles.borderRightWidth);
		var padB = parseInt(styles.paddingBottom)+parseInt(styles.borderBottomWidth);

		// note: in some browsers bounds properties are read only.
		return {
			left: bounds.left+offX+padL,
			right: bounds.right+offX-padR,
			top: bounds.top+offY+padT,
			bottom: bounds.bottom+offY-padB
		}
	};

	/**
	 * @method _getPointerData
	 * @protected
	 * @param {Number} id
	 **/
	p._getPointerData = function(id) {
		var data = this._pointerData[id];
		if (!data) { data = this._pointerData[id] = {x:0,y:0}; }
		return data;
	};

	/**
	 * @method _handleMouseMove
	 * @protected
	 * @param {MouseEvent} e
	 **/
	p._handleMouseMove = function(e) {
		if(!e){ e = window.event; }
		this._handlePointerMove(-1, e, e.pageX, e.pageY);
	};

	/**
	 * @method _handlePointerMove
	 * @protected
	 * @param {Number} id
	 * @param {Event} e
	 * @param {Number} pageX
	 * @param {Number} pageY
	 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
	 **/
	p._handlePointerMove = function(id, e, pageX, pageY, owner) {
		if (this._prevStage && owner === undefined) { return; } // redundant listener.
		if (!this.canvas) { return; }
		var nextStage=this._nextStage, o=this._getPointerData(id);

		var inBounds = o.inBounds;
		this._updatePointerPosition(id, e, pageX, pageY);
		if (inBounds || o.inBounds || this.mouseMoveOutside) {
			if (id === -1 && o.inBounds == !inBounds) {
				this._dispatchMouseEvent(this, (inBounds ? "mouseleave" : "mouseenter"), false, id, o, e);
			}
			
			this._dispatchMouseEvent(this, "stagemousemove", false, id, o, e);
			this._dispatchMouseEvent(o.target, "pressmove", true, id, o, e);
		}
		
		nextStage&&nextStage._handlePointerMove(id, e, pageX, pageY, null);
	};

	/**
	 * @method _updatePointerPosition
	 * @protected
	 * @param {Number} id
	 * @param {Event} e
	 * @param {Number} pageX
	 * @param {Number} pageY
	 **/
	p._updatePointerPosition = function(id, e, pageX, pageY) {
		var rect = this._getElementRect(this.canvas);
		pageX -= rect.left;
		pageY -= rect.top;

		var w = this.canvas.width;
		var h = this.canvas.height;
		pageX /= (rect.right-rect.left)/w;
		pageY /= (rect.bottom-rect.top)/h;
		var o = this._getPointerData(id);
		if (o.inBounds = (pageX >= 0 && pageY >= 0 && pageX <= w-1 && pageY <= h-1)) {
			o.x = pageX;
			o.y = pageY;
		} else if (this.mouseMoveOutside) {
			o.x = pageX < 0 ? 0 : (pageX > w-1 ? w-1 : pageX);
			o.y = pageY < 0 ? 0 : (pageY > h-1 ? h-1 : pageY);
		}

		o.posEvtObj = e;
		o.rawX = pageX;
		o.rawY = pageY;

		if (id === this._primaryPointerID || id === -1) {
			this.mouseX = o.x;
			this.mouseY = o.y;
			this.mouseInBounds = o.inBounds;
		}
	};

	/**
	 * @method _handleMouseUp
	 * @protected
	 * @param {MouseEvent} e
	 **/
	p._handleMouseUp = function(e) {
		this._handlePointerUp(-1, e, false);
	};

	/**
	 * @method _handlePointerUp
	 * @protected
	 * @param {Number} id
	 * @param {Event} e
	 * @param {Boolean} clear
	 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
	 **/
	p._handlePointerUp = function(id, e, clear, owner) {
		var nextStage = this._nextStage, o = this._getPointerData(id);
		if (this._prevStage && owner === undefined) { return; } // redundant listener.
		
		var target=null, oTarget = o.target;
		if (!owner && (oTarget || nextStage)) { target = this._getObjectsUnderPoint(o.x, o.y, null, true); }
		
		if (o.down) { this._dispatchMouseEvent(this, "stagemouseup", false, id, o, e, target); o.down = false; }
		
		if (target == oTarget) { this._dispatchMouseEvent(oTarget, "click", true, id, o, e); }
		this._dispatchMouseEvent(oTarget, "pressup", true, id, o, e);
		
		if (clear) {
			if (id==this._primaryPointerID) { this._primaryPointerID = null; }
			delete(this._pointerData[id]);
		} else { o.target = null; }
		
		nextStage&&nextStage._handlePointerUp(id, e, clear, owner || target && this);
	};

	/**
	 * @method _handleMouseDown
	 * @protected
	 * @param {MouseEvent} e
	 **/
	p._handleMouseDown = function(e) {
		this._handlePointerDown(-1, e, e.pageX, e.pageY);
	};

	/**
	 * @method _handlePointerDown
	 * @protected
	 * @param {Number} id
	 * @param {Event} e
	 * @param {Number} pageX
	 * @param {Number} pageY
	 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
	 **/
	p._handlePointerDown = function(id, e, pageX, pageY, owner) {
		if (this.preventSelection) { e.preventDefault(); }
		if (this._primaryPointerID == null || id === -1) { this._primaryPointerID = id; } // mouse always takes over.
		
		if (pageY != null) { this._updatePointerPosition(id, e, pageX, pageY); }
		var target = null, nextStage = this._nextStage, o = this._getPointerData(id);
		if (!owner) { target = o.target = this._getObjectsUnderPoint(o.x, o.y, null, true); }

		if (o.inBounds) { this._dispatchMouseEvent(this, "stagemousedown", false, id, o, e, target); o.down = true; }
		this._dispatchMouseEvent(target, "mousedown", true, id, o, e);
		
		nextStage&&nextStage._handlePointerDown(id, e, pageX, pageY, owner || target && this);
	};

	/**
	 * @method _testMouseOver
	 * @param {Boolean} clear If true, clears the mouseover / rollover (ie. no target)
	 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
	 * @param {Stage} eventTarget The stage that the cursor is actively over.
	 * @protected
	 **/
	p._testMouseOver = function(clear, owner, eventTarget) {
		if (this._prevStage && owner === undefined) { return; } // redundant listener.
		
		var nextStage = this._nextStage;
		if (!this._mouseOverIntervalID) {
			// not enabled for mouseover, but should still relay the event.
			nextStage&&nextStage._testMouseOver(clear, owner, eventTarget);
			return;
		}
		var o = this._getPointerData(-1);
		// only update if the mouse position has changed. This provides a lot of optimization, but has some trade-offs.
		if (!o || (!clear && this.mouseX == this._mouseOverX && this.mouseY == this._mouseOverY && this.mouseInBounds)) { return; }
		
		var e = o.posEvtObj;
		var isEventTarget = eventTarget || e&&(e.target == this.canvas);
		var target=null, common = -1, cursor="", t, i, l;
		
		if (!owner && (clear || this.mouseInBounds && isEventTarget)) {
			target = this._getObjectsUnderPoint(this.mouseX, this.mouseY, null, true);
			this._mouseOverX = this.mouseX;
			this._mouseOverY = this.mouseY;
		}

		var oldList = this._mouseOverTarget||[];
		var oldTarget = oldList[oldList.length-1];
		var list = this._mouseOverTarget = [];

		// generate ancestor list and check for cursor:
		t = target;
		while (t) {
			list.unshift(t);
			if (!cursor) { cursor = t.cursor; }
			t = t.parent;
		}
		this.canvas.style.cursor = cursor;
		if (!owner && eventTarget) { eventTarget.canvas.style.cursor = cursor; }

		// find common ancestor:
		for (i=0,l=list.length; i<l; i++) {
			if (list[i] != oldList[i]) { break; }
			common = i;
		}

		if (oldTarget != target) {
			this._dispatchMouseEvent(oldTarget, "mouseout", true, -1, o, e, target);
		}

		for (i=oldList.length-1; i>common; i--) {
			this._dispatchMouseEvent(oldList[i], "rollout", false, -1, o, e, target);
		}

		for (i=list.length-1; i>common; i--) {
			this._dispatchMouseEvent(list[i], "rollover", false, -1, o, e, oldTarget);
		}

		if (oldTarget != target) {
			this._dispatchMouseEvent(target, "mouseover", true, -1, o, e, oldTarget);
		}
		
		nextStage&&nextStage._testMouseOver(clear, owner || target && this, eventTarget || isEventTarget && this);
	};

	/**
	 * @method _handleDoubleClick
	 * @protected
	 * @param {MouseEvent} e
	 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
	 **/
	p._handleDoubleClick = function(e, owner) {
		var target=null, nextStage=this._nextStage, o=this._getPointerData(-1);
		if (!owner) {
			target = this._getObjectsUnderPoint(o.x, o.y, null, true);
			this._dispatchMouseEvent(target, "dblclick", true, -1, o, e);
		}
		nextStage&&nextStage._handleDoubleClick(e, owner || target && this);
	};

	/**
	 * @method _dispatchMouseEvent
	 * @protected
	 * @param {DisplayObject} target
	 * @param {String} type
	 * @param {Boolean} bubbles
	 * @param {Number} pointerId
	 * @param {Object} o
	 * @param {MouseEvent} [nativeEvent]
	 * @param {DisplayObject} [relatedTarget]
	 **/
	p._dispatchMouseEvent = function(target, type, bubbles, pointerId, o, nativeEvent, relatedTarget) {
		// TODO: might be worth either reusing MouseEvent instances, or adding a willTrigger method to avoid GC.
		if (!target || (!bubbles && !target.hasEventListener(type))) { return; }
		/*
		// TODO: account for stage transformations?
		this._mtx = this.getConcatenatedMatrix(this._mtx).invert();
		var pt = this._mtx.transformPoint(o.x, o.y);
		var evt = new createjs.MouseEvent(type, bubbles, false, pt.x, pt.y, nativeEvent, pointerId, pointerId==this._primaryPointerID || pointerId==-1, o.rawX, o.rawY);
		*/
		var evt = new createjs.MouseEvent(type, bubbles, false, o.x, o.y, nativeEvent, pointerId, pointerId === this._primaryPointerID || pointerId === -1, o.rawX, o.rawY, relatedTarget);
		target.dispatchEvent(evt);
	};


	createjs.Stage = createjs.promote(Stage, "Container");
}());

//##############################################################################
// Bitmap.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	
	/**
	 * A Bitmap represents an Image, Canvas, or Video in the display list. A Bitmap can be instantiated using an existing
	 * HTML element, or a string.
	 *
	 * <h4>Example</h4>
	 *
	 *      var bitmap = new createjs.Bitmap("imagePath.jpg");
	 *
	 * <strong>Notes:</strong>
	 * <ol>
	 *     <li>When a string path or image tag that is not yet loaded is used, the stage may need to be redrawn before it
	 *      will be displayed.</li>
	 *     <li>Bitmaps with an SVG source currently will not respect an alpha value other than 0 or 1. To get around this,
	 *     the Bitmap can be cached.</li>
	 *     <li>Bitmaps with an SVG source will taint the canvas with cross-origin data, which prevents interactivity. This
	 *     happens in all browsers except recent Firefox builds.</li>
	 *     <li>Images loaded cross-origin will throw cross-origin security errors when interacted with using a mouse, using
	 *     methods such as `getObjectUnderPoint`, or using filters, or caching. You can get around this by setting
	 *     `crossOrigin` flags on your images before passing them to EaselJS, eg: `img.crossOrigin="Anonymous";`</li>
	 * </ol>
	 *
	 * @class Bitmap
	 * @extends DisplayObject
	 * @constructor
	 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | String} imageOrUri The source object or URI to an image to
	 * display. This can be either an Image, Canvas, or Video object, or a string URI to an image file to load and use.
	 * If it is a URI, a new Image object will be constructed and assigned to the .image property.
	 **/
	function Bitmap(imageOrUri) {
		this.DisplayObject_constructor();
		
		
	// public properties:
		/**
		 * The image to render. This can be an Image, a Canvas, or a Video. Not all browsers (especially
		 * mobile browsers) support drawing video to a canvas.
		 * @property image
		 * @type HTMLImageElement | HTMLCanvasElement | HTMLVideoElement
		 **/
		if (typeof imageOrUri == "string") {
			this.image = document.createElement("img");
			this.image.src = imageOrUri;
		} else {
			this.image = imageOrUri;
		}
	
		/**
		 * Specifies an area of the source image to draw. If omitted, the whole image will be drawn.
		 * Note that video sources must have a width / height set to work correctly with `sourceRect`.
		 * @property sourceRect
		 * @type Rectangle
		 * @default null
		 */
		this.sourceRect = null;
	}
	var p = createjs.extend(Bitmap, createjs.DisplayObject);
	
	
// public methods:
	/**
	 * Constructor alias for backwards compatibility. This method will be removed in future versions.
	 * Subclasses should be updated to use {{#crossLink "Utility Methods/extends"}}{{/crossLink}}.
	 * @method initialize
	 * @deprecated in favour of `createjs.promote()`
	 **/
	p.initialize = Bitmap; // TODO: deprecated.

	/**
	 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
	 **/
	p.isVisible = function() {
		var image = this.image;
		var hasContent = this.cacheCanvas || (image && (image.naturalWidth || image.getContext || image.readyState >= 2));
		return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
	};

	/**
	 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
	 * Returns true if the draw was handled (useful for overriding functionality).
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache.
	 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
	 * into itself).
	 * @return {Boolean}
	 **/
	p.draw = function(ctx, ignoreCache) {
		if (this.DisplayObject_draw(ctx, ignoreCache) || !this.image) { return true; }
		var img = this.image, rect = this.sourceRect;
		if (rect) {
			// some browsers choke on out of bound values, so we'll fix them:
			var x1 = rect.x, y1 = rect.y, x2 = x1 + rect.width, y2 = y1 + rect.height, x = 0, y = 0, w = img.width, h = img.height;
			if (x1 < 0) { x -= x1; x1 = 0; }
			if (x2 > w) { x2 = w; }
			if (y1 < 0) { y -= y1; y1 = 0; }
			if (y2 > h) { y2 = h; }
			ctx.drawImage(img, x1, y1, x2-x1, y2-y1, x, y, x2-x1, y2-y1);
		} else {
			ctx.drawImage(img, 0, 0);
		}
		return true;
	};
	
	//Note, the doc sections below document using the specified APIs (from DisplayObject)  from
	//Bitmap. This is why they have no method implementations.
	
	/**
	 * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.
	 * You should <b>not</b> cache Bitmap instances as it can degrade performance.
	 *
	 * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>
	 * To see the API for caching, please visit the DisplayObject {{#crossLink "DisplayObject/cache"}}{{/crossLink}}
	 * method.
	 * @method cache
	 **/
	
	/**
	 * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.
	 * You should <b>not</b> cache Bitmap instances as it can degrade performance.
	 *
	 * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>
	 * To see the API for caching, please visit the DisplayObject {{#crossLink "DisplayObject/cache"}}{{/crossLink}}
	 * method.
	 * @method updateCache
	 **/
	
	/**
	 * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.
	 * You should <b>not</b> cache Bitmap instances as it can degrade performance.
	 *
	 * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>
	 * To see the API for caching, please visit the DisplayObject {{#crossLink "DisplayObject/cache"}}{{/crossLink}}
	 * method.
	 * @method uncache
	 **/

	/**
	 * Docced in superclass.
	 */
	p.getBounds = function() {
		var rect = this.DisplayObject_getBounds();
		if (rect) { return rect; }
		var image = this.image, o = this.sourceRect || image;
		var hasContent = (image && (image.naturalWidth || image.getContext || image.readyState >= 2));
		return hasContent ? this._rectangle.setValues(0, 0, o.width, o.height) : null;
	};
	
	/**
	 * Returns a clone of the Bitmap instance.
	 * @method clone
	 * @return {Bitmap} a clone of the Bitmap instance.
	 **/
	p.clone = function() {
		var o = new Bitmap(this.image);
		if (this.sourceRect) { o.sourceRect = this.sourceRect.clone(); }
		this._cloneProps(o);
		return o;
	};
	
	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Bitmap (name="+  this.name +")]";
	};

	
	createjs.Bitmap = createjs.promote(Bitmap, "DisplayObject");
}());

//##############################################################################
// Sprite.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Displays a frame or sequence of frames (ie. an animation) from a SpriteSheet instance. A sprite sheet is a series of
	 * images (usually animation frames) combined into a single image. For example, an animation consisting of 8 100x100
	 * images could be combined into a 400x200 sprite sheet (4 frames across by 2 high). You can display individual frames,
	 * play frames as an animation, and even sequence animations together.
	 *
	 * See the {{#crossLink "SpriteSheet"}}{{/crossLink}} class for more information on setting up frames and animations.
	 *
	 * <h4>Example</h4>
	 *
	 *      var instance = new createjs.Sprite(spriteSheet);
	 *      instance.gotoAndStop("frameName");
	 *
	 * Until {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} or {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}} is called,
	 * only the first defined frame defined in the sprite sheet will be displayed.
	 *
	 * @class Sprite
	 * @extends DisplayObject
	 * @constructor
	 * @param {SpriteSheet} spriteSheet The SpriteSheet instance to play back. This includes the source image(s), frame
	 * dimensions, and frame data. See {{#crossLink "SpriteSheet"}}{{/crossLink}} for more information.
	 * @param {String|Number} [frameOrAnimation] The frame number or animation to play initially.
	 **/
	function Sprite(spriteSheet, frameOrAnimation) {
		this.DisplayObject_constructor();
		
		
	// public properties:
		/**
		 * The frame index that will be drawn when draw is called. Note that with some {{#crossLink "SpriteSheet"}}{{/crossLink}}
		 * definitions, this will advance non-sequentially. This will always be an integer value.
		 * @property currentFrame
		 * @type {Number}
		 * @default 0
		 * @readonly
		 **/
		this.currentFrame = 0;
	
		/**
		 * Returns the name of the currently playing animation.
		 * @property currentAnimation
		 * @type {String}
		 * @final
		 * @readonly
		 **/
		this.currentAnimation = null;
	
		/**
		 * Prevents the animation from advancing each tick automatically. For example, you could create a sprite
		 * sheet of icons, set paused to true, and display the appropriate icon by setting <code>currentFrame</code>.
		 * @property paused
		 * @type {Boolean}
		 * @default false
		 **/
		this.paused = true;
	
		/**
		 * The SpriteSheet instance to play back. This includes the source image, frame dimensions, and frame
		 * data. See {{#crossLink "SpriteSheet"}}{{/crossLink}} for more information.
		 * @property spriteSheet
		 * @type {SpriteSheet}
		 * @readonly
		 **/
		this.spriteSheet = spriteSheet;
	
		/**
		 * Specifies the current frame index within the currently playing animation. When playing normally, this will increase
		 * from 0 to n-1, where n is the number of frames in the current animation.
		 *
		 * This could be a non-integer value if
		 * using time-based playback (see {{#crossLink "Sprite/framerate"}}{{/crossLink}}, or if the animation's speed is
		 * not an integer.
		 * @property currentAnimationFrame
		 * @type {Number}
		 * @default 0
		 **/
		this.currentAnimationFrame = 0;
	
		/**
		 * By default Sprite instances advance one frame per tick. Specifying a framerate for the Sprite (or its related
		 * SpriteSheet) will cause it to advance based on elapsed time between ticks as appropriate to maintain the target
		 * framerate.
		 *
		 * For example, if a Sprite with a framerate of 10 is placed on a Stage being updated at 40fps, then the Sprite will
		 * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will
		 * vary slightly between frames.
		 *
		 * This feature is dependent on the tick event object (or an object with an appropriate "delta" property) being
		 * passed into {{#crossLink "Stage/update"}}{{/crossLink}}.
		 * @property framerate
		 * @type {Number}
		 * @default 0
		 **/
		this.framerate = 0;
	
	
	// private properties:
		/**
		 * Current animation object.
		 * @property _animation
		 * @protected
		 * @type {Object}
		 * @default null
		 **/
		this._animation = null;
	
		/**
		 * Current frame index.
		 * @property _currentFrame
		 * @protected
		 * @type {Number}
		 * @default null
		 **/
		this._currentFrame = null;
		
		/**
		 * Skips the next auto advance. Used by gotoAndPlay to avoid immediately jumping to the next frame
		 * @property _skipAdvance
		 * @protected
		 * @type {Boolean}
		 * @default false
		 **/
		this._skipAdvance = false;
		
		
		if (frameOrAnimation != null) { this.gotoAndPlay(frameOrAnimation); }
	}
	var p = createjs.extend(Sprite, createjs.DisplayObject);

	/**
	 * Constructor alias for backwards compatibility. This method will be removed in future versions.
	 * Subclasses should be updated to use {{#crossLink "Utility Methods/extends"}}{{/crossLink}}.
	 * @method initialize
	 * @deprecated in favour of `createjs.promote()`
	 **/
	p.initialize = Sprite; // TODO: Deprecated. This is for backwards support of FlashCC spritesheet export.


// events:
	/**
	 * Dispatched when an animation reaches its ends.
	 * @event animationend
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {String} name The name of the animation that just ended.
	 * @param {String} next The name of the next animation that will be played, or null. This will be the same as name if the animation is looping.
	 * @since 0.6.0
	 */
	 
	/**
	 * Dispatched any time the current frame changes. For example, this could be due to automatic advancement on a tick,
	 * or calling gotoAndPlay() or gotoAndStop().
	 * @event change
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 */


// public methods:
	/**
	 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
	 **/
	p.isVisible = function() {
		var hasContent = this.cacheCanvas || this.spriteSheet.complete;
		return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
	};

	/**
	 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
	 * Returns true if the draw was handled (useful for overriding functionality).
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.
	 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
	 * into itself).
	 **/
	p.draw = function(ctx, ignoreCache) {
		if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
		this._normalizeFrame();
		var o = this.spriteSheet.getFrame(this._currentFrame|0);
		if (!o) { return false; }
		var rect = o.rect;
		if (rect.width && rect.height) { ctx.drawImage(o.image, rect.x, rect.y, rect.width, rect.height, -o.regX, -o.regY, rect.width, rect.height); }
		return true;
	};

	//Note, the doc sections below document using the specified APIs (from DisplayObject)  from
	//Bitmap. This is why they have no method implementations.

	/**
	 * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.
	 * You should not cache Sprite instances as it can degrade performance.
	 * @method cache
	 **/

	/**
	 * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.
	 * You should not cache Sprite instances as it can degrade performance.
	 * @method updateCache
	 **/

	/**
	 * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.
	 * You should not cache Sprite instances as it can degrade performance.
	 * @method uncache
	 **/

	/**
	 * Play (unpause) the current animation. The Sprite will be paused if either {{#crossLink "Sprite/stop"}}{{/crossLink}}
	 * or {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} is called. Single frame animations will remain
	 * unchanged.
	 * @method play
	 **/
	p.play = function() {
		this.paused = false;
	};

	/**
	 * Stop playing a running animation. The Sprite will be playing if {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}}
	 * is called. Note that calling {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}} or {{#crossLink "Sprite/play"}}{{/crossLink}}
	 * will resume playback.
	 * @method stop
	 **/
	p.stop = function() {
		this.paused = true;
	};

	/**
	 * Sets paused to false and plays the specified animation name, named frame, or frame number.
	 * @method gotoAndPlay
	 * @param {String|Number} frameOrAnimation The frame number or animation name that the playhead should move to
	 * and begin playing.
	 **/
	p.gotoAndPlay = function(frameOrAnimation) {
		this.paused = false;
		this._skipAdvance = true;
		this._goto(frameOrAnimation);
	};

	/**
	 * Sets paused to true and seeks to the specified animation name, named frame, or frame number.
	 * @method gotoAndStop
	 * @param {String|Number} frameOrAnimation The frame number or animation name that the playhead should move to
	 * and stop.
	 **/
	p.gotoAndStop = function(frameOrAnimation) {
		this.paused = true;
		this._goto(frameOrAnimation);
	};

	/**
	 * Advances the playhead. This occurs automatically each tick by default.
	 * @param [time] {Number} The amount of time in ms to advance by. Only applicable if framerate is set on the Sprite
	 * or its SpriteSheet.
	 * @method advance
	*/
	p.advance = function(time) {
		var fps = this.framerate || this.spriteSheet.framerate;
		var t = (fps && time != null) ? time/(1000/fps) : 1;
		this._normalizeFrame(t);
	};
	
	/**
	 * Returns a {{#crossLink "Rectangle"}}{{/crossLink}} instance defining the bounds of the current frame relative to
	 * the origin. For example, a 90 x 70 frame with <code>regX=50</code> and <code>regY=40</code> would return a
	 * rectangle with [x=-50, y=-40, width=90, height=70]. This ignores transformations on the display object.
	 *
	 * Also see the SpriteSheet {{#crossLink "SpriteSheet/getFrameBounds"}}{{/crossLink}} method.
	 * @method getBounds
	 * @return {Rectangle} A Rectangle instance. Returns null if the frame does not exist, or the image is not fully
	 * loaded.
	 **/
	p.getBounds = function() {
		// TODO: should this normalizeFrame?
		return this.DisplayObject_getBounds() || this.spriteSheet.getFrameBounds(this.currentFrame, this._rectangle);
	};

	/**
	 * Returns a clone of the Sprite instance. Note that the same SpriteSheet is shared between cloned
	 * instances.
	 * @method clone
	 * @return {Sprite} a clone of the Sprite instance.
	 **/
	p.clone = function() {
		return this._cloneProps(new Sprite(this.spriteSheet));
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Sprite (name="+  this.name +")]";
	};

// private methods:
	/**
	 * @method _cloneProps
	 * @param {Sprite} o
	 * @return {Sprite} o
	 * @protected
	 **/
	p._cloneProps = function(o) {
		this.DisplayObject__cloneProps(o);
		o.currentFrame = this.currentFrame;
		o.currentAnimation = this.currentAnimation;
		o.paused = this.paused;
		o.currentAnimationFrame = this.currentAnimationFrame;
		o.framerate = this.framerate;
		
		o._animation = this._animation;
		o._currentFrame = this._currentFrame;
		o._skipAdvance = this._skipAdvance;
		return o;
	};
	
	/**
	 * Advances the <code>currentFrame</code> if paused is not true. This is called automatically when the {{#crossLink "Stage"}}{{/crossLink}}
	 * ticks.
	 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
	 * @protected
	 * @method _tick
	 **/
	p._tick = function(evtObj) {
		if (!this.paused) {
			if (!this._skipAdvance) { this.advance(evtObj&&evtObj.delta); }
			this._skipAdvance = false;
		}
		this.DisplayObject__tick(evtObj);
	};


	/**
	 * Normalizes the current frame, advancing animations and dispatching callbacks as appropriate.
	 * @protected
	 * @method _normalizeFrame
	 **/
	p._normalizeFrame = function(frameDelta) {
		frameDelta = frameDelta || 0;
		var animation = this._animation;
		var paused = this.paused;
		var frame = this._currentFrame;
		var l;
		
		if (animation) {
			var speed = animation.speed || 1;
			var animFrame = this.currentAnimationFrame;
			l = animation.frames.length;
			if (animFrame + frameDelta * speed >= l) {
				var next = animation.next;
				if (this._dispatchAnimationEnd(animation, frame, paused, next, l - 1)) {
					// something changed in the event stack, so we shouldn't make any more changes here.
					return;
				} else if (next) {
					// sequence. Automatically calls _normalizeFrame again with the remaining frames.
					return this._goto(next, frameDelta - (l - animFrame) / speed);
				} else {
					// end.
					this.paused = true;
					animFrame = animation.frames.length - 1;
				}
			} else {
				animFrame += frameDelta * speed;
			}
			this.currentAnimationFrame = animFrame;
			this._currentFrame = animation.frames[animFrame | 0]
		} else {
			frame = (this._currentFrame += frameDelta);
			l = this.spriteSheet.getNumFrames();
			if (frame >= l && l > 0) {
				if (!this._dispatchAnimationEnd(animation, frame, paused, l - 1)) {
					// looped.
					if ((this._currentFrame -= l) >= l) { return this._normalizeFrame(); }
				}
			}
		}
		frame = this._currentFrame | 0;
		if (this.currentFrame != frame) {
			this.currentFrame = frame;
			this.dispatchEvent("change");
		}
	};

	/**
	 * Dispatches the "animationend" event. Returns true if a handler changed the animation (ex. calling {{#crossLink "Sprite/stop"}}{{/crossLink}},
	 * {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}}, etc.)
	 * @property _dispatchAnimationEnd
	 * @private
	 * @type {Function}
	 **/
	p._dispatchAnimationEnd = function(animation, frame, paused, next, end) {
		var name = animation ? animation.name : null;
		if (this.hasEventListener("animationend")) {
			var evt = new createjs.Event("animationend");
			evt.name = name;
			evt.next = next;
			this.dispatchEvent(evt);
		}
		// did the animation get changed in the event stack?:
		var changed = (this._animation != animation || this._currentFrame != frame);
		// if the animation hasn't changed, but the sprite was paused, then we want to stick to the last frame:
		if (!changed && !paused && this.paused) { this.currentAnimationFrame = end; changed = true; }
		return changed;
	};

	/**
	 * Moves the playhead to the specified frame number or animation.
	 * @method _goto
	 * @param {String|Number} frameOrAnimation The frame number or animation that the playhead should move to.
	 * @param {Boolean} [frame] The frame of the animation to go to. Defaults to 0.
	 * @protected
	 **/
	p._goto = function(frameOrAnimation, frame) {
		this.currentAnimationFrame = 0;
		if (isNaN(frameOrAnimation)) {
			var data = this.spriteSheet.getAnimation(frameOrAnimation);
			if (data) {
				this._animation = data;
				this.currentAnimation = frameOrAnimation;
				this._normalizeFrame(frame);
			}
		} else {
			this.currentAnimation = this._animation = null;
			this._currentFrame = frameOrAnimation;
			this._normalizeFrame();
		}
	};


	createjs.Sprite = createjs.promote(Sprite, "DisplayObject");
}());

//##############################################################################
// Shape.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * A Shape allows you to display vector art in the display list. It composites a {{#crossLink "Graphics"}}{{/crossLink}}
	 * instance which exposes all of the vector drawing methods. The Graphics instance can be shared between multiple Shape
	 * instances to display the same vector graphics with different positions or transforms.
	 *
	 * If the vector art will not
	 * change between draws, you may want to use the {{#crossLink "DisplayObject/cache"}}{{/crossLink}} method to reduce the
	 * rendering cost.
	 *
	 * <h4>Example</h4>
	 *
	 *      var graphics = new createjs.Graphics().beginFill("#ff0000").drawRect(0, 0, 100, 100);
	 *      var shape = new createjs.Shape(graphics);
	 *
	 *      //Alternatively use can also use the graphics property of the Shape class to renderer the same as above.
	 *      var shape = new createjs.Shape();
	 *      shape.graphics.beginFill("#ff0000").drawRect(0, 0, 100, 100);
	 *
	 * @class Shape
	 * @extends DisplayObject
	 * @constructor
	 * @param {Graphics} graphics Optional. The graphics instance to display. If null, a new Graphics instance will be created.
	 **/
	function Shape(graphics) {
		this.DisplayObject_constructor();
		
		
	// public properties:
		/**
		 * The graphics instance to display.
		 * @property graphics
		 * @type Graphics
		 **/
		this.graphics = graphics ? graphics : new createjs.Graphics();
	}
	var p = createjs.extend(Shape, createjs.DisplayObject);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// public methods:
	/**
	 * Returns true or false indicating whether the Shape would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Boolean indicating whether the Shape would be visible if drawn to a canvas
	 **/
	p.isVisible = function() {
		var hasContent = this.cacheCanvas || (this.graphics && !this.graphics.isEmpty());
		return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
	};

	/**
	 * Draws the Shape into the specified context ignoring its visible, alpha, shadow, and transform. Returns true if
	 * the draw was handled (useful for overriding functionality).
	 *
	 * <i>NOTE: This method is mainly for internal use, though it may be useful for advanced uses.</i>
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,
	 * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).
	 * @return {Boolean}
	 **/
	p.draw = function(ctx, ignoreCache) {
		if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
		this.graphics.draw(ctx, this);
		return true;
	};

	/**
	 * Returns a clone of this Shape. Some properties that are specific to this instance's current context are reverted to
	 * their defaults (for example .parent).
	 * @method clone
	 * @param {Boolean} recursive If true, this Shape's {{#crossLink "Graphics"}}{{/crossLink}} instance will also be
	 * cloned. If false, the Graphics instance will be shared with the new Shape.
	 **/
	p.clone = function(recursive) {
		var g = (recursive && this.graphics) ? this.graphics.clone() : this.graphics;
		return  this._cloneProps(new Shape(g));
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Shape (name="+  this.name +")]";
	};


	createjs.Shape = createjs.promote(Shape, "DisplayObject");
}());

//##############################################################################
// Text.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Display one or more lines of dynamic text (not user editable) in the display list. Line wrapping support (using the
	 * lineWidth) is very basic, wrapping on spaces and tabs only. Note that as an alternative to Text, you can position HTML
	 * text above or below the canvas relative to items in the display list using the {{#crossLink "DisplayObject/localToGlobal"}}{{/crossLink}}
	 * method, or using {{#crossLink "DOMElement"}}{{/crossLink}}.
	 *
	 * <b>Please note that Text does not support HTML text, and can only display one font style at a time.</b> To use
	 * multiple font styles, you will need to create multiple text instances, and position them manually.
	 *
	 * <h4>Example</h4>
	 *
	 *      var text = new createjs.Text("Hello World", "20px Arial", "#ff7700");
	 *      text.x = 100;
	 *      text.textBaseline = "alphabetic";
	 *
	 * CreateJS Text supports web fonts (the same rules as Canvas). The font must be loaded and supported by the browser
	 * before it can be displayed.
	 *
	 * <strong>Note:</strong> Text can be expensive to generate, so cache instances where possible. Be aware that not all
	 * browsers will render Text exactly the same.
	 * @class Text
	 * @extends DisplayObject
	 * @constructor
	 * @param {String} [text] The text to display.
	 * @param {String} [font] The font style to use. Any valid value for the CSS font attribute is acceptable (ex. "bold
	 * 36px Arial").
	 * @param {String} [color] The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex.
	 * "#F00", "red", or "#FF0000").
	 **/
	function Text(text, font, color) {
		this.DisplayObject_constructor();
		
		
	// public properties:
		/**
		 * The text to display.
		 * @property text
		 * @type String
		 **/
		this.text = text;
	
		/**
		 * The font style to use. Any valid value for the CSS font attribute is acceptable (ex. "bold 36px Arial").
		 * @property font
		 * @type String
		 **/
		this.font = font;
	
		/**
		 * The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex. "#F00"). Default is "#000".
		 * It will also accept valid canvas fillStyle values.
		 * @property color
		 * @type String
		 **/
		this.color = color;
	
		/**
		 * The horizontal text alignment. Any of "start", "end", "left", "right", and "center". For detailed
		 * information view the
		 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles">
		 * whatwg spec</a>. Default is "left".
		 * @property textAlign
		 * @type String
		 **/
		this.textAlign = "left";
	
		/**
		 * The vertical alignment point on the font. Any of "top", "hanging", "middle", "alphabetic", "ideographic", or
		 * "bottom". For detailed information view the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles">
		 * whatwg spec</a>. Default is "top".
		 * @property textBaseline
		 * @type String
		*/
		this.textBaseline = "top";
	
		/**
		 * The maximum width to draw the text. If maxWidth is specified (not null), the text will be condensed or
		 * shrunk to make it fit in this width. For detailed information view the
		 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles">
		 * whatwg spec</a>.
		 * @property maxWidth
		 * @type Number
		*/
		this.maxWidth = null;
	
		/**
		 * If greater than 0, the text will be drawn as a stroke (outline) of the specified width.
		 * @property outline
		 * @type Number
		 **/
		this.outline = 0;
	
		/**
		 * Indicates the line height (vertical distance between baselines) for multi-line text. If null or 0,
		 * the value of getMeasuredLineHeight is used.
		 * @property lineHeight
		 * @type Number
		 **/
		this.lineHeight = 0;
	
		/**
		 * Indicates the maximum width for a line of text before it is wrapped to multiple lines. If null,
		 * the text will not be wrapped.
		 * @property lineWidth
		 * @type Number
		 **/
		this.lineWidth = null;
	}
	var p = createjs.extend(Text, createjs.DisplayObject);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.

	
// static properties:
	/**
	 * @property _workingContext
	 * @type CanvasRenderingContext2D
	 * @private
	 **/
	var canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"));
	if (canvas.getContext) { Text._workingContext = canvas.getContext("2d"); canvas.width = canvas.height = 1; }
	
	
// constants:
	/**
	 * Lookup table for the ratio to offset bounds x calculations based on the textAlign property.
	 * @property H_OFFSETS
	 * @type Object
	 * @protected
	 * @static
	 **/
	Text.H_OFFSETS = {start: 0, left: 0, center: -0.5, end: -1, right: -1};
	
	/**
	 * Lookup table for the ratio to offset bounds y calculations based on the textBaseline property.
	 * @property H_OFFSETS
	 * @type Object
	 * @protected
	 * @static
	 **/
	Text.V_OFFSETS = {top: 0, hanging: -0.01, middle: -0.4, alphabetic: -0.8, ideographic: -0.85, bottom: -1};


// public methods:
	/**
	 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Whether the display object would be visible if drawn to a canvas
	 **/
	p.isVisible = function() {
		var hasContent = this.cacheCanvas || (this.text != null && this.text !== "");
		return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
	};

	/**
	 * Draws the Text into the specified context ignoring its visible, alpha, shadow, and transform.
	 * Returns true if the draw was handled (useful for overriding functionality).
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.
	 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
	 * into itself).
	 **/
	p.draw = function(ctx, ignoreCache) {
		if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }

		var col = this.color || "#000";
		if (this.outline) { ctx.strokeStyle = col; ctx.lineWidth = this.outline*1; }
		else { ctx.fillStyle = col; }
		
		this._drawText(this._prepContext(ctx));
		return true;
	};

	/**
	 * Returns the measured, untransformed width of the text without wrapping. Use getBounds for a more robust value.
	 * @method getMeasuredWidth
	 * @return {Number} The measured, untransformed width of the text.
	 **/
	p.getMeasuredWidth = function() {
		return this._getMeasuredWidth(this.text);
	};

	/**
	 * Returns an approximate line height of the text, ignoring the lineHeight property. This is based on the measured
	 * width of a "M" character multiplied by 1.2, which provides an approximate line height for most fonts.
	 * @method getMeasuredLineHeight
	 * @return {Number} an approximate line height of the text, ignoring the lineHeight property. This is
	 * based on the measured width of a "M" character multiplied by 1.2, which approximates em for most fonts.
	 **/
	p.getMeasuredLineHeight = function() {
		return this._getMeasuredWidth("M")*1.2;
	};

	/**
	 * Returns the approximate height of multi-line text by multiplying the number of lines against either the
	 * <code>lineHeight</code> (if specified) or {{#crossLink "Text/getMeasuredLineHeight"}}{{/crossLink}}. Note that
	 * this operation requires the text flowing logic to run, which has an associated CPU cost.
	 * @method getMeasuredHeight
	 * @return {Number} The approximate height of the untransformed multi-line text.
	 **/
	p.getMeasuredHeight = function() {
		return this._drawText(null,{}).height;
	};

	/**
	 * Docced in superclass.
	 */
	p.getBounds = function() {
		var rect = this.DisplayObject_getBounds();
		if (rect) { return rect; }
		if (this.text == null || this.text === "") { return null; }
		var o = this._drawText(null, {});
		var w = (this.maxWidth && this.maxWidth < o.width) ? this.maxWidth : o.width;
		var x = w * Text.H_OFFSETS[this.textAlign||"left"];
		var lineHeight = this.lineHeight||this.getMeasuredLineHeight();
		var y = lineHeight * Text.V_OFFSETS[this.textBaseline||"top"];
		return this._rectangle.setValues(x, y, w, o.height);
	};
	
	/**
	 * Returns an object with width, height, and lines properties. The width and height are the visual width and height
	 * of the drawn text. The lines property contains an array of strings, one for
	 * each line of text that will be drawn, accounting for line breaks and wrapping. These strings have trailing
	 * whitespace removed.
	 * @method getMetrics
	 * @return {Object} An object with width, height, and lines properties.
	 **/
	p.getMetrics = function() {
		var o = {lines:[]};
		o.lineHeight = this.lineHeight || this.getMeasuredLineHeight();
		o.vOffset = o.lineHeight * Text.V_OFFSETS[this.textBaseline||"top"];
		return this._drawText(null, o, o.lines);
	};

	/**
	 * Returns a clone of the Text instance.
	 * @method clone
	 * @return {Text} a clone of the Text instance.
	 **/
	p.clone = function() {
		return this._cloneProps(new Text(this.text, this.font, this.color));
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Text (text="+  (this.text.length > 20 ? this.text.substr(0, 17)+"..." : this.text) +")]";
	};


// private methods:
	/**
	 * @method _cloneProps
	 * @param {Text} o
	 * @protected
	 * @return {Text} o
	 **/
	p._cloneProps = function(o) {
		this.DisplayObject__cloneProps(o);
		o.textAlign = this.textAlign;
		o.textBaseline = this.textBaseline;
		o.maxWidth = this.maxWidth;
		o.outline = this.outline;
		o.lineHeight = this.lineHeight;
		o.lineWidth = this.lineWidth;
		return o;
	};

	/**
	 * @method _getWorkingContext
	 * @param {CanvasRenderingContext2D} ctx
	 * @return {CanvasRenderingContext2D}
	 * @protected
	 **/
	p._prepContext = function(ctx) {
		ctx.font = this.font||"10px sans-serif";
		ctx.textAlign = this.textAlign||"left";
		ctx.textBaseline = this.textBaseline||"top";
		return ctx;
	};

	/**
	 * Draws multiline text.
	 * @method _drawText
	 * @param {CanvasRenderingContext2D} ctx
	 * @param {Object} o
	 * @param {Array} lines
	 * @return {Object}
	 * @protected
	 **/
	p._drawText = function(ctx, o, lines) {
		var paint = !!ctx;
		if (!paint) {
			ctx = Text._workingContext;
			ctx.save();
			this._prepContext(ctx);
		}
		var lineHeight = this.lineHeight||this.getMeasuredLineHeight();
		
		var maxW = 0, count = 0;
		var hardLines = String(this.text).split(/(?:\r\n|\r|\n)/);
		for (var i=0, l=hardLines.length; i<l; i++) {
			var str = hardLines[i];
			var w = null;
			
			if (this.lineWidth != null && (w = ctx.measureText(str).width) > this.lineWidth) {
				// text wrapping:
				var words = str.split(/(\s)/);
				str = words[0];
				w = ctx.measureText(str).width;
				
				for (var j=1, jl=words.length; j<jl; j+=2) {
					// Line needs to wrap:
					var wordW = ctx.measureText(words[j] + words[j+1]).width;
					if (w + wordW > this.lineWidth) {
						if (paint) { this._drawTextLine(ctx, str, count*lineHeight); }
						if (lines) { lines.push(str); }
						if (w > maxW) { maxW = w; }
						str = words[j+1];
						w = ctx.measureText(str).width;
						count++;
					} else {
						str += words[j] + words[j+1];
						w += wordW;
					}
				}
			}
			
			if (paint) { this._drawTextLine(ctx, str, count*lineHeight); }
			if (lines) { lines.push(str); }
			if (o && w == null) { w = ctx.measureText(str).width; }
			if (w > maxW) { maxW = w; }
			count++;
		}
		
		if (o) {
			o.width = maxW;
			o.height = count*lineHeight;
		}
		if (!paint) { ctx.restore(); }
		return o;
	};

	/**
	 * @method _drawTextLine
	 * @param {CanvasRenderingContext2D} ctx
	 * @param {String} text
	 * @param {Number} y
	 * @protected
	 **/
	p._drawTextLine = function(ctx, text, y) {
		// Chrome 17 will fail to draw the text if the last param is included but null, so we feed it a large value instead:
		if (this.outline) { ctx.strokeText(text, 0, y, this.maxWidth||0xFFFF); }
		else { ctx.fillText(text, 0, y, this.maxWidth||0xFFFF); }
	};
	
	
	/**
	 * @method _getMeasuredWidth
	 * @param {String} text
	 * @protected
	 **/
	p._getMeasuredWidth = function(text) {
		var ctx = Text._workingContext;
		ctx.save();
		var w = this._prepContext(ctx).measureText(text).width;
		ctx.restore();
		return w;
	};


	createjs.Text = createjs.promote(Text, "DisplayObject");
}());

//##############################################################################
// BitmapText.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";


// constructor:
	/**
	 * Displays text using bitmap glyphs defined in a sprite sheet. Multi-line text is supported
	 * using new line characters, but automatic wrapping is not supported. See the 
	 * {{#crossLink "BitmapText/spriteSheet:property"}}{{/crossLink}}
	 * property for more information on defining glyphs.
	 * 
	 * <strong>Important:</strong> BitmapText extends Container, but is not designed to be used as one.
	 * As such, methods like addChild and removeChild are disabled.
	 * @class BitmapText
	 * @extends DisplayObject
	 * @param {String} [text=""] The text to display.
	 * @param {SpriteSheet} [spriteSheet=null] The spritesheet that defines the character glyphs.
	 * @constructor
	 **/
	function BitmapText(text, spriteSheet) {
		this.Container_constructor();
		
		
	// public properties:
		/**
		 * The text to display.
		 * @property text
		 * @type String
		 * @default ""
		 **/
		this.text = text||"";
		
		/**
		 * A SpriteSheet instance that defines the glyphs for this bitmap text. Each glyph/character
		 * should have a single frame animation defined in the sprite sheet named the same as
		 * corresponding character. For example, the following animation definition:
		 *
		 * 		"A": {frames: [0]}
		 *
		 * would indicate that the frame at index 0 of the spritesheet should be drawn for the "A" character. The short form
		 * is also acceptable:
		 * 
		 * 		"A": 0
		 *
		 * Note that if a character in the text is not found in the sprite sheet, it will also
		 * try to use the alternate case (upper or lower).
		 *
		 * See SpriteSheet for more information on defining sprite sheet data.
		 * @property spriteSheet
		 * @type SpriteSheet
		 * @default null
		 **/
		this.spriteSheet = spriteSheet;
	
		/**
		 * The height of each line of text. If 0, then it will use a line height calculated
		 * by checking for the height of the "1", "T", or "L" character (in that order). If
		 * those characters are not defined, it will use the height of the first frame of the
		 * sprite sheet.
		 * @property lineHeight
		 * @type Number
		 * @default 0
		 **/
		this.lineHeight = 0;
	
		/**
		 * This spacing (in pixels) will be added after each character in the output.
		 * @property letterSpacing
		 * @type Number
		 * @default 0
		 **/
		this.letterSpacing = 0;
	
		/**
		 * If a space character is not defined in the sprite sheet, then empty pixels equal to
		 * spaceWidth will be inserted instead. If 0, then it will use a value calculated
		 * by checking for the width of the "1", "l", "E", or "A" character (in that order). If
		 * those characters are not defined, it will use the width of the first frame of the
		 * sprite sheet.
		 * @property spaceWidth
		 * @type Number
		 * @default 0
		 **/
		this.spaceWidth = 0;
		
		
	// private properties:
	 	/**
		 * @property _oldProps
		 * @type Object
		 * @protected
		 **/
		this._oldProps = {text:0,spriteSheet:0,lineHeight:0,letterSpacing:0,spaceWidth:0};
	}
	var p = createjs.extend(BitmapText, createjs.Container);

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.

// static properties:
	/**
	 * BitmapText uses Sprite instances to draw text. To reduce the creation and destruction of instances (and thus garbage collection), it maintains
	 * an internal object pool of sprite instances to reuse. Increasing this value can cause more sprites to be
	 * retained, slightly increasing memory use, but reducing instantiation.
	 * @property maxPoolSize
	 * @type Number
	 * @static
	 * @default 100
	 **/
	BitmapText.maxPoolSize = 100;
	
	/**
	 * Sprite object pool.
	 * @type {Array}
	 * @static
	 * @private
	 */
	BitmapText._spritePool = [];

	
// public methods:
	/**
	 * Docced in superclass.
	 **/
	p.draw = function(ctx, ignoreCache) {
		if (this.DisplayObject_draw(ctx, ignoreCache)) { return; }
		this._updateText();
		this.Container_draw(ctx, ignoreCache);
	};
	
	/**
	 * Docced in superclass.
	 **/
	p.getBounds = function() {
		this._updateText();
		return this.Container_getBounds();
	};
	
	/**
	 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
	 **/
	p.isVisible = function() {
		var hasContent = this.cacheCanvas || (this.spriteSheet && this.spriteSheet.complete && this.text);
		return !!(this.visible && this.alpha > 0 && this.scaleX !== 0 && this.scaleY !== 0 && hasContent);
	};
	
	p.clone = function() {
		return this._cloneProps(new BitmapText(this.text, this.spriteSheet));
	};
	
	/**
	 * <strong>Disabled in BitmapText.</strong>
	 * @method addChild
	 **/
	/**
	 * <strong>Disabled in BitmapText.</strong>
	 * @method addChildAt
	 **/
	/**
	 * <strong>Disabled in BitmapText.</strong>
	 * @method removeChild
	 **/
	/**
	 * <strong>Disabled in BitmapText.</strong>
	 * @method removeChildAt
	 **/
	/**
	 * <strong>Disabled in BitmapText.</strong>
	 * @method removeAllChildren
	 **/
	p.addChild = p.addChildAt = p.removeChild = p.removeChildAt = p.removeAllChildren = function() {};


// private methods:
 	/**
	 * @method _cloneProps
	 * @param {BitmapText} o
	 * @return {BitmapText} o
	 * @protected
	 **/
	p._cloneProps = function(o) {
		this.Container__cloneProps(o);
		o.lineHeight = this.lineHeight;
		o.letterSpacing = this.letterSpacing;
		o.spaceWidth = this.spaceWidth;
		return o;
	};
	
	/**
	 * @method _getFrameIndex
	 * @param {String} character
	 * @param {SpriteSheet} spriteSheet
	 * @return {Number}
	 * @protected
	 **/
	p._getFrameIndex = function(character, spriteSheet) {
		var c, o = spriteSheet.getAnimation(character);
		if (!o) {
			(character != (c = character.toUpperCase())) || (character != (c = character.toLowerCase())) || (c=null);
			if (c) { o = spriteSheet.getAnimation(c); }
		}
		return o && o.frames[0];
	};
	
	/**
	 * @method _getFrame
	 * @param {String} character
	 * @param {SpriteSheet} spriteSheet
	 * @return {Object}
	 * @protected
	 **/
	p._getFrame = function(character, spriteSheet) {
		var index = this._getFrameIndex(character, spriteSheet);
		return index == null ? index : spriteSheet.getFrame(index);
	};
	
	/**
	 * @method _getLineHeight
	 * @param {SpriteSheet} ss
	 * @return {Number}
	 * @protected
	 **/
	p._getLineHeight = function(ss) {
		var frame = this._getFrame("1",ss) || this._getFrame("T",ss) || this._getFrame("L",ss) || ss.getFrame(0);
		return frame ? frame.rect.height : 1;
	};
	/**
	 * @method _getSpaceWidth
	 * @param {SpriteSheet} ss
	 * @return {Number}
	 * @protected
	 **/
	p._getSpaceWidth = function(ss) {
		var frame = this._getFrame("1",ss) || this._getFrame("l",ss) || this._getFrame("e",ss) || this._getFrame("a",ss) || ss.getFrame(0);
		return frame ? frame.rect.width : 1;
	};
	
	/**
	 * @method _drawText
	 * @protected
	 **/
	p._updateText = function() {
		var x=0, y=0, o=this._oldProps, change=false, spaceW=this.spaceWidth, lineH=this.lineHeight, ss=this.spriteSheet;
		var pool=BitmapText._spritePool, kids=this.children, childIndex=0, numKids=kids.length, sprite;
		
		for (var n in o) {
			if (o[n] != this[n]) {
				o[n] = this[n];
				change = true;
			}
		}
		if (!change) { return; }
		
		var hasSpace = !!this._getFrame(" ", ss);
		if (!hasSpace && !spaceW) { spaceW = this._getSpaceWidth(ss); }
		if (!lineH) { lineH = this._getLineHeight(ss); }
		
		for(var i=0, l=this.text.length; i<l; i++) {
			var character = this.text.charAt(i);
			if (character == " " && !hasSpace) {
				x += spaceW;
				continue;
			} else if (character=="\n" || character=="\r") {
				if (character=="\r" && this.text.charAt(i+1) == "\n") { i++; } // crlf
				x = 0;
				y += lineH;
				continue;
			}

			var index = this._getFrameIndex(character, ss);
			if (index == null) { continue; }
			
			if (childIndex < numKids) {
				sprite = kids[childIndex];
			} else {
				kids.push(sprite = pool.length ? pool.pop() : new createjs.Sprite());
				sprite.parent = this;
				numKids++;
			}
			sprite.spriteSheet = ss;
			sprite.gotoAndStop(index);
			sprite.x = x;
			sprite.y = y;
			childIndex++;
			
			x += sprite.getBounds().width + this.letterSpacing;
		}
		while (numKids > childIndex) {
			 // faster than removeChild.
			pool.push(sprite = kids.pop());
			sprite.parent = null;
			numKids--;
		}
		if (pool.length > BitmapText.maxPoolSize) { pool.length = BitmapText.maxPoolSize; }
	};


	createjs.BitmapText = createjs.promote(BitmapText, "Container");
}());

//##############################################################################
// SpriteSheetUtils.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";
	
	
// constructor:
	/**
	 * The SpriteSheetUtils class is a collection of static methods for working with {{#crossLink "SpriteSheet"}}{{/crossLink}}s.
	 * A sprite sheet is a series of images (usually animation frames) combined into a single image on a regular grid. For
	 * example, an animation consisting of 8 100x100 images could be combined into a 400x200 sprite sheet (4 frames across
	 * by 2 high). The SpriteSheetUtils class uses a static interface and should not be instantiated.
	 * @class SpriteSheetUtils
	 * @static
	 **/
	function SpriteSheetUtils() {
		throw "SpriteSheetUtils cannot be instantiated";
	}


// private static properties:
	/**
	 * @property _workingCanvas
	 * @static
	 * @type HTMLCanvasElement | Object
	 * @protected
	*/
	/**
	 * @property _workingContext
	 * @static
	 * @type CanvasRenderingContext2D
	 * @protected
	*/
	var canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"));
	if (canvas.getContext) {
		SpriteSheetUtils._workingCanvas = canvas;
		SpriteSheetUtils._workingContext = canvas.getContext("2d");
		canvas.width = canvas.height = 1;
	}


// public static methods:
	/**
	 * <b>This is an experimental method, and may be buggy. Please report issues.</b><br/><br/>
	 * Extends the existing sprite sheet by flipping the original frames horizontally, vertically, or both,
	 * and adding appropriate animation & frame data. The flipped animations will have a suffix added to their names
	 * (_h, _v, _hv as appropriate). Make sure the sprite sheet images are fully loaded before using this method.
	 * <br/><br/>
	 * For example:<br/>
	 * SpriteSheetUtils.addFlippedFrames(mySpriteSheet, true, true);
	 * The above would add frames that are flipped horizontally AND frames that are flipped vertically.
	 * <br/><br/>
	 * Note that you can also flip any display object by setting its scaleX or scaleY to a negative value. On some
	 * browsers (especially those without hardware accelerated canvas) this can result in slightly degraded performance,
	 * which is why addFlippedFrames is available.
	 * @method addFlippedFrames
	 * @static
	 * @param {SpriteSheet} spriteSheet
	 * @param {Boolean} horizontal If true, horizontally flipped frames will be added.
	 * @param {Boolean} vertical If true, vertically flipped frames will be added.
	 * @param {Boolean} both If true, frames that are flipped both horizontally and vertically will be added.
	 * @deprecated Modern browsers perform better when flipping via a transform (ex. scaleX=-1) rendering this obsolete.
	 **/
	SpriteSheetUtils.addFlippedFrames = function(spriteSheet, horizontal, vertical, both) {
		if (!horizontal && !vertical && !both) { return; }

		var count = 0;
		if (horizontal) { SpriteSheetUtils._flip(spriteSheet,++count,true,false); }
		if (vertical) { SpriteSheetUtils._flip(spriteSheet,++count,false,true); }
		if (both) { SpriteSheetUtils._flip(spriteSheet,++count,true,true); }
	};

	/**
	 * Returns a single frame of the specified sprite sheet as a new PNG image. An example of when this may be useful is
	 * to use a spritesheet frame as the source for a bitmap fill.
	 *
	 * <strong>WARNING:</strong> In almost all cases it is better to display a single frame using a {{#crossLink "Sprite"}}{{/crossLink}}
	 * with a {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} call than it is to slice out a frame using this
	 * method and display it with a Bitmap instance. You can also crop an image using the {{#crossLink "Bitmap/sourceRect"}}{{/crossLink}}
	 * property of {{#crossLink "Bitmap"}}{{/crossLink}}.
	 *
	 * The extractFrame method may cause cross-domain warnings since it accesses pixels directly on the canvas.
	 * @method extractFrame
	 * @static
	 * @param {SpriteSheet} spriteSheet The SpriteSheet instance to extract a frame from.
	 * @param {Number|String} frameOrAnimation The frame number or animation name to extract. If an animation
	 * name is specified, only the first frame of the animation will be extracted.
	 * @return {HTMLImageElement} a single frame of the specified sprite sheet as a new PNG image.
	*/
	SpriteSheetUtils.extractFrame = function(spriteSheet, frameOrAnimation) {
		if (isNaN(frameOrAnimation)) {
			frameOrAnimation = spriteSheet.getAnimation(frameOrAnimation).frames[0];
		}
		var data = spriteSheet.getFrame(frameOrAnimation);
		if (!data) { return null; }
		var r = data.rect;
		var canvas = SpriteSheetUtils._workingCanvas;
		canvas.width = r.width;
		canvas.height = r.height;
		SpriteSheetUtils._workingContext.drawImage(data.image, r.x, r.y, r.width, r.height, 0, 0, r.width, r.height);
		var img = document.createElement("img");
		img.src = canvas.toDataURL("image/png");
		return img;
	};

	/**
	 * Merges the rgb channels of one image with the alpha channel of another. This can be used to combine a compressed
	 * JPEG image containing color data with a PNG32 monochromatic image containing alpha data. With certain types of
	 * images (those with detail that lend itself to JPEG compression) this can provide significant file size savings
	 * versus a single RGBA PNG32. This method is very fast (generally on the order of 1-2 ms to run).
	 * @method mergeAlpha
	 * @static
	 * @param {HTMLImageElement} rbgImage The image (or canvas) containing the RGB channels to use.
	 * @param {HTMLImageElement} alphaImage The image (or canvas) containing the alpha channel to use.
	 * @param {HTMLCanvasElement} canvas Optional. If specified, this canvas will be used and returned. If not, a new canvas will be created.
	 * @return {HTMLCanvasElement} A canvas with the combined image data. This can be used as a source for Bitmap or SpriteSheet.
	 * @deprecated Tools such as ImageAlpha generally provide better results. This will be moved to sandbox in the future.
	*/
	SpriteSheetUtils.mergeAlpha = function(rgbImage, alphaImage, canvas) {
		if (!canvas) { canvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"); }
		canvas.width = Math.max(alphaImage.width, rgbImage.width);
		canvas.height = Math.max(alphaImage.height, rgbImage.height);
		var ctx = canvas.getContext("2d");
		ctx.save();
		ctx.drawImage(rgbImage,0,0);
		ctx.globalCompositeOperation = "destination-in";
		ctx.drawImage(alphaImage,0,0);
		ctx.restore();
		return canvas;
	};


// private static methods:
	SpriteSheetUtils._flip = function(spriteSheet, count, h, v) {
		var imgs = spriteSheet._images;
		var canvas = SpriteSheetUtils._workingCanvas;
		var ctx = SpriteSheetUtils._workingContext;
		var il = imgs.length/count;
		for (var i=0;i<il;i++) {
			var src = imgs[i];
			src.__tmp = i; // a bit hacky, but faster than doing indexOf below.
			ctx.setTransform(1,0,0,1,0,0);
			ctx.clearRect(0,0,canvas.width+1,canvas.height+1);
			canvas.width = src.width;
			canvas.height = src.height;
			ctx.setTransform(h?-1:1, 0, 0, v?-1:1, h?src.width:0, v?src.height:0);
			ctx.drawImage(src,0,0);
			var img = document.createElement("img");
			img.src = canvas.toDataURL("image/png");
			// work around a strange bug in Safari:
			img.width = src.width;
			img.height = src.height;
			imgs.push(img);
		}

		var frames = spriteSheet._frames;
		var fl = frames.length/count;
		for (i=0;i<fl;i++) {
			src = frames[i];
			var rect = src.rect.clone();
			img = imgs[src.image.__tmp+il*count];

			var frame = {image:img,rect:rect,regX:src.regX,regY:src.regY};
			if (h) {
				rect.x = img.width-rect.x-rect.width; // update rect
				frame.regX = rect.width-src.regX; // update registration point
			}
			if (v) {
				rect.y = img.height-rect.y-rect.height;  // update rect
				frame.regY = rect.height-src.regY; // update registration point
			}
			frames.push(frame);
		}

		var sfx = "_"+(h?"h":"")+(v?"v":"");
		var names = spriteSheet._animations;
		var data = spriteSheet._data;
		var al = names.length/count;
		for (i=0;i<al;i++) {
			var name = names[i];
			src = data[name];
			var anim = {name:name+sfx,speed:src.speed,next:src.next,frames:[]};
			if (src.next) { anim.next += sfx; }
			frames = src.frames;
			for (var j=0,l=frames.length;j<l;j++) {
				anim.frames.push(frames[j]+fl*count);
			}
			data[anim.name] = anim;
			names.push(anim.name);
		}
	};


	createjs.SpriteSheetUtils = SpriteSheetUtils;
}());

//##############################################################################
// SpriteSheetBuilder.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * The SpriteSheetBuilder allows you to generate sprite sheets at run time from any display object. This can allow
	 * you to maintain your assets as vector graphics (for low file size), and render them at run time as sprite sheets
	 * for better performance.
	 *
	 * Sprite sheets can be built either synchronously, or asynchronously, so that large sprite sheets can be generated
	 * without locking the UI.
	 *
	 * Note that the "images" used in the generated sprite sheet are actually canvas elements, and that they will be sized
	 * to the nearest power of 2 up to the value of <code>maxWidth</code> or <code>maxHeight</code>.
	 * @class SpriteSheetBuilder
	 * @extends EventDispatcher
	 * @constructor
	 **/
	function SpriteSheetBuilder() {
		this.EventDispatcher_constructor();
		
	// public properties:
		/**
		 * The maximum width for the images (not individual frames) in the generated sprite sheet. It is recommended to use
		 * a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max dimensions, then
		 * additional images will be created as needed.
		 * @property maxWidth
		 * @type Number
		 * @default 2048
		*/
		this.maxWidth = 2048;
	
		/**
		 * The maximum height for the images (not individual frames) in the generated sprite sheet. It is recommended to use
		 * a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max dimensions, then
		 * additional images will be created as needed.
		 * @property maxHeight
		 * @type Number
		 * @default 2048
		 **/
		this.maxHeight = 2048;
	
		/**
		 * The sprite sheet that was generated. This will be null before a build is completed successfully.
		 * @property spriteSheet
		 * @type SpriteSheet
		 **/
		this.spriteSheet = null;
	
		/**
		 * The scale to apply when drawing all frames to the sprite sheet. This is multiplied against any scale specified
		 * in the addFrame call. This can be used, for example, to generate a sprite sheet at run time that is tailored to
		 * the a specific device resolution (ex. tablet vs mobile).
		 * @property scale
		 * @type Number
		 * @default 1
		 **/
		this.scale = 1;
	
		/**
		* The padding to use between frames. This is helpful to preserve antialiasing on drawn vector content.
		* @property padding
		* @type Number
		* @default 1
		**/
		this.padding = 1;
	
		/**
		 * A number from 0.01 to 0.99 that indicates what percentage of time the builder can use. This can be
		 * thought of as the number of seconds per second the builder will use. For example, with a timeSlice value of 0.3,
		 * the builder will run 20 times per second, using approximately 15ms per build (30% of available time, or 0.3s per second).
		 * Defaults to 0.3.
		 * @property timeSlice
		 * @type Number
		 * @default 0.3
		 **/
		this.timeSlice = 0.3;
	
		/**
		 * A value between 0 and 1 that indicates the progress of a build, or -1 if a build has not
		 * been initiated.
		 * @property progress
		 * @type Number
		 * @default -1
		 * @readonly
		 **/
		this.progress = -1;
	
	
	// private properties:
		/**
		 * @property _frames
		 * @protected
		 * @type Array
		 **/
		this._frames = [];
	
		/**
		 * @property _animations
		 * @protected
		 * @type Array
		 **/
		this._animations = {};
	
		/**
		 * @property _data
		 * @protected
		 * @type Array
		 **/
		this._data = null;
	
		/**
		 * @property _nextFrameIndex
		 * @protected
		 * @type Number
		 **/
		this._nextFrameIndex = 0;
	
		/**
		 * @property _index
		 * @protected
		 * @type Number
		 **/
		this._index = 0;
	
		/**
		 * @property _timerID
		 * @protected
		 * @type Number
		 **/
		this._timerID = null;
	
		/**
		 * @property _scale
		 * @protected
		 * @type Number
		 **/
		this._scale = 1;
	}
	var p = createjs.extend(SpriteSheetBuilder, createjs.EventDispatcher);

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// constants:
	SpriteSheetBuilder.ERR_DIMENSIONS = "frame dimensions exceed max spritesheet dimensions";
	SpriteSheetBuilder.ERR_RUNNING = "a build is already running";

// events:
	/**
	 * Dispatched when a build completes.
	 * @event complete
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @since 0.6.0
	 */

	/**
	 * Dispatched when an asynchronous build has progress.
	 * @event progress
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Number} progress The current progress value (0-1).
	 * @since 0.6.0
	 */


// public methods:
	/**
	 * Adds a frame to the {{#crossLink "SpriteSheet"}}{{/crossLink}}. Note that the frame will not be drawn until you
	 * call {{#crossLink "SpriteSheetBuilder/build"}}{{/crossLink}} method. The optional setup params allow you to have
	 * a function run immediately before the draw occurs. For example, this allows you to add a single source multiple
	 * times, but manipulate it or its children to change it to generate different frames.
	 *
	 * Note that the source's transformations (x, y, scale, rotate, alpha) will be ignored, except for regX/Y. To apply
	 * transforms to a source object and have them captured in the sprite sheet, simply place it into a {{#crossLink "Container"}}{{/crossLink}}
	 * and pass in the Container as the source.
	 * @method addFrame
	 * @param {DisplayObject} source The source {{#crossLink "DisplayObject"}}{{/crossLink}}  to draw as the frame.
	 * @param {Rectangle} [sourceRect] A {{#crossLink "Rectangle"}}{{/crossLink}} defining the portion of the
	 * source to draw to the frame. If not specified, it will look for a <code>getBounds</code> method, bounds property,
	 * or <code>nominalBounds</code> property on the source to use. If one is not found, the frame will be skipped.
	 * @param {Number} [scale=1] Optional. The scale to draw this frame at. Default is 1.
	 * @param {Function} [setupFunction] A function to call immediately before drawing this frame. It will be called with two parameters: the source, and setupData.
	 * @param {Object} [setupData] Arbitrary setup data to pass to setupFunction as the second parameter.
	 * @return {Number} The index of the frame that was just added, or null if a sourceRect could not be determined.
	 **/
	p.addFrame = function(source, sourceRect, scale, setupFunction, setupData) {
		if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
		var rect = sourceRect||source.bounds||source.nominalBounds;
		if (!rect&&source.getBounds) { rect = source.getBounds(); }
		if (!rect) { return null; }
		scale = scale||1;
		return this._frames.push({source:source, sourceRect:rect, scale:scale, funct:setupFunction, data:setupData, index:this._frames.length, height:rect.height*scale})-1;
	};

	/**
	 * Adds an animation that will be included in the created sprite sheet.
	 * @method addAnimation
	 * @param {String} name The name for the animation.
	 * @param {Array} frames An array of frame indexes that comprise the animation. Ex. [3,6,5] would describe an animation
	 * that played frame indexes 3, 6, and 5 in that order.
	 * @param {String} [next] Specifies the name of the animation to continue to after this animation ends. You can
	 * also pass false to have the animation stop when it ends. By default it will loop to the start of the same animation.
	 * @param {Number} [frequency] Specifies a frame advance frequency for this animation. For example, a value
	 * of 2 would cause the animation to advance every second tick.
	 **/
	p.addAnimation = function(name, frames, next, frequency) {
		if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
		this._animations[name] = {frames:frames, next:next, frequency:frequency};
	};

	/**
	 * This will take a MovieClip instance, and add its frames and labels to this builder. Labels will be added as an animation
	 * running from the label index to the next label. For example, if there is a label named "foo" at frame 0 and a label
	 * named "bar" at frame 10, in a MovieClip with 15 frames, it will add an animation named "foo" that runs from frame
	 * index 0 to 9, and an animation named "bar" that runs from frame index 10 to 14.
	 *
	 * Note that this will iterate through the full MovieClip with actionsEnabled set to false, ending on the last frame.
	 * @method addMovieClip
	 * @param {MovieClip} source The source MovieClip instance to add to the sprite sheet.
	 * @param {Rectangle} [sourceRect] A {{#crossLink "Rectangle"}}{{/crossLink}} defining the portion of the source to
	 * draw to the frame. If not specified, it will look for a <code>getBounds</code> method, <code>frameBounds</code>
	 * Array, <code>bounds</code> property, or <code>nominalBounds</code> property on the source to use. If one is not
	 * found, the MovieClip will be skipped.
	 * @param {Number} [scale=1] The scale to draw the movie clip at.
	 * @param {Function} [setupFunction] A function to call immediately before drawing each frame. It will be called with three parameters: the source, setupData, and the frame index.
	 * @param {Object} [setupData] Arbitrary setup data to pass to setupFunction as the second parameter.
	 * @param {Function} [labelFunction] This method will be called for each movieclip label that is added with four parameters: the label name, the source movieclip instance, the starting frame index (in the movieclip timeline) and the end index. It must return a new name for the label/animation, or false to exclude the label.
	 **/
	p.addMovieClip = function(source, sourceRect, scale, setupFunction, setupData, labelFunction) {
		if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
		var rects = source.frameBounds;
		var rect = sourceRect||source.bounds||source.nominalBounds;
		if (!rect&&source.getBounds) { rect = source.getBounds(); }
		if (!rect && !rects) { return; }

		var i, l, baseFrameIndex = this._frames.length;
		var duration = source.timeline.duration;
		for (i=0; i<duration; i++) {
			var r = (rects&&rects[i]) ? rects[i] : rect;
			this.addFrame(source, r, scale, this._setupMovieClipFrame, {i:i, f:setupFunction, d:setupData});
		}
		var labels = source.timeline._labels;
		var lbls = [];
		for (var n in labels) {
			lbls.push({index:labels[n], label:n});
		}
		if (lbls.length) {
			lbls.sort(function(a,b){ return a.index-b.index; });
			for (i=0,l=lbls.length; i<l; i++) {
				var label = lbls[i].label;
				var start = baseFrameIndex+lbls[i].index;
				var end = baseFrameIndex+((i == l-1) ? duration : lbls[i+1].index);
				var frames = [];
				for (var j=start; j<end; j++) { frames.push(j); }
				if (labelFunction) {
					label = labelFunction(label, source, start, end);
					if (!label) { continue; }
				}
				this.addAnimation(label, frames, true); // for now, this loops all animations.
			}
		}
	};

	/**
	 * Builds a SpriteSheet instance based on the current frames.
	 * @method build
	 * @return {SpriteSheet} The created SpriteSheet instance, or null if a build is already running or an error occurred.
	 **/
	p.build = function() {
		if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
		this._startBuild();
		while (this._drawNext()) {}
		this._endBuild();
		return this.spriteSheet;
	};

	/**
	 * Asynchronously builds a {{#crossLink "SpriteSheet"}}{{/crossLink}} instance based on the current frames. It will
	 * run 20 times per second, using an amount of time defined by <code>timeSlice</code>. When it is complete it will
	 * call the specified callback.
	 * @method buildAsync
	 * @param {Number} [timeSlice] Sets the timeSlice property on this instance.
	 **/
	p.buildAsync = function(timeSlice) {
		if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
		this.timeSlice = timeSlice;
		this._startBuild();
		var _this = this;
		this._timerID = setTimeout(function() { _this._run(); }, 50-Math.max(0.01, Math.min(0.99, this.timeSlice||0.3))*50);
	};

	/**
	 * Stops the current asynchronous build.
	 * @method stopAsync
	 **/
	p.stopAsync = function() {
		clearTimeout(this._timerID);
		this._data = null;
	};

	/**
	 * SpriteSheetBuilder instances cannot be cloned.
	 * @method clone
	 **/
	p.clone = function() {
		throw("SpriteSheetBuilder cannot be cloned.");
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[SpriteSheetBuilder]";
	};


// private methods:
	/**
	 * @method _startBuild
	 * @protected
	 **/
	p._startBuild = function() {
		var pad = this.padding||0;
		this.progress = 0;
		this.spriteSheet = null;
		this._index = 0;
		this._scale = this.scale;
		var dataFrames = [];
		this._data = {
			images: [],
			frames: dataFrames,
			animations: this._animations // TODO: should we "clone" _animations in case someone adds more animations after a build?
		};

		var frames = this._frames.slice();
		frames.sort(function(a,b) { return (a.height<=b.height) ? -1 : 1; });

		if (frames[frames.length-1].height+pad*2 > this.maxHeight) { throw SpriteSheetBuilder.ERR_DIMENSIONS; }
		var y=0, x=0;
		var img = 0;
		while (frames.length) {
			var o = this._fillRow(frames, y, img, dataFrames, pad);
			if (o.w > x) { x = o.w; }
			y += o.h;
			if (!o.h || !frames.length) {
				var canvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");
				canvas.width = this._getSize(x,this.maxWidth);
				canvas.height = this._getSize(y,this.maxHeight);
				this._data.images[img] = canvas;
				if (!o.h) {
					x=y=0;
					img++;
				}
			}
		}
	};
	
	/**
	 * @method _setupMovieClipFrame
	 * @protected
	 * @return {Number} The width & height of the row.
	 **/
	p._setupMovieClipFrame = function(source, data) {
		var ae = source.actionsEnabled;
		source.actionsEnabled = false;
		source.gotoAndStop(data.i);
		source.actionsEnabled = ae;
		data.f&&data.f(source, data.d, data.i);
	};

	/**
	 * @method _getSize
	 * @protected
	 * @return {Number} The width & height of the row.
	 **/
	p._getSize = function(size,max) {
		var pow = 4;
		while (Math.pow(2,++pow) < size){}
		return Math.min(max,Math.pow(2,pow));
	};

	/**
	 * @method _fillRow
	 * @param {Array} frames
	 * @param {Number} y
	 * @param {HTMLImageElement} img
	 * @param {Object} dataFrames
	 * @param {Number} pad
	 * @protected
	 * @return {Number} The width & height of the row.
	 **/
	p._fillRow = function(frames, y, img, dataFrames, pad) {
		var w = this.maxWidth;
		var maxH = this.maxHeight;
		y += pad;
		var h = maxH-y;
		var x = pad;
		var height = 0;
		for (var i=frames.length-1; i>=0; i--) {
			var frame = frames[i];
			var sc = this._scale*frame.scale;
			var rect = frame.sourceRect;
			var source = frame.source;
			var rx = Math.floor(sc*rect.x-pad);
			var ry = Math.floor(sc*rect.y-pad);
			var rh = Math.ceil(sc*rect.height+pad*2);
			var rw = Math.ceil(sc*rect.width+pad*2);
			if (rw > w) { throw SpriteSheetBuilder.ERR_DIMENSIONS; }
			if (rh > h || x+rw > w) { continue; }
			frame.img = img;
			frame.rect = new createjs.Rectangle(x,y,rw,rh);
			height = height || rh;
			frames.splice(i,1);
			dataFrames[frame.index] = [x,y,rw,rh,img,Math.round(-rx+sc*source.regX-pad),Math.round(-ry+sc*source.regY-pad)];
			x += rw;
		}
		return {w:x, h:height};
	};

	/**
	 * @method _endBuild
	 * @protected
	 **/
	p._endBuild = function() {
		this.spriteSheet = new createjs.SpriteSheet(this._data);
		this._data = null;
		this.progress = 1;
		this.dispatchEvent("complete");
	};

	/**
	 * @method _run
	 * @protected
	 **/
	p._run = function() {
		var ts = Math.max(0.01, Math.min(0.99, this.timeSlice||0.3))*50;
		var t = (new Date()).getTime()+ts;
		var complete = false;
		while (t > (new Date()).getTime()) {
			if (!this._drawNext()) { complete = true; break; }
		}
		if (complete) {
			this._endBuild();
		} else {
			var _this = this;
			this._timerID = setTimeout(function() { _this._run(); }, 50-ts);
		}
		var p = this.progress = this._index/this._frames.length;
		if (this.hasEventListener("progress")) {
			var evt = new createjs.Event("progress");
			evt.progress = p;
			this.dispatchEvent(evt);
		}
	};

	/**
	 * @method _drawNext
	 * @protected
	 * @return Boolean Returns false if this is the last draw.
	 **/
	p._drawNext = function() {
		var frame = this._frames[this._index];
		var sc = frame.scale*this._scale;
		var rect = frame.rect;
		var sourceRect = frame.sourceRect;
		var canvas = this._data.images[frame.img];
		var ctx = canvas.getContext("2d");
		frame.funct&&frame.funct(frame.source, frame.data);
		ctx.save();
		ctx.beginPath();
		ctx.rect(rect.x, rect.y, rect.width, rect.height);
		ctx.clip();
		ctx.translate(Math.ceil(rect.x-sourceRect.x*sc), Math.ceil(rect.y-sourceRect.y*sc));
		ctx.scale(sc,sc);
		frame.source.draw(ctx); // display object will draw itself.
		ctx.restore();
		return (++this._index) < this._frames.length;
	};


	createjs.SpriteSheetBuilder = createjs.promote(SpriteSheetBuilder, "EventDispatcher");
}());

//##############################################################################
// DOMElement.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * <b>This class is still experimental, and more advanced use is likely to be buggy. Please report bugs.</b>
	 *
	 * A DOMElement allows you to associate a HTMLElement with the display list. It will be transformed
	 * within the DOM as though it is child of the {{#crossLink "Container"}}{{/crossLink}} it is added to. However, it is
	 * not rendered to canvas, and as such will retain whatever z-index it has relative to the canvas (ie. it will be
	 * drawn in front of or behind the canvas).
	 *
	 * The position of a DOMElement is relative to their parent node in the DOM. It is recommended that
	 * the DOM Object be added to a div that also contains the canvas so that they share the same position
	 * on the page.
	 *
	 * DOMElement is useful for positioning HTML elements over top of canvas content, and for elements
	 * that you want to display outside the bounds of the canvas. For example, a tooltip with rich HTML
	 * content.
	 *
	 * <h4>Mouse Interaction</h4>
	 *
	 * DOMElement instances are not full EaselJS display objects, and do not participate in EaselJS mouse
	 * events or support methods like hitTest. To get mouse events from a DOMElement, you must instead add handlers to
	 * the htmlElement (note, this does not support EventDispatcher)
	 *
	 *      var domElement = new createjs.DOMElement(htmlElement);
	 *      domElement.htmlElement.onclick = function() {
	 *          console.log("clicked");
	 *      }
	 *
	 * @class DOMElement
	 * @extends DisplayObject
	 * @constructor
	 * @param {HTMLElement} htmlElement A reference or id for the DOM element to manage.
	 */
	function DOMElement(htmlElement) {
		this.DisplayObject_constructor();
		
		if (typeof(htmlElement)=="string") { htmlElement = document.getElementById(htmlElement); }
		this.mouseEnabled = false;
		
		var style = htmlElement.style;
		style.position = "absolute";
		style.transformOrigin = style.WebkitTransformOrigin = style.msTransformOrigin = style.MozTransformOrigin = style.OTransformOrigin = "0% 0%";
		
		
	// public properties:
		/**
		 * The DOM object to manage.
		 * @property htmlElement
		 * @type HTMLElement
		 */
		this.htmlElement = htmlElement;
	
	
	// private properties:
		/**
		 * @property _oldMtx
		 * @type Matrix2D
		 * @protected
		 */
		this._oldProps = null;
	}
	var p = createjs.extend(DOMElement, createjs.DisplayObject);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// public methods:
	/**
	 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
	 */
	p.isVisible = function() {
		return this.htmlElement != null;
	};

	/**
	 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
	 * Returns true if the draw was handled (useful for overriding functionality).
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.
	 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
	 * into itself).
	 * @return {Boolean}
	 */
	p.draw = function(ctx, ignoreCache) {
		// this relies on the _tick method because draw isn't called if the parent is not visible.
		// the actual update happens in _handleDrawEnd
		return true;
	};

	/**
	 * Not applicable to DOMElement.
	 * @method cache
	 */
	p.cache = function() {};

	/**
	 * Not applicable to DOMElement.
	 * @method uncache
	 */
	p.uncache = function() {};

	/**
	 * Not applicable to DOMElement.
	 * @method updateCache
	 */
	p.updateCache = function() {};

	/**
	 * Not applicable to DOMElement.
	 * @method hitTest
	 */
	p.hitTest = function() {};

	/**
	 * Not applicable to DOMElement.
	 * @method localToGlobal
	 */
	p.localToGlobal = function() {};

	/**
	 * Not applicable to DOMElement.
	 * @method globalToLocal
	 */
	p.globalToLocal = function() {};

	/**
	 * Not applicable to DOMElement.
	 * @method localToLocal
	 */
	p.localToLocal = function() {};

	/**
	 * DOMElement cannot be cloned. Throws an error.
	 * @method clone
	 */
	p.clone = function() {
		throw("DOMElement cannot be cloned.")
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 */
	p.toString = function() {
		return "[DOMElement (name="+  this.name +")]";
	};

	/**
     * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances
	 * are not full EaselJS display objects and do not participate in EaselJS mouse events.
	 * @event click
	 */

     /**
     * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances
 	 * are not full EaselJS display objects and do not participate in EaselJS mouse events.
	 * @event dblClick
	 */

     /**
      * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances
 	  * are not full EaselJS display objects and do not participate in EaselJS mouse events.
	  * @event mousedown
	  */

     /**
      * The HTMLElement can listen for the mouseover event, not the DOMElement instance.
      * Since DOMElement instances are not full EaselJS display objects and do not participate in EaselJS mouse events.
      * @event mouseover
	  */

     /**
      * Not applicable to DOMElement.
	  * @event tick
	  */


// private methods:
	/**
	 * @method _tick
	 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
	 * function.
	 * @protected
	 */
	p._tick = function(evtObj) {
		var stage = this.getStage();
		stage&&stage.on("drawend", this._handleDrawEnd, this, true);
		this.DisplayObject__tick(evtObj);
	};
	
	/**
	 * @method _handleDrawEnd
	 * @param {Event} evt
	 * @protected
	 */
	p._handleDrawEnd = function(evt) {
		var o = this.htmlElement;
		if (!o) { return; }
		var style = o.style;
		
		var props = this.getConcatenatedDisplayProps(this._props), mtx = props.matrix;
		
		var visibility = props.visible ? "visible" : "hidden";
		if (visibility != style.visibility) { style.visibility = visibility; }
		if (!props.visible) { return; }
		
		var oldProps = this._oldProps, oldMtx = oldProps&&oldProps.matrix;
		var n = 10000; // precision
		
		if (!oldMtx || !oldMtx.equals(mtx)) {
			var str = "matrix(" + (mtx.a*n|0)/n +","+ (mtx.b*n|0)/n +","+ (mtx.c*n|0)/n +","+ (mtx.d*n|0)/n +","+ (mtx.tx+0.5|0);
			style.transform = style.WebkitTransform = style.OTransform = style.msTransform = str +","+ (mtx.ty+0.5|0) +")";
			style.MozTransform = str +"px,"+ (mtx.ty+0.5|0) +"px)";
			if (!oldProps) { oldProps = this._oldProps = new createjs.DisplayProps(true, NaN); }
			oldProps.matrix.copy(mtx);
		}
		
		if (oldProps.alpha != props.alpha) {
			style.opacity = ""+(props.alpha*n|0)/n;
			oldProps.alpha = props.alpha;
		}
	};


	createjs.DOMElement = createjs.promote(DOMElement, "DisplayObject");
}());

//##############################################################################
// Filter.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Base class that all filters should inherit from. Filters need to be applied to objects that have been cached using
	 * the {{#crossLink "DisplayObject/cache"}}{{/crossLink}} method. If an object changes, please cache it again, or use
	 * {{#crossLink "DisplayObject/updateCache"}}{{/crossLink}}. Note that the filters must be applied before caching.
	 *
	 * <h4>Example</h4>
	 *
	 *      myInstance.filters = [
	 *          new createjs.ColorFilter(0, 0, 0, 1, 255, 0, 0),
	 *          new createjs.BlurFilter(5, 5, 10)
	 *      ];
	 *      myInstance.cache(0,0, 100, 100);
	 *
	 * Note that each filter can implement a {{#crossLink "Filter/getBounds"}}{{/crossLink}} method, which returns the
	 * margins that need to be applied in order to fully display the filter. For example, the {{#crossLink "BlurFilter"}}{{/crossLink}}
	 * will cause an object to feather outwards, resulting in a margin around the shape.
	 *
	 * <h4>EaselJS Filters</h4>
	 * EaselJS comes with a number of pre-built filters. Note that individual filters are not compiled into the minified
	 * version of EaselJS. To use them, you must include them manually in the HTML.
	 * <ul><li>{{#crossLink "AlphaMapFilter"}}{{/crossLink}} : Map a greyscale image to the alpha channel of a display object</li>
	 *      <li>{{#crossLink "AlphaMaskFilter"}}{{/crossLink}}: Map an image's alpha channel to the alpha channel of a display object</li>
	 *      <li>{{#crossLink "BlurFilter"}}{{/crossLink}}: Apply vertical and horizontal blur to a display object</li>
	 *      <li>{{#crossLink "ColorFilter"}}{{/crossLink}}: Color transform a display object</li>
	 *      <li>{{#crossLink "ColorMatrixFilter"}}{{/crossLink}}: Transform an image using a {{#crossLink "ColorMatrix"}}{{/crossLink}}</li>
	 * </ul>
	 *
	 * @class Filter
	 * @constructor
	 **/
	function Filter() {}
	var p = Filter.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// public methods:
	/**
	 * Provides padding values for this filter. That is, how much the filter will extend the visual bounds of an object it is applied to.
	 * @method getBounds
	 * @param {Rectangle} [rect] If specified, the provided Rectangle instance will be expanded by the padding amounts and returned.
	 * @return {Rectangle} If a `rect` param was provided, it is returned. If not, either a new rectangle with the padding values, or null if no padding is required for this filter.
	 **/
	p.getBounds = function(rect) {
		return rect;
	};

	/**
	 * Applies the filter to the specified context.
	 * @method applyFilter
	 * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.
	 * @param {Number} x The x position to use for the source rect.
	 * @param {Number} y The y position to use for the source rect.
	 * @param {Number} width The width to use for the source rect.
	 * @param {Number} height The height to use for the source rect.
	 * @param {CanvasRenderingContext2D} [targetCtx] The 2D context to draw the result to. Defaults to the context passed to ctx.
	 * @param {Number} [targetX] The x position to draw the result to. Defaults to the value passed to x.
	 * @param {Number} [targetY] The y position to draw the result to. Defaults to the value passed to y.
	 * @return {Boolean} If the filter was applied successfully.
	 **/
	p.applyFilter = function(ctx, x, y, width, height, targetCtx, targetX, targetY) {
		// this is the default behaviour because most filters access pixel data. It is overridden when not needed.
		targetCtx = targetCtx || ctx;
		if (targetX == null) { targetX = x; }
		if (targetY == null) { targetY = y; }
		try {
			var imageData = ctx.getImageData(x, y, width, height);
		} catch (e) {
			return false;
		}
		if (this._applyFilter(imageData)) {
			targetCtx.putImageData(imageData, targetX, targetY);
			return true;
		}
		return false;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Filter]";
	};

	/**
	 * Returns a clone of this Filter instance.
	 * @method clone
	 * @return {Filter} A clone of the current Filter instance.
	 **/
	p.clone = function() {
		return new Filter();
	};
	
// private methods:
	/**
	 * @method _applyFilter
	 * @param {ImageData} imageData Target ImageData instance.
	 * @return {Boolean}
	 **/
	p._applyFilter = function(imageData) { return true; };


	createjs.Filter = Filter;
}());

//##############################################################################
// BlurFilter.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Applies a box blur to DisplayObjects. Note that this filter is fairly CPU intensive, particularly if the quality is
	 * set higher than 1.
	 *
	 * <h4>Example</h4>
	 * This example creates a red circle, and then applies a 5 pixel blur to it. It uses the {{#crossLink "Filter/getBounds"}}{{/crossLink}}
	 * method to account for the spread that the blur causes.
	 *
	 *      var shape = new createjs.Shape().set({x:100,y:100});
	 *      shape.graphics.beginFill("#ff0000").drawCircle(0,0,50);
	 *
	 *      var blurFilter = new createjs.BlurFilter(5, 5, 1);
	 *      shape.filters = [blurFilter];
	 *      var bounds = blurFilter.getBounds();
	 *
	 *      shape.cache(-50+bounds.x, -50+bounds.y, 100+bounds.width, 100+bounds.height);
	 *
	 * See {{#crossLink "Filter"}}{{/crossLink}} for an more information on applying filters.
	 * @class BlurFilter
	 * @extends Filter
	 * @constructor
	 * @param {Number} [blurX=0] The horizontal blur radius in pixels.
	 * @param {Number} [blurY=0] The vertical blur radius in pixels.
	 * @param {Number} [quality=1] The number of blur iterations.
	 **/
	function BlurFilter( blurX, blurY, quality) {
		if ( isNaN(blurX) || blurX < 0 ) blurX = 0;
		if ( isNaN(blurY) || blurY < 0 ) blurY = 0;
		if ( isNaN(quality) || quality < 1  ) quality = 1;


		// public properties:
		/**
		 * Horizontal blur radius in pixels
		 * @property blurX
		 * @default 0
		 * @type Number
		 **/
		this.blurX = blurX | 0;

		/**
		 * Vertical blur radius in pixels
		 * @property blurY
		 * @default 0
		 * @type Number
		 **/
		this.blurY = blurY | 0;

		/**
		 * Number of blur iterations. For example, a value of 1 will produce a rough blur. A value of 2 will produce a
		 * smoother blur, but take twice as long to run.
		 * @property quality
		 * @default 1
		 * @type Number
		 **/
		this.quality = quality | 0;
	}
	var p = createjs.extend(BlurFilter, createjs.Filter);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// constants:
	/**
	 * Array of multiply values for blur calculations.
	 * @property MUL_TABLE
	 * @type Array
	 * @protected
	 * @static
	 **/
	BlurFilter.MUL_TABLE = [1, 171, 205, 293, 57, 373, 79, 137, 241, 27, 391, 357, 41, 19, 283, 265, 497, 469, 443, 421, 25, 191, 365, 349, 335, 161, 155, 149, 9, 278, 269, 261, 505, 245, 475, 231, 449, 437, 213, 415, 405, 395, 193, 377, 369, 361, 353, 345, 169, 331, 325, 319, 313, 307, 301, 37, 145, 285, 281, 69, 271, 267, 263, 259, 509, 501, 493, 243, 479, 118, 465, 459, 113, 446, 55, 435, 429, 423, 209, 413, 51, 403, 199, 393, 97, 3, 379, 375, 371, 367, 363, 359, 355, 351, 347, 43, 85, 337, 333, 165, 327, 323, 5, 317, 157, 311, 77, 305, 303, 75, 297, 294, 73, 289, 287, 71, 141, 279, 277, 275, 68, 135, 67, 133, 33, 262, 260, 129, 511, 507, 503, 499, 495, 491, 61, 121, 481, 477, 237, 235, 467, 232, 115, 457, 227, 451, 7, 445, 221, 439, 218, 433, 215, 427, 425, 211, 419, 417, 207, 411, 409, 203, 202, 401, 399, 396, 197, 49, 389, 387, 385, 383, 95, 189, 47, 187, 93, 185, 23, 183, 91, 181, 45, 179, 89, 177, 11, 175, 87, 173, 345, 343, 341, 339, 337, 21, 167, 83, 331, 329, 327, 163, 81, 323, 321, 319, 159, 79, 315, 313, 39, 155, 309, 307, 153, 305, 303, 151, 75, 299, 149, 37, 295, 147, 73, 291, 145, 289, 287, 143, 285, 71, 141, 281, 35, 279, 139, 69, 275, 137, 273, 17, 271, 135, 269, 267, 133, 265, 33, 263, 131, 261, 130, 259, 129, 257, 1];

	/**
	 * Array of shift values for blur calculations.
	 * @property SHG_TABLE
	 * @type Array
	 * @protected
	 * @static
	 **/
	BlurFilter.SHG_TABLE = [0, 9, 10, 11, 9, 12, 10, 11, 12, 9, 13, 13, 10, 9, 13, 13, 14, 14, 14, 14, 10, 13, 14, 14, 14, 13, 13, 13, 9, 14, 14, 14, 15, 14, 15, 14, 15, 15, 14, 15, 15, 15, 14, 15, 15, 15, 15, 15, 14, 15, 15, 15, 15, 15, 15, 12, 14, 15, 15, 13, 15, 15, 15, 15, 16, 16, 16, 15, 16, 14, 16, 16, 14, 16, 13, 16, 16, 16, 15, 16, 13, 16, 15, 16, 14, 9, 16, 16, 16, 16, 16, 16, 16, 16, 16, 13, 14, 16, 16, 15, 16, 16, 10, 16, 15, 16, 14, 16, 16, 14, 16, 16, 14, 16, 16, 14, 15, 16, 16, 16, 14, 15, 14, 15, 13, 16, 16, 15, 17, 17, 17, 17, 17, 17, 14, 15, 17, 17, 16, 16, 17, 16, 15, 17, 16, 17, 11, 17, 16, 17, 16, 17, 16, 17, 17, 16, 17, 17, 16, 17, 17, 16, 16, 17, 17, 17, 16, 14, 17, 17, 17, 17, 15, 16, 14, 16, 15, 16, 13, 16, 15, 16, 14, 16, 15, 16, 12, 16, 15, 16, 17, 17, 17, 17, 17, 13, 16, 15, 17, 17, 17, 16, 15, 17, 17, 17, 16, 15, 17, 17, 14, 16, 17, 17, 16, 17, 17, 16, 15, 17, 16, 14, 17, 16, 15, 17, 16, 17, 17, 16, 17, 15, 16, 17, 14, 17, 16, 15, 17, 16, 17, 13, 17, 16, 17, 17, 16, 17, 14, 17, 16, 17, 16, 17, 16, 17, 9];

// public methods:
	/** docced in super class **/
	p.getBounds = function (rect) {
		var x = this.blurX|0, y = this.blurY| 0;
		if (x <= 0 && y <= 0) { return rect; }
		var q = Math.pow(this.quality, 0.2);
		return (rect || new createjs.Rectangle()).pad(x*q+1,y*q+1,x*q+1,y*q+1);
	};

	/** docced in super class **/
	p.clone = function() {
		return new BlurFilter(this.blurX, this.blurY, this.quality);
	};

	/** docced in super class **/
	p.toString = function() {
		return "[BlurFilter]";
	};


// private methods:

	/** docced in super class **/
	p._applyFilter = function (imageData) {

		var radiusX = this.blurX >> 1;
		if (isNaN(radiusX) || radiusX < 0) return false;
		var radiusY = this.blurY >> 1;
		if (isNaN(radiusY) || radiusY < 0) return false;
		if (radiusX == 0 && radiusY == 0) return false;

		var iterations = this.quality;
		if (isNaN(iterations) || iterations < 1) iterations = 1;
		iterations |= 0;
		if (iterations > 3) iterations = 3;
		if (iterations < 1) iterations = 1;

		var px = imageData.data;
		var x=0, y=0, i=0, p=0, yp=0, yi=0, yw=0, r=0, g=0, b=0, a=0, pr=0, pg=0, pb=0, pa=0;

		var divx = (radiusX + radiusX + 1) | 0;
		var divy = (radiusY + radiusY + 1) | 0;
		var w = imageData.width | 0;
		var h = imageData.height | 0;

		var w1 = (w - 1) | 0;
		var h1 = (h - 1) | 0;
		var rxp1 = (radiusX + 1) | 0;
		var ryp1 = (radiusY + 1) | 0;

		var ssx = {r:0,b:0,g:0,a:0};
		var sx = ssx;
		for ( i = 1; i < divx; i++ )
		{
			sx = sx.n = {r:0,b:0,g:0,a:0};
		}
		sx.n = ssx;

		var ssy = {r:0,b:0,g:0,a:0};
		var sy = ssy;
		for ( i = 1; i < divy; i++ )
		{
			sy = sy.n = {r:0,b:0,g:0,a:0};
		}
		sy.n = ssy;

		var si = null;


		var mtx = BlurFilter.MUL_TABLE[radiusX] | 0;
		var stx = BlurFilter.SHG_TABLE[radiusX] | 0;
		var mty = BlurFilter.MUL_TABLE[radiusY] | 0;
		var sty = BlurFilter.SHG_TABLE[radiusY] | 0;

		while (iterations-- > 0) {

			yw = yi = 0;
			var ms = mtx;
			var ss = stx;
			for (y = h; --y > -1;) {
				r = rxp1 * (pr = px[(yi) | 0]);
				g = rxp1 * (pg = px[(yi + 1) | 0]);
				b = rxp1 * (pb = px[(yi + 2) | 0]);
				a = rxp1 * (pa = px[(yi + 3) | 0]);

				sx = ssx;

				for( i = rxp1; --i > -1; )
				{
					sx.r = pr;
					sx.g = pg;
					sx.b = pb;
					sx.a = pa;
					sx = sx.n;
				}

				for( i = 1; i < rxp1; i++ )
				{
					p = (yi + ((w1 < i ? w1 : i) << 2)) | 0;
					r += ( sx.r = px[p]);
					g += ( sx.g = px[p+1]);
					b += ( sx.b = px[p+2]);
					a += ( sx.a = px[p+3]);

					sx = sx.n;
				}

				si = ssx;
				for ( x = 0; x < w; x++ )
				{
					px[yi++] = (r * ms) >>> ss;
					px[yi++] = (g * ms) >>> ss;
					px[yi++] = (b * ms) >>> ss;
					px[yi++] = (a * ms) >>> ss;

					p = ((yw + ((p = x + radiusX + 1) < w1 ? p : w1)) << 2);

					r -= si.r - ( si.r = px[p]);
					g -= si.g - ( si.g = px[p+1]);
					b -= si.b - ( si.b = px[p+2]);
					a -= si.a - ( si.a = px[p+3]);

					si = si.n;

				}
				yw += w;
			}

			ms = mty;
			ss = sty;
			for (x = 0; x < w; x++) {
				yi = (x << 2) | 0;

				r = (ryp1 * (pr = px[yi])) | 0;
				g = (ryp1 * (pg = px[(yi + 1) | 0])) | 0;
				b = (ryp1 * (pb = px[(yi + 2) | 0])) | 0;
				a = (ryp1 * (pa = px[(yi + 3) | 0])) | 0;

				sy = ssy;
				for( i = 0; i < ryp1; i++ )
				{
					sy.r = pr;
					sy.g = pg;
					sy.b = pb;
					sy.a = pa;
					sy = sy.n;
				}

				yp = w;

				for( i = 1; i <= radiusY; i++ )
				{
					yi = ( yp + x ) << 2;

					r += ( sy.r = px[yi]);
					g += ( sy.g = px[yi+1]);
					b += ( sy.b = px[yi+2]);
					a += ( sy.a = px[yi+3]);

					sy = sy.n;

					if( i < h1 )
					{
						yp += w;
					}
				}

				yi = x;
				si = ssy;
				if ( iterations > 0 )
				{
					for ( y = 0; y < h; y++ )
					{
						p = yi << 2;
						px[p+3] = pa =(a * ms) >>> ss;
						if ( pa > 0 )
						{
							px[p]   = ((r * ms) >>> ss );
							px[p+1] = ((g * ms) >>> ss );
							px[p+2] = ((b * ms) >>> ss );
						} else {
							px[p] = px[p+1] = px[p+2] = 0
						}

						p = ( x + (( ( p = y + ryp1) < h1 ? p : h1 ) * w )) << 2;

						r -= si.r - ( si.r = px[p]);
						g -= si.g - ( si.g = px[p+1]);
						b -= si.b - ( si.b = px[p+2]);
						a -= si.a - ( si.a = px[p+3]);

						si = si.n;

						yi += w;
					}
				} else {
					for ( y = 0; y < h; y++ )
					{
						p = yi << 2;
						px[p+3] = pa =(a * ms) >>> ss;
						if ( pa > 0 )
						{
							pa = 255 / pa;
							px[p]   = ((r * ms) >>> ss ) * pa;
							px[p+1] = ((g * ms) >>> ss ) * pa;
							px[p+2] = ((b * ms) >>> ss ) * pa;
						} else {
							px[p] = px[p+1] = px[p+2] = 0
						}

						p = ( x + (( ( p = y + ryp1) < h1 ? p : h1 ) * w )) << 2;

						r -= si.r - ( si.r = px[p]);
						g -= si.g - ( si.g = px[p+1]);
						b -= si.b - ( si.b = px[p+2]);
						a -= si.a - ( si.a = px[p+3]);

						si = si.n;

						yi += w;
					}
				}
			}

		}
		return true;
	};

	createjs.BlurFilter = createjs.promote(BlurFilter, "Filter");
}());

//##############################################################################
// AlphaMapFilter.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";
	
	
// constructor:
	/**
	 * Applies a greyscale alpha map image (or canvas) to the target, such that the alpha channel of the result will
	 * be copied from the red channel of the map, and the RGB channels will be copied from the target.
	 *
	 * Generally, it is recommended that you use {{#crossLink "AlphaMaskFilter"}}{{/crossLink}}, because it has much
	 * better performance.
	 *
	 * <h4>Example</h4>
	 * This example draws a red->blue box, caches it, and then uses the cache canvas as an alpha map on a 100x100 image.
	 *
	 *       var box = new createjs.Shape();
	 *       box.graphics.beginLinearGradientFill(["#ff0000", "#0000ff"], [0, 1], 0, 0, 0, 100)
	 *       box.graphics.drawRect(0, 0, 100, 100);
	 *       box.cache(0, 0, 100, 100);
	 *
	 *       var bmp = new createjs.Bitmap("path/to/image.jpg");
	 *       bmp.filters = [
	 *           new createjs.AlphaMapFilter(box.cacheCanvas)
	 *       ];
	 *       bmp.cache(0, 0, 100, 100);
	 *       stage.addChild(bmp);
	 *
	 * See {{#crossLink "Filter"}}{{/crossLink}} for more information on applying filters.
	 * @class AlphaMapFilter
	 * @extends Filter
	 * @constructor
	 * @param {HTMLImageElement|HTMLCanvasElement} alphaMap The greyscale image (or canvas) to use as the alpha value for the
	 * result. This should be exactly the same dimensions as the target.
	 **/
	function AlphaMapFilter(alphaMap) {
	
	
	// public properties:
		/**
		 * The greyscale image (or canvas) to use as the alpha value for the result. This should be exactly the same
		 * dimensions as the target.
		 * @property alphaMap
		 * @type HTMLImageElement|HTMLCanvasElement
		 **/
		this.alphaMap = alphaMap;
		
		
	// private properties:
		/**
		 * @property _alphaMap
		 * @protected
		 * @type HTMLImageElement|HTMLCanvasElement
		 **/
		this._alphaMap = null;
		
		/**
		 * @property _mapData
		 * @protected
		 * @type Uint8ClampedArray
		 **/
		this._mapData = null;
	}
	var p = createjs.extend(AlphaMapFilter, createjs.Filter);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// public methods:
	/** docced in super class **/
	p.clone = function () {
		var o = new AlphaMapFilter(this.alphaMap);
		o._alphaMap = this._alphaMap;
		o._mapData = this._mapData;
		return o;
	};

	/** docced in super class **/
	p.toString = function () {
		return "[AlphaMapFilter]";
	};


// private methods:
	/** docced in super class **/
	p._applyFilter = function (imageData) {
		if (!this.alphaMap) { return true; }
		if (!this._prepAlphaMap()) { return false; }
		
		// TODO: update to support scenarios where the target has different dimensions.
		var data = imageData.data;
		var map = this._mapData;
		for(var i=0, l=data.length; i<l; i += 4) { data[i + 3] = map[i] || 0; }
		
		return true;
	};

	/**
	 * @method _prepAlphaMap
	 * @protected
	 **/
	p._prepAlphaMap = function () {
		if (!this.alphaMap) { return false; }
		if (this.alphaMap == this._alphaMap && this._mapData) { return true; }

		this._mapData = null;
		var map = this._alphaMap = this.alphaMap;
		var canvas = map;
		var ctx;
		if (map instanceof HTMLCanvasElement) {
			ctx = canvas.getContext("2d");
		} else {
			canvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement("canvas");
			canvas.width = map.width;
			canvas.height = map.height;
			ctx = canvas.getContext("2d");
			ctx.drawImage(map, 0, 0);
		}

		try {
			var imgData = ctx.getImageData(0, 0, map.width, map.height);
		} catch (e) {
			//if (!this.suppressCrossDomainErrors) throw new Error("unable to access local image data: " + e);
			return false;
		}
		
		this._mapData = imgData.data;
		return true;
	};


	createjs.AlphaMapFilter = createjs.promote(AlphaMapFilter, "Filter");
}());

//##############################################################################
// AlphaMaskFilter.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";


// constructor:
	/**
	 * Applies the alpha from the mask image (or canvas) to the target, such that the alpha channel of the result will
	 * be derived from the mask, and the RGB channels will be copied from the target. This can be used, for example, to
	 * apply an alpha mask to a display object. This can also be used to combine a JPG compressed RGB image with a PNG32
	 * alpha mask, which can result in a much smaller file size than a single PNG32 containing ARGB.
	 *
	 * <b>IMPORTANT NOTE: This filter currently does not support the targetCtx, or targetX/Y parameters correctly.</b>
	 *
	 * <h4>Example</h4>
	 * This example draws a gradient box, then caches it and uses the "cacheCanvas" as the alpha mask on a 100x100 image.
	 *
	 *      var box = new createjs.Shape();
	 *      box.graphics.beginLinearGradientFill(["#000000", "rgba(0, 0, 0, 0)"], [0, 1], 0, 0, 100, 100)
	 *      box.graphics.drawRect(0, 0, 100, 100);
	 *      box.cache(0, 0, 100, 100);
	 *
	 *      var bmp = new createjs.Bitmap("path/to/image.jpg");
	 *      bmp.filters = [
	 *          new createjs.AlphaMaskFilter(box.cacheCanvas)
	 *      ];
	 *      bmp.cache(0, 0, 100, 100);
	 *
	 * See {{#crossLink "Filter"}}{{/crossLink}} for more information on applying filters.
	 * @class AlphaMaskFilter
	 * @extends Filter
	 * @constructor
	 * @param {HTMLImageElement|HTMLCanvasElement} mask
	 **/
	function AlphaMaskFilter(mask) {
	
	
	// public properties:
		/**
		 * The image (or canvas) to use as the mask.
		 * @property mask
		 * @type HTMLImageElement|HTMLCanvasElement
		 **/
		this.mask = mask;
	}
	var p = createjs.extend(AlphaMaskFilter, createjs.Filter);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	

// public methods:
	/**
	 * Applies the filter to the specified context.
	 *
	 * <strong>IMPORTANT NOTE: This filter currently does not support the targetCtx, or targetX/Y parameters
	 * correctly.</strong>
	 * @method applyFilter
	 * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.
	 * @param {Number} x The x position to use for the source rect.
	 * @param {Number} y The y position to use for the source rect.
	 * @param {Number} width The width to use for the source rect.
	 * @param {Number} height The height to use for the source rect.
	 * @param {CanvasRenderingContext2D} [targetCtx] NOT SUPPORTED IN THIS FILTER. The 2D context to draw the result to. Defaults to the context passed to ctx.
	 * @param {Number} [targetX] NOT SUPPORTED IN THIS FILTER. The x position to draw the result to. Defaults to the value passed to x.
	 * @param {Number} [targetY] NOT SUPPORTED IN THIS FILTER. The y position to draw the result to. Defaults to the value passed to y.
	 * @return {Boolean} If the filter was applied successfully.
	 **/
	p.applyFilter = function (ctx, x, y, width, height, targetCtx, targetX, targetY) {
		if (!this.mask) { return true; }
		targetCtx = targetCtx || ctx;
		if (targetX == null) { targetX = x; }
		if (targetY == null) { targetY = y; }

		targetCtx.save();
		if (ctx != targetCtx) {
			// TODO: support targetCtx and targetX/Y
			// clearRect, then draw the ctx in?
			return false;
		}

		targetCtx.globalCompositeOperation = "destination-in";
		targetCtx.drawImage(this.mask, targetX, targetY);
		targetCtx.restore();
		return true;
	};

	/** docced in super class **/
	p.clone = function () {
		return new AlphaMaskFilter(this.mask);
	};

	/** docced in super class **/
	p.toString = function () {
		return "[AlphaMaskFilter]";
	};


	createjs.AlphaMaskFilter = createjs.promote(AlphaMaskFilter, "Filter");
}());

//##############################################################################
// ColorFilter.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Applies a color transform to DisplayObjects.
	 *
	 * <h4>Example</h4>
	 * This example draws a red circle, and then transforms it to Blue. This is accomplished by multiplying all the channels
	 * to 0 (except alpha, which is set to 1), and then adding 255 to the blue channel.
	 *
	 *      var shape = new createjs.Shape().set({x:100,y:100});
	 *      shape.graphics.beginFill("#ff0000").drawCircle(0,0,50);
	 *
	 *      shape.filters = [
	 *          new createjs.ColorFilter(0,0,0,1, 0,0,255,0)
	 *      ];
	 *      shape.cache(-50, -50, 100, 100);
	 *
	 * See {{#crossLink "Filter"}}{{/crossLink}} for an more information on applying filters.
	 * @class ColorFilter
	 * @param {Number} [redMultiplier=1] The amount to multiply against the red channel. This is a range between 0 and 1.
	 * @param {Number} [greenMultiplier=1] The amount to multiply against the green channel. This is a range between 0 and 1.
	 * @param {Number} [blueMultiplier=1] The amount to multiply against the blue channel. This is a range between 0 and 1.
	 * @param {Number} [alphaMultiplier=1] The amount to multiply against the alpha channel. This is a range between 0 and 1.
	 * @param {Number} [redOffset=0] The amount to add to the red channel after it has been multiplied. This is a range
	 * between -255 and 255.
	 * @param {Number} [greenOffset=0] The amount to add to the green channel after it has been multiplied. This is a range
	  * between -255 and 255.
	 * @param {Number} [blueOffset=0] The amount to add to the blue channel after it has been multiplied. This is a range
	  * between -255 and 255.
	 * @param {Number} [alphaOffset=0] The amount to add to the alpha channel after it has been multiplied. This is a range
	  * between -255 and 255.
	 * @constructor
	 * @extends Filter
	 **/
	function ColorFilter(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
		
	
	// public properties:
		/**
		 * Red channel multiplier.
		 * @property redMultiplier
		 * @type Number
		 **/
		this.redMultiplier = redMultiplier != null ? redMultiplier : 1;
	
		/**
		 * Green channel multiplier.
		 * @property greenMultiplier
		 * @type Number
		 **/
		this.greenMultiplier = greenMultiplier != null ? greenMultiplier : 1;
	
		/**
		 * Blue channel multiplier.
		 * @property blueMultiplier
		 * @type Number
		 **/
		this.blueMultiplier = blueMultiplier != null ? blueMultiplier : 1;
	
		/**
		 * Alpha channel multiplier.
		 * @property alphaMultiplier
		 * @type Number
		 **/
		this.alphaMultiplier = alphaMultiplier != null ? alphaMultiplier : 1;
	
		/**
		 * Red channel offset (added to value).
		 * @property redOffset
		 * @type Number
		 **/
		this.redOffset = redOffset || 0;
	
		/**
		 * Green channel offset (added to value).
		 * @property greenOffset
		 * @type Number
		 **/
		this.greenOffset = greenOffset || 0;
	
		/**
		 * Blue channel offset (added to value).
		 * @property blueOffset
		 * @type Number
		 **/
		this.blueOffset = blueOffset || 0;
	
		/**
		 * Alpha channel offset (added to value).
		 * @property alphaOffset
		 * @type Number
		 **/
		this.alphaOffset = alphaOffset || 0;
	}
	var p = createjs.extend(ColorFilter, createjs.Filter);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// public methods:
	/** docced in super class **/
	p.toString = function() {
		return "[ColorFilter]";
	};

	/** docced in super class **/
	p.clone = function() {
		return new ColorFilter(this.redMultiplier, this.greenMultiplier, this.blueMultiplier, this.alphaMultiplier, this.redOffset, this.greenOffset, this.blueOffset, this.alphaOffset);
	};
	

// private methods:
	/** docced in super class **/
	p._applyFilter = function(imageData) {
		var data = imageData.data;
		var l = data.length;
		for (var i=0; i<l; i+=4) {
			data[i] = data[i]*this.redMultiplier+this.redOffset;
			data[i+1] = data[i+1]*this.greenMultiplier+this.greenOffset;
			data[i+2] = data[i+2]*this.blueMultiplier+this.blueOffset;
			data[i+3] = data[i+3]*this.alphaMultiplier+this.alphaOffset;
		}
		return true;
	};


	createjs.ColorFilter = createjs.promote(ColorFilter, "Filter");
}());

//##############################################################################
// ColorMatrix.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Provides helper functions for assembling a matrix for use with the {{#crossLink "ColorMatrixFilter"}}{{/crossLink}}.
	 * Most methods return the instance to facilitate chained calls.
	 *
	 * <h4>Example</h4>
	 *
	 *      myColorMatrix.adjustHue(20).adjustBrightness(50);
	 *
	 * See {{#crossLink "Filter"}}{{/crossLink}} for an example of how to apply filters, or {{#crossLink "ColorMatrixFilter"}}{{/crossLink}}
	 * for an example of how to use ColorMatrix to change a DisplayObject's color.
	 * @class ColorMatrix
	 * @param {Number} brightness
	 * @param {Number} contrast
	 * @param {Number} saturation
	 * @param {Number} hue
	 * @constructor
	 **/
	function ColorMatrix(brightness, contrast, saturation, hue) {
		this.setColor(brightness, contrast, saturation, hue);
	}
	var p = ColorMatrix.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// constants:
	/**
	 * Array of delta values for contrast calculations.
	 * @property DELTA_INDEX
	 * @type Array
	 * @protected
	 * @static
	 **/
	ColorMatrix.DELTA_INDEX = [
		0,    0.01, 0.02, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1,  0.11,
		0.12, 0.14, 0.15, 0.16, 0.17, 0.18, 0.20, 0.21, 0.22, 0.24,
		0.25, 0.27, 0.28, 0.30, 0.32, 0.34, 0.36, 0.38, 0.40, 0.42,
		0.44, 0.46, 0.48, 0.5,  0.53, 0.56, 0.59, 0.62, 0.65, 0.68,
		0.71, 0.74, 0.77, 0.80, 0.83, 0.86, 0.89, 0.92, 0.95, 0.98,
		1.0,  1.06, 1.12, 1.18, 1.24, 1.30, 1.36, 1.42, 1.48, 1.54,
		1.60, 1.66, 1.72, 1.78, 1.84, 1.90, 1.96, 2.0,  2.12, 2.25,
		2.37, 2.50, 2.62, 2.75, 2.87, 3.0,  3.2,  3.4,  3.6,  3.8,
		4.0,  4.3,  4.7,  4.9,  5.0,  5.5,  6.0,  6.5,  6.8,  7.0,
		7.3,  7.5,  7.8,  8.0,  8.4,  8.7,  9.0,  9.4,  9.6,  9.8,
		10.0
	];

	/**
	 * Identity matrix values.
	 * @property IDENTITY_MATRIX
	 * @type Array
	 * @protected
	 * @static
	 **/
	ColorMatrix.IDENTITY_MATRIX = [
		1,0,0,0,0,
		0,1,0,0,0,
		0,0,1,0,0,
		0,0,0,1,0,
		0,0,0,0,1
	];

	/**
	 * The constant length of a color matrix.
	 * @property LENGTH
	 * @type Number
	 * @protected
	 * @static
	 **/
	ColorMatrix.LENGTH = ColorMatrix.IDENTITY_MATRIX.length;


// public methods:
	/**
	 * Resets the instance with the specified values.
	 * @method setColor
	 * @param {Number} brightness
	 * @param {Number} contrast
	 * @param {Number} saturation
	 * @param {Number} hue
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 */
	p.setColor = function(brightness,contrast,saturation,hue) {
		return this.reset().adjustColor(brightness,contrast,saturation,hue);
	};

	/**
	 * Resets the matrix to identity values.
	 * @method reset
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 */
	p.reset = function() {
		return this.copy(ColorMatrix.IDENTITY_MATRIX);
	};

	/**
	 * Shortcut method to adjust brightness, contrast, saturation and hue.
	 * Equivalent to calling adjustHue(hue), adjustContrast(contrast),
	 * adjustBrightness(brightness), adjustSaturation(saturation), in that order.
	 * @method adjustColor
	 * @param {Number} brightness
	 * @param {Number} contrast
	 * @param {Number} saturation
	 * @param {Number} hue
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.adjustColor = function(brightness,contrast,saturation,hue) {
		this.adjustHue(hue);
		this.adjustContrast(contrast);
		this.adjustBrightness(brightness);
		return this.adjustSaturation(saturation);
	};

	/**
	 * Adjusts the brightness of pixel color by adding the specified value to the red, green and blue channels.
	 * Positive values will make the image brighter, negative values will make it darker.
	 * @method adjustBrightness
	 * @param {Number} value A value between -255 & 255 that will be added to the RGB channels.
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.adjustBrightness = function(value) {
		if (value == 0 || isNaN(value)) { return this; }
		value = this._cleanValue(value,255);
		this._multiplyMatrix([
			1,0,0,0,value,
			0,1,0,0,value,
			0,0,1,0,value,
			0,0,0,1,0,
			0,0,0,0,1
		]);
		return this;
	};

	/**
	 * Adjusts the contrast of pixel color.
	 * Positive values will increase contrast, negative values will decrease contrast.
	 * @method adjustContrast
	 * @param {Number} value A value between -100 & 100.
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.adjustContrast = function(value) {
		if (value == 0 || isNaN(value)) { return this; }
		value = this._cleanValue(value,100);
		var x;
		if (value<0) {
			x = 127+value/100*127;
		} else {
			x = value%1;
			if (x == 0) {
				x = ColorMatrix.DELTA_INDEX[value];
			} else {
				x = ColorMatrix.DELTA_INDEX[(value<<0)]*(1-x)+ColorMatrix.DELTA_INDEX[(value<<0)+1]*x; // use linear interpolation for more granularity.
			}
			x = x*127+127;
		}
		this._multiplyMatrix([
			x/127,0,0,0,0.5*(127-x),
			0,x/127,0,0,0.5*(127-x),
			0,0,x/127,0,0.5*(127-x),
			0,0,0,1,0,
			0,0,0,0,1
		]);
		return this;
	};

	/**
	 * Adjusts the color saturation of the pixel.
	 * Positive values will increase saturation, negative values will decrease saturation (trend towards greyscale).
	 * @method adjustSaturation
	 * @param {Number} value A value between -100 & 100.
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.adjustSaturation = function(value) {
		if (value == 0 || isNaN(value)) { return this; }
		value = this._cleanValue(value,100);
		var x = 1+((value > 0) ? 3*value/100 : value/100);
		var lumR = 0.3086;
		var lumG = 0.6094;
		var lumB = 0.0820;
		this._multiplyMatrix([
			lumR*(1-x)+x,lumG*(1-x),lumB*(1-x),0,0,
			lumR*(1-x),lumG*(1-x)+x,lumB*(1-x),0,0,
			lumR*(1-x),lumG*(1-x),lumB*(1-x)+x,0,0,
			0,0,0,1,0,
			0,0,0,0,1
		]);
		return this;
	};


	/**
	 * Adjusts the hue of the pixel color.
	 * @method adjustHue
	 * @param {Number} value A value between -180 & 180.
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.adjustHue = function(value) {
		if (value == 0 || isNaN(value)) { return this; }
		value = this._cleanValue(value,180)/180*Math.PI;
		var cosVal = Math.cos(value);
		var sinVal = Math.sin(value);
		var lumR = 0.213;
		var lumG = 0.715;
		var lumB = 0.072;
		this._multiplyMatrix([
			lumR+cosVal*(1-lumR)+sinVal*(-lumR),lumG+cosVal*(-lumG)+sinVal*(-lumG),lumB+cosVal*(-lumB)+sinVal*(1-lumB),0,0,
			lumR+cosVal*(-lumR)+sinVal*(0.143),lumG+cosVal*(1-lumG)+sinVal*(0.140),lumB+cosVal*(-lumB)+sinVal*(-0.283),0,0,
			lumR+cosVal*(-lumR)+sinVal*(-(1-lumR)),lumG+cosVal*(-lumG)+sinVal*(lumG),lumB+cosVal*(1-lumB)+sinVal*(lumB),0,0,
			0,0,0,1,0,
			0,0,0,0,1
		]);
		return this;
	};

	/**
	 * Concatenates (multiplies) the specified matrix with this one.
	 * @method concat
	 * @param {Array} matrix An array or ColorMatrix instance.
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.concat = function(matrix) {
		matrix = this._fixMatrix(matrix);
		if (matrix.length != ColorMatrix.LENGTH) { return this; }
		this._multiplyMatrix(matrix);
		return this;
	};

	/**
	 * Returns a clone of this ColorMatrix.
	 * @method clone
	 * @return {ColorMatrix} A clone of this ColorMatrix.
	 **/
	p.clone = function() {
		return (new ColorMatrix()).copy(this);
	};

	/**
	 * Return a length 25 (5x5) array instance containing this matrix's values.
	 * @method toArray
	 * @return {Array} An array holding this matrix's values.
	 **/
	p.toArray = function() {
		var arr = [];
		for (var i= 0, l=ColorMatrix.LENGTH; i<l; i++) {
			arr[i] = this[i];
		}
		return arr;
	};

	/**
	 * Copy the specified matrix's values to this matrix.
	 * @method copy
	 * @param {Array} matrix An array or ColorMatrix instance.
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.copy = function(matrix) {
		var l = ColorMatrix.LENGTH;
		for (var i=0;i<l;i++) {
			this[i] = matrix[i];
		}
		return this;
	};
	
	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[ColorMatrix]";
	};


// private methods:
	/**
	 * @method _multiplyMatrix
	 * @param {Array} matrix
	 * @protected
	 **/
	p._multiplyMatrix = function(matrix) {
		var i, j, k, col = [];

		for (i=0;i<5;i++) {
			for (j=0;j<5;j++) {
				col[j] = this[j+i*5];
			}
			for (j=0;j<5;j++) {
				var val=0;
				for (k=0;k<5;k++) {
					val += matrix[j+k*5]*col[k];
				}
				this[j+i*5] = val;
			}
		}
	};

	/**
	 * Make sure values are within the specified range, hue has a limit of 180, brightness is 255, others are 100.
	 * @method _cleanValue
	 * @param {Number} value The raw number
	 * @param {Number} limit The maximum that the number can be. The minimum is the limit * -1.
	 * @protected
	 **/
	p._cleanValue = function(value, limit) {
		return Math.min(limit,Math.max(-limit,value));
	};

	/**
	 * Makes sure matrixes are 5x5 (25 long).
	 * @method _fixMatrix
	 * @param {Array} matrix
	 * @protected
	 **/
	p._fixMatrix = function(matrix) {
		if (matrix instanceof ColorMatrix) { matrix = matrix.toArray(); }
		if (matrix.length < ColorMatrix.LENGTH) {
			matrix = matrix.slice(0,matrix.length).concat(ColorMatrix.IDENTITY_MATRIX.slice(matrix.length,ColorMatrix.LENGTH));
		} else if (matrix.length > ColorMatrix.LENGTH) {
			matrix = matrix.slice(0,ColorMatrix.LENGTH);
		}
		return matrix;
	};


	createjs.ColorMatrix = ColorMatrix;
}());

//##############################################################################
// ColorMatrixFilter.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Allows you to carry out complex color operations such as modifying saturation, brightness, or inverting. See the
	 * {{#crossLink "ColorMatrix"}}{{/crossLink}} for more information on changing colors. For an easier color transform,
	 * consider the {{#crossLink "ColorFilter"}}{{/crossLink}}.
	 *
	 * <h4>Example</h4>
	 * This example creates a red circle, inverts its hue, and then saturates it to brighten it up.
	 *
	 *      var shape = new createjs.Shape().set({x:100,y:100});
	 *      shape.graphics.beginFill("#ff0000").drawCircle(0,0,50);
	 *
	 *      var matrix = new createjs.ColorMatrix().adjustHue(180).adjustSaturation(100);
	 *      shape.filters = [
	 *          new createjs.ColorMatrixFilter(matrix)
	 *      ];
	 *
	 *      shape.cache(-50, -50, 100, 100);
	 *
	 * See {{#crossLink "Filter"}}{{/crossLink}} for an more information on applying filters.
	 * @class ColorMatrixFilter
	 * @constructor
	 * @extends Filter
	 * @param {Array | ColorMatrix} matrix A 4x5 matrix describing the color operation to perform. See also the {{#crossLink "ColorMatrix"}}{{/crossLink}}
	 * class.
	 **/
	function ColorMatrixFilter(matrix) {
	
		
	// public properties:
		/**
		 * A 4x5 matrix describing the color operation to perform. See also the {{#crossLink "ColorMatrix"}}{{/crossLink}}
		 * @property matrix
		 * @type Array | ColorMatrix
		 **/
		this.matrix = matrix;
	}
	var p = createjs.extend(ColorMatrixFilter, createjs.Filter);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	

// public methods:
	/** docced in super class **/
	p.toString = function() {
		return "[ColorMatrixFilter]";
	};

	/** docced in super class **/
	p.clone = function() {
		return new ColorMatrixFilter(this.matrix);
	};

// private methods:
	/** docced in super class **/
	p._applyFilter = function(imageData) { 
		var data = imageData.data;
		var l = data.length;
		var r,g,b,a;
		var mtx = this.matrix;
		var m0 =  mtx[0],  m1 =  mtx[1],  m2 =  mtx[2],  m3 =  mtx[3],  m4 =  mtx[4];
		var m5 =  mtx[5],  m6 =  mtx[6],  m7 =  mtx[7],  m8 =  mtx[8],  m9 =  mtx[9];
		var m10 = mtx[10], m11 = mtx[11], m12 = mtx[12], m13 = mtx[13], m14 = mtx[14];
		var m15 = mtx[15], m16 = mtx[16], m17 = mtx[17], m18 = mtx[18], m19 = mtx[19];

		for (var i=0; i<l; i+=4) {
			r = data[i];
			g = data[i+1];
			b = data[i+2];
			a = data[i+3];
			data[i] = r*m0+g*m1+b*m2+a*m3+m4; // red
			data[i+1] = r*m5+g*m6+b*m7+a*m8+m9; // green
			data[i+2] = r*m10+g*m11+b*m12+a*m13+m14; // blue
			data[i+3] = r*m15+g*m16+b*m17+a*m18+m19; // alpha
		}
		return true;
	};


	createjs.ColorMatrixFilter = createjs.promote(ColorMatrixFilter, "Filter");
}());

//##############################################################################
// Touch.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
 * Global utility for working with multi-touch enabled devices in EaselJS. Currently supports W3C Touch API (iOS and
 * modern Android browser) and the Pointer API (IE), including ms-prefixed events in IE10, and unprefixed in IE11.
 *
 * Ensure that you {{#crossLink "Touch/disable"}}{{/crossLink}} touch when cleaning up your application. You do not have
 * to check if touch is supported to enable it, as it will fail gracefully if it is not supported.
 *
 * <h4>Example</h4>
 *
 *      var stage = new createjs.Stage("canvasId");
 *      createjs.Touch.enable(stage);
 *
 * <strong>Note:</strong> It is important to disable Touch on a stage that you are no longer using:
 *
 *      createjs.Touch.disable(stage);
 *
 * @class Touch
 * @static
 **/
	function Touch() {
		throw "Touch cannot be instantiated";
	}


// public static methods:
	/**
	 * Returns `true` if touch is supported in the current browser.
	 * @method isSupported
	 * @return {Boolean} Indicates whether touch is supported in the current browser.
	 * @static
	 **/
	Touch.isSupported = function() {
		return	!!(('ontouchstart' in window) // iOS & Android
			|| (window.navigator['msPointerEnabled'] && window.navigator['msMaxTouchPoints'] > 0) // IE10
			|| (window.navigator['pointerEnabled'] && window.navigator['maxTouchPoints'] > 0)); // IE11+
	};

	/**
	 * Enables touch interaction for the specified EaselJS {{#crossLink "Stage"}}{{/crossLink}}. Currently supports iOS
	 * (and compatible browsers, such as modern Android browsers), and IE10/11. Supports both single touch and
	 * multi-touch modes. Extends the EaselJS {{#crossLink "MouseEvent"}}{{/crossLink}} model, but without support for
	 * double click or over/out events. See the MouseEvent {{#crossLink "MouseEvent/pointerId:property"}}{{/crossLink}}
	 * for more information.
	 * @method enable
	 * @param {Stage} stage The {{#crossLink "Stage"}}{{/crossLink}} to enable touch on.
	 * @param {Boolean} [singleTouch=false] If `true`, only a single touch will be active at a time.
	 * @param {Boolean} [allowDefault=false] If `true`, then default gesture actions (ex. scrolling, zooming) will be
	 * allowed when the user is interacting with the target canvas.
	 * @return {Boolean} Returns `true` if touch was successfully enabled on the target stage.
	 * @static
	 **/
	Touch.enable = function(stage, singleTouch, allowDefault) {
		if (!stage || !stage.canvas || !Touch.isSupported()) { return false; }
		if (stage.__touch) { return true; }

		// inject required properties on stage:
		stage.__touch = {pointers:{}, multitouch:!singleTouch, preventDefault:!allowDefault, count:0};

		// note that in the future we may need to disable the standard mouse event model before adding
		// these to prevent duplicate calls. It doesn't seem to be an issue with iOS devices though.
		if ('ontouchstart' in window) { Touch._IOS_enable(stage); }
		else if (window.navigator['msPointerEnabled'] || window.navigator["pointerEnabled"]) { Touch._IE_enable(stage); }
		return true;
	};

	/**
	 * Removes all listeners that were set up when calling `Touch.enable()` on a stage.
	 * @method disable
	 * @param {Stage} stage The {{#crossLink "Stage"}}{{/crossLink}} to disable touch on.
	 * @static
	 **/
	Touch.disable = function(stage) {
		if (!stage) { return; }
		if ('ontouchstart' in window) { Touch._IOS_disable(stage); }
		else if (window.navigator['msPointerEnabled'] || window.navigator["pointerEnabled"]) { Touch._IE_disable(stage); }
		
		delete stage.__touch;
	};


// Private static methods:
	/**
	 * @method _IOS_enable
	 * @protected
	 * @param {Stage} stage
	 * @static
	 **/
	Touch._IOS_enable = function(stage) {
		var canvas = stage.canvas;
		var f = stage.__touch.f = function(e) { Touch._IOS_handleEvent(stage,e); };
		canvas.addEventListener("touchstart", f, false);
		canvas.addEventListener("touchmove", f, false);
		canvas.addEventListener("touchend", f, false);
		canvas.addEventListener("touchcancel", f, false);
	};

	/**
	 * @method _IOS_disable
	 * @protected
	 * @param {Stage} stage
	 * @static
	 **/
	Touch._IOS_disable = function(stage) {
		var canvas = stage.canvas;
		if (!canvas) { return; }
		var f = stage.__touch.f;
		canvas.removeEventListener("touchstart", f, false);
		canvas.removeEventListener("touchmove", f, false);
		canvas.removeEventListener("touchend", f, false);
		canvas.removeEventListener("touchcancel", f, false);
	};

	/**
	 * @method _IOS_handleEvent
	 * @param {Stage} stage
	 * @param {Object} e The event to handle
	 * @protected
	 * @static
	 **/
	Touch._IOS_handleEvent = function(stage, e) {
		if (!stage) { return; }
		if (stage.__touch.preventDefault) { e.preventDefault&&e.preventDefault(); }
		var touches = e.changedTouches;
		var type = e.type;
		for (var i= 0,l=touches.length; i<l; i++) {
			var touch = touches[i];
			var id = touch.identifier;
			if (touch.target != stage.canvas) { continue; }

			if (type == "touchstart") {
				this._handleStart(stage, id, e, touch.pageX, touch.pageY);
			} else if (type == "touchmove") {
				this._handleMove(stage, id, e, touch.pageX, touch.pageY);
			} else if (type == "touchend" || type == "touchcancel") {
				this._handleEnd(stage, id, e);
			}
		}
	};

	/**
	 * @method _IE_enable
	 * @protected
	 * @param {Stage} stage
	 * @static
	 **/
	Touch._IE_enable = function(stage) {
		var canvas = stage.canvas;
		var f = stage.__touch.f = function(e) { Touch._IE_handleEvent(stage,e); };

		if (window.navigator["pointerEnabled"] === undefined) {
			canvas.addEventListener("MSPointerDown", f, false);
			window.addEventListener("MSPointerMove", f, false);
			window.addEventListener("MSPointerUp", f, false);
			window.addEventListener("MSPointerCancel", f, false);
			if (stage.__touch.preventDefault) { canvas.style.msTouchAction = "none"; }
		} else {
			canvas.addEventListener("pointerdown", f, false);
			window.addEventListener("pointermove", f, false);
			window.addEventListener("pointerup", f, false);
			window.addEventListener("pointercancel", f, false);
			if (stage.__touch.preventDefault) { canvas.style.touchAction = "none"; }

		}
		stage.__touch.activeIDs = {};
	};

	/**
	 * @method _IE_disable
	 * @protected
	 * @param {Stage} stage
	 * @static
	 **/
	Touch._IE_disable = function(stage) {
		var f = stage.__touch.f;

		if (window.navigator["pointerEnabled"] === undefined) {
			window.removeEventListener("MSPointerMove", f, false);
			window.removeEventListener("MSPointerUp", f, false);
			window.removeEventListener("MSPointerCancel", f, false);
			if (stage.canvas) {
				stage.canvas.removeEventListener("MSPointerDown", f, false);
			}
		} else {
			window.removeEventListener("pointermove", f, false);
			window.removeEventListener("pointerup", f, false);
			window.removeEventListener("pointercancel", f, false);
			if (stage.canvas) {
				stage.canvas.removeEventListener("pointerdown", f, false);
			}
		}
	};

	/**
	 * @method _IE_handleEvent
	 * @param {Stage} stage
	 * @param {Object} e The event to handle.
	 * @protected
	 * @static
	 **/
	Touch._IE_handleEvent = function(stage, e) {
		if (!stage) { return; }
		if (stage.__touch.preventDefault) { e.preventDefault && e.preventDefault(); }
		var type = e.type;
		var id = e.pointerId;
		var ids = stage.__touch.activeIDs;

		if (type == "MSPointerDown" || type == "pointerdown") {
			if (e.srcElement != stage.canvas) { return; }
			ids[id] = true;
			this._handleStart(stage, id, e, e.pageX, e.pageY);
		} else if (ids[id]) { // it's an id we're watching
			if (type == "MSPointerMove" || type == "pointermove") {
				this._handleMove(stage, id, e, e.pageX, e.pageY);
			} else if (type == "MSPointerUp" || type == "MSPointerCancel"
					|| type == "pointerup" || type == "pointercancel") {
				delete(ids[id]);
				this._handleEnd(stage, id, e);
			}
		}
	};

	/**
	 * @method _handleStart
	 * @param {Stage} stage
	 * @param {String|Number} id
	 * @param {Object} e
	 * @param {Number} x
	 * @param {Number} y
	 * @protected
	 **/
	Touch._handleStart = function(stage, id, e, x, y) {
		var props = stage.__touch;
		if (!props.multitouch && props.count) { return; }
		var ids = props.pointers;
		if (ids[id]) { return; }
		ids[id] = true;
		props.count++;
		stage._handlePointerDown(id, e, x, y);
	};

	/**
	 * @method _handleMove
	 * @param {Stage} stage
	 * @param {String|Number} id
	 * @param {Object} e
	 * @param {Number} x
	 * @param {Number} y
	 * @protected
	 **/
	Touch._handleMove = function(stage, id, e, x, y) {
		if (!stage.__touch.pointers[id]) { return; }
		stage._handlePointerMove(id, e, x, y);
	};

	/**
	 * @method _handleEnd
	 * @param {Stage} stage
	 * @param {String|Number} id
	 * @param {Object} e
	 * @protected
	 **/
	Touch._handleEnd = function(stage, id, e) {
		// TODO: cancel should be handled differently for proper UI (ex. an up would trigger a click, a cancel would more closely resemble an out).
		var props = stage.__touch;
		var ids = props.pointers;
		if (!ids[id]) { return; }
		props.count--;
		stage._handlePointerUp(id, e, true);
		delete(ids[id]);
	};


	createjs.Touch = Touch;
}());

//##############################################################################
// version.js
//##############################################################################

this.createjs = this.createjs || {};

(function() {
	"use strict";

	/**
	 * Static class holding library specific information such as the version and buildDate of
	 * the library.
	 * @class EaselJS
	 **/
	var s = createjs.EaselJS = createjs.EaselJS || {};

	/**
	 * The version string for this release.
	 * @property version
	 * @type String
	 * @static
	 **/
	s.version = /*=version*/"0.8.1"; // injected by build process

	/**
	 * The build date for this release in UTC format.
	 * @property buildDate
	 * @type String
	 * @static
	 **/
	s.buildDate = /*=date*/"Thu, 21 May 2015 16:17:39 GMT"; // injected by build process

})();
/*!
* PreloadJS
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2010 gskinner.com, inc.
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/


//##############################################################################
// version.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	/**
	 * Static class holding library specific information such as the version and buildDate of the library.
	 * @class PreloadJS
	 **/
	var s = createjs.PreloadJS = createjs.PreloadJS || {};

	/**
	 * The version string for this release.
	 * @property version
	 * @type {String}
	 * @static
	 **/
	s.version = /*=version*/"0.6.1"; // injected by build process

	/**
	 * The build date for this release in UTC format.
	 * @property buildDate
	 * @type {String}
	 * @static
	 **/
	s.buildDate = /*=date*/"Thu, 21 May 2015 16:17:37 GMT"; // injected by build process

})();

//##############################################################################
// extend.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Sets up the prototype chain and constructor property for a new class.
 *
 * This should be called right after creating the class constructor.
 *
 * 	function MySubClass() {}
 * 	createjs.extend(MySubClass, MySuperClass);
 * 	ClassB.prototype.doSomething = function() { }
 *
 * 	var foo = new MySubClass();
 * 	console.log(foo instanceof MySuperClass); // true
 * 	console.log(foo.prototype.constructor === MySubClass); // true
 *
 * @method extend
 * @param {Function} subclass The subclass.
 * @param {Function} superclass The superclass to extend.
 * @return {Function} Returns the subclass's new prototype.
 */
createjs.extend = function(subclass, superclass) {
	"use strict";

	function o() { this.constructor = subclass; }
	o.prototype = superclass.prototype;
	return (subclass.prototype = new o());
};

//##############################################################################
// promote.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.
 * It is recommended to use the super class's name as the prefix.
 * An alias to the super class's constructor is always added in the format `prefix_constructor`.
 * This allows the subclass to call super class methods without using `function.call`, providing better performance.
 *
 * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, "MySuperClass")`
 * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the
 * prototype of `MySubClass` as `MySuperClass_draw`.
 *
 * This should be called after the class's prototype is fully defined.
 *
 * 	function ClassA(name) {
 * 		this.name = name;
 * 	}
 * 	ClassA.prototype.greet = function() {
 * 		return "Hello "+this.name;
 * 	}
 *
 * 	function ClassB(name, punctuation) {
 * 		this.ClassA_constructor(name);
 * 		this.punctuation = punctuation;
 * 	}
 * 	createjs.extend(ClassB, ClassA);
 * 	ClassB.prototype.greet = function() {
 * 		return this.ClassA_greet()+this.punctuation;
 * 	}
 * 	createjs.promote(ClassB, "ClassA");
 *
 * 	var foo = new ClassB("World", "!?!");
 * 	console.log(foo.greet()); // Hello World!?!
 *
 * @method promote
 * @param {Function} subclass The class to promote super class methods on.
 * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.
 * @return {Function} Returns the subclass.
 */
createjs.promote = function(subclass, prefix) {
	"use strict";

	var subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;
	if (supP) {
		subP[(prefix+="_") + "constructor"] = supP.constructor; // constructor is not always innumerable
		for (var n in supP) {
			if (subP.hasOwnProperty(n) && (typeof supP[n] == "function")) { subP[prefix + n] = supP[n]; }
		}
	}
	return subclass;
};

//##############################################################################
// indexOf.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of
 * that value.  Returns -1 if value is not found.
 *
 *      var i = createjs.indexOf(myArray, myElementToFind);
 *
 * @method indexOf
 * @param {Array} array Array to search for searchElement
 * @param searchElement Element to find in array.
 * @return {Number} The first index of searchElement in array.
 */
createjs.indexOf = function (array, searchElement){
	"use strict";

	for (var i = 0,l=array.length; i < l; i++) {
		if (searchElement === array[i]) {
			return i;
		}
	}
	return -1;
};

//##############################################################################
// proxy.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * Various utilities that the CreateJS Suite uses. Utilities are created as separate files, and will be available on the
 * createjs namespace directly.
 *
 * <h4>Example</h4>
 *
 *      myObject.addEventListener("change", createjs.proxy(myMethod, scope));
 *
 * @class Utility Methods
 * @main Utility Methods
 */

(function() {
	"use strict";

	/**
	 * A function proxy for methods. By default, JavaScript methods do not maintain scope, so passing a method as a
	 * callback will result in the method getting called in the scope of the caller. Using a proxy ensures that the
	 * method gets called in the correct scope.
	 *
	 * Additional arguments can be passed that will be applied to the function when it is called.
	 *
	 * <h4>Example</h4>
	 *
	 *      myObject.addEventListener("event", createjs.proxy(myHandler, this, arg1, arg2));
	 *
	 *      function myHandler(arg1, arg2) {
	 *           // This gets called when myObject.myCallback is executed.
	 *      }
	 *
	 * @method proxy
	 * @param {Function} method The function to call
	 * @param {Object} scope The scope to call the method name on
	 * @param {mixed} [arg] * Arguments that are appended to the callback for additional params.
	 * @public
	 * @static
	 */
	createjs.proxy = function (method, scope) {
		var aArgs = Array.prototype.slice.call(arguments, 2);
		return function () {
			return method.apply(scope, Array.prototype.slice.call(arguments, 0).concat(aArgs));
		};
	}

}());

//##############################################################################
// BrowserDetect.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */
(function() {
	"use strict";

	/**
	 * An object that determines the current browser, version, operating system, and other environment
	 * variables via user agent string.
	 *
	 * Used for audio because feature detection is unable to detect the many limitations of mobile devices.
	 *
	 * <h4>Example</h4>
	 *
	 *      if (createjs.BrowserDetect.isIOS) { // do stuff }
	 *
	 * @property BrowserDetect
	 * @type {Object}
	 * @param {Boolean} isFirefox True if our browser is Firefox.
	 * @param {Boolean} isOpera True if our browser is opera.
	 * @param {Boolean} isChrome True if our browser is Chrome.  Note that Chrome for Android returns true, but is a
	 * completely different browser with different abilities.
	 * @param {Boolean} isIOS True if our browser is safari for iOS devices (iPad, iPhone, and iPod).
	 * @param {Boolean} isAndroid True if our browser is Android.
	 * @param {Boolean} isBlackberry True if our browser is Blackberry.
	 * @constructor
	 * @static
	 */
	function BrowserDetect() {
		throw "BrowserDetect cannot be instantiated";
	}

	var agent = BrowserDetect.agent = window.navigator.userAgent;
	BrowserDetect.isWindowPhone = (agent.indexOf("IEMobile") > -1) || (agent.indexOf("Windows Phone") > -1);
	BrowserDetect.isFirefox = (agent.indexOf("Firefox") > -1);
	BrowserDetect.isOpera = (window.opera != null);
	BrowserDetect.isChrome = (agent.indexOf("Chrome") > -1);  // NOTE that Chrome on Android returns true but is a completely different browser with different abilities
	BrowserDetect.isIOS = (agent.indexOf("iPod") > -1 || agent.indexOf("iPhone") > -1 || agent.indexOf("iPad") > -1) && !BrowserDetect.isWindowPhone;
	BrowserDetect.isAndroid = (agent.indexOf("Android") > -1) && !BrowserDetect.isWindowPhone;
	BrowserDetect.isBlackberry = (agent.indexOf("Blackberry") > -1);

	createjs.BrowserDetect = BrowserDetect;

}());

//##############################################################################
// Event.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

// constructor:
	/**
	 * Contains properties and methods shared by all events for use with
	 * {{#crossLink "EventDispatcher"}}{{/crossLink}}.
	 * 
	 * Note that Event objects are often reused, so you should never
	 * rely on an event object's state outside of the call stack it was received in.
	 * @class Event
	 * @param {String} type The event type.
	 * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
	 * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
	 * @constructor
	 **/
	function Event(type, bubbles, cancelable) {
		
	
	// public properties:
		/**
		 * The type of event.
		 * @property type
		 * @type String
		 **/
		this.type = type;
	
		/**
		 * The object that generated an event.
		 * @property target
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.target = null;
	
		/**
		 * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will
		 * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event
		 * is generated from childObj, then a listener on parentObj would receive the event with
		 * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).
		 * @property currentTarget
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.currentTarget = null;
	
		/**
		 * For bubbling events, this indicates the current event phase:<OL>
		 * 	<LI> capture phase: starting from the top parent to the target</LI>
		 * 	<LI> at target phase: currently being dispatched from the target</LI>
		 * 	<LI> bubbling phase: from the target to the top parent</LI>
		 * </OL>
		 * @property eventPhase
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.eventPhase = 0;
	
		/**
		 * Indicates whether the event will bubble through the display list.
		 * @property bubbles
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.bubbles = !!bubbles;
	
		/**
		 * Indicates whether the default behaviour of this event can be cancelled via
		 * {{#crossLink "Event/preventDefault"}}{{/crossLink}}. This is set via the Event constructor.
		 * @property cancelable
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.cancelable = !!cancelable;
	
		/**
		 * The epoch time at which this event was created.
		 * @property timeStamp
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.timeStamp = (new Date()).getTime();
	
		/**
		 * Indicates if {{#crossLink "Event/preventDefault"}}{{/crossLink}} has been called
		 * on this event.
		 * @property defaultPrevented
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.defaultPrevented = false;
	
		/**
		 * Indicates if {{#crossLink "Event/stopPropagation"}}{{/crossLink}} or
		 * {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called on this event.
		 * @property propagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.propagationStopped = false;
	
		/**
		 * Indicates if {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called
		 * on this event.
		 * @property immediatePropagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.immediatePropagationStopped = false;
		
		/**
		 * Indicates if {{#crossLink "Event/remove"}}{{/crossLink}} has been called on this event.
		 * @property removed
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.removed = false;
	}
	var p = Event.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.
	

// public methods:
	/**
	 * Sets {{#crossLink "Event/defaultPrevented"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method preventDefault
	 **/
	p.preventDefault = function() {
		this.defaultPrevented = this.cancelable&&true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopPropagation
	 **/
	p.stopPropagation = function() {
		this.propagationStopped = true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} and
	 * {{#crossLink "Event/immediatePropagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopImmediatePropagation
	 **/
	p.stopImmediatePropagation = function() {
		this.immediatePropagationStopped = this.propagationStopped = true;
	};
	
	/**
	 * Causes the active listener to be removed via removeEventListener();
	 * 
	 * 		myBtn.addEventListener("click", function(evt) {
	 * 			// do stuff...
	 * 			evt.remove(); // removes this listener.
	 * 		});
	 * 
	 * @method remove
	 **/
	p.remove = function() {
		this.removed = true;
	};
	
	/**
	 * Returns a clone of the Event instance.
	 * @method clone
	 * @return {Event} a clone of the Event instance.
	 **/
	p.clone = function() {
		return new Event(this.type, this.bubbles, this.cancelable);
	};
	
	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the instance.
	 * @return {Event} Returns the instance the method is called on (useful for chaining calls.)
	 * @chainable
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Event (type="+this.type+")]";
	};

	createjs.Event = Event;
}());

//##############################################################################
// ErrorEvent.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

	/**
	 * A general error {{#crossLink "Event"}}{{/crossLink}}, that describes an error that occurred, as well as any details.
	 * @class ErrorEvent
	 * @param {String} [title] The error title
	 * @param {String} [message] The error description
	 * @param {Object} [data] Additional error data
	 * @constructor
	 */
	function ErrorEvent(title, message, data) {
		this.Event_constructor("error");

		/**
		 * The short error title, which indicates the type of error that occurred.
		 * @property title
		 * @type String
		 */
		this.title = title;

		/**
		 * The verbose error message, containing details about the error.
		 * @property message
		 * @type String
		 */
		this.message = message;

		/**
		 * Additional data attached to an error.
		 * @property data
		 * @type {Object}
		 */
		this.data = data;
	}

	var p = createjs.extend(ErrorEvent, createjs.Event);

	p.clone = function() {
		return new createjs.ErrorEvent(this.title, this.message, this.data);
	};

	createjs.ErrorEvent = createjs.promote(ErrorEvent, "Event");

}());

//##############################################################################
// EventDispatcher.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * EventDispatcher provides methods for managing queues of event listeners and dispatching events.
	 *
	 * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the
	 * EventDispatcher {{#crossLink "EventDispatcher/initialize"}}{{/crossLink}} method.
	 * 
	 * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the
	 * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports
	 * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.
	 * 
	 * EventDispatcher also exposes a {{#crossLink "EventDispatcher/on"}}{{/crossLink}} method, which makes it easier
	 * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The 
	 * {{#crossLink "EventDispatcher/off"}}{{/crossLink}} method is merely an alias to
	 * {{#crossLink "EventDispatcher/removeEventListener"}}{{/crossLink}}.
	 * 
	 * Another addition to the DOM Level 2 model is the {{#crossLink "EventDispatcher/removeAllEventListeners"}}{{/crossLink}}
	 * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also 
	 * includes a {{#crossLink "Event/remove"}}{{/crossLink}} method which removes the active listener.
	 *
	 * <h4>Example</h4>
	 * Add EventDispatcher capabilities to the "MyClass" class.
	 *
	 *      EventDispatcher.initialize(MyClass.prototype);
	 *
	 * Add an event (see {{#crossLink "EventDispatcher/addEventListener"}}{{/crossLink}}).
	 *
	 *      instance.addEventListener("eventName", handlerMethod);
	 *      function handlerMethod(event) {
	 *          console.log(event.target + " Was Clicked");
	 *      }
	 *
	 * <b>Maintaining proper scope</b><br />
	 * Scope (ie. "this") can be be a challenge with events. Using the {{#crossLink "EventDispatcher/on"}}{{/crossLink}}
	 * method to subscribe to events simplifies this.
	 *
	 *      instance.addEventListener("click", function(event) {
	 *          console.log(instance == this); // false, scope is ambiguous.
	 *      });
	 *      
	 *      instance.on("click", function(event) {
	 *          console.log(instance == this); // true, "on" uses dispatcher scope by default.
	 *      });
	 * 
	 * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage scope.
	 *      
	 *
	 * @class EventDispatcher
	 * @constructor
	 **/
	function EventDispatcher() {
	
	
	// private properties:
		/**
		 * @protected
		 * @property _listeners
		 * @type Object
		 **/
		this._listeners = null;
		
		/**
		 * @protected
		 * @property _captureListeners
		 * @type Object
		 **/
		this._captureListeners = null;
	}
	var p = EventDispatcher.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// static public methods:
	/**
	 * Static initializer to mix EventDispatcher methods into a target object or prototype.
	 * 
	 * 		EventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class
	 * 		EventDispatcher.initialize(myObject); // add to a specific instance
	 * 
	 * @method initialize
	 * @static
	 * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a
	 * prototype.
	 **/
	EventDispatcher.initialize = function(target) {
		target.addEventListener = p.addEventListener;
		target.on = p.on;
		target.removeEventListener = target.off =  p.removeEventListener;
		target.removeAllEventListeners = p.removeAllEventListeners;
		target.hasEventListener = p.hasEventListener;
		target.dispatchEvent = p.dispatchEvent;
		target._dispatchEvent = p._dispatchEvent;
		target.willTrigger = p.willTrigger;
	};
	

// public methods:
	/**
	 * Adds the specified event listener. Note that adding multiple listeners to the same function will result in
	 * multiple callbacks getting fired.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.addEventListener("click", handleClick);
	 *      function handleClick(event) {
	 *         // Click happened.
	 *      }
	 *
	 * @method addEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function | Object} Returns the listener for chaining or assignment.
	 **/
	p.addEventListener = function(type, listener, useCapture) {
		var listeners;
		if (useCapture) {
			listeners = this._captureListeners = this._captureListeners||{};
		} else {
			listeners = this._listeners = this._listeners||{};
		}
		var arr = listeners[type];
		if (arr) { this.removeEventListener(type, listener, useCapture); }
		arr = listeners[type]; // remove may have deleted the array
		if (!arr) { listeners[type] = [listener];  }
		else { arr.push(listener); }
		return listener;
	};
	
	/**
	 * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener
	 * only run once, associate arbitrary data with the listener, and remove the listener.
	 * 
	 * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.
	 * The created anonymous function is returned for use with .removeEventListener (or .off).
	 * 
	 * <h4>Example</h4>
	 * 
	 * 		var listener = myBtn.on("click", handleClick, null, false, {count:3});
	 * 		function handleClick(evt, data) {
	 * 			data.count -= 1;
	 * 			console.log(this == myBtn); // true - scope defaults to the dispatcher
	 * 			if (data.count == 0) {
	 * 				alert("clicked 3 times!");
	 * 				myBtn.off("click", listener);
	 * 				// alternately: evt.remove();
	 * 			}
	 * 		}
	 * 
	 * @method on
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).
	 * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.
	 * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.
	 * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.
	 **/
	p.on = function(type, listener, scope, once, data, useCapture) {
		if (listener.handleEvent) {
			scope = scope||listener;
			listener = listener.handleEvent;
		}
		scope = scope||this;
		return this.addEventListener(type, function(evt) {
				listener.call(scope, evt, data);
				once&&evt.remove();
			}, useCapture);
	};

	/**
	 * Removes the specified event listener.
	 *
	 * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy
	 * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or
	 * closure will not work.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.removeEventListener("click", handleClick);
	 *
	 * @method removeEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.removeEventListener = function(type, listener, useCapture) {
		var listeners = useCapture ? this._captureListeners : this._listeners;
		if (!listeners) { return; }
		var arr = listeners[type];
		if (!arr) { return; }
		for (var i=0,l=arr.length; i<l; i++) {
			if (arr[i] == listener) {
				if (l==1) { delete(listeners[type]); } // allows for faster checks.
				else { arr.splice(i,1); }
				break;
			}
		}
	};
	
	/**
	 * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the
	 * .on method.
	 *
	 * @method off
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.off = p.removeEventListener;

	/**
	 * Removes all listeners for the specified type, or all listeners of all types.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Remove all listeners
	 *      displayObject.removeAllEventListeners();
	 *
	 *      // Remove all click listeners
	 *      displayObject.removeAllEventListeners("click");
	 *
	 * @method removeAllEventListeners
	 * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.
	 **/
	p.removeAllEventListeners = function(type) {
		if (!type) { this._listeners = this._captureListeners = null; }
		else {
			if (this._listeners) { delete(this._listeners[type]); }
			if (this._captureListeners) { delete(this._captureListeners[type]); }
		}
	};

	/**
	 * Dispatches the specified event to all listeners.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Use a string event
	 *      this.dispatchEvent("complete");
	 *
	 *      // Use an Event instance
	 *      var event = new createjs.Event("progress");
	 *      this.dispatchEvent(event);
	 *
	 * @method dispatchEvent
	 * @param {Object | String | Event} eventObj An object with a "type" property, or a string type.
	 * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,
	 * dispatchEvent will construct an Event instance with the specified type.
	 * @return {Boolean} Returns the value of eventObj.defaultPrevented.
	 **/
	p.dispatchEvent = function(eventObj) {
		if (typeof eventObj == "string") {
			// won't bubble, so skip everything if there's no listeners:
			var listeners = this._listeners;
			if (!listeners || !listeners[eventObj]) { return false; }
			eventObj = new createjs.Event(eventObj);
		} else if (eventObj.target && eventObj.clone) {
			// redispatching an active event object, so clone it:
			eventObj = eventObj.clone();
		}
		try { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events

		if (!eventObj.bubbles || !this.parent) {
			this._dispatchEvent(eventObj, 2);
		} else {
			var top=this, list=[top];
			while (top.parent) { list.push(top = top.parent); }
			var i, l=list.length;

			// capture & atTarget
			for (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {
				list[i]._dispatchEvent(eventObj, 1+(i==0));
			}
			// bubbling
			for (i=1; i<l && !eventObj.propagationStopped; i++) {
				list[i]._dispatchEvent(eventObj, 3);
			}
		}
		return eventObj.defaultPrevented;
	};

	/**
	 * Indicates whether there is at least one listener for the specified event type.
	 * @method hasEventListener
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns true if there is at least one listener for the specified event.
	 **/
	p.hasEventListener = function(type) {
		var listeners = this._listeners, captureListeners = this._captureListeners;
		return !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));
	};
	
	/**
	 * Indicates whether there is at least one listener for the specified event type on this object or any of its
	 * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the
	 * specified type is dispatched from this object, it will trigger at least one listener.
	 * 
	 * This is similar to {{#crossLink "EventDispatcher/hasEventListener"}}{{/crossLink}}, but it searches the entire
	 * event flow for a listener, not just this object.
	 * @method willTrigger
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns `true` if there is at least one listener for the specified event.
	 **/
	p.willTrigger = function(type) {
		var o = this;
		while (o) {
			if (o.hasEventListener(type)) { return true; }
			o = o.parent;
		}
		return false;
	};

	/**
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[EventDispatcher]";
	};


// private methods:
	/**
	 * @method _dispatchEvent
	 * @param {Object | String | Event} eventObj
	 * @param {Object} eventPhase
	 * @protected
	 **/
	p._dispatchEvent = function(eventObj, eventPhase) {
		var l, listeners = (eventPhase==1) ? this._captureListeners : this._listeners;
		if (eventObj && listeners) {
			var arr = listeners[eventObj.type];
			if (!arr||!(l=arr.length)) { return; }
			try { eventObj.currentTarget = this; } catch (e) {}
			try { eventObj.eventPhase = eventPhase; } catch (e) {}
			eventObj.removed = false;
			
			arr = arr.slice(); // to avoid issues with items being removed or added during the dispatch
			for (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {
				var o = arr[i];
				if (o.handleEvent) { o.handleEvent(eventObj); }
				else { o(eventObj); }
				if (eventObj.removed) {
					this.off(eventObj.type, o, eventPhase==1);
					eventObj.removed = false;
				}
			}
		}
	};


	createjs.EventDispatcher = EventDispatcher;
}());

//##############################################################################
// ProgressEvent.js
//##############################################################################

this.createjs = this.createjs || {};

(function (scope) {
	"use strict";

	// constructor
	/**
	 * A CreateJS {{#crossLink "Event"}}{{/crossLink}} that is dispatched when progress changes.
	 * @class ProgressEvent
	 * @param {Number} loaded The amount that has been loaded. This can be any number relative to the total.
	 * @param {Number} [total=1] The total amount that will load. This will default to 1, so if the `loaded` value is
	 * a percentage (between 0 and 1), it can be omitted.
	 * @todo Consider having this event be a "fileprogress" event as well
	 * @constructor
	 */
	function ProgressEvent(loaded, total) {
		this.Event_constructor("progress");

		/**
		 * The amount that has been loaded (out of a total amount)
		 * @property loaded
		 * @type {Number}
		 */
		this.loaded = loaded;

		/**
		 * The total "size" of the load.
		 * @property total
		 * @type {Number}
		 * @default 1
		 */
		this.total = (total == null) ? 1 : total;

		/**
		 * The percentage (out of 1) that the load has been completed. This is calculated using `loaded/total`.
		 * @property progress
		 * @type {Number}
		 * @default 0
		 */
		this.progress = (total == 0) ? 0 : this.loaded / this.total;
	};

	var p = createjs.extend(ProgressEvent, createjs.Event);

	/**
	 * Returns a clone of the ProgressEvent instance.
	 * @method clone
	 * @return {ProgressEvent} a clone of the Event instance.
	 **/
	p.clone = function() {
		return new createjs.ProgressEvent(this.loaded, this.total);
	};

	createjs.ProgressEvent = createjs.promote(ProgressEvent, "Event");

}(window));

//##############################################################################
// json3.js
//##############################################################################

/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

//##############################################################################
// DomUtils.js
//##############################################################################

(function () {

	/**
	 * A few utilities for interacting with the dom.
	 * @class DomUtils
	 */
	var s = {};

	s.appendToHead = function (el) {
		s.getHead().appendChild(el)
	}

	s.getHead = function () {
		return document.head || document.getElementsByTagName("head")[0];
	}

	s.getBody = function () {
		return document.body || document.getElementsByTagName("body")[0];
	}

	createjs.DomUtils = s;

}());

//##############################################################################
// DataUtils.js
//##############################################################################

(function () {

	/**
	 * A few data utilities for formatting different data types.
	 * @class DataUtils
	 */
	var s = {};

	// static methods
	/**
	 * Parse XML using the DOM. This is required when preloading XML or SVG.
	 * @method parseXML
	 * @param {String} text The raw text or XML that is loaded by XHR.
	 * @param {String} type The mime type of the XML. Use "text/xml" for XML, and  "image/svg+xml" for SVG parsing.
	 * @return {XML} An XML document
	 * @static
	 */
	s.parseXML = function (text, type) {
		var xml = null;
		// CocoonJS does not support XML parsing with either method.

		// Most browsers will use DOMParser
		// IE fails on certain SVG files, so we have a fallback below.
		try {
			if (window.DOMParser) {
				var parser = new DOMParser();
				xml = parser.parseFromString(text, type);
			}
		} catch (e) {
		}

		// Fallback for IE support.
		if (!xml) {
			try {
				xml = new ActiveXObject("Microsoft.XMLDOM");
				xml.async = false;
				xml.loadXML(text);
			} catch (e) {
				xml = null;
			}
		}

		return xml;
	};

	/**
	 * Parse a string into an Object.
	 * @method parseJSON
	 * @param {String} value The loaded JSON string
	 * @returns {Object} A JavaScript object.
	 */
	s.parseJSON = function (value) {
		if (value == null) {
			return null;
		}

		try {
			return JSON.parse(value);
		} catch (e) {
			// TODO; Handle this with a custom error?
			throw e;
		}
	};

	createjs.DataUtils = s;

}());

//##############################################################################
// LoadItem.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	/**
	 * All loaders accept an item containing the properties defined in this class. If a raw object is passed instead,
	 * it will not be affected, but it must contain at least a {{#crossLink "src:property"}}{{/crossLink}} property. A
	 * string path or HTML tag is also acceptable, but it will be automatically converted to a LoadItem using the
	 * {{#crossLink "create"}}{{/crossLink}} method by {{#crossLink "AbstractLoader"}}{{/crossLink}}
	 * @class LoadItem
	 * @constructor
	 * @since 0.6.0
	 */
	function LoadItem() {
		/**
		 * The source of the file that is being loaded. This property is <b>required</b>. The source can either be a
		 * string (recommended), or an HTML tag.
		 * This can also be an object, but in that case it has to include a type and be handled by a plugin.
		 * @property src
		 * @type {String}
		 * @default null
		 */
		this.src = null;

		/**
		 * The type file that is being loaded. The type of the file is usually inferred by the extension, but can also
		 * be set manually. This is helpful in cases where a file does not have an extension.
		 * @property type
		 * @type {String}
		 * @default null
		 */
		this.type = null;

		/**
		 * A string identifier which can be used to reference the loaded object. If none is provided, this will be
		 * automatically set to the {{#crossLink "src:property"}}{{/crossLink}}.
		 * @property id
		 * @type {String}
		 * @default null
		 */
		this.id = null;

		/**
		 * Determines if a manifest will maintain the order of this item, in relation to other items in the manifest
		 * that have also set the `maintainOrder` property to `true`. This only applies when the max connections has
		 * been set above 1 (using {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}). Everything with this
		 * property set to `false` will finish as it is loaded. Ordered items are combined with script tags loading in
		 * order when {{#crossLink "LoadQueue/maintainScriptOrder:property"}}{{/crossLink}} is set to `true`.
		 * @property maintainOrder
		 * @type {Boolean}
		 * @default false
		 */
		this.maintainOrder = false;

		/**
		 * A callback used by JSONP requests that defines what global method to call when the JSONP content is loaded.
		 * @property callback
		 * @type {String}
		 * @default null
		 */
		this.callback = null;

		/**
		 * An arbitrary data object, which is included with the loaded object.
		 * @property data
		 * @type {Object}
		 * @default null
		 */
		this.data = null;

		/**
		 * The request method used for HTTP calls. Both {{#crossLink "AbstractLoader/GET:property"}}{{/crossLink}} or
		 * {{#crossLink "AbstractLoader/POST:property"}}{{/crossLink}} request types are supported, and are defined as
		 * constants on {{#crossLink "AbstractLoader"}}{{/crossLink}}.
		 * @property method
		 * @type {String}
		 * @default get
		 */
		this.method = createjs.LoadItem.GET;

		/**
		 * An object hash of name/value pairs to send to the server.
		 * @property values
		 * @type {Object}
		 * @default null
		 */
		this.values = null;

		/**
		 * An object hash of headers to attach to an XHR request. PreloadJS will automatically attach some default
		 * headers when required, including "Origin", "Content-Type", and "X-Requested-With". You may override the
		 * default headers by including them in your headers object.
		 * @property headers
		 * @type {Object}
		 * @default null
		 */
		this.headers = null;

		/**
		 * Enable credentials for XHR requests.
		 * @property withCredentials
		 * @type {Boolean}
		 * @default false
		 */
		this.withCredentials = false;

		/**
		 * Set the mime type of XHR-based requests. This is automatically set to "text/plain; charset=utf-8" for text
		 * based files (json, xml, text, css, js).
		 * @property mimeType
		 * @type {String}
		 * @default null
		 */
		this.mimeType = null;

		/**
		 * Sets the crossOrigin attribute for CORS-enabled images loading cross-domain.
		 * @property crossOrigin
		 * @type {boolean}
		 * @default Anonymous
		 */
		this.crossOrigin = null;

		/**
		 * The duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR
		 * (level one) loading, as XHR (level 2) provides its own timeout event.
		 * @property loadTimeout
		 * @type {Number}
		 * @default 8000 (8 seconds)
		 */
		this.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;
	};

	var p = LoadItem.prototype = {};
	var s = LoadItem;

	/**
	 * Default duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR
	 * (level one) loading, as XHR (level 2) provides its own timeout event.
	 * @property LOAD_TIMEOUT_DEFAULT
	 * @type {number}
	 * @static
	 */
	s.LOAD_TIMEOUT_DEFAULT = 8000;

	/**
	 * Create a LoadItem.
	 * <ul>
	 *     <li>String-based items are converted to a LoadItem with a populated {{#crossLink "src:property"}}{{/crossLink}}.</li>
	 *     <li>LoadItem instances are returned as-is</li>
	 *     <li>Objects are returned with any needed properties added</li>
	 * </ul>
	 * @method create
	 * @param {LoadItem|String|Object} value The load item value
	 * @returns {LoadItem|Object}
	 * @static
	 */
	s.create = function (value) {
		if (typeof value == "string") {
			var item = new LoadItem();
			item.src = value;
			return item;
		} else if (value instanceof s) {
			return value;
		} else if (value instanceof Object && value.src) {
			if (value.loadTimeout == null) {
				value.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;
			}
			return value;
		} else {
			throw new Error("Type not recognized.");
		}
	};

	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * <h4>Example</h4>
	 *
	 *      var loadItem = new createjs.LoadItem().set({src:"image.png", maintainOrder:true});
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the LoadItem instance.
	 * @return {LoadItem} Returns the instance the method is called on (useful for chaining calls.)
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};

	createjs.LoadItem = s;

}());

//##############################################################################
// RequestUtils.js
//##############################################################################

(function () {

	/**
	 * Utilities that assist with parsing load items, and determining file types, etc.
	 * @class RequestUtils
	 */
	var s = {};

	/**
	 * The Regular Expression used to test file URLS for an absolute path.
	 * @property ABSOLUTE_PATH
	 * @type {RegExp}
	 * @static
	 */
	s.ABSOLUTE_PATT = /^(?:\w+:)?\/{2}/i;

	/**
	 * The Regular Expression used to test file URLS for a relative path.
	 * @property RELATIVE_PATH
	 * @type {RegExp}
	 * @static
	 */
	s.RELATIVE_PATT = (/^[./]*?\//i);

	/**
	 * The Regular Expression used to test file URLS for an extension. Note that URIs must already have the query string
	 * removed.
	 * @property EXTENSION_PATT
	 * @type {RegExp}
	 * @static
	 */
	s.EXTENSION_PATT = /\/?[^/]+\.(\w{1,5})$/i;

	/**
	 * Parse a file path to determine the information we need to work with it. Currently, PreloadJS needs to know:
	 * <ul>
	 *     <li>If the path is absolute. Absolute paths start with a protocol (such as `http://`, `file://`, or
	 *     `//networkPath`)</li>
	 *     <li>If the path is relative. Relative paths start with `../` or `/path` (or similar)</li>
	 *     <li>The file extension. This is determined by the filename with an extension. Query strings are dropped, and
	 *     the file path is expected to follow the format `name.ext`.</li>
	 * </ul>
	 * @method parseURI
	 * @param {String} path
	 * @returns {Object} An Object with an `absolute` and `relative` Boolean values, as well as an optional 'extension`
	 * property, which is the lowercase extension.
	 * @static
	 */
	s.parseURI = function (path) {
		var info = {absolute: false, relative: false};
		if (path == null) { return info; }

		// Drop the query string
		var queryIndex = path.indexOf("?");
		if (queryIndex > -1) {
			path = path.substr(0, queryIndex);
		}

		// Absolute
		var match;
		if (s.ABSOLUTE_PATT.test(path)) {
			info.absolute = true;

			// Relative
		} else if (s.RELATIVE_PATT.test(path)) {
			info.relative = true;
		}

		// Extension
		if (match = path.match(s.EXTENSION_PATT)) {
			info.extension = match[1].toLowerCase();
		}
		return info;
	};

	/**
	 * Formats an object into a query string for either a POST or GET request.
	 * @method formatQueryString
	 * @param {Object} data The data to convert to a query string.
	 * @param {Array} [query] Existing name/value pairs to append on to this query.
	 * @static
	 */
	s.formatQueryString = function (data, query) {
		if (data == null) {
			throw new Error('You must specify data.');
		}
		var params = [];
		for (var n in data) {
			params.push(n + '=' + escape(data[n]));
		}
		if (query) {
			params = params.concat(query);
		}
		return params.join('&');
	};

	/**
	 * A utility method that builds a file path using a source and a data object, and formats it into a new path.
	 * @method buildPath
	 * @param {String} src The source path to add values to.
	 * @param {Object} [data] Object used to append values to this request as a query string. Existing parameters on the
	 * path will be preserved.
	 * @returns {string} A formatted string that contains the path and the supplied parameters.
	 * @static
	 */
	s.buildPath = function (src, data) {
		if (data == null) {
			return src;
		}

		var query = [];
		var idx = src.indexOf('?');

		if (idx != -1) {
			var q = src.slice(idx + 1);
			query = query.concat(q.split('&'));
		}

		if (idx != -1) {
			return src.slice(0, idx) + '?' + this._formatQueryString(data, query);
		} else {
			return src + '?' + this._formatQueryString(data, query);
		}
	};

	/**
	 * @method isCrossDomain
	 * @param {LoadItem|Object} item A load item with a `src` property.
	 * @return {Boolean} If the load item is loading from a different domain than the current location.
	 * @static
	 */
	s.isCrossDomain = function (item) {
		var target = document.createElement("a");
		target.href = item.src;

		var host = document.createElement("a");
		host.href = location.href;

		var crossdomain = (target.hostname != "") &&
						  (target.port != host.port ||
						   target.protocol != host.protocol ||
						   target.hostname != host.hostname);
		return crossdomain;
	};

	/**
	 * @method isLocal
	 * @param {LoadItem|Object} item A load item with a `src` property
	 * @return {Boolean} If the load item is loading from the "file:" protocol. Assume that the host must be local as
	 * well.
	 * @static
	 */
	s.isLocal = function (item) {
		var target = document.createElement("a");
		target.href = item.src;
		return target.hostname == "" && target.protocol == "file:";
	};

	/**
	 * Determine if a specific type should be loaded as a binary file. Currently, only images and items marked
	 * specifically as "binary" are loaded as binary. Note that audio is <b>not</b> a binary type, as we can not play
	 * back using an audio tag if it is loaded as binary. Plugins can change the item type to binary to ensure they get
	 * a binary result to work with. Binary files are loaded using XHR2. Types are defined as static constants on
	 * {{#crossLink "AbstractLoader"}}{{/crossLink}}.
	 * @method isBinary
	 * @param {String} type The item type.
	 * @return {Boolean} If the specified type is binary.
	 * @static
	 */
	s.isBinary = function (type) {
		switch (type) {
			case createjs.AbstractLoader.IMAGE:
			case createjs.AbstractLoader.BINARY:
				return true;
			default:
				return false;
		}
	};

	/**
	 * Check if item is a valid HTMLImageElement
	 * @method isImageTag
	 * @param {Object} item
	 * @returns {Boolean}
	 * @static
	 */
	s.isImageTag = function(item) {
		return item instanceof HTMLImageElement;
	};

	/**
	 * Check if item is a valid HTMLAudioElement
	 * @method isAudioTag
	 * @param {Object} item
	 * @returns {Boolean}
	 * @static
	 */
	s.isAudioTag = function(item) {
		if (window.HTMLAudioElement) {
			return item instanceof HTMLAudioElement;
		} else {
			return false;
		}
	};

	/**
	 * Check if item is a valid HTMLVideoElement
	 * @method isVideoTag
	 * @param {Object} item
	 * @returns {Boolean}
	 * @static
	 */
	s.isVideoTag = function(item) {
		if (window.HTMLVideoElement) {
			return item instanceof HTMLVideoElement;
		} else {
			return false;
		}
	};

	/**
	 * Determine if a specific type is a text-based asset, and should be loaded as UTF-8.
	 * @method isText
	 * @param {String} type The item type.
	 * @return {Boolean} If the specified type is text.
	 * @static
	 */
	s.isText = function (type) {
		switch (type) {
			case createjs.AbstractLoader.TEXT:
			case createjs.AbstractLoader.JSON:
			case createjs.AbstractLoader.MANIFEST:
			case createjs.AbstractLoader.XML:
			case createjs.AbstractLoader.CSS:
			case createjs.AbstractLoader.SVG:
			case createjs.AbstractLoader.JAVASCRIPT:
			case createjs.AbstractLoader.SPRITESHEET:
				return true;
			default:
				return false;
		}
	};

	/**
	 * Determine the type of the object using common extensions. Note that the type can be passed in with the load item
	 * if it is an unusual extension.
	 * @method getTypeByExtension
	 * @param {String} extension The file extension to use to determine the load type.
	 * @return {String} The determined load type (for example, <code>AbstractLoader.IMAGE</code>). Will return `null` if
	 * the type can not be determined by the extension.
	 * @static
	 */
	s.getTypeByExtension = function (extension) {
		if (extension == null) {
			return createjs.AbstractLoader.TEXT;
		}

		switch (extension.toLowerCase()) {
			case "jpeg":
			case "jpg":
			case "gif":
			case "png":
			case "webp":
			case "bmp":
				return createjs.AbstractLoader.IMAGE;
			case "ogg":
			case "mp3":
			case "webm":
				return createjs.AbstractLoader.SOUND;
			case "mp4":
			case "webm":
			case "ts":
				return createjs.AbstractLoader.VIDEO;
			case "json":
				return createjs.AbstractLoader.JSON;
			case "xml":
				return createjs.AbstractLoader.XML;
			case "css":
				return createjs.AbstractLoader.CSS;
			case "js":
				return createjs.AbstractLoader.JAVASCRIPT;
			case 'svg':
				return createjs.AbstractLoader.SVG;
			default:
				return createjs.AbstractLoader.TEXT;
		}
	};

	createjs.RequestUtils = s;

}());

//##############################################################################
// AbstractLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

// constructor
	/**
	 * The base loader, which defines all the generic methods, properties, and events. All loaders extend this class,
	 * including the {{#crossLink "LoadQueue"}}{{/crossLink}}.
	 * @class AbstractLoader
	 * @param {LoadItem|object|string} loadItem The item to be loaded.
	 * @param {Boolean} [preferXHR] Determines if the LoadItem should <em>try</em> and load using XHR, or take a
	 * tag-based approach, which can be better in cross-domain situations. Not all loaders can load using one or the
	 * other, so this is a suggested directive.
	 * @param {String} [type] The type of loader. Loader types are defined as constants on the AbstractLoader class,
	 * such as {{#crossLink "IMAGE:property"}}{{/crossLink}}, {{#crossLink "CSS:property"}}{{/crossLink}}, etc.
	 * @extends EventDispatcher
	 */
	function AbstractLoader(loadItem, preferXHR, type) {
		this.EventDispatcher_constructor();

		// public properties
		/**
		 * If the loader has completed loading. This provides a quick check, but also ensures that the different approaches
		 * used for loading do not pile up resulting in more than one `complete` {{#crossLink "Event"}}{{/crossLink}}.
		 * @property loaded
		 * @type {Boolean}
		 * @default false
		 */
		this.loaded = false;

		/**
		 * Determine if the loader was canceled. Canceled loads will not fire complete events. Note that this property
		 * is readonly, so {{#crossLink "LoadQueue"}}{{/crossLink}} queues should be closed using {{#crossLink "LoadQueue/close"}}{{/crossLink}}
		 * instead.
		 * @property canceled
		 * @type {Boolean}
		 * @default false
		 * @readonly
		 */
		this.canceled = false;

		/**
		 * The current load progress (percentage) for this item. This will be a number between 0 and 1.
		 *
		 * <h4>Example</h4>
		 *
		 *     var queue = new createjs.LoadQueue();
		 *     queue.loadFile("largeImage.png");
		 *     queue.on("progress", function() {
		 *         console.log("Progress:", queue.progress, event.progress);
		 *     });
		 *
		 * @property progress
		 * @type {Number}
		 * @default 0
		 */
		this.progress = 0;

		/**
		 * The type of item this loader will load. See {{#crossLink "AbstractLoader"}}{{/crossLink}} for a full list of
		 * supported types.
		 * @property type
		 * @type {String}
		 */
		this.type = type;

		/**
		 * A formatter function that converts the loaded raw result into the final result. For example, the JSONLoader
		 * converts a string of text into a JavaScript object. Not all loaders have a resultFormatter, and this property
		 * can be overridden to provide custom formatting.
		 *
		 * Optionally, a resultFormatter can return a callback function in cases where the formatting needs to be
		 * asynchronous, such as creating a new image.
		 * @property resultFormatter
		 * @type {Function}
		 * @default null
		 */
		this.resultFormatter = null;

		// protected properties
		/**
		 * The {{#crossLink "LoadItem"}}{{/crossLink}} this loader represents. Note that this is null in a {{#crossLink "LoadQueue"}}{{/crossLink}},
		 * but will be available on loaders such as {{#crossLink "XMLLoader"}}{{/crossLink}} and {{#crossLink "ImageLoader"}}{{/crossLink}}.
		 * @property _item
		 * @type {LoadItem|Object}
		 * @private
		 */
		if (loadItem) {
			this._item = createjs.LoadItem.create(loadItem);
		} else {
			this._item = null;
		}

		/**
		 * Whether the loader will try and load content using XHR (true) or HTML tags (false).
		 * @property _preferXHR
		 * @type {Boolean}
		 * @private
		 */
		this._preferXHR = preferXHR;

		/**
		 * The loaded result after it is formatted by an optional {{#crossLink "resultFormatter"}}{{/crossLink}}. For
		 * items that are not formatted, this will be the same as the {{#crossLink "_rawResult:property"}}{{/crossLink}}.
		 * The result is accessed using the {{#crossLink "getResult"}}{{/crossLink}} method.
		 * @property _result
		 * @type {Object|String}
		 * @private
		 */
		this._result = null;

		/**
		 * The loaded result before it is formatted. The rawResult is accessed using the {{#crossLink "getResult"}}{{/crossLink}}
		 * method, and passing `true`.
		 * @property _rawResult
		 * @type {Object|String}
		 * @private
		 */
		this._rawResult = null;

		/**
		 * A list of items that loaders load behind the scenes. This does not include the main item the loader is
		 * responsible for loading. Examples of loaders that have sub-items include the {{#crossLink "SpriteSheetLoader"}}{{/crossLink}} and
		 * {{#crossLink "ManifestLoader"}}{{/crossLink}}.
		 * @property _loadItems
		 * @type {null}
		 * @protected
		 */
		this._loadedItems = null;

		/**
		 * The attribute the items loaded using tags use for the source.
		 * @type {string}
		 * @default null
		 * @private
		 */
		this._tagSrcAttribute = null;

		/**
		 * An HTML tag (or similar) that a loader may use to load HTML content, such as images, scripts, etc.
		 * @property _tag
		 * @type {Object}
		 * @private
		 */
		this._tag = null;
	};

	var p = createjs.extend(AbstractLoader, createjs.EventDispatcher);
	var s = AbstractLoader;

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


	/**
	 * Defines a POST request, use for a method value when loading data.
	 * @property POST
	 * @type {string}
	 * @default post
	 * @static
	 */
	s.POST = "POST";

	/**
	 * Defines a GET request, use for a method value when loading data.
	 * @property GET
	 * @type {string}
	 * @default get
	 * @static
	 */
	s.GET = "GET";

	/**
	 * The preload type for generic binary types. Note that images are loaded as binary files when using XHR.
	 * @property BINARY
	 * @type {String}
	 * @default binary
	 * @static
	 * @since 0.6.0
	 */
	s.BINARY = "binary";

	/**
	 * The preload type for css files. CSS files are loaded using a &lt;link&gt; when loaded with XHR, or a
	 * &lt;style&gt; tag when loaded with tags.
	 * @property CSS
	 * @type {String}
	 * @default css
	 * @static
	 * @since 0.6.0
	 */
	s.CSS = "css";

	/**
	 * The preload type for image files, usually png, gif, or jpg/jpeg. Images are loaded into an &lt;image&gt; tag.
	 * @property IMAGE
	 * @type {String}
	 * @default image
	 * @static
	 * @since 0.6.0
	 */
	s.IMAGE = "image";

	/**
	 * The preload type for javascript files, usually with the "js" file extension. JavaScript files are loaded into a
	 * &lt;script&gt; tag.
	 *
	 * Since version 0.4.1+, due to how tag-loaded scripts work, all JavaScript files are automatically injected into
	 * the body of the document to maintain parity between XHR and tag-loaded scripts. In version 0.4.0 and earlier,
	 * only tag-loaded scripts are injected.
	 * @property JAVASCRIPT
	 * @type {String}
	 * @default javascript
	 * @static
	 * @since 0.6.0
	 */
	s.JAVASCRIPT = "javascript";

	/**
	 * The preload type for json files, usually with the "json" file extension. JSON data is loaded and parsed into a
	 * JavaScript object. Note that if a `callback` is present on the load item, the file will be loaded with JSONP,
	 * no matter what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}} property is set to, and the JSON
	 * must contain a matching wrapper function.
	 * @property JSON
	 * @type {String}
	 * @default json
	 * @static
	 * @since 0.6.0
	 */
	s.JSON = "json";

	/**
	 * The preload type for jsonp files, usually with the "json" file extension. JSON data is loaded and parsed into a
	 * JavaScript object. You are required to pass a callback parameter that matches the function wrapper in the JSON.
	 * Note that JSONP will always be used if there is a callback present, no matter what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}}
	 * property is set to.
	 * @property JSONP
	 * @type {String}
	 * @default jsonp
	 * @static
	 * @since 0.6.0
	 */
	s.JSONP = "jsonp";

	/**
	 * The preload type for json-based manifest files, usually with the "json" file extension. The JSON data is loaded
	 * and parsed into a JavaScript object. PreloadJS will then look for a "manifest" property in the JSON, which is an
	 * Array of files to load, following the same format as the {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}
	 * method. If a "callback" is specified on the manifest object, then it will be loaded using JSONP instead,
	 * regardless of what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}} property is set to.
	 * @property MANIFEST
	 * @type {String}
	 * @default manifest
	 * @static
	 * @since 0.6.0
	 */
	s.MANIFEST = "manifest";

	/**
	 * The preload type for sound files, usually mp3, ogg, or wav. When loading via tags, audio is loaded into an
	 * &lt;audio&gt; tag.
	 * @property SOUND
	 * @type {String}
	 * @default sound
	 * @static
	 * @since 0.6.0
	 */
	s.SOUND = "sound";

	/**
	 * The preload type for video files, usually mp4, ts, or ogg. When loading via tags, video is loaded into an
	 * &lt;video&gt; tag.
	 * @property VIDEO
	 * @type {String}
	 * @default video
	 * @static
	 * @since 0.6.0
	 */
	s.VIDEO = "video";

	/**
	 * The preload type for SpriteSheet files. SpriteSheet files are JSON files that contain string image paths.
	 * @property SPRITESHEET
	 * @type {String}
	 * @default spritesheet
	 * @static
	 * @since 0.6.0
	 */
	s.SPRITESHEET = "spritesheet";

	/**
	 * The preload type for SVG files.
	 * @property SVG
	 * @type {String}
	 * @default svg
	 * @static
	 * @since 0.6.0
	 */
	s.SVG = "svg";

	/**
	 * The preload type for text files, which is also the default file type if the type can not be determined. Text is
	 * loaded as raw text.
	 * @property TEXT
	 * @type {String}
	 * @default text
	 * @static
	 * @since 0.6.0
	 */
	s.TEXT = "text";

	/**
	 * The preload type for xml files. XML is loaded into an XML document.
	 * @property XML
	 * @type {String}
	 * @default xml
	 * @static
	 * @since 0.6.0
	 */
	s.XML = "xml";

// Events
	/**
	 * The {{#crossLink "ProgressEvent"}}{{/crossLink}} that is fired when the overall progress changes. Prior to
	 * version 0.6.0, this was just a regular {{#crossLink "Event"}}{{/crossLink}}.
	 * @event progress
	 * @since 0.3.0
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when a load starts.
	 * @event loadstart
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @since 0.3.1
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when the entire queue has been loaded.
	 * @event complete
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @since 0.3.0
	 */

	/**
	 * The {{#crossLink "ErrorEvent"}}{{/crossLink}} that is fired when the loader encounters an error. If the error was
	 * encountered by a file, the event will contain the item that caused the error. Prior to version 0.6.0, this was
	 * just a regular {{#crossLink "Event"}}{{/crossLink}}.
	 * @event error
	 * @since 0.3.0
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when the loader encounters an internal file load error.
	 * This enables loaders to maintain internal queues, and surface file load errors.
	 * @event fileerror
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The even type ("fileerror")
	 * @param {LoadItem|object} The item that encountered the error
	 * @since 0.6.0
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when a loader internally loads a file. This enables
	 * loaders such as {{#crossLink "ManifestLoader"}}{{/crossLink}} to maintain internal {{#crossLink "LoadQueue"}}{{/crossLink}}s
	 * and notify when they have loaded a file. The {{#crossLink "LoadQueue"}}{{/crossLink}} class dispatches a
	 * slightly different {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event.
	 * @event fileload
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type ("fileload")
	 * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a `src` property.
	 * @param {Object} result The HTML tag or parsed result of the loaded item.
	 * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted
	 * to a usable object.
	 * @since 0.6.0
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired after the internal request is created, but before a load.
	 * This allows updates to the loader for specific loading needs, such as binary or XHR image loading.
	 * @event initialize
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type ("initialize")
	 * @param {AbstractLoader} loader The loader that has been initialized.
	 */


	/**
	 * Get a reference to the manifest item that is loaded by this loader. In some cases this will be the value that was
	 * passed into {{#crossLink "LoadQueue"}}{{/crossLink}} using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or
	 * {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. However if only a String path was passed in, then it will
	 * be a {{#crossLink "LoadItem"}}{{/crossLink}}.
	 * @method getItem
	 * @return {Object} The manifest item that this loader is responsible for loading.
	 * @since 0.6.0
	 */
	p.getItem = function () {
		return this._item;
	};

	/**
	 * Get a reference to the content that was loaded by the loader (only available after the {{#crossLink "complete:event"}}{{/crossLink}}
	 * event is dispatched.
	 * @method getResult
	 * @param {Boolean} [raw=false] Determines if the returned result will be the formatted content, or the raw loaded
	 * data (if it exists).
	 * @return {Object}
	 * @since 0.6.0
	 */
	p.getResult = function (raw) {
		return raw ? this._rawResult : this._result;
	};

	/**
	 * Return the `tag` this object creates or uses for loading.
	 * @method getTag
	 * @return {Object} The tag instance
	 * @since 0.6.0
	 */
	p.getTag = function () {
		return this._tag;
	};

	/**
	 * Set the `tag` this item uses for loading.
	 * @method setTag
	 * @param {Object} tag The tag instance
	 * @since 0.6.0
	 */
	p.setTag = function(tag) {
	  this._tag = tag;
	};

	/**
	 * Begin loading the item. This method is required when using a loader by itself.
	 *
	 * <h4>Example</h4>
	 *
	 *      var queue = new createjs.LoadQueue();
	 *      queue.on("complete", handleComplete);
	 *      queue.loadManifest(fileArray, false); // Note the 2nd argument that tells the queue not to start loading yet
	 *      queue.load();
	 *
	 * @method load
	 */
	p.load = function () {
		this._createRequest();

		this._request.on("complete", this, this);
		this._request.on("progress", this, this);
		this._request.on("loadStart", this, this);
		this._request.on("abort", this, this);
		this._request.on("timeout", this, this);
		this._request.on("error", this, this);

		var evt = new createjs.Event("initialize");
		evt.loader = this._request;
		this.dispatchEvent(evt);

		this._request.load();
	};

	/**
	 * Close the the item. This will stop any open requests (although downloads using HTML tags may still continue in
	 * the background), but events will not longer be dispatched.
	 * @method cancel
	 */
	p.cancel = function () {
		this.canceled = true;
		this.destroy();
	};

	/**
	 * Clean up the loader.
	 * @method destroy
	 */
	p.destroy = function() {
		if (this._request) {
			this._request.removeAllEventListeners();
			this._request.destroy();
		}

		this._request = null;

		this._item = null;
		this._rawResult = null;
		this._result = null;

		this._loadItems = null;

		this.removeAllEventListeners();
	};

	/**
	 * Get any items loaded internally by the loader. The enables loaders such as {{#crossLink "ManifestLoader"}}{{/crossLink}}
	 * to expose items it loads internally.
	 * @method getLoadedItems
	 * @return {Array} A list of the items loaded by the loader.
	 * @since 0.6.0
	 */
	p.getLoadedItems = function () {
		return this._loadedItems;
	};


	// Private methods
	/**
	 * Create an internal request used for loading. By default, an {{#crossLink "XHRRequest"}}{{/crossLink}} or
	 * {{#crossLink "TagRequest"}}{{/crossLink}} is created, depending on the value of {{#crossLink "preferXHR:property"}}{{/crossLink}}.
	 * Other loaders may override this to use different request types, such as {{#crossLink "ManifestLoader"}}{{/crossLink}},
	 * which uses {{#crossLink "JSONLoader"}}{{/crossLink}} or {{#crossLink "JSONPLoader"}}{{/crossLink}} under the hood.
	 * @method _createRequest
	 * @protected
	 */
	p._createRequest = function() {
		if (!this._preferXHR) {
			this._request = new createjs.TagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);
		} else {
			this._request = new createjs.XHRRequest(this._item);
		}
	};

	/**
	 * Create the HTML tag used for loading. This method does nothing by default, and needs to be implemented
	 * by loaders that require tag loading.
	 * @method _createTag
	 * @param {String} src The tag source
	 * @return {HTMLElement} The tag that was created
	 * @protected
	 */
	p._createTag = function(src) { return null; };

	/**
	 * Dispatch a loadstart {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/loadstart:event"}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendLoadStart
	 * @protected
	 */
	p._sendLoadStart = function () {
		if (this._isCanceled()) { return; }
		this.dispatchEvent("loadstart");
	};

	/**
	 * Dispatch a {{#crossLink "ProgressEvent"}}{{/crossLink}}.
	 * @method _sendProgress
	 * @param {Number | Object} value The progress of the loaded item, or an object containing <code>loaded</code>
	 * and <code>total</code> properties.
	 * @protected
	 */
	p._sendProgress = function (value) {
		if (this._isCanceled()) { return; }
		var event = null;
		if (typeof(value) == "number") {
			this.progress = value;
			event = new createjs.ProgressEvent(this.progress);
		} else {
			event = value;
			this.progress = value.loaded / value.total;
			event.progress = this.progress;
			if (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }
		}
		this.hasEventListener("progress") && this.dispatchEvent(event);
	};

	/**
	 * Dispatch a complete {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}} event
	 * @method _sendComplete
	 * @protected
	 */
	p._sendComplete = function () {
		if (this._isCanceled()) { return; }

		this.loaded = true;

		var event = new createjs.Event("complete");
		event.rawResult = this._rawResult;

		if (this._result != null) {
			event.result = this._result;
		}

		this.dispatchEvent(event);
	};

	/**
	 * Dispatch an error {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendError
	 * @param {ErrorEvent} event The event object containing specific error properties.
	 * @protected
	 */
	p._sendError = function (event) {
		if (this._isCanceled() || !this.hasEventListener("error")) { return; }
		if (event == null) {
			event = new createjs.ErrorEvent("PRELOAD_ERROR_EMPTY"); // TODO: Populate error
		}
		this.dispatchEvent(event);
	};

	/**
	 * Determine if the load has been canceled. This is important to ensure that method calls or asynchronous events
	 * do not cause issues after the queue has been cleaned up.
	 * @method _isCanceled
	 * @return {Boolean} If the loader has been canceled.
	 * @protected
	 */
	p._isCanceled = function () {
		if (window.createjs == null || this.canceled) {
			return true;
		}
		return false;
	};

	/**
	 * A custom result formatter function, which is called just before a request dispatches its complete event. Most
	 * loader types already have an internal formatter, but this can be user-overridden for custom formatting. The
	 * formatted result will be available on Loaders using {{#crossLink "getResult"}}{{/crossLink}}, and passing `true`.
	 * @property resultFormatter
	 * @type Function
	 * @return {Object} The formatted result
	 * @since 0.6.0
	 */
	p.resultFormatter = null;

	/**
	 * Handle events from internal requests. By default, loaders will handle, and redispatch the necessary events, but
	 * this method can be overridden for custom behaviours.
	 * @method handleEvent
	 * @param {Event} event The event that the internal request dispatches.
	 * @protected
	 * @since 0.6.0
	 */
	p.handleEvent = function (event) {
		switch (event.type) {
			case "complete":
				this._rawResult = event.target._response;
				var result = this.resultFormatter && this.resultFormatter(this);
				var _this = this;
				if (result instanceof Function) {
					result(function(result) {
						_this._result = result;
						_this._sendComplete();
					});
				} else {
					this._result =  result || this._rawResult;
					this._sendComplete();
				}
				break;
			case "progress":
				this._sendProgress(event);
				break;
			case "error":
				this._sendError(event);
				break;
			case "loadstart":
				this._sendLoadStart();
				break;
			case "abort":
			case "timeout":
				if (!this._isCanceled()) {
					this.dispatchEvent(event.type);
				}
				break;
		}
	};

	/**
	 * @method buildPath
	 * @protected
	 * @deprecated Use the {{#crossLink "RequestUtils"}}{{/crossLink}} method {{#crossLink "RequestUtils/buildPath"}}{{/crossLink}}
	 * instead.
	 */
	p.buildPath = function (src, data) {
		return createjs.RequestUtils.buildPath(src, data);
	};

	/**
	 * @method toString
	 * @return {String} a string representation of the instance.
	 */
	p.toString = function () {
		return "[PreloadJS AbstractLoader]";
	};

	createjs.AbstractLoader = createjs.promote(AbstractLoader, "EventDispatcher");

}());

//##############################################################################
// AbstractMediaLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * The AbstractMediaLoader is a base class that handles some of the shared methods and properties of loaders that
	 * handle HTML media elements, such as Video and Audio.
	 * @class AbstractMediaLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @param {String} type The type of media to load. Usually "video" or "audio".
	 * @extends AbstractLoader
	 * @constructor
	 */
	function AbstractMediaLoader(loadItem, preferXHR, type) {
		this.AbstractLoader_constructor(loadItem, preferXHR, type);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = "src";
	};

	var p = createjs.extend(AbstractMediaLoader, createjs.AbstractLoader);

	// static properties
	// public methods
	p.load = function () {
		// TagRequest will handle most of this, but Sound / Video need a few custom properties, so just handle them here.
		if (!this._tag) {
			this._tag = this._createTag(this._item.src);
		}

		this._tag.preload = "auto";
		this._tag.load();

		this.AbstractLoader_load();
	};

	// protected methods
	/**
	 * Creates a new tag for loading if it doesn't exist yet.
	 * @method _createTag
	 * @private
	 */
	p._createTag = function () {};


	p._createRequest = function() {
		if (!this._preferXHR) {
			this._request = new createjs.MediaTagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);
		} else {
			this._request = new createjs.XHRRequest(this._item);
		}
	};

	/**
	 * The result formatter for media files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLVideoElement|HTMLAudioElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler);
		this._tag.onstalled = null;
		if (this._preferXHR) {
			loader.getTag().src = loader.getResult(true);
		}
		return loader.getTag();
	};

	createjs.AbstractMediaLoader = createjs.promote(AbstractMediaLoader, "AbstractLoader");

}());

//##############################################################################
// AbstractRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	/**
	 * A base class for actual data requests, such as {{#crossLink "XHRRequest"}}{{/crossLink}}, {{#crossLink "TagRequest"}}{{/crossLink}},
	 * and {{#crossLink "MediaRequest"}}{{/crossLink}}. PreloadJS loaders will typically use a data loader under the
	 * hood to get data.
	 * @class AbstractRequest
	 * @param {LoadItem} item
	 * @constructor
	 */
	var AbstractRequest = function (item) {
		this._item = item;
	};

	var p = createjs.extend(AbstractRequest, createjs.EventDispatcher);

	// public methods
	/**
	 * Begin a load.
	 * @method load
	 */
	p.load =  function() {};

	/**
	 * Clean up a request.
	 * @method destroy
	 */
	p.destroy = function() {};

	/**
	 * Cancel an in-progress request.
	 * @method cancel
	 */
	p.cancel = function() {};

	createjs.AbstractRequest = createjs.promote(AbstractRequest, "EventDispatcher");

}());

//##############################################################################
// TagRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * An {{#crossLink "AbstractRequest"}}{{/crossLink}} that loads HTML tags, such as images and scripts.
	 * @class TagRequest
	 * @param {LoadItem} loadItem
	 * @param {HTMLElement} tag
	 * @param {String} srcAttribute The tag attribute that specifies the source, such as "src", "href", etc.
	 */
	function TagRequest(loadItem, tag, srcAttribute) {
		this.AbstractRequest_constructor(loadItem);

		// protected properties
		/**
		 * The HTML tag instance that is used to load.
		 * @property _tag
		 * @type {HTMLElement}
		 * @protected
		 */
		this._tag = tag;

		/**
		 * The tag attribute that specifies the source, such as "src", "href", etc.
		 * @property _tagSrcAttribute
		 * @type {String}
		 * @protected
		 */
		this._tagSrcAttribute = srcAttribute;

		/**
		 * A method closure used for handling the tag load event.
		 * @property _loadedHandler
		 * @type {Function}
		 * @private
		 */
		this._loadedHandler = createjs.proxy(this._handleTagComplete, this);

		/**
		 * Determines if the element was added to the DOM automatically by PreloadJS, so it can be cleaned up after.
		 * @property _addedToDOM
		 * @type {Boolean}
		 * @private
		 */
		this._addedToDOM = false;

		/**
		 * Determines what the tags initial style.visibility was, so we can set it correctly after a load.
		 *
		 * @type {null}
		 * @private
		 */
		this._startTagVisibility = null;
	};

	var p = createjs.extend(TagRequest, createjs.AbstractRequest);

	// public methods
	p.load = function () {
		this._tag.onload = createjs.proxy(this._handleTagComplete, this);
		this._tag.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this);
		this._tag.onerror = createjs.proxy(this._handleError, this);

		var evt = new createjs.Event("initialize");
		evt.loader = this._tag;

		this.dispatchEvent(evt);

		this._hideTag();

		this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);

		this._tag[this._tagSrcAttribute] = this._item.src;

		// wdg:: Append the tag AFTER setting the src, or SVG loading on iOS will fail.
		if (this._tag.parentNode == null) {
			window.document.body.appendChild(this._tag);
			this._addedToDOM = true;
		}
	};

	p.destroy = function() {
		this._clean();
		this._tag = null;

		this.AbstractRequest_destroy();
	};

	// private methods
	/**
	 * Handle the readyStateChange event from a tag. We need this in place of the `onload` callback (mainly SCRIPT
	 * and LINK tags), but other cases may exist.
	 * @method _handleReadyStateChange
	 * @private
	 */
	p._handleReadyStateChange = function () {
		clearTimeout(this._loadTimeout);
		// This is strictly for tags in browsers that do not support onload.
		var tag = this._tag;

		// Complete is for old IE support.
		if (tag.readyState == "loaded" || tag.readyState == "complete") {
			this._handleTagComplete();
		}
	};

	/**
	 * Handle any error events from the tag.
	 * @method _handleError
	 * @protected
	 */
	p._handleError = function() {
		this._clean();
		this.dispatchEvent("error");
	};

	/**
	 * Handle the tag's onload callback.
	 * @method _handleTagComplete
	 * @private
	 */
	p._handleTagComplete = function () {
		this._rawResult = this._tag;
		this._result = this.resultFormatter && this.resultFormatter(this) || this._rawResult;

		this._clean();
		this._showTag();

		this.dispatchEvent("complete");
	};

	/**
	 * The tag request has not loaded within the time specified in loadTimeout.
	 * @method _handleError
	 * @param {Object} event The XHR error event.
	 * @private
	 */
	p._handleTimeout = function () {
		this._clean();
		this.dispatchEvent(new createjs.Event("timeout"));
	};

	/**
	 * Remove event listeners, but don't destroy the request object
	 * @method _clean
	 * @private
	 */
	p._clean = function() {
		this._tag.onload = null;
		this._tag.onreadystatechange = null;
		this._tag.onerror = null;
		if (this._addedToDOM && this._tag.parentNode != null) {
			this._tag.parentNode.removeChild(this._tag);
		}
		clearTimeout(this._loadTimeout);
	};

	p._hideTag = function() {
		this._startTagVisibility = this._tag.style.visibility;
		this._tag.style.visibility = "hidden";
	};

	p._showTag = function() {
		this._tag.style.visibility = this._startTagVisibility;
	};

	/**
	 * Handle a stalled audio event. The main place this happens is with HTMLAudio in Chrome when playing back audio
	 * that is already in a load, but not complete.
	 * @method _handleStalled
	 * @private
	 */
	p._handleStalled = function () {
		//Ignore, let the timeout take care of it. Sometimes its not really stopped.
	};

	createjs.TagRequest = createjs.promote(TagRequest, "AbstractRequest");

}());

//##############################################################################
// MediaTagRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * An {{#crossLink "TagRequest"}}{{/crossLink}} that loads HTML tags for video and audio.
	 * @class MediaTagRequest
	 * @param {LoadItem} loadItem
	 * @param {HTMLAudioElement|HTMLVideoElement} tag
	 * @param {String} srcAttribute The tag attribute that specifies the source, such as "src", "href", etc.
	 * @constructor
	 */
	function MediaTagRequest(loadItem, tag, srcAttribute) {
		this.AbstractRequest_constructor(loadItem);

		// protected properties
		this._tag = tag;
		this._tagSrcAttribute = srcAttribute;
		this._loadedHandler = createjs.proxy(this._handleTagComplete, this);
	};

	var p = createjs.extend(MediaTagRequest, createjs.TagRequest);
	var s = MediaTagRequest;

	// public methods
	p.load = function () {
		var sc = createjs.proxy(this._handleStalled, this);
		this._stalledCallback = sc;

		var pc = createjs.proxy(this._handleProgress, this);
		this._handleProgress = pc;

		this._tag.addEventListener("stalled", sc);
		this._tag.addEventListener("progress", pc);

		// This will tell us when audio is buffered enough to play through, but not when its loaded.
		// The tag doesn't keep loading in Chrome once enough has buffered, and we have decided that behaviour is sufficient.
		this._tag.addEventListener && this._tag.addEventListener("canplaythrough", this._loadedHandler, false); // canplaythrough callback doesn't work in Chrome, so we use an event.

		this.TagRequest_load();
	};

	// private methods
	p._handleReadyStateChange = function () {
		clearTimeout(this._loadTimeout);
		// This is strictly for tags in browsers that do not support onload.
		var tag = this._tag;

		// Complete is for old IE support.
		if (tag.readyState == "loaded" || tag.readyState == "complete") {
			this._handleTagComplete();
		}
	};

	p._handleStalled = function () {
		//Ignore, let the timeout take care of it. Sometimes its not really stopped.
	};

	/**
	 * An XHR request has reported progress.
	 * @method _handleProgress
	 * @param {Object} event The XHR progress event.
	 * @private
	 */
	p._handleProgress = function (event) {
		if (!event || event.loaded > 0 && event.total == 0) {
			return; // Sometimes we get no "total", so just ignore the progress event.
		}

		var newEvent = new createjs.ProgressEvent(event.loaded, event.total);
		this.dispatchEvent(newEvent);
	};

	// protected methods
	p._clean = function () {
		this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler);
		this._tag.removeEventListener("stalled", this._stalledCallback);
		this._tag.removeEventListener("progress", this._progressCallback);

		this.TagRequest__clean();
	};

	createjs.MediaTagRequest = createjs.promote(MediaTagRequest, "TagRequest");

}());

//##############################################################################
// XHRRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

// constructor
	/**
	 * A preloader that loads items using XHR requests, usually XMLHttpRequest. However XDomainRequests will be used
	 * for cross-domain requests if possible, and older versions of IE fall back on to ActiveX objects when necessary.
	 * XHR requests load the content as text or binary data, provide progress and consistent completion events, and
	 * can be canceled during load. Note that XHR is not supported in IE 6 or earlier, and is not recommended for
	 * cross-domain loading.
	 * @class XHRRequest
	 * @constructor
	 * @param {Object} item The object that defines the file to load. Please see the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * for an overview of supported file properties.
	 * @extends AbstractLoader
	 */
	function XHRRequest (item) {
		this.AbstractRequest_constructor(item);

		// protected properties
		/**
		 * A reference to the XHR request used to load the content.
		 * @property _request
		 * @type {XMLHttpRequest | XDomainRequest | ActiveX.XMLHTTP}
		 * @private
		 */
		this._request = null;

		/**
		 * A manual load timeout that is used for browsers that do not support the onTimeout event on XHR (XHR level 1,
		 * typically IE9).
		 * @property _loadTimeout
		 * @type {Number}
		 * @private
		 */
		this._loadTimeout = null;

		/**
		 * The browser's XHR (XMLHTTPRequest) version. Supported versions are 1 and 2. There is no official way to detect
		 * the version, so we use capabilities to make a best guess.
		 * @property _xhrLevel
		 * @type {Number}
		 * @default 1
		 * @private
		 */
		this._xhrLevel = 1;

		/**
		 * The response of a loaded file. This is set because it is expensive to look up constantly. This property will be
		 * null until the file is loaded.
		 * @property _response
		 * @type {mixed}
		 * @private
		 */
		this._response = null;

		/**
		 * The response of the loaded file before it is modified. In most cases, content is converted from raw text to
		 * an HTML tag or a formatted object which is set to the <code>result</code> property, but the developer may still
		 * want to access the raw content as it was loaded.
		 * @property _rawResponse
		 * @type {String|Object}
		 * @private
		 */
		this._rawResponse = null;

		this._canceled = false;

		// Setup our event handlers now.
		this._handleLoadStartProxy = createjs.proxy(this._handleLoadStart, this);
		this._handleProgressProxy = createjs.proxy(this._handleProgress, this);
		this._handleAbortProxy = createjs.proxy(this._handleAbort, this);
		this._handleErrorProxy = createjs.proxy(this._handleError, this);
		this._handleTimeoutProxy = createjs.proxy(this._handleTimeout, this);
		this._handleLoadProxy = createjs.proxy(this._handleLoad, this);
		this._handleReadyStateChangeProxy = createjs.proxy(this._handleReadyStateChange, this);

		if (!this._createXHR(item)) {
			//TODO: Throw error?
		}
	};

	var p = createjs.extend(XHRRequest, createjs.AbstractRequest);

// static properties
	/**
	 * A list of XMLHTTP object IDs to try when building an ActiveX object for XHR requests in earlier versions of IE.
	 * @property ACTIVEX_VERSIONS
	 * @type {Array}
	 * @since 0.4.2
	 * @private
	 */
	XHRRequest.ACTIVEX_VERSIONS = [
		"Msxml2.XMLHTTP.6.0",
		"Msxml2.XMLHTTP.5.0",
		"Msxml2.XMLHTTP.4.0",
		"MSXML2.XMLHTTP.3.0",
		"MSXML2.XMLHTTP",
		"Microsoft.XMLHTTP"
	];

// Public methods
	/**
	 * Look up the loaded result.
	 * @method getResult
	 * @param {Boolean} [raw=false] Return a raw result instead of a formatted result. This applies to content
	 * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be
	 * returned instead.
	 * @return {Object} A result object containing the content that was loaded, such as:
	 * <ul>
	 *      <li>An image tag (&lt;image /&gt;) for images</li>
	 *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts loaded with tags may be added to the
	 *      HTML head.</li>
	 *      <li>A style tag for CSS (&lt;style /&gt;)</li>
	 *      <li>Raw text for TEXT</li>
	 *      <li>A formatted JavaScript object defined by JSON</li>
	 *      <li>An XML document</li>
	 *      <li>An binary arraybuffer loaded by XHR</li>
	 * </ul>
	 * Note that if a raw result is requested, but not found, the result will be returned instead.
	 */
	p.getResult = function (raw) {
		if (raw && this._rawResponse) {
			return this._rawResponse;
		}
		return this._response;
	};

	// Overrides abstract method in AbstractRequest
	p.cancel = function () {
		this.canceled = true;
		this._clean();
		this._request.abort();
	};

	// Overrides abstract method in AbstractLoader
	p.load = function () {
		if (this._request == null) {
			this._handleError();
			return;
		}

		//Events
		if (this._request.addEventListener != null) {
			this._request.addEventListener("loadstart", this._handleLoadStartProxy, false);
			this._request.addEventListener("progress", this._handleProgressProxy, false);
			this._request.addEventListener("abort", this._handleAbortProxy, false);
			this._request.addEventListener("error", this._handleErrorProxy, false);
			this._request.addEventListener("timeout", this._handleTimeoutProxy, false);

			// Note: We don't get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.
			this._request.addEventListener("load", this._handleLoadProxy, false);
			this._request.addEventListener("readystatechange", this._handleReadyStateChangeProxy, false);
		} else {
			// IE9 support
			this._request.onloadstart = this._handleLoadStartProxy;
			this._request.onprogress = this._handleProgressProxy;
			this._request.onabort = this._handleAbortProxy;
			this._request.onerror = this._handleErrorProxy;
			this._request.ontimeout = this._handleTimeoutProxy;

			// Note: We don't get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.
			this._request.onload = this._handleLoadProxy;
			this._request.onreadystatechange = this._handleReadyStateChangeProxy;
		}

		// Set up a timeout if we don't have XHR2
		if (this._xhrLevel == 1) {
			this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);
		}

		// Sometimes we get back 404s immediately, particularly when there is a cross origin request.  // note this does not catch in Chrome
		try {
			if (!this._item.values || this._item.method == createjs.AbstractLoader.GET) {
				this._request.send();
			} else if (this._item.method == createjs.AbstractLoader.POST) {
				this._request.send(createjs.RequestUtils.formatQueryString(this._item.values));
			}
		} catch (error) {
			this.dispatchEvent(new createjs.ErrorEvent("XHR_SEND", null, error));
		}
	};

	p.setResponseType = function (type) {
		// Some old browsers doesn't support blob, so we convert arraybuffer to blob after response is downloaded
		if (type === 'blob') {
			type = window.URL ? 'blob' : 'arraybuffer';
			this._responseType = type;
		}
		this._request.responseType = type;
	};

	/**
	 * Get all the response headers from the XmlHttpRequest.
	 *
	 * <strong>From the docs:</strong> Return all the HTTP headers, excluding headers that are a case-insensitive match
	 * for Set-Cookie or Set-Cookie2, as a single string, with each header line separated by a U+000D CR U+000A LF pair,
	 * excluding the status line, and with each header name and header value separated by a U+003A COLON U+0020 SPACE
	 * pair.
	 * @method getAllResponseHeaders
	 * @return {String}
	 * @since 0.4.1
	 */
	p.getAllResponseHeaders = function () {
		if (this._request.getAllResponseHeaders instanceof Function) {
			return this._request.getAllResponseHeaders();
		} else {
			return null;
		}
	};

	/**
	 * Get a specific response header from the XmlHttpRequest.
	 *
	 * <strong>From the docs:</strong> Returns the header field value from the response of which the field name matches
	 * header, unless the field name is Set-Cookie or Set-Cookie2.
	 * @method getResponseHeader
	 * @param {String} header The header name to retrieve.
	 * @return {String}
	 * @since 0.4.1
	 */
	p.getResponseHeader = function (header) {
		if (this._request.getResponseHeader instanceof Function) {
			return this._request.getResponseHeader(header);
		} else {
			return null;
		}
	};

// protected methods
	/**
	 * The XHR request has reported progress.
	 * @method _handleProgress
	 * @param {Object} event The XHR progress event.
	 * @private
	 */
	p._handleProgress = function (event) {
		if (!event || event.loaded > 0 && event.total == 0) {
			return; // Sometimes we get no "total", so just ignore the progress event.
		}

		var newEvent = new createjs.ProgressEvent(event.loaded, event.total);
		this.dispatchEvent(newEvent);
	};

	/**
	 * The XHR request has reported a load start.
	 * @method _handleLoadStart
	 * @param {Object} event The XHR loadStart event.
	 * @private
	 */
	p._handleLoadStart = function (event) {
		clearTimeout(this._loadTimeout);
		this.dispatchEvent("loadstart");
	};

	/**
	 * The XHR request has reported an abort event.
	 * @method handleAbort
	 * @param {Object} event The XHR abort event.
	 * @private
	 */
	p._handleAbort = function (event) {
		this._clean();
		this.dispatchEvent(new createjs.ErrorEvent("XHR_ABORTED", null, event));
	};

	/**
	 * The XHR request has reported an error event.
	 * @method _handleError
	 * @param {Object} event The XHR error event.
	 * @private
	 */
	p._handleError = function (event) {
		this._clean();
		this.dispatchEvent(new createjs.ErrorEvent(event.message));
	};

	/**
	 * The XHR request has reported a readyState change. Note that older browsers (IE 7 & 8) do not provide an onload
	 * event, so we must monitor the readyStateChange to determine if the file is loaded.
	 * @method _handleReadyStateChange
	 * @param {Object} event The XHR readyStateChange event.
	 * @private
	 */
	p._handleReadyStateChange = function (event) {
		if (this._request.readyState == 4) {
			this._handleLoad();
		}
	};

	/**
	 * The XHR request has completed. This is called by the XHR request directly, or by a readyStateChange that has
	 * <code>request.readyState == 4</code>. Only the first call to this method will be processed.
	 * @method _handleLoad
	 * @param {Object} event The XHR load event.
	 * @private
	 */
	p._handleLoad = function (event) {
		if (this.loaded) {
			return;
		}
		this.loaded = true;

		var error = this._checkError();
		if (error) {
			this._handleError(error);
			return;
		}

		this._response = this._getResponse();
		// Convert arraybuffer back to blob
		if (this._responseType === 'arraybuffer') {
			try {
				this._response = new Blob([this._response]);
			} catch (e) {
				// Fallback to use BlobBuilder if Blob constructor is not supported
				// Tested on Android 2.3 ~ 4.2 and iOS5 safari
				window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
				if (e.name === 'TypeError' && window.BlobBuilder) {
					var builder = new BlobBuilder();
					builder.append(this._response);
					this._response = builder.getBlob();
				}
			}
		}
		this._clean();

		this.dispatchEvent(new createjs.Event("complete"));
	};

	/**
	 * The XHR request has timed out. This is called by the XHR request directly, or via a <code>setTimeout</code>
	 * callback.
	 * @method _handleTimeout
	 * @param {Object} [event] The XHR timeout event. This is occasionally null when called by the backup setTimeout.
	 * @private
	 */
	p._handleTimeout = function (event) {
		this._clean();

		this.dispatchEvent(new createjs.ErrorEvent("PRELOAD_TIMEOUT", null, event));
	};

// Protected
	/**
	 * Determine if there is an error in the current load. This checks the status of the request for problem codes. Note
	 * that this does not check for an actual response. Currently, it only checks for 404 or 0 error code.
	 * @method _checkError
	 * @return {int} If the request status returns an error code.
	 * @private
	 */
	p._checkError = function () {
		//LM: Probably need additional handlers here, maybe 501
		var status = parseInt(this._request.status);

		switch (status) {
			case 404:   // Not Found
			case 0:     // Not Loaded
				return new Error(status);
		}
		return null;
	};

	/**
	 * Validate the response. Different browsers have different approaches, some of which throw errors when accessed
	 * in other browsers. If there is no response, the <code>_response</code> property will remain null.
	 * @method _getResponse
	 * @private
	 */
	p._getResponse = function () {
		if (this._response != null) {
			return this._response;
		}

		if (this._request.response != null) {
			return this._request.response;
		}

		// Android 2.2 uses .responseText
		try {
			if (this._request.responseText != null) {
				return this._request.responseText;
			}
		} catch (e) {
		}

		// When loading XML, IE9 does not return .response, instead it returns responseXML.xml
		try {
			if (this._request.responseXML != null) {
				return this._request.responseXML;
			}
		} catch (e) {
		}

		return null;
	};

	/**
	 * Create an XHR request. Depending on a number of factors, we get totally different results.
	 * <ol><li>Some browsers get an <code>XDomainRequest</code> when loading cross-domain.</li>
	 *      <li>XMLHttpRequest are created when available.</li>
	 *      <li>ActiveX.XMLHTTP objects are used in older IE browsers.</li>
	 *      <li>Text requests override the mime type if possible</li>
	 *      <li>Origin headers are sent for crossdomain requests in some browsers.</li>
	 *      <li>Binary loads set the response type to "arraybuffer"</li></ol>
	 * @method _createXHR
	 * @param {Object} item The requested item that is being loaded.
	 * @return {Boolean} If an XHR request or equivalent was successfully created.
	 * @private
	 */
	p._createXHR = function (item) {
		// Check for cross-domain loads. We can't fully support them, but we can try.
		var crossdomain = createjs.RequestUtils.isCrossDomain(item);
		var headers = {};

		// Create the request. Fallback to whatever support we have.
		var req = null;
		if (window.XMLHttpRequest) {
			req = new XMLHttpRequest();
			// This is 8 or 9, so use XDomainRequest instead.
			if (crossdomain && req.withCredentials === undefined && window.XDomainRequest) {
				req = new XDomainRequest();
			}
		} else { // Old IE versions use a different approach
			for (var i = 0, l = s.ACTIVEX_VERSIONS.length; i < l; i++) {
				var axVersion = s.ACTIVEX_VERSIONS[i];
				try {
					req = new ActiveXObject(axVersion);
					break;
				} catch (e) {
				}
			}
			if (req == null) {
				return false;
			}
		}

		// Default to utf-8 for Text requests.
		if (item.mimeType == null && createjs.RequestUtils.isText(item.type)) {
			item.mimeType = "text/plain; charset=utf-8";
		}

		// IE9 doesn't support overrideMimeType(), so we need to check for it.
		if (item.mimeType && req.overrideMimeType) {
			req.overrideMimeType(item.mimeType);
		}

		// Determine the XHR level
		this._xhrLevel = (typeof req.responseType === "string") ? 2 : 1;

		var src = null;
		if (item.method == createjs.AbstractLoader.GET) {
			src = createjs.RequestUtils.buildPath(item.src, item.values);
		} else {
			src = item.src;
		}

		// Open the request.  Set cross-domain flags if it is supported (XHR level 1 only)
		req.open(item.method || createjs.AbstractLoader.GET, src, true);

		if (crossdomain && req instanceof XMLHttpRequest && this._xhrLevel == 1) {
			headers["Origin"] = location.origin;
		}

		// To send data we need to set the Content-type header)
		if (item.values && item.method == createjs.AbstractLoader.POST) {
			headers["Content-Type"] = "application/x-www-form-urlencoded";
		}

		if (!crossdomain && !headers["X-Requested-With"]) {
			headers["X-Requested-With"] = "XMLHttpRequest";
		}

		if (item.headers) {
			for (var n in item.headers) {
				headers[n] = item.headers[n];
			}
		}

		for (n in headers) {
			req.setRequestHeader(n, headers[n])
		}

		if (req instanceof XMLHttpRequest && item.withCredentials !== undefined) {
			req.withCredentials = item.withCredentials;
		}

		this._request = req;

		return true;
	};

	/**
	 * A request has completed (or failed or canceled), and needs to be disposed.
	 * @method _clean
	 * @private
	 */
	p._clean = function () {
		clearTimeout(this._loadTimeout);

		if (this._request.removeEventListener != null) {
			this._request.removeEventListener("loadstart", this._handleLoadStartProxy);
			this._request.removeEventListener("progress", this._handleProgressProxy);
			this._request.removeEventListener("abort", this._handleAbortProxy);
			this._request.removeEventListener("error", this._handleErrorProxy);
			this._request.removeEventListener("timeout", this._handleTimeoutProxy);
			this._request.removeEventListener("load", this._handleLoadProxy);
			this._request.removeEventListener("readystatechange", this._handleReadyStateChangeProxy);
		} else {
			this._request.onloadstart = null;
			this._request.onprogress = null;
			this._request.onabort = null;
			this._request.onerror = null;
			this._request.ontimeout = null;
			this._request.onload = null;
			this._request.onreadystatechange = null;
		}
	};

	p.toString = function () {
		return "[PreloadJS XHRRequest]";
	};

	createjs.XHRRequest = createjs.promote(XHRRequest, "AbstractRequest");

}());

//##############################################################################
// LoadQueue.js
//##############################################################################

this.createjs = this.createjs || {};

/*
 TODO: WINDOWS ISSUES
 * No error for HTML audio in IE 678
 * SVG no failure error in IE 67 (maybe 8) TAGS AND XHR
 * No script complete handler in IE 67 TAGS (XHR is fine)
 * No XML/JSON in IE6 TAGS
 * Need to hide loading SVG in Opera TAGS
 * No CSS onload/readystatechange in Safari or Android TAGS (requires rule checking)
 * SVG no load or failure in Opera XHR
 * Reported issues with IE7/8
 */

(function () {
	"use strict";

// constructor
	/**
	 * The LoadQueue class is the main API for preloading content. LoadQueue is a load manager, which can preload either
	 * a single file, or queue of files.
	 *
	 * <b>Creating a Queue</b><br />
	 * To use LoadQueue, create a LoadQueue instance. If you want to force tag loading where possible, set the preferXHR
	 * argument to false.
	 *
	 *      var queue = new createjs.LoadQueue(true);
	 *
	 * <b>Listening for Events</b><br />
	 * Add any listeners you want to the queue. Since PreloadJS 0.3.0, the {{#crossLink "EventDispatcher"}}{{/crossLink}}
	 * lets you add as many listeners as you want for events. You can subscribe to the following events:<ul>
	 *     <li>{{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}}: fired when a queue completes loading all
	 *     files</li>
	 *     <li>{{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}: fired when the queue encounters an error with
	 *     any file.</li>
	 *     <li>{{#crossLink "AbstractLoader/progress:event"}}{{/crossLink}}: Progress for the entire queue has
	 *     changed.</li>
	 *     <li>{{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}: A single file has completed loading.</li>
	 *     <li>{{#crossLink "LoadQueue/fileprogress:event"}}{{/crossLink}}: Progress for a single file has changes. Note
	 *     that only files loaded with XHR (or possibly by plugins) will fire progress events other than 0 or 100%.</li>
	 * </ul>
	 *
	 *      queue.on("fileload", handleFileLoad, this);
	 *      queue.on("complete", handleComplete, this);
	 *
	 * <b>Adding files and manifests</b><br />
	 * Add files you want to load using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or add multiple files at a
	 * time using a list or a manifest definition using {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. Files are
	 * appended to the end of the active queue, so you can use these methods as many times as you like, whenever you
	 * like.
	 *
	 *      queue.loadFile("filePath/file.jpg");
	 *      queue.loadFile({id:"image", src:"filePath/file.jpg"});
	 *      queue.loadManifest(["filePath/file.jpg", {id:"image", src:"filePath/file.jpg"}]);
	 *
	 *      // Use an external manifest
	 *      queue.loadManifest("path/to/manifest.json");
	 *      queue.loadManifest({src:"manifest.json", type:"manifest"});
	 *
	 * If you pass `false` as the `loadNow` parameter, the queue will not kick of the load of the files, but it will not
	 * stop if it has already been started. Call the {{#crossLink "AbstractLoader/load"}}{{/crossLink}} method to begin
	 * a paused queue. Note that a paused queue will automatically resume when new files are added to it with a
	 * `loadNow` argument of `true`.
	 *
	 *      queue.load();
	 *
	 * <b>File Types</b><br />
	 * The file type of a manifest item is auto-determined by the file extension. The pattern matching in PreloadJS
	 * should handle the majority of standard file and url formats, and works with common file extensions. If you have
	 * either a non-standard file extension, or are serving the file using a proxy script, then you can pass in a
	 * <code>type</code> property with any manifest item.
	 *
	 *      queue.loadFile({src:"path/to/myFile.mp3x", type:createjs.AbstractLoader.SOUND});
	 *
	 *      // Note that PreloadJS will not read a file extension from the query string
	 *      queue.loadFile({src:"http://server.com/proxy?file=image.jpg", type:createjs.AbstractLoader.IMAGE});
	 *
	 * Supported types are defined on the {{#crossLink "AbstractLoader"}}{{/crossLink}} class, and include:
	 * <ul>
	 *     <li>{{#crossLink "AbstractLoader/BINARY:property"}}{{/crossLink}}: Raw binary data via XHR</li>
	 *     <li>{{#crossLink "AbstractLoader/CSS:property"}}{{/crossLink}}: CSS files</li>
	 *     <li>{{#crossLink "AbstractLoader/IMAGE:property"}}{{/crossLink}}: Common image formats</li>
	 *     <li>{{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}}: JavaScript files</li>
	 *     <li>{{#crossLink "AbstractLoader/JSON:property"}}{{/crossLink}}: JSON data</li>
	 *     <li>{{#crossLink "AbstractLoader/JSONP:property"}}{{/crossLink}}: JSON files cross-domain</li>
	 *     <li>{{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}}: A list of files to load in JSON format, see
	 *     {{#crossLink "AbstractLoader/loadManifest"}}{{/crossLink}}</li>
	 *     <li>{{#crossLink "AbstractLoader/SOUND:property"}}{{/crossLink}}: Audio file formats</li>
	 *     <li>{{#crossLink "AbstractLoader/SPRITESHEET:property"}}{{/crossLink}}: JSON SpriteSheet definiteions. This
	 *     will also load sub-images, and provide a {{#crossLink "SpriteSheet"}}{{/crossLink}} instance.</li>
	 *     <li>{{#crossLink "AbstractLoader/SVG:property"}}{{/crossLink}}: SVG files</li>
	 *     <li>{{#crossLink "AbstractLoader/TEXT:property"}}{{/crossLink}}: Text files - XHR only</li>
	 *     <li>{{#crossLink "AbstractLoader/XML:property"}}{{/crossLink}}: XML data</li>
	 * </ul>
	 *
	 * <em>Note: Loader types used to be defined on LoadQueue, but have been moved to AbstractLoader for better
	 * portability of loader classes, which can be used individually now. The properties on LoadQueue still exist, but
	 * are deprecated.</em>
	 *
	 * <b>Handling Results</b><br />
	 * When a file is finished downloading, a {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event is
	 * dispatched. In an example above, there is an event listener snippet for fileload. Loaded files are usually a
	 * formatted object that can be used immediately, including:
	 * <ul>
	 *     <li>Binary: The binary loaded result</li>
	 *     <li>CSS: A &lt;link /&gt; tag</li>
	 *     <li>Image: An &lt;img /&gt; tag</li>
	 *     <li>JavaScript: A &lt;script /&gt; tag</li>
	 *     <li>JSON/JSONP: A formatted JavaScript Object</li>
	 *     <li>Manifest: A JavaScript object.
	 *     <li>Sound: An &lt;audio /&gt; tag</a>
	 *     <li>SpriteSheet: A {{#crossLink "SpriteSheet"}}{{/crossLink}} instance, containing loaded images.
	 *     <li>SVG: An &lt;object /&gt; tag</li>
	 *     <li>Text: Raw text</li>
	 *     <li>XML: An XML DOM node</li>
	 * </ul>
	 *
	 *      function handleFileLoad(event) {
	 *          var item = event.item; // A reference to the item that was passed in to the LoadQueue
	 *          var type = item.type;
	 *
	 *          // Add any images to the page body.
	 *          if (type == createjs.LoadQueue.IMAGE) {
	 *              document.body.appendChild(event.result);
	 *          }
	 *      }
	 *
	 * At any time after the file has been loaded (usually after the queue has completed), any result can be looked up
	 * via its "id" using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}. If no id was provided, then the
	 * "src" or file path can be used instead, including the `path` defined by a manifest, but <strong>not including</strong>
	 * a base path defined on the LoadQueue. It is recommended to always pass an id if you want to look up content.
	 *
	 *      var image = queue.getResult("image");
	 *      document.body.appendChild(image);
	 *
	 * Raw loaded content can be accessed using the <code>rawResult</code> property of the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}
	 * event, or can be looked up using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}, passing `true` as the 2nd
	 * argument. This is only applicable for content that has been parsed for the browser, specifically: JavaScript,
	 * CSS, XML, SVG, and JSON objects, or anything loaded with XHR.
	 *
	 *      var image = queue.getResult("image", true); // load the binary image data loaded with XHR.
	 *
	 * <b>Plugins</b><br />
	 * LoadQueue has a simple plugin architecture to help process and preload content. For example, to preload audio,
	 * make sure to install the <a href="http://soundjs.com">SoundJS</a> Sound class, which will help load HTML audio,
	 * Flash audio, and WebAudio files. This should be installed <strong>before</strong> loading any audio files.
	 *
	 *      queue.installPlugin(createjs.Sound);
	 *
	 * <h4>Known Browser Issues</h4>
	 * <ul>
	 *     <li>Browsers without audio support can not load audio files.</li>
	 *     <li>Safari on Mac OS X can only play HTML audio if QuickTime is installed</li>
	 *     <li>HTML Audio tags will only download until their <code>canPlayThrough</code> event is fired. Browsers other
	 *     than Chrome will continue to download in the background.</li>
	 *     <li>When loading scripts using tags, they are automatically added to the document.</li>
	 *     <li>Scripts loaded via XHR may not be properly inspectable with browser tools.</li>
	 *     <li>IE6 and IE7 (and some other browsers) may not be able to load XML, Text, or JSON, since they require
	 *     XHR to work.</li>
	 *     <li>Content loaded via tags will not show progress, and will continue to download in the background when
	 *     canceled, although no events will be dispatched.</li>
	 * </ul>
	 *
	 * @class LoadQueue
	 * @param {Boolean} [preferXHR=true] Determines whether the preload instance will favor loading with XHR (XML HTTP
	 * Requests), or HTML tags. When this is `false`, the queue will use tag loading when possible, and fall back on XHR
	 * when necessary.
	 * @param {String} [basePath=""] A path that will be prepended on to the source parameter of all items in the queue
	 * before they are loaded.  Sources beginning with a protocol such as `http://` or a relative path such as `../`
	 * will not receive a base path.
	 * @param {String|Boolean} [crossOrigin=""] An optional flag to support images loaded from a CORS-enabled server. To
	 * use it, set this value to `true`, which will default the crossOrigin property on images to "Anonymous". Any
	 * string value will be passed through, but only "" and "Anonymous" are recommended. <strong>Note: The crossOrigin
	 * parameter is deprecated. Use LoadItem.crossOrigin instead</strong>
	 *
	 * @constructor
	 * @extends AbstractLoader
	 */
	function LoadQueue (preferXHR, basePath, crossOrigin) {
		this.AbstractLoader_constructor();

		/**
		 * An array of the plugins registered using {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}}.
		 * @property _plugins
		 * @type {Array}
		 * @private
		 * @since 0.6.1
		 */
		this._plugins = [];

		/**
		 * An object hash of callbacks that are fired for each file type before the file is loaded, giving plugins the
		 * ability to override properties of the load. Please see the {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}}
		 * method for more information.
		 * @property _typeCallbacks
		 * @type {Object}
		 * @private
		 */
		this._typeCallbacks = {};

		/**
		 * An object hash of callbacks that are fired for each file extension before the file is loaded, giving plugins the
		 * ability to override properties of the load. Please see the {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}}
		 * method for more information.
		 * @property _extensionCallbacks
		 * @type {null}
		 * @private
		 */
		this._extensionCallbacks = {};

		/**
		 * The next preload queue to process when this one is complete. If an error is thrown in the current queue, and
		 * {{#crossLink "LoadQueue/stopOnError:property"}}{{/crossLink}} is `true`, the next queue will not be processed.
		 * @property next
		 * @type {LoadQueue}
		 * @default null
		 */
		this.next = null;

		/**
		 * Ensure loaded scripts "complete" in the order they are specified. Loaded scripts are added to the document head
		 * once they are loaded. Scripts loaded via tags will load one-at-a-time when this property is `true`, whereas
		 * scripts loaded using XHR can load in any order, but will "finish" and be added to the document in the order
		 * specified.
		 *
		 * Any items can be set to load in order by setting the {{#crossLink "maintainOrder:property"}}{{/crossLink}}
		 * property on the load item, or by ensuring that only one connection can be open at a time using
		 * {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}. Note that when the `maintainScriptOrder` property
		 * is set to `true`, scripts items are automatically set to `maintainOrder=true`, and changing the
		 * `maintainScriptOrder` to `false` during a load will not change items already in a queue.
		 *
		 * <h4>Example</h4>
		 *
		 *      var queue = new createjs.LoadQueue();
		 *      queue.setMaxConnections(3); // Set a higher number to load multiple items at once
		 *      queue.maintainScriptOrder = true; // Ensure scripts are loaded in order
		 *      queue.loadManifest([
		 *          "script1.js",
		 *          "script2.js",
		 *          "image.png", // Load any time
		 *          {src: "image2.png", maintainOrder: true} // Will wait for script2.js
		 *          "image3.png",
		 *          "script3.js" // Will wait for image2.png before loading (or completing when loading with XHR)
		 *      ]);
		 *
		 * @property maintainScriptOrder
		 * @type {Boolean}
		 * @default true
		 */
		this.maintainScriptOrder = true;

		/**
		 * Determines if the LoadQueue will stop processing the current queue when an error is encountered.
		 * @property stopOnError
		 * @type {Boolean}
		 * @default false
		 */
		this.stopOnError = false;

		/**
		 * The number of maximum open connections that a loadQueue tries to maintain. Please see
		 * {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}} for more information.
		 * @property _maxConnections
		 * @type {Number}
		 * @default 1
		 * @private
		 */
		this._maxConnections = 1;

		/**
		 * An internal list of all the default Loaders that are included with PreloadJS. Before an item is loaded, the
		 * available loader list is iterated, in the order they are included, and as soon as a loader indicates it can
		 * handle the content, it will be selected. The default loader, ({{#crossLink "TextLoader"}}{{/crossLink}} is
		 * last in the list, so it will be used if no other match is found. Typically, loaders will match based on the
		 * {{#crossLink "LoadItem/type"}}{{/crossLink}}, which is automatically determined using the file extension of
		 * the {{#crossLink "LoadItem/src:property"}}{{/crossLink}}.
		 *
		 * Loaders can be removed from PreloadJS by simply not including them.
		 *
		 * Custom loaders installed using {{#crossLink "registerLoader"}}{{/crossLink}} will be prepended to this list
		 * so that they are checked first.
		 * @property _availableLoaders
		 * @type {Array}
		 * @private
		 * @since 0.6.0
		 */
		this._availableLoaders = [
			createjs.ImageLoader,
			createjs.JavaScriptLoader,
			createjs.CSSLoader,
			createjs.JSONLoader,
			createjs.JSONPLoader,
			createjs.SoundLoader,
			createjs.ManifestLoader,
			createjs.SpriteSheetLoader,
			createjs.XMLLoader,
			createjs.SVGLoader,
			createjs.BinaryLoader,
			createjs.VideoLoader,
			createjs.TextLoader,
		];

		/**
		 * The number of built in loaders, so they can't be removed by {{#crossLink "unregisterLoader"}}{{/crossLink}.
				 * @property _defaultLoaderLength
		 * @type {Number}
		 * @private
		 * @since 0.6.0
		 */
		this._defaultLoaderLength = this._availableLoaders.length;

		this.init(preferXHR, basePath, crossOrigin);
	}

	var p = createjs.extend(LoadQueue, createjs.AbstractLoader);
	var s = LoadQueue;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.

	/**
	 * An internal initialization method, which is used for initial set up, but also to reset the LoadQueue.
	 * @method init
	 * @param preferXHR
	 * @param basePath
	 * @param crossOrigin
	 * @private
	 */
	p.init = function (preferXHR, basePath, crossOrigin) {

		// public properties
		/**
		 * @property useXHR
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 * @deprecated Use preferXHR instead.
		 */
		this.useXHR = true;

		/**
		 * Try and use XMLHttpRequest (XHR) when possible. Note that LoadQueue will default to tag loading or XHR
		 * loading depending on the requirements for a media type. For example, HTML audio can not be loaded with XHR,
		 * and plain text can not be loaded with tags, so it will default the the correct type instead of using the
		 * user-defined type.
		 * @type {Boolean}
		 * @default true
		 * @since 0.6.0
		 */
		this.preferXHR = true; //TODO: Get/Set
		this._preferXHR = true;
		this.setPreferXHR(preferXHR);

		// protected properties
		/**
		 * Whether the queue is currently paused or not.
		 * @property _paused
		 * @type {boolean}
		 * @private
		 */
		this._paused = false;

		/**
		 * A path that will be prepended on to the item's {{#crossLink "LoadItem/src:property"}}{{/crossLink}}. The
		 * `_basePath` property will only be used if an item's source is relative, and does not include a protocol such
		 * as `http://`, or a relative path such as `../`.
		 * @property _basePath
		 * @type {String}
		 * @private
		 * @since 0.3.1
		 */
		this._basePath = basePath;

		/**
		 * An optional flag to set on images that are loaded using PreloadJS, which enables CORS support. Images loaded
		 * cross-domain by servers that support CORS require the crossOrigin flag to be loaded and interacted with by
		 * a canvas. When loading locally, or with a server with no CORS support, this flag can cause other security issues,
		 * so it is recommended to only set it if you are sure the server supports it. Currently, supported values are ""
		 * and "Anonymous".
		 * @property _crossOrigin
		 * @type {String}
		 * @default ""
		 * @private
		 * @since 0.4.1
		 */
		this._crossOrigin = crossOrigin;

		/**
		 * Determines if the loadStart event was dispatched already. This event is only fired one time, when the first
		 * file is requested.
		 * @property _loadStartWasDispatched
		 * @type {Boolean}
		 * @default false
		 * @private
		 */
		this._loadStartWasDispatched = false;

		/**
		 * Determines if there is currently a script loading. This helps ensure that only a single script loads at once when
		 * using a script tag to do preloading.
		 * @property _currentlyLoadingScript
		 * @type {Boolean}
		 * @private
		 */
		this._currentlyLoadingScript = null;

		/**
		 * An array containing the currently downloading files.
		 * @property _currentLoads
		 * @type {Array}
		 * @private
		 */
		this._currentLoads = [];

		/**
		 * An array containing the queued items that have not yet started downloading.
		 * @property _loadQueue
		 * @type {Array}
		 * @private
		 */
		this._loadQueue = [];

		/**
		 * An array containing downloads that have not completed, so that the LoadQueue can be properly reset.
		 * @property _loadQueueBackup
		 * @type {Array}
		 * @private
		 */
		this._loadQueueBackup = [];

		/**
		 * An object hash of items that have finished downloading, indexed by the {{#crossLink "LoadItem"}}{{/crossLink}}
		 * id.
		 * @property _loadItemsById
		 * @type {Object}
		 * @private
		 */
		this._loadItemsById = {};

		/**
		 * An object hash of items that have finished downloading, indexed by {{#crossLink "LoadItem"}}{{/crossLink}}
		 * source.
		 * @property _loadItemsBySrc
		 * @type {Object}
		 * @private
		 */
		this._loadItemsBySrc = {};

		/**
		 * An object hash of loaded items, indexed by the ID of the {{#crossLink "LoadItem"}}{{/crossLink}}.
		 * @property _loadedResults
		 * @type {Object}
		 * @private
		 */
		this._loadedResults = {};

		/**
		 * An object hash of un-parsed loaded items, indexed by the ID of the {{#crossLink "LoadItem"}}{{/crossLink}}.
		 * @property _loadedRawResults
		 * @type {Object}
		 * @private
		 */
		this._loadedRawResults = {};

		/**
		 * The number of items that have been requested. This helps manage an overall progress without knowing how large
		 * the files are before they are downloaded. This does not include items inside of loaders such as the
		 * {{#crossLink "ManifestLoader"}}{{/crossLink}}.
		 * @property _numItems
		 * @type {Number}
		 * @default 0
		 * @private
		 */
		this._numItems = 0;

		/**
		 * The number of items that have completed loaded. This helps manage an overall progress without knowing how large
		 * the files are before they are downloaded.
		 * @property _numItemsLoaded
		 * @type {Number}
		 * @default 0
		 * @private
		 */
		this._numItemsLoaded = 0;

		/**
		 * A list of scripts in the order they were requested. This helps ensure that scripts are "completed" in the right
		 * order.
		 * @property _scriptOrder
		 * @type {Array}
		 * @private
		 */
		this._scriptOrder = [];

		/**
		 * A list of scripts that have been loaded. Items are added to this list as <code>null</code> when they are
		 * requested, contain the loaded item if it has completed, but not been dispatched to the user, and <code>true</true>
		 * once they are complete and have been dispatched.
		 * @property _loadedScripts
		 * @type {Array}
		 * @private
		 */
		this._loadedScripts = [];

		/**
		 * The last progress amount. This is used to suppress duplicate progress events.
		 * @property _lastProgress
		 * @type {Number}
		 * @private
		 * @since 0.6.0
		 */
		this._lastProgress = NaN;

	};

// static properties
	/**
	 * The time in milliseconds to assume a load has failed. An {{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}
	 * event is dispatched if the timeout is reached before any data is received.
	 * @property loadTimeout
	 * @type {Number}
	 * @default 8000
	 * @static
	 * @since 0.4.1
	 * @deprecated In favour of {{#crossLink "LoadItem/LOAD_TIMEOUT_DEFAULT:property}}{{/crossLink}} property.
	 */
	s.loadTimeout = 8000;

	/**
	 * The time in milliseconds to assume a load has failed.
	 * @property LOAD_TIMEOUT
	 * @type {Number}
	 * @default 0
	 * @deprecated in favor of the {{#crossLink "LoadQueue/loadTimeout:property"}}{{/crossLink}} property.
	 */
	s.LOAD_TIMEOUT = 0;

// Preload Types
	/**
	 * @property BINARY
	 * @type {String}
	 * @default binary
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/BINARY:property"}}{{/crossLink}} instead.
	 */
	s.BINARY = createjs.AbstractLoader.BINARY;

	/**
	 * @property CSS
	 * @type {String}
	 * @default css
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/CSS:property"}}{{/crossLink}} instead.
	 */
	s.CSS = createjs.AbstractLoader.CSS;

	/**
	 * @property IMAGE
	 * @type {String}
	 * @default image
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/CSS:property"}}{{/crossLink}} instead.
	 */
	s.IMAGE = createjs.AbstractLoader.IMAGE;

	/**
	 * @property JAVASCRIPT
	 * @type {String}
	 * @default javascript
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}} instead.
	 */
	s.JAVASCRIPT = createjs.AbstractLoader.JAVASCRIPT;

	/**
	 * @property JSON
	 * @type {String}
	 * @default json
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JSON:property"}}{{/crossLink}} instead.
	 */
	s.JSON = createjs.AbstractLoader.JSON;

	/**
	 * @property JSONP
	 * @type {String}
	 * @default jsonp
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JSONP:property"}}{{/crossLink}} instead.
	 */
	s.JSONP = createjs.AbstractLoader.JSONP;

	/**
	 * @property MANIFEST
	 * @type {String}
	 * @default manifest
	 * @static
	 * @since 0.4.1
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}} instead.
	 */
	s.MANIFEST = createjs.AbstractLoader.MANIFEST;

	/**
	 * @property SOUND
	 * @type {String}
	 * @default sound
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}} instead.
	 */
	s.SOUND = createjs.AbstractLoader.SOUND;

	/**
	 * @property VIDEO
	 * @type {String}
	 * @default video
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}} instead.
	 */
	s.VIDEO = createjs.AbstractLoader.VIDEO;

	/**
	 * @property SVG
	 * @type {String}
	 * @default svg
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/SVG:property"}}{{/crossLink}} instead.
	 */
	s.SVG = createjs.AbstractLoader.SVG;

	/**
	 * @property TEXT
	 * @type {String}
	 * @default text
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/TEXT:property"}}{{/crossLink}} instead.
	 */
	s.TEXT = createjs.AbstractLoader.TEXT;

	/**
	 * @property XML
	 * @type {String}
	 * @default xml
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/XML:property"}}{{/crossLink}} instead.
	 */
	s.XML = createjs.AbstractLoader.XML;

	/**
	 * @property POST
	 * @type {string}
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/POST:property"}}{{/crossLink}} instead.
	 */
	s.POST = createjs.AbstractLoader.POST;

	/**
	 * @property GET
	 * @type {string}
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/GET:property"}}{{/crossLink}} instead.
	 */
	s.GET = createjs.AbstractLoader.GET;

// events
	/**
	 * This event is fired when an individual file has loaded, and been processed.
	 * @event fileload
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a `src` property.
	 * @param {Object} result The HTML tag or parsed result of the loaded item.
	 * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted
	 * to a usable object.
	 * @since 0.3.0
	 */

	/**
	 * This {{#crossLink "ProgressEvent"}}{{/crossLink}} that is fired when an an individual file's progress changes.
	 * @event fileprogress
	 * @since 0.3.0
	 */

	/**
	 * This event is fired when an individual file starts to load.
	 * @event filestart
	 * @param {Object} The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a property.
	 */

// public methods
	/**
	 * Register a custom loaders class. New loaders are given precedence over loaders added earlier and default loaders.
	 * It is recommended that loaders extend {{#crossLink "AbstractLoader"}}{{/crossLink}}. Loaders can only be added
	 * once, and will be prepended to the list of available loaders.
	 * @method registerLoader
	 * @param {Function|AbstractLoader} loader The AbstractLoader class to add.
	 * @since 0.6.0
	 */
	p.registerLoader = function (loader) {
		if (!loader || !loader.canLoadItem) {
			throw new Error("loader is of an incorrect type.");
		} else if (this._availableLoaders.indexOf(loader) != -1) {
			throw new Error("loader already exists."); //LM: Maybe just silently fail here
		}

		this._availableLoaders.unshift(loader);
	};

	/**
	 * Remove a custom loader added usig {{#crossLink "registerLoader"}}{{/crossLink}}. Only custom loaders can be
	 * unregistered, the default loaders will always be available.
	 * @method unregisterLoader
	 * @param {Function|AbstractLoader} loader The AbstractLoader class to remove
	 */
	p.unregisterLoader = function (loader) {
		var idx = this._availableLoaders.indexOf(loader);
		if (idx != -1 && idx < this._defaultLoaderLength - 1) {
			this._availableLoaders.splice(idx, 1);
		}
	};

	/**
	 * @method setUseXHR
	 * @param {Boolean} value The new useXHR value to set.
	 * @return {Boolean} The new useXHR value. If XHR is not supported by the browser, this will return false, even if
	 * the provided value argument was true.
	 * @since 0.3.0
	 * @deprecated use the {{#crossLink "preferXHR:property"}}{{/crossLink}} property, or the {{#crossLink "setUseXHR"}}{{/crossLink}}
	 * method instead.
	 */
	p.setUseXHR = function (value) {
		return this.setPreferXHR(value);
	};

	/**
	 * Change the {{#crossLink "preferXHR:property"}}{{/crossLink}} value. Note that if this is set to `true`, it may
	 * fail, or be ignored depending on the browser's capabilities and the load type.
	 * @method setPreferXHR
	 * @param {Boolean} value
	 * @returns {Boolean} The value of {{#crossLink "preferXHR"}}{{/crossLink}} that was successfully set.
	 * @since 0.6.0
	 */
	p.setPreferXHR = function (value) {
		// Determine if we can use XHR. XHR defaults to TRUE, but the browser may not support it.
		//TODO: Should we be checking for the other XHR types? Might have to do a try/catch on the different types similar to createXHR.
		this.preferXHR = (value != false && window.XMLHttpRequest != null);
		return this.preferXHR;
	};

	/**
	 * Stops all queued and loading items, and clears the queue. This also removes all internal references to loaded
	 * content, and allows the queue to be used again.
	 * @method removeAll
	 * @since 0.3.0
	 */
	p.removeAll = function () {
		this.remove();
	};

	/**
	 * Stops an item from being loaded, and removes it from the queue. If nothing is passed, all items are removed.
	 * This also removes internal references to loaded item(s).
	 *
	 * <h4>Example</h4>
	 *
	 *      queue.loadManifest([
	 *          {src:"test.png", id:"png"},
	 *          {src:"test.jpg", id:"jpg"},
	 *          {src:"test.mp3", id:"mp3"}
	 *      ]);
	 *      queue.remove("png"); // Single item by ID
	 *      queue.remove("png", "test.jpg"); // Items as arguments. Mixed id and src.
	 *      queue.remove(["test.png", "jpg"]); // Items in an Array. Mixed id and src.
	 *
	 * @method remove
	 * @param {String | Array} idsOrUrls* The id or ids to remove from this queue. You can pass an item, an array of
	 * items, or multiple items as arguments.
	 * @since 0.3.0
	 */
	p.remove = function (idsOrUrls) {
		var args = null;

		if (idsOrUrls && !(idsOrUrls instanceof Array)) {
			args = [idsOrUrls];
		} else if (idsOrUrls) {
			args = idsOrUrls;
		} else if (arguments.length > 0) {
			return;
		}

		var itemsWereRemoved = false;

		// Destroy everything
		if (!args) {
			this.close();
			for (var n in this._loadItemsById) {
				this._disposeItem(this._loadItemsById[n]);
			}
			this.init(this.preferXHR, this._basePath);

			// Remove specific items
		} else {
			while (args.length) {
				var item = args.pop();
				var r = this.getResult(item);

				//Remove from the main load Queue
				for (i = this._loadQueue.length - 1; i >= 0; i--) {
					loadItem = this._loadQueue[i].getItem();
					if (loadItem.id == item || loadItem.src == item) {
						this._loadQueue.splice(i, 1)[0].cancel();
						break;
					}
				}

				//Remove from the backup queue
				for (i = this._loadQueueBackup.length - 1; i >= 0; i--) {
					loadItem = this._loadQueueBackup[i].getItem();
					if (loadItem.id == item || loadItem.src == item) {
						this._loadQueueBackup.splice(i, 1)[0].cancel();
						break;
					}
				}

				if (r) {
					this._disposeItem(this.getItem(item));
				} else {
					for (var i = this._currentLoads.length - 1; i >= 0; i--) {
						var loadItem = this._currentLoads[i].getItem();
						if (loadItem.id == item || loadItem.src == item) {
							this._currentLoads.splice(i, 1)[0].cancel();
							itemsWereRemoved = true;
							break;
						}
					}
				}
			}

			// If this was called during a load, try to load the next item.
			if (itemsWereRemoved) {
				this._loadNext();
			}
		}
	};

	/**
	 * Stops all open loads, destroys any loaded items, and resets the queue, so all items can
	 * be reloaded again by calling {{#crossLink "AbstractLoader/load"}}{{/crossLink}}. Items are not removed from the
	 * queue. To remove items use the {{#crossLink "LoadQueue/remove"}}{{/crossLink}} or
	 * {{#crossLink "LoadQueue/removeAll"}}{{/crossLink}} method.
	 * @method reset
	 * @since 0.3.0
	 */
	p.reset = function () {
		this.close();
		for (var n in this._loadItemsById) {
			this._disposeItem(this._loadItemsById[n]);
		}

		//Reset the queue to its start state
		var a = [];
		for (var i = 0, l = this._loadQueueBackup.length; i < l; i++) {
			a.push(this._loadQueueBackup[i].getItem());
		}

		this.loadManifest(a, false);
	};

	/**
	 * Register a plugin. Plugins can map to load types (sound, image, etc), or specific extensions (png, mp3, etc).
	 * Currently, only one plugin can exist per type/extension.
	 *
	 * When a plugin is installed, a <code>getPreloadHandlers()</code> method will be called on it. For more information
	 * on this method, check out the {{#crossLink "SamplePlugin/getPreloadHandlers"}}{{/crossLink}} method in the
	 * {{#crossLink "SamplePlugin"}}{{/crossLink}} class.
	 *
	 * Before a file is loaded, a matching plugin has an opportunity to modify the load. If a `callback` is returned
	 * from the {{#crossLink "SamplePlugin/getPreloadHandlers"}}{{/crossLink}} method, it will be invoked first, and its
	 * result may cancel or modify the item. The callback method can also return a `completeHandler` to be fired when
	 * the file is loaded, or a `tag` object, which will manage the actual download. For more information on these
	 * methods, check out the {{#crossLink "SamplePlugin/preloadHandler"}}{{/crossLink}} and {{#crossLink "SamplePlugin/fileLoadHandler"}}{{/crossLink}}
	 * methods on the {{#crossLink "SamplePlugin"}}{{/crossLink}}.
	 *
	 * @method installPlugin
	 * @param {Function} plugin The plugin class to install.
	 */
	p.installPlugin = function (plugin) {
		if (plugin == null) {
			return;
		}

		if (plugin.getPreloadHandlers != null) {
			this._plugins.push(plugin);
			var map = plugin.getPreloadHandlers();
			map.scope = plugin;

			if (map.types != null) {
				for (var i = 0, l = map.types.length; i < l; i++) {
					this._typeCallbacks[map.types[i]] = map;
				}
			}

			if (map.extensions != null) {
				for (i = 0, l = map.extensions.length; i < l; i++) {
					this._extensionCallbacks[map.extensions[i]] = map;
				}
			}
		}
	};

	/**
	 * Set the maximum number of concurrent connections. Note that browsers and servers may have a built-in maximum
	 * number of open connections, so any additional connections may remain in a pending state until the browser
	 * opens the connection. When loading scripts using tags, and when {{#crossLink "LoadQueue/maintainScriptOrder:property"}}{{/crossLink}}
	 * is `true`, only one script is loaded at a time due to browser limitations.
	 *
	 * <h4>Example</h4>
	 *
	 *      var queue = new createjs.LoadQueue();
	 *      queue.setMaxConnections(10); // Allow 10 concurrent loads
	 *
	 * @method setMaxConnections
	 * @param {Number} value The number of concurrent loads to allow. By default, only a single connection per LoadQueue
	 * is open at any time.
	 */
	p.setMaxConnections = function (value) {
		this._maxConnections = value;
		if (!this._paused && this._loadQueue.length > 0) {
			this._loadNext();
		}
	};

	/**
	 * Load a single file. To add multiple files at once, use the {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}
	 * method.
	 *
	 * Files are always appended to the current queue, so this method can be used multiple times to add files.
	 * To clear the queue first, use the {{#crossLink "AbstractLoader/close"}}{{/crossLink}} method.
	 * @method loadFile
	 * @param {LoadItem|Object|String} file The file object or path to load. A file can be either
	 * <ul>
	 *     <li>A {{#crossLink "LoadItem"}}{{/crossLink}} instance</li>
	 *     <li>An object containing properties defined by {{#crossLink "LoadItem"}}{{/crossLink}}</li>
	 *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink "LoadItem"}}{{/crossLink}}
	 *     in the background.</li>
	 * </ul>
	 * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default
	 * value is true. If the queue is paused using {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}}, and the value is
	 * `true`, the queue will resume automatically.
	 * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the
	 * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}},
	 * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>
	 * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue
	 * constructor, or a `path` property in a manifest definition.
	 */
	p.loadFile = function (file, loadNow, basePath) {
		if (file == null) {
			var event = new createjs.ErrorEvent("PRELOAD_NO_FILE");
			this._sendError(event);
			return;
		}
		this._addItem(file, null, basePath);

		if (loadNow !== false) {
			this.setPaused(false);
		} else {
			this.setPaused(true);
		}
	};

	/**
	 * Load an array of files. To load a single file, use the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} method.
	 * The files in the manifest are requested in the same order, but may complete in a different order if the max
	 * connections are set above 1 using {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}. Scripts will load
	 * in the right order as long as {{#crossLink "LoadQueue/maintainScriptOrder"}}{{/crossLink}} is true (which is
	 * default).
	 *
	 * Files are always appended to the current queue, so this method can be used multiple times to add files.
	 * To clear the queue first, use the {{#crossLink "AbstractLoader/close"}}{{/crossLink}} method.
	 * @method loadManifest
	 * @param {Array|String|Object} manifest An list of files to load. The loadManifest call supports four types of
	 * manifests:
	 * <ol>
	 *     <li>A string path, which points to a manifest file, which is a JSON file that contains a "manifest" property,
	 *     which defines the list of files to load, and can optionally contain a "path" property, which will be
	 *     prepended to each file in the list.</li>
	 *     <li>An object which defines a "src", which is a JSON or JSONP file. A "callback" can be defined for JSONP
	 *     file. The JSON/JSONP file should contain a "manifest" property, which defines the list of files to load,
	 *     and can optionally contain a "path" property, which will be prepended to each file in the list.</li>
	 *     <li>An object which contains a "manifest" property, which defines the list of files to load, and can
	 *     optionally contain a "path" property, which will be prepended to each file in the list.</li>
	 *     <li>An Array of files to load.</li>
	 * </ol>
	 *
	 * Each "file" in a manifest can be either:
	 * <ul>
	 *     <li>A {{#crossLink "LoadItem"}}{{/crossLink}} instance</li>
	 *     <li>An object containing properties defined by {{#crossLink "LoadItem"}}{{/crossLink}}</li>
	 *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink "LoadItem"}}{{/crossLink}}
	 *     in the background.</li>
	 * </ul>
	 *
	 * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default
	 * value is true. If the queue is paused using {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}} and this value is
	 * `true`, the queue will resume automatically.
	 * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the
	 * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink "LoadQueue/MANIFEST:property"}}{{/crossLink}},
	 * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>
	 * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue
	 * constructor, or a `path` property in a manifest definition.
	 */
	p.loadManifest = function (manifest, loadNow, basePath) {
		var fileList = null;
		var path = null;

		// Array-based list of items
		if (manifest instanceof Array) {
			if (manifest.length == 0) {
				var event = new createjs.ErrorEvent("PRELOAD_MANIFEST_EMPTY");
				this._sendError(event);
				return;
			}
			fileList = manifest;

			// String-based. Only file manifests can be specified this way. Any other types will cause an error when loaded.
		} else if (typeof(manifest) === "string") {
			fileList = [
				{
					src: manifest,
					type: s.MANIFEST
				}
			];

		} else if (typeof(manifest) == "object") {

			// An object that defines a manifest path
			if (manifest.src !== undefined) {
				if (manifest.type == null) {
					manifest.type = s.MANIFEST;
				} else if (manifest.type != s.MANIFEST) {
					var event = new createjs.ErrorEvent("PRELOAD_MANIFEST_TYPE");
					this._sendError(event);
				}
				fileList = [manifest];

				// An object that defines a manifest
			} else if (manifest.manifest !== undefined) {
				fileList = manifest.manifest;
				path = manifest.path;
			}

			// Unsupported. This will throw an error.
		} else {
			var event = new createjs.ErrorEvent("PRELOAD_MANIFEST_NULL");
			this._sendError(event);
			return;
		}

		for (var i = 0, l = fileList.length; i < l; i++) {
			this._addItem(fileList[i], path, basePath);
		}

		if (loadNow !== false) {
			this.setPaused(false);
		} else {
			this.setPaused(true);
		}

	};

	/**
	 * Start a LoadQueue that was created, but not automatically started.
	 * @method load
	 */
	p.load = function () {
		this.setPaused(false);
	};

	/**
	 * Look up a {{#crossLink "LoadItem"}}{{/crossLink}} using either the "id" or "src" that was specified when loading it. Note that if no "id" was
	 * supplied with the load item, the ID will be the "src", including a `path` property defined by a manifest. The
	 * `basePath` will not be part of the ID.
	 * @method getItem
	 * @param {String} value The <code>id</code> or <code>src</code> of the load item.
	 * @return {Object} The load item that was initially requested using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. This object is also returned via the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}
	 * event as the `item` parameter.
	 */
	p.getItem = function (value) {
		return this._loadItemsById[value] || this._loadItemsBySrc[value];
	};

	/**
	 * Look up a loaded result using either the "id" or "src" that was specified when loading it. Note that if no "id"
	 * was supplied with the load item, the ID will be the "src", including a `path` property defined by a manifest. The
	 * `basePath` will not be part of the ID.
	 * @method getResult
	 * @param {String} value The <code>id</code> or <code>src</code> of the load item.
	 * @param {Boolean} [rawResult=false] Return a raw result instead of a formatted result. This applies to content
	 * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be
	 * returned instead.
	 * @return {Object} A result object containing the content that was loaded, such as:
	 * <ul>
	 *      <li>An image tag (&lt;image /&gt;) for images</li>
	 *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts are automatically added to the HTML
	 *      DOM.</li>
	 *      <li>A style tag for CSS (&lt;style /&gt; or &lt;link &gt;)</li>
	 *      <li>Raw text for TEXT</li>
	 *      <li>A formatted JavaScript object defined by JSON</li>
	 *      <li>An XML document</li>
	 *      <li>A binary arraybuffer loaded by XHR</li>
	 *      <li>An audio tag (&lt;audio &gt;) for HTML audio. Note that it is recommended to use SoundJS APIs to play
	 *      loaded audio. Specifically, audio loaded by Flash and WebAudio will return a loader object using this method
	 *      which can not be used to play audio back.</li>
	 * </ul>
	 * This object is also returned via the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event as the 'item`
	 * parameter. Note that if a raw result is requested, but not found, the result will be returned instead.
	 */
	p.getResult = function (value, rawResult) {
		var item = this._loadItemsById[value] || this._loadItemsBySrc[value];
		if (item == null) {
			return null;
		}
		var id = item.id;
		if (rawResult && this._loadedRawResults[id]) {
			return this._loadedRawResults[id];
		}
		return this._loadedResults[id];
	};

	/**
	 * Generate an list of items loaded by this queue.
	 * @method getItems
	 * @param {Boolean} loaded Determines if only items that have been loaded should be returned. If false, in-progress
	 * and failed load items will also be included.
	 * @returns {Array} A list of objects that have been loaded. Each item includes the {{#crossLink "LoadItem"}}{{/crossLink}},
	 * result, and rawResult.
	 * @since 0.6.0
	 */
	p.getItems = function (loaded) {
		var arr = [];
		for (var n in this._loadItemsById) {
			var item = this._loadItemsById[n];
			var result = this.getResult(n);
			if (loaded === true && result == null) {
				continue;
			}
			arr.push({
				item: item,
				result: result,
				rawResult: this.getResult(n, true)
			});
		}
		return arr;
	};

	/**
	 * Pause or resume the current load. Active loads will not be cancelled, but the next items in the queue will not
	 * be processed when active loads complete. LoadQueues are not paused by default.
	 *
	 * Note that if new items are added to the queue using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or
	 * {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}, a paused queue will be resumed, unless the `loadNow`
	 * argument is `false`.
	 * @method setPaused
	 * @param {Boolean} value Whether the queue should be paused or not.
	 */
	p.setPaused = function (value) {
		this._paused = value;
		if (!this._paused) {
			this._loadNext();
		}
	};

	/**
	 * Close the active queue. Closing a queue completely empties the queue, and prevents any remaining items from
	 * starting to download. Note that currently any active loads will remain open, and events may be processed.
	 *
	 * To stop and restart a queue, use the {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}} method instead.
	 * @method close
	 */
	p.close = function () {
		while (this._currentLoads.length) {
			this._currentLoads.pop().cancel();
		}
		this._scriptOrder.length = 0;
		this._loadedScripts.length = 0;
		this.loadStartWasDispatched = false;
		this._itemCount = 0;
		this._lastProgress = NaN;
	};

// protected methods
	/**
	 * Add an item to the queue. Items are formatted into a usable object containing all the properties necessary to
	 * load the content. The load queue is populated with the loader instance that handles preloading, and not the load
	 * item that was passed in by the user. To look up the load item by id or src, use the {{#crossLink "LoadQueue.getItem"}}{{/crossLink}}
	 * method.
	 * @method _addItem
	 * @param {String|Object} value The item to add to the queue.
	 * @param {String} [path] An optional path prepended to the `src`. The path will only be prepended if the src is
	 * relative, and does not start with a protocol such as `http://`, or a path like `../`. If the LoadQueue was
	 * provided a {{#crossLink "_basePath"}}{{/crossLink}}, then it will optionally be prepended after.
	 * @param {String} [basePath] <strong>Deprecated</strong>An optional basePath passed into a {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} call. This parameter will be removed in a future tagged
	 * version.
	 * @private
	 */
	p._addItem = function (value, path, basePath) {
		var item = this._createLoadItem(value, path, basePath); // basePath and manifest path are added to the src.
		if (item == null) {
			return;
		} // Sometimes plugins or types should be skipped.
		var loader = this._createLoader(item);
		if (loader != null) {
			if ("plugins" in loader) {
				loader.plugins = this._plugins;
			}
			item._loader = loader;
			this._loadQueue.push(loader);
			this._loadQueueBackup.push(loader);

			this._numItems++;
			this._updateProgress();

			// Only worry about script order when using XHR to load scripts. Tags are only loading one at a time.
			if ((this.maintainScriptOrder
					&& item.type == createjs.LoadQueue.JAVASCRIPT
						//&& loader instanceof createjs.XHRLoader //NOTE: Have to track all JS files this way
					)
					|| item.maintainOrder === true) {
				this._scriptOrder.push(item);
				this._loadedScripts.push(null);
			}
		}
	};

	/**
	 * Create a refined {{#crossLink "LoadItem"}}{{/crossLink}}, which contains all the required properties. The type of
	 * item is determined by browser support, requirements based on the file type, and developer settings. For example,
	 * XHR is only used for file types that support it in new browsers.
	 *
	 * Before the item is returned, any plugins registered to handle the type or extension will be fired, which may
	 * alter the load item.
	 * @method _createLoadItem
	 * @param {String | Object | HTMLAudioElement | HTMLImageElement} value The item that needs to be preloaded.
	 * @param {String} [path] A path to prepend to the item's source. Sources beginning with http:// or similar will
	 * not receive a path. Since PreloadJS 0.4.1, the src will be modified to include the `path` and {{#crossLink "LoadQueue/_basePath:property"}}{{/crossLink}}
	 * when it is added.
	 * @param {String} [basePath] <strong>Deprectated</strong> A base path to prepend to the items source in addition to
	 * the path argument.
	 * @return {Object} The loader instance that will be used.
	 * @private
	 */
	p._createLoadItem = function (value, path, basePath) {
		var item = createjs.LoadItem.create(value);
		if (item == null) {
			return null;
		}

		var bp = ""; // Store the generated basePath
		var useBasePath = basePath || this._basePath;

		if (item.src instanceof Object) {
			if (!item.type) {
				return null;
			} // the the src is an object, type is required to pass off to plugin
			if (path) {
				bp = path;
				var pathMatch = createjs.RequestUtils.parseURI(path);
				// Also append basePath
				if (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {
					bp = useBasePath + bp;
				}
			} else if (useBasePath != null) {
				bp = useBasePath;
			}
		} else {
			// Determine Extension, etc.
			var match = createjs.RequestUtils.parseURI(item.src);
			if (match.extension) {
				item.ext = match.extension;
			}
			if (item.type == null) {
				item.type = createjs.RequestUtils.getTypeByExtension(item.ext);
			}

			// Inject path & basePath
			var autoId = item.src;
			if (!match.absolute && !match.relative) {
				if (path) {
					bp = path;
					var pathMatch = createjs.RequestUtils.parseURI(path);
					autoId = path + autoId;
					// Also append basePath
					if (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {
						bp = useBasePath + bp;
					}
				} else if (useBasePath != null) {
					bp = useBasePath;
				}
			}
			item.src = bp + item.src;
		}
		item.path = bp;

		// If there's no id, set one now.
		if (item.id === undefined || item.id === null || item.id === "") {
			item.id = autoId;
		}

		// Give plugins a chance to modify the loadItem:
		var customHandler = this._typeCallbacks[item.type] || this._extensionCallbacks[item.ext];
		if (customHandler) {
			// Plugins are now passed both the full source, as well as a combined path+basePath (appropriately)
			var result = customHandler.callback.call(customHandler.scope, item, this);

			// The plugin will handle the load, or has canceled it. Ignore it.
			if (result === false) {
				return null;

				// Load as normal:
			} else if (result === true) {
				// Do Nothing

				// Result is a loader class:
			} else if (result != null) {
				item._loader = result;
			}

			// Update the extension in case the type changed:
			match = createjs.RequestUtils.parseURI(item.src);
			if (match.extension != null) {
				item.ext = match.extension;
			}
		}

		// Store the item for lookup. This also helps clean-up later.
		this._loadItemsById[item.id] = item;
		this._loadItemsBySrc[item.src] = item;

		if (item.crossOrigin == null) {
			item.crossOrigin = this._crossOrigin;
		}

		return item;
	};

	/**
	 * Create a loader for a load item.
	 * @method _createLoader
	 * @param {Object} item A formatted load item that can be used to generate a loader.
	 * @return {AbstractLoader} A loader that can be used to load content.
	 * @private
	 */
	p._createLoader = function (item) {
		if (item._loader != null) { // A plugin already specified a loader
			return item._loader;
		}

		// Initially, try and use the provided/supported XHR mode:
		var preferXHR = this.preferXHR;

		for (var i = 0; i < this._availableLoaders.length; i++) {
			var loader = this._availableLoaders[i];
			if (loader && loader.canLoadItem(item)) {
				return new loader(item, preferXHR);
			}
		}

		// TODO: Log error (requires createjs.log)
		return null;
	};

	/**
	 * Load the next item in the queue. If the queue is empty (all items have been loaded), then the complete event
	 * is processed. The queue will "fill up" any empty slots, up to the max connection specified using
	 * {{#crossLink "LoadQueue.setMaxConnections"}}{{/crossLink}} method. The only exception is scripts that are loaded
	 * using tags, which have to be loaded one at a time to maintain load order.
	 * @method _loadNext
	 * @private
	 */
	p._loadNext = function () {
		if (this._paused) {
			return;
		}

		// Only dispatch loadstart event when the first file is loaded.
		if (!this._loadStartWasDispatched) {
			this._sendLoadStart();
			this._loadStartWasDispatched = true;
		}

		// The queue has completed.
		if (this._numItems == this._numItemsLoaded) {
			this.loaded = true;
			this._sendComplete();

			// Load the next queue, if it has been defined.
			if (this.next && this.next.load) {
				this.next.load();
			}
		} else {
			this.loaded = false;
		}

		// Must iterate forwards to load in the right order.
		for (var i = 0; i < this._loadQueue.length; i++) {
			if (this._currentLoads.length >= this._maxConnections) {
				break;
			}
			var loader = this._loadQueue[i];

			// Determine if we should be only loading one tag-script at a time:
			// Note: maintainOrder items don't do anything here because we can hold onto their loaded value
			if (!this._canStartLoad(loader)) {
				continue;
			}
			this._loadQueue.splice(i, 1);
			i--;
			this._loadItem(loader);
		}
	};

	/**
	 * Begin loading an item. Event listeners are not added to the loaders until the load starts.
	 * @method _loadItem
	 * @param {AbstractLoader} loader The loader instance to start. Currently, this will be an XHRLoader or TagLoader.
	 * @private
	 */
	p._loadItem = function (loader) {
		loader.on("fileload", this._handleFileLoad, this);
		loader.on("progress", this._handleProgress, this);
		loader.on("complete", this._handleFileComplete, this);
		loader.on("error", this._handleError, this);
		loader.on("fileerror", this._handleFileError, this);
		this._currentLoads.push(loader);
		this._sendFileStart(loader.getItem());
		loader.load();
	};

	/**
	 * The callback that is fired when a loader loads a file. This enables loaders like {{#crossLink "ManifestLoader"}}{{/crossLink}}
	 * to maintain internal queues, but for this queue to dispatch the {{#crossLink "fileload:event"}}{{/crossLink}}
	 * events.
	 * @param {Event} event The {{#crossLink "AbstractLoader/fileload:event"}}{{/crossLink}} event from the loader.
	 * @private
	 * @since 0.6.0
	 */
	p._handleFileLoad = function (event) {
		event.target = null;
		this.dispatchEvent(event);
	};

	/**
	 * The callback that is fired when a loader encounters an error from an internal file load operation. This enables
	 * loaders like M
	 * @param event
	 * @private
	 */
	p._handleFileError = function (event) {
		var newEvent = new createjs.ErrorEvent("FILE_LOAD_ERROR", null, event.item);
		this._sendError(newEvent);
	};

	/**
	 * The callback that is fired when a loader encounters an error. The queue will continue loading unless {{#crossLink "LoadQueue/stopOnError:property"}}{{/crossLink}}
	 * is set to `true`.
	 * @method _handleError
	 * @param {ErrorEvent} event The error event, containing relevant error information.
	 * @private
	 */
	p._handleError = function (event) {
		var loader = event.target;
		this._numItemsLoaded++;

		this._finishOrderedItem(loader, true);
		this._updateProgress();

		var newEvent = new createjs.ErrorEvent("FILE_LOAD_ERROR", null, loader.getItem());
		// TODO: Propagate actual error message.

		this._sendError(newEvent);

		if (!this.stopOnError) {
			this._removeLoadItem(loader);
			this._cleanLoadItem(loader);
			this._loadNext();
		} else {
			this.setPaused(true);
		}
	};

	/**
	 * An item has finished loading. We can assume that it is totally loaded, has been parsed for immediate use, and
	 * is available as the "result" property on the load item. The raw text result for a parsed item (such as JSON, XML,
	 * CSS, JavaScript, etc) is available as the "rawResult" property, and can also be looked up using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}.
	 * @method _handleFileComplete
	 * @param {Event} event The event object from the loader.
	 * @private
	 */
	p._handleFileComplete = function (event) {
		var loader = event.target;
		var item = loader.getItem();

		var result = loader.getResult();
		this._loadedResults[item.id] = result;
		var rawResult = loader.getResult(true);
		if (rawResult != null && rawResult !== result) {
			this._loadedRawResults[item.id] = rawResult;
		}

		this._saveLoadedItems(loader);

		// Remove the load item
		this._removeLoadItem(loader);

		if (!this._finishOrderedItem(loader)) {
			// The item was NOT managed, so process it now
			this._processFinishedLoad(item, loader);
		}

		// Clean up the load item
		this._cleanLoadItem(loader);
	};

	/**
	 * Some loaders might load additional content, other than the item they were passed (such as {{#crossLink "ManifestLoader"}}{{/crossLink}}).
	 * Any items exposed by the loader using {{#crossLink "AbstractLoader/getLoadItems"}}{{/crossLink}} are added to the
	 * LoadQueue's look-ups, including {{#crossLink "getItem"}}{{/crossLink}} and {{#crossLink "getResult"}}{{/crossLink}}
	 * methods.
	 * @method _saveLoadedItems
	 * @param {AbstractLoader} loader
	 * @protected
	 * @since 0.6.0
	 */
	p._saveLoadedItems = function (loader) {
		// TODO: Not sure how to handle this. Would be nice to expose the items.
		// Loaders may load sub-items. This adds them to this queue
		var list = loader.getLoadedItems();
		if (list === null) {
			return;
		}

		for (var i = 0; i < list.length; i++) {
			var item = list[i].item;

			// Store item lookups
			this._loadItemsBySrc[item.src] = item;
			this._loadItemsById[item.id] = item;

			// Store loaded content
			this._loadedResults[item.id] = list[i].result;
			this._loadedRawResults[item.id] = list[i].rawResult;
		}
	};

	/**
	 * Flag an item as finished. If the item's order is being managed, then ensure that it is allowed to finish, and if
	 * so, trigger prior items to trigger as well.
	 * @method _finishOrderedItem
	 * @param {AbstractLoader} loader
	 * @param {Boolean} loadFailed
	 * @return {Boolean} If the item's order is being managed. This allows the caller to take an alternate
	 * behaviour if it is.
	 * @private
	 */
	p._finishOrderedItem = function (loader, loadFailed) {
		var item = loader.getItem();

		if ((this.maintainScriptOrder && item.type == createjs.LoadQueue.JAVASCRIPT)
				|| item.maintainOrder) {

			//TODO: Evaluate removal of the _currentlyLoadingScript
			if (loader instanceof createjs.JavaScriptLoader) {
				this._currentlyLoadingScript = false;
			}

			var index = createjs.indexOf(this._scriptOrder, item);
			if (index == -1) {
				return false;
			} // This loader no longer exists
			this._loadedScripts[index] = (loadFailed === true) ? true : item;

			this._checkScriptLoadOrder();
			return true;
		}

		return false;
	};

	/**
	 * Ensure the scripts load and dispatch in the correct order. When using XHR, scripts are stored in an array in the
	 * order they were added, but with a "null" value. When they are completed, the value is set to the load item,
	 * and then when they are processed and dispatched, the value is set to `true`. This method simply
	 * iterates the array, and ensures that any loaded items that are not preceded by a `null` value are
	 * dispatched.
	 * @method _checkScriptLoadOrder
	 * @private
	 */
	p._checkScriptLoadOrder = function () {
		var l = this._loadedScripts.length;

		for (var i = 0; i < l; i++) {
			var item = this._loadedScripts[i];
			if (item === null) {
				break;
			} // This is still loading. Do not process further.
			if (item === true) {
				continue;
			} // This has completed, and been processed. Move on.

			var loadItem = this._loadedResults[item.id];
			if (item.type == createjs.LoadQueue.JAVASCRIPT) {
				// Append script tags to the head automatically.
				createjs.DomUtils.appendToHead(loadItem);
			}

			var loader = item._loader;
			this._processFinishedLoad(item, loader);
			this._loadedScripts[i] = true;
		}
	};

	/**
	 * A file has completed loading, and the LoadQueue can move on. This triggers the complete event, and kick-starts
	 * the next item.
	 * @method _processFinishedLoad
	 * @param {LoadItem|Object} item
	 * @param {AbstractLoader} loader
	 * @protected
	 */
	p._processFinishedLoad = function (item, loader) {
		this._numItemsLoaded++;

		// Since LoadQueue needs maintain order, we can't append scripts in the loader.
		// So we do it here instead. Or in _checkScriptLoadOrder();
		if (!this.maintainScriptOrder && item.type == createjs.LoadQueue.JAVASCRIPT) {
			createjs.DomUtils.appendToHead(item.result);
		}

		this._updateProgress();
		this._sendFileComplete(item, loader);
		this._loadNext();
	};

	/**
	 * Ensure items with `maintainOrder=true` that are before the specified item have loaded. This only applies to
	 * JavaScript items that are being loaded with a TagLoader, since they have to be loaded and completed <strong>before</strong>
	 * the script can even be started, since it exist in the DOM while loading.
	 * @method _canStartLoad
	 * @param {AbstractLoader} loader The loader for the item
	 * @return {Boolean} Whether the item can start a load or not.
	 * @private
	 */
	p._canStartLoad = function (loader) {
		if (!this.maintainScriptOrder || loader.preferXHR) {
			return true;
		}
		var item = loader.getItem();
		if (item.type != createjs.LoadQueue.JAVASCRIPT) {
			return true;
		}
		if (this._currentlyLoadingScript) {
			return false;
		}

		var index = this._scriptOrder.indexOf(item);
		var i = 0;
		while (i < index) {
			var checkItem = this._loadedScripts[i];
			if (checkItem == null) {
				return false;
			}
			i++;
		}
		this._currentlyLoadingScript = true;
		return true;
	};

	/**
	 * A load item is completed or was canceled, and needs to be removed from the LoadQueue.
	 * @method _removeLoadItem
	 * @param {AbstractLoader} loader A loader instance to remove.
	 * @private
	 */
	p._removeLoadItem = function (loader) {
		var l = this._currentLoads.length;
		for (var i = 0; i < l; i++) {
			if (this._currentLoads[i] == loader) {
				this._currentLoads.splice(i, 1);
				break;
			}
		}
	};

	/**
	 * Remove unneeded references from a loader.
	 *
	 * @param loader
	 * @private
	 */
	p._cleanLoadItem = function(loader) {
		var item = loader.getItem();
		if (item) {
			delete item._loader;
		}
	}

	/**
	 * An item has dispatched progress. Propagate that progress, and update the LoadQueue's overall progress.
	 * @method _handleProgress
	 * @param {ProgressEvent} event The progress event from the item.
	 * @private
	 */
	p._handleProgress = function (event) {
		var loader = event.target;
		this._sendFileProgress(loader.getItem(), loader.progress);
		this._updateProgress();
	};

	/**
	 * Overall progress has changed, so determine the new progress amount and dispatch it. This changes any time an
	 * item dispatches progress or completes. Note that since we don't always know the actual filesize of items before
	 * they are loaded. In this case, we define a "slot" for each item (1 item in 10 would get 10%), and then append
	 * loaded progress on top of the already-loaded items.
	 *
	 * For example, if 5/10 items have loaded, and item 6 is 20% loaded, the total progress would be:
	 * <ul>
	 *      <li>5/10 of the items in the queue (50%)</li>
	 *      <li>plus 20% of item 6's slot (2%)</li>
	 *      <li>equals 52%</li>
	 * </ul>
	 * @method _updateProgress
	 * @private
	 */
	p._updateProgress = function () {
		var loaded = this._numItemsLoaded / this._numItems; // Fully Loaded Progress
		var remaining = this._numItems - this._numItemsLoaded;
		if (remaining > 0) {
			var chunk = 0;
			for (var i = 0, l = this._currentLoads.length; i < l; i++) {
				chunk += this._currentLoads[i].progress;
			}
			loaded += (chunk / remaining) * (remaining / this._numItems);
		}

		if (this._lastProgress != loaded) {
			this._sendProgress(loaded);
			this._lastProgress = loaded;
		}
	};

	/**
	 * Clean out item results, to free them from memory. Mainly, the loaded item and results are cleared from internal
	 * hashes.
	 * @method _disposeItem
	 * @param {LoadItem|Object} item The item that was passed in for preloading.
	 * @private
	 */
	p._disposeItem = function (item) {
		delete this._loadedResults[item.id];
		delete this._loadedRawResults[item.id];
		delete this._loadItemsById[item.id];
		delete this._loadItemsBySrc[item.src];
	};

	/**
	 * Dispatch a "fileprogress" {{#crossLink "Event"}}{{/crossLink}}. Please see the LoadQueue {{#crossLink "LoadQueue/fileprogress:event"}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendFileProgress
	 * @param {LoadItem|Object} item The item that is being loaded.
	 * @param {Number} progress The amount the item has been loaded (between 0 and 1).
	 * @protected
	 */
	p._sendFileProgress = function (item, progress) {
		if (this._isCanceled() || this._paused) {
			return;
		}
		if (!this.hasEventListener("fileprogress")) {
			return;
		}

		//LM: Rework ProgressEvent to support this?
		var event = new createjs.Event("fileprogress");
		event.progress = progress;
		event.loaded = progress;
		event.total = 1;
		event.item = item;

		this.dispatchEvent(event);
	};

	/**
	 * Dispatch a fileload {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event for
	 * details on the event payload.
	 * @method _sendFileComplete
	 * @param {LoadItemObject} item The item that is being loaded.
	 * @param {AbstractLoader} loader
	 * @protected
	 */
	p._sendFileComplete = function (item, loader) {
		if (this._isCanceled() || this._paused) {
			return;
		}

		var event = new createjs.Event("fileload");
		event.loader = loader;
		event.item = item;
		event.result = this._loadedResults[item.id];
		event.rawResult = this._loadedRawResults[item.id];

		// This calls a handler specified on the actual load item. Currently, the SoundJS plugin uses this.
		if (item.completeHandler) {
			item.completeHandler(event);
		}

		this.hasEventListener("fileload") && this.dispatchEvent(event);
	};

	/**
	 * Dispatch a filestart {{#crossLink "Event"}}{{/crossLink}} immediately before a file starts to load. Please see
	 * the {{#crossLink "LoadQueue/filestart:event"}}{{/crossLink}} event for details on the event payload.
	 * @method _sendFileStart
	 * @param {LoadItem|Object} item The item that is being loaded.
	 * @protected
	 */
	p._sendFileStart = function (item) {
		var event = new createjs.Event("filestart");
		event.item = item;
		this.hasEventListener("filestart") && this.dispatchEvent(event);
	};

	p.toString = function () {
		return "[PreloadJS LoadQueue]";
	};

	createjs.LoadQueue = createjs.promote(LoadQueue, "AbstractLoader");
}());

//##############################################################################
// TextLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for Text files.
	 * @class TextLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function TextLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.TEXT);
	};

	var p = createjs.extend(TextLoader, createjs.AbstractLoader);
	var s = TextLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader loads items that are of type {{#crossLink "AbstractLoader/TEXT:property"}}{{/crossLink}},
	 * but is also the default loader if a file type can not be determined.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.TEXT;
	};

	createjs.TextLoader = createjs.promote(TextLoader, "AbstractLoader");

}());

//##############################################################################
// BinaryLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for binary files. This is useful for loading web audio, or content that requires an ArrayBuffer.
	 * @class BinaryLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function BinaryLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.BINARY);
		this.on("initialize", this._updateXHR, this);
	};

	var p = createjs.extend(BinaryLoader, createjs.AbstractLoader);
	var s = BinaryLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/BINARY:property"}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.BINARY;
	};

	// private methods
	/**
	 * Before the item loads, set the response type to "arraybuffer"
	 * @property _updateXHR
	 * @param {Event} event
	 * @private
	 */
	p._updateXHR = function (event) {
		event.loader.setResponseType("arraybuffer");
	};

	createjs.BinaryLoader = createjs.promote(BinaryLoader, "AbstractLoader");

}());

//##############################################################################
// CSSLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for CSS files.
	 * @class CSSLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractLoader
	 * @constructor
	 */
	function CSSLoader(loadItem, preferXHR) {
		this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.CSS);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = "href";

		if (preferXHR) {
			this._tag = document.createElement("style");
		} else {
			this._tag = document.createElement("link");
		}

		this._tag.rel = "stylesheet";
		this._tag.type = "text/css";
	};

	var p = createjs.extend(CSSLoader, createjs.AbstractLoader);
	var s = CSSLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/CSS:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.CSS;
	};

	// protected methods
	/**
	 * The result formatter for CSS files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLLinkElement|HTMLStyleElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		if (this._preferXHR) {
			var tag = loader.getTag();

			if (tag.styleSheet) { // IE
				tag.styleSheet.cssText = loader.getResult(true);
			} else {
				var textNode = document.createTextNode(loader.getResult(true));
				tag.appendChild(textNode);
			}
		} else {
			tag = this._tag;
		}

		createjs.DomUtils.appendToHead(tag);

		return tag;
	};

	createjs.CSSLoader = createjs.promote(CSSLoader, "AbstractLoader");

}());

//##############################################################################
// ImageLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for image files.
	 * @class ImageLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractLoader
	 * @constructor
	 */
	function ImageLoader (loadItem, preferXHR) {
		this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.IMAGE);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = "src";

		// Check if the preload item is already a tag.
		if (createjs.RequestUtils.isImageTag(loadItem)) {
			this._tag = loadItem;
		} else if (createjs.RequestUtils.isImageTag(loadItem.src)) {
			this._tag = loadItem.src;
		} else if (createjs.RequestUtils.isImageTag(loadItem.tag)) {
			this._tag = loadItem.tag;
		}

		if (this._tag != null) {
			this._preferXHR = false;
		} else {
			this._tag = document.createElement("img");
		}

		this.on("initialize", this._updateXHR, this);
	};

	var p = createjs.extend(ImageLoader, createjs.AbstractLoader);
	var s = ImageLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/IMAGE:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.IMAGE;
	};

	// public methods
	p.load = function () {
		if (this._tag.src != "" && this._tag.complete) {
			this._sendComplete();
			return;
		}

		var crossOrigin = this._item.crossOrigin;
		if (crossOrigin == true) { crossOrigin = "Anonymous"; }
		if (crossOrigin != null && !createjs.RequestUtils.isLocal(this._item.src)) {
			this._tag.crossOrigin = crossOrigin;
		}

		this.AbstractLoader_load();
	};

	// protected methods
	/**
	 * Before the item loads, set its mimeType and responseType.
	 * @property _updateXHR
	 * @param {Event} event
	 * @private
	 */
	p._updateXHR = function (event) {
		event.loader.mimeType = 'text/plain; charset=x-user-defined-binary';

		// Only exists for XHR
		if (event.loader.setResponseType) {
			event.loader.setResponseType("blob");
		}
	};

	/**
	 * The result formatter for Image files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLImageElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		var _this = this;
		return function (done) {
			var tag = _this._tag;
			var URL = window.URL || window.webkitURL;

			if (!_this._preferXHR) {
				//document.body.removeChild(tag);
			} else if (URL) {
				var objURL = URL.createObjectURL(loader.getResult(true));
				tag.src = objURL;
				tag.onload = function () {
					URL.revokeObjectURL(_this.src);
				}
			} else {
				tag.src = loader.getItem().src;
			}

			if (tag.complete) {
				done(tag);
			} else {
				tag.onload = function () {
					done(this);
				}
			}
		};
	};

	createjs.ImageLoader = createjs.promote(ImageLoader, "AbstractLoader");

}());

//##############################################################################
// JavaScriptLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for JavaScript files.
	 * @class JavaScriptLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractLoader
	 * @constructor
	 */
	function JavaScriptLoader(loadItem, preferXHR) {
		this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.JAVASCRIPT);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = "src";
		this.setTag(document.createElement("script"));
	};

	var p = createjs.extend(JavaScriptLoader, createjs.AbstractLoader);
	var s = JavaScriptLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.JAVASCRIPT;
	};

	// protected methods
	/**
	 * The result formatter for JavaScript files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLLinkElement|HTMLStyleElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		var tag = loader.getTag();
		if (this._preferXHR) {
			tag.text = loader.getResult(true);
		}
		return tag;
	};

	createjs.JavaScriptLoader = createjs.promote(JavaScriptLoader, "AbstractLoader");

}());

//##############################################################################
// JSONLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for JSON files. To load JSON cross-domain, use JSONP and the {{#crossLink "JSONPLoader"}}{{/crossLink}}
	 * instead. To load JSON-formatted manifests, use {{#crossLink "ManifestLoader"}}{{/crossLink}}, and to
	 * load EaselJS SpriteSheets, use {{#crossLink "SpriteSheetLoader"}}{{/crossLink}}.
	 * @class JSONLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function JSONLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.JSON);

		// public properties
		this.resultFormatter = this._formatResult;
	};

	var p = createjs.extend(JSONLoader, createjs.AbstractLoader);
	var s = JSONLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/JSON:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.JSON && !item._loadAsJSONP;
	};

	// protected methods
	/**
	 * The result formatter for JSON files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLLinkElement|HTMLStyleElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		var json = null;
		try {
			json = createjs.DataUtils.parseJSON(loader.getResult(true));
		} catch (e) {
			var event = new createjs.ErrorEvent("JSON_FORMAT", null, e);
			this._sendError(event);
			return e;
		}

		return json;
	};

	createjs.JSONLoader = createjs.promote(JSONLoader, "AbstractLoader");

}());

//##############################################################################
// JSONPLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for JSONP files, which are JSON-formatted text files, wrapped in a callback. To load regular JSON
	 * without a callback use the {{#crossLink "JSONLoader"}}{{/crossLink}} instead. To load JSON-formatted manifests,
	 * use {{#crossLink "ManifestLoader"}}{{/crossLink}}, and to load EaselJS SpriteSheets, use
	 * {{#crossLink "SpriteSheetLoader"}}{{/crossLink}}.
	 *
	 * Note that JSONP files loaded concurrently require a <em>unique</em> callback. To ensure JSONP files are loaded
	 * in order, either use the {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}} method (set to 1),
	 * or set {{#crossLink "LoadItem/maintainOrder:property"}}{{/crossLink}} on items with the same callback.
	 * @class JSONPLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function JSONPLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, false, createjs.AbstractLoader.JSONP);
		this.setTag(document.createElement("script"));
		this.getTag().type = "text/javascript";
	};

	var p = createjs.extend(JSONPLoader, createjs.AbstractLoader);
	var s = JSONPLoader;


	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/JSONP:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.JSONP || item._loadAsJSONP;
	};

	// public methods
	p.cancel = function () {
		this.AbstractLoader_cancel();
		this._dispose();
	};

	/**
	 * Loads the JSONp file.  Because of the unique loading needs of jsonP
	 * we don't use the AbstractLoader.load() method.
	 *
	 * @method load
	 *
	 */
	p.load = function () {
		if (this._item.callback == null) {
			throw new Error('callback is required for loading JSONP requests.');
		}

		// TODO: Look into creating our own iFrame to handle the load
		// In the first attempt, FF did not get the result
		//   result instanceof Object did not work either
		//   so we would need to clone the result.
		if (window[this._item.callback] != null) {
			throw new Error(
				"JSONP callback '" +
				this._item.callback +
				"' already exists on window. You need to specify a different callback or re-name the current one.");
		}

		window[this._item.callback] = createjs.proxy(this._handleLoad, this);
		window.document.body.appendChild(this._tag);

		this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);

		// Load the tag
		this._tag.src = this._item.src;
	};

	// private methods
	/**
	 * Handle the JSONP callback, which is a public method defined on `window`.
	 * @method _handleLoad
	 * @param {Object} data The formatted JSON data.
	 * @private
	 */
	p._handleLoad = function (data) {
		this._result = this._rawResult = data;
		this._sendComplete();

		this._dispose();
	};

	/**
	 * The tag request has not loaded within the time specfied in loadTimeout.
	 * @method _handleError
	 * @param {Object} event The XHR error event.
	 * @private
	 */
	p._handleTimeout = function () {
		this._dispose();
		this.dispatchEvent(new createjs.ErrorEvent("timeout"));
	};

	/**
	 * Clean up the JSONP load. This clears out the callback and script tag that this loader creates.
	 * @method _dispose
	 * @private
	 */
	p._dispose = function () {
		window.document.body.removeChild(this._tag);
		delete window[this._item.callback];

		clearTimeout(this._loadTimeout);
	};

	createjs.JSONPLoader = createjs.promote(JSONPLoader, "AbstractLoader");

}());

//##############################################################################
// ManifestLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for JSON manifests. Items inside the manifest are loaded before the loader completes. To load manifests
	 * using JSONP, specify a {{#crossLink "LoadItem/callback:property"}}{{/crossLink}} as part of the
	 * {{#crossLink "LoadItem"}}{{/crossLink}}.
	 *
	 * The list of files in the manifest must be defined on the top-level JSON object in a `manifest` property. This
	 * example shows a sample manifest definition, as well as how to to include a sub-manifest.
	 *
	 * 		{
	 * 			"path": "assets/",
	 *	 	    "manifest": [
	 *				"image.png",
	 *				{"src": "image2.png", "id":"image2"},
	 *				{"src": "sub-manifest.json", "type":"manifest", "callback":"jsonCallback"}
	 *	 	    ]
	 *	 	}
	 *
	 * When a ManifestLoader has completed loading, the parent loader (usually a {{#crossLink "LoadQueue"}}{{/crossLink}},
	 * but could also be another ManifestLoader) will inherit all the loaded items, so you can access them directly.
	 *
	 * Note that the {{#crossLink "JSONLoader"}}{{/crossLink}} and {{#crossLink "JSONPLoader"}}{{/crossLink}} are
	 * higher priority loaders, so manifests <strong>must</strong> set the {{#crossLink "LoadItem"}}{{/crossLink}}
	 * {{#crossLink "LoadItem/type:property"}}{{/crossLink}} property to {{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}}.
	 * @class ManifestLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function ManifestLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, null, createjs.AbstractLoader.MANIFEST);

	// Public Properties
		/**
		 * An array of the plugins registered using {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}},
		 * used to pass plugins to new LoadQueues that may be created.
		 * @property _plugins
		 * @type {Array}
		 * @private
		 * @since 0.6.1
		 */
		this.plugins = null;


	// Protected Properties
		/**
		 * An internal {{#crossLink "LoadQueue"}}{{/crossLink}} that loads the contents of the manifest.
		 * @property _manifestQueue
		 * @type {LoadQueue}
		 * @private
		 */
		this._manifestQueue = null;
	};

	var p = createjs.extend(ManifestLoader, createjs.AbstractLoader);
	var s = ManifestLoader;

	// static properties
	/**
	 * The amount of progress that the manifest itself takes up.
	 * @property MANIFEST_PROGRESS
	 * @type {number}
	 * @default 0.25 (25%)
	 * @private
	 * @static
	 */
	s.MANIFEST_PROGRESS = 0.25;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.MANIFEST;
	};

	// public methods
	p.load = function () {
		this.AbstractLoader_load();
	};

	// protected methods
	p._createRequest = function() {
		var callback = this._item.callback;
		if (callback != null) {
			this._request = new createjs.JSONPLoader(this._item);
		} else {
			this._request = new createjs.JSONLoader(this._item);
		}
	};

	p.handleEvent = function (event) {
		switch (event.type) {
			case "complete":
				this._rawResult = event.target.getResult(true);
				this._result = event.target.getResult();
				this._sendProgress(s.MANIFEST_PROGRESS);
				this._loadManifest(this._result);
				return;
			case "progress":
				event.loaded *= s.MANIFEST_PROGRESS;
				this.progress = event.loaded / event.total;
				if (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }
				this._sendProgress(event);
				return;
		}
		this.AbstractLoader_handleEvent(event);
	};

	p.destroy = function() {
		this.AbstractLoader_destroy();
		this._manifestQueue.close();
	};

	/**
	 * Create and load the manifest items once the actual manifest has been loaded.
	 * @method _loadManifest
	 * @param {Object} json
	 * @private
	 */
	p._loadManifest = function (json) {
		if (json && json.manifest) {
			var queue = this._manifestQueue = new createjs.LoadQueue();
			queue.on("fileload", this._handleManifestFileLoad, this);
			queue.on("progress", this._handleManifestProgress, this);
			queue.on("complete", this._handleManifestComplete, this, true);
			queue.on("error", this._handleManifestError, this, true);
			for(var i = 0, l = this.plugins.length; i < l; i++) {	// conserve order of plugins
				queue.installPlugin(this.plugins[i]);
			}
			queue.loadManifest(json);
		} else {
			this._sendComplete();
		}
	};

	/**
	 * An item from the {{#crossLink "_manifestQueue:property"}}{{/crossLink}} has completed.
	 * @method _handleManifestFileLoad
	 * @param {Event} event
	 * @private
	 */
	p._handleManifestFileLoad = function (event) {
		event.target = null;
		this.dispatchEvent(event);
	};

	/**
	 * The manifest has completed loading. This triggers the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}}
	 * {{#crossLink "Event"}}{{/crossLink}} from the ManifestLoader.
	 * @method _handleManifestComplete
	 * @param {Event} event
	 * @private
	 */
	p._handleManifestComplete = function (event) {
		this._loadedItems = this._manifestQueue.getItems(true);
		this._sendComplete();
	};

	/**
	 * The manifest has reported progress.
	 * @method _handleManifestProgress
	 * @param {ProgressEvent} event
	 * @private
	 */
	p._handleManifestProgress = function (event) {
		this.progress = event.progress * (1 - s.MANIFEST_PROGRESS) + s.MANIFEST_PROGRESS;
		this._sendProgress(this.progress);
	};

	/**
	 * The manifest has reported an error with one of the files.
	 * @method _handleManifestError
	 * @param {ErrorEvent} event
	 * @private
	 */
	p._handleManifestError = function (event) {
		var newEvent = new createjs.Event("fileerror");
		newEvent.item = event.data;
		this.dispatchEvent(newEvent);
	};

	createjs.ManifestLoader = createjs.promote(ManifestLoader, "AbstractLoader");

}());

//##############################################################################
// SoundLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for HTML audio files. PreloadJS can not load WebAudio files, as a WebAudio context is required, which
	 * should be created by either a library playing the sound (such as <a href="http://soundjs.com">SoundJS</a>, or an
	 * external framework that handles audio playback. To load content that can be played by WebAudio, use the
	 * {{#crossLink "BinaryLoader"}}{{/crossLink}}, and handle the audio context decoding manually.
	 * @class SoundLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractMediaLoader
	 * @constructor
	 */
	function SoundLoader(loadItem, preferXHR) {
		this.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SOUND);

		// protected properties
		if (createjs.RequestUtils.isAudioTag(loadItem)) {
			this._tag = loadItem;
		} else if (createjs.RequestUtils.isAudioTag(loadItem.src)) {
			this._tag = loadItem;
		} else if (createjs.RequestUtils.isAudioTag(loadItem.tag)) {
			this._tag = createjs.RequestUtils.isAudioTag(loadItem) ? loadItem : loadItem.src;
		}

		if (this._tag != null) {
			this._preferXHR = false;
		}
	};

	var p = createjs.extend(SoundLoader, createjs.AbstractMediaLoader);
	var s = SoundLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/SOUND:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.SOUND;
	};

	// protected methods
	p._createTag = function (src) {
		var tag = document.createElement("audio");
		tag.autoplay = false;
		tag.preload = "none";

		//LM: Firefox fails when this the preload="none" for other tags, but it needs to be "none" to ensure PreloadJS works.
		tag.src = src;
		return tag;
	};

	createjs.SoundLoader = createjs.promote(SoundLoader, "AbstractMediaLoader");

}());

//##############################################################################
// VideoLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for video files.
	 * @class VideoLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractMediaLoader
	 * @constructor
	 */
	function VideoLoader(loadItem, preferXHR) {
		this.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.VIDEO);

		if (createjs.RequestUtils.isVideoTag(loadItem) || createjs.RequestUtils.isVideoTag(loadItem.src)) {
			this.setTag(createjs.RequestUtils.isVideoTag(loadItem)?loadItem:loadItem.src);

			// We can't use XHR for a tag that's passed in.
			this._preferXHR = false;
		} else {
			this.setTag(this._createTag());
		}
	};

	var p = createjs.extend(VideoLoader, createjs.AbstractMediaLoader);
	var s = VideoLoader;

	/**
	 * Create a new video tag
	 *
	 * @returns {HTMLElement}
	 * @private
	 */
	p._createTag = function () {
		return document.createElement("video");
	};

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/VIDEO:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.VIDEO;
	};

	createjs.VideoLoader = createjs.promote(VideoLoader, "AbstractMediaLoader");

}());

//##############################################################################
// SpriteSheetLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for EaselJS SpriteSheets. Images inside the spritesheet definition are loaded before the loader
	 * completes. To load SpriteSheets using JSONP, specify a {{#crossLink "LoadItem/callback:property"}}{{/crossLink}}
	 * as part of the {{#crossLink "LoadItem"}}{{/crossLink}}. Note that the {{#crossLink "JSONLoader"}}{{/crossLink}}
	 * and {{#crossLink "JSONPLoader"}}{{/crossLink}} are higher priority loaders, so SpriteSheets <strong>must</strong>
	 * set the {{#crossLink "LoadItem"}}{{/crossLink}} {{#crossLink "LoadItem/type:property"}}{{/crossLink}} property
	 * to {{#crossLink "AbstractLoader/SPRITESHEET:property"}}{{/crossLink}}.
	 * @class SpriteSheetLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function SpriteSheetLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, null, createjs.AbstractLoader.SPRITESHEET);

		// protected properties
		/**
		 * An internal queue which loads the SpriteSheet's images.
		 * @method _manifestQueue
		 * @type {LoadQueue}
		 * @private
		 */
		this._manifestQueue = null;
	}

	var p = createjs.extend(SpriteSheetLoader, createjs.AbstractLoader);
	var s = SpriteSheetLoader;

	// static properties
	/**
	 * The amount of progress that the manifest itself takes up.
	 * @property SPRITESHEET_PROGRESS
	 * @type {number}
	 * @default 0.25 (25%)
	 * @private
	 * @static
	 */
	s.SPRITESHEET_PROGRESS = 0.25;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/SPRITESHEET:property"}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.SPRITESHEET;
	};

	// public methods
	p.destroy = function() {
		this.AbstractLoader_destroy;
		this._manifestQueue.close();
	};

	// protected methods
	p._createRequest = function() {
		var callback = this._item.callback;
		if (callback != null && callback instanceof Function) {
			this._request = new createjs.JSONPLoader(this._item);
		} else {
			this._request = new createjs.JSONLoader(this._item);
		}
	};

	p.handleEvent = function (event) {
		switch (event.type) {
			case "complete":
				this._rawResult = event.target.getResult(true);
				this._result = event.target.getResult();
				this._sendProgress(s.SPRITESHEET_PROGRESS);
				this._loadManifest(this._result);
				return;
			case "progress":
				event.loaded *= s.SPRITESHEET_PROGRESS;
				this.progress = event.loaded / event.total;
				if (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }
				this._sendProgress(event);
				return;
		}
		this.AbstractLoader_handleEvent(event);
	};

	/**
	 * Create and load the images once the SpriteSheet JSON has been loaded.
	 * @method _loadManifest
	 * @param {Object} json
	 * @private
	 */
	p._loadManifest = function (json) {
		if (json && json.images) {
			var queue = this._manifestQueue = new createjs.LoadQueue();
			queue.on("complete", this._handleManifestComplete, this, true);
			queue.on("fileload", this._handleManifestFileLoad, this);
			queue.on("progress", this._handleManifestProgress, this);
			queue.on("error", this._handleManifestError, this, true);
			queue.loadManifest(json.images);
		}
	};

	/**
	 * An item from the {{#crossLink "_manifestQueue:property"}}{{/crossLink}} has completed.
	 * @method _handleManifestFileLoad
	 * @param {Event} event
	 * @private
	 */
	p._handleManifestFileLoad = function (event) {
		var image = event.result;
		if (image != null) {
			var images = this.getResult().images;
			var pos = images.indexOf(event.item.src);
			images[pos] = image;
		}
	};

	/**
	 * The images have completed loading. This triggers the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}}
	 * {{#crossLink "Event"}}{{/crossLink}} from the SpriteSheetLoader.
	 * @method _handleManifestComplete
	 * @param {Event} event
	 * @private
	 */
	p._handleManifestComplete = function (event) {
		this._result = new createjs.SpriteSheet(this._result);
		this._loadedItems = this._manifestQueue.getItems(true);
		this._sendComplete();
	};

	/**
	 * The images {{#crossLink "LoadQueue"}}{{/crossLink}} has reported progress.
	 * @method _handleManifestProgress
	 * @param {ProgressEvent} event
	 * @private
	 */
	p._handleManifestProgress = function (event) {
		this.progress = event.progress * (1 - s.SPRITESHEET_PROGRESS) + s.SPRITESHEET_PROGRESS;
		this._sendProgress(this.progress);
	};

	/**
	 * An image has reported an error.
	 * @method _handleManifestError
	 * @param {ErrorEvent} event
	 * @private
	 */
	p._handleManifestError = function (event) {
		var newEvent = new createjs.Event("fileerror");
		newEvent.item = event.data;
		this.dispatchEvent(newEvent);
	};

	createjs.SpriteSheetLoader = createjs.promote(SpriteSheetLoader, "AbstractLoader");

}());

//##############################################################################
// SVGLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for SVG files.
	 * @class SVGLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractLoader
	 * @constructor
	 */
	function SVGLoader(loadItem, preferXHR) {
		this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SVG);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = "data";

		if (preferXHR) {
			this.setTag(document.createElement("svg"));
		} else {
			this.setTag(document.createElement("object"));
			this.getTag().type = "image/svg+xml";
		}
	};

	var p = createjs.extend(SVGLoader, createjs.AbstractLoader);
	var s = SVGLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/SVG:property"}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.SVG;
	};

	// protected methods
	/**
	 * The result formatter for SVG files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {Object}
	 * @private
	 */
	p._formatResult = function (loader) {
		// mime should be image/svg+xml, but Opera requires text/xml
		var xml = createjs.DataUtils.parseXML(loader.getResult(true), "text/xml");
		var tag = loader.getTag();

		if (!this._preferXHR && document.body.contains(tag)) {
			document.body.removeChild(tag);
		}

		if (xml.documentElement != null) {
			tag.appendChild(xml.documentElement);
			tag.style.visibility = "visible";
			return tag;
		} else { // For browsers that don't support SVG, just give them the XML. (IE 9-8)
			return xml;
		}
	};

	createjs.SVGLoader = createjs.promote(SVGLoader, "AbstractLoader");

}());

//##############################################################################
// XMLLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for CSS files.
	 * @class XMLLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function XMLLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.XML);

		// public properties
		this.resultFormatter = this._formatResult;
	};

	var p = createjs.extend(XMLLoader, createjs.AbstractLoader);
	var s = XMLLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/XML:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.XML;
	};

	// protected methods
	/**
	 * The result formatter for XML files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {XMLDocument}
	 * @private
	 */
	p._formatResult = function (loader) {
		return createjs.DataUtils.parseXML(loader.getResult(true), "text/xml");
	};

	createjs.XMLLoader = createjs.promote(XMLLoader, "AbstractLoader");

}());
/*!
* TweenJS
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2010 gskinner.com, inc.
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/


//##############################################################################
// extend.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Sets up the prototype chain and constructor property for a new class.
 *
 * This should be called right after creating the class constructor.
 *
 * 	function MySubClass() {}
 * 	createjs.extend(MySubClass, MySuperClass);
 * 	ClassB.prototype.doSomething = function() { }
 *
 * 	var foo = new MySubClass();
 * 	console.log(foo instanceof MySuperClass); // true
 * 	console.log(foo.prototype.constructor === MySubClass); // true
 *
 * @method extend
 * @param {Function} subclass The subclass.
 * @param {Function} superclass The superclass to extend.
 * @return {Function} Returns the subclass's new prototype.
 */
createjs.extend = function(subclass, superclass) {
	"use strict";

	function o() { this.constructor = subclass; }
	o.prototype = superclass.prototype;
	return (subclass.prototype = new o());
};

//##############################################################################
// promote.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.
 * It is recommended to use the super class's name as the prefix.
 * An alias to the super class's constructor is always added in the format `prefix_constructor`.
 * This allows the subclass to call super class methods without using `function.call`, providing better performance.
 *
 * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, "MySuperClass")`
 * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the
 * prototype of `MySubClass` as `MySuperClass_draw`.
 *
 * This should be called after the class's prototype is fully defined.
 *
 * 	function ClassA(name) {
 * 		this.name = name;
 * 	}
 * 	ClassA.prototype.greet = function() {
 * 		return "Hello "+this.name;
 * 	}
 *
 * 	function ClassB(name, punctuation) {
 * 		this.ClassA_constructor(name);
 * 		this.punctuation = punctuation;
 * 	}
 * 	createjs.extend(ClassB, ClassA);
 * 	ClassB.prototype.greet = function() {
 * 		return this.ClassA_greet()+this.punctuation;
 * 	}
 * 	createjs.promote(ClassB, "ClassA");
 *
 * 	var foo = new ClassB("World", "!?!");
 * 	console.log(foo.greet()); // Hello World!?!
 *
 * @method promote
 * @param {Function} subclass The class to promote super class methods on.
 * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.
 * @return {Function} Returns the subclass.
 */
createjs.promote = function(subclass, prefix) {
	"use strict";

	var subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;
	if (supP) {
		subP[(prefix+="_") + "constructor"] = supP.constructor; // constructor is not always innumerable
		for (var n in supP) {
			if (subP.hasOwnProperty(n) && (typeof supP[n] == "function")) { subP[prefix + n] = supP[n]; }
		}
	}
	return subclass;
};

//##############################################################################
// Event.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

// constructor:
	/**
	 * Contains properties and methods shared by all events for use with
	 * {{#crossLink "EventDispatcher"}}{{/crossLink}}.
	 * 
	 * Note that Event objects are often reused, so you should never
	 * rely on an event object's state outside of the call stack it was received in.
	 * @class Event
	 * @param {String} type The event type.
	 * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
	 * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
	 * @constructor
	 **/
	function Event(type, bubbles, cancelable) {
		
	
	// public properties:
		/**
		 * The type of event.
		 * @property type
		 * @type String
		 **/
		this.type = type;
	
		/**
		 * The object that generated an event.
		 * @property target
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.target = null;
	
		/**
		 * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will
		 * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event
		 * is generated from childObj, then a listener on parentObj would receive the event with
		 * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).
		 * @property currentTarget
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.currentTarget = null;
	
		/**
		 * For bubbling events, this indicates the current event phase:<OL>
		 * 	<LI> capture phase: starting from the top parent to the target</LI>
		 * 	<LI> at target phase: currently being dispatched from the target</LI>
		 * 	<LI> bubbling phase: from the target to the top parent</LI>
		 * </OL>
		 * @property eventPhase
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.eventPhase = 0;
	
		/**
		 * Indicates whether the event will bubble through the display list.
		 * @property bubbles
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.bubbles = !!bubbles;
	
		/**
		 * Indicates whether the default behaviour of this event can be cancelled via
		 * {{#crossLink "Event/preventDefault"}}{{/crossLink}}. This is set via the Event constructor.
		 * @property cancelable
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.cancelable = !!cancelable;
	
		/**
		 * The epoch time at which this event was created.
		 * @property timeStamp
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.timeStamp = (new Date()).getTime();
	
		/**
		 * Indicates if {{#crossLink "Event/preventDefault"}}{{/crossLink}} has been called
		 * on this event.
		 * @property defaultPrevented
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.defaultPrevented = false;
	
		/**
		 * Indicates if {{#crossLink "Event/stopPropagation"}}{{/crossLink}} or
		 * {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called on this event.
		 * @property propagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.propagationStopped = false;
	
		/**
		 * Indicates if {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called
		 * on this event.
		 * @property immediatePropagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.immediatePropagationStopped = false;
		
		/**
		 * Indicates if {{#crossLink "Event/remove"}}{{/crossLink}} has been called on this event.
		 * @property removed
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.removed = false;
	}
	var p = Event.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.
	

// public methods:
	/**
	 * Sets {{#crossLink "Event/defaultPrevented"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method preventDefault
	 **/
	p.preventDefault = function() {
		this.defaultPrevented = this.cancelable&&true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopPropagation
	 **/
	p.stopPropagation = function() {
		this.propagationStopped = true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} and
	 * {{#crossLink "Event/immediatePropagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopImmediatePropagation
	 **/
	p.stopImmediatePropagation = function() {
		this.immediatePropagationStopped = this.propagationStopped = true;
	};
	
	/**
	 * Causes the active listener to be removed via removeEventListener();
	 * 
	 * 		myBtn.addEventListener("click", function(evt) {
	 * 			// do stuff...
	 * 			evt.remove(); // removes this listener.
	 * 		});
	 * 
	 * @method remove
	 **/
	p.remove = function() {
		this.removed = true;
	};
	
	/**
	 * Returns a clone of the Event instance.
	 * @method clone
	 * @return {Event} a clone of the Event instance.
	 **/
	p.clone = function() {
		return new Event(this.type, this.bubbles, this.cancelable);
	};
	
	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the instance.
	 * @return {Event} Returns the instance the method is called on (useful for chaining calls.)
	 * @chainable
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Event (type="+this.type+")]";
	};

	createjs.Event = Event;
}());

//##############################################################################
// EventDispatcher.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * EventDispatcher provides methods for managing queues of event listeners and dispatching events.
	 *
	 * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the
	 * EventDispatcher {{#crossLink "EventDispatcher/initialize"}}{{/crossLink}} method.
	 * 
	 * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the
	 * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports
	 * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.
	 * 
	 * EventDispatcher also exposes a {{#crossLink "EventDispatcher/on"}}{{/crossLink}} method, which makes it easier
	 * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The 
	 * {{#crossLink "EventDispatcher/off"}}{{/crossLink}} method is merely an alias to
	 * {{#crossLink "EventDispatcher/removeEventListener"}}{{/crossLink}}.
	 * 
	 * Another addition to the DOM Level 2 model is the {{#crossLink "EventDispatcher/removeAllEventListeners"}}{{/crossLink}}
	 * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also 
	 * includes a {{#crossLink "Event/remove"}}{{/crossLink}} method which removes the active listener.
	 *
	 * <h4>Example</h4>
	 * Add EventDispatcher capabilities to the "MyClass" class.
	 *
	 *      EventDispatcher.initialize(MyClass.prototype);
	 *
	 * Add an event (see {{#crossLink "EventDispatcher/addEventListener"}}{{/crossLink}}).
	 *
	 *      instance.addEventListener("eventName", handlerMethod);
	 *      function handlerMethod(event) {
	 *          console.log(event.target + " Was Clicked");
	 *      }
	 *
	 * <b>Maintaining proper scope</b><br />
	 * Scope (ie. "this") can be be a challenge with events. Using the {{#crossLink "EventDispatcher/on"}}{{/crossLink}}
	 * method to subscribe to events simplifies this.
	 *
	 *      instance.addEventListener("click", function(event) {
	 *          console.log(instance == this); // false, scope is ambiguous.
	 *      });
	 *      
	 *      instance.on("click", function(event) {
	 *          console.log(instance == this); // true, "on" uses dispatcher scope by default.
	 *      });
	 * 
	 * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage scope.
	 *      
	 *
	 * @class EventDispatcher
	 * @constructor
	 **/
	function EventDispatcher() {
	
	
	// private properties:
		/**
		 * @protected
		 * @property _listeners
		 * @type Object
		 **/
		this._listeners = null;
		
		/**
		 * @protected
		 * @property _captureListeners
		 * @type Object
		 **/
		this._captureListeners = null;
	}
	var p = EventDispatcher.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// static public methods:
	/**
	 * Static initializer to mix EventDispatcher methods into a target object or prototype.
	 * 
	 * 		EventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class
	 * 		EventDispatcher.initialize(myObject); // add to a specific instance
	 * 
	 * @method initialize
	 * @static
	 * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a
	 * prototype.
	 **/
	EventDispatcher.initialize = function(target) {
		target.addEventListener = p.addEventListener;
		target.on = p.on;
		target.removeEventListener = target.off =  p.removeEventListener;
		target.removeAllEventListeners = p.removeAllEventListeners;
		target.hasEventListener = p.hasEventListener;
		target.dispatchEvent = p.dispatchEvent;
		target._dispatchEvent = p._dispatchEvent;
		target.willTrigger = p.willTrigger;
	};
	

// public methods:
	/**
	 * Adds the specified event listener. Note that adding multiple listeners to the same function will result in
	 * multiple callbacks getting fired.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.addEventListener("click", handleClick);
	 *      function handleClick(event) {
	 *         // Click happened.
	 *      }
	 *
	 * @method addEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function | Object} Returns the listener for chaining or assignment.
	 **/
	p.addEventListener = function(type, listener, useCapture) {
		var listeners;
		if (useCapture) {
			listeners = this._captureListeners = this._captureListeners||{};
		} else {
			listeners = this._listeners = this._listeners||{};
		}
		var arr = listeners[type];
		if (arr) { this.removeEventListener(type, listener, useCapture); }
		arr = listeners[type]; // remove may have deleted the array
		if (!arr) { listeners[type] = [listener];  }
		else { arr.push(listener); }
		return listener;
	};
	
	/**
	 * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener
	 * only run once, associate arbitrary data with the listener, and remove the listener.
	 * 
	 * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.
	 * The created anonymous function is returned for use with .removeEventListener (or .off).
	 * 
	 * <h4>Example</h4>
	 * 
	 * 		var listener = myBtn.on("click", handleClick, null, false, {count:3});
	 * 		function handleClick(evt, data) {
	 * 			data.count -= 1;
	 * 			console.log(this == myBtn); // true - scope defaults to the dispatcher
	 * 			if (data.count == 0) {
	 * 				alert("clicked 3 times!");
	 * 				myBtn.off("click", listener);
	 * 				// alternately: evt.remove();
	 * 			}
	 * 		}
	 * 
	 * @method on
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).
	 * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.
	 * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.
	 * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.
	 **/
	p.on = function(type, listener, scope, once, data, useCapture) {
		if (listener.handleEvent) {
			scope = scope||listener;
			listener = listener.handleEvent;
		}
		scope = scope||this;
		return this.addEventListener(type, function(evt) {
				listener.call(scope, evt, data);
				once&&evt.remove();
			}, useCapture);
	};

	/**
	 * Removes the specified event listener.
	 *
	 * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy
	 * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or
	 * closure will not work.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.removeEventListener("click", handleClick);
	 *
	 * @method removeEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.removeEventListener = function(type, listener, useCapture) {
		var listeners = useCapture ? this._captureListeners : this._listeners;
		if (!listeners) { return; }
		var arr = listeners[type];
		if (!arr) { return; }
		for (var i=0,l=arr.length; i<l; i++) {
			if (arr[i] == listener) {
				if (l==1) { delete(listeners[type]); } // allows for faster checks.
				else { arr.splice(i,1); }
				break;
			}
		}
	};
	
	/**
	 * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the
	 * .on method.
	 *
	 * @method off
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.off = p.removeEventListener;

	/**
	 * Removes all listeners for the specified type, or all listeners of all types.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Remove all listeners
	 *      displayObject.removeAllEventListeners();
	 *
	 *      // Remove all click listeners
	 *      displayObject.removeAllEventListeners("click");
	 *
	 * @method removeAllEventListeners
	 * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.
	 **/
	p.removeAllEventListeners = function(type) {
		if (!type) { this._listeners = this._captureListeners = null; }
		else {
			if (this._listeners) { delete(this._listeners[type]); }
			if (this._captureListeners) { delete(this._captureListeners[type]); }
		}
	};

	/**
	 * Dispatches the specified event to all listeners.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Use a string event
	 *      this.dispatchEvent("complete");
	 *
	 *      // Use an Event instance
	 *      var event = new createjs.Event("progress");
	 *      this.dispatchEvent(event);
	 *
	 * @method dispatchEvent
	 * @param {Object | String | Event} eventObj An object with a "type" property, or a string type.
	 * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,
	 * dispatchEvent will construct an Event instance with the specified type.
	 * @return {Boolean} Returns the value of eventObj.defaultPrevented.
	 **/
	p.dispatchEvent = function(eventObj) {
		if (typeof eventObj == "string") {
			// won't bubble, so skip everything if there's no listeners:
			var listeners = this._listeners;
			if (!listeners || !listeners[eventObj]) { return false; }
			eventObj = new createjs.Event(eventObj);
		} else if (eventObj.target && eventObj.clone) {
			// redispatching an active event object, so clone it:
			eventObj = eventObj.clone();
		}
		try { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events

		if (!eventObj.bubbles || !this.parent) {
			this._dispatchEvent(eventObj, 2);
		} else {
			var top=this, list=[top];
			while (top.parent) { list.push(top = top.parent); }
			var i, l=list.length;

			// capture & atTarget
			for (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {
				list[i]._dispatchEvent(eventObj, 1+(i==0));
			}
			// bubbling
			for (i=1; i<l && !eventObj.propagationStopped; i++) {
				list[i]._dispatchEvent(eventObj, 3);
			}
		}
		return eventObj.defaultPrevented;
	};

	/**
	 * Indicates whether there is at least one listener for the specified event type.
	 * @method hasEventListener
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns true if there is at least one listener for the specified event.
	 **/
	p.hasEventListener = function(type) {
		var listeners = this._listeners, captureListeners = this._captureListeners;
		return !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));
	};
	
	/**
	 * Indicates whether there is at least one listener for the specified event type on this object or any of its
	 * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the
	 * specified type is dispatched from this object, it will trigger at least one listener.
	 * 
	 * This is similar to {{#crossLink "EventDispatcher/hasEventListener"}}{{/crossLink}}, but it searches the entire
	 * event flow for a listener, not just this object.
	 * @method willTrigger
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns `true` if there is at least one listener for the specified event.
	 **/
	p.willTrigger = function(type) {
		var o = this;
		while (o) {
			if (o.hasEventListener(type)) { return true; }
			o = o.parent;
		}
		return false;
	};

	/**
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[EventDispatcher]";
	};


// private methods:
	/**
	 * @method _dispatchEvent
	 * @param {Object | String | Event} eventObj
	 * @param {Object} eventPhase
	 * @protected
	 **/
	p._dispatchEvent = function(eventObj, eventPhase) {
		var l, listeners = (eventPhase==1) ? this._captureListeners : this._listeners;
		if (eventObj && listeners) {
			var arr = listeners[eventObj.type];
			if (!arr||!(l=arr.length)) { return; }
			try { eventObj.currentTarget = this; } catch (e) {}
			try { eventObj.eventPhase = eventPhase; } catch (e) {}
			eventObj.removed = false;
			
			arr = arr.slice(); // to avoid issues with items being removed or added during the dispatch
			for (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {
				var o = arr[i];
				if (o.handleEvent) { o.handleEvent(eventObj); }
				else { o(eventObj); }
				if (eventObj.removed) {
					this.off(eventObj.type, o, eventPhase==1);
					eventObj.removed = false;
				}
			}
		}
	};


	createjs.EventDispatcher = EventDispatcher;
}());

//##############################################################################
// Ticker.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * The Ticker provides a centralized tick or heartbeat broadcast at a set interval. Listeners can subscribe to the tick
	 * event to be notified when a set time interval has elapsed.
	 *
	 * Note that the interval that the tick event is called is a target interval, and may be broadcast at a slower interval
	 * when under high CPU load. The Ticker class uses a static interface (ex. `Ticker.framerate = 30;`) and
	 * can not be instantiated.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.Ticker.addEventListener("tick", handleTick);
	 *      function handleTick(event) {
	 *          // Actions carried out each tick (aka frame)
	 *          if (!event.paused) {
	 *              // Actions carried out when the Ticker is not paused.
	 *          }
	 *      }
	 *
	 * @class Ticker
	 * @uses EventDispatcher
	 * @static
	 **/
	function Ticker() {
		throw "Ticker cannot be instantiated.";
	}


// constants:
	/**
	 * In this mode, Ticker uses the requestAnimationFrame API, but attempts to synch the ticks to target framerate. It
	 * uses a simple heuristic that compares the time of the RAF return to the target time for the current frame and
	 * dispatches the tick when the time is within a certain threshold.
	 *
	 * This mode has a higher variance for time between frames than {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}},
	 * but does not require that content be time based as with {{#crossLink "Ticker/RAF:property"}}{{/crossLink}} while
	 * gaining the benefits of that API (screen synch, background throttling).
	 *
	 * Variance is usually lowest for framerates that are a divisor of the RAF frequency. This is usually 60, so
	 * framerates of 10, 12, 15, 20, and 30 work well.
	 *
	 * Falls back to {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}} if the requestAnimationFrame API is not
	 * supported.
	 * @property RAF_SYNCHED
	 * @static
	 * @type {String}
	 * @default "synched"
	 * @readonly
	 **/
	Ticker.RAF_SYNCHED = "synched";

	/**
	 * In this mode, Ticker passes through the requestAnimationFrame heartbeat, ignoring the target framerate completely.
	 * Because requestAnimationFrame frequency is not deterministic, any content using this mode should be time based.
	 * You can leverage {{#crossLink "Ticker/getTime"}}{{/crossLink}} and the {{#crossLink "Ticker/tick:event"}}{{/crossLink}}
	 * event object's "delta" properties to make this easier.
	 *
	 * Falls back on {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}} if the requestAnimationFrame API is not
	 * supported.
	 * @property RAF
	 * @static
	 * @type {String}
	 * @default "raf"
	 * @readonly
	 **/
	Ticker.RAF = "raf";

	/**
	 * In this mode, Ticker uses the setTimeout API. This provides predictable, adaptive frame timing, but does not
	 * provide the benefits of requestAnimationFrame (screen synch, background throttling).
	 * @property TIMEOUT
	 * @static
	 * @type {String}
	 * @default "timeout"
	 * @readonly
	 **/
	Ticker.TIMEOUT = "timeout";


// static events:
	/**
	 * Dispatched each tick. The event will be dispatched to each listener even when the Ticker has been paused using
	 * {{#crossLink "Ticker/setPaused"}}{{/crossLink}}.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.Ticker.addEventListener("tick", handleTick);
	 *      function handleTick(event) {
	 *          console.log("Paused:", event.paused, event.delta);
	 *      }
	 *
	 * @event tick
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Boolean} paused Indicates whether the ticker is currently paused.
	 * @param {Number} delta The time elapsed in ms since the last tick.
	 * @param {Number} time The total time in ms since Ticker was initialized.
	 * @param {Number} runTime The total time in ms that Ticker was not paused since it was initialized. For example,
	 * 	you could determine the amount of time that the Ticker has been paused since initialization with `time-runTime`.
	 * @since 0.6.0
	 */


// public static properties:
	/**
	 * Deprecated in favour of {{#crossLink "Ticker/timingMode"}}{{/crossLink}}, and will be removed in a future version. If true, timingMode will
	 * use {{#crossLink "Ticker/RAF_SYNCHED"}}{{/crossLink}} by default.
	 * @deprecated Deprecated in favour of {{#crossLink "Ticker/timingMode"}}{{/crossLink}}.
	 * @property useRAF
	 * @static
	 * @type {Boolean}
	 * @default false
	 **/
	Ticker.useRAF = false;

	/**
	 * Specifies the timing api (setTimeout or requestAnimationFrame) and mode to use. See
	 * {{#crossLink "Ticker/TIMEOUT"}}{{/crossLink}}, {{#crossLink "Ticker/RAF"}}{{/crossLink}}, and
	 * {{#crossLink "Ticker/RAF_SYNCHED"}}{{/crossLink}} for mode details.
	 * @property timingMode
	 * @static
	 * @type {String}
	 * @default Ticker.TIMEOUT
	 **/
	Ticker.timingMode = null;

	/**
	 * Specifies a maximum value for the delta property in the tick event object. This is useful when building time
	 * based animations and systems to prevent issues caused by large time gaps caused by background tabs, system sleep,
	 * alert dialogs, or other blocking routines. Double the expected frame duration is often an effective value
	 * (ex. maxDelta=50 when running at 40fps).
	 * 
	 * This does not impact any other values (ex. time, runTime, etc), so you may experience issues if you enable maxDelta
	 * when using both delta and other values.
	 * 
	 * If 0, there is no maximum.
	 * @property maxDelta
	 * @static
	 * @type {number}
	 * @default 0
	 */
	Ticker.maxDelta = 0;
	
	/**
	 * When the ticker is paused, all listeners will still receive a tick event, but the <code>paused</code> property
	 * of the event will be `true`. Also, while paused the `runTime` will not increase. See {{#crossLink "Ticker/tick:event"}}{{/crossLink}},
	 * {{#crossLink "Ticker/getTime"}}{{/crossLink}}, and {{#crossLink "Ticker/getEventTime"}}{{/crossLink}} for more
	 * info.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.Ticker.addEventListener("tick", handleTick);
	 *      createjs.Ticker.paused = true;
	 *      function handleTick(event) {
	 *          console.log(event.paused,
	 *          	createjs.Ticker.getTime(false),
	 *          	createjs.Ticker.getTime(true));
	 *      }
	 *
	 * @property paused
	 * @static
	 * @type {Boolean}
	 * @default false
	 **/
	Ticker.paused = false;


// mix-ins:
	// EventDispatcher methods:
	Ticker.removeEventListener = null;
	Ticker.removeAllEventListeners = null;
	Ticker.dispatchEvent = null;
	Ticker.hasEventListener = null;
	Ticker._listeners = null;
	createjs.EventDispatcher.initialize(Ticker); // inject EventDispatcher methods.
	Ticker._addEventListener = Ticker.addEventListener;
	Ticker.addEventListener = function() {
		!Ticker._inited&&Ticker.init();
		return Ticker._addEventListener.apply(Ticker, arguments);
	};


// private static properties:
	/**
	 * @property _inited
	 * @static
	 * @type {Boolean}
	 * @protected
	 **/
	Ticker._inited = false;

	/**
	 * @property _startTime
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._startTime = 0;

	/**
	 * @property _pausedTime
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._pausedTime=0;

	/**
	 * The number of ticks that have passed
	 * @property _ticks
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._ticks = 0;

	/**
	 * The number of ticks that have passed while Ticker has been paused
	 * @property _pausedTicks
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._pausedTicks = 0;

	/**
	 * @property _interval
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._interval = 50;

	/**
	 * @property _lastTime
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._lastTime = 0;

	/**
	 * @property _times
	 * @static
	 * @type {Array}
	 * @protected
	 **/
	Ticker._times = null;

	/**
	 * @property _tickTimes
	 * @static
	 * @type {Array}
	 * @protected
	 **/
	Ticker._tickTimes = null;

	/**
	 * Stores the timeout or requestAnimationFrame id.
	 * @property _timerId
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._timerId = null;
	
	/**
	 * True if currently using requestAnimationFrame, false if using setTimeout. This may be different than timingMode
	 * if that property changed and a tick hasn't fired.
	 * @property _raf
	 * @static
	 * @type {Boolean}
	 * @protected
	 **/
	Ticker._raf = true;
	

// static getter / setters:
	/**
	 * Use the {{#crossLink "Ticker/interval:property"}}{{/crossLink}} property instead.
	 * @method setInterval
	 * @static
	 * @param {Number} interval
	 * @deprecated
	 **/
	Ticker.setInterval = function(interval) {
		Ticker._interval = interval;
		if (!Ticker._inited) { return; }
		Ticker._setupTick();
	};

	/**
	 * Use the {{#crossLink "Ticker/framerate:property"}}{{/crossLink}} property instead.
	 * @method getInterval
	 * @static
	 * @return {Number}
	 * @deprecated
	 **/
	Ticker.getInterval = function() {
		return Ticker._interval;
	};

	/**
	 * Use the {{#crossLink "Ticker/framerate:property"}}{{/crossLink}} property instead.
	 * @method setFPS
	 * @static
	 * @param {Number} value
	 * @deprecated
	 **/
	Ticker.setFPS = function(value) {
		Ticker.setInterval(1000/value);
	};

	/**
	 * Use the {{#crossLink "Ticker/interval:property"}}{{/crossLink}} property instead.
	 * @method getFPS
	 * @static
	 * @return {Number}
	 * @deprecated
	 **/
	Ticker.getFPS = function() {
		return 1000/Ticker._interval;
	};

	/**
	 * Indicates the target time (in milliseconds) between ticks. Default is 50 (20 FPS).
	 * Note that actual time between ticks may be more than specified depending on CPU load.
	 * This property is ignored if the ticker is using the `RAF` timing mode.
	 * @property interval
	 * @static
	 * @type {Number}
	 **/
	 
	/**
	 * Indicates the target frame rate in frames per second (FPS). Effectively just a shortcut to `interval`, where
	 * `framerate == 1000/interval`.
	 * @property framerate
	 * @static
	 * @type {Number}
	 **/
	try {
		Object.defineProperties(Ticker, {
			interval: { get: Ticker.getInterval, set: Ticker.setInterval },
			framerate: { get: Ticker.getFPS, set: Ticker.setFPS }
		});
	} catch (e) { console.log(e); }


// public static methods:
	/**
	 * Starts the tick. This is called automatically when the first listener is added.
	 * @method init
	 * @static
	 **/
	Ticker.init = function() {
		if (Ticker._inited) { return; }
		Ticker._inited = true;
		Ticker._times = [];
		Ticker._tickTimes = [];
		Ticker._startTime = Ticker._getTime();
		Ticker._times.push(Ticker._lastTime = 0);
		Ticker.interval = Ticker._interval;
	};
	
	/**
	 * Stops the Ticker and removes all listeners. Use init() to restart the Ticker.
	 * @method reset
	 * @static
	 **/
	Ticker.reset = function() {
		if (Ticker._raf) {
			var f = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;
			f&&f(Ticker._timerId);
		} else {
			clearTimeout(Ticker._timerId);
		}
		Ticker.removeAllEventListeners("tick");
		Ticker._timerId = Ticker._times = Ticker._tickTimes = null;
		Ticker._startTime = Ticker._lastTime = Ticker._ticks = 0;
		Ticker._inited = false;
	};

	/**
	 * Returns the average time spent within a tick. This can vary significantly from the value provided by getMeasuredFPS
	 * because it only measures the time spent within the tick execution stack. 
	 * 
	 * Example 1: With a target FPS of 20, getMeasuredFPS() returns 20fps, which indicates an average of 50ms between 
	 * the end of one tick and the end of the next. However, getMeasuredTickTime() returns 15ms. This indicates that 
	 * there may be up to 35ms of "idle" time between the end of one tick and the start of the next.
	 *
	 * Example 2: With a target FPS of 30, getFPS() returns 10fps, which indicates an average of 100ms between the end of
	 * one tick and the end of the next. However, getMeasuredTickTime() returns 20ms. This would indicate that something
	 * other than the tick is using ~80ms (another script, DOM rendering, etc).
	 * @method getMeasuredTickTime
	 * @static
	 * @param {Number} [ticks] The number of previous ticks over which to measure the average time spent in a tick.
	 * Defaults to the number of ticks per second. To get only the last tick's time, pass in 1.
	 * @return {Number} The average time spent in a tick in milliseconds.
	 **/
	Ticker.getMeasuredTickTime = function(ticks) {
		var ttl=0, times=Ticker._tickTimes;
		if (!times || times.length < 1) { return -1; }

		// by default, calculate average for the past ~1 second:
		ticks = Math.min(times.length, ticks||(Ticker.getFPS()|0));
		for (var i=0; i<ticks; i++) { ttl += times[i]; }
		return ttl/ticks;
	};

	/**
	 * Returns the actual frames / ticks per second.
	 * @method getMeasuredFPS
	 * @static
	 * @param {Number} [ticks] The number of previous ticks over which to measure the actual frames / ticks per second.
	 * Defaults to the number of ticks per second.
	 * @return {Number} The actual frames / ticks per second. Depending on performance, this may differ
	 * from the target frames per second.
	 **/
	Ticker.getMeasuredFPS = function(ticks) {
		var times = Ticker._times;
		if (!times || times.length < 2) { return -1; }

		// by default, calculate fps for the past ~1 second:
		ticks = Math.min(times.length-1, ticks||(Ticker.getFPS()|0));
		return 1000/((times[0]-times[ticks])/ticks);
	};

	/**
	 * Use the {{#crossLink "Ticker/paused:property"}}{{/crossLink}} property instead.
	 * @method setPaused
	 * @static
	 * @param {Boolean} value
	 * @deprecated
	 **/
	Ticker.setPaused = function(value) {
		// TODO: deprecated.
		Ticker.paused = value;
	};

	/**
	 * Use the {{#crossLink "Ticker/paused:property"}}{{/crossLink}} property instead.
	 * @method getPaused
	 * @static
	 * @return {Boolean}
	 * @deprecated
	 **/
	Ticker.getPaused = function() {
		// TODO: deprecated.
		return Ticker.paused;
	};

	/**
	 * Returns the number of milliseconds that have elapsed since Ticker was initialized via {{#crossLink "Ticker/init"}}.
	 * Returns -1 if Ticker has not been initialized. For example, you could use
	 * this in a time synchronized animation to determine the exact amount of time that has elapsed.
	 * @method getTime
	 * @static
	 * @param {Boolean} [runTime=false] If true only time elapsed while Ticker was not paused will be returned.
	 * If false, the value returned will be total time elapsed since the first tick event listener was added.
	 * @return {Number} Number of milliseconds that have elapsed since Ticker was initialized or -1.
	 **/
	Ticker.getTime = function(runTime) {
		return Ticker._startTime ? Ticker._getTime() - (runTime ? Ticker._pausedTime : 0) : -1;
	};

	/**
	 * Similar to getTime(), but returns the time on the most recent tick event object.
	 * @method getEventTime
	 * @static
	 * @param runTime {Boolean} [runTime=false] If true, the runTime property will be returned instead of time.
	 * @returns {number} The time or runTime property from the most recent tick event or -1.
	 */
	Ticker.getEventTime = function(runTime) {
		return Ticker._startTime ? (Ticker._lastTime || Ticker._startTime) - (runTime ? Ticker._pausedTime : 0) : -1;
	};
	
	/**
	 * Returns the number of ticks that have been broadcast by Ticker.
	 * @method getTicks
	 * @static
	 * @param {Boolean} pauseable Indicates whether to include ticks that would have been broadcast
	 * while Ticker was paused. If true only tick events broadcast while Ticker is not paused will be returned.
	 * If false, tick events that would have been broadcast while Ticker was paused will be included in the return
	 * value. The default value is false.
	 * @return {Number} of ticks that have been broadcast.
	 **/
	Ticker.getTicks = function(pauseable) {
		return  Ticker._ticks - (pauseable ? Ticker._pausedTicks : 0);
	};


// private static methods:
	/**
	 * @method _handleSynch
	 * @static
	 * @protected
	 **/
	Ticker._handleSynch = function() {
		Ticker._timerId = null;
		Ticker._setupTick();

		// run if enough time has elapsed, with a little bit of flexibility to be early:
		if (Ticker._getTime() - Ticker._lastTime >= (Ticker._interval-1)*0.97) {
			Ticker._tick();
		}
	};

	/**
	 * @method _handleRAF
	 * @static
	 * @protected
	 **/
	Ticker._handleRAF = function() {
		Ticker._timerId = null;
		Ticker._setupTick();
		Ticker._tick();
	};

	/**
	 * @method _handleTimeout
	 * @static
	 * @protected
	 **/
	Ticker._handleTimeout = function() {
		Ticker._timerId = null;
		Ticker._setupTick();
		Ticker._tick();
	};

	/**
	 * @method _setupTick
	 * @static
	 * @protected
	 **/
	Ticker._setupTick = function() {
		if (Ticker._timerId != null) { return; } // avoid duplicates

		var mode = Ticker.timingMode||(Ticker.useRAF&&Ticker.RAF_SYNCHED);
		if (mode == Ticker.RAF_SYNCHED || mode == Ticker.RAF) {
			var f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
			if (f) {
				Ticker._timerId = f(mode == Ticker.RAF ? Ticker._handleRAF : Ticker._handleSynch);
				Ticker._raf = true;
				return;
			}
		}
		Ticker._raf = false;
		Ticker._timerId = setTimeout(Ticker._handleTimeout, Ticker._interval);
	};

	/**
	 * @method _tick
	 * @static
	 * @protected
	 **/
	Ticker._tick = function() {
		var paused = Ticker.paused;
		var time = Ticker._getTime();
		var elapsedTime = time-Ticker._lastTime;
		Ticker._lastTime = time;
		Ticker._ticks++;
		
		if (paused) {
			Ticker._pausedTicks++;
			Ticker._pausedTime += elapsedTime;
		}
		
		if (Ticker.hasEventListener("tick")) {
			var event = new createjs.Event("tick");
			var maxDelta = Ticker.maxDelta;
			event.delta = (maxDelta && elapsedTime > maxDelta) ? maxDelta : elapsedTime;
			event.paused = paused;
			event.time = time;
			event.runTime = time-Ticker._pausedTime;
			Ticker.dispatchEvent(event);
		}
		
		Ticker._tickTimes.unshift(Ticker._getTime()-time);
		while (Ticker._tickTimes.length > 100) { Ticker._tickTimes.pop(); }

		Ticker._times.unshift(time);
		while (Ticker._times.length > 100) { Ticker._times.pop(); }
	};

	/**
	 * @method _getTime
	 * @static
	 * @protected
	 **/
	var now = window.performance && (performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow);
	Ticker._getTime = function() {
		return ((now&&now.call(performance))||(new Date().getTime())) - Ticker._startTime;
	};


	createjs.Ticker = Ticker;
}());

//##############################################################################
// Tween.js
//##############################################################################

// TODO: possibly add a END actionsMode (only runs actions that == position)?
// TODO: evaluate a way to decouple paused from tick registration.


this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor
	/**
	 * A Tween instance tweens properties for a single target. Instance methods can be chained for easy construction and sequencing:
	 *
	 * <h4>Example</h4>
	 *
	 *      target.alpha = 1;
	 *	    createjs.Tween.get(target)
	 *	         .wait(500)
	 *	         .to({alpha:0, visible:false}, 1000)
	 *	         .call(handleComplete);
	 *	    function handleComplete() {
	 *	    	//Tween complete
	 *	    }
	 *
	 * Multiple tweens can point to the same instance, however if they affect the same properties there could be unexpected
	 * behaviour. To stop all tweens on an object, use {{#crossLink "Tween/removeTweens"}}{{/crossLink}} or pass `override:true`
	 * in the props argument.
	 *
	 *      createjs.Tween.get(target, {override:true}).to({x:100});
	 *
	 * Subscribe to the {{#crossLink "Tween/change:event"}}{{/crossLink}} event to get notified when a property of the
	 * target is changed.
	 *
	 *      createjs.Tween.get(target, {override:true}).to({x:100}).addEventListener("change", handleChange);
	 *      function handleChange(event) {
	 *          // The tween changed.
	 *      }
	 *
	 * See the Tween {{#crossLink "Tween/get"}}{{/crossLink}} method for additional param documentation.
	 * @class Tween
	 * @param {Object} target The target object that will have its properties tweened.
	 * @param {Object} [props] The configuration properties to apply to this tween instance (ex. `{loop:true, paused:true}`.
	 * All properties default to false. Supported props are:<UL>
	 *    <LI> loop: sets the loop property on this tween.</LI>
	 *    <LI> useTicks: uses ticks for all durations instead of milliseconds.</LI>
	 *    <LI> ignoreGlobalPause: sets the {{#crossLink "Tween/ignoreGlobalPause:property"}}{{/crossLink}} property on this tween.</LI>
	 *    <LI> override: if true, `Tween.removeTweens(target)` will be called to remove any other tweens with the same target.
	 *    <LI> paused: indicates whether to start the tween paused.</LI>
	 *    <LI> position: indicates the initial position for this tween.</LI>
	 *    <LI> onChange: specifies a listener for the "change" event.</LI>
	 * </UL>
	 * @param {Object} [pluginData] An object containing data for use by installed plugins. See individual
	 * plugins' documentation for details.
	 * @extends EventDispatcher
	 * @constructor
	 */
	function Tween(target, props, pluginData) {

	// public properties:
		/**
		 * Causes this tween to continue playing when a global pause is active. For example, if TweenJS is using {{#crossLink "Ticker"}}{{/crossLink}},
		 * then setting this to true (the default) will cause this tween to be paused when <code>Ticker.setPaused(true)</code>
		 * is called. See the Tween {{#crossLink "Tween/tick"}}{{/crossLink}} method for more info. Can be set via the props
		 * parameter.
		 * @property ignoreGlobalPause
		 * @type Boolean
		 * @default false
		 */
		this.ignoreGlobalPause = false;
	
		/**
		 * If true, the tween will loop when it reaches the end. Can be set via the props param.
		 * @property loop
		 * @type {Boolean}
		 * @default false
		 */
		this.loop = false;
	
		/**
		 * Specifies the total duration of this tween in milliseconds (or ticks if useTicks is true).
		 * This value is automatically updated as you modify the tween. Changing it directly could result in unexpected
		 * behaviour.
		 * @property duration
		 * @type {Number}
		 * @default 0
		 * @readonly
		 */
		this.duration = 0;
	
		/**
		 * Allows you to specify data that will be used by installed plugins. Each plugin uses this differently, but in general
		 * you specify data by setting it to a property of pluginData with the same name as the plugin class.
		 * @example
		 *	myTween.pluginData.PluginClassName = data;
		 * <br/>
		 * Also, most plugins support a property to enable or disable them. This is typically the plugin class name followed by "_enabled".<br/>
		 * @example
		 *	myTween.pluginData.PluginClassName_enabled = false;<br/>
		 * <br/>
		 * Some plugins also store instance data in this object, usually in a property named _PluginClassName.
		 * See the documentation for individual plugins for more details.
		 * @property pluginData
		 * @type {Object}
		 */
		this.pluginData = pluginData || {};
	
		/**
		 * The target of this tween. This is the object on which the tweened properties will be changed. Changing
		 * this property after the tween is created will not have any effect.
		 * @property target
		 * @type {Object}
		 * @readonly
		 */
		this.target = target;
	
		/**
		 * The current normalized position of the tween. This will always be a value between 0 and duration.
		 * Changing this property directly will have no effect.
		 * @property position
		 * @type {Object}
		 * @readonly
		 */
		this.position = null;
	
		/**
		 * Indicates the tween's current position is within a passive wait.
		 * @property passive
		 * @type {Boolean}
		 * @default false
		 * @readonly
		 **/
		this.passive = false;
	
	// private properties:	
		/**
		 * @property _paused
		 * @type {Boolean}
		 * @default false
		 * @protected
		 */
		this._paused = false;
	
		/**
		 * @property _curQueueProps
		 * @type {Object}
		 * @protected
		 */
		this._curQueueProps = {};
	
		/**
		 * @property _initQueueProps
		 * @type {Object}
		 * @protected
		 */
		this._initQueueProps = {};
	
		/**
		 * @property _steps
		 * @type {Array}
		 * @protected
		 */
		this._steps = [];
	
		/**
		 * @property _actions
		 * @type {Array}
		 * @protected
		 */
		this._actions = [];
	
		/**
		 * Raw position.
		 * @property _prevPosition
		 * @type {Number}
		 * @default 0
		 * @protected
		 */
		this._prevPosition = 0;
	
		/**
		 * The position within the current step.
		 * @property _stepPosition
		 * @type {Number}
		 * @default 0
		 * @protected
		 */
		this._stepPosition = 0; // this is needed by MovieClip.
	
		/**
		 * Normalized position.
		 * @property _prevPos
		 * @type {Number}
		 * @default -1
		 * @protected
		 */
		this._prevPos = -1;
	
		/**
		 * @property _target
		 * @type {Object}
		 * @protected
		 */
		this._target = target;
	
		/**
		 * @property _useTicks
		 * @type {Boolean}
		 * @default false
		 * @protected
		 */
		this._useTicks = false;
	
		/**
		 * @property _inited
		 * @type {boolean}
		 * @default false
		 * @protected
		 */
		this._inited = false;
		
		/**
		 * Indicates whether the tween is currently registered with Tween.
		 * @property _registered
		 * @type {boolean}
		 * @default false
		 * @protected
		 */
		this._registered = false;


		if (props) {
			this._useTicks = props.useTicks;
			this.ignoreGlobalPause = props.ignoreGlobalPause;
			this.loop = props.loop;
			props.onChange && this.addEventListener("change", props.onChange);
			if (props.override) { Tween.removeTweens(target); }
		}
		if (props&&props.paused) { this._paused=true; }
		else { createjs.Tween._register(this,true); }
		if (props&&props.position!=null) { this.setPosition(props.position, Tween.NONE); }

	};

	var p = createjs.extend(Tween, createjs.EventDispatcher);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	

// static properties
	/**
	 * Constant defining the none actionsMode for use with setPosition.
	 * @property NONE
	 * @type Number
	 * @default 0
	 * @static
	 */
	Tween.NONE = 0;

	/**
	 * Constant defining the loop actionsMode for use with setPosition.
	 * @property LOOP
	 * @type Number
	 * @default 1
	 * @static
	 */
	Tween.LOOP = 1;

	/**
	 * Constant defining the reverse actionsMode for use with setPosition.
	 * @property REVERSE
	 * @type Number
	 * @default 2
	 * @static
	 */
	Tween.REVERSE = 2;

	/**
	 * Constant returned by plugins to tell the tween not to use default assignment.
	 * @property IGNORE
	 * @type Object
	 * @static
	 */
	Tween.IGNORE = {};

	/**
	 * @property _listeners
	 * @type Array[Tween]
	 * @static
	 * @protected
	 */
	Tween._tweens = [];

	/**
	 * @property _plugins
	 * @type Object
	 * @static
	 * @protected
	 */
	Tween._plugins = {};


// static methods	
	/**
	 * Returns a new tween instance. This is functionally identical to using "new Tween(...)", but looks cleaner
	 * with the chained syntax of TweenJS.
	 * <h4>Example</h4>
	 *
	 *		var tween = createjs.Tween.get(target);
	 *
	 * @method get
	 * @param {Object} target The target object that will have its properties tweened.
	 * @param {Object} [props] The configuration properties to apply to this tween instance (ex. `{loop:true, paused:true}`).
	 * All properties default to `false`. Supported props are:
	 * <UL>
	 *    <LI> loop: sets the loop property on this tween.</LI>
	 *    <LI> useTicks: uses ticks for all durations instead of milliseconds.</LI>
	 *    <LI> ignoreGlobalPause: sets the {{#crossLink "Tween/ignoreGlobalPause:property"}}{{/crossLink}} property on
	 *    this tween.</LI>
	 *    <LI> override: if true, `createjs.Tween.removeTweens(target)` will be called to remove any other tweens with
	 *    the same target.
	 *    <LI> paused: indicates whether to start the tween paused.</LI>
	 *    <LI> position: indicates the initial position for this tween.</LI>
	 *    <LI> onChange: specifies a listener for the {{#crossLink "Tween/change:event"}}{{/crossLink}} event.</LI>
	 * </UL>
	 * @param {Object} [pluginData] An object containing data for use by installed plugins. See individual plugins'
	 * documentation for details.
	 * @param {Boolean} [override=false] If true, any previous tweens on the same target will be removed. This is the
	 * same as calling `Tween.removeTweens(target)`.
	 * @return {Tween} A reference to the created tween. Additional chained tweens, method calls, or callbacks can be
	 * applied to the returned tween instance.
	 * @static
	 */
	Tween.get = function(target, props, pluginData, override) {
		if (override) { Tween.removeTweens(target); }
		return new Tween(target, props, pluginData);
	};

	/**
	 * Advances all tweens. This typically uses the {{#crossLink "Ticker"}}{{/crossLink}} class, but you can call it
	 * manually if you prefer to use your own "heartbeat" implementation.
	 * @method tick
	 * @param {Number} delta The change in time in milliseconds since the last tick. Required unless all tweens have
	 * `useTicks` set to true.
	 * @param {Boolean} paused Indicates whether a global pause is in effect. Tweens with {{#crossLink "Tween/ignoreGlobalPause:property"}}{{/crossLink}}
	 * will ignore this, but all others will pause if this is `true`.
	 * @static
	 */
	Tween.tick = function(delta, paused) {
		var tweens = Tween._tweens.slice(); // to avoid race conditions.
		for (var i=tweens.length-1; i>=0; i--) {
			var tween = tweens[i];
			if ((paused && !tween.ignoreGlobalPause) || tween._paused) { continue; }
			tween.tick(tween._useTicks?1:delta);
		}
	};

	/**
	 * Handle events that result from Tween being used as an event handler. This is included to allow Tween to handle
	 * {{#crossLink "Ticker/tick:event"}}{{/crossLink}} events from the createjs {{#crossLink "Ticker"}}{{/crossLink}}.
	 * No other events are handled in Tween.
	 * @method handleEvent
	 * @param {Object} event An event object passed in by the {{#crossLink "EventDispatcher"}}{{/crossLink}}. Will
	 * usually be of type "tick".
	 * @private
	 * @static
	 * @since 0.4.2
	 */
	Tween.handleEvent = function(event) {
		if (event.type == "tick") {
			this.tick(event.delta, event.paused);
		}
	};

	/**
	 * Removes all existing tweens for a target. This is called automatically by new tweens if the `override`
	 * property is `true`.
	 * @method removeTweens
	 * @param {Object} target The target object to remove existing tweens from.
	 * @static
	 */
	Tween.removeTweens = function(target) {
		if (!target.tweenjs_count) { return; }
		var tweens = Tween._tweens;
		for (var i=tweens.length-1; i>=0; i--) {
			var tween = tweens[i];
			if (tween._target == target) {
				tween._paused = true;
				tweens.splice(i, 1);
			}
		}
		target.tweenjs_count = 0;
	};

	/**
	 * Stop and remove all existing tweens.
	 * @method removeAllTweens
	 * @static
	 * @since 0.4.1
	 */
	Tween.removeAllTweens = function() {
		var tweens = Tween._tweens;
		for (var i= 0, l=tweens.length; i<l; i++) {
			var tween = tweens[i];
			tween._paused = true;
			tween.target&&(tween.target.tweenjs_count = 0);
		}
		tweens.length = 0;
	};

	/**
	 * Indicates whether there are any active tweens (and how many) on the target object (if specified) or in general.
	 * @method hasActiveTweens
	 * @param {Object} [target] The target to check for active tweens. If not specified, the return value will indicate
	 * if there are any active tweens on any target.
	 * @return {Boolean} If there are active tweens.
	 * @static
	 */
	Tween.hasActiveTweens = function(target) {
		if (target) { return target.tweenjs_count != null && !!target.tweenjs_count; }
		return Tween._tweens && !!Tween._tweens.length;
	};

	/**
	 * Installs a plugin, which can modify how certain properties are handled when tweened. See the {{#crossLink "CSSPlugin"}}{{/crossLink}}
	 * for an example of how to write TweenJS plugins.
	 * @method installPlugin
	 * @static
	 * @param {Object} plugin The plugin class to install
	 * @param {Array} properties An array of properties that the plugin will handle.
	 */
	Tween.installPlugin = function(plugin, properties) {
		var priority = plugin.priority;
		if (priority == null) { plugin.priority = priority = 0; }
		for (var i=0,l=properties.length,p=Tween._plugins;i<l;i++) {
			var n = properties[i];
			if (!p[n]) { p[n] = [plugin]; }
			else {
				var arr = p[n];
				for (var j=0,jl=arr.length;j<jl;j++) {
					if (priority < arr[j].priority) { break; }
				}
				p[n].splice(j,0,plugin);
			}
		}
	};

	/**
	 * Registers or unregisters a tween with the ticking system.
	 * @method _register
	 * @param {Tween} tween The tween instance to register or unregister.
	 * @param {Boolean} value If `true`, the tween is registered. If `false` the tween is unregistered.
	 * @static
	 * @protected
	 */
	Tween._register = function(tween, value) {
		var target = tween._target;
		var tweens = Tween._tweens;
		if (value && !tween._registered) {
			// TODO: this approach might fail if a dev is using sealed objects in ES5
			if (target) { target.tweenjs_count = target.tweenjs_count ? target.tweenjs_count+1 : 1; }
			tweens.push(tween);
			if (!Tween._inited && createjs.Ticker) { createjs.Ticker.addEventListener("tick", Tween); Tween._inited = true; }
		} else if (!value && tween._registered) {
			if (target) { target.tweenjs_count--; }
			var i = tweens.length;
			while (i--) {
				if (tweens[i] == tween) {
					tweens.splice(i, 1);
					break;
				}
			}
		}
		tween._registered = value;
	};


// events:
	/**
	 * Called whenever the tween's position changes.
	 * @event change
	 * @since 0.4.0
	 **/
	

// public methods:
	/**
	 * Queues a wait (essentially an empty tween).
	 * <h4>Example</h4>
	 *
	 *		//This tween will wait 1s before alpha is faded to 0.
	 *		createjs.Tween.get(target).wait(1000).to({alpha:0}, 1000);
	 *
	 * @method wait
	 * @param {Number} duration The duration of the wait in milliseconds (or in ticks if `useTicks` is true).
	 * @param {Boolean} [passive] Tween properties will not be updated during a passive wait. This
	 * is mostly useful for use with {{#crossLink "Timeline"}}{{/crossLink}} instances that contain multiple tweens
	 * affecting the same target at different times.
	 * @return {Tween} This tween instance (for chaining calls).
	 **/
	p.wait = function(duration, passive) {
		if (duration == null || duration <= 0) { return this; }
		var o = this._cloneProps(this._curQueueProps);
		return this._addStep({d:duration, p0:o, e:this._linearEase, p1:o, v:passive});
	};

	/**
	 * Queues a tween from the current values to the target properties. Set duration to 0 to jump to these value.
	 * Numeric properties will be tweened from their current value in the tween to the target value. Non-numeric
	 * properties will be set at the end of the specified duration.
	 * <h4>Example</h4>
	 *
	 *		createjs.Tween.get(target).to({alpha:0}, 1000);
	 *
	 * @method to
	 * @param {Object} props An object specifying property target values for this tween (Ex. `{x:300}` would tween the x
	 * property of the target to 300).
	 * @param {Number} [duration=0] The duration of the wait in milliseconds (or in ticks if `useTicks` is true).
	 * @param {Function} [ease="linear"] The easing function to use for this tween. See the {{#crossLink "Ease"}}{{/crossLink}}
	 * class for a list of built-in ease functions.
	 * @return {Tween} This tween instance (for chaining calls).
	 */
	p.to = function(props, duration, ease) {
		if (isNaN(duration) || duration < 0) { duration = 0; }
		return this._addStep({d:duration||0, p0:this._cloneProps(this._curQueueProps), e:ease, p1:this._cloneProps(this._appendQueueProps(props))});
	};

	/**
	 * Queues an action to call the specified function.
	 * <h4>Example</h4>
	 *
	 *   	//would call myFunction() after 1 second.
	 *   	myTween.wait(1000).call(myFunction);
	 *
	 * @method call
	 * @param {Function} callback The function to call.
	 * @param {Array} [params]. The parameters to call the function with. If this is omitted, then the function
	 *      will be called with a single param pointing to this tween.
	 * @param {Object} [scope]. The scope to call the function in. If omitted, it will be called in the target's
	 *      scope.
	 * @return {Tween} This tween instance (for chaining calls).
	 */
	p.call = function(callback, params, scope) {
		return this._addAction({f:callback, p:params ? params : [this], o:scope ? scope : this._target});
	};

	// TODO: add clarification between this and a 0 duration .to:
	/**
	 * Queues an action to set the specified props on the specified target. If target is null, it will use this tween's
	 * target.
	 * <h4>Example</h4>
	 *
	 *		myTween.wait(1000).set({visible:false},foo);
	 *
	 * @method set
	 * @param {Object} props The properties to set (ex. `{visible:false}`).
	 * @param {Object} [target] The target to set the properties on. If omitted, they will be set on the tween's target.
	 * @return {Tween} This tween instance (for chaining calls).
	 */
	p.set = function(props, target) {
		return this._addAction({f:this._set, o:this, p:[props, target ? target : this._target]});
	};

	/**
	 * Queues an action to play (unpause) the specified tween. This enables you to sequence multiple tweens.
	 * <h4>Example</h4>
	 *
	 *		myTween.to({x:100},500).play(otherTween);
	 *
	 * @method play
	 * @param {Tween} tween The tween to play.
	 * @return {Tween} This tween instance (for chaining calls).
	 */
	p.play = function(tween) {
		if (!tween) { tween = this; }
		return this.call(tween.setPaused, [false], tween);
	};

	/**
	 * Queues an action to pause the specified tween.
	 * @method pause
	 * @param {Tween} tween The tween to pause. If null, it pauses this tween.
	 * @return {Tween} This tween instance (for chaining calls)
	 */
	p.pause = function(tween) {
		if (!tween) { tween = this; }
		return this.call(tween.setPaused, [true], tween);
	};

	/**
	 * Advances the tween to a specified position.
	 * @method setPosition
	 * @param {Number} value The position to seek to in milliseconds (or ticks if useTicks is true).
	 * @param {Number} [actionsMode=1] Specifies how actions are handled (ie. call, set, play, pause):
	 * <ul>
	 *      <li>{{#crossLink "Tween/NONE:property"}}{{/crossLink}} (0) - run no actions.</li>
	 *      <li>{{#crossLink "Tween/LOOP:property"}}{{/crossLink}} (1) - if new position is less than old, then run all
	 *      actions between old and duration, then all actions between 0 and new.</li>
	 *      <li>{{#crossLink "Tween/REVERSE:property"}}{{/crossLink}} (2) - if new position is less than old, run all
	 *      actions between them in reverse.</li>
	 * </ul>
	 * @return {Boolean} Returns `true` if the tween is complete (ie. the full tween has run & {{#crossLink "Tween/loop:property"}}{{/crossLink}}
	 * is `false`).
	 */
	p.setPosition = function(value, actionsMode) {
		if (value < 0) { value = 0; }
		if (actionsMode == null) { actionsMode = 1; }

		// normalize position:
		var t = value;
		var end = false;
		if (t >= this.duration) {
			if (this.loop) { t = t%this.duration; }
			else {
				t = this.duration;
				end = true;
			}
		}
		if (t == this._prevPos) { return end; }


		var prevPos = this._prevPos;
		this.position = this._prevPos = t; // set this in advance in case an action modifies position.
		this._prevPosition = value;

		// handle tweens:
		if (this._target) {
			if (end) {
				// addresses problems with an ending zero length step.
				this._updateTargetProps(null,1);
			} else if (this._steps.length > 0) {
				// find our new tween index:
				for (var i=0, l=this._steps.length; i<l; i++) {
					if (this._steps[i].t > t) { break; }
				}
				var step = this._steps[i-1];
				this._updateTargetProps(step,(this._stepPosition = t-step.t)/step.d);
			}
		}

		// run actions:
		if (actionsMode != 0 && this._actions.length > 0) {
			if (this._useTicks) {
				// only run the actions we landed on.
				this._runActions(t,t);
			} else if (actionsMode == 1 && t<prevPos) {
				if (prevPos != this.duration) { this._runActions(prevPos, this.duration); }
				this._runActions(0, t, true);
			} else {
				this._runActions(prevPos, t);
			}
		}

		if (end) { this.setPaused(true); }

        this.dispatchEvent("change");
		return end;
	};

	/**
	 * Advances this tween by the specified amount of time in milliseconds (or ticks if`useTicks` is `true`).
	 * This is normally called automatically by the Tween engine (via {{#crossLink "Tween/tick"}}{{/crossLink}}), but is
	 * exposed for advanced uses.
	 * @method tick
	 * @param {Number} delta The time to advance in milliseconds (or ticks if `useTicks` is `true`).
	 */
	p.tick = function(delta) {
		if (this._paused) { return; }
		this.setPosition(this._prevPosition+delta);
	};

	/**
	 * Pauses or plays this tween.
	 * @method setPaused
	 * @param {Boolean} [value=true] Indicates whether the tween should be paused (`true`) or played (`false`).
	 * @return {Tween} This tween instance (for chaining calls)
	 */
	p.setPaused = function(value) {
		if (this._paused === !!value) { return this; }
		this._paused = !!value;
		Tween._register(this, !value);
		return this;
	};

	// tiny api (primarily for tool output):
	p.w = p.wait;
	p.t = p.to;
	p.c = p.call;
	p.s = p.set;

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 */
	p.toString = function() {
		return "[Tween]";
	};

	/**
	 * @method clone
	 * @protected
	 */
	p.clone = function() {
		throw("Tween can not be cloned.")
	};

// private methods:
	/**
	 * @method _updateTargetProps
	 * @param {Object} step
	 * @param {Number} ratio
	 * @protected
	 */
	p._updateTargetProps = function(step, ratio) {
		var p0,p1,v,v0,v1,arr;
		if (!step && ratio == 1) {
			// GDS: when does this run? Just at the very end? Shouldn't.
			this.passive = false;
			p0 = p1 = this._curQueueProps;
		} else {
			this.passive = !!step.v;
			if (this.passive) { return; } // don't update props.
			// apply ease to ratio.
			if (step.e) { ratio = step.e(ratio,0,1,1); }
			p0 = step.p0;
			p1 = step.p1;
		}

		for (var n in this._initQueueProps) {
			if ((v0 = p0[n]) == null) { p0[n] = v0 = this._initQueueProps[n]; }
			if ((v1 = p1[n]) == null) { p1[n] = v1 = v0; }
			if (v0 == v1 || ratio == 0 || ratio == 1 || (typeof(v0) != "number")) {
				// no interpolation - either at start, end, values don't change, or the value is non-numeric.
				v = ratio == 1 ? v1 : v0;
			} else {
				v = v0+(v1-v0)*ratio;
			}

			var ignore = false;
			if (arr = Tween._plugins[n]) {
				for (var i=0,l=arr.length;i<l;i++) {
					var v2 = arr[i].tween(this, n, v, p0, p1, ratio, !!step&&p0==p1, !step);
					if (v2 == Tween.IGNORE) { ignore = true; }
					else { v = v2; }
				}
			}
			if (!ignore) { this._target[n] = v; }
		}

	};

	/**
	 * @method _runActions
	 * @param {Number} startPos
	 * @param {Number} endPos
	 * @param {Boolean} includeStart
	 * @protected
	 */
	p._runActions = function(startPos, endPos, includeStart) {
		var sPos = startPos;
		var ePos = endPos;
		var i = -1;
		var j = this._actions.length;
		var k = 1;
		if (startPos > endPos) {
			// running backwards, flip everything:
			sPos = endPos;
			ePos = startPos;
			i = j;
			j = k = -1;
		}
		while ((i+=k) != j) {
			var action = this._actions[i];
			var pos = action.t;
			if (pos == ePos || (pos > sPos && pos < ePos) || (includeStart && pos == startPos) ) {
				action.f.apply(action.o, action.p);
			}
		}
	};

	/**
	 * @method _appendQueueProps
	 * @param {Object} o
	 * @protected
	 */
	p._appendQueueProps = function(o) {
		var arr,oldValue,i, l, injectProps;
		for (var n in o) {
			if (this._initQueueProps[n] === undefined) {
				oldValue = this._target[n];

				// init plugins:
				if (arr = Tween._plugins[n]) {
					for (i=0,l=arr.length;i<l;i++) {
						oldValue = arr[i].init(this, n, oldValue);
					}
				}
				this._initQueueProps[n] = this._curQueueProps[n] = (oldValue===undefined) ? null : oldValue;
			} else {
				oldValue = this._curQueueProps[n];
			}
		}

		for (var n in o) {
			oldValue = this._curQueueProps[n];
			if (arr = Tween._plugins[n]) {
				injectProps = injectProps||{};
				for (i=0, l=arr.length;i<l;i++) {
					// TODO: remove the check for .step in the next version. It's here for backwards compatibility.
					if (arr[i].step) { arr[i].step(this, n, oldValue, o[n], injectProps); }
				}
			}
			this._curQueueProps[n] = o[n];
		}
		if (injectProps) { this._appendQueueProps(injectProps); }
		return this._curQueueProps;
	};

	/**
	 * @method _cloneProps
	 * @param {Object} props
	 * @protected
	 */
	p._cloneProps = function(props) {
		var o = {};
		for (var n in props) {
			o[n] = props[n];
		}
		return o;
	};

	/**
	 * @method _addStep
	 * @param {Object} o
	 * @protected
	 */
	p._addStep = function(o) {
		if (o.d > 0) {
			this._steps.push(o);
			o.t = this.duration;
			this.duration += o.d;
		}
		return this;
	};

	/**
	 * @method _addAction
	 * @param {Object} o
	 * @protected
	 */
	p._addAction = function(o) {
		o.t = this.duration;
		this._actions.push(o);
		return this;
	};

	/**
	 * @method _set
	 * @param {Object} props
	 * @param {Object} o
	 * @protected
	 */
	p._set = function(props, o) {
		for (var n in props) {
			o[n] = props[n];
		}
	};

	createjs.Tween = createjs.promote(Tween, "EventDispatcher");

}());

//##############################################################################
// Timeline.js
//##############################################################################

this.createjs = this.createjs||{};


(function() {
	"use strict";
	

// constructor	
	/**
	 * The Timeline class synchronizes multiple tweens and allows them to be controlled as a group. Please note that if a
	 * timeline is looping, the tweens on it may appear to loop even if the "loop" property of the tween is false.
	 * @class Timeline
	 * @param {Array} tweens An array of Tweens to add to this timeline. See {{#crossLink "Timeline/addTween"}}{{/crossLink}}
	 * for more info.
	 * @param {Object} labels An object defining labels for using {{#crossLink "Timeline/gotoAndPlay"}}{{/crossLink}}/{{#crossLink "Timeline/gotoAndStop"}}{{/crossLink}}.
	 * See {{#crossLink "Timeline/setLabels"}}{{/crossLink}}
	 * for details.
	 * @param {Object} props The configuration properties to apply to this tween instance (ex. `{loop:true}`). All properties
	 * default to false. Supported props are:<UL>
	 *    <LI> loop: sets the loop property on this tween.</LI>
	 *    <LI> useTicks: uses ticks for all durations instead of milliseconds.</LI>
	 *    <LI> ignoreGlobalPause: sets the ignoreGlobalPause property on this tween.</LI>
	 *    <LI> paused: indicates whether to start the tween paused.</LI>
	 *    <LI> position: indicates the initial position for this timeline.</LI>
	 *    <LI> onChange: specifies a listener to add for the {{#crossLink "Timeline/change:event"}}{{/crossLink}} event.</LI>
	 * </UL>
	 * @extends EventDispatcher
	 * @constructor
	 **/
	function Timeline(tweens, labels, props) {
		this.EventDispatcher_constructor();

	// public properties:
		/**
		 * Causes this timeline to continue playing when a global pause is active.
		 * @property ignoreGlobalPause
		 * @type Boolean
		 **/
		this.ignoreGlobalPause = false;

		/**
		 * The total duration of this timeline in milliseconds (or ticks if `useTicks `is `true`). This value is usually
		 * automatically updated as you modify the timeline. See {{#crossLink "Timeline/updateDuration"}}{{/crossLink}}
		 * for more information.
		 * @property duration
		 * @type Number
		 * @default 0
		 * @readonly
		 **/
		this.duration = 0;

		/**
		 * If true, the timeline will loop when it reaches the end. Can be set via the props param.
		 * @property loop
		 * @type Boolean
		 **/
		this.loop = false;

		/**
		 * The current normalized position of the timeline. This will always be a value between 0 and
		 * {{#crossLink "Timeline/duration:property"}}{{/crossLink}}.
		 * Changing this property directly will have no effect.
		 * @property position
		 * @type Object
		 * @readonly
		 **/
		this.position = null;

		// private properties:
		/**
		 * @property _paused
		 * @type Boolean
		 * @protected
		 **/
		this._paused = false;

		/**
		 * @property _tweens
		 * @type Array[Tween]
		 * @protected
		 **/
		this._tweens = [];

		/**
		 * @property _labels
		 * @type Object
		 * @protected
		 **/
		this._labels = null;

		/**
		 * @property _labelList
		 * @type Array[Object]
		 * @protected
		 **/
		this._labelList = null;

		/**
		 * @property _prevPosition
		 * @type Number
		 * @default 0
		 * @protected
		 **/
		this._prevPosition = 0;

		/**
		 * @property _prevPos
		 * @type Number
		 * @default -1
		 * @protected
		 **/
		this._prevPos = -1;

		/**
		 * @property _useTicks
		 * @type Boolean
		 * @default false
		 * @protected
		 **/
		this._useTicks = false;
		
		/**
		 * Indicates whether the timeline is currently registered with Tween.
		 * @property _registered
		 * @type {boolean}
		 * @default false
		 * @protected
		 */
		this._registered = false;


		if (props) {
			this._useTicks = props.useTicks;
			this.loop = props.loop;
			this.ignoreGlobalPause = props.ignoreGlobalPause;
			props.onChange&&this.addEventListener("change", props.onChange);
		}
		if (tweens) { this.addTween.apply(this, tweens); }
		this.setLabels(labels);
		if (props&&props.paused) { this._paused=true; }
		else { createjs.Tween._register(this,true); }
		if (props&&props.position!=null) { this.setPosition(props.position, createjs.Tween.NONE); }
		
	};
	
	var p = createjs.extend(Timeline, createjs.EventDispatcher);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.

	
// events:
	/**
	 * Called whenever the timeline's position changes.
	 * @event change
	 * @since 0.5.0
	 **/


// public methods:
	/**
	 * Adds one or more tweens (or timelines) to this timeline. The tweens will be paused (to remove them from the
	 * normal ticking system) and managed by this timeline. Adding a tween to multiple timelines will result in
	 * unexpected behaviour.
	 * @method addTween
	 * @param {Tween} ...tween The tween(s) to add. Accepts multiple arguments.
	 * @return {Tween} The first tween that was passed in.
	 **/
	p.addTween = function(tween) {
		var l = arguments.length;
		if (l > 1) {
			for (var i=0; i<l; i++) { this.addTween(arguments[i]); }
			return arguments[0];
		} else if (l == 0) { return null; }
		this.removeTween(tween);
		this._tweens.push(tween);
		tween.setPaused(true);
		tween._paused = false;
		tween._useTicks = this._useTicks;
		if (tween.duration > this.duration) { this.duration = tween.duration; }
		if (this._prevPos >= 0) { tween.setPosition(this._prevPos, createjs.Tween.NONE); }
		return tween;
	};

	/**
	 * Removes one or more tweens from this timeline.
	 * @method removeTween
	 * @param {Tween} ...tween The tween(s) to remove. Accepts multiple arguments.
	 * @return Boolean Returns `true` if all of the tweens were successfully removed.
	 **/
	p.removeTween = function(tween) {
		var l = arguments.length;
		if (l > 1) {
			var good = true;
			for (var i=0; i<l; i++) { good = good && this.removeTween(arguments[i]); }
			return good;
		} else if (l == 0) { return false; }

		var tweens = this._tweens;
		var i = tweens.length;
		while (i--) {
			if (tweens[i] == tween) {
				tweens.splice(i, 1);
				if (tween.duration >= this.duration) { this.updateDuration(); }
				return true;
			}
		}
		return false;
	};

	/**
	 * Adds a label that can be used with {{#crossLink "Timeline/gotoAndPlay"}}{{/crossLink}}/{{#crossLink "Timeline/gotoAndStop"}}{{/crossLink}}.
	 * @method addLabel
	 * @param {String} label The label name.
	 * @param {Number} position The position this label represents.
	 **/
	p.addLabel = function(label, position) {
		this._labels[label] = position;
		var list = this._labelList;
		if (list) {
			for (var i= 0,l=list.length; i<l; i++) { if (position < list[i].position) { break; } }
			list.splice(i, 0, {label:label, position:position});
		}
	};

	/**
	 * Defines labels for use with gotoAndPlay/Stop. Overwrites any previously set labels.
	 * @method setLabels
	 * @param {Object} o An object defining labels for using {{#crossLink "Timeline/gotoAndPlay"}}{{/crossLink}}/{{#crossLink "Timeline/gotoAndStop"}}{{/crossLink}}
	 * in the form `{labelName:time}` where time is in milliseconds (or ticks if `useTicks` is `true`).
	 **/
	p.setLabels = function(o) {
		this._labels = o ?  o : {};
	};

	/**
	 * Returns a sorted list of the labels defined on this timeline.
	 * @method getLabels
	 * @return {Array[Object]} A sorted array of objects with label and position properties.
	 **/
	p.getLabels = function() {
		var list = this._labelList;
		if (!list) {
			list = this._labelList = [];
			var labels = this._labels;
			for (var n in labels) {
				list.push({label:n, position:labels[n]});
			}
			list.sort(function (a,b) { return a.position- b.position; });
		}
		return list;
	};

	/**
	 * Returns the name of the label on or immediately before the current position. For example, given a timeline with
	 * two labels, "first" on frame index 4, and "second" on frame 8, getCurrentLabel would return:
	 * <UL>
	 * 		<LI>null if the current position is 2.</LI>
	 * 		<LI>"first" if the current position is 4.</LI>
	 * 		<LI>"first" if the current position is 7.</LI>
	 * 		<LI>"second" if the current position is 15.</LI>
	 * </UL>
	 * @method getCurrentLabel
	 * @return {String} The name of the current label or null if there is no label
	 **/
	p.getCurrentLabel = function() {
		var labels = this.getLabels();
		var pos = this.position;
		var l = labels.length;
		if (l) {
			for (var i = 0; i<l; i++) { if (pos < labels[i].position) { break; } }
			return (i==0) ? null : labels[i-1].label;
		}
		return null;
	};

	/**
	 * Unpauses this timeline and jumps to the specified position or label.
	 * @method gotoAndPlay
	 * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`)
	 * or label to jump to.
	 **/
	p.gotoAndPlay = function(positionOrLabel) {
		this.setPaused(false);
		this._goto(positionOrLabel);
	};

	/**
	 * Pauses this timeline and jumps to the specified position or label.
	 * @method gotoAndStop
	 * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`) or label
	 * to jump to.
	 **/
	p.gotoAndStop = function(positionOrLabel) {
		this.setPaused(true);
		this._goto(positionOrLabel);
	};

	/**
	 * Advances the timeline to the specified position.
	 * @method setPosition
	 * @param {Number} value The position to seek to in milliseconds (or ticks if `useTicks` is `true`).
	 * @param {Number} [actionsMode] parameter specifying how actions are handled. See the Tween {{#crossLink "Tween/setPosition"}}{{/crossLink}}
	 * method for more details.
	 * @return {Boolean} Returns `true` if the timeline is complete (ie. the full timeline has run & {{#crossLink "Timeline/loop:property"}}{{/crossLink}}
	 * is `false`).
	 **/
	p.setPosition = function(value, actionsMode) {
		var t = this._calcPosition(value);
		var end = !this.loop && value >= this.duration;
		if (t == this._prevPos) { return end; }
		this._prevPosition = value;
		this.position = this._prevPos = t; // in case an action changes the current frame.
		for (var i=0, l=this._tweens.length; i<l; i++) {
			this._tweens[i].setPosition(t, actionsMode);
			if (t != this._prevPos) { return false; } // an action changed this timeline's position.
		}
		if (end) { this.setPaused(true); }
		this.dispatchEvent("change");
		return end;
	};

	/**
	 * Pauses or plays this timeline.
	 * @method setPaused
	 * @param {Boolean} value Indicates whether the tween should be paused (`true`) or played (`false`).
	 **/
	p.setPaused = function(value) {
		this._paused = !!value; 
		createjs.Tween._register(this, !value);
	};

	/**
	 * Recalculates the duration of the timeline. The duration is automatically updated when tweens are added or removed,
	 * but this method is useful if you modify a tween after it was added to the timeline.
	 * @method updateDuration
	 **/
	p.updateDuration = function() {
		this.duration = 0;
		for (var i=0,l=this._tweens.length; i<l; i++) {
			var tween = this._tweens[i];
			if (tween.duration > this.duration) { this.duration = tween.duration; }
		}
	};

	/**
	 * Advances this timeline by the specified amount of time in milliseconds (or ticks if `useTicks` is `true`).
	 * This is normally called automatically by the Tween engine (via the {{#crossLink "Tween/tick:event"}}{{/crossLink}}
	 * event), but is exposed for advanced uses.
	 * @method tick
	 * @param {Number} delta The time to advance in milliseconds (or ticks if useTicks is true).
	 **/
	p.tick = function(delta) {
		this.setPosition(this._prevPosition+delta);
	};

	/**
	 * If a numeric position is passed, it is returned unchanged. If a string is passed, the position of the
	 * corresponding frame label will be returned, or `null` if a matching label is not defined.
	 * @method resolve
	 * @param {String|Number} positionOrLabel A numeric position value or label string.
	 **/
	p.resolve = function(positionOrLabel) {
		var pos = Number(positionOrLabel);
		if (isNaN(pos)) { pos = this._labels[positionOrLabel]; }
		return pos;
	};

	/**
	* Returns a string representation of this object.
	* @method toString
	* @return {String} a string representation of the instance.
	**/
	p.toString = function() {
		return "[Timeline]";
	};

	/**
	 * @method clone
	 * @protected
	 **/
	p.clone = function() {
		throw("Timeline can not be cloned.")
	};

// private methods:
	/**
	 * @method _goto
	 * @param {String | Number} positionOrLabel
	 * @protected
	 **/
	p._goto = function(positionOrLabel) {
		var pos = this.resolve(positionOrLabel);
		if (pos != null) { this.setPosition(pos); }
	};
	
	/**
	 * @method _calcPosition
	 * @param {Number} value
	 * @return {Number}
	 * @protected
	 **/
	p._calcPosition = function(value) {
		if (value < 0) { return 0; }
		if (value < this.duration) { return value; }
		return this.loop ? value%this.duration : this.duration;
	};

	createjs.Timeline = createjs.promote(Timeline, "EventDispatcher");

}());

//##############################################################################
// Ease.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

	/**
	 * The Ease class provides a collection of easing functions for use with TweenJS. It does not use the standard 4 param
	 * easing signature. Instead it uses a single param which indicates the current linear ratio (0 to 1) of the tween.
	 *
	 * Most methods on Ease can be passed directly as easing functions:
	 *
	 *      Tween.get(target).to({x:100}, 500, Ease.linear);
	 *
	 * However, methods beginning with "get" will return an easing function based on parameter values:
	 *
	 *      Tween.get(target).to({y:200}, 500, Ease.getPowIn(2.2));
	 *
	 * Please see the <a href="http://www.createjs.com/Demos/TweenJS/Tween_SparkTable">spark table demo</a> for an
	 * overview of the different ease types on <a href="http://tweenjs.com">TweenJS.com</a>.
	 *
	 * <em>Equations derived from work by Robert Penner.</em>
	 * @class Ease
	 * @static
	 **/
	function Ease() {
		throw "Ease cannot be instantiated.";
	}


// static methods and properties
	/**
	 * @method linear
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.linear = function(t) { return t; };

	/**
	 * Identical to linear.
	 * @method none
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.none = Ease.linear;

	/**
	 * Mimics the simple -100 to 100 easing in Flash Pro.
	 * @method get
	 * @param {Number} amount A value from -1 (ease in) to 1 (ease out) indicating the strength and direction of the ease.
	 * @static
	 * @return {Function}
	 **/
	Ease.get = function(amount) {
		if (amount < -1) { amount = -1; }
		if (amount > 1) { amount = 1; }
		return function(t) {
			if (amount==0) { return t; }
			if (amount<0) { return t*(t*-amount+1+amount); }
			return t*((2-t)*amount+(1-amount));
		};
	};

	/**
	 * Configurable exponential ease.
	 * @method getPowIn
	 * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
	 * @static
	 * @return {Function}
	 **/
	Ease.getPowIn = function(pow) {
		return function(t) {
			return Math.pow(t,pow);
		};
	};

	/**
	 * Configurable exponential ease.
	 * @method getPowOut
	 * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
	 * @static
	 * @return {Function}
	 **/
	Ease.getPowOut = function(pow) {
		return function(t) {
			return 1-Math.pow(1-t,pow);
		};
	};

	/**
	 * Configurable exponential ease.
	 * @method getPowInOut
	 * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
	 * @static
	 * @return {Function}
	 **/
	Ease.getPowInOut = function(pow) {
		return function(t) {
			if ((t*=2)<1) return 0.5*Math.pow(t,pow);
			return 1-0.5*Math.abs(Math.pow(2-t,pow));
		};
	};

	/**
	 * @method quadIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quadIn = Ease.getPowIn(2);
	/**
	 * @method quadOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quadOut = Ease.getPowOut(2);
	/**
	 * @method quadInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quadInOut = Ease.getPowInOut(2);

	/**
	 * @method cubicIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.cubicIn = Ease.getPowIn(3);
	/**
	 * @method cubicOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.cubicOut = Ease.getPowOut(3);
	/**
	 * @method cubicInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.cubicInOut = Ease.getPowInOut(3);

	/**
	 * @method quartIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quartIn = Ease.getPowIn(4);
	/**
	 * @method quartOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quartOut = Ease.getPowOut(4);
	/**
	 * @method quartInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quartInOut = Ease.getPowInOut(4);

	/**
	 * @method quintIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quintIn = Ease.getPowIn(5);
	/**
	 * @method quintOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quintOut = Ease.getPowOut(5);
	/**
	 * @method quintInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quintInOut = Ease.getPowInOut(5);

	/**
	 * @method sineIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.sineIn = function(t) {
		return 1-Math.cos(t*Math.PI/2);
	};

	/**
	 * @method sineOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.sineOut = function(t) {
		return Math.sin(t*Math.PI/2);
	};

	/**
	 * @method sineInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.sineInOut = function(t) {
		return -0.5*(Math.cos(Math.PI*t) - 1);
	};

	/**
	 * Configurable "back in" ease.
	 * @method getBackIn
	 * @param {Number} amount The strength of the ease.
	 * @static
	 * @return {Function}
	 **/
	Ease.getBackIn = function(amount) {
		return function(t) {
			return t*t*((amount+1)*t-amount);
		};
	};
	/**
	 * @method backIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.backIn = Ease.getBackIn(1.7);

	/**
	 * Configurable "back out" ease.
	 * @method getBackOut
	 * @param {Number} amount The strength of the ease.
	 * @static
	 * @return {Function}
	 **/
	Ease.getBackOut = function(amount) {
		return function(t) {
			return (--t*t*((amount+1)*t + amount) + 1);
		};
	};
	/**
	 * @method backOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.backOut = Ease.getBackOut(1.7);

	/**
	 * Configurable "back in out" ease.
	 * @method getBackInOut
	 * @param {Number} amount The strength of the ease.
	 * @static
	 * @return {Function}
	 **/
	Ease.getBackInOut = function(amount) {
		amount*=1.525;
		return function(t) {
			if ((t*=2)<1) return 0.5*(t*t*((amount+1)*t-amount));
			return 0.5*((t-=2)*t*((amount+1)*t+amount)+2);
		};
	};
	/**
	 * @method backInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.backInOut = Ease.getBackInOut(1.7);

	/**
	 * @method circIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.circIn = function(t) {
		return -(Math.sqrt(1-t*t)- 1);
	};

	/**
	 * @method circOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.circOut = function(t) {
		return Math.sqrt(1-(--t)*t);
	};

	/**
	 * @method circInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.circInOut = function(t) {
		if ((t*=2) < 1) return -0.5*(Math.sqrt(1-t*t)-1);
		return 0.5*(Math.sqrt(1-(t-=2)*t)+1);
	};

	/**
	 * @method bounceIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.bounceIn = function(t) {
		return 1-Ease.bounceOut(1-t);
	};

	/**
	 * @method bounceOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.bounceOut = function(t) {
		if (t < 1/2.75) {
			return (7.5625*t*t);
		} else if (t < 2/2.75) {
			return (7.5625*(t-=1.5/2.75)*t+0.75);
		} else if (t < 2.5/2.75) {
			return (7.5625*(t-=2.25/2.75)*t+0.9375);
		} else {
			return (7.5625*(t-=2.625/2.75)*t +0.984375);
		}
	};

	/**
	 * @method bounceInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.bounceInOut = function(t) {
		if (t<0.5) return Ease.bounceIn (t*2) * .5;
		return Ease.bounceOut(t*2-1)*0.5+0.5;
	};

	/**
	 * Configurable elastic ease.
	 * @method getElasticIn
	 * @param {Number} amplitude
	 * @param {Number} period
	 * @static
	 * @return {Function}
	 **/
	Ease.getElasticIn = function(amplitude,period) {
		var pi2 = Math.PI*2;
		return function(t) {
			if (t==0 || t==1) return t;
			var s = period/pi2*Math.asin(1/amplitude);
			return -(amplitude*Math.pow(2,10*(t-=1))*Math.sin((t-s)*pi2/period));
		};
	};
	/**
	 * @method elasticIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.elasticIn = Ease.getElasticIn(1,0.3);

	/**
	 * Configurable elastic ease.
	 * @method getElasticOut
	 * @param {Number} amplitude
	 * @param {Number} period
	 * @static
	 * @return {Function}
	 **/
	Ease.getElasticOut = function(amplitude,period) {
		var pi2 = Math.PI*2;
		return function(t) {
			if (t==0 || t==1) return t;
			var s = period/pi2 * Math.asin(1/amplitude);
			return (amplitude*Math.pow(2,-10*t)*Math.sin((t-s)*pi2/period )+1);
		};
	};
	/**
	 * @method elasticOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.elasticOut = Ease.getElasticOut(1,0.3);

	/**
	 * Configurable elastic ease.
	 * @method getElasticInOut
	 * @param {Number} amplitude
	 * @param {Number} period
	 * @static
	 * @return {Function}
	 **/
	Ease.getElasticInOut = function(amplitude,period) {
		var pi2 = Math.PI*2;
		return function(t) {
			var s = period/pi2 * Math.asin(1/amplitude);
			if ((t*=2)<1) return -0.5*(amplitude*Math.pow(2,10*(t-=1))*Math.sin( (t-s)*pi2/period ));
			return amplitude*Math.pow(2,-10*(t-=1))*Math.sin((t-s)*pi2/period)*0.5+1;
		};
	};
	/**
	 * @method elasticInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.elasticInOut = Ease.getElasticInOut(1,0.3*1.5);

	createjs.Ease = Ease;

}());

//##############################################################################
// MotionGuidePlugin.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

	/**
	 * A TweenJS plugin for working with motion guides.
	 *
	 * To use, install the plugin after TweenJS has loaded. Next tween the 'guide' property with an object as detailed below.
	 *
	 *       createjs.MotionGuidePlugin.install();
	 *
	 * <h4>Example</h4>
	 *
	 *      // Using a Motion Guide
	 *	    createjs.Tween.get(target).to({guide:{ path:[0,0, 0,200,200,200, 200,0,0,0] }},7000);
	 *	    // Visualizing the line
	 *	    graphics.moveTo(0,0).curveTo(0,200,200,200).curveTo(200,0,0,0);
	 *
	 * Each path needs pre-computation to ensure there's fast performance. Because of the pre-computation there's no
	 * built in support for path changes mid tween. These are the Guide Object's properties:<UL>
	 *      <LI> path: Required, Array : The x/y points used to draw the path with a moveTo and 1 to n curveTo calls.</LI>
	 *      <LI> start: Optional, 0-1 : Initial position, default 0 except for when continuing along the same path.</LI>
	 *      <LI> end: Optional, 0-1 : Final position, default 1 if not specified.</LI>
	 *      <LI> orient: Optional, string : "fixed"/"auto"/"cw"/"ccw"<UL>
	 *				<LI>"fixed" forces the object to face down the path all movement (relative to start rotation),</LI>
	 *      		<LI>"auto" rotates the object along the path relative to the line.</LI>
	 *      		<LI>"cw"/"ccw" force clockwise or counter clockwise rotations including flash like behaviour</LI>
	 * 		</UL></LI>
	 * </UL>
	 * Guide objects should not be shared between tweens even if all properties are identical, the library stores
	 * information on these objects in the background and sharing them can cause unexpected behaviour. Values
	 * outside 0-1 range of tweens will be a "best guess" from the appropriate part of the defined curve.
	 *
	 * @class MotionGuidePlugin
	 * @constructor
	 **/
	function MotionGuidePlugin() {
		throw("MotionGuidePlugin cannot be instantiated.")
	};


// static properties:
	/**
	 * @property priority
	 * @protected
	 * @static
	 **/
	MotionGuidePlugin.priority = 0; // high priority, should run sooner

	/**
	 * @property temporary variable storage
	 * @private
	 * @static
	 */
	MotionGuidePlugin._rotOffS;
	/**
	 * @property temporary variable storage
	 * @private
	 * @static
	 */
	MotionGuidePlugin._rotOffE;
	/**
	 * @property temporary variable storage
	 * @private
	 * @static
	 */
	MotionGuidePlugin._rotNormS;
	/**
	 * @property temporary variable storage
	 * @private
	 * @static
	 */
	MotionGuidePlugin._rotNormE;


// static methods
	/**
	 * Installs this plugin for use with TweenJS. Call this once after TweenJS is loaded to enable this plugin.
	 * @method install
	 * @static
	 **/
	MotionGuidePlugin.install = function() {
		createjs.Tween.installPlugin(MotionGuidePlugin, ["guide", "x", "y", "rotation"]);
		return createjs.Tween.IGNORE;
	};

	/**
	 * @method init
	 * @protected
	 * @static
	 **/
	MotionGuidePlugin.init = function(tween, prop, value) {
		var target = tween.target;
		if(!target.hasOwnProperty("x")){ target.x = 0; }
		if(!target.hasOwnProperty("y")){ target.y = 0; }
		if(!target.hasOwnProperty("rotation")){ target.rotation = 0; }

		if(prop=="rotation"){ tween.__needsRot = true; }
		return prop=="guide"?null:value;
	};

	/**
	 * @method step
	 * @protected
	 * @static
	 **/
	MotionGuidePlugin.step = function(tween, prop, startValue, endValue, injectProps) {
		// other props
		if(prop == "rotation"){
			tween.__rotGlobalS = startValue;
			tween.__rotGlobalE = endValue;
			MotionGuidePlugin.testRotData(tween, injectProps);
		}
		if(prop != "guide"){ return endValue; }

		// guide only information - Start -
		var temp, data = endValue;
		if(!data.hasOwnProperty("path")){ data.path = []; }
		var path = data.path;
		if(!data.hasOwnProperty("end")){ data.end = 1; }
		if(!data.hasOwnProperty("start")){
			data.start = (startValue&&startValue.hasOwnProperty("end")&&startValue.path===path)?startValue.end:0;
		}

		// Figure out subline information
		if(data.hasOwnProperty("_segments") && data._length){ return endValue; }
		var l = path.length;
		var accuracy = 10;		// Adjust to improve line following precision but sacrifice performance (# of seg)
		if(l >= 6 && (l-2) % 4 == 0){	// Enough points && contains correct number per entry ignoring start
			data._segments = [];
			data._length = 0;
			for(var i=2; i<l; i+=4){
				var sx = path[i-2], sy = path[i-1];
				var cx = path[i+0], cy = path[i+1];
				var ex = path[i+2], ey = path[i+3];
				var oldX = sx, oldY = sy;
				var tempX, tempY, total = 0;
				var sublines = [];
				for(var j=1; j<=accuracy; j++){
					var t = j/accuracy;
					var inv = 1 - t;
					tempX = inv*inv * sx + 2 * inv * t * cx + t*t * ex;
					tempY = inv*inv * sy + 2 * inv * t * cy + t*t * ey;
					total += sublines[sublines.push(Math.sqrt((temp=tempX-oldX)*temp + (temp=tempY-oldY)*temp))-1];
					oldX = tempX;
					oldY = tempY;
				}
				data._segments.push(total);
				data._segments.push(sublines);
				data._length += total;
			}
		} else {
			throw("invalid 'path' data, please see documentation for valid paths");
		}

		// Setup x/y tweens
		temp = data.orient;
		data.orient = true;
		var o = {};
		MotionGuidePlugin.calc(data, data.start, o);
		tween.__rotPathS = Number(o.rotation.toFixed(5));
		MotionGuidePlugin.calc(data, data.end, o);
		tween.__rotPathE = Number(o.rotation.toFixed(5));
		data.orient = false;	//here and now we don't know if we need to
		MotionGuidePlugin.calc(data, data.end, injectProps);
		data.orient = temp;

		// Setup rotation properties
		if(!data.orient){ return endValue; }
		tween.__guideData = data;
		MotionGuidePlugin.testRotData(tween, injectProps);
		return endValue;
	};

	/**
	 * @method testRotData
	 * @protected
	 * @static
	 **/
	MotionGuidePlugin.testRotData = function(tween, injectProps){

		// no rotation informat? if we need it come back, if we don't use 0 & ensure we have guide data
		if(tween.__rotGlobalS === undefined || tween.__rotGlobalE === undefined){
			if(tween.__needsRot){ return; }
			if(tween._curQueueProps.rotation !== undefined){
				tween.__rotGlobalS = tween.__rotGlobalE = tween._curQueueProps.rotation;
			} else {
				tween.__rotGlobalS = tween.__rotGlobalE = injectProps.rotation = tween.target.rotation || 0;
			}
		}
		if(tween.__guideData === undefined){ return; }

		// Process rotation properties
		var data = tween.__guideData;
		var rotGlobalD = tween.__rotGlobalE - tween.__rotGlobalS;
		var rotPathD = tween.__rotPathE - tween.__rotPathS;
		var rot = rotGlobalD - rotPathD;

		if(data.orient == "auto"){
			if(rot > 180){			rot -= 360; }
			else if(rot < -180){	rot += 360; }

		} else if(data.orient == "cw"){
			while(rot < 0){ rot += 360; }
			if(rot == 0 && rotGlobalD > 0 && rotGlobalD != 180){ rot += 360; }

		} else if(data.orient == "ccw"){
			rot = rotGlobalD - ((rotPathD > 180)?(360-rotPathD):(rotPathD));	// sign flipping on path
			while(rot > 0){ rot -= 360; }
			if(rot == 0 && rotGlobalD < 0 && rotGlobalD != -180){ rot -= 360; }
		}

		data.rotDelta = rot;
		data.rotOffS = tween.__rotGlobalS - tween.__rotPathS;

		// reset
		tween.__rotGlobalS = tween.__rotGlobalE = tween.__guideData = tween.__needsRot = undefined;
	};

	/**
	 * @method tween
	 * @protected
	 * @static
	 **/
	MotionGuidePlugin.tween = function(tween, prop, value, startValues, endValues, ratio, wait, end) {
		var data = endValues.guide;
		if(data == undefined || data === startValues.guide){ return value; }
		if(data.lastRatio != ratio){
			// first time through so calculate what I need to
			var t = ((data.end-data.start)*(wait?data.end:ratio)+data.start);
			MotionGuidePlugin.calc(data, t, tween.target);
			switch(data.orient){
				case "cw":		// mix in the original rotation
				case "ccw":
				case "auto": tween.target.rotation += data.rotOffS + data.rotDelta*ratio; break;
				case "fixed":	// follow fixed behaviour to solve potential issues
				default: tween.target.rotation += data.rotOffS; break;
			}
			data.lastRatio = ratio;
		}
		if(prop == "rotation" && ((!data.orient) || data.orient == "false")){ return value; }
		return tween.target[prop];
	};

	/**
	 * Determine the appropriate x/y/rotation information about a path for a given ratio along the path.
	 * Assumes a path object with all optional parameters specified.
	 * @param data Data object you would pass to the "guide:" property in a Tween
	 * @param ratio 0-1 Distance along path, values outside 0-1 are "best guess"
	 * @param target Object to copy the results onto, will use a new object if not supplied.
	 * @return {Object} The target object or a new object w/ the tweened properties
	 * @static
	 */
	MotionGuidePlugin.calc = function(data, ratio, target) {
		if(data._segments == undefined){ MotionGuidePlugin.validate(data); }
		if(target == undefined){ target = {x:0, y:0, rotation:0}; }
		var seg = data._segments;
		var path = data.path;

		// find segment
		var pos = data._length * ratio;
		var cap = seg.length - 2;
		var n = 0;
		while(pos > seg[n] && n < cap){
			pos -= seg[n];
			n+=2;
		}

		// find subline
		var sublines = seg[n+1];
		var i = 0;
		cap = sublines.length-1;
		while(pos > sublines[i] && i < cap){
			pos -= sublines[i];
			i++;
		}
		var t = (i/++cap)+(pos/(cap*sublines[i]));

		// find x/y
		n = (n*2)+2;
		var inv = 1 - t;
		target.x = inv*inv * path[n-2] + 2 * inv * t * path[n+0] + t*t * path[n+2];
		target.y = inv*inv * path[n-1] + 2 * inv * t * path[n+1] + t*t * path[n+3];

		// orientation
		if(data.orient){
			target.rotation = 57.2957795 * Math.atan2(
				(path[n+1]-path[n-1])*inv + (path[n+3]-path[n+1])*t,
				(path[n+0]-path[n-2])*inv + (path[n+2]-path[n+0])*t);
		}

		return target;
	};

	createjs.MotionGuidePlugin = MotionGuidePlugin;

}());

//##############################################################################
// version.js
//##############################################################################

this.createjs = this.createjs || {};

(function() {
	"use strict";

	/**
	 * Static class holding library specific information such as the version and buildDate of
	 * the library.
	 * @class TweenJS
	 **/
	var s = createjs.TweenJS = createjs.TweenJS || {};

	/**
	 * The version string for this release.
	 * @property version
	 * @type String
	 * @static
	 **/
	s.version = /*=version*/"0.6.1"; // injected by build process

	/**
	 * The build date for this release in UTC format.
	 * @property buildDate
	 * @type String
	 * @static
	 **/
	s.buildDate = /*=date*/"Thu, 21 May 2015 16:17:37 GMT"; // injected by build process

})();
if(typeof module !== "undefined" && typeof module.exports !== "undefined") module.exports = this.createjs;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],15:[function(require,module,exports){
/*!
 * enquire.js v2.1.1 - Awesome Media Queries in JavaScript
 * Copyright (c) 2014 Nick Williams - http://wicky.nillia.ms/enquire.js
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

;(function (name, context, factory) {
	var matchMedia = window.matchMedia;

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = factory(matchMedia);
	}
	else if (typeof define === 'function' && define.amd) {
		define(function() {
			return (context[name] = factory(matchMedia));
		});
	}
	else {
		context[name] = factory(matchMedia);
	}
}('enquire', this, function (matchMedia) {

	'use strict';

    /*jshint unused:false */
    /**
     * Helper function for iterating over a collection
     *
     * @param collection
     * @param fn
     */
    function each(collection, fn) {
        var i      = 0,
            length = collection.length,
            cont;

        for(i; i < length; i++) {
            cont = fn(collection[i], i);
            if(cont === false) {
                break; //allow early exit
            }
        }
    }

    /**
     * Helper function for determining whether target object is an array
     *
     * @param target the object under test
     * @return {Boolean} true if array, false otherwise
     */
    function isArray(target) {
        return Object.prototype.toString.apply(target) === '[object Array]';
    }

    /**
     * Helper function for determining whether target object is a function
     *
     * @param target the object under test
     * @return {Boolean} true if function, false otherwise
     */
    function isFunction(target) {
        return typeof target === 'function';
    }

    /**
     * Delegate to handle a media query being matched and unmatched.
     *
     * @param {object} options
     * @param {function} options.match callback for when the media query is matched
     * @param {function} [options.unmatch] callback for when the media query is unmatched
     * @param {function} [options.setup] one-time callback triggered the first time a query is matched
     * @param {boolean} [options.deferSetup=false] should the setup callback be run immediately, rather than first time query is matched?
     * @constructor
     */
    function QueryHandler(options) {
        this.options = options;
        !options.deferSetup && this.setup();
    }
    QueryHandler.prototype = {

        /**
         * coordinates setup of the handler
         *
         * @function
         */
        setup : function() {
            if(this.options.setup) {
                this.options.setup();
            }
            this.initialised = true;
        },

        /**
         * coordinates setup and triggering of the handler
         *
         * @function
         */
        on : function() {
            !this.initialised && this.setup();
            this.options.match && this.options.match();
        },

        /**
         * coordinates the unmatch event for the handler
         *
         * @function
         */
        off : function() {
            this.options.unmatch && this.options.unmatch();
        },

        /**
         * called when a handler is to be destroyed.
         * delegates to the destroy or unmatch callbacks, depending on availability.
         *
         * @function
         */
        destroy : function() {
            this.options.destroy ? this.options.destroy() : this.off();
        },

        /**
         * determines equality by reference.
         * if object is supplied compare options, if function, compare match callback
         *
         * @function
         * @param {object || function} [target] the target for comparison
         */
        equals : function(target) {
            return this.options === target || this.options.match === target;
        }

    };
    /**
     * Represents a single media query, manages it's state and registered handlers for this query
     *
     * @constructor
     * @param {string} query the media query string
     * @param {boolean} [isUnconditional=false] whether the media query should run regardless of whether the conditions are met. Primarily for helping older browsers deal with mobile-first design
     */
    function MediaQuery(query, isUnconditional) {
        this.query = query;
        this.isUnconditional = isUnconditional;
        this.handlers = [];
        this.mql = matchMedia(query);

        var self = this;
        this.listener = function(mql) {
            self.mql = mql;
            self.assess();
        };
        this.mql.addListener(this.listener);
    }
    MediaQuery.prototype = {

        /**
         * add a handler for this query, triggering if already active
         *
         * @param {object} handler
         * @param {function} handler.match callback for when query is activated
         * @param {function} [handler.unmatch] callback for when query is deactivated
         * @param {function} [handler.setup] callback for immediate execution when a query handler is registered
         * @param {boolean} [handler.deferSetup=false] should the setup callback be deferred until the first time the handler is matched?
         */
        addHandler : function(handler) {
            var qh = new QueryHandler(handler);
            this.handlers.push(qh);

            this.matches() && qh.on();
        },

        /**
         * removes the given handler from the collection, and calls it's destroy methods
         * 
         * @param {object || function} handler the handler to remove
         */
        removeHandler : function(handler) {
            var handlers = this.handlers;
            each(handlers, function(h, i) {
                if(h.equals(handler)) {
                    h.destroy();
                    return !handlers.splice(i,1); //remove from array and exit each early
                }
            });
        },

        /**
         * Determine whether the media query should be considered a match
         * 
         * @return {Boolean} true if media query can be considered a match, false otherwise
         */
        matches : function() {
            return this.mql.matches || this.isUnconditional;
        },

        /**
         * Clears all handlers and unbinds events
         */
        clear : function() {
            each(this.handlers, function(handler) {
                handler.destroy();
            });
            this.mql.removeListener(this.listener);
            this.handlers.length = 0; //clear array
        },

        /*
         * Assesses the query, turning on all handlers if it matches, turning them off if it doesn't match
         */
        assess : function() {
            var action = this.matches() ? 'on' : 'off';

            each(this.handlers, function(handler) {
                handler[action]();
            });
        }
    };
    /**
     * Allows for registration of query handlers.
     * Manages the query handler's state and is responsible for wiring up browser events
     *
     * @constructor
     */
    function MediaQueryDispatch () {
        if(!matchMedia) {
            throw new Error('matchMedia not present, legacy browsers require a polyfill');
        }

        this.queries = {};
        this.browserIsIncapable = !matchMedia('only all').matches;
    }

    MediaQueryDispatch.prototype = {

        /**
         * Registers a handler for the given media query
         *
         * @param {string} q the media query
         * @param {object || Array || Function} options either a single query handler object, a function, or an array of query handlers
         * @param {function} options.match fired when query matched
         * @param {function} [options.unmatch] fired when a query is no longer matched
         * @param {function} [options.setup] fired when handler first triggered
         * @param {boolean} [options.deferSetup=false] whether setup should be run immediately or deferred until query is first matched
         * @param {boolean} [shouldDegrade=false] whether this particular media query should always run on incapable browsers
         */
        register : function(q, options, shouldDegrade) {
            var queries         = this.queries,
                isUnconditional = shouldDegrade && this.browserIsIncapable;

            if(!queries[q]) {
                queries[q] = new MediaQuery(q, isUnconditional);
            }

            //normalise to object in an array
            if(isFunction(options)) {
                options = { match : options };
            }
            if(!isArray(options)) {
                options = [options];
            }
            each(options, function(handler) {
                queries[q].addHandler(handler);
            });

            return this;
        },

        /**
         * unregisters a query and all it's handlers, or a specific handler for a query
         *
         * @param {string} q the media query to target
         * @param {object || function} [handler] specific handler to unregister
         */
        unregister : function(q, handler) {
            var query = this.queries[q];

            if(query) {
                if(handler) {
                    query.removeHandler(handler);
                }
                else {
                    query.clear();
                    delete this.queries[q];
                }
            }

            return this;
        }
    };

	return new MediaQueryDispatch();

}));
},{}],16:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v2.2.2
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-03-17T17:51Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//"use strict";
var arr = [];

var document = window.document;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	version = "2.2.2",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = jQuery.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		var realStringObj = obj && obj.toString();
		return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
	},

	isPlainObject: function( obj ) {
		var key;

		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		// Not own constructor property must be Object
		if ( obj.constructor &&
				!hasOwn.call( obj, "constructor" ) &&
				!hasOwn.call( obj.constructor.prototype || {}, "isPrototypeOf" ) ) {
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {

			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf( "use strict" ) === 1 ) {
				script = document.createElement( "script" );
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {

				// Otherwise, avoid the DOM node creation, insertion
				// and removal by using an indirect global eval

				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

// JSHint would error on this code due to the Symbol not being defined in ES5.
// Defining this global in .jshintrc would create a danger of using the global
// unguarded in another place, it seems safer to just disable JSHint for these
// three lines.
/* jshint ignore: start */
if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}
/* jshint ignore: end */

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: iOS 8.2 (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.1
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-10-17
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, nidselect, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
					while ( i-- ) {
						groups[i] = nidselect + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( (parent = document.defaultView) && parent.top !== parent ) {
		// Support: IE 11
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( document.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				return m ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( (oldCache = uniqueCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		} );

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {

						// Inject the element directly into the jQuery object
						this.length = 1;
						this[ 0 ] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

				// Always skip document fragments
				if ( cur.nodeType < 11 && ( pos ?
					pos.index( cur ) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector( cur, selectors ) ) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnotwhite = ( /\S+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];

							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this === promise ? newDefer.promise() : this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add( function() {

					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 ||
				( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred.
			// If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.progress( updateFunc( i, progressContexts, progressValues ) )
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
} );


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {

	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
} );

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called
		// after the browser event has already occurred.
		// Support: IE9-10 only
		// Older IE sometimes signals "interactive" too soon
		if ( document.readyState === "complete" ||
			( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

			// Handle it asynchronously to allow scripts the opportunity to delay ready
			window.setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	register: function( owner, initial ) {
		var value = initial || {};

		// If it is a node unlikely to be stringify-ed or looped over
		// use plain assignment
		if ( owner.nodeType ) {
			owner[ this.expando ] = value;

		// Otherwise secure it in a non-enumerable, non-writable property
		// configurability must be true to allow the property to be
		// deleted with the delete operator
		} else {
			Object.defineProperty( owner, this.expando, {
				value: value,
				writable: true,
				configurable: true
			} );
		}
		return owner[ this.expando ];
	},
	cache: function( owner ) {

		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return an empty object.
		if ( !acceptData( owner ) ) {
			return {};
		}

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ prop ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :
			owner[ this.expando ] && owner[ this.expando ][ key ];
	},
	access: function( owner, key, value ) {
		var stored;

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase( key ) );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key === undefined ) {
			this.register( owner );

		} else {

			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {

				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );

				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;

			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <= 35-45+
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://code.google.com/p/chromium/issues/detail?id=378607
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :

					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data, camelKey;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// with the key as-is
				data = dataUser.get( elem, key ) ||

					// Try to find dashed key if it exists (gh-2779)
					// This is for 2.2.x only
					dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );

				if ( data !== undefined ) {
					return data;
				}

				camelKey = jQuery.camelCase( key );

				// Attempt to get data from the cache
				// with the key camelized
				data = dataUser.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			camelKey = jQuery.camelCase( key );
			this.each( function() {

				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = dataUser.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				dataUser.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
					dataUser.set( this, key, value );
				}
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {

		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" ||
			!jQuery.contains( elem.ownerDocument, elem );
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() { return tween.cur(); } :
			function() { return jQuery.css( elem, prop, "" ); },
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([\w:-]+)/ );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE9
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE9-11+
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== "undefined" ?
				context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android<4.1, PhantomJS<2
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android<4.1, PhantomJS<2
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0-4.3, Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE9
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Support (at least): Chrome, IE9
		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		//
		// Support: Firefox<=42+
		// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
		if ( delegateCount && cur.nodeType &&
			( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push( { elem: cur, handlers: matches } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
		"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split( " " ),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
			"screenX screenY toElement" ).split( " " ),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX +
					( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
					( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY +
					( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
					( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://code.google.com/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {
	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,

	// Support: IE 10-11, Edge 10240+
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName( "tbody" )[ 0 ] ||
			elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android<4.1, PhantomJS<2
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <= 35-45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <= 35-45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {

	// Keep domManip exposed until 3.0 (gh-2225)
	domManip: domManip,

	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );


var iframe,
	elemdisplay = {

		// Support: Firefox
		// We have to pre-define these values for FF (#10227)
		HTML: "block",
		BODY: "block"
	};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */

// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		display = jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
				.appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var documentElement = document.documentElement;



( function() {
	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {
		div.style.cssText =

			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );
	}

	jQuery.extend( support, {
		pixelPosition: function() {

			// This test is executed only once but we still do memoizing
			// since we can use the boxSizingReliable pre-computing.
			// No need to check if the test was already performed, though.
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {

			// Support: Android 4.0-4.3
			// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
			// since that compresses better and they're computed together anyway.
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {

			// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return reliableMarginLeftVal;
		},
		reliableMarginRight: function() {

			// Support: Android 2.3
			// Check if div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container. (#3333)
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			// This support function is only executed once so no memoizing is needed.
			var ret,
				marginDiv = div.appendChild( document.createElement( "div" ) );

			// Reset CSS: box-sizing; display; margin; border; padding
			marginDiv.style.cssText = div.style.cssText =

				// Support: Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;box-sizing:content-box;" +
				"display:block;margin:0;border:0;padding:0";
			marginDiv.style.marginRight = marginDiv.style.width = "0";
			div.style.width = "1px";
			documentElement.appendChild( container );

			ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );

			documentElement.removeChild( container );
			div.removeChild( marginDiv );

			return ret;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );
	ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

	// Support: Opera 12.1x only
	// Fall back to style even without computed
	// computed is undefined for elems on document fragments
	if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {
		ret = jQuery.style( elem, name );
	}

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// http://dev.w3.org/csswg/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE9-11+
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?

		// If we already have the right measurement, avoid augmentation
		4 :

		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Support: IE11 only
	// In IE 11 fullscreen elements inside of an iframe have
	// 100x too small dimensions (gh-1764).
	if ( document.msFullscreenElement && window.top !== window ) {

		// Support: IE11 only
		// Running getBoundingClientRect on a disconnected node
		// in IE throws an error.
		if ( elem.getClientRects().length ) {
			val = Math.round( elem.getBoundingClientRect()[ name ] * 100 );
		}
	}

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {

		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test( val ) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = dataPriv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {

			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = dataPriv.access(
					elem,
					"olddisplay",
					defaultDisplay( elem.nodeName )
				);
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				dataPriv.set(
					elem,
					"olddisplay",
					hidden ? display : jQuery.css( elem, "display" )
				);
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				style[ name ] = value;
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}
		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
					elem.offsetWidth === 0 ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {

		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show
				// and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = dataPriv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done( function() {
				jQuery( elem ).hide();
			} );
		}
		anim.done( function() {
			var prop;

			dataPriv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		} );
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {
	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnotwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
		opt.duration : opt.duration in jQuery.fx.speeds ?
			jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	window.clearInterval( timerId );

	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {

					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) && elem.href ?
							0 :
							-1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {
			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




var rclass = /[\t\r\n\f]/g;

function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnotwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + getClass( elem ) + " " ).replace( rclass, " " )
					.indexOf( className ) > -1
			) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g,
	rspaces = /[\x20\t\r\n\f]+/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?

					// Handle most common string cases
					ret.replace( rreturn, "" ) :

					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ?
								!option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled ||
								!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true

				// Previously, `originalEvent: {}` was set here, so stopPropagation call
				// would not be triggered on donor event, since in our own
				// jQuery.event.stopPropagation function we had a check for existence of
				// originalEvent.stopPropagation method, so, consequently it would be a noop.
				//
				// But now, this "simulate" function is used only for events
				// for which stopPropagation() is noop, so there is no need for that anymore.
				//
				// For the 1.x branch though, guard for "click" and "submit"
				// events is still used, but was moved to jQuery.event.stopPropagation function
				// because `originalEvent` should point to the original event for the constancy
				// with other events and for more focused logic
			}
		);

		jQuery.event.trigger( e, null, elem );

		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome, Safari
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// The jqXHR state
			state = 0,

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {

								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE8-11+
			// IE throws exception if url is malformed, e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE8-11+
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( state === 2 ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );

				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapAll( html.call( this, i ) );
			} );
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function() {
		return this.parent().each( function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		} ).end();
	}
} );


jQuery.expr.filters.hidden = function( elem ) {
	return !jQuery.expr.filters.visible( elem );
};
jQuery.expr.filters.visible = function( elem ) {

	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	// Use OR instead of AND as the element is not visible if either is true
	// See tickets #10406 and #13132
	return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {

			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} ) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE9
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE9
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( self, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		box = elem.getBoundingClientRect();
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari<7-8+, Chrome<37-44+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},
	size: function() {
		return this.length;
	}
} );

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}



var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}

return jQuery;
}));

},{}],17:[function(require,module,exports){
'use strict'

module.exports = function(stage, resized) {

	var createjs = require('createjs-collection');

	var squareWidth, squareHeight, xOffset, yOffset, spacing;

	setStageSize();
	setSquareDimensions();
	setOffsets();

	for (var i = 0; i < 4; i++) {
		if (!resized)
			addSquare();
		else
			redrawSquare(i);
	}

	stage.update();

	function setStageSize() {

		var gameSection = document.getElementById('gameSection');

		// resize canvas to be responsive with section element
		var width = gameSection.offsetWidth,
			height = gameSection.offsetHeight;

		// this ensures the squares are always squares and fit within the screen
		if (width > height) {
			stage.canvas.width = height;
			stage.canvas.height = height;
		} else {
			stage.canvas.width = width;
			stage.canvas.height = width;
		}

	};

	function setSquareDimensions() {

		// square dimensions
		squareWidth = stage.canvas.width * 0.4;
		squareHeight = stage.canvas.height * 0.4;

	};

	function setOffsets() {

		// x and y offsets from center for square positioning
		xOffset = (stage.canvas.width / 2) - squareWidth - 5;
		yOffset = (stage.canvas.height / 2) - squareHeight - 5;

		// spacing between the squares
		spacing = 10;

	};

	function addSquare() {

		var square = new createjs.Shape();
		square.graphics.beginFill(getSquareColor(square.id)).drawRect(0, 0, squareWidth, squareHeight);
		square.shadow = new createjs.Shadow("#000", 5, 5, 10);
		square.x = getXPosition(square.id);
		square.y = getYPosition(square.id);
		stage.addChild(square);

	};

	function redrawSquare(squareIndex) {

		var square = stage.getChildAt(squareIndex);
		square.graphics.clear();
		square.graphics.beginFill(getSquareColor(square.id)).drawRect(0, 0, squareWidth, squareHeight);
		square.shadow = new createjs.Shadow("#000", 5, 5, 10);
		square.x = getXPosition(square.id);
		square.y = getYPosition(square.id);

	};

	function getSquareColor(squareId) {

		if (squareId === 1) 
			return "red";
		else if (squareId === 2) 
			return "green";
		else if (squareId === 3)
			return "blue";
		else
			return "yellow";

	}

	function getXPosition(squareId) {

		if (squareId === 1 || squareId === 3) 
			return xOffset;
		else 
			return xOffset + squareWidth + spacing;

	};

	function getYPosition(squareId) {

		if (squareId === 1 || squareId === 2) 
			return yOffset;
		else 
			return yOffset + squareHeight + spacing;

	};

	/*
		Draw Function Uses:
		- drawRect
		- apply shadow
		- add the rectangle to the canvas

	/* 
		-Changing x moves the shape horizonatally
		-Changing y moves the shape vertically
		-Changing alpha will fade the shape in and out
	*/

	/*
		createjs.Tween.get(circle, { loop: true })
			.to({ x: 400 }, 1000, createjs.Ease.getPowInOut(4))
			.to({ alpha: 0, y: 175 }, 500, createjs.Ease.getPowInOut(2))
			.to({ alpha: 0, y: 225 }, 100)
			.to({ alpha: 1, y: 200 }, 500, createjs.Ease.getPowInOut(2))
			.to({ x: 100 }, 800, createjs.Ease.getPowInOut(2));

		createjs.Ticker.setFPS(60);
		createjs.Ticker.addEventListener("tick", stage);
	*/

};
},{"createjs-collection":14}],18:[function(require,module,exports){
module.exports = (function() {

    var enquire = require('enquire.js');
    var button = document.getElementById('startButton');

    enquire
        .register("(min-width: 768px), (min-height: 768px)", {
            match : function() {
                button.className = 'btn btn-success btn-lg';
            },
            unmatch : function() {
                button.className = 'btn btn-success btn-md';
            }
        });
});
},{"enquire.js":15}],19:[function(require,module,exports){
module.exports = function() {

	var createjs = require('createjs-collection');

	var canvas, stage;
		
	canvas = document.getElementById('gameCanvas');
	stage = new createjs.Stage(canvas);

	createjs.Touch.enable(stage);

	stage.enableMouseOver(10);
	stage.mouseMoveOutside = true;

	return stage;

};
},{"createjs-collection":14}],20:[function(require,module,exports){
(function (global){
(function() {

	'use strict'

	var init = require('./init'),
		draw = require('./drawSquares'),
		sequence = require('./startRandomSequence'),
		$ = require('jquery'),
		enquireStyles = require('./enquireJSStyles');

	global.jQuery = $;

	require('bootstrap');

	var stage;

	// Polling for the sake of my intern tests
	var interval = setInterval(function() {
	    if(document.readyState === 'complete') {
	        clearInterval(interval);
	        done();
	    }    
	}, 100);

	function done() {

		// setup the stage
		stage = init();

		// apply media query styles
		enquireStyles();

		// draw squares onto the stage
		draw(stage, false);

		// display game rules and how to play
		$('#gameModal').modal('show');

		console.log('initialized');

	};

	// begin game with start button press
	var startBtn = document.getElementById('startButton');

	startBtn.onclick = function(e) {

		// user can't spam the start button
		startBtn.disabled = true;

		console.log("begin sequence");

		// begin the sequence
		sequence(stage);

		
	};

	window.addEventListener('resize', resize, false);

	function resize() {

		draw(stage, true);

	};

})();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./drawSquares":17,"./enquireJSStyles":18,"./init":19,"./startRandomSequence":22,"bootstrap":1,"jquery":16}],21:[function(require,module,exports){
'use strict'

module.exports = function (min, max) {

	return Math.floor(Math.random() * (max-min+1) + min);

}
},{}],22:[function(require,module,exports){
'use strict'

module.exports = function (stage) {

	var squareNum = require('./randomIntFromInterval'),
	createjs = require('createjs-collection');

	createjs.Ticker.addEventListener("tick", tick);

	var update = true;

	(function fadeSquare(i) {          
	   	setTimeout(function () {   
	   		var square = stage.getChildAt(squareNum(0, 3));

			createjs.Tween.get(square).wait(1000).play(
				createjs.Tween.get(square,{paused:true})
				.to({alpha:0.5}, 1500)
				.to({alpha:1}, 1500)
			);

	    	if (--i) fadeSquare(i); 
	   	}, 3000)
	})(4);  

	function tick(event) {

		update = false; 
		stage.update(event);

	};

}
},{"./randomIntFromInterval":21,"createjs-collection":14}]},{},[20])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvbnBtLmpzIiwibm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy9hZmZpeC5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvYWxlcnQuanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL2J1dHRvbi5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvY2Fyb3VzZWwuanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL2NvbGxhcHNlLmpzIiwibm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy9kcm9wZG93bi5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvbW9kYWwuanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL3BvcG92ZXIuanMiLCJub2RlX21vZHVsZXMvYm9vdHN0cmFwL2pzL3Njcm9sbHNweS5qcyIsIm5vZGVfbW9kdWxlcy9ib290c3RyYXAvanMvdGFiLmpzIiwibm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy90b29sdGlwLmpzIiwibm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9qcy90cmFuc2l0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NyZWF0ZWpzLWNvbGxlY3Rpb24vY3JlYXRlanMuanMiLCJub2RlX21vZHVsZXMvZW5xdWlyZS5qcy9kaXN0L2VucXVpcmUuanMiLCJub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzIiwicHVibGljL2pzL2RyYXdTcXVhcmVzLmpzIiwicHVibGljL2pzL2VucXVpcmVKU1N0eWxlcy5qcyIsInB1YmxpYy9qcy9pbml0LmpzIiwicHVibGljL2pzL21haW4uanMiLCJwdWJsaWMvanMvcmFuZG9tSW50RnJvbUludGVydmFsLmpzIiwicHVibGljL2pzL3N0YXJ0UmFuZG9tU2VxdWVuY2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcHJ0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xuVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8gVGhpcyBmaWxlIGlzIGF1dG9nZW5lcmF0ZWQgdmlhIHRoZSBgY29tbW9uanNgIEdydW50IHRhc2suIFlvdSBjYW4gcmVxdWlyZSgpIHRoaXMgZmlsZSBpbiBhIENvbW1vbkpTIGVudmlyb25tZW50LlxucmVxdWlyZSgnLi4vLi4vanMvdHJhbnNpdGlvbi5qcycpXG5yZXF1aXJlKCcuLi8uLi9qcy9hbGVydC5qcycpXG5yZXF1aXJlKCcuLi8uLi9qcy9idXR0b24uanMnKVxucmVxdWlyZSgnLi4vLi4vanMvY2Fyb3VzZWwuanMnKVxucmVxdWlyZSgnLi4vLi4vanMvY29sbGFwc2UuanMnKVxucmVxdWlyZSgnLi4vLi4vanMvZHJvcGRvd24uanMnKVxucmVxdWlyZSgnLi4vLi4vanMvbW9kYWwuanMnKVxucmVxdWlyZSgnLi4vLi4vanMvdG9vbHRpcC5qcycpXG5yZXF1aXJlKCcuLi8uLi9qcy9wb3BvdmVyLmpzJylcbnJlcXVpcmUoJy4uLy4uL2pzL3Njcm9sbHNweS5qcycpXG5yZXF1aXJlKCcuLi8uLi9qcy90YWIuanMnKVxucmVxdWlyZSgnLi4vLi4vanMvYWZmaXguanMnKSIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBhZmZpeC5qcyB2My4zLjZcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2FmZml4XG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQUZGSVggQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIEFmZml4ID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQWZmaXguREVGQVVMVFMsIG9wdGlvbnMpXG5cbiAgICB0aGlzLiR0YXJnZXQgPSAkKHRoaXMub3B0aW9ucy50YXJnZXQpXG4gICAgICAub24oJ3Njcm9sbC5icy5hZmZpeC5kYXRhLWFwaScsICQucHJveHkodGhpcy5jaGVja1Bvc2l0aW9uLCB0aGlzKSlcbiAgICAgIC5vbignY2xpY2suYnMuYWZmaXguZGF0YS1hcGknLCAgJC5wcm94eSh0aGlzLmNoZWNrUG9zaXRpb25XaXRoRXZlbnRMb29wLCB0aGlzKSlcblxuICAgIHRoaXMuJGVsZW1lbnQgICAgID0gJChlbGVtZW50KVxuICAgIHRoaXMuYWZmaXhlZCAgICAgID0gbnVsbFxuICAgIHRoaXMudW5waW4gICAgICAgID0gbnVsbFxuICAgIHRoaXMucGlubmVkT2Zmc2V0ID0gbnVsbFxuXG4gICAgdGhpcy5jaGVja1Bvc2l0aW9uKClcbiAgfVxuXG4gIEFmZml4LlZFUlNJT04gID0gJzMuMy42J1xuXG4gIEFmZml4LlJFU0VUICAgID0gJ2FmZml4IGFmZml4LXRvcCBhZmZpeC1ib3R0b20nXG5cbiAgQWZmaXguREVGQVVMVFMgPSB7XG4gICAgb2Zmc2V0OiAwLFxuICAgIHRhcmdldDogd2luZG93XG4gIH1cblxuICBBZmZpeC5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoc2Nyb2xsSGVpZ2h0LCBoZWlnaHQsIG9mZnNldFRvcCwgb2Zmc2V0Qm90dG9tKSB7XG4gICAgdmFyIHNjcm9sbFRvcCAgICA9IHRoaXMuJHRhcmdldC5zY3JvbGxUb3AoKVxuICAgIHZhciBwb3NpdGlvbiAgICAgPSB0aGlzLiRlbGVtZW50Lm9mZnNldCgpXG4gICAgdmFyIHRhcmdldEhlaWdodCA9IHRoaXMuJHRhcmdldC5oZWlnaHQoKVxuXG4gICAgaWYgKG9mZnNldFRvcCAhPSBudWxsICYmIHRoaXMuYWZmaXhlZCA9PSAndG9wJykgcmV0dXJuIHNjcm9sbFRvcCA8IG9mZnNldFRvcCA/ICd0b3AnIDogZmFsc2VcblxuICAgIGlmICh0aGlzLmFmZml4ZWQgPT0gJ2JvdHRvbScpIHtcbiAgICAgIGlmIChvZmZzZXRUb3AgIT0gbnVsbCkgcmV0dXJuIChzY3JvbGxUb3AgKyB0aGlzLnVucGluIDw9IHBvc2l0aW9uLnRvcCkgPyBmYWxzZSA6ICdib3R0b20nXG4gICAgICByZXR1cm4gKHNjcm9sbFRvcCArIHRhcmdldEhlaWdodCA8PSBzY3JvbGxIZWlnaHQgLSBvZmZzZXRCb3R0b20pID8gZmFsc2UgOiAnYm90dG9tJ1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsaXppbmcgICA9IHRoaXMuYWZmaXhlZCA9PSBudWxsXG4gICAgdmFyIGNvbGxpZGVyVG9wICAgID0gaW5pdGlhbGl6aW5nID8gc2Nyb2xsVG9wIDogcG9zaXRpb24udG9wXG4gICAgdmFyIGNvbGxpZGVySGVpZ2h0ID0gaW5pdGlhbGl6aW5nID8gdGFyZ2V0SGVpZ2h0IDogaGVpZ2h0XG5cbiAgICBpZiAob2Zmc2V0VG9wICE9IG51bGwgJiYgc2Nyb2xsVG9wIDw9IG9mZnNldFRvcCkgcmV0dXJuICd0b3AnXG4gICAgaWYgKG9mZnNldEJvdHRvbSAhPSBudWxsICYmIChjb2xsaWRlclRvcCArIGNvbGxpZGVySGVpZ2h0ID49IHNjcm9sbEhlaWdodCAtIG9mZnNldEJvdHRvbSkpIHJldHVybiAnYm90dG9tJ1xuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBBZmZpeC5wcm90b3R5cGUuZ2V0UGlubmVkT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnBpbm5lZE9mZnNldCkgcmV0dXJuIHRoaXMucGlubmVkT2Zmc2V0XG4gICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhBZmZpeC5SRVNFVCkuYWRkQ2xhc3MoJ2FmZml4JylcbiAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy4kdGFyZ2V0LnNjcm9sbFRvcCgpXG4gICAgdmFyIHBvc2l0aW9uICA9IHRoaXMuJGVsZW1lbnQub2Zmc2V0KClcbiAgICByZXR1cm4gKHRoaXMucGlubmVkT2Zmc2V0ID0gcG9zaXRpb24udG9wIC0gc2Nyb2xsVG9wKVxuICB9XG5cbiAgQWZmaXgucHJvdG90eXBlLmNoZWNrUG9zaXRpb25XaXRoRXZlbnRMb29wID0gZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQoJC5wcm94eSh0aGlzLmNoZWNrUG9zaXRpb24sIHRoaXMpLCAxKVxuICB9XG5cbiAgQWZmaXgucHJvdG90eXBlLmNoZWNrUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLiRlbGVtZW50LmlzKCc6dmlzaWJsZScpKSByZXR1cm5cblxuICAgIHZhciBoZWlnaHQgICAgICAgPSB0aGlzLiRlbGVtZW50LmhlaWdodCgpXG4gICAgdmFyIG9mZnNldCAgICAgICA9IHRoaXMub3B0aW9ucy5vZmZzZXRcbiAgICB2YXIgb2Zmc2V0VG9wICAgID0gb2Zmc2V0LnRvcFxuICAgIHZhciBvZmZzZXRCb3R0b20gPSBvZmZzZXQuYm90dG9tXG4gICAgdmFyIHNjcm9sbEhlaWdodCA9IE1hdGgubWF4KCQoZG9jdW1lbnQpLmhlaWdodCgpLCAkKGRvY3VtZW50LmJvZHkpLmhlaWdodCgpKVxuXG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgIT0gJ29iamVjdCcpICAgICAgICAgb2Zmc2V0Qm90dG9tID0gb2Zmc2V0VG9wID0gb2Zmc2V0XG4gICAgaWYgKHR5cGVvZiBvZmZzZXRUb3AgPT0gJ2Z1bmN0aW9uJykgICAgb2Zmc2V0VG9wICAgID0gb2Zmc2V0LnRvcCh0aGlzLiRlbGVtZW50KVxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0Qm90dG9tID09ICdmdW5jdGlvbicpIG9mZnNldEJvdHRvbSA9IG9mZnNldC5ib3R0b20odGhpcy4kZWxlbWVudClcblxuICAgIHZhciBhZmZpeCA9IHRoaXMuZ2V0U3RhdGUoc2Nyb2xsSGVpZ2h0LCBoZWlnaHQsIG9mZnNldFRvcCwgb2Zmc2V0Qm90dG9tKVxuXG4gICAgaWYgKHRoaXMuYWZmaXhlZCAhPSBhZmZpeCkge1xuICAgICAgaWYgKHRoaXMudW5waW4gIT0gbnVsbCkgdGhpcy4kZWxlbWVudC5jc3MoJ3RvcCcsICcnKVxuXG4gICAgICB2YXIgYWZmaXhUeXBlID0gJ2FmZml4JyArIChhZmZpeCA/ICctJyArIGFmZml4IDogJycpXG4gICAgICB2YXIgZSAgICAgICAgID0gJC5FdmVudChhZmZpeFR5cGUgKyAnLmJzLmFmZml4JylcblxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cblxuICAgICAgdGhpcy5hZmZpeGVkID0gYWZmaXhcbiAgICAgIHRoaXMudW5waW4gPSBhZmZpeCA9PSAnYm90dG9tJyA/IHRoaXMuZ2V0UGlubmVkT2Zmc2V0KCkgOiBudWxsXG5cbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLnJlbW92ZUNsYXNzKEFmZml4LlJFU0VUKVxuICAgICAgICAuYWRkQ2xhc3MoYWZmaXhUeXBlKVxuICAgICAgICAudHJpZ2dlcihhZmZpeFR5cGUucmVwbGFjZSgnYWZmaXgnLCAnYWZmaXhlZCcpICsgJy5icy5hZmZpeCcpXG4gICAgfVxuXG4gICAgaWYgKGFmZml4ID09ICdib3R0b20nKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZnNldCh7XG4gICAgICAgIHRvcDogc2Nyb2xsSGVpZ2h0IC0gaGVpZ2h0IC0gb2Zmc2V0Qm90dG9tXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gQUZGSVggUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICAgID0gJHRoaXMuZGF0YSgnYnMuYWZmaXgnKVxuICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvblxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmFmZml4JywgKGRhdGEgPSBuZXcgQWZmaXgodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLmFmZml4XG5cbiAgJC5mbi5hZmZpeCAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLmFmZml4LkNvbnN0cnVjdG9yID0gQWZmaXhcblxuXG4gIC8vIEFGRklYIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5hZmZpeC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uYWZmaXggPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBBRkZJWCBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PVxuXG4gICQod2luZG93KS5vbignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAkKCdbZGF0YS1zcHk9XCJhZmZpeFwiXScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRzcHkgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSA9ICRzcHkuZGF0YSgpXG5cbiAgICAgIGRhdGEub2Zmc2V0ID0gZGF0YS5vZmZzZXQgfHwge31cblxuICAgICAgaWYgKGRhdGEub2Zmc2V0Qm90dG9tICE9IG51bGwpIGRhdGEub2Zmc2V0LmJvdHRvbSA9IGRhdGEub2Zmc2V0Qm90dG9tXG4gICAgICBpZiAoZGF0YS5vZmZzZXRUb3AgICAgIT0gbnVsbCkgZGF0YS5vZmZzZXQudG9wICAgID0gZGF0YS5vZmZzZXRUb3BcblxuICAgICAgUGx1Z2luLmNhbGwoJHNweSwgZGF0YSlcbiAgICB9KVxuICB9KVxuXG59KGpRdWVyeSk7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogYWxlcnQuanMgdjMuMy42XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNhbGVydHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBBTEVSVCBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgZGlzbWlzcyA9ICdbZGF0YS1kaXNtaXNzPVwiYWxlcnRcIl0nXG4gIHZhciBBbGVydCAgID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgJChlbCkub24oJ2NsaWNrJywgZGlzbWlzcywgdGhpcy5jbG9zZSlcbiAgfVxuXG4gIEFsZXJ0LlZFUlNJT04gPSAnMy4zLjYnXG5cbiAgQWxlcnQuVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIEFsZXJ0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyICR0aGlzICAgID0gJCh0aGlzKVxuICAgIHZhciBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2RhdGEtdGFyZ2V0JylcblxuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgIHNlbGVjdG9yID0gJHRoaXMuYXR0cignaHJlZicpXG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yICYmIHNlbGVjdG9yLnJlcGxhY2UoLy4qKD89I1teXFxzXSokKS8sICcnKSAvLyBzdHJpcCBmb3IgaWU3XG4gICAgfVxuXG4gICAgdmFyICRwYXJlbnQgPSAkKHNlbGVjdG9yKVxuXG4gICAgaWYgKGUpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgaWYgKCEkcGFyZW50Lmxlbmd0aCkge1xuICAgICAgJHBhcmVudCA9ICR0aGlzLmNsb3Nlc3QoJy5hbGVydCcpXG4gICAgfVxuXG4gICAgJHBhcmVudC50cmlnZ2VyKGUgPSAkLkV2ZW50KCdjbG9zZS5icy5hbGVydCcpKVxuXG4gICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgJHBhcmVudC5yZW1vdmVDbGFzcygnaW4nKVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRWxlbWVudCgpIHtcbiAgICAgIC8vIGRldGFjaCBmcm9tIHBhcmVudCwgZmlyZSBldmVudCB0aGVuIGNsZWFuIHVwIGRhdGFcbiAgICAgICRwYXJlbnQuZGV0YWNoKCkudHJpZ2dlcignY2xvc2VkLmJzLmFsZXJ0JykucmVtb3ZlKClcbiAgICB9XG5cbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiAkcGFyZW50Lmhhc0NsYXNzKCdmYWRlJykgP1xuICAgICAgJHBhcmVudFxuICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCByZW1vdmVFbGVtZW50KVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoQWxlcnQuVFJBTlNJVElPTl9EVVJBVElPTikgOlxuICAgICAgcmVtb3ZlRWxlbWVudCgpXG4gIH1cblxuXG4gIC8vIEFMRVJUIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgID0gJHRoaXMuZGF0YSgnYnMuYWxlcnQnKVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmFsZXJ0JywgKGRhdGEgPSBuZXcgQWxlcnQodGhpcykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXS5jYWxsKCR0aGlzKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5hbGVydFxuXG4gICQuZm4uYWxlcnQgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5hbGVydC5Db25zdHJ1Y3RvciA9IEFsZXJ0XG5cblxuICAvLyBBTEVSVCBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uYWxlcnQubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmFsZXJ0ID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gQUxFUlQgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KS5vbignY2xpY2suYnMuYWxlcnQuZGF0YS1hcGknLCBkaXNtaXNzLCBBbGVydC5wcm90b3R5cGUuY2xvc2UpXG5cbn0oalF1ZXJ5KTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBidXR0b24uanMgdjMuMy42XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNidXR0b25zXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQlVUVE9OIFBVQkxJQyBDTEFTUyBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBCdXR0b24gPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgID0gJChlbGVtZW50KVxuICAgIHRoaXMub3B0aW9ucyAgID0gJC5leHRlbmQoe30sIEJ1dHRvbi5ERUZBVUxUUywgb3B0aW9ucylcbiAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlXG4gIH1cblxuICBCdXR0b24uVkVSU0lPTiAgPSAnMy4zLjYnXG5cbiAgQnV0dG9uLkRFRkFVTFRTID0ge1xuICAgIGxvYWRpbmdUZXh0OiAnbG9hZGluZy4uLidcbiAgfVxuXG4gIEJ1dHRvbi5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICB2YXIgZCAgICA9ICdkaXNhYmxlZCdcbiAgICB2YXIgJGVsICA9IHRoaXMuJGVsZW1lbnRcbiAgICB2YXIgdmFsICA9ICRlbC5pcygnaW5wdXQnKSA/ICd2YWwnIDogJ2h0bWwnXG4gICAgdmFyIGRhdGEgPSAkZWwuZGF0YSgpXG5cbiAgICBzdGF0ZSArPSAnVGV4dCdcblxuICAgIGlmIChkYXRhLnJlc2V0VGV4dCA9PSBudWxsKSAkZWwuZGF0YSgncmVzZXRUZXh0JywgJGVsW3ZhbF0oKSlcblxuICAgIC8vIHB1c2ggdG8gZXZlbnQgbG9vcCB0byBhbGxvdyBmb3JtcyB0byBzdWJtaXRcbiAgICBzZXRUaW1lb3V0KCQucHJveHkoZnVuY3Rpb24gKCkge1xuICAgICAgJGVsW3ZhbF0oZGF0YVtzdGF0ZV0gPT0gbnVsbCA/IHRoaXMub3B0aW9uc1tzdGF0ZV0gOiBkYXRhW3N0YXRlXSlcblxuICAgICAgaWYgKHN0YXRlID09ICdsb2FkaW5nVGV4dCcpIHtcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlXG4gICAgICAgICRlbC5hZGRDbGFzcyhkKS5hdHRyKGQsIGQpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNMb2FkaW5nKSB7XG4gICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2VcbiAgICAgICAgJGVsLnJlbW92ZUNsYXNzKGQpLnJlbW92ZUF0dHIoZClcbiAgICAgIH1cbiAgICB9LCB0aGlzKSwgMClcbiAgfVxuXG4gIEJ1dHRvbi5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjaGFuZ2VkID0gdHJ1ZVxuICAgIHZhciAkcGFyZW50ID0gdGhpcy4kZWxlbWVudC5jbG9zZXN0KCdbZGF0YS10b2dnbGU9XCJidXR0b25zXCJdJylcblxuICAgIGlmICgkcGFyZW50Lmxlbmd0aCkge1xuICAgICAgdmFyICRpbnB1dCA9IHRoaXMuJGVsZW1lbnQuZmluZCgnaW5wdXQnKVxuICAgICAgaWYgKCRpbnB1dC5wcm9wKCd0eXBlJykgPT0gJ3JhZGlvJykge1xuICAgICAgICBpZiAoJGlucHV0LnByb3AoJ2NoZWNrZWQnKSkgY2hhbmdlZCA9IGZhbHNlXG4gICAgICAgICRwYXJlbnQuZmluZCgnLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKCdhY3RpdmUnKVxuICAgICAgfSBlbHNlIGlmICgkaW5wdXQucHJvcCgndHlwZScpID09ICdjaGVja2JveCcpIHtcbiAgICAgICAgaWYgKCgkaW5wdXQucHJvcCgnY2hlY2tlZCcpKSAhPT0gdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnYWN0aXZlJykpIGNoYW5nZWQgPSBmYWxzZVxuICAgICAgICB0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgfVxuICAgICAgJGlucHV0LnByb3AoJ2NoZWNrZWQnLCB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdhY3RpdmUnKSlcbiAgICAgIGlmIChjaGFuZ2VkKSAkaW5wdXQudHJpZ2dlcignY2hhbmdlJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLXByZXNzZWQnLCAhdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnYWN0aXZlJykpXG4gICAgICB0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKCdhY3RpdmUnKVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gQlVUVE9OIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5idXR0b24nKVxuICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvblxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmJ1dHRvbicsIChkYXRhID0gbmV3IEJ1dHRvbih0aGlzLCBvcHRpb25zKSkpXG5cbiAgICAgIGlmIChvcHRpb24gPT0gJ3RvZ2dsZScpIGRhdGEudG9nZ2xlKClcbiAgICAgIGVsc2UgaWYgKG9wdGlvbikgZGF0YS5zZXRTdGF0ZShvcHRpb24pXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLmJ1dHRvblxuXG4gICQuZm4uYnV0dG9uICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uYnV0dG9uLkNvbnN0cnVjdG9yID0gQnV0dG9uXG5cblxuICAvLyBCVVRUT04gTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5idXR0b24ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLmJ1dHRvbiA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIEJVVFRPTiBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KVxuICAgIC5vbignY2xpY2suYnMuYnV0dG9uLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZV49XCJidXR0b25cIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyICRidG4gPSAkKGUudGFyZ2V0KVxuICAgICAgaWYgKCEkYnRuLmhhc0NsYXNzKCdidG4nKSkgJGJ0biA9ICRidG4uY2xvc2VzdCgnLmJ0bicpXG4gICAgICBQbHVnaW4uY2FsbCgkYnRuLCAndG9nZ2xlJylcbiAgICAgIGlmICghKCQoZS50YXJnZXQpLmlzKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKSB8fCAkKGUudGFyZ2V0KS5pcygnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJykpKSBlLnByZXZlbnREZWZhdWx0KClcbiAgICB9KVxuICAgIC5vbignZm9jdXMuYnMuYnV0dG9uLmRhdGEtYXBpIGJsdXIuYnMuYnV0dG9uLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZV49XCJidXR0b25cIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgJChlLnRhcmdldCkuY2xvc2VzdCgnLmJ0bicpLnRvZ2dsZUNsYXNzKCdmb2N1cycsIC9eZm9jdXMoaW4pPyQvLnRlc3QoZS50eXBlKSlcbiAgICB9KVxuXG59KGpRdWVyeSk7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogY2Fyb3VzZWwuanMgdjMuMy42XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNjYXJvdXNlbFxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENBUk9VU0VMIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBDYXJvdXNlbCA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy4kZWxlbWVudCAgICA9ICQoZWxlbWVudClcbiAgICB0aGlzLiRpbmRpY2F0b3JzID0gdGhpcy4kZWxlbWVudC5maW5kKCcuY2Fyb3VzZWwtaW5kaWNhdG9ycycpXG4gICAgdGhpcy5vcHRpb25zICAgICA9IG9wdGlvbnNcbiAgICB0aGlzLnBhdXNlZCAgICAgID0gbnVsbFxuICAgIHRoaXMuc2xpZGluZyAgICAgPSBudWxsXG4gICAgdGhpcy5pbnRlcnZhbCAgICA9IG51bGxcbiAgICB0aGlzLiRhY3RpdmUgICAgID0gbnVsbFxuICAgIHRoaXMuJGl0ZW1zICAgICAgPSBudWxsXG5cbiAgICB0aGlzLm9wdGlvbnMua2V5Ym9hcmQgJiYgdGhpcy4kZWxlbWVudC5vbigna2V5ZG93bi5icy5jYXJvdXNlbCcsICQucHJveHkodGhpcy5rZXlkb3duLCB0aGlzKSlcblxuICAgIHRoaXMub3B0aW9ucy5wYXVzZSA9PSAnaG92ZXInICYmICEoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSAmJiB0aGlzLiRlbGVtZW50XG4gICAgICAub24oJ21vdXNlZW50ZXIuYnMuY2Fyb3VzZWwnLCAkLnByb3h5KHRoaXMucGF1c2UsIHRoaXMpKVxuICAgICAgLm9uKCdtb3VzZWxlYXZlLmJzLmNhcm91c2VsJywgJC5wcm94eSh0aGlzLmN5Y2xlLCB0aGlzKSlcbiAgfVxuXG4gIENhcm91c2VsLlZFUlNJT04gID0gJzMuMy42J1xuXG4gIENhcm91c2VsLlRSQU5TSVRJT05fRFVSQVRJT04gPSA2MDBcblxuICBDYXJvdXNlbC5ERUZBVUxUUyA9IHtcbiAgICBpbnRlcnZhbDogNTAwMCxcbiAgICBwYXVzZTogJ2hvdmVyJyxcbiAgICB3cmFwOiB0cnVlLFxuICAgIGtleWJvYXJkOiB0cnVlXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUua2V5ZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZS50YXJnZXQudGFnTmFtZSkpIHJldHVyblxuICAgIHN3aXRjaCAoZS53aGljaCkge1xuICAgICAgY2FzZSAzNzogdGhpcy5wcmV2KCk7IGJyZWFrXG4gICAgICBjYXNlIDM5OiB0aGlzLm5leHQoKTsgYnJlYWtcbiAgICAgIGRlZmF1bHQ6IHJldHVyblxuICAgIH1cblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmN5Y2xlID0gZnVuY3Rpb24gKGUpIHtcbiAgICBlIHx8ICh0aGlzLnBhdXNlZCA9IGZhbHNlKVxuXG4gICAgdGhpcy5pbnRlcnZhbCAmJiBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpXG5cbiAgICB0aGlzLm9wdGlvbnMuaW50ZXJ2YWxcbiAgICAgICYmICF0aGlzLnBhdXNlZFxuICAgICAgJiYgKHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgkLnByb3h5KHRoaXMubmV4dCwgdGhpcyksIHRoaXMub3B0aW9ucy5pbnRlcnZhbCkpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmdldEl0ZW1JbmRleCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdGhpcy4kaXRlbXMgPSBpdGVtLnBhcmVudCgpLmNoaWxkcmVuKCcuaXRlbScpXG4gICAgcmV0dXJuIHRoaXMuJGl0ZW1zLmluZGV4KGl0ZW0gfHwgdGhpcy4kYWN0aXZlKVxuICB9XG5cbiAgQ2Fyb3VzZWwucHJvdG90eXBlLmdldEl0ZW1Gb3JEaXJlY3Rpb24gPSBmdW5jdGlvbiAoZGlyZWN0aW9uLCBhY3RpdmUpIHtcbiAgICB2YXIgYWN0aXZlSW5kZXggPSB0aGlzLmdldEl0ZW1JbmRleChhY3RpdmUpXG4gICAgdmFyIHdpbGxXcmFwID0gKGRpcmVjdGlvbiA9PSAncHJldicgJiYgYWN0aXZlSW5kZXggPT09IDApXG4gICAgICAgICAgICAgICAgfHwgKGRpcmVjdGlvbiA9PSAnbmV4dCcgJiYgYWN0aXZlSW5kZXggPT0gKHRoaXMuJGl0ZW1zLmxlbmd0aCAtIDEpKVxuICAgIGlmICh3aWxsV3JhcCAmJiAhdGhpcy5vcHRpb25zLndyYXApIHJldHVybiBhY3RpdmVcbiAgICB2YXIgZGVsdGEgPSBkaXJlY3Rpb24gPT0gJ3ByZXYnID8gLTEgOiAxXG4gICAgdmFyIGl0ZW1JbmRleCA9IChhY3RpdmVJbmRleCArIGRlbHRhKSAlIHRoaXMuJGl0ZW1zLmxlbmd0aFxuICAgIHJldHVybiB0aGlzLiRpdGVtcy5lcShpdGVtSW5kZXgpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgdmFyIHRoYXQgICAgICAgID0gdGhpc1xuICAgIHZhciBhY3RpdmVJbmRleCA9IHRoaXMuZ2V0SXRlbUluZGV4KHRoaXMuJGFjdGl2ZSA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLml0ZW0uYWN0aXZlJykpXG5cbiAgICBpZiAocG9zID4gKHRoaXMuJGl0ZW1zLmxlbmd0aCAtIDEpIHx8IHBvcyA8IDApIHJldHVyblxuXG4gICAgaWYgKHRoaXMuc2xpZGluZykgICAgICAgcmV0dXJuIHRoaXMuJGVsZW1lbnQub25lKCdzbGlkLmJzLmNhcm91c2VsJywgZnVuY3Rpb24gKCkgeyB0aGF0LnRvKHBvcykgfSkgLy8geWVzLCBcInNsaWRcIlxuICAgIGlmIChhY3RpdmVJbmRleCA9PSBwb3MpIHJldHVybiB0aGlzLnBhdXNlKCkuY3ljbGUoKVxuXG4gICAgcmV0dXJuIHRoaXMuc2xpZGUocG9zID4gYWN0aXZlSW5kZXggPyAnbmV4dCcgOiAncHJldicsIHRoaXMuJGl0ZW1zLmVxKHBvcykpXG4gIH1cblxuICBDYXJvdXNlbC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUgfHwgKHRoaXMucGF1c2VkID0gdHJ1ZSlcblxuICAgIGlmICh0aGlzLiRlbGVtZW50LmZpbmQoJy5uZXh0LCAucHJldicpLmxlbmd0aCAmJiAkLnN1cHBvcnQudHJhbnNpdGlvbikge1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZClcbiAgICAgIHRoaXMuY3ljbGUodHJ1ZSlcbiAgICB9XG5cbiAgICB0aGlzLmludGVydmFsID0gY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnNsaWRpbmcpIHJldHVyblxuICAgIHJldHVybiB0aGlzLnNsaWRlKCduZXh0JylcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnNsaWRpbmcpIHJldHVyblxuICAgIHJldHVybiB0aGlzLnNsaWRlKCdwcmV2JylcbiAgfVxuXG4gIENhcm91c2VsLnByb3RvdHlwZS5zbGlkZSA9IGZ1bmN0aW9uICh0eXBlLCBuZXh0KSB7XG4gICAgdmFyICRhY3RpdmUgICA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLml0ZW0uYWN0aXZlJylcbiAgICB2YXIgJG5leHQgICAgID0gbmV4dCB8fCB0aGlzLmdldEl0ZW1Gb3JEaXJlY3Rpb24odHlwZSwgJGFjdGl2ZSlcbiAgICB2YXIgaXNDeWNsaW5nID0gdGhpcy5pbnRlcnZhbFxuICAgIHZhciBkaXJlY3Rpb24gPSB0eXBlID09ICduZXh0JyA/ICdsZWZ0JyA6ICdyaWdodCdcbiAgICB2YXIgdGhhdCAgICAgID0gdGhpc1xuXG4gICAgaWYgKCRuZXh0Lmhhc0NsYXNzKCdhY3RpdmUnKSkgcmV0dXJuICh0aGlzLnNsaWRpbmcgPSBmYWxzZSlcblxuICAgIHZhciByZWxhdGVkVGFyZ2V0ID0gJG5leHRbMF1cbiAgICB2YXIgc2xpZGVFdmVudCA9ICQuRXZlbnQoJ3NsaWRlLmJzLmNhcm91c2VsJywge1xuICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZFRhcmdldCxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uXG4gICAgfSlcbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoc2xpZGVFdmVudClcbiAgICBpZiAoc2xpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB0aGlzLnNsaWRpbmcgPSB0cnVlXG5cbiAgICBpc0N5Y2xpbmcgJiYgdGhpcy5wYXVzZSgpXG5cbiAgICBpZiAodGhpcy4kaW5kaWNhdG9ycy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuJGluZGljYXRvcnMuZmluZCgnLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgdmFyICRuZXh0SW5kaWNhdG9yID0gJCh0aGlzLiRpbmRpY2F0b3JzLmNoaWxkcmVuKClbdGhpcy5nZXRJdGVtSW5kZXgoJG5leHQpXSlcbiAgICAgICRuZXh0SW5kaWNhdG9yICYmICRuZXh0SW5kaWNhdG9yLmFkZENsYXNzKCdhY3RpdmUnKVxuICAgIH1cblxuICAgIHZhciBzbGlkRXZlbnQgPSAkLkV2ZW50KCdzbGlkLmJzLmNhcm91c2VsJywgeyByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0LCBkaXJlY3Rpb246IGRpcmVjdGlvbiB9KSAvLyB5ZXMsIFwic2xpZFwiXG4gICAgaWYgKCQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ3NsaWRlJykpIHtcbiAgICAgICRuZXh0LmFkZENsYXNzKHR5cGUpXG4gICAgICAkbmV4dFswXS5vZmZzZXRXaWR0aCAvLyBmb3JjZSByZWZsb3dcbiAgICAgICRhY3RpdmUuYWRkQ2xhc3MoZGlyZWN0aW9uKVxuICAgICAgJG5leHQuYWRkQ2xhc3MoZGlyZWN0aW9uKVxuICAgICAgJGFjdGl2ZVxuICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgJG5leHQucmVtb3ZlQ2xhc3MoW3R5cGUsIGRpcmVjdGlvbl0uam9pbignICcpKS5hZGRDbGFzcygnYWN0aXZlJylcbiAgICAgICAgICAkYWN0aXZlLnJlbW92ZUNsYXNzKFsnYWN0aXZlJywgZGlyZWN0aW9uXS5qb2luKCcgJykpXG4gICAgICAgICAgdGhhdC5zbGlkaW5nID0gZmFsc2VcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcihzbGlkRXZlbnQpXG4gICAgICAgICAgfSwgMClcbiAgICAgICAgfSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKENhcm91c2VsLlRSQU5TSVRJT05fRFVSQVRJT04pXG4gICAgfSBlbHNlIHtcbiAgICAgICRhY3RpdmUucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICAkbmV4dC5hZGRDbGFzcygnYWN0aXZlJylcbiAgICAgIHRoaXMuc2xpZGluZyA9IGZhbHNlXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoc2xpZEV2ZW50KVxuICAgIH1cblxuICAgIGlzQ3ljbGluZyAmJiB0aGlzLmN5Y2xlKClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIENBUk9VU0VMIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLmNhcm91c2VsJylcbiAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIENhcm91c2VsLkRFRkFVTFRTLCAkdGhpcy5kYXRhKCksIHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uKVxuICAgICAgdmFyIGFjdGlvbiAgPSB0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnID8gb3B0aW9uIDogb3B0aW9ucy5zbGlkZVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmNhcm91c2VsJywgKGRhdGEgPSBuZXcgQ2Fyb3VzZWwodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ251bWJlcicpIGRhdGEudG8ob3B0aW9uKVxuICAgICAgZWxzZSBpZiAoYWN0aW9uKSBkYXRhW2FjdGlvbl0oKVxuICAgICAgZWxzZSBpZiAob3B0aW9ucy5pbnRlcnZhbCkgZGF0YS5wYXVzZSgpLmN5Y2xlKClcbiAgICB9KVxuICB9XG5cbiAgdmFyIG9sZCA9ICQuZm4uY2Fyb3VzZWxcblxuICAkLmZuLmNhcm91c2VsICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4uY2Fyb3VzZWwuQ29uc3RydWN0b3IgPSBDYXJvdXNlbFxuXG5cbiAgLy8gQ0FST1VTRUwgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PT1cblxuICAkLmZuLmNhcm91c2VsLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5jYXJvdXNlbCA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuXG4gIC8vIENBUk9VU0VMIERBVEEtQVBJXG4gIC8vID09PT09PT09PT09PT09PT09XG5cbiAgdmFyIGNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGhyZWZcbiAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcbiAgICB2YXIgJHRhcmdldCA9ICQoJHRoaXMuYXR0cignZGF0YS10YXJnZXQnKSB8fCAoaHJlZiA9ICR0aGlzLmF0dHIoJ2hyZWYnKSkgJiYgaHJlZi5yZXBsYWNlKC8uKig/PSNbXlxcc10rJCkvLCAnJykpIC8vIHN0cmlwIGZvciBpZTdcbiAgICBpZiAoISR0YXJnZXQuaGFzQ2xhc3MoJ2Nhcm91c2VsJykpIHJldHVyblxuICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sICR0YXJnZXQuZGF0YSgpLCAkdGhpcy5kYXRhKCkpXG4gICAgdmFyIHNsaWRlSW5kZXggPSAkdGhpcy5hdHRyKCdkYXRhLXNsaWRlLXRvJylcbiAgICBpZiAoc2xpZGVJbmRleCkgb3B0aW9ucy5pbnRlcnZhbCA9IGZhbHNlXG5cbiAgICBQbHVnaW4uY2FsbCgkdGFyZ2V0LCBvcHRpb25zKVxuXG4gICAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICAgICR0YXJnZXQuZGF0YSgnYnMuY2Fyb3VzZWwnKS50byhzbGlkZUluZGV4KVxuICAgIH1cblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICB9XG5cbiAgJChkb2N1bWVudClcbiAgICAub24oJ2NsaWNrLmJzLmNhcm91c2VsLmRhdGEtYXBpJywgJ1tkYXRhLXNsaWRlXScsIGNsaWNrSGFuZGxlcilcbiAgICAub24oJ2NsaWNrLmJzLmNhcm91c2VsLmRhdGEtYXBpJywgJ1tkYXRhLXNsaWRlLXRvXScsIGNsaWNrSGFuZGxlcilcblxuICAkKHdpbmRvdykub24oJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgJCgnW2RhdGEtcmlkZT1cImNhcm91c2VsXCJdJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJGNhcm91c2VsID0gJCh0aGlzKVxuICAgICAgUGx1Z2luLmNhbGwoJGNhcm91c2VsLCAkY2Fyb3VzZWwuZGF0YSgpKVxuICAgIH0pXG4gIH0pXG5cbn0oalF1ZXJ5KTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBjb2xsYXBzZS5qcyB2My4zLjZcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2NvbGxhcHNlXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ09MTEFQU0UgUFVCTElDIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgQ29sbGFwc2UgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGVsZW1lbnQgICAgICA9ICQoZWxlbWVudClcbiAgICB0aGlzLm9wdGlvbnMgICAgICAgPSAkLmV4dGVuZCh7fSwgQ29sbGFwc2UuREVGQVVMVFMsIG9wdGlvbnMpXG4gICAgdGhpcy4kdHJpZ2dlciAgICAgID0gJCgnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1baHJlZj1cIiMnICsgZWxlbWVudC5pZCArICdcIl0sJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1bZGF0YS10YXJnZXQ9XCIjJyArIGVsZW1lbnQuaWQgKyAnXCJdJylcbiAgICB0aGlzLnRyYW5zaXRpb25pbmcgPSBudWxsXG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnBhcmVudCkge1xuICAgICAgdGhpcy4kcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLiRlbGVtZW50LCB0aGlzLiR0cmlnZ2VyKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMudG9nZ2xlKSB0aGlzLnRvZ2dsZSgpXG4gIH1cblxuICBDb2xsYXBzZS5WRVJTSU9OICA9ICczLjMuNidcblxuICBDb2xsYXBzZS5UUkFOU0lUSU9OX0RVUkFUSU9OID0gMzUwXG5cbiAgQ29sbGFwc2UuREVGQVVMVFMgPSB7XG4gICAgdG9nZ2xlOiB0cnVlXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUuZGltZW5zaW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYXNXaWR0aCA9IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ3dpZHRoJylcbiAgICByZXR1cm4gaGFzV2lkdGggPyAnd2lkdGgnIDogJ2hlaWdodCdcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRyYW5zaXRpb25pbmcgfHwgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaW4nKSkgcmV0dXJuXG5cbiAgICB2YXIgYWN0aXZlc0RhdGFcbiAgICB2YXIgYWN0aXZlcyA9IHRoaXMuJHBhcmVudCAmJiB0aGlzLiRwYXJlbnQuY2hpbGRyZW4oJy5wYW5lbCcpLmNoaWxkcmVuKCcuaW4sIC5jb2xsYXBzaW5nJylcblxuICAgIGlmIChhY3RpdmVzICYmIGFjdGl2ZXMubGVuZ3RoKSB7XG4gICAgICBhY3RpdmVzRGF0YSA9IGFjdGl2ZXMuZGF0YSgnYnMuY29sbGFwc2UnKVxuICAgICAgaWYgKGFjdGl2ZXNEYXRhICYmIGFjdGl2ZXNEYXRhLnRyYW5zaXRpb25pbmcpIHJldHVyblxuICAgIH1cblxuICAgIHZhciBzdGFydEV2ZW50ID0gJC5FdmVudCgnc2hvdy5icy5jb2xsYXBzZScpXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKHN0YXJ0RXZlbnQpXG4gICAgaWYgKHN0YXJ0RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgaWYgKGFjdGl2ZXMgJiYgYWN0aXZlcy5sZW5ndGgpIHtcbiAgICAgIFBsdWdpbi5jYWxsKGFjdGl2ZXMsICdoaWRlJylcbiAgICAgIGFjdGl2ZXNEYXRhIHx8IGFjdGl2ZXMuZGF0YSgnYnMuY29sbGFwc2UnLCBudWxsKVxuICAgIH1cblxuICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmRpbWVuc2lvbigpXG5cbiAgICB0aGlzLiRlbGVtZW50XG4gICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNlJylcbiAgICAgIC5hZGRDbGFzcygnY29sbGFwc2luZycpW2RpbWVuc2lvbl0oMClcbiAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcblxuICAgIHRoaXMuJHRyaWdnZXJcbiAgICAgIC5yZW1vdmVDbGFzcygnY29sbGFwc2VkJylcbiAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcblxuICAgIHRoaXMudHJhbnNpdGlvbmluZyA9IDFcblxuICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdjb2xsYXBzaW5nJylcbiAgICAgICAgLmFkZENsYXNzKCdjb2xsYXBzZSBpbicpW2RpbWVuc2lvbl0oJycpXG4gICAgICB0aGlzLnRyYW5zaXRpb25pbmcgPSAwXG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC50cmlnZ2VyKCdzaG93bi5icy5jb2xsYXBzZScpXG4gICAgfVxuXG4gICAgaWYgKCEkLnN1cHBvcnQudHJhbnNpdGlvbikgcmV0dXJuIGNvbXBsZXRlLmNhbGwodGhpcylcblxuICAgIHZhciBzY3JvbGxTaXplID0gJC5jYW1lbENhc2UoWydzY3JvbGwnLCBkaW1lbnNpb25dLmpvaW4oJy0nKSlcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsICQucHJveHkoY29tcGxldGUsIHRoaXMpKVxuICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKENvbGxhcHNlLlRSQU5TSVRJT05fRFVSQVRJT04pW2RpbWVuc2lvbl0odGhpcy4kZWxlbWVudFswXVtzY3JvbGxTaXplXSlcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnRyYW5zaXRpb25pbmcgfHwgIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2luJykpIHJldHVyblxuXG4gICAgdmFyIHN0YXJ0RXZlbnQgPSAkLkV2ZW50KCdoaWRlLmJzLmNvbGxhcHNlJylcbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoc3RhcnRFdmVudClcbiAgICBpZiAoc3RhcnRFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5kaW1lbnNpb24oKVxuXG4gICAgdGhpcy4kZWxlbWVudFtkaW1lbnNpb25dKHRoaXMuJGVsZW1lbnRbZGltZW5zaW9uXSgpKVswXS5vZmZzZXRIZWlnaHRcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIC5hZGRDbGFzcygnY29sbGFwc2luZycpXG4gICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNlIGluJylcbiAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpXG5cbiAgICB0aGlzLiR0cmlnZ2VyXG4gICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNlZCcpXG4gICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKVxuXG4gICAgdGhpcy50cmFuc2l0aW9uaW5nID0gMVxuXG4gICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uaW5nID0gMFxuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ2NvbGxhcHNpbmcnKVxuICAgICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNlJylcbiAgICAgICAgLnRyaWdnZXIoJ2hpZGRlbi5icy5jb2xsYXBzZScpXG4gICAgfVxuXG4gICAgaWYgKCEkLnN1cHBvcnQudHJhbnNpdGlvbikgcmV0dXJuIGNvbXBsZXRlLmNhbGwodGhpcylcblxuICAgIHRoaXMuJGVsZW1lbnRcbiAgICAgIFtkaW1lbnNpb25dKDApXG4gICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCAkLnByb3h5KGNvbXBsZXRlLCB0aGlzKSlcbiAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChDb2xsYXBzZS5UUkFOU0lUSU9OX0RVUkFUSU9OKVxuICB9XG5cbiAgQ29sbGFwc2UucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzW3RoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2luJykgPyAnaGlkZScgOiAnc2hvdyddKClcbiAgfVxuXG4gIENvbGxhcHNlLnByb3RvdHlwZS5nZXRQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICQodGhpcy5vcHRpb25zLnBhcmVudClcbiAgICAgIC5maW5kKCdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtkYXRhLXBhcmVudD1cIicgKyB0aGlzLm9wdGlvbnMucGFyZW50ICsgJ1wiXScpXG4gICAgICAuZWFjaCgkLnByb3h5KGZ1bmN0aW9uIChpLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciAkZWxlbWVudCA9ICQoZWxlbWVudClcbiAgICAgICAgdGhpcy5hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoZ2V0VGFyZ2V0RnJvbVRyaWdnZXIoJGVsZW1lbnQpLCAkZWxlbWVudClcbiAgICAgIH0sIHRoaXMpKVxuICAgICAgLmVuZCgpXG4gIH1cblxuICBDb2xsYXBzZS5wcm90b3R5cGUuYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzID0gZnVuY3Rpb24gKCRlbGVtZW50LCAkdHJpZ2dlcikge1xuICAgIHZhciBpc09wZW4gPSAkZWxlbWVudC5oYXNDbGFzcygnaW4nKVxuXG4gICAgJGVsZW1lbnQuYXR0cignYXJpYS1leHBhbmRlZCcsIGlzT3BlbilcbiAgICAkdHJpZ2dlclxuICAgICAgLnRvZ2dsZUNsYXNzKCdjb2xsYXBzZWQnLCAhaXNPcGVuKVxuICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBpc09wZW4pXG4gIH1cblxuICBmdW5jdGlvbiBnZXRUYXJnZXRGcm9tVHJpZ2dlcigkdHJpZ2dlcikge1xuICAgIHZhciBocmVmXG4gICAgdmFyIHRhcmdldCA9ICR0cmlnZ2VyLmF0dHIoJ2RhdGEtdGFyZ2V0JylcbiAgICAgIHx8IChocmVmID0gJHRyaWdnZXIuYXR0cignaHJlZicpKSAmJiBocmVmLnJlcGxhY2UoLy4qKD89I1teXFxzXSskKS8sICcnKSAvLyBzdHJpcCBmb3IgaWU3XG5cbiAgICByZXR1cm4gJCh0YXJnZXQpXG4gIH1cblxuXG4gIC8vIENPTExBUFNFIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLmNvbGxhcHNlJylcbiAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIENvbGxhcHNlLkRFRkFVTFRTLCAkdGhpcy5kYXRhKCksIHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uKVxuXG4gICAgICBpZiAoIWRhdGEgJiYgb3B0aW9ucy50b2dnbGUgJiYgL3Nob3d8aGlkZS8udGVzdChvcHRpb24pKSBvcHRpb25zLnRvZ2dsZSA9IGZhbHNlXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLmNvbGxhcHNlJywgKGRhdGEgPSBuZXcgQ29sbGFwc2UodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLmNvbGxhcHNlXG5cbiAgJC5mbi5jb2xsYXBzZSAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLmNvbGxhcHNlLkNvbnN0cnVjdG9yID0gQ29sbGFwc2VcblxuXG4gIC8vIENPTExBUFNFIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5jb2xsYXBzZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uY29sbGFwc2UgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBDT0xMQVBTRSBEQVRBLUFQSVxuICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gICQoZG9jdW1lbnQpLm9uKCdjbGljay5icy5jb2xsYXBzZS5kYXRhLWFwaScsICdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXScsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG5cbiAgICBpZiAoISR0aGlzLmF0dHIoJ2RhdGEtdGFyZ2V0JykpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgdmFyICR0YXJnZXQgPSBnZXRUYXJnZXRGcm9tVHJpZ2dlcigkdGhpcylcbiAgICB2YXIgZGF0YSAgICA9ICR0YXJnZXQuZGF0YSgnYnMuY29sbGFwc2UnKVxuICAgIHZhciBvcHRpb24gID0gZGF0YSA/ICd0b2dnbGUnIDogJHRoaXMuZGF0YSgpXG5cbiAgICBQbHVnaW4uY2FsbCgkdGFyZ2V0LCBvcHRpb24pXG4gIH0pXG5cbn0oalF1ZXJ5KTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBkcm9wZG93bi5qcyB2My4zLjZcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI2Ryb3Bkb3duc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIERST1BET1dOIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBiYWNrZHJvcCA9ICcuZHJvcGRvd24tYmFja2Ryb3AnXG4gIHZhciB0b2dnbGUgICA9ICdbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXSdcbiAgdmFyIERyb3Bkb3duID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAkKGVsZW1lbnQpLm9uKCdjbGljay5icy5kcm9wZG93bicsIHRoaXMudG9nZ2xlKVxuICB9XG5cbiAgRHJvcGRvd24uVkVSU0lPTiA9ICczLjMuNidcblxuICBmdW5jdGlvbiBnZXRQYXJlbnQoJHRoaXMpIHtcbiAgICB2YXIgc2VsZWN0b3IgPSAkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpXG5cbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICBzZWxlY3RvciA9ICR0aGlzLmF0dHIoJ2hyZWYnKVxuICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvciAmJiAvI1tBLVphLXpdLy50ZXN0KHNlbGVjdG9yKSAmJiBzZWxlY3Rvci5yZXBsYWNlKC8uKig/PSNbXlxcc10qJCkvLCAnJykgLy8gc3RyaXAgZm9yIGllN1xuICAgIH1cblxuICAgIHZhciAkcGFyZW50ID0gc2VsZWN0b3IgJiYgJChzZWxlY3RvcilcblxuICAgIHJldHVybiAkcGFyZW50ICYmICRwYXJlbnQubGVuZ3RoID8gJHBhcmVudCA6ICR0aGlzLnBhcmVudCgpXG4gIH1cblxuICBmdW5jdGlvbiBjbGVhck1lbnVzKGUpIHtcbiAgICBpZiAoZSAmJiBlLndoaWNoID09PSAzKSByZXR1cm5cbiAgICAkKGJhY2tkcm9wKS5yZW1vdmUoKVxuICAgICQodG9nZ2xlKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgICAgICAgID0gJCh0aGlzKVxuICAgICAgdmFyICRwYXJlbnQgICAgICAgPSBnZXRQYXJlbnQoJHRoaXMpXG4gICAgICB2YXIgcmVsYXRlZFRhcmdldCA9IHsgcmVsYXRlZFRhcmdldDogdGhpcyB9XG5cbiAgICAgIGlmICghJHBhcmVudC5oYXNDbGFzcygnb3BlbicpKSByZXR1cm5cblxuICAgICAgaWYgKGUgJiYgZS50eXBlID09ICdjbGljaycgJiYgL2lucHV0fHRleHRhcmVhL2kudGVzdChlLnRhcmdldC50YWdOYW1lKSAmJiAkLmNvbnRhaW5zKCRwYXJlbnRbMF0sIGUudGFyZ2V0KSkgcmV0dXJuXG5cbiAgICAgICRwYXJlbnQudHJpZ2dlcihlID0gJC5FdmVudCgnaGlkZS5icy5kcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpKVxuXG4gICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAgICR0aGlzLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKVxuICAgICAgJHBhcmVudC5yZW1vdmVDbGFzcygnb3BlbicpLnRyaWdnZXIoJC5FdmVudCgnaGlkZGVuLmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldCkpXG4gICAgfSlcbiAgfVxuXG4gIERyb3Bkb3duLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciAkdGhpcyA9ICQodGhpcylcblxuICAgIGlmICgkdGhpcy5pcygnLmRpc2FibGVkLCA6ZGlzYWJsZWQnKSkgcmV0dXJuXG5cbiAgICB2YXIgJHBhcmVudCAgPSBnZXRQYXJlbnQoJHRoaXMpXG4gICAgdmFyIGlzQWN0aXZlID0gJHBhcmVudC5oYXNDbGFzcygnb3BlbicpXG5cbiAgICBjbGVhck1lbnVzKClcblxuICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgISRwYXJlbnQuY2xvc2VzdCgnLm5hdmJhci1uYXYnKS5sZW5ndGgpIHtcbiAgICAgICAgLy8gaWYgbW9iaWxlIHdlIHVzZSBhIGJhY2tkcm9wIGJlY2F1c2UgY2xpY2sgZXZlbnRzIGRvbid0IGRlbGVnYXRlXG4gICAgICAgICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpXG4gICAgICAgICAgLmFkZENsYXNzKCdkcm9wZG93bi1iYWNrZHJvcCcpXG4gICAgICAgICAgLmluc2VydEFmdGVyKCQodGhpcykpXG4gICAgICAgICAgLm9uKCdjbGljaycsIGNsZWFyTWVudXMpXG4gICAgICB9XG5cbiAgICAgIHZhciByZWxhdGVkVGFyZ2V0ID0geyByZWxhdGVkVGFyZ2V0OiB0aGlzIH1cbiAgICAgICRwYXJlbnQudHJpZ2dlcihlID0gJC5FdmVudCgnc2hvdy5icy5kcm9wZG93bicsIHJlbGF0ZWRUYXJnZXQpKVxuXG4gICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICAgICR0aGlzXG4gICAgICAgIC50cmlnZ2VyKCdmb2N1cycpXG4gICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKVxuXG4gICAgICAkcGFyZW50XG4gICAgICAgIC50b2dnbGVDbGFzcygnb3BlbicpXG4gICAgICAgIC50cmlnZ2VyKCQuRXZlbnQoJ3Nob3duLmJzLmRyb3Bkb3duJywgcmVsYXRlZFRhcmdldCkpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBEcm9wZG93bi5wcm90b3R5cGUua2V5ZG93biA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKCEvKDM4fDQwfDI3fDMyKS8udGVzdChlLndoaWNoKSB8fCAvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGUudGFyZ2V0LnRhZ05hbWUpKSByZXR1cm5cblxuICAgIHZhciAkdGhpcyA9ICQodGhpcylcblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIGlmICgkdGhpcy5pcygnLmRpc2FibGVkLCA6ZGlzYWJsZWQnKSkgcmV0dXJuXG5cbiAgICB2YXIgJHBhcmVudCAgPSBnZXRQYXJlbnQoJHRoaXMpXG4gICAgdmFyIGlzQWN0aXZlID0gJHBhcmVudC5oYXNDbGFzcygnb3BlbicpXG5cbiAgICBpZiAoIWlzQWN0aXZlICYmIGUud2hpY2ggIT0gMjcgfHwgaXNBY3RpdmUgJiYgZS53aGljaCA9PSAyNykge1xuICAgICAgaWYgKGUud2hpY2ggPT0gMjcpICRwYXJlbnQuZmluZCh0b2dnbGUpLnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgIHJldHVybiAkdGhpcy50cmlnZ2VyKCdjbGljaycpXG4gICAgfVxuXG4gICAgdmFyIGRlc2MgPSAnIGxpOm5vdCguZGlzYWJsZWQpOnZpc2libGUgYSdcbiAgICB2YXIgJGl0ZW1zID0gJHBhcmVudC5maW5kKCcuZHJvcGRvd24tbWVudScgKyBkZXNjKVxuXG4gICAgaWYgKCEkaXRlbXMubGVuZ3RoKSByZXR1cm5cblxuICAgIHZhciBpbmRleCA9ICRpdGVtcy5pbmRleChlLnRhcmdldClcblxuICAgIGlmIChlLndoaWNoID09IDM4ICYmIGluZGV4ID4gMCkgICAgICAgICAgICAgICAgIGluZGV4LS0gICAgICAgICAvLyB1cFxuICAgIGlmIChlLndoaWNoID09IDQwICYmIGluZGV4IDwgJGl0ZW1zLmxlbmd0aCAtIDEpIGluZGV4KysgICAgICAgICAvLyBkb3duXG4gICAgaWYgKCF+aW5kZXgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAwXG5cbiAgICAkaXRlbXMuZXEoaW5kZXgpLnRyaWdnZXIoJ2ZvY3VzJylcbiAgfVxuXG5cbiAgLy8gRFJPUERPV04gUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgPSAkdGhpcy5kYXRhKCdicy5kcm9wZG93bicpXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuZHJvcGRvd24nLCAoZGF0YSA9IG5ldyBEcm9wZG93bih0aGlzKSkpXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJykgZGF0YVtvcHRpb25dLmNhbGwoJHRoaXMpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLmRyb3Bkb3duXG5cbiAgJC5mbi5kcm9wZG93biAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLmRyb3Bkb3duLkNvbnN0cnVjdG9yID0gRHJvcGRvd25cblxuXG4gIC8vIERST1BET1dOIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5kcm9wZG93bi5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4uZHJvcGRvd24gPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBBUFBMWSBUTyBTVEFOREFSRCBEUk9QRE9XTiBFTEVNRU5UU1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICQoZG9jdW1lbnQpXG4gICAgLm9uKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScsIGNsZWFyTWVudXMpXG4gICAgLm9uKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScsICcuZHJvcGRvd24gZm9ybScsIGZ1bmN0aW9uIChlKSB7IGUuc3RvcFByb3BhZ2F0aW9uKCkgfSlcbiAgICAub24oJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgdG9nZ2xlLCBEcm9wZG93bi5wcm90b3R5cGUudG9nZ2xlKVxuICAgIC5vbigna2V5ZG93bi5icy5kcm9wZG93bi5kYXRhLWFwaScsIHRvZ2dsZSwgRHJvcGRvd24ucHJvdG90eXBlLmtleWRvd24pXG4gICAgLm9uKCdrZXlkb3duLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgJy5kcm9wZG93bi1tZW51JywgRHJvcGRvd24ucHJvdG90eXBlLmtleWRvd24pXG5cbn0oalF1ZXJ5KTtcbiIsIi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQm9vdHN0cmFwOiBtb2RhbC5qcyB2My4zLjZcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI21vZGFsc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIE1PREFMIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBNb2RhbCA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zICAgICAgICAgICAgID0gb3B0aW9uc1xuICAgIHRoaXMuJGJvZHkgICAgICAgICAgICAgICA9ICQoZG9jdW1lbnQuYm9keSlcbiAgICB0aGlzLiRlbGVtZW50ICAgICAgICAgICAgPSAkKGVsZW1lbnQpXG4gICAgdGhpcy4kZGlhbG9nICAgICAgICAgICAgID0gdGhpcy4kZWxlbWVudC5maW5kKCcubW9kYWwtZGlhbG9nJylcbiAgICB0aGlzLiRiYWNrZHJvcCAgICAgICAgICAgPSBudWxsXG4gICAgdGhpcy5pc1Nob3duICAgICAgICAgICAgID0gbnVsbFxuICAgIHRoaXMub3JpZ2luYWxCb2R5UGFkICAgICA9IG51bGxcbiAgICB0aGlzLnNjcm9sbGJhcldpZHRoICAgICAgPSAwXG4gICAgdGhpcy5pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2VcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucmVtb3RlKSB7XG4gICAgICB0aGlzLiRlbGVtZW50XG4gICAgICAgIC5maW5kKCcubW9kYWwtY29udGVudCcpXG4gICAgICAgIC5sb2FkKHRoaXMub3B0aW9ucy5yZW1vdGUsICQucHJveHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignbG9hZGVkLmJzLm1vZGFsJylcbiAgICAgICAgfSwgdGhpcykpXG4gICAgfVxuICB9XG5cbiAgTW9kYWwuVkVSU0lPTiAgPSAnMy4zLjYnXG5cbiAgTW9kYWwuVFJBTlNJVElPTl9EVVJBVElPTiA9IDMwMFxuICBNb2RhbC5CQUNLRFJPUF9UUkFOU0lUSU9OX0RVUkFUSU9OID0gMTUwXG5cbiAgTW9kYWwuREVGQVVMVFMgPSB7XG4gICAgYmFja2Ryb3A6IHRydWUsXG4gICAga2V5Ym9hcmQ6IHRydWUsXG4gICAgc2hvdzogdHJ1ZVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uIChfcmVsYXRlZFRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLmlzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyhfcmVsYXRlZFRhcmdldClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKF9yZWxhdGVkVGFyZ2V0KSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgdmFyIGUgICAgPSAkLkV2ZW50KCdzaG93LmJzLm1vZGFsJywgeyByZWxhdGVkVGFyZ2V0OiBfcmVsYXRlZFRhcmdldCB9KVxuXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXG5cbiAgICBpZiAodGhpcy5pc1Nob3duIHx8IGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgdGhpcy5pc1Nob3duID0gdHJ1ZVxuXG4gICAgdGhpcy5jaGVja1Njcm9sbGJhcigpXG4gICAgdGhpcy5zZXRTY3JvbGxiYXIoKVxuICAgIHRoaXMuJGJvZHkuYWRkQ2xhc3MoJ21vZGFsLW9wZW4nKVxuXG4gICAgdGhpcy5lc2NhcGUoKVxuICAgIHRoaXMucmVzaXplKClcblxuICAgIHRoaXMuJGVsZW1lbnQub24oJ2NsaWNrLmRpc21pc3MuYnMubW9kYWwnLCAnW2RhdGEtZGlzbWlzcz1cIm1vZGFsXCJdJywgJC5wcm94eSh0aGlzLmhpZGUsIHRoaXMpKVxuXG4gICAgdGhpcy4kZGlhbG9nLm9uKCdtb3VzZWRvd24uZGlzbWlzcy5icy5tb2RhbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQuJGVsZW1lbnQub25lKCdtb3VzZXVwLmRpc21pc3MuYnMubW9kYWwnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoJChlLnRhcmdldCkuaXModGhhdC4kZWxlbWVudCkpIHRoYXQuaWdub3JlQmFja2Ryb3BDbGljayA9IHRydWVcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHRoaXMuYmFja2Ryb3AoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRyYW5zaXRpb24gPSAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiB0aGF0LiRlbGVtZW50Lmhhc0NsYXNzKCdmYWRlJylcblxuICAgICAgaWYgKCF0aGF0LiRlbGVtZW50LnBhcmVudCgpLmxlbmd0aCkge1xuICAgICAgICB0aGF0LiRlbGVtZW50LmFwcGVuZFRvKHRoYXQuJGJvZHkpIC8vIGRvbid0IG1vdmUgbW9kYWxzIGRvbSBwb3NpdGlvblxuICAgICAgfVxuXG4gICAgICB0aGF0LiRlbGVtZW50XG4gICAgICAgIC5zaG93KClcbiAgICAgICAgLnNjcm9sbFRvcCgwKVxuXG4gICAgICB0aGF0LmFkanVzdERpYWxvZygpXG5cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHRoYXQuJGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGggLy8gZm9yY2UgcmVmbG93XG4gICAgICB9XG5cbiAgICAgIHRoYXQuJGVsZW1lbnQuYWRkQ2xhc3MoJ2luJylcblxuICAgICAgdGhhdC5lbmZvcmNlRm9jdXMoKVxuXG4gICAgICB2YXIgZSA9ICQuRXZlbnQoJ3Nob3duLmJzLm1vZGFsJywgeyByZWxhdGVkVGFyZ2V0OiBfcmVsYXRlZFRhcmdldCB9KVxuXG4gICAgICB0cmFuc2l0aW9uID9cbiAgICAgICAgdGhhdC4kZGlhbG9nIC8vIHdhaXQgZm9yIG1vZGFsIHRvIHNsaWRlIGluXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdmb2N1cycpLnRyaWdnZXIoZSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChNb2RhbC5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignZm9jdXMnKS50cmlnZ2VyKGUpXG4gICAgfSlcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZSkgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICBlID0gJC5FdmVudCgnaGlkZS5icy5tb2RhbCcpXG5cbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcblxuICAgIGlmICghdGhpcy5pc1Nob3duIHx8IGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgdGhpcy5pc1Nob3duID0gZmFsc2VcblxuICAgIHRoaXMuZXNjYXBlKClcbiAgICB0aGlzLnJlc2l6ZSgpXG5cbiAgICAkKGRvY3VtZW50KS5vZmYoJ2ZvY3VzaW4uYnMubW9kYWwnKVxuXG4gICAgdGhpcy4kZWxlbWVudFxuICAgICAgLnJlbW92ZUNsYXNzKCdpbicpXG4gICAgICAub2ZmKCdjbGljay5kaXNtaXNzLmJzLm1vZGFsJylcbiAgICAgIC5vZmYoJ21vdXNldXAuZGlzbWlzcy5icy5tb2RhbCcpXG5cbiAgICB0aGlzLiRkaWFsb2cub2ZmKCdtb3VzZWRvd24uZGlzbWlzcy5icy5tb2RhbCcpXG5cbiAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdmYWRlJykgP1xuICAgICAgdGhpcy4kZWxlbWVudFxuICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCAkLnByb3h5KHRoaXMuaGlkZU1vZGFsLCB0aGlzKSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKE1vZGFsLlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgIHRoaXMuaGlkZU1vZGFsKClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5lbmZvcmNlRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgJChkb2N1bWVudClcbiAgICAgIC5vZmYoJ2ZvY3VzaW4uYnMubW9kYWwnKSAvLyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGZvY3VzIGxvb3BcbiAgICAgIC5vbignZm9jdXNpbi5icy5tb2RhbCcsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuJGVsZW1lbnRbMF0gIT09IGUudGFyZ2V0ICYmICF0aGlzLiRlbGVtZW50LmhhcyhlLnRhcmdldCkubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdmb2N1cycpXG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLmVzY2FwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc1Nob3duICYmIHRoaXMub3B0aW9ucy5rZXlib2FyZCkge1xuICAgICAgdGhpcy4kZWxlbWVudC5vbigna2V5ZG93bi5kaXNtaXNzLmJzLm1vZGFsJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLndoaWNoID09IDI3ICYmIHRoaXMuaGlkZSgpXG4gICAgICB9LCB0aGlzKSlcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzU2hvd24pIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdrZXlkb3duLmRpc21pc3MuYnMubW9kYWwnKVxuICAgIH1cbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNTaG93bikge1xuICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUuYnMubW9kYWwnLCAkLnByb3h5KHRoaXMuaGFuZGxlVXBkYXRlLCB0aGlzKSlcbiAgICB9IGVsc2Uge1xuICAgICAgJCh3aW5kb3cpLm9mZigncmVzaXplLmJzLm1vZGFsJylcbiAgICB9XG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuaGlkZU1vZGFsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIHRoaXMuJGVsZW1lbnQuaGlkZSgpXG4gICAgdGhpcy5iYWNrZHJvcChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LiRib2R5LnJlbW92ZUNsYXNzKCdtb2RhbC1vcGVuJylcbiAgICAgIHRoYXQucmVzZXRBZGp1c3RtZW50cygpXG4gICAgICB0aGF0LnJlc2V0U2Nyb2xsYmFyKClcbiAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignaGlkZGVuLmJzLm1vZGFsJylcbiAgICB9KVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnJlbW92ZUJhY2tkcm9wID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuJGJhY2tkcm9wICYmIHRoaXMuJGJhY2tkcm9wLnJlbW92ZSgpXG4gICAgdGhpcy4kYmFja2Ryb3AgPSBudWxsXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuYmFja2Ryb3AgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICB2YXIgYW5pbWF0ZSA9IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/ICdmYWRlJyA6ICcnXG5cbiAgICBpZiAodGhpcy5pc1Nob3duICYmIHRoaXMub3B0aW9ucy5iYWNrZHJvcCkge1xuICAgICAgdmFyIGRvQW5pbWF0ZSA9ICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIGFuaW1hdGVcblxuICAgICAgdGhpcy4kYmFja2Ryb3AgPSAkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKVxuICAgICAgICAuYWRkQ2xhc3MoJ21vZGFsLWJhY2tkcm9wICcgKyBhbmltYXRlKVxuICAgICAgICAuYXBwZW5kVG8odGhpcy4kYm9keSlcblxuICAgICAgdGhpcy4kZWxlbWVudC5vbignY2xpY2suZGlzbWlzcy5icy5tb2RhbCcsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaWdub3JlQmFja2Ryb3BDbGljaykge1xuICAgICAgICAgIHRoaXMuaWdub3JlQmFja2Ryb3BDbGljayA9IGZhbHNlXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQpIHJldHVyblxuICAgICAgICB0aGlzLm9wdGlvbnMuYmFja2Ryb3AgPT0gJ3N0YXRpYydcbiAgICAgICAgICA/IHRoaXMuJGVsZW1lbnRbMF0uZm9jdXMoKVxuICAgICAgICAgIDogdGhpcy5oaWRlKClcbiAgICAgIH0sIHRoaXMpKVxuXG4gICAgICBpZiAoZG9BbmltYXRlKSB0aGlzLiRiYWNrZHJvcFswXS5vZmZzZXRXaWR0aCAvLyBmb3JjZSByZWZsb3dcblxuICAgICAgdGhpcy4kYmFja2Ryb3AuYWRkQ2xhc3MoJ2luJylcblxuICAgICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuXG5cbiAgICAgIGRvQW5pbWF0ZSA/XG4gICAgICAgIHRoaXMuJGJhY2tkcm9wXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY2FsbGJhY2spXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKE1vZGFsLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgY2FsbGJhY2soKVxuXG4gICAgfSBlbHNlIGlmICghdGhpcy5pc1Nob3duICYmIHRoaXMuJGJhY2tkcm9wKSB7XG4gICAgICB0aGlzLiRiYWNrZHJvcC5yZW1vdmVDbGFzcygnaW4nKVxuXG4gICAgICB2YXIgY2FsbGJhY2tSZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoYXQucmVtb3ZlQmFja2Ryb3AoKVxuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gICAgICB9XG4gICAgICAkLnN1cHBvcnQudHJhbnNpdGlvbiAmJiB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdmYWRlJykgP1xuICAgICAgICB0aGlzLiRiYWNrZHJvcFxuICAgICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGNhbGxiYWNrUmVtb3ZlKVxuICAgICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChNb2RhbC5CQUNLRFJPUF9UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICAgIGNhbGxiYWNrUmVtb3ZlKClcblxuICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gIH1cblxuICAvLyB0aGVzZSBmb2xsb3dpbmcgbWV0aG9kcyBhcmUgdXNlZCB0byBoYW5kbGUgb3ZlcmZsb3dpbmcgbW9kYWxzXG5cbiAgTW9kYWwucHJvdG90eXBlLmhhbmRsZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFkanVzdERpYWxvZygpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuYWRqdXN0RGlhbG9nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RhbElzT3ZlcmZsb3dpbmcgPSB0aGlzLiRlbGVtZW50WzBdLnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcblxuICAgIHRoaXMuJGVsZW1lbnQuY3NzKHtcbiAgICAgIHBhZGRpbmdMZWZ0OiAgIXRoaXMuYm9keUlzT3ZlcmZsb3dpbmcgJiYgbW9kYWxJc092ZXJmbG93aW5nID8gdGhpcy5zY3JvbGxiYXJXaWR0aCA6ICcnLFxuICAgICAgcGFkZGluZ1JpZ2h0OiB0aGlzLmJvZHlJc092ZXJmbG93aW5nICYmICFtb2RhbElzT3ZlcmZsb3dpbmcgPyB0aGlzLnNjcm9sbGJhcldpZHRoIDogJydcbiAgICB9KVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnJlc2V0QWRqdXN0bWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kZWxlbWVudC5jc3Moe1xuICAgICAgcGFkZGluZ0xlZnQ6ICcnLFxuICAgICAgcGFkZGluZ1JpZ2h0OiAnJ1xuICAgIH0pXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUuY2hlY2tTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZ1bGxXaW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgaWYgKCFmdWxsV2luZG93V2lkdGgpIHsgLy8gd29ya2Fyb3VuZCBmb3IgbWlzc2luZyB3aW5kb3cuaW5uZXJXaWR0aCBpbiBJRThcbiAgICAgIHZhciBkb2N1bWVudEVsZW1lbnRSZWN0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICBmdWxsV2luZG93V2lkdGggPSBkb2N1bWVudEVsZW1lbnRSZWN0LnJpZ2h0IC0gTWF0aC5hYnMoZG9jdW1lbnRFbGVtZW50UmVjdC5sZWZ0KVxuICAgIH1cbiAgICB0aGlzLmJvZHlJc092ZXJmbG93aW5nID0gZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCA8IGZ1bGxXaW5kb3dXaWR0aFxuICAgIHRoaXMuc2Nyb2xsYmFyV2lkdGggPSB0aGlzLm1lYXN1cmVTY3JvbGxiYXIoKVxuICB9XG5cbiAgTW9kYWwucHJvdG90eXBlLnNldFNjcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYm9keVBhZCA9IHBhcnNlSW50KCh0aGlzLiRib2R5LmNzcygncGFkZGluZy1yaWdodCcpIHx8IDApLCAxMClcbiAgICB0aGlzLm9yaWdpbmFsQm9keVBhZCA9IGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0IHx8ICcnXG4gICAgaWYgKHRoaXMuYm9keUlzT3ZlcmZsb3dpbmcpIHRoaXMuJGJvZHkuY3NzKCdwYWRkaW5nLXJpZ2h0JywgYm9keVBhZCArIHRoaXMuc2Nyb2xsYmFyV2lkdGgpXG4gIH1cblxuICBNb2RhbC5wcm90b3R5cGUucmVzZXRTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy4kYm9keS5jc3MoJ3BhZGRpbmctcmlnaHQnLCB0aGlzLm9yaWdpbmFsQm9keVBhZClcbiAgfVxuXG4gIE1vZGFsLnByb3RvdHlwZS5tZWFzdXJlU2Nyb2xsYmFyID0gZnVuY3Rpb24gKCkgeyAvLyB0aHggd2Fsc2hcbiAgICB2YXIgc2Nyb2xsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBzY3JvbGxEaXYuY2xhc3NOYW1lID0gJ21vZGFsLXNjcm9sbGJhci1tZWFzdXJlJ1xuICAgIHRoaXMuJGJvZHkuYXBwZW5kKHNjcm9sbERpdilcbiAgICB2YXIgc2Nyb2xsYmFyV2lkdGggPSBzY3JvbGxEaXYub2Zmc2V0V2lkdGggLSBzY3JvbGxEaXYuY2xpZW50V2lkdGhcbiAgICB0aGlzLiRib2R5WzBdLnJlbW92ZUNoaWxkKHNjcm9sbERpdilcbiAgICByZXR1cm4gc2Nyb2xsYmFyV2lkdGhcbiAgfVxuXG5cbiAgLy8gTU9EQUwgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBQbHVnaW4ob3B0aW9uLCBfcmVsYXRlZFRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLm1vZGFsJylcbiAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIE1vZGFsLkRFRkFVTFRTLCAkdGhpcy5kYXRhKCksIHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uKVxuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLm1vZGFsJywgKGRhdGEgPSBuZXcgTW9kYWwodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXShfcmVsYXRlZFRhcmdldClcbiAgICAgIGVsc2UgaWYgKG9wdGlvbnMuc2hvdykgZGF0YS5zaG93KF9yZWxhdGVkVGFyZ2V0KVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5tb2RhbFxuXG4gICQuZm4ubW9kYWwgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5tb2RhbC5Db25zdHJ1Y3RvciA9IE1vZGFsXG5cblxuICAvLyBNT0RBTCBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gICQuZm4ubW9kYWwubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkLmZuLm1vZGFsID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgLy8gTU9EQUwgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT1cblxuICAkKGRvY3VtZW50KS5vbignY2xpY2suYnMubW9kYWwuZGF0YS1hcGknLCAnW2RhdGEtdG9nZ2xlPVwibW9kYWxcIl0nLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgIHZhciBocmVmICAgID0gJHRoaXMuYXR0cignaHJlZicpXG4gICAgdmFyICR0YXJnZXQgPSAkKCR0aGlzLmF0dHIoJ2RhdGEtdGFyZ2V0JykgfHwgKGhyZWYgJiYgaHJlZi5yZXBsYWNlKC8uKig/PSNbXlxcc10rJCkvLCAnJykpKSAvLyBzdHJpcCBmb3IgaWU3XG4gICAgdmFyIG9wdGlvbiAgPSAkdGFyZ2V0LmRhdGEoJ2JzLm1vZGFsJykgPyAndG9nZ2xlJyA6ICQuZXh0ZW5kKHsgcmVtb3RlOiAhLyMvLnRlc3QoaHJlZikgJiYgaHJlZiB9LCAkdGFyZ2V0LmRhdGEoKSwgJHRoaXMuZGF0YSgpKVxuXG4gICAgaWYgKCR0aGlzLmlzKCdhJykpIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgJHRhcmdldC5vbmUoJ3Nob3cuYnMubW9kYWwnLCBmdW5jdGlvbiAoc2hvd0V2ZW50KSB7XG4gICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm4gLy8gb25seSByZWdpc3RlciBmb2N1cyByZXN0b3JlciBpZiBtb2RhbCB3aWxsIGFjdHVhbGx5IGdldCBzaG93blxuICAgICAgJHRhcmdldC5vbmUoJ2hpZGRlbi5icy5tb2RhbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJHRoaXMuaXMoJzp2aXNpYmxlJykgJiYgJHRoaXMudHJpZ2dlcignZm9jdXMnKVxuICAgICAgfSlcbiAgICB9KVxuICAgIFBsdWdpbi5jYWxsKCR0YXJnZXQsIG9wdGlvbiwgdGhpcylcbiAgfSlcblxufShqUXVlcnkpO1xuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IHBvcG92ZXIuanMgdjMuMy42XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyNwb3BvdmVyc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFBPUE9WRVIgUFVCTElDIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBQb3BvdmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmluaXQoJ3BvcG92ZXInLCBlbGVtZW50LCBvcHRpb25zKVxuICB9XG5cbiAgaWYgKCEkLmZuLnRvb2x0aXApIHRocm93IG5ldyBFcnJvcignUG9wb3ZlciByZXF1aXJlcyB0b29sdGlwLmpzJylcblxuICBQb3BvdmVyLlZFUlNJT04gID0gJzMuMy42J1xuXG4gIFBvcG92ZXIuREVGQVVMVFMgPSAkLmV4dGVuZCh7fSwgJC5mbi50b29sdGlwLkNvbnN0cnVjdG9yLkRFRkFVTFRTLCB7XG4gICAgcGxhY2VtZW50OiAncmlnaHQnLFxuICAgIHRyaWdnZXI6ICdjbGljaycsXG4gICAgY29udGVudDogJycsXG4gICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwicG9wb3ZlclwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBjbGFzcz1cImFycm93XCI+PC9kaXY+PGgzIGNsYXNzPVwicG9wb3Zlci10aXRsZVwiPjwvaDM+PGRpdiBjbGFzcz1cInBvcG92ZXItY29udGVudFwiPjwvZGl2PjwvZGl2PidcbiAgfSlcblxuXG4gIC8vIE5PVEU6IFBPUE9WRVIgRVhURU5EUyB0b29sdGlwLmpzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgUG9wb3Zlci5wcm90b3R5cGUgPSAkLmV4dGVuZCh7fSwgJC5mbi50b29sdGlwLkNvbnN0cnVjdG9yLnByb3RvdHlwZSlcblxuICBQb3BvdmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvcG92ZXJcblxuICBQb3BvdmVyLnByb3RvdHlwZS5nZXREZWZhdWx0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUG9wb3Zlci5ERUZBVUxUU1xuICB9XG5cbiAgUG9wb3Zlci5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJHRpcCAgICA9IHRoaXMudGlwKClcbiAgICB2YXIgdGl0bGUgICA9IHRoaXMuZ2V0VGl0bGUoKVxuICAgIHZhciBjb250ZW50ID0gdGhpcy5nZXRDb250ZW50KClcblxuICAgICR0aXAuZmluZCgnLnBvcG92ZXItdGl0bGUnKVt0aGlzLm9wdGlvbnMuaHRtbCA/ICdodG1sJyA6ICd0ZXh0J10odGl0bGUpXG4gICAgJHRpcC5maW5kKCcucG9wb3Zlci1jb250ZW50JykuY2hpbGRyZW4oKS5kZXRhY2goKS5lbmQoKVsgLy8gd2UgdXNlIGFwcGVuZCBmb3IgaHRtbCBvYmplY3RzIHRvIG1haW50YWluIGpzIGV2ZW50c1xuICAgICAgdGhpcy5vcHRpb25zLmh0bWwgPyAodHlwZW9mIGNvbnRlbnQgPT0gJ3N0cmluZycgPyAnaHRtbCcgOiAnYXBwZW5kJykgOiAndGV4dCdcbiAgICBdKGNvbnRlbnQpXG5cbiAgICAkdGlwLnJlbW92ZUNsYXNzKCdmYWRlIHRvcCBib3R0b20gbGVmdCByaWdodCBpbicpXG5cbiAgICAvLyBJRTggZG9lc24ndCBhY2NlcHQgaGlkaW5nIHZpYSB0aGUgYDplbXB0eWAgcHNldWRvIHNlbGVjdG9yLCB3ZSBoYXZlIHRvIGRvXG4gICAgLy8gdGhpcyBtYW51YWxseSBieSBjaGVja2luZyB0aGUgY29udGVudHMuXG4gICAgaWYgKCEkdGlwLmZpbmQoJy5wb3BvdmVyLXRpdGxlJykuaHRtbCgpKSAkdGlwLmZpbmQoJy5wb3BvdmVyLXRpdGxlJykuaGlkZSgpXG4gIH1cblxuICBQb3BvdmVyLnByb3RvdHlwZS5oYXNDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldFRpdGxlKCkgfHwgdGhpcy5nZXRDb250ZW50KClcbiAgfVxuXG4gIFBvcG92ZXIucHJvdG90eXBlLmdldENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICRlID0gdGhpcy4kZWxlbWVudFxuICAgIHZhciBvICA9IHRoaXMub3B0aW9uc1xuXG4gICAgcmV0dXJuICRlLmF0dHIoJ2RhdGEtY29udGVudCcpXG4gICAgICB8fCAodHlwZW9mIG8uY29udGVudCA9PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgIG8uY29udGVudC5jYWxsKCRlWzBdKSA6XG4gICAgICAgICAgICBvLmNvbnRlbnQpXG4gIH1cblxuICBQb3BvdmVyLnByb3RvdHlwZS5hcnJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuJGFycm93ID0gdGhpcy4kYXJyb3cgfHwgdGhpcy50aXAoKS5maW5kKCcuYXJyb3cnKSlcbiAgfVxuXG5cbiAgLy8gUE9QT1ZFUiBQTFVHSU4gREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLnBvcG92ZXInKVxuICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvblxuXG4gICAgICBpZiAoIWRhdGEgJiYgL2Rlc3Ryb3l8aGlkZS8udGVzdChvcHRpb24pKSByZXR1cm5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMucG9wb3ZlcicsIChkYXRhID0gbmV3IFBvcG92ZXIodGhpcywgb3B0aW9ucykpKVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpXG4gICAgfSlcbiAgfVxuXG4gIHZhciBvbGQgPSAkLmZuLnBvcG92ZXJcblxuICAkLmZuLnBvcG92ZXIgICAgICAgICAgICAgPSBQbHVnaW5cbiAgJC5mbi5wb3BvdmVyLkNvbnN0cnVjdG9yID0gUG9wb3ZlclxuXG5cbiAgLy8gUE9QT1ZFUiBOTyBDT05GTElDVFxuICAvLyA9PT09PT09PT09PT09PT09PT09XG5cbiAgJC5mbi5wb3BvdmVyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5wb3BvdmVyID0gb2xkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG59KGpRdWVyeSk7XG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEJvb3RzdHJhcDogc2Nyb2xsc3B5LmpzIHYzLjMuNlxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jc2Nyb2xsc3B5XG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gU0NST0xMU1BZIENMQVNTIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiBTY3JvbGxTcHkoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMuJGJvZHkgICAgICAgICAgPSAkKGRvY3VtZW50LmJvZHkpXG4gICAgdGhpcy4kc2Nyb2xsRWxlbWVudCA9ICQoZWxlbWVudCkuaXMoZG9jdW1lbnQuYm9keSkgPyAkKHdpbmRvdykgOiAkKGVsZW1lbnQpXG4gICAgdGhpcy5vcHRpb25zICAgICAgICA9ICQuZXh0ZW5kKHt9LCBTY3JvbGxTcHkuREVGQVVMVFMsIG9wdGlvbnMpXG4gICAgdGhpcy5zZWxlY3RvciAgICAgICA9ICh0aGlzLm9wdGlvbnMudGFyZ2V0IHx8ICcnKSArICcgLm5hdiBsaSA+IGEnXG4gICAgdGhpcy5vZmZzZXRzICAgICAgICA9IFtdXG4gICAgdGhpcy50YXJnZXRzICAgICAgICA9IFtdXG4gICAgdGhpcy5hY3RpdmVUYXJnZXQgICA9IG51bGxcbiAgICB0aGlzLnNjcm9sbEhlaWdodCAgID0gMFxuXG4gICAgdGhpcy4kc2Nyb2xsRWxlbWVudC5vbignc2Nyb2xsLmJzLnNjcm9sbHNweScsICQucHJveHkodGhpcy5wcm9jZXNzLCB0aGlzKSlcbiAgICB0aGlzLnJlZnJlc2goKVxuICAgIHRoaXMucHJvY2VzcygpXG4gIH1cblxuICBTY3JvbGxTcHkuVkVSU0lPTiAgPSAnMy4zLjYnXG5cbiAgU2Nyb2xsU3B5LkRFRkFVTFRTID0ge1xuICAgIG9mZnNldDogMTBcbiAgfVxuXG4gIFNjcm9sbFNweS5wcm90b3R5cGUuZ2V0U2Nyb2xsSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLiRzY3JvbGxFbGVtZW50WzBdLnNjcm9sbEhlaWdodCB8fCBNYXRoLm1heCh0aGlzLiRib2R5WzBdLnNjcm9sbEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodClcbiAgfVxuXG4gIFNjcm9sbFNweS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCAgICAgICAgICA9IHRoaXNcbiAgICB2YXIgb2Zmc2V0TWV0aG9kICA9ICdvZmZzZXQnXG4gICAgdmFyIG9mZnNldEJhc2UgICAgPSAwXG5cbiAgICB0aGlzLm9mZnNldHMgICAgICA9IFtdXG4gICAgdGhpcy50YXJnZXRzICAgICAgPSBbXVxuICAgIHRoaXMuc2Nyb2xsSGVpZ2h0ID0gdGhpcy5nZXRTY3JvbGxIZWlnaHQoKVxuXG4gICAgaWYgKCEkLmlzV2luZG93KHRoaXMuJHNjcm9sbEVsZW1lbnRbMF0pKSB7XG4gICAgICBvZmZzZXRNZXRob2QgPSAncG9zaXRpb24nXG4gICAgICBvZmZzZXRCYXNlICAgPSB0aGlzLiRzY3JvbGxFbGVtZW50LnNjcm9sbFRvcCgpXG4gICAgfVxuXG4gICAgdGhpcy4kYm9keVxuICAgICAgLmZpbmQodGhpcy5zZWxlY3RvcilcbiAgICAgIC5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJGVsICAgPSAkKHRoaXMpXG4gICAgICAgIHZhciBocmVmICA9ICRlbC5kYXRhKCd0YXJnZXQnKSB8fCAkZWwuYXR0cignaHJlZicpXG4gICAgICAgIHZhciAkaHJlZiA9IC9eIy4vLnRlc3QoaHJlZikgJiYgJChocmVmKVxuXG4gICAgICAgIHJldHVybiAoJGhyZWZcbiAgICAgICAgICAmJiAkaHJlZi5sZW5ndGhcbiAgICAgICAgICAmJiAkaHJlZi5pcygnOnZpc2libGUnKVxuICAgICAgICAgICYmIFtbJGhyZWZbb2Zmc2V0TWV0aG9kXSgpLnRvcCArIG9mZnNldEJhc2UsIGhyZWZdXSkgfHwgbnVsbFxuICAgICAgfSlcbiAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhWzBdIC0gYlswXSB9KVxuICAgICAgLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGF0Lm9mZnNldHMucHVzaCh0aGlzWzBdKVxuICAgICAgICB0aGF0LnRhcmdldHMucHVzaCh0aGlzWzFdKVxuICAgICAgfSlcbiAgfVxuXG4gIFNjcm9sbFNweS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2Nyb2xsVG9wICAgID0gdGhpcy4kc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3AoKSArIHRoaXMub3B0aW9ucy5vZmZzZXRcbiAgICB2YXIgc2Nyb2xsSGVpZ2h0ID0gdGhpcy5nZXRTY3JvbGxIZWlnaHQoKVxuICAgIHZhciBtYXhTY3JvbGwgICAgPSB0aGlzLm9wdGlvbnMub2Zmc2V0ICsgc2Nyb2xsSGVpZ2h0IC0gdGhpcy4kc2Nyb2xsRWxlbWVudC5oZWlnaHQoKVxuICAgIHZhciBvZmZzZXRzICAgICAgPSB0aGlzLm9mZnNldHNcbiAgICB2YXIgdGFyZ2V0cyAgICAgID0gdGhpcy50YXJnZXRzXG4gICAgdmFyIGFjdGl2ZVRhcmdldCA9IHRoaXMuYWN0aXZlVGFyZ2V0XG4gICAgdmFyIGlcblxuICAgIGlmICh0aGlzLnNjcm9sbEhlaWdodCAhPSBzY3JvbGxIZWlnaHQpIHtcbiAgICAgIHRoaXMucmVmcmVzaCgpXG4gICAgfVxuXG4gICAgaWYgKHNjcm9sbFRvcCA+PSBtYXhTY3JvbGwpIHtcbiAgICAgIHJldHVybiBhY3RpdmVUYXJnZXQgIT0gKGkgPSB0YXJnZXRzW3RhcmdldHMubGVuZ3RoIC0gMV0pICYmIHRoaXMuYWN0aXZhdGUoaSlcbiAgICB9XG5cbiAgICBpZiAoYWN0aXZlVGFyZ2V0ICYmIHNjcm9sbFRvcCA8IG9mZnNldHNbMF0pIHtcbiAgICAgIHRoaXMuYWN0aXZlVGFyZ2V0ID0gbnVsbFxuICAgICAgcmV0dXJuIHRoaXMuY2xlYXIoKVxuICAgIH1cblxuICAgIGZvciAoaSA9IG9mZnNldHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBhY3RpdmVUYXJnZXQgIT0gdGFyZ2V0c1tpXVxuICAgICAgICAmJiBzY3JvbGxUb3AgPj0gb2Zmc2V0c1tpXVxuICAgICAgICAmJiAob2Zmc2V0c1tpICsgMV0gPT09IHVuZGVmaW5lZCB8fCBzY3JvbGxUb3AgPCBvZmZzZXRzW2kgKyAxXSlcbiAgICAgICAgJiYgdGhpcy5hY3RpdmF0ZSh0YXJnZXRzW2ldKVxuICAgIH1cbiAgfVxuXG4gIFNjcm9sbFNweS5wcm90b3R5cGUuYWN0aXZhdGUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGhpcy5hY3RpdmVUYXJnZXQgPSB0YXJnZXRcblxuICAgIHRoaXMuY2xlYXIoKVxuXG4gICAgdmFyIHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciArXG4gICAgICAnW2RhdGEtdGFyZ2V0PVwiJyArIHRhcmdldCArICdcIl0sJyArXG4gICAgICB0aGlzLnNlbGVjdG9yICsgJ1tocmVmPVwiJyArIHRhcmdldCArICdcIl0nXG5cbiAgICB2YXIgYWN0aXZlID0gJChzZWxlY3RvcilcbiAgICAgIC5wYXJlbnRzKCdsaScpXG4gICAgICAuYWRkQ2xhc3MoJ2FjdGl2ZScpXG5cbiAgICBpZiAoYWN0aXZlLnBhcmVudCgnLmRyb3Bkb3duLW1lbnUnKS5sZW5ndGgpIHtcbiAgICAgIGFjdGl2ZSA9IGFjdGl2ZVxuICAgICAgICAuY2xvc2VzdCgnbGkuZHJvcGRvd24nKVxuICAgICAgICAuYWRkQ2xhc3MoJ2FjdGl2ZScpXG4gICAgfVxuXG4gICAgYWN0aXZlLnRyaWdnZXIoJ2FjdGl2YXRlLmJzLnNjcm9sbHNweScpXG4gIH1cblxuICBTY3JvbGxTcHkucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICQodGhpcy5zZWxlY3RvcilcbiAgICAgIC5wYXJlbnRzVW50aWwodGhpcy5vcHRpb25zLnRhcmdldCwgJy5hY3RpdmUnKVxuICAgICAgLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICB9XG5cblxuICAvLyBTQ1JPTExTUFkgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICB2YXIgZGF0YSAgICA9ICR0aGlzLmRhdGEoJ2JzLnNjcm9sbHNweScpXG4gICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMuc2Nyb2xsc3B5JywgKGRhdGEgPSBuZXcgU2Nyb2xsU3B5KHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi5zY3JvbGxzcHlcblxuICAkLmZuLnNjcm9sbHNweSAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLnNjcm9sbHNweS5Db25zdHJ1Y3RvciA9IFNjcm9sbFNweVxuXG5cbiAgLy8gU0NST0xMU1BZIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4uc2Nyb2xsc3B5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi5zY3JvbGxzcHkgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBTQ1JPTExTUFkgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09PT09PT09XG5cbiAgJCh3aW5kb3cpLm9uKCdsb2FkLmJzLnNjcm9sbHNweS5kYXRhLWFwaScsIGZ1bmN0aW9uICgpIHtcbiAgICAkKCdbZGF0YS1zcHk9XCJzY3JvbGxcIl0nKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkc3B5ID0gJCh0aGlzKVxuICAgICAgUGx1Z2luLmNhbGwoJHNweSwgJHNweS5kYXRhKCkpXG4gICAgfSlcbiAgfSlcblxufShqUXVlcnkpO1xuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IHRhYi5qcyB2My4zLjZcbiAqIGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2phdmFzY3JpcHQvI3RhYnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblxuK2Z1bmN0aW9uICgkKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBUQUIgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PVxuXG4gIHZhciBUYWIgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIC8vIGpzY3M6ZGlzYWJsZSByZXF1aXJlRG9sbGFyQmVmb3JlalF1ZXJ5QXNzaWdubWVudFxuICAgIHRoaXMuZWxlbWVudCA9ICQoZWxlbWVudClcbiAgICAvLyBqc2NzOmVuYWJsZSByZXF1aXJlRG9sbGFyQmVmb3JlalF1ZXJ5QXNzaWdubWVudFxuICB9XG5cbiAgVGFiLlZFUlNJT04gPSAnMy4zLjYnXG5cbiAgVGFiLlRSQU5TSVRJT05fRFVSQVRJT04gPSAxNTBcblxuICBUYWIucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICR0aGlzICAgID0gdGhpcy5lbGVtZW50XG4gICAgdmFyICR1bCAgICAgID0gJHRoaXMuY2xvc2VzdCgndWw6bm90KC5kcm9wZG93bi1tZW51KScpXG4gICAgdmFyIHNlbGVjdG9yID0gJHRoaXMuZGF0YSgndGFyZ2V0JylcblxuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgIHNlbGVjdG9yID0gJHRoaXMuYXR0cignaHJlZicpXG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yICYmIHNlbGVjdG9yLnJlcGxhY2UoLy4qKD89I1teXFxzXSokKS8sICcnKSAvLyBzdHJpcCBmb3IgaWU3XG4gICAgfVxuXG4gICAgaWYgKCR0aGlzLnBhcmVudCgnbGknKS5oYXNDbGFzcygnYWN0aXZlJykpIHJldHVyblxuXG4gICAgdmFyICRwcmV2aW91cyA9ICR1bC5maW5kKCcuYWN0aXZlOmxhc3QgYScpXG4gICAgdmFyIGhpZGVFdmVudCA9ICQuRXZlbnQoJ2hpZGUuYnMudGFiJywge1xuICAgICAgcmVsYXRlZFRhcmdldDogJHRoaXNbMF1cbiAgICB9KVxuICAgIHZhciBzaG93RXZlbnQgPSAkLkV2ZW50KCdzaG93LmJzLnRhYicsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6ICRwcmV2aW91c1swXVxuICAgIH0pXG5cbiAgICAkcHJldmlvdXMudHJpZ2dlcihoaWRlRXZlbnQpXG4gICAgJHRoaXMudHJpZ2dlcihzaG93RXZlbnQpXG5cbiAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuXG5cbiAgICB2YXIgJHRhcmdldCA9ICQoc2VsZWN0b3IpXG5cbiAgICB0aGlzLmFjdGl2YXRlKCR0aGlzLmNsb3Nlc3QoJ2xpJyksICR1bClcbiAgICB0aGlzLmFjdGl2YXRlKCR0YXJnZXQsICR0YXJnZXQucGFyZW50KCksIGZ1bmN0aW9uICgpIHtcbiAgICAgICRwcmV2aW91cy50cmlnZ2VyKHtcbiAgICAgICAgdHlwZTogJ2hpZGRlbi5icy50YWInLFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiAkdGhpc1swXVxuICAgICAgfSlcbiAgICAgICR0aGlzLnRyaWdnZXIoe1xuICAgICAgICB0eXBlOiAnc2hvd24uYnMudGFiJyxcbiAgICAgICAgcmVsYXRlZFRhcmdldDogJHByZXZpb3VzWzBdXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBUYWIucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICB2YXIgJGFjdGl2ZSAgICA9IGNvbnRhaW5lci5maW5kKCc+IC5hY3RpdmUnKVxuICAgIHZhciB0cmFuc2l0aW9uID0gY2FsbGJhY2tcbiAgICAgICYmICQuc3VwcG9ydC50cmFuc2l0aW9uXG4gICAgICAmJiAoJGFjdGl2ZS5sZW5ndGggJiYgJGFjdGl2ZS5oYXNDbGFzcygnZmFkZScpIHx8ICEhY29udGFpbmVyLmZpbmQoJz4gLmZhZGUnKS5sZW5ndGgpXG5cbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgJGFjdGl2ZVxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICAgIC5maW5kKCc+IC5kcm9wZG93bi1tZW51ID4gLmFjdGl2ZScpXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKCdhY3RpdmUnKVxuICAgICAgICAuZW5kKClcbiAgICAgICAgLmZpbmQoJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScpXG4gICAgICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSlcblxuICAgICAgZWxlbWVudFxuICAgICAgICAuYWRkQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICAgIC5maW5kKCdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nKVxuICAgICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcblxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgZWxlbWVudFswXS5vZmZzZXRXaWR0aCAvLyByZWZsb3cgZm9yIHRyYW5zaXRpb25cbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcygnaW4nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcygnZmFkZScpXG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50LnBhcmVudCgnLmRyb3Bkb3duLW1lbnUnKS5sZW5ndGgpIHtcbiAgICAgICAgZWxlbWVudFxuICAgICAgICAgIC5jbG9zZXN0KCdsaS5kcm9wZG93bicpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2FjdGl2ZScpXG4gICAgICAgICAgLmVuZCgpXG4gICAgICAgICAgLmZpbmQoJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScpXG4gICAgICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICB9XG5cbiAgICAkYWN0aXZlLmxlbmd0aCAmJiB0cmFuc2l0aW9uID9cbiAgICAgICRhY3RpdmVcbiAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgbmV4dClcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKFRhYi5UUkFOU0lUSU9OX0RVUkFUSU9OKSA6XG4gICAgICBuZXh0KClcblxuICAgICRhY3RpdmUucmVtb3ZlQ2xhc3MoJ2luJylcbiAgfVxuXG5cbiAgLy8gVEFCIFBMVUdJTiBERUZJTklUSU9OXG4gIC8vID09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcylcbiAgICAgIHZhciBkYXRhICA9ICR0aGlzLmRhdGEoJ2JzLnRhYicpXG5cbiAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgnYnMudGFiJywgKGRhdGEgPSBuZXcgVGFiKHRoaXMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi50YWJcblxuICAkLmZuLnRhYiAgICAgICAgICAgICA9IFBsdWdpblxuICAkLmZuLnRhYi5Db25zdHJ1Y3RvciA9IFRhYlxuXG5cbiAgLy8gVEFCIE5PIENPTkZMSUNUXG4gIC8vID09PT09PT09PT09PT09PVxuXG4gICQuZm4udGFiLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJC5mbi50YWIgPSBvbGRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICAvLyBUQUIgREFUQS1BUElcbiAgLy8gPT09PT09PT09PT09XG5cbiAgdmFyIGNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgUGx1Z2luLmNhbGwoJCh0aGlzKSwgJ3Nob3cnKVxuICB9XG5cbiAgJChkb2N1bWVudClcbiAgICAub24oJ2NsaWNrLmJzLnRhYi5kYXRhLWFwaScsICdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nLCBjbGlja0hhbmRsZXIpXG4gICAgLm9uKCdjbGljay5icy50YWIuZGF0YS1hcGknLCAnW2RhdGEtdG9nZ2xlPVwicGlsbFwiXScsIGNsaWNrSGFuZGxlcilcblxufShqUXVlcnkpO1xuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IHRvb2x0aXAuanMgdjMuMy42XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyN0b29sdGlwXG4gKiBJbnNwaXJlZCBieSB0aGUgb3JpZ2luYWwgalF1ZXJ5LnRpcHN5IGJ5IEphc29uIEZyYW1lXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHlyaWdodCAyMDExLTIwMTUgVHdpdHRlciwgSW5jLlxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cbitmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gVE9PTFRJUCBQVUJMSUMgQ0xBU1MgREVGSU5JVElPTlxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIFRvb2x0aXAgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSAgICAgICA9IG51bGxcbiAgICB0aGlzLm9wdGlvbnMgICAgPSBudWxsXG4gICAgdGhpcy5lbmFibGVkICAgID0gbnVsbFxuICAgIHRoaXMudGltZW91dCAgICA9IG51bGxcbiAgICB0aGlzLmhvdmVyU3RhdGUgPSBudWxsXG4gICAgdGhpcy4kZWxlbWVudCAgID0gbnVsbFxuICAgIHRoaXMuaW5TdGF0ZSAgICA9IG51bGxcblxuICAgIHRoaXMuaW5pdCgndG9vbHRpcCcsIGVsZW1lbnQsIG9wdGlvbnMpXG4gIH1cblxuICBUb29sdGlwLlZFUlNJT04gID0gJzMuMy42J1xuXG4gIFRvb2x0aXAuVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxuXG4gIFRvb2x0aXAuREVGQVVMVFMgPSB7XG4gICAgYW5pbWF0aW9uOiB0cnVlLFxuICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgc2VsZWN0b3I6IGZhbHNlLFxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+PGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj48L2Rpdj4nLFxuICAgIHRyaWdnZXI6ICdob3ZlciBmb2N1cycsXG4gICAgdGl0bGU6ICcnLFxuICAgIGRlbGF5OiAwLFxuICAgIGh0bWw6IGZhbHNlLFxuICAgIGNvbnRhaW5lcjogZmFsc2UsXG4gICAgdmlld3BvcnQ6IHtcbiAgICAgIHNlbGVjdG9yOiAnYm9keScsXG4gICAgICBwYWRkaW5nOiAwXG4gICAgfVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICh0eXBlLCBlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdGhpcy5lbmFibGVkICAgPSB0cnVlXG4gICAgdGhpcy50eXBlICAgICAgPSB0eXBlXG4gICAgdGhpcy4kZWxlbWVudCAgPSAkKGVsZW1lbnQpXG4gICAgdGhpcy5vcHRpb25zICAgPSB0aGlzLmdldE9wdGlvbnMob3B0aW9ucylcbiAgICB0aGlzLiR2aWV3cG9ydCA9IHRoaXMub3B0aW9ucy52aWV3cG9ydCAmJiAkKCQuaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMudmlld3BvcnQpID8gdGhpcy5vcHRpb25zLnZpZXdwb3J0LmNhbGwodGhpcywgdGhpcy4kZWxlbWVudCkgOiAodGhpcy5vcHRpb25zLnZpZXdwb3J0LnNlbGVjdG9yIHx8IHRoaXMub3B0aW9ucy52aWV3cG9ydCkpXG4gICAgdGhpcy5pblN0YXRlICAgPSB7IGNsaWNrOiBmYWxzZSwgaG92ZXI6IGZhbHNlLCBmb2N1czogZmFsc2UgfVxuXG4gICAgaWYgKHRoaXMuJGVsZW1lbnRbMF0gaW5zdGFuY2VvZiBkb2N1bWVudC5jb25zdHJ1Y3RvciAmJiAhdGhpcy5vcHRpb25zLnNlbGVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BzZWxlY3RvcmAgb3B0aW9uIG11c3QgYmUgc3BlY2lmaWVkIHdoZW4gaW5pdGlhbGl6aW5nICcgKyB0aGlzLnR5cGUgKyAnIG9uIHRoZSB3aW5kb3cuZG9jdW1lbnQgb2JqZWN0IScpXG4gICAgfVxuXG4gICAgdmFyIHRyaWdnZXJzID0gdGhpcy5vcHRpb25zLnRyaWdnZXIuc3BsaXQoJyAnKVxuXG4gICAgZm9yICh2YXIgaSA9IHRyaWdnZXJzLmxlbmd0aDsgaS0tOykge1xuICAgICAgdmFyIHRyaWdnZXIgPSB0cmlnZ2Vyc1tpXVxuXG4gICAgICBpZiAodHJpZ2dlciA9PSAnY2xpY2snKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2NsaWNrLicgKyB0aGlzLnR5cGUsIHRoaXMub3B0aW9ucy5zZWxlY3RvciwgJC5wcm94eSh0aGlzLnRvZ2dsZSwgdGhpcykpXG4gICAgICB9IGVsc2UgaWYgKHRyaWdnZXIgIT0gJ21hbnVhbCcpIHtcbiAgICAgICAgdmFyIGV2ZW50SW4gID0gdHJpZ2dlciA9PSAnaG92ZXInID8gJ21vdXNlZW50ZXInIDogJ2ZvY3VzaW4nXG4gICAgICAgIHZhciBldmVudE91dCA9IHRyaWdnZXIgPT0gJ2hvdmVyJyA/ICdtb3VzZWxlYXZlJyA6ICdmb2N1c291dCdcblxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKGV2ZW50SW4gICsgJy4nICsgdGhpcy50eXBlLCB0aGlzLm9wdGlvbnMuc2VsZWN0b3IsICQucHJveHkodGhpcy5lbnRlciwgdGhpcykpXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oZXZlbnRPdXQgKyAnLicgKyB0aGlzLnR5cGUsIHRoaXMub3B0aW9ucy5zZWxlY3RvciwgJC5wcm94eSh0aGlzLmxlYXZlLCB0aGlzKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMuc2VsZWN0b3IgP1xuICAgICAgKHRoaXMuX29wdGlvbnMgPSAkLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCB7IHRyaWdnZXI6ICdtYW51YWwnLCBzZWxlY3RvcjogJycgfSkpIDpcbiAgICAgIHRoaXMuZml4VGl0bGUoKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZ2V0RGVmYXVsdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRvb2x0aXAuREVGQVVMVFNcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgdGhpcy5nZXREZWZhdWx0cygpLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucylcblxuICAgIGlmIChvcHRpb25zLmRlbGF5ICYmIHR5cGVvZiBvcHRpb25zLmRlbGF5ID09ICdudW1iZXInKSB7XG4gICAgICBvcHRpb25zLmRlbGF5ID0ge1xuICAgICAgICBzaG93OiBvcHRpb25zLmRlbGF5LFxuICAgICAgICBoaWRlOiBvcHRpb25zLmRlbGF5XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldERlbGVnYXRlT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyAgPSB7fVxuICAgIHZhciBkZWZhdWx0cyA9IHRoaXMuZ2V0RGVmYXVsdHMoKVxuXG4gICAgdGhpcy5fb3B0aW9ucyAmJiAkLmVhY2godGhpcy5fb3B0aW9ucywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChkZWZhdWx0c1trZXldICE9IHZhbHVlKSBvcHRpb25zW2tleV0gPSB2YWx1ZVxuICAgIH0pXG5cbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHNlbGYgPSBvYmogaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yID9cbiAgICAgIG9iaiA6ICQob2JqLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUpXG5cbiAgICBpZiAoIXNlbGYpIHtcbiAgICAgIHNlbGYgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihvYmouY3VycmVudFRhcmdldCwgdGhpcy5nZXREZWxlZ2F0ZU9wdGlvbnMoKSlcbiAgICAgICQob2JqLmN1cnJlbnRUYXJnZXQpLmRhdGEoJ2JzLicgKyB0aGlzLnR5cGUsIHNlbGYpXG4gICAgfVxuXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mICQuRXZlbnQpIHtcbiAgICAgIHNlbGYuaW5TdGF0ZVtvYmoudHlwZSA9PSAnZm9jdXNpbicgPyAnZm9jdXMnIDogJ2hvdmVyJ10gPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHNlbGYudGlwKCkuaGFzQ2xhc3MoJ2luJykgfHwgc2VsZi5ob3ZlclN0YXRlID09ICdpbicpIHtcbiAgICAgIHNlbGYuaG92ZXJTdGF0ZSA9ICdpbidcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNsZWFyVGltZW91dChzZWxmLnRpbWVvdXQpXG5cbiAgICBzZWxmLmhvdmVyU3RhdGUgPSAnaW4nXG5cbiAgICBpZiAoIXNlbGYub3B0aW9ucy5kZWxheSB8fCAhc2VsZi5vcHRpb25zLmRlbGF5LnNob3cpIHJldHVybiBzZWxmLnNob3coKVxuXG4gICAgc2VsZi50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5ob3ZlclN0YXRlID09ICdpbicpIHNlbGYuc2hvdygpXG4gICAgfSwgc2VsZi5vcHRpb25zLmRlbGF5LnNob3cpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5pc0luU3RhdGVUcnVlID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmluU3RhdGUpIHtcbiAgICAgIGlmICh0aGlzLmluU3RhdGVba2V5XSkgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBzZWxmID0gb2JqIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvciA/XG4gICAgICBvYmogOiAkKG9iai5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlKVxuXG4gICAgaWYgKCFzZWxmKSB7XG4gICAgICBzZWxmID0gbmV3IHRoaXMuY29uc3RydWN0b3Iob2JqLmN1cnJlbnRUYXJnZXQsIHRoaXMuZ2V0RGVsZWdhdGVPcHRpb25zKCkpXG4gICAgICAkKG9iai5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlLCBzZWxmKVxuICAgIH1cblxuICAgIGlmIChvYmogaW5zdGFuY2VvZiAkLkV2ZW50KSB7XG4gICAgICBzZWxmLmluU3RhdGVbb2JqLnR5cGUgPT0gJ2ZvY3Vzb3V0JyA/ICdmb2N1cycgOiAnaG92ZXInXSA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHNlbGYuaXNJblN0YXRlVHJ1ZSgpKSByZXR1cm5cblxuICAgIGNsZWFyVGltZW91dChzZWxmLnRpbWVvdXQpXG5cbiAgICBzZWxmLmhvdmVyU3RhdGUgPSAnb3V0J1xuXG4gICAgaWYgKCFzZWxmLm9wdGlvbnMuZGVsYXkgfHwgIXNlbGYub3B0aW9ucy5kZWxheS5oaWRlKSByZXR1cm4gc2VsZi5oaWRlKClcblxuICAgIHNlbGYudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuaG92ZXJTdGF0ZSA9PSAnb3V0Jykgc2VsZi5oaWRlKClcbiAgICB9LCBzZWxmLm9wdGlvbnMuZGVsYXkuaGlkZSlcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGUgPSAkLkV2ZW50KCdzaG93LmJzLicgKyB0aGlzLnR5cGUpXG5cbiAgICBpZiAodGhpcy5oYXNDb250ZW50KCkgJiYgdGhpcy5lbmFibGVkKSB7XG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcblxuICAgICAgdmFyIGluRG9tID0gJC5jb250YWlucyh0aGlzLiRlbGVtZW50WzBdLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLiRlbGVtZW50WzBdKVxuICAgICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgIWluRG9tKSByZXR1cm5cbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuXG4gICAgICB2YXIgJHRpcCA9IHRoaXMudGlwKClcblxuICAgICAgdmFyIHRpcElkID0gdGhpcy5nZXRVSUQodGhpcy50eXBlKVxuXG4gICAgICB0aGlzLnNldENvbnRlbnQoKVxuICAgICAgJHRpcC5hdHRyKCdpZCcsIHRpcElkKVxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWRlc2NyaWJlZGJ5JywgdGlwSWQpXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKSAkdGlwLmFkZENsYXNzKCdmYWRlJylcblxuICAgICAgdmFyIHBsYWNlbWVudCA9IHR5cGVvZiB0aGlzLm9wdGlvbnMucGxhY2VtZW50ID09ICdmdW5jdGlvbicgP1xuICAgICAgICB0aGlzLm9wdGlvbnMucGxhY2VtZW50LmNhbGwodGhpcywgJHRpcFswXSwgdGhpcy4kZWxlbWVudFswXSkgOlxuICAgICAgICB0aGlzLm9wdGlvbnMucGxhY2VtZW50XG5cbiAgICAgIHZhciBhdXRvVG9rZW4gPSAvXFxzP2F1dG8/XFxzPy9pXG4gICAgICB2YXIgYXV0b1BsYWNlID0gYXV0b1Rva2VuLnRlc3QocGxhY2VtZW50KVxuICAgICAgaWYgKGF1dG9QbGFjZSkgcGxhY2VtZW50ID0gcGxhY2VtZW50LnJlcGxhY2UoYXV0b1Rva2VuLCAnJykgfHwgJ3RvcCdcblxuICAgICAgJHRpcFxuICAgICAgICAuZGV0YWNoKClcbiAgICAgICAgLmNzcyh7IHRvcDogMCwgbGVmdDogMCwgZGlzcGxheTogJ2Jsb2NrJyB9KVxuICAgICAgICAuYWRkQ2xhc3MocGxhY2VtZW50KVxuICAgICAgICAuZGF0YSgnYnMuJyArIHRoaXMudHlwZSwgdGhpcylcblxuICAgICAgdGhpcy5vcHRpb25zLmNvbnRhaW5lciA/ICR0aXAuYXBwZW5kVG8odGhpcy5vcHRpb25zLmNvbnRhaW5lcikgOiAkdGlwLmluc2VydEFmdGVyKHRoaXMuJGVsZW1lbnQpXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2luc2VydGVkLmJzLicgKyB0aGlzLnR5cGUpXG5cbiAgICAgIHZhciBwb3MgICAgICAgICAgPSB0aGlzLmdldFBvc2l0aW9uKClcbiAgICAgIHZhciBhY3R1YWxXaWR0aCAgPSAkdGlwWzBdLm9mZnNldFdpZHRoXG4gICAgICB2YXIgYWN0dWFsSGVpZ2h0ID0gJHRpcFswXS5vZmZzZXRIZWlnaHRcblxuICAgICAgaWYgKGF1dG9QbGFjZSkge1xuICAgICAgICB2YXIgb3JnUGxhY2VtZW50ID0gcGxhY2VtZW50XG4gICAgICAgIHZhciB2aWV3cG9ydERpbSA9IHRoaXMuZ2V0UG9zaXRpb24odGhpcy4kdmlld3BvcnQpXG5cbiAgICAgICAgcGxhY2VtZW50ID0gcGxhY2VtZW50ID09ICdib3R0b20nICYmIHBvcy5ib3R0b20gKyBhY3R1YWxIZWlnaHQgPiB2aWV3cG9ydERpbS5ib3R0b20gPyAndG9wJyAgICA6XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9PSAndG9wJyAgICAmJiBwb3MudG9wICAgIC0gYWN0dWFsSGVpZ2h0IDwgdmlld3BvcnREaW0udG9wICAgID8gJ2JvdHRvbScgOlxuICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPT0gJ3JpZ2h0JyAgJiYgcG9zLnJpZ2h0ICArIGFjdHVhbFdpZHRoICA+IHZpZXdwb3J0RGltLndpZHRoICA/ICdsZWZ0JyAgIDpcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID09ICdsZWZ0JyAgICYmIHBvcy5sZWZ0ICAgLSBhY3R1YWxXaWR0aCAgPCB2aWV3cG9ydERpbS5sZWZ0ICAgPyAncmlnaHQnICA6XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudFxuXG4gICAgICAgICR0aXBcbiAgICAgICAgICAucmVtb3ZlQ2xhc3Mob3JnUGxhY2VtZW50KVxuICAgICAgICAgIC5hZGRDbGFzcyhwbGFjZW1lbnQpXG4gICAgICB9XG5cbiAgICAgIHZhciBjYWxjdWxhdGVkT2Zmc2V0ID0gdGhpcy5nZXRDYWxjdWxhdGVkT2Zmc2V0KHBsYWNlbWVudCwgcG9zLCBhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0KVxuXG4gICAgICB0aGlzLmFwcGx5UGxhY2VtZW50KGNhbGN1bGF0ZWRPZmZzZXQsIHBsYWNlbWVudClcblxuICAgICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJldkhvdmVyU3RhdGUgPSB0aGF0LmhvdmVyU3RhdGVcbiAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdzaG93bi5icy4nICsgdGhhdC50eXBlKVxuICAgICAgICB0aGF0LmhvdmVyU3RhdGUgPSBudWxsXG5cbiAgICAgICAgaWYgKHByZXZIb3ZlclN0YXRlID09ICdvdXQnKSB0aGF0LmxlYXZlKHRoYXQpXG4gICAgICB9XG5cbiAgICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJHRpcC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgICAgJHRpcFxuICAgICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGNvbXBsZXRlKVxuICAgICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChUb29sdGlwLlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgICAgY29tcGxldGUoKVxuICAgIH1cbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmFwcGx5UGxhY2VtZW50ID0gZnVuY3Rpb24gKG9mZnNldCwgcGxhY2VtZW50KSB7XG4gICAgdmFyICR0aXAgICA9IHRoaXMudGlwKClcbiAgICB2YXIgd2lkdGggID0gJHRpcFswXS5vZmZzZXRXaWR0aFxuICAgIHZhciBoZWlnaHQgPSAkdGlwWzBdLm9mZnNldEhlaWdodFxuXG4gICAgLy8gbWFudWFsbHkgcmVhZCBtYXJnaW5zIGJlY2F1c2UgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGluY2x1ZGVzIGRpZmZlcmVuY2VcbiAgICB2YXIgbWFyZ2luVG9wID0gcGFyc2VJbnQoJHRpcC5jc3MoJ21hcmdpbi10b3AnKSwgMTApXG4gICAgdmFyIG1hcmdpbkxlZnQgPSBwYXJzZUludCgkdGlwLmNzcygnbWFyZ2luLWxlZnQnKSwgMTApXG5cbiAgICAvLyB3ZSBtdXN0IGNoZWNrIGZvciBOYU4gZm9yIGllIDgvOVxuICAgIGlmIChpc05hTihtYXJnaW5Ub3ApKSAgbWFyZ2luVG9wICA9IDBcbiAgICBpZiAoaXNOYU4obWFyZ2luTGVmdCkpIG1hcmdpbkxlZnQgPSAwXG5cbiAgICBvZmZzZXQudG9wICArPSBtYXJnaW5Ub3BcbiAgICBvZmZzZXQubGVmdCArPSBtYXJnaW5MZWZ0XG5cbiAgICAvLyAkLmZuLm9mZnNldCBkb2Vzbid0IHJvdW5kIHBpeGVsIHZhbHVlc1xuICAgIC8vIHNvIHdlIHVzZSBzZXRPZmZzZXQgZGlyZWN0bHkgd2l0aCBvdXIgb3duIGZ1bmN0aW9uIEItMFxuICAgICQub2Zmc2V0LnNldE9mZnNldCgkdGlwWzBdLCAkLmV4dGVuZCh7XG4gICAgICB1c2luZzogZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICR0aXAuY3NzKHtcbiAgICAgICAgICB0b3A6IE1hdGgucm91bmQocHJvcHMudG9wKSxcbiAgICAgICAgICBsZWZ0OiBNYXRoLnJvdW5kKHByb3BzLmxlZnQpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSwgb2Zmc2V0KSwgMClcblxuICAgICR0aXAuYWRkQ2xhc3MoJ2luJylcblxuICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBwbGFjaW5nIHRpcCBpbiBuZXcgb2Zmc2V0IGNhdXNlZCB0aGUgdGlwIHRvIHJlc2l6ZSBpdHNlbGZcbiAgICB2YXIgYWN0dWFsV2lkdGggID0gJHRpcFswXS5vZmZzZXRXaWR0aFxuICAgIHZhciBhY3R1YWxIZWlnaHQgPSAkdGlwWzBdLm9mZnNldEhlaWdodFxuXG4gICAgaWYgKHBsYWNlbWVudCA9PSAndG9wJyAmJiBhY3R1YWxIZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICBvZmZzZXQudG9wID0gb2Zmc2V0LnRvcCArIGhlaWdodCAtIGFjdHVhbEhlaWdodFxuICAgIH1cblxuICAgIHZhciBkZWx0YSA9IHRoaXMuZ2V0Vmlld3BvcnRBZGp1c3RlZERlbHRhKHBsYWNlbWVudCwgb2Zmc2V0LCBhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0KVxuXG4gICAgaWYgKGRlbHRhLmxlZnQpIG9mZnNldC5sZWZ0ICs9IGRlbHRhLmxlZnRcbiAgICBlbHNlIG9mZnNldC50b3AgKz0gZGVsdGEudG9wXG5cbiAgICB2YXIgaXNWZXJ0aWNhbCAgICAgICAgICA9IC90b3B8Ym90dG9tLy50ZXN0KHBsYWNlbWVudClcbiAgICB2YXIgYXJyb3dEZWx0YSAgICAgICAgICA9IGlzVmVydGljYWwgPyBkZWx0YS5sZWZ0ICogMiAtIHdpZHRoICsgYWN0dWFsV2lkdGggOiBkZWx0YS50b3AgKiAyIC0gaGVpZ2h0ICsgYWN0dWFsSGVpZ2h0XG4gICAgdmFyIGFycm93T2Zmc2V0UG9zaXRpb24gPSBpc1ZlcnRpY2FsID8gJ29mZnNldFdpZHRoJyA6ICdvZmZzZXRIZWlnaHQnXG5cbiAgICAkdGlwLm9mZnNldChvZmZzZXQpXG4gICAgdGhpcy5yZXBsYWNlQXJyb3coYXJyb3dEZWx0YSwgJHRpcFswXVthcnJvd09mZnNldFBvc2l0aW9uXSwgaXNWZXJ0aWNhbClcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnJlcGxhY2VBcnJvdyA9IGZ1bmN0aW9uIChkZWx0YSwgZGltZW5zaW9uLCBpc1ZlcnRpY2FsKSB7XG4gICAgdGhpcy5hcnJvdygpXG4gICAgICAuY3NzKGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJywgNTAgKiAoMSAtIGRlbHRhIC8gZGltZW5zaW9uKSArICclJylcbiAgICAgIC5jc3MoaXNWZXJ0aWNhbCA/ICd0b3AnIDogJ2xlZnQnLCAnJylcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyICR0aXAgID0gdGhpcy50aXAoKVxuICAgIHZhciB0aXRsZSA9IHRoaXMuZ2V0VGl0bGUoKVxuXG4gICAgJHRpcC5maW5kKCcudG9vbHRpcC1pbm5lcicpW3RoaXMub3B0aW9ucy5odG1sID8gJ2h0bWwnIDogJ3RleHQnXSh0aXRsZSlcbiAgICAkdGlwLnJlbW92ZUNsYXNzKCdmYWRlIGluIHRvcCBib3R0b20gbGVmdCByaWdodCcpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgdmFyICR0aXAgPSAkKHRoaXMuJHRpcClcbiAgICB2YXIgZSAgICA9ICQuRXZlbnQoJ2hpZGUuYnMuJyArIHRoaXMudHlwZSlcblxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgaWYgKHRoYXQuaG92ZXJTdGF0ZSAhPSAnaW4nKSAkdGlwLmRldGFjaCgpXG4gICAgICB0aGF0LiRlbGVtZW50XG4gICAgICAgIC5yZW1vdmVBdHRyKCdhcmlhLWRlc2NyaWJlZGJ5JylcbiAgICAgICAgLnRyaWdnZXIoJ2hpZGRlbi5icy4nICsgdGhhdC50eXBlKVxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgIH1cblxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihlKVxuXG4gICAgaWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHJldHVyblxuXG4gICAgJHRpcC5yZW1vdmVDbGFzcygnaW4nKVxuXG4gICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgJHRpcC5oYXNDbGFzcygnZmFkZScpID9cbiAgICAgICR0aXBcbiAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY29tcGxldGUpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChUb29sdGlwLlRSQU5TSVRJT05fRFVSQVRJT04pIDpcbiAgICAgIGNvbXBsZXRlKClcblxuICAgIHRoaXMuaG92ZXJTdGF0ZSA9IG51bGxcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5maXhUaXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJGUgPSB0aGlzLiRlbGVtZW50XG4gICAgaWYgKCRlLmF0dHIoJ3RpdGxlJykgfHwgdHlwZW9mICRlLmF0dHIoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnKSAhPSAnc3RyaW5nJykge1xuICAgICAgJGUuYXR0cignZGF0YS1vcmlnaW5hbC10aXRsZScsICRlLmF0dHIoJ3RpdGxlJykgfHwgJycpLmF0dHIoJ3RpdGxlJywgJycpXG4gICAgfVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuaGFzQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaXRsZSgpXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgkZWxlbWVudCkge1xuICAgICRlbGVtZW50ICAgPSAkZWxlbWVudCB8fCB0aGlzLiRlbGVtZW50XG5cbiAgICB2YXIgZWwgICAgID0gJGVsZW1lbnRbMF1cbiAgICB2YXIgaXNCb2R5ID0gZWwudGFnTmFtZSA9PSAnQk9EWSdcblxuICAgIHZhciBlbFJlY3QgICAgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGlmIChlbFJlY3Qud2lkdGggPT0gbnVsbCkge1xuICAgICAgLy8gd2lkdGggYW5kIGhlaWdodCBhcmUgbWlzc2luZyBpbiBJRTgsIHNvIGNvbXB1dGUgdGhlbSBtYW51YWxseTsgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9pc3N1ZXMvMTQwOTNcbiAgICAgIGVsUmVjdCA9ICQuZXh0ZW5kKHt9LCBlbFJlY3QsIHsgd2lkdGg6IGVsUmVjdC5yaWdodCAtIGVsUmVjdC5sZWZ0LCBoZWlnaHQ6IGVsUmVjdC5ib3R0b20gLSBlbFJlY3QudG9wIH0pXG4gICAgfVxuICAgIHZhciBlbE9mZnNldCAgPSBpc0JvZHkgPyB7IHRvcDogMCwgbGVmdDogMCB9IDogJGVsZW1lbnQub2Zmc2V0KClcbiAgICB2YXIgc2Nyb2xsICAgID0geyBzY3JvbGw6IGlzQm9keSA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgOiAkZWxlbWVudC5zY3JvbGxUb3AoKSB9XG4gICAgdmFyIG91dGVyRGltcyA9IGlzQm9keSA/IHsgd2lkdGg6ICQod2luZG93KS53aWR0aCgpLCBoZWlnaHQ6ICQod2luZG93KS5oZWlnaHQoKSB9IDogbnVsbFxuXG4gICAgcmV0dXJuICQuZXh0ZW5kKHt9LCBlbFJlY3QsIHNjcm9sbCwgb3V0ZXJEaW1zLCBlbE9mZnNldClcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldENhbGN1bGF0ZWRPZmZzZXQgPSBmdW5jdGlvbiAocGxhY2VtZW50LCBwb3MsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50ID09ICdib3R0b20nID8geyB0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0LCAgIGxlZnQ6IHBvcy5sZWZ0ICsgcG9zLndpZHRoIC8gMiAtIGFjdHVhbFdpZHRoIC8gMiB9IDpcbiAgICAgICAgICAgcGxhY2VtZW50ID09ICd0b3AnICAgID8geyB0b3A6IHBvcy50b3AgLSBhY3R1YWxIZWlnaHQsIGxlZnQ6IHBvcy5sZWZ0ICsgcG9zLndpZHRoIC8gMiAtIGFjdHVhbFdpZHRoIC8gMiB9IDpcbiAgICAgICAgICAgcGxhY2VtZW50ID09ICdsZWZ0JyAgID8geyB0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0IC8gMiAtIGFjdHVhbEhlaWdodCAvIDIsIGxlZnQ6IHBvcy5sZWZ0IC0gYWN0dWFsV2lkdGggfSA6XG4gICAgICAgIC8qIHBsYWNlbWVudCA9PSAncmlnaHQnICovIHsgdG9wOiBwb3MudG9wICsgcG9zLmhlaWdodCAvIDIgLSBhY3R1YWxIZWlnaHQgLyAyLCBsZWZ0OiBwb3MubGVmdCArIHBvcy53aWR0aCB9XG5cbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldFZpZXdwb3J0QWRqdXN0ZWREZWx0YSA9IGZ1bmN0aW9uIChwbGFjZW1lbnQsIHBvcywgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodCkge1xuICAgIHZhciBkZWx0YSA9IHsgdG9wOiAwLCBsZWZ0OiAwIH1cbiAgICBpZiAoIXRoaXMuJHZpZXdwb3J0KSByZXR1cm4gZGVsdGFcblxuICAgIHZhciB2aWV3cG9ydFBhZGRpbmcgPSB0aGlzLm9wdGlvbnMudmlld3BvcnQgJiYgdGhpcy5vcHRpb25zLnZpZXdwb3J0LnBhZGRpbmcgfHwgMFxuICAgIHZhciB2aWV3cG9ydERpbWVuc2lvbnMgPSB0aGlzLmdldFBvc2l0aW9uKHRoaXMuJHZpZXdwb3J0KVxuXG4gICAgaWYgKC9yaWdodHxsZWZ0Ly50ZXN0KHBsYWNlbWVudCkpIHtcbiAgICAgIHZhciB0b3BFZGdlT2Zmc2V0ICAgID0gcG9zLnRvcCAtIHZpZXdwb3J0UGFkZGluZyAtIHZpZXdwb3J0RGltZW5zaW9ucy5zY3JvbGxcbiAgICAgIHZhciBib3R0b21FZGdlT2Zmc2V0ID0gcG9zLnRvcCArIHZpZXdwb3J0UGFkZGluZyAtIHZpZXdwb3J0RGltZW5zaW9ucy5zY3JvbGwgKyBhY3R1YWxIZWlnaHRcbiAgICAgIGlmICh0b3BFZGdlT2Zmc2V0IDwgdmlld3BvcnREaW1lbnNpb25zLnRvcCkgeyAvLyB0b3Agb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEudG9wID0gdmlld3BvcnREaW1lbnNpb25zLnRvcCAtIHRvcEVkZ2VPZmZzZXRcbiAgICAgIH0gZWxzZSBpZiAoYm90dG9tRWRnZU9mZnNldCA+IHZpZXdwb3J0RGltZW5zaW9ucy50b3AgKyB2aWV3cG9ydERpbWVuc2lvbnMuaGVpZ2h0KSB7IC8vIGJvdHRvbSBvdmVyZmxvd1xuICAgICAgICBkZWx0YS50b3AgPSB2aWV3cG9ydERpbWVuc2lvbnMudG9wICsgdmlld3BvcnREaW1lbnNpb25zLmhlaWdodCAtIGJvdHRvbUVkZ2VPZmZzZXRcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxlZnRFZGdlT2Zmc2V0ICA9IHBvcy5sZWZ0IC0gdmlld3BvcnRQYWRkaW5nXG4gICAgICB2YXIgcmlnaHRFZGdlT2Zmc2V0ID0gcG9zLmxlZnQgKyB2aWV3cG9ydFBhZGRpbmcgKyBhY3R1YWxXaWR0aFxuICAgICAgaWYgKGxlZnRFZGdlT2Zmc2V0IDwgdmlld3BvcnREaW1lbnNpb25zLmxlZnQpIHsgLy8gbGVmdCBvdmVyZmxvd1xuICAgICAgICBkZWx0YS5sZWZ0ID0gdmlld3BvcnREaW1lbnNpb25zLmxlZnQgLSBsZWZ0RWRnZU9mZnNldFxuICAgICAgfSBlbHNlIGlmIChyaWdodEVkZ2VPZmZzZXQgPiB2aWV3cG9ydERpbWVuc2lvbnMucmlnaHQpIHsgLy8gcmlnaHQgb3ZlcmZsb3dcbiAgICAgICAgZGVsdGEubGVmdCA9IHZpZXdwb3J0RGltZW5zaW9ucy5sZWZ0ICsgdmlld3BvcnREaW1lbnNpb25zLndpZHRoIC0gcmlnaHRFZGdlT2Zmc2V0XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbHRhXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGl0bGVcbiAgICB2YXIgJGUgPSB0aGlzLiRlbGVtZW50XG4gICAgdmFyIG8gID0gdGhpcy5vcHRpb25zXG5cbiAgICB0aXRsZSA9ICRlLmF0dHIoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnKVxuICAgICAgfHwgKHR5cGVvZiBvLnRpdGxlID09ICdmdW5jdGlvbicgPyBvLnRpdGxlLmNhbGwoJGVbMF0pIDogIG8udGl0bGUpXG5cbiAgICByZXR1cm4gdGl0bGVcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmdldFVJRCA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBkbyBwcmVmaXggKz0gfn4oTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApXG4gICAgd2hpbGUgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHByZWZpeCkpXG4gICAgcmV0dXJuIHByZWZpeFxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUudGlwID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy4kdGlwKSB7XG4gICAgICB0aGlzLiR0aXAgPSAkKHRoaXMub3B0aW9ucy50ZW1wbGF0ZSlcbiAgICAgIGlmICh0aGlzLiR0aXAubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMudHlwZSArICcgYHRlbXBsYXRlYCBvcHRpb24gbXVzdCBjb25zaXN0IG9mIGV4YWN0bHkgMSB0b3AtbGV2ZWwgZWxlbWVudCEnKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy4kdGlwXG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5hcnJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMuJGFycm93ID0gdGhpcy4kYXJyb3cgfHwgdGhpcy50aXAoKS5maW5kKCcudG9vbHRpcC1hcnJvdycpKVxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWVcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2VcbiAgfVxuXG4gIFRvb2x0aXAucHJvdG90eXBlLnRvZ2dsZUVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gIXRoaXMuZW5hYmxlZFxuICB9XG5cbiAgVG9vbHRpcC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICBpZiAoZSkge1xuICAgICAgc2VsZiA9ICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlKVxuICAgICAgaWYgKCFzZWxmKSB7XG4gICAgICAgIHNlbGYgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihlLmN1cnJlbnRUYXJnZXQsIHRoaXMuZ2V0RGVsZWdhdGVPcHRpb25zKCkpXG4gICAgICAgICQoZS5jdXJyZW50VGFyZ2V0KS5kYXRhKCdicy4nICsgdGhpcy50eXBlLCBzZWxmKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlKSB7XG4gICAgICBzZWxmLmluU3RhdGUuY2xpY2sgPSAhc2VsZi5pblN0YXRlLmNsaWNrXG4gICAgICBpZiAoc2VsZi5pc0luU3RhdGVUcnVlKCkpIHNlbGYuZW50ZXIoc2VsZilcbiAgICAgIGVsc2Ugc2VsZi5sZWF2ZShzZWxmKVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnRpcCgpLmhhc0NsYXNzKCdpbicpID8gc2VsZi5sZWF2ZShzZWxmKSA6IHNlbGYuZW50ZXIoc2VsZilcbiAgICB9XG4gIH1cblxuICBUb29sdGlwLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpXG4gICAgdGhpcy5oaWRlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQuJGVsZW1lbnQub2ZmKCcuJyArIHRoYXQudHlwZSkucmVtb3ZlRGF0YSgnYnMuJyArIHRoYXQudHlwZSlcbiAgICAgIGlmICh0aGF0LiR0aXApIHtcbiAgICAgICAgdGhhdC4kdGlwLmRldGFjaCgpXG4gICAgICB9XG4gICAgICB0aGF0LiR0aXAgPSBudWxsXG4gICAgICB0aGF0LiRhcnJvdyA9IG51bGxcbiAgICAgIHRoYXQuJHZpZXdwb3J0ID0gbnVsbFxuICAgIH0pXG4gIH1cblxuXG4gIC8vIFRPT0xUSVAgUExVR0lOIERFRklOSVRJT05cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIFBsdWdpbihvcHRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy50b29sdGlwJylcbiAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb25cblxuICAgICAgaWYgKCFkYXRhICYmIC9kZXN0cm95fGhpZGUvLnRlc3Qob3B0aW9uKSkgcmV0dXJuXG4gICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ2JzLnRvb2x0aXAnLCAoZGF0YSA9IG5ldyBUb29sdGlwKHRoaXMsIG9wdGlvbnMpKSlcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKVxuICAgIH0pXG4gIH1cblxuICB2YXIgb2xkID0gJC5mbi50b29sdGlwXG5cbiAgJC5mbi50b29sdGlwICAgICAgICAgICAgID0gUGx1Z2luXG4gICQuZm4udG9vbHRpcC5Db25zdHJ1Y3RvciA9IFRvb2x0aXBcblxuXG4gIC8vIFRPT0xUSVAgTk8gQ09ORkxJQ1RcbiAgLy8gPT09PT09PT09PT09PT09PT09PVxuXG4gICQuZm4udG9vbHRpcC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICQuZm4udG9vbHRpcCA9IG9sZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxufShqUXVlcnkpO1xuIiwiLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCb290c3RyYXA6IHRyYW5zaXRpb24uanMgdjMuMy42XG4gKiBodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbS9qYXZhc2NyaXB0LyN0cmFuc2l0aW9uc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXG4rZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENTUyBUUkFOU0lUSU9OIFNVUFBPUlQgKFNob3V0b3V0OiBodHRwOi8vd3d3Lm1vZGVybml6ci5jb20vKVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Jvb3RzdHJhcCcpXG5cbiAgICB2YXIgdHJhbnNFbmRFdmVudE5hbWVzID0ge1xuICAgICAgV2Via2l0VHJhbnNpdGlvbiA6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAgIE1velRyYW5zaXRpb24gICAgOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgICBPVHJhbnNpdGlvbiAgICAgIDogJ29UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kJyxcbiAgICAgIHRyYW5zaXRpb24gICAgICAgOiAndHJhbnNpdGlvbmVuZCdcbiAgICB9XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHRyYW5zRW5kRXZlbnROYW1lcykge1xuICAgICAgaWYgKGVsLnN0eWxlW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHsgZW5kOiB0cmFuc0VuZEV2ZW50TmFtZXNbbmFtZV0gfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZSAvLyBleHBsaWNpdCBmb3IgaWU4ICggIC5fLilcbiAgfVxuXG4gIC8vIGh0dHA6Ly9ibG9nLmFsZXhtYWNjYXcuY29tL2Nzcy10cmFuc2l0aW9uc1xuICAkLmZuLmVtdWxhdGVUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlXG4gICAgdmFyICRlbCA9IHRoaXNcbiAgICAkKHRoaXMpLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgZnVuY3Rpb24gKCkgeyBjYWxsZWQgPSB0cnVlIH0pXG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkgeyBpZiAoIWNhbGxlZCkgJCgkZWwpLnRyaWdnZXIoJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kKSB9XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgZHVyYXRpb24pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gICQoZnVuY3Rpb24gKCkge1xuICAgICQuc3VwcG9ydC50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkVuZCgpXG5cbiAgICBpZiAoISQuc3VwcG9ydC50cmFuc2l0aW9uKSByZXR1cm5cblxuICAgICQuZXZlbnQuc3BlY2lhbC5ic1RyYW5zaXRpb25FbmQgPSB7XG4gICAgICBiaW5kVHlwZTogJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kLFxuICAgICAgZGVsZWdhdGVUeXBlOiAkLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQsXG4gICAgICBoYW5kbGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICgkKGUudGFyZ2V0KS5pcyh0aGlzKSkgcmV0dXJuIGUuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxufShqUXVlcnkpO1xuIiwidmFyIGNyZWF0ZWpzID0gKHRoaXMuY3JlYXRlanMgPSAodGhpcy5jcmVhdGVqcyB8fCB7fSkpO1xuLyohXG4qIEVhc2VsSlNcbiogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgZ3NraW5uZXIuY29tLCBpbmMuXG4qXG4qIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4qIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4qIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4qIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4qIGNvbmRpdGlvbnM6XG4qXG4qIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4qIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuKlxuKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4qIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4qIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIGV4dGVuZC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuXG4vKipcbiAqIFNldHMgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiBhbmQgY29uc3RydWN0b3IgcHJvcGVydHkgZm9yIGEgbmV3IGNsYXNzLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCByaWdodCBhZnRlciBjcmVhdGluZyB0aGUgY2xhc3MgY29uc3RydWN0b3IuXG4gKlxuICogXHRmdW5jdGlvbiBNeVN1YkNsYXNzKCkge31cbiAqIFx0Y3JlYXRlanMuZXh0ZW5kKE15U3ViQ2xhc3MsIE15U3VwZXJDbGFzcyk7XG4gKiBcdENsYXNzQi5wcm90b3R5cGUuZG9Tb21ldGhpbmcgPSBmdW5jdGlvbigpIHsgfVxuICpcbiAqIFx0dmFyIGZvbyA9IG5ldyBNeVN1YkNsYXNzKCk7XG4gKiBcdGNvbnNvbGUubG9nKGZvbyBpbnN0YW5jZW9mIE15U3VwZXJDbGFzcyk7IC8vIHRydWVcbiAqIFx0Y29uc29sZS5sb2coZm9vLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9PT0gTXlTdWJDbGFzcyk7IC8vIHRydWVcbiAqXG4gKiBAbWV0aG9kIGV4dGVuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ViY2xhc3MgVGhlIHN1YmNsYXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJjbGFzcyBUaGUgc3VwZXJjbGFzcyB0byBleHRlbmQuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgc3ViY2xhc3MncyBuZXcgcHJvdG90eXBlLlxuICovXG5jcmVhdGVqcy5leHRlbmQgPSBmdW5jdGlvbihzdWJjbGFzcywgc3VwZXJjbGFzcykge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRmdW5jdGlvbiBvKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gc3ViY2xhc3M7IH1cblx0by5wcm90b3R5cGUgPSBzdXBlcmNsYXNzLnByb3RvdHlwZTtcblx0cmV0dXJuIChzdWJjbGFzcy5wcm90b3R5cGUgPSBuZXcgbygpKTtcbn07XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBwcm9tb3RlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbi8qKlxuICogUHJvbW90ZXMgYW55IG1ldGhvZHMgb24gdGhlIHN1cGVyIGNsYXNzIHRoYXQgd2VyZSBvdmVycmlkZGVuLCBieSBjcmVhdGluZyBhbiBhbGlhcyBpbiB0aGUgZm9ybWF0IGBwcmVmaXhfbWV0aG9kTmFtZWAuXG4gKiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgdGhlIHN1cGVyIGNsYXNzJ3MgbmFtZSBhcyB0aGUgcHJlZml4LlxuICogQW4gYWxpYXMgdG8gdGhlIHN1cGVyIGNsYXNzJ3MgY29uc3RydWN0b3IgaXMgYWx3YXlzIGFkZGVkIGluIHRoZSBmb3JtYXQgYHByZWZpeF9jb25zdHJ1Y3RvcmAuXG4gKiBUaGlzIGFsbG93cyB0aGUgc3ViY2xhc3MgdG8gY2FsbCBzdXBlciBjbGFzcyBtZXRob2RzIHdpdGhvdXQgdXNpbmcgYGZ1bmN0aW9uLmNhbGxgLCBwcm92aWRpbmcgYmV0dGVyIHBlcmZvcm1hbmNlLlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiBgTXlTdWJDbGFzc2AgZXh0ZW5kcyBgTXlTdXBlckNsYXNzYCwgYW5kIGJvdGggZGVmaW5lIGEgYGRyYXdgIG1ldGhvZCwgdGhlbiBjYWxsaW5nIGBwcm9tb3RlKE15U3ViQ2xhc3MsIFwiTXlTdXBlckNsYXNzXCIpYFxuICogd291bGQgYWRkIGEgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAgbWV0aG9kIHRvIE15U3ViQ2xhc3MgYW5kIHByb21vdGUgdGhlIGBkcmF3YCBtZXRob2Qgb24gYE15U3VwZXJDbGFzc2AgdG8gdGhlXG4gKiBwcm90b3R5cGUgb2YgYE15U3ViQ2xhc3NgIGFzIGBNeVN1cGVyQ2xhc3NfZHJhd2AuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoZSBjbGFzcydzIHByb3RvdHlwZSBpcyBmdWxseSBkZWZpbmVkLlxuICpcbiAqIFx0ZnVuY3Rpb24gQ2xhc3NBKG5hbWUpIHtcbiAqIFx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuICogXHR9XG4gKiBcdENsYXNzQS5wcm90b3R5cGUuZ3JlZXQgPSBmdW5jdGlvbigpIHtcbiAqIFx0XHRyZXR1cm4gXCJIZWxsbyBcIit0aGlzLm5hbWU7XG4gKiBcdH1cbiAqXG4gKiBcdGZ1bmN0aW9uIENsYXNzQihuYW1lLCBwdW5jdHVhdGlvbikge1xuICogXHRcdHRoaXMuQ2xhc3NBX2NvbnN0cnVjdG9yKG5hbWUpO1xuICogXHRcdHRoaXMucHVuY3R1YXRpb24gPSBwdW5jdHVhdGlvbjtcbiAqIFx0fVxuICogXHRjcmVhdGVqcy5leHRlbmQoQ2xhc3NCLCBDbGFzc0EpO1xuICogXHRDbGFzc0IucHJvdG90eXBlLmdyZWV0ID0gZnVuY3Rpb24oKSB7XG4gKiBcdFx0cmV0dXJuIHRoaXMuQ2xhc3NBX2dyZWV0KCkrdGhpcy5wdW5jdHVhdGlvbjtcbiAqIFx0fVxuICogXHRjcmVhdGVqcy5wcm9tb3RlKENsYXNzQiwgXCJDbGFzc0FcIik7XG4gKlxuICogXHR2YXIgZm9vID0gbmV3IENsYXNzQihcIldvcmxkXCIsIFwiIT8hXCIpO1xuICogXHRjb25zb2xlLmxvZyhmb28uZ3JlZXQoKSk7IC8vIEhlbGxvIFdvcmxkIT8hXG4gKlxuICogQG1ldGhvZCBwcm9tb3RlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJjbGFzcyBUaGUgY2xhc3MgdG8gcHJvbW90ZSBzdXBlciBjbGFzcyBtZXRob2RzIG9uLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBUaGUgcHJlZml4IHRvIGFkZCB0byB0aGUgcHJvbW90ZWQgbWV0aG9kIG5hbWVzLiBVc3VhbGx5IHRoZSBuYW1lIG9mIHRoZSBzdXBlcmNsYXNzLlxuICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgdGhlIHN1YmNsYXNzLlxuICovXG5jcmVhdGVqcy5wcm9tb3RlID0gZnVuY3Rpb24oc3ViY2xhc3MsIHByZWZpeCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHR2YXIgc3ViUCA9IHN1YmNsYXNzLnByb3RvdHlwZSwgc3VwUCA9IChPYmplY3QuZ2V0UHJvdG90eXBlT2YmJk9iamVjdC5nZXRQcm90b3R5cGVPZihzdWJQKSl8fHN1YlAuX19wcm90b19fO1xuXHRpZiAoc3VwUCkge1xuXHRcdHN1YlBbKHByZWZpeCs9XCJfXCIpICsgXCJjb25zdHJ1Y3RvclwiXSA9IHN1cFAuY29uc3RydWN0b3I7IC8vIGNvbnN0cnVjdG9yIGlzIG5vdCBhbHdheXMgaW5udW1lcmFibGVcblx0XHRmb3IgKHZhciBuIGluIHN1cFApIHtcblx0XHRcdGlmIChzdWJQLmhhc093blByb3BlcnR5KG4pICYmICh0eXBlb2Ygc3VwUFtuXSA9PSBcImZ1bmN0aW9uXCIpKSB7IHN1YlBbcHJlZml4ICsgbl0gPSBzdXBQW25dOyB9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBzdWJjbGFzcztcbn07XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBpbmRleE9mLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBzcGVjaWZpZWQgdmFsdWUgc2VhcmNoRWxlbWVudCBpbiB0aGUgcGFzc2VkIGluIGFycmF5LCBhbmQgcmV0dXJucyB0aGUgaW5kZXggb2ZcbiAqIHRoYXQgdmFsdWUuICBSZXR1cm5zIC0xIGlmIHZhbHVlIGlzIG5vdCBmb3VuZC5cbiAqXG4gKiAgICAgIHZhciBpID0gY3JlYXRlanMuaW5kZXhPZihteUFycmF5LCBteUVsZW1lbnRUb0ZpbmQpO1xuICpcbiAqIEBtZXRob2QgaW5kZXhPZlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgQXJyYXkgdG8gc2VhcmNoIGZvciBzZWFyY2hFbGVtZW50XG4gKiBAcGFyYW0gc2VhcmNoRWxlbWVudCBFbGVtZW50IHRvIGZpbmQgaW4gYXJyYXkuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBmaXJzdCBpbmRleCBvZiBzZWFyY2hFbGVtZW50IGluIGFycmF5LlxuICovXG5jcmVhdGVqcy5pbmRleE9mID0gZnVuY3Rpb24gKGFycmF5LCBzZWFyY2hFbGVtZW50KXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Zm9yICh2YXIgaSA9IDAsbD1hcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRpZiAoc2VhcmNoRWxlbWVudCA9PT0gYXJyYXlbaV0pIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59O1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRXZlbnQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBDb250YWlucyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHNoYXJlZCBieSBhbGwgZXZlbnRzIGZvciB1c2Ugd2l0aFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFxuXHQgKiBOb3RlIHRoYXQgRXZlbnQgb2JqZWN0cyBhcmUgb2Z0ZW4gcmV1c2VkLCBzbyB5b3Ugc2hvdWxkIG5ldmVyXG5cdCAqIHJlbHkgb24gYW4gZXZlbnQgb2JqZWN0J3Mgc3RhdGUgb3V0c2lkZSBvZiB0aGUgY2FsbCBzdGFjayBpdCB3YXMgcmVjZWl2ZWQgaW4uXG5cdCAqIEBjbGFzcyBFdmVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBidWJibGVzIEluZGljYXRlcyB3aGV0aGVyIHRoZSBldmVudCB3aWxsIGJ1YmJsZSB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FuY2VsYWJsZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdGhpcyBldmVudCBjYW4gYmUgY2FuY2VsbGVkLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBFdmVudCh0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlKSB7XG5cdFx0XG5cdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgdHlwZSBvZiBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgdHlwZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqKi9cblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgb2JqZWN0IHRoYXQgZ2VuZXJhdGVkIGFuIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSB0YXJnZXRcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLnRhcmdldCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IHRhcmdldCB0aGF0IGEgYnViYmxpbmcgZXZlbnQgaXMgYmVpbmcgZGlzcGF0Y2hlZCBmcm9tLiBGb3Igbm9uLWJ1YmJsaW5nIGV2ZW50cywgdGhpcyB3aWxsXG5cdFx0ICogYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHRhcmdldC4gRm9yIGV4YW1wbGUsIGlmIGNoaWxkT2JqLnBhcmVudCA9IHBhcmVudE9iaiwgYW5kIGEgYnViYmxpbmcgZXZlbnRcblx0XHQgKiBpcyBnZW5lcmF0ZWQgZnJvbSBjaGlsZE9iaiwgdGhlbiBhIGxpc3RlbmVyIG9uIHBhcmVudE9iaiB3b3VsZCByZWNlaXZlIHRoZSBldmVudCB3aXRoXG5cdFx0ICogdGFyZ2V0PWNoaWxkT2JqICh0aGUgb3JpZ2luYWwgdGFyZ2V0KSBhbmQgY3VycmVudFRhcmdldD1wYXJlbnRPYmogKHdoZXJlIHRoZSBsaXN0ZW5lciB3YXMgYWRkZWQpLlxuXHRcdCAqIEBwcm9wZXJ0eSBjdXJyZW50VGFyZ2V0XG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogRm9yIGJ1YmJsaW5nIGV2ZW50cywgdGhpcyBpbmRpY2F0ZXMgdGhlIGN1cnJlbnQgZXZlbnQgcGhhc2U6PE9MPlxuXHRcdCAqIFx0PExJPiBjYXB0dXJlIHBoYXNlOiBzdGFydGluZyBmcm9tIHRoZSB0b3AgcGFyZW50IHRvIHRoZSB0YXJnZXQ8L0xJPlxuXHRcdCAqIFx0PExJPiBhdCB0YXJnZXQgcGhhc2U6IGN1cnJlbnRseSBiZWluZyBkaXNwYXRjaGVkIGZyb20gdGhlIHRhcmdldDwvTEk+XG5cdFx0ICogXHQ8TEk+IGJ1YmJsaW5nIHBoYXNlOiBmcm9tIHRoZSB0YXJnZXQgdG8gdGhlIHRvcCBwYXJlbnQ8L0xJPlxuXHRcdCAqIDwvT0w+XG5cdFx0ICogQHByb3BlcnR5IGV2ZW50UGhhc2Vcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmV2ZW50UGhhc2UgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZXZlbnQgd2lsbCBidWJibGUgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBidWJibGVzXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmJ1YmJsZXMgPSAhIWJ1YmJsZXM7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiB0aGlzIGV2ZW50IGNhbiBiZSBjYW5jZWxsZWQgdmlhXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcHJldmVudERlZmF1bHRcIn19e3svY3Jvc3NMaW5rfX0uIFRoaXMgaXMgc2V0IHZpYSB0aGUgRXZlbnQgY29uc3RydWN0b3IuXG5cdFx0ICogQHByb3BlcnR5IGNhbmNlbGFibGVcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuY2FuY2VsYWJsZSA9ICEhY2FuY2VsYWJsZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGVwb2NoIHRpbWUgYXQgd2hpY2ggdGhpcyBldmVudCB3YXMgY3JlYXRlZC5cblx0XHQgKiBAcHJvcGVydHkgdGltZVN0YW1wXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy50aW1lU3RhbXAgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcHJldmVudERlZmF1bHRcIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkXG5cdFx0ICogb24gdGhpcyBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgZGVmYXVsdFByZXZlbnRlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9zdG9wUHJvcGFnYXRpb25cIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudC9zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkIG9uIHRoaXMgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IHByb3BhZ2F0aW9uU3RvcHBlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHt7I2Nyb3NzTGluayBcIkV2ZW50L3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwifX17ey9jcm9zc0xpbmt9fSBoYXMgYmVlbiBjYWxsZWRcblx0XHQgKiBvbiB0aGlzIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBpbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHt7I2Nyb3NzTGluayBcIkV2ZW50L3JlbW92ZVwifX17ey9jcm9zc0xpbmt9fSBoYXMgYmVlbiBjYWxsZWQgb24gdGhpcyBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgcmVtb3ZlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5yZW1vdmVkID0gZmFsc2U7XG5cdH1cblx0dmFyIHAgPSBFdmVudC5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFNldHMge3sjY3Jvc3NMaW5rIFwiRXZlbnQvZGVmYXVsdFByZXZlbnRlZFwifX17ey9jcm9zc0xpbmt9fSB0byB0cnVlIGlmIHRoZSBldmVudCBpcyBjYW5jZWxhYmxlLlxuXHQgKiBNaXJyb3JzIHRoZSBET00gbGV2ZWwgMiBldmVudCBzdGFuZGFyZC4gSW4gZ2VuZXJhbCwgY2FuY2VsYWJsZSBldmVudHMgdGhhdCBoYXZlIGBwcmV2ZW50RGVmYXVsdCgpYCBjYWxsZWQgd2lsbFxuXHQgKiBjYW5jZWwgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXG5cdCAqIEBtZXRob2QgcHJldmVudERlZmF1bHRcblx0ICoqL1xuXHRwLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kZWZhdWx0UHJldmVudGVkID0gdGhpcy5jYW5jZWxhYmxlJiZ0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHt7I2Nyb3NzTGluayBcIkV2ZW50L3Byb3BhZ2F0aW9uU3RvcHBlZFwifX17ey9jcm9zc0xpbmt9fSB0byB0cnVlLlxuXHQgKiBNaXJyb3JzIHRoZSBET00gZXZlbnQgc3RhbmRhcmQuXG5cdCAqIEBtZXRob2Qgc3RvcFByb3BhZ2F0aW9uXG5cdCAqKi9cblx0cC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcHJvcGFnYXRpb25TdG9wcGVkXCJ9fXt7L2Nyb3NzTGlua319IGFuZFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudC9pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWRcIn19e3svY3Jvc3NMaW5rfX0gdG8gdHJ1ZS5cblx0ICogTWlycm9ycyB0aGUgRE9NIGV2ZW50IHN0YW5kYXJkLlxuXHQgKiBAbWV0aG9kIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblxuXHQgKiovXG5cdHAuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2F1c2VzIHRoZSBhY3RpdmUgbGlzdGVuZXIgdG8gYmUgcmVtb3ZlZCB2aWEgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuXHQgKiBcblx0ICogXHRcdG15QnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihldnQpIHtcblx0ICogXHRcdFx0Ly8gZG8gc3R1ZmYuLi5cblx0ICogXHRcdFx0ZXZ0LnJlbW92ZSgpOyAvLyByZW1vdmVzIHRoaXMgbGlzdGVuZXIuXG5cdCAqIFx0XHR9KTtcblx0ICogXG5cdCAqIEBtZXRob2QgcmVtb3ZlXG5cdCAqKi9cblx0cC5yZW1vdmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlbW92ZWQgPSB0cnVlO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgRXZlbnQgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7RXZlbnR9IGEgY2xvbmUgb2YgdGhlIEV2ZW50IGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEV2ZW50KHRoaXMudHlwZSwgdGhpcy5idWJibGVzLCB0aGlzLmNhbmNlbGFibGUpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFByb3ZpZGVzIGEgY2hhaW5hYmxlIHNob3J0Y3V0IG1ldGhvZCBmb3Igc2V0dGluZyBhIG51bWJlciBvZiBwcm9wZXJ0aWVzIG9uIHRoZSBpbnN0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBzZXRcblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEEgZ2VuZXJpYyBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRvIGNvcHkgdG8gdGhlIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtFdmVudH0gUmV0dXJucyB0aGUgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAuc2V0ID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRmb3IgKHZhciBuIGluIHByb3BzKSB7IHRoaXNbbl0gPSBwcm9wc1tuXTsgfVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbRXZlbnQgKHR5cGU9XCIrdGhpcy50eXBlK1wiKV1cIjtcblx0fTtcblxuXHRjcmVhdGVqcy5FdmVudCA9IEV2ZW50O1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEV2ZW50RGlzcGF0Y2hlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbi8vIGNvbnN0cnVjdG9yOlxyXG5cdC8qKlxyXG5cdCAqIEV2ZW50RGlzcGF0Y2hlciBwcm92aWRlcyBtZXRob2RzIGZvciBtYW5hZ2luZyBxdWV1ZXMgb2YgZXZlbnQgbGlzdGVuZXJzIGFuZCBkaXNwYXRjaGluZyBldmVudHMuXHJcblx0ICpcclxuXHQgKiBZb3UgY2FuIGVpdGhlciBleHRlbmQgRXZlbnREaXNwYXRjaGVyIG9yIG1peCBpdHMgbWV0aG9kcyBpbnRvIGFuIGV4aXN0aW5nIHByb3RvdHlwZSBvciBpbnN0YW5jZSBieSB1c2luZyB0aGVcclxuXHQgKiBFdmVudERpc3BhdGNoZXIge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL2luaXRpYWxpemVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxyXG5cdCAqIFxyXG5cdCAqIFRvZ2V0aGVyIHdpdGggdGhlIENyZWF0ZUpTIEV2ZW50IGNsYXNzLCBFdmVudERpc3BhdGNoZXIgcHJvdmlkZXMgYW4gZXh0ZW5kZWQgZXZlbnQgbW9kZWwgdGhhdCBpcyBiYXNlZCBvbiB0aGVcclxuXHQgKiBET00gTGV2ZWwgMiBldmVudCBtb2RlbCwgaW5jbHVkaW5nIGFkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXIsIGFuZCBkaXNwYXRjaEV2ZW50LiBJdCBzdXBwb3J0c1xyXG5cdCAqIGJ1YmJsaW5nIC8gY2FwdHVyZSwgcHJldmVudERlZmF1bHQsIHN0b3BQcm9wYWdhdGlvbiwgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uLCBhbmQgaGFuZGxlRXZlbnQuXHJcblx0ICogXHJcblx0ICogRXZlbnREaXNwYXRjaGVyIGFsc28gZXhwb3NlcyBhIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9vblwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QsIHdoaWNoIG1ha2VzIGl0IGVhc2llclxyXG5cdCAqIHRvIGNyZWF0ZSBzY29wZWQgbGlzdGVuZXJzLCBsaXN0ZW5lcnMgdGhhdCBvbmx5IHJ1biBvbmNlLCBhbmQgbGlzdGVuZXJzIHdpdGggYXNzb2NpYXRlZCBhcmJpdHJhcnkgZGF0YS4gVGhlIFxyXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9vZmZcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGlzIG1lcmVseSBhbiBhbGlhcyB0b1xyXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9yZW1vdmVFdmVudExpc3RlbmVyXCJ9fXt7L2Nyb3NzTGlua319LlxyXG5cdCAqIFxyXG5cdCAqIEFub3RoZXIgYWRkaXRpb24gdG8gdGhlIERPTSBMZXZlbCAyIG1vZGVsIGlzIHRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnNcIn19e3svY3Jvc3NMaW5rfX1cclxuXHQgKiBtZXRob2QsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGxpc3RlbmVycyBmb3IgYWxsIGV2ZW50cywgb3IgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmljIGV2ZW50LiBUaGUgRXZlbnQgb2JqZWN0IGFsc28gXHJcblx0ICogaW5jbHVkZXMgYSB7eyNjcm9zc0xpbmsgXCJFdmVudC9yZW1vdmVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIHdoaWNoIHJlbW92ZXMgdGhlIGFjdGl2ZSBsaXN0ZW5lci5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKiBBZGQgRXZlbnREaXNwYXRjaGVyIGNhcGFiaWxpdGllcyB0byB0aGUgXCJNeUNsYXNzXCIgY2xhc3MuXHJcblx0ICpcclxuXHQgKiAgICAgIEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplKE15Q2xhc3MucHJvdG90eXBlKTtcclxuXHQgKlxyXG5cdCAqIEFkZCBhbiBldmVudCAoc2VlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9hZGRFdmVudExpc3RlbmVyXCJ9fXt7L2Nyb3NzTGlua319KS5cclxuXHQgKlxyXG5cdCAqICAgICAgaW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcihcImV2ZW50TmFtZVwiLCBoYW5kbGVyTWV0aG9kKTtcclxuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZXJNZXRob2QoZXZlbnQpIHtcclxuXHQgKiAgICAgICAgICBjb25zb2xlLmxvZyhldmVudC50YXJnZXQgKyBcIiBXYXMgQ2xpY2tlZFwiKTtcclxuXHQgKiAgICAgIH1cclxuXHQgKlxyXG5cdCAqIDxiPk1haW50YWluaW5nIHByb3BlciBzY29wZTwvYj48YnIgLz5cclxuXHQgKiBTY29wZSAoaWUuIFwidGhpc1wiKSBjYW4gYmUgYmUgYSBjaGFsbGVuZ2Ugd2l0aCBldmVudHMuIFVzaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvb25cIn19e3svY3Jvc3NMaW5rfX1cclxuXHQgKiBtZXRob2QgdG8gc3Vic2NyaWJlIHRvIGV2ZW50cyBzaW1wbGlmaWVzIHRoaXMuXHJcblx0ICpcclxuXHQgKiAgICAgIGluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCkge1xyXG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKGluc3RhbmNlID09IHRoaXMpOyAvLyBmYWxzZSwgc2NvcGUgaXMgYW1iaWd1b3VzLlxyXG5cdCAqICAgICAgfSk7XHJcblx0ICogICAgICBcclxuXHQgKiAgICAgIGluc3RhbmNlLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuXHQgKiAgICAgICAgICBjb25zb2xlLmxvZyhpbnN0YW5jZSA9PSB0aGlzKTsgLy8gdHJ1ZSwgXCJvblwiIHVzZXMgZGlzcGF0Y2hlciBzY29wZSBieSBkZWZhdWx0LlxyXG5cdCAqICAgICAgfSk7XHJcblx0ICogXHJcblx0ICogSWYgeW91IHdhbnQgdG8gdXNlIGFkZEV2ZW50TGlzdGVuZXIgaW5zdGVhZCwgeW91IG1heSB3YW50IHRvIHVzZSBmdW5jdGlvbi5iaW5kKCkgb3IgYSBzaW1pbGFyIHByb3h5IHRvIG1hbmFnZSBzY29wZS5cclxuXHQgKiAgICAgIFxyXG5cdCAqXHJcblx0ICogQGNsYXNzIEV2ZW50RGlzcGF0Y2hlclxyXG5cdCAqIEBjb25zdHJ1Y3RvclxyXG5cdCAqKi9cclxuXHRmdW5jdGlvbiBFdmVudERpc3BhdGNoZXIoKSB7XHJcblx0XHJcblx0XHJcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAcHJvcGVydHkgX2xpc3RlbmVyc1xyXG5cdFx0ICogQHR5cGUgT2JqZWN0XHJcblx0XHQgKiovXHJcblx0XHR0aGlzLl9saXN0ZW5lcnMgPSBudWxsO1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIEBwcm90ZWN0ZWRcclxuXHRcdCAqIEBwcm9wZXJ0eSBfY2FwdHVyZUxpc3RlbmVyc1xyXG5cdFx0ICogQHR5cGUgT2JqZWN0XHJcblx0XHQgKiovXHJcblx0XHR0aGlzLl9jYXB0dXJlTGlzdGVuZXJzID0gbnVsbDtcclxuXHR9XHJcblx0dmFyIHAgPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlO1xyXG5cclxuXHQvKipcclxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXHJcblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XHJcblx0ICogZm9yIGRldGFpbHMuXHJcblx0ICpcclxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiBAZGVwcmVjYXRlZFxyXG5cdCAqL1xyXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxyXG5cclxuXHJcbi8vIHN0YXRpYyBwdWJsaWMgbWV0aG9kczpcclxuXHQvKipcclxuXHQgKiBTdGF0aWMgaW5pdGlhbGl6ZXIgdG8gbWl4IEV2ZW50RGlzcGF0Y2hlciBtZXRob2RzIGludG8gYSB0YXJnZXQgb2JqZWN0IG9yIHByb3RvdHlwZS5cclxuXHQgKiBcclxuXHQgKiBcdFx0RXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUoTXlDbGFzcy5wcm90b3R5cGUpOyAvLyBhZGQgdG8gdGhlIHByb3RvdHlwZSBvZiB0aGUgY2xhc3NcclxuXHQgKiBcdFx0RXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUobXlPYmplY3QpOyAvLyBhZGQgdG8gYSBzcGVjaWZpYyBpbnN0YW5jZVxyXG5cdCAqIFxyXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxyXG5cdCAqIEBzdGF0aWNcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IHRvIGluamVjdCBFdmVudERpc3BhdGNoZXIgbWV0aG9kcyBpbnRvLiBUaGlzIGNhbiBiZSBhbiBpbnN0YW5jZSBvciBhXHJcblx0ICogcHJvdG90eXBlLlxyXG5cdCAqKi9cclxuXHRFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKHRhcmdldCkge1xyXG5cdFx0dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgPSBwLmFkZEV2ZW50TGlzdGVuZXI7XHJcblx0XHR0YXJnZXQub24gPSBwLm9uO1xyXG5cdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIgPSB0YXJnZXQub2ZmID0gIHAucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcclxuXHRcdHRhcmdldC5yZW1vdmVBbGxFdmVudExpc3RlbmVycyA9IHAucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnM7XHJcblx0XHR0YXJnZXQuaGFzRXZlbnRMaXN0ZW5lciA9IHAuaGFzRXZlbnRMaXN0ZW5lcjtcclxuXHRcdHRhcmdldC5kaXNwYXRjaEV2ZW50ID0gcC5kaXNwYXRjaEV2ZW50O1xyXG5cdFx0dGFyZ2V0Ll9kaXNwYXRjaEV2ZW50ID0gcC5fZGlzcGF0Y2hFdmVudDtcclxuXHRcdHRhcmdldC53aWxsVHJpZ2dlciA9IHAud2lsbFRyaWdnZXI7XHJcblx0fTtcclxuXHRcclxuXHJcbi8vIHB1YmxpYyBtZXRob2RzOlxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgdGhlIHNwZWNpZmllZCBldmVudCBsaXN0ZW5lci4gTm90ZSB0aGF0IGFkZGluZyBtdWx0aXBsZSBsaXN0ZW5lcnMgdG8gdGhlIHNhbWUgZnVuY3Rpb24gd2lsbCByZXN1bHQgaW5cclxuXHQgKiBtdWx0aXBsZSBjYWxsYmFja3MgZ2V0dGluZyBmaXJlZC5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spO1xyXG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcclxuXHQgKiAgICAgICAgIC8vIENsaWNrIGhhcHBlbmVkLlxyXG5cdCAqICAgICAgfVxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBBbiBvYmplY3Qgd2l0aCBhIGhhbmRsZUV2ZW50IG1ldGhvZCwgb3IgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5cclxuXHQgKiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXHJcblx0ICogQHJldHVybiB7RnVuY3Rpb24gfCBPYmplY3R9IFJldHVybnMgdGhlIGxpc3RlbmVyIGZvciBjaGFpbmluZyBvciBhc3NpZ25tZW50LlxyXG5cdCAqKi9cclxuXHRwLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xyXG5cdFx0dmFyIGxpc3RlbmVycztcclxuXHRcdGlmICh1c2VDYXB0dXJlKSB7XHJcblx0XHRcdGxpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgPSB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzfHx7fTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc3x8e307XHJcblx0XHR9XHJcblx0XHR2YXIgYXJyID0gbGlzdGVuZXJzW3R5cGVdO1xyXG5cdFx0aWYgKGFycikgeyB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpOyB9XHJcblx0XHRhcnIgPSBsaXN0ZW5lcnNbdHlwZV07IC8vIHJlbW92ZSBtYXkgaGF2ZSBkZWxldGVkIHRoZSBhcnJheVxyXG5cdFx0aWYgKCFhcnIpIHsgbGlzdGVuZXJzW3R5cGVdID0gW2xpc3RlbmVyXTsgIH1cclxuXHRcdGVsc2UgeyBhcnIucHVzaChsaXN0ZW5lcik7IH1cclxuXHRcdHJldHVybiBsaXN0ZW5lcjtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEEgc2hvcnRjdXQgbWV0aG9kIGZvciB1c2luZyBhZGRFdmVudExpc3RlbmVyIHRoYXQgbWFrZXMgaXQgZWFzaWVyIHRvIHNwZWNpZnkgYW4gZXhlY3V0aW9uIHNjb3BlLCBoYXZlIGEgbGlzdGVuZXJcclxuXHQgKiBvbmx5IHJ1biBvbmNlLCBhc3NvY2lhdGUgYXJiaXRyYXJ5IGRhdGEgd2l0aCB0aGUgbGlzdGVuZXIsIGFuZCByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG5cdCAqIFxyXG5cdCAqIFRoaXMgbWV0aG9kIHdvcmtzIGJ5IGNyZWF0aW5nIGFuIGFub255bW91cyB3cmFwcGVyIGZ1bmN0aW9uIGFuZCBzdWJzY3JpYmluZyBpdCB3aXRoIGFkZEV2ZW50TGlzdGVuZXIuXHJcblx0ICogVGhlIHdyYXBwZXIgZnVuY3Rpb24gaXMgcmV0dXJuZWQgZm9yIHVzZSB3aXRoIGByZW1vdmVFdmVudExpc3RlbmVyYCAob3IgYG9mZmApLlxyXG5cdCAqIFxyXG5cdCAqIDxiPklNUE9SVEFOVDo8L2I+IFRvIHJlbW92ZSBhIGxpc3RlbmVyIGFkZGVkIHdpdGggYG9uYCwgeW91IG11c3QgcGFzcyBpbiB0aGUgcmV0dXJuZWQgd3JhcHBlciBmdW5jdGlvbiBhcyB0aGUgbGlzdGVuZXIsIG9yIHVzZVxyXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50L3JlbW92ZVwifX17ey9jcm9zc0xpbmt9fS4gTGlrZXdpc2UsIGVhY2ggdGltZSB5b3UgY2FsbCBgb25gIGEgTkVXIHdyYXBwZXIgZnVuY3Rpb24gaXMgc3Vic2NyaWJlZCwgc28gbXVsdGlwbGUgY2FsbHNcclxuXHQgKiB0byBgb25gIHdpdGggdGhlIHNhbWUgcGFyYW1zIHdpbGwgY3JlYXRlIG11bHRpcGxlIGxpc3RlbmVycy5cclxuXHQgKiBcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICogXHJcblx0ICogXHRcdHZhciBsaXN0ZW5lciA9IG15QnRuLm9uKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2ssIG51bGwsIGZhbHNlLCB7Y291bnQ6M30pO1xyXG5cdCAqIFx0XHRmdW5jdGlvbiBoYW5kbGVDbGljayhldnQsIGRhdGEpIHtcclxuXHQgKiBcdFx0XHRkYXRhLmNvdW50IC09IDE7XHJcblx0ICogXHRcdFx0Y29uc29sZS5sb2codGhpcyA9PSBteUJ0bik7IC8vIHRydWUgLSBzY29wZSBkZWZhdWx0cyB0byB0aGUgZGlzcGF0Y2hlclxyXG5cdCAqIFx0XHRcdGlmIChkYXRhLmNvdW50ID09IDApIHtcclxuXHQgKiBcdFx0XHRcdGFsZXJ0KFwiY2xpY2tlZCAzIHRpbWVzIVwiKTtcclxuXHQgKiBcdFx0XHRcdG15QnRuLm9mZihcImNsaWNrXCIsIGxpc3RlbmVyKTtcclxuXHQgKiBcdFx0XHRcdC8vIGFsdGVybmF0ZWx5OiBldnQucmVtb3ZlKCk7XHJcblx0ICogXHRcdFx0fVxyXG5cdCAqIFx0XHR9XHJcblx0ICogXHJcblx0ICogQG1ldGhvZCBvblxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbiB8IE9iamVjdH0gbGlzdGVuZXIgQW4gb2JqZWN0IHdpdGggYSBoYW5kbGVFdmVudCBtZXRob2QsIG9yIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuXHJcblx0ICogdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gVGhlIHNjb3BlIHRvIGV4ZWN1dGUgdGhlIGxpc3RlbmVyIGluLiBEZWZhdWx0cyB0byB0aGUgZGlzcGF0Y2hlci9jdXJyZW50VGFyZ2V0IGZvciBmdW5jdGlvbiBsaXN0ZW5lcnMsIGFuZCB0byB0aGUgbGlzdGVuZXIgaXRzZWxmIGZvciBvYmplY3QgbGlzdGVuZXJzIChpZS4gdXNpbmcgaGFuZGxlRXZlbnQpLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIElmIHRydWUsIHRoZSBsaXN0ZW5lciB3aWxsIHJlbW92ZSBpdHNlbGYgYWZ0ZXIgdGhlIGZpcnN0IHRpbWUgaXQgaXMgdHJpZ2dlcmVkLlxyXG5cdCAqIEBwYXJhbSB7Kn0gW2RhdGFdIEFyYml0cmFyeSBkYXRhIHRoYXQgd2lsbCBiZSBpbmNsdWRlZCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciB3aGVuIHRoZSBsaXN0ZW5lciBpcyBjYWxsZWQuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZT1mYWxzZV0gRm9yIGV2ZW50cyB0aGF0IGJ1YmJsZSwgaW5kaWNhdGVzIHdoZXRoZXIgdG8gbGlzdGVuIGZvciB0aGUgZXZlbnQgaW4gdGhlIGNhcHR1cmUgb3IgYnViYmxpbmcvdGFyZ2V0IHBoYXNlLlxyXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBhbm9ueW1vdXMgZnVuY3Rpb24gdGhhdCB3YXMgY3JlYXRlZCBhbmQgYXNzaWduZWQgYXMgdGhlIGxpc3RlbmVyLiBUaGlzIGlzIG5lZWRlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGxhdGVyIHVzaW5nIC5yZW1vdmVFdmVudExpc3RlbmVyLlxyXG5cdCAqKi9cclxuXHRwLm9uID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIHNjb3BlLCBvbmNlLCBkYXRhLCB1c2VDYXB0dXJlKSB7XHJcblx0XHRpZiAobGlzdGVuZXIuaGFuZGxlRXZlbnQpIHtcclxuXHRcdFx0c2NvcGUgPSBzY29wZXx8bGlzdGVuZXI7XHJcblx0XHRcdGxpc3RlbmVyID0gbGlzdGVuZXIuaGFuZGxlRXZlbnQ7XHJcblx0XHR9XHJcblx0XHRzY29wZSA9IHNjb3BlfHx0aGlzO1xyXG5cdFx0cmV0dXJuIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jdGlvbihldnQpIHtcclxuXHRcdFx0XHRsaXN0ZW5lci5jYWxsKHNjb3BlLCBldnQsIGRhdGEpO1xyXG5cdFx0XHRcdG9uY2UmJmV2dC5yZW1vdmUoKTtcclxuXHRcdFx0fSwgdXNlQ2FwdHVyZSk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGV2ZW50IGxpc3RlbmVyLlxyXG5cdCAqXHJcblx0ICogPGI+SW1wb3J0YW50IE5vdGU6PC9iPiB0aGF0IHlvdSBtdXN0IHBhc3MgdGhlIGV4YWN0IGZ1bmN0aW9uIHJlZmVyZW5jZSB1c2VkIHdoZW4gdGhlIGV2ZW50IHdhcyBhZGRlZC4gSWYgYSBwcm94eVxyXG5cdCAqIGZ1bmN0aW9uLCBvciBmdW5jdGlvbiBjbG9zdXJlIGlzIHVzZWQgYXMgdGhlIGNhbGxiYWNrLCB0aGUgcHJveHkvY2xvc3VyZSByZWZlcmVuY2UgbXVzdCBiZSB1c2VkIC0gYSBuZXcgcHJveHkgb3JcclxuXHQgKiBjbG9zdXJlIHdpbGwgbm90IHdvcmsuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrKTtcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lclxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbiB8IE9iamVjdH0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIG9yIG9iamVjdC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXHJcblx0ICoqL1xyXG5cdHAucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdXNlQ2FwdHVyZSA/IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgOiB0aGlzLl9saXN0ZW5lcnM7XHJcblx0XHRpZiAoIWxpc3RlbmVycykgeyByZXR1cm47IH1cclxuXHRcdHZhciBhcnIgPSBsaXN0ZW5lcnNbdHlwZV07XHJcblx0XHRpZiAoIWFycikgeyByZXR1cm47IH1cclxuXHRcdGZvciAodmFyIGk9MCxsPWFyci5sZW5ndGg7IGk8bDsgaSsrKSB7XHJcblx0XHRcdGlmIChhcnJbaV0gPT0gbGlzdGVuZXIpIHtcclxuXHRcdFx0XHRpZiAobD09MSkgeyBkZWxldGUobGlzdGVuZXJzW3R5cGVdKTsgfSAvLyBhbGxvd3MgZm9yIGZhc3RlciBjaGVja3MuXHJcblx0XHRcdFx0ZWxzZSB7IGFyci5zcGxpY2UoaSwxKTsgfVxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBBIHNob3J0Y3V0IHRvIHRoZSByZW1vdmVFdmVudExpc3RlbmVyIG1ldGhvZCwgd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFuZCByZXR1cm4gdmFsdWUuIFRoaXMgaXMgYSBjb21wYW5pb24gdG8gdGhlXHJcblx0ICogLm9uIG1ldGhvZC5cclxuXHQgKiBcclxuXHQgKiA8Yj5JTVBPUlRBTlQ6PC9iPiBUbyByZW1vdmUgYSBsaXN0ZW5lciBhZGRlZCB3aXRoIGBvbmAsIHlvdSBtdXN0IHBhc3MgaW4gdGhlIHJldHVybmVkIHdyYXBwZXIgZnVuY3Rpb24gYXMgdGhlIGxpc3RlbmVyLiBTZWUgXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL29uXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhbiBleGFtcGxlLlxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBvZmZcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb24gfCBPYmplY3R9IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiBvciBvYmplY3QuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZV0gRm9yIGV2ZW50cyB0aGF0IGJ1YmJsZSwgaW5kaWNhdGVzIHdoZXRoZXIgdG8gbGlzdGVuIGZvciB0aGUgZXZlbnQgaW4gdGhlIGNhcHR1cmUgb3IgYnViYmxpbmcvdGFyZ2V0IHBoYXNlLlxyXG5cdCAqKi9cclxuXHRwLm9mZiA9IHAucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgc3BlY2lmaWVkIHR5cGUsIG9yIGFsbCBsaXN0ZW5lcnMgb2YgYWxsIHR5cGVzLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVyc1xyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5yZW1vdmVBbGxFdmVudExpc3RlbmVycygpO1xyXG5cdCAqXHJcblx0ICogICAgICAvLyBSZW1vdmUgYWxsIGNsaWNrIGxpc3RlbmVyc1xyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5yZW1vdmVBbGxFdmVudExpc3RlbmVycyhcImNsaWNrXCIpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCByZW1vdmVBbGxFdmVudExpc3RlbmVyc1xyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC4gSWYgb21pdHRlZCwgYWxsIGxpc3RlbmVycyBmb3IgYWxsIHR5cGVzIHdpbGwgYmUgcmVtb3ZlZC5cclxuXHQgKiovXHJcblx0cC5yZW1vdmVBbGxFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdGlmICghdHlwZSkgeyB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzID0gbnVsbDsgfVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGlmICh0aGlzLl9saXN0ZW5lcnMpIHsgZGVsZXRlKHRoaXMuX2xpc3RlbmVyc1t0eXBlXSk7IH1cclxuXHRcdFx0aWYgKHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMpIHsgZGVsZXRlKHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnNbdHlwZV0pOyB9XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogRGlzcGF0Y2hlcyB0aGUgc3BlY2lmaWVkIGV2ZW50IHRvIGFsbCBsaXN0ZW5lcnMuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIC8vIFVzZSBhIHN0cmluZyBldmVudFxyXG5cdCAqICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiY29tcGxldGVcIik7XHJcblx0ICpcclxuXHQgKiAgICAgIC8vIFVzZSBhbiBFdmVudCBpbnN0YW5jZVxyXG5cdCAqICAgICAgdmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwicHJvZ3Jlc3NcIik7XHJcblx0ICogICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBkaXNwYXRjaEV2ZW50XHJcblx0ICogQHBhcmFtIHtPYmplY3QgfCBTdHJpbmcgfCBFdmVudH0gZXZlbnRPYmogQW4gb2JqZWN0IHdpdGggYSBcInR5cGVcIiBwcm9wZXJ0eSwgb3IgYSBzdHJpbmcgdHlwZS5cclxuXHQgKiBXaGlsZSBhIGdlbmVyaWMgb2JqZWN0IHdpbGwgd29yaywgaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIGEgQ3JlYXRlSlMgRXZlbnQgaW5zdGFuY2UuIElmIGEgc3RyaW5nIGlzIHVzZWQsXHJcblx0ICogZGlzcGF0Y2hFdmVudCB3aWxsIGNvbnN0cnVjdCBhbiBFdmVudCBpbnN0YW5jZSBpZiBuZWNlc3Nhcnkgd2l0aCB0aGUgc3BlY2lmaWVkIHR5cGUuIFRoaXMgbGF0dGVyIGFwcHJvYWNoIGNhblxyXG5cdCAqIGJlIHVzZWQgdG8gYXZvaWQgZXZlbnQgb2JqZWN0IGluc3RhbnRpYXRpb24gZm9yIG5vbi1idWJibGluZyBldmVudHMgdGhhdCBtYXkgbm90IGhhdmUgYW55IGxpc3RlbmVycy5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtidWJibGVzXSBTcGVjaWZpZXMgdGhlIGBidWJibGVzYCB2YWx1ZSB3aGVuIGEgc3RyaW5nIHdhcyBwYXNzZWQgdG8gZXZlbnRPYmouXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbY2FuY2VsYWJsZV0gU3BlY2lmaWVzIHRoZSBgY2FuY2VsYWJsZWAgdmFsdWUgd2hlbiBhIHN0cmluZyB3YXMgcGFzc2VkIHRvIGV2ZW50T2JqLlxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgZmFsc2UgaWYgYHByZXZlbnREZWZhdWx0KClgIHdhcyBjYWxsZWQgb24gYSBjYW5jZWxhYmxlIGV2ZW50LCB0cnVlIG90aGVyd2lzZS5cclxuXHQgKiovXHJcblx0cC5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnRPYmosIGJ1YmJsZXMsIGNhbmNlbGFibGUpIHtcclxuXHRcdGlmICh0eXBlb2YgZXZlbnRPYmogPT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHQvLyBza2lwIGV2ZXJ5dGhpbmcgaWYgdGhlcmUncyBubyBsaXN0ZW5lcnMgYW5kIGl0IGRvZXNuJ3QgYnViYmxlOlxyXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG5cdFx0XHRpZiAoIWJ1YmJsZXMgJiYgKCFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVyc1tldmVudE9ial0pKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcdGV2ZW50T2JqID0gbmV3IGNyZWF0ZWpzLkV2ZW50KGV2ZW50T2JqLCBidWJibGVzLCBjYW5jZWxhYmxlKTtcclxuXHRcdH0gZWxzZSBpZiAoZXZlbnRPYmoudGFyZ2V0ICYmIGV2ZW50T2JqLmNsb25lKSB7XHJcblx0XHRcdC8vIHJlZGlzcGF0Y2hpbmcgYW4gYWN0aXZlIGV2ZW50IG9iamVjdCwgc28gY2xvbmUgaXQ6XHJcblx0XHRcdGV2ZW50T2JqID0gZXZlbnRPYmouY2xvbmUoKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Ly8gVE9ETzogaXQgd291bGQgYmUgbmljZSB0byBlbGltaW5hdGUgdGhpcy4gTWF5YmUgaW4gZmF2b3VyIG9mIGV2dE9iaiBpbnN0YW5jZW9mIEV2ZW50PyBPciAhIWV2dE9iai5jcmVhdGVFdmVudFxyXG5cdFx0dHJ5IHsgZXZlbnRPYmoudGFyZ2V0ID0gdGhpczsgfSBjYXRjaCAoZSkge30gLy8gdHJ5L2NhdGNoIGFsbG93cyByZWRpc3BhdGNoaW5nIG9mIG5hdGl2ZSBldmVudHNcclxuXHJcblx0XHRpZiAoIWV2ZW50T2JqLmJ1YmJsZXMgfHwgIXRoaXMucGFyZW50KSB7XHJcblx0XHRcdHRoaXMuX2Rpc3BhdGNoRXZlbnQoZXZlbnRPYmosIDIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHRvcD10aGlzLCBsaXN0PVt0b3BdO1xyXG5cdFx0XHR3aGlsZSAodG9wLnBhcmVudCkgeyBsaXN0LnB1c2godG9wID0gdG9wLnBhcmVudCk7IH1cclxuXHRcdFx0dmFyIGksIGw9bGlzdC5sZW5ndGg7XHJcblxyXG5cdFx0XHQvLyBjYXB0dXJlICYgYXRUYXJnZXRcclxuXHRcdFx0Zm9yIChpPWwtMTsgaT49MCAmJiAhZXZlbnRPYmoucHJvcGFnYXRpb25TdG9wcGVkOyBpLS0pIHtcclxuXHRcdFx0XHRsaXN0W2ldLl9kaXNwYXRjaEV2ZW50KGV2ZW50T2JqLCAxKyhpPT0wKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gYnViYmxpbmdcclxuXHRcdFx0Zm9yIChpPTE7IGk8bCAmJiAhZXZlbnRPYmoucHJvcGFnYXRpb25TdG9wcGVkOyBpKyspIHtcclxuXHRcdFx0XHRsaXN0W2ldLl9kaXNwYXRjaEV2ZW50KGV2ZW50T2JqLCAzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuICFldmVudE9iai5kZWZhdWx0UHJldmVudGVkO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudCB0eXBlLlxyXG5cdCAqIEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lclxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cclxuXHQgKiovXHJcblx0cC5oYXNFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycywgY2FwdHVyZUxpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnM7XHJcblx0XHRyZXR1cm4gISEoKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnNbdHlwZV0pIHx8IChjYXB0dXJlTGlzdGVuZXJzICYmIGNhcHR1cmVMaXN0ZW5lcnNbdHlwZV0pKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudCB0eXBlIG9uIHRoaXMgb2JqZWN0IG9yIGFueSBvZiBpdHNcclxuXHQgKiBhbmNlc3RvcnMgKHBhcmVudCwgcGFyZW50J3MgcGFyZW50LCBldGMpLiBBIHJldHVybiB2YWx1ZSBvZiB0cnVlIGluZGljYXRlcyB0aGF0IGlmIGEgYnViYmxpbmcgZXZlbnQgb2YgdGhlXHJcblx0ICogc3BlY2lmaWVkIHR5cGUgaXMgZGlzcGF0Y2hlZCBmcm9tIHRoaXMgb2JqZWN0LCBpdCB3aWxsIHRyaWdnZXIgYXQgbGVhc3Qgb25lIGxpc3RlbmVyLlxyXG5cdCAqIFxyXG5cdCAqIFRoaXMgaXMgc2ltaWxhciB0byB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvaGFzRXZlbnRMaXN0ZW5lclwifX17ey9jcm9zc0xpbmt9fSwgYnV0IGl0IHNlYXJjaGVzIHRoZSBlbnRpcmVcclxuXHQgKiBldmVudCBmbG93IGZvciBhIGxpc3RlbmVyLCBub3QganVzdCB0aGlzIG9iamVjdC5cclxuXHQgKiBAbWV0aG9kIHdpbGxUcmlnZ2VyXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXHJcblx0ICoqL1xyXG5cdHAud2lsbFRyaWdnZXIgPSBmdW5jdGlvbih0eXBlKSB7XHJcblx0XHR2YXIgbyA9IHRoaXM7XHJcblx0XHR3aGlsZSAobykge1xyXG5cdFx0XHRpZiAoby5oYXNFdmVudExpc3RlbmVyKHR5cGUpKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcdG8gPSBvLnBhcmVudDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXHJcblx0ICoqL1xyXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBcIltFdmVudERpc3BhdGNoZXJdXCI7XHJcblx0fTtcclxuXHJcblxyXG4vLyBwcml2YXRlIG1ldGhvZHM6XHJcblx0LyoqXHJcblx0ICogQG1ldGhvZCBfZGlzcGF0Y2hFdmVudFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0IHwgU3RyaW5nIHwgRXZlbnR9IGV2ZW50T2JqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50UGhhc2VcclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICoqL1xyXG5cdHAuX2Rpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudE9iaiwgZXZlbnRQaGFzZSkge1xyXG5cdFx0dmFyIGwsIGxpc3RlbmVycyA9IChldmVudFBoYXNlPT0xKSA/IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgOiB0aGlzLl9saXN0ZW5lcnM7XHJcblx0XHRpZiAoZXZlbnRPYmogJiYgbGlzdGVuZXJzKSB7XHJcblx0XHRcdHZhciBhcnIgPSBsaXN0ZW5lcnNbZXZlbnRPYmoudHlwZV07XHJcblx0XHRcdGlmICghYXJyfHwhKGw9YXJyLmxlbmd0aCkpIHsgcmV0dXJuOyB9XHJcblx0XHRcdHRyeSB7IGV2ZW50T2JqLmN1cnJlbnRUYXJnZXQgPSB0aGlzOyB9IGNhdGNoIChlKSB7fVxyXG5cdFx0XHR0cnkgeyBldmVudE9iai5ldmVudFBoYXNlID0gZXZlbnRQaGFzZTsgfSBjYXRjaCAoZSkge31cclxuXHRcdFx0ZXZlbnRPYmoucmVtb3ZlZCA9IGZhbHNlO1xyXG5cdFx0XHRcclxuXHRcdFx0YXJyID0gYXJyLnNsaWNlKCk7IC8vIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGl0ZW1zIGJlaW5nIHJlbW92ZWQgb3IgYWRkZWQgZHVyaW5nIHRoZSBkaXNwYXRjaFxyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bCAmJiAhZXZlbnRPYmouaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgbyA9IGFycltpXTtcclxuXHRcdFx0XHRpZiAoby5oYW5kbGVFdmVudCkgeyBvLmhhbmRsZUV2ZW50KGV2ZW50T2JqKTsgfVxyXG5cdFx0XHRcdGVsc2UgeyBvKGV2ZW50T2JqKTsgfVxyXG5cdFx0XHRcdGlmIChldmVudE9iai5yZW1vdmVkKSB7XHJcblx0XHRcdFx0XHR0aGlzLm9mZihldmVudE9iai50eXBlLCBvLCBldmVudFBoYXNlPT0xKTtcclxuXHRcdFx0XHRcdGV2ZW50T2JqLnJlbW92ZWQgPSBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHJcblx0Y3JlYXRlanMuRXZlbnREaXNwYXRjaGVyID0gRXZlbnREaXNwYXRjaGVyO1xyXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVGlja2VyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBUaGUgVGlja2VyIHByb3ZpZGVzIGEgY2VudHJhbGl6ZWQgdGljayBvciBoZWFydGJlYXQgYnJvYWRjYXN0IGF0IGEgc2V0IGludGVydmFsLiBMaXN0ZW5lcnMgY2FuIHN1YnNjcmliZSB0byB0aGUgdGlja1xuXHQgKiBldmVudCB0byBiZSBub3RpZmllZCB3aGVuIGEgc2V0IHRpbWUgaW50ZXJ2YWwgaGFzIGVsYXBzZWQuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgaW50ZXJ2YWwgdGhhdCB0aGUgdGljayBldmVudCBpcyBjYWxsZWQgaXMgYSB0YXJnZXQgaW50ZXJ2YWwsIGFuZCBtYXkgYmUgYnJvYWRjYXN0IGF0IGEgc2xvd2VyIGludGVydmFsXG5cdCAqIHdoZW4gdW5kZXIgaGlnaCBDUFUgbG9hZC4gVGhlIFRpY2tlciBjbGFzcyB1c2VzIGEgc3RhdGljIGludGVyZmFjZSAoZXguIGBUaWNrZXIuZnJhbWVyYXRlID0gMzA7YCkgYW5kXG5cdCAqIGNhbiBub3QgYmUgaW5zdGFudGlhdGVkLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIGhhbmRsZVRpY2spO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZVRpY2soZXZlbnQpIHtcblx0ICogICAgICAgICAgLy8gQWN0aW9ucyBjYXJyaWVkIG91dCBlYWNoIHRpY2sgKGFrYSBmcmFtZSlcblx0ICogICAgICAgICAgaWYgKCFldmVudC5wYXVzZWQpIHtcblx0ICogICAgICAgICAgICAgIC8vIEFjdGlvbnMgY2FycmllZCBvdXQgd2hlbiB0aGUgVGlja2VyIGlzIG5vdCBwYXVzZWQuXG5cdCAqICAgICAgICAgIH1cblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBjbGFzcyBUaWNrZXJcblx0ICogQHVzZXMgRXZlbnREaXNwYXRjaGVyXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRmdW5jdGlvbiBUaWNrZXIoKSB7XG5cdFx0dGhyb3cgXCJUaWNrZXIgY2Fubm90IGJlIGluc3RhbnRpYXRlZC5cIjtcblx0fVxuXG5cbi8vIGNvbnN0YW50czpcblx0LyoqXG5cdCAqIEluIHRoaXMgbW9kZSwgVGlja2VyIHVzZXMgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBBUEksIGJ1dCBhdHRlbXB0cyB0byBzeW5jaCB0aGUgdGlja3MgdG8gdGFyZ2V0IGZyYW1lcmF0ZS4gSXRcblx0ICogdXNlcyBhIHNpbXBsZSBoZXVyaXN0aWMgdGhhdCBjb21wYXJlcyB0aGUgdGltZSBvZiB0aGUgUkFGIHJldHVybiB0byB0aGUgdGFyZ2V0IHRpbWUgZm9yIHRoZSBjdXJyZW50IGZyYW1lIGFuZFxuXHQgKiBkaXNwYXRjaGVzIHRoZSB0aWNrIHdoZW4gdGhlIHRpbWUgaXMgd2l0aGluIGEgY2VydGFpbiB0aHJlc2hvbGQuXG5cdCAqXG5cdCAqIFRoaXMgbW9kZSBoYXMgYSBoaWdoZXIgdmFyaWFuY2UgZm9yIHRpbWUgYmV0d2VlbiBmcmFtZXMgdGhhbiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvVElNRU9VVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogYnV0IGRvZXMgbm90IHJlcXVpcmUgdGhhdCBjb250ZW50IGJlIHRpbWUgYmFzZWQgYXMgd2l0aCB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvUkFGOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHdoaWxlXG5cdCAqIGdhaW5pbmcgdGhlIGJlbmVmaXRzIG9mIHRoYXQgQVBJIChzY3JlZW4gc3luY2gsIGJhY2tncm91bmQgdGhyb3R0bGluZykuXG5cdCAqXG5cdCAqIFZhcmlhbmNlIGlzIHVzdWFsbHkgbG93ZXN0IGZvciBmcmFtZXJhdGVzIHRoYXQgYXJlIGEgZGl2aXNvciBvZiB0aGUgUkFGIGZyZXF1ZW5jeS4gVGhpcyBpcyB1c3VhbGx5IDYwLCBzb1xuXHQgKiBmcmFtZXJhdGVzIG9mIDEwLCAxMiwgMTUsIDIwLCBhbmQgMzAgd29yayB3ZWxsLlxuXHQgKlxuXHQgKiBGYWxscyBiYWNrIHRvIHt7I2Nyb3NzTGluayBcIlRpY2tlci9USU1FT1VUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlmIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgQVBJIGlzIG5vdFxuXHQgKiBzdXBwb3J0ZWQuXG5cdCAqIEBwcm9wZXJ0eSBSQUZfU1lOQ0hFRFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IFwic3luY2hlZFwiXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdFRpY2tlci5SQUZfU1lOQ0hFRCA9IFwic3luY2hlZFwiO1xuXG5cdC8qKlxuXHQgKiBJbiB0aGlzIG1vZGUsIFRpY2tlciBwYXNzZXMgdGhyb3VnaCB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGhlYXJ0YmVhdCwgaWdub3JpbmcgdGhlIHRhcmdldCBmcmFtZXJhdGUgY29tcGxldGVseS5cblx0ICogQmVjYXVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZnJlcXVlbmN5IGlzIG5vdCBkZXRlcm1pbmlzdGljLCBhbnkgY29udGVudCB1c2luZyB0aGlzIG1vZGUgc2hvdWxkIGJlIHRpbWUgYmFzZWQuXG5cdCAqIFlvdSBjYW4gbGV2ZXJhZ2Uge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2dldFRpbWVcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBvYmplY3QncyBcImRlbHRhXCIgcHJvcGVydGllcyB0byBtYWtlIHRoaXMgZWFzaWVyLlxuXHQgKlxuXHQgKiBGYWxscyBiYWNrIG9uIHt7I2Nyb3NzTGluayBcIlRpY2tlci9USU1FT1VUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlmIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgQVBJIGlzIG5vdFxuXHQgKiBzdXBwb3J0ZWQuXG5cdCAqIEBwcm9wZXJ0eSBSQUZcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBcInJhZlwiXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdFRpY2tlci5SQUYgPSBcInJhZlwiO1xuXG5cdC8qKlxuXHQgKiBJbiB0aGlzIG1vZGUsIFRpY2tlciB1c2VzIHRoZSBzZXRUaW1lb3V0IEFQSS4gVGhpcyBwcm92aWRlcyBwcmVkaWN0YWJsZSwgYWRhcHRpdmUgZnJhbWUgdGltaW5nLCBidXQgZG9lcyBub3Rcblx0ICogcHJvdmlkZSB0aGUgYmVuZWZpdHMgb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIChzY3JlZW4gc3luY2gsIGJhY2tncm91bmQgdGhyb3R0bGluZykuXG5cdCAqIEBwcm9wZXJ0eSBUSU1FT1VUXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgXCJ0aW1lb3V0XCJcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0VGlja2VyLlRJTUVPVVQgPSBcInRpbWVvdXRcIjtcblxuXG4vLyBzdGF0aWMgZXZlbnRzOlxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCBlYWNoIHRpY2suIFRoZSBldmVudCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gZWFjaCBsaXN0ZW5lciBldmVuIHdoZW4gdGhlIFRpY2tlciBoYXMgYmVlbiBwYXVzZWQgdXNpbmdcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3NldFBhdXNlZFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLlRpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBoYW5kbGVUaWNrKTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVUaWNrKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKFwiUGF1c2VkOlwiLCBldmVudC5wYXVzZWQsIGV2ZW50LmRlbHRhKTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBldmVudCB0aWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBwYXVzZWQgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRpY2tlciBpcyBjdXJyZW50bHkgcGF1c2VkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgVGhlIHRpbWUgZWxhcHNlZCBpbiBtcyBzaW5jZSB0aGUgbGFzdCB0aWNrLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgdG90YWwgdGltZSBpbiBtcyBzaW5jZSBUaWNrZXIgd2FzIGluaXRpYWxpemVkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcnVuVGltZSBUaGUgdG90YWwgdGltZSBpbiBtcyB0aGF0IFRpY2tlciB3YXMgbm90IHBhdXNlZCBzaW5jZSBpdCB3YXMgaW5pdGlhbGl6ZWQuIEZvciBleGFtcGxlLFxuXHQgKiBcdHlvdSBjb3VsZCBkZXRlcm1pbmUgdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgdGhlIFRpY2tlciBoYXMgYmVlbiBwYXVzZWQgc2luY2UgaW5pdGlhbGl6YXRpb24gd2l0aCBgdGltZS1ydW5UaW1lYC5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cbi8vIHB1YmxpYyBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIERlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aW1pbmdNb2RlXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uIElmIHRydWUsIHRpbWluZ01vZGUgd2lsbFxuXHQgKiB1c2Uge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1JBRl9TWU5DSEVEXCJ9fXt7L2Nyb3NzTGlua319IGJ5IGRlZmF1bHQuXG5cdCAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aW1pbmdNb2RlXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAcHJvcGVydHkgdXNlUkFGXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqKi9cblx0VGlja2VyLnVzZVJBRiA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpZXMgdGhlIHRpbWluZyBhcGkgKHNldFRpbWVvdXQgb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSBhbmQgbW9kZSB0byB1c2UuIFNlZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvVElNRU9VVFwifX17ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1JBRlwifX17ey9jcm9zc0xpbmt9fSwgYW5kXG5cdCAqIHt7I2Nyb3NzTGluayBcIlRpY2tlci9SQUZfU1lOQ0hFRFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9kZSBkZXRhaWxzLlxuXHQgKiBAcHJvcGVydHkgdGltaW5nTW9kZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IFRpY2tlci5USU1FT1VUXG5cdCAqKi9cblx0VGlja2VyLnRpbWluZ01vZGUgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpZXMgYSBtYXhpbXVtIHZhbHVlIGZvciB0aGUgZGVsdGEgcHJvcGVydHkgaW4gdGhlIHRpY2sgZXZlbnQgb2JqZWN0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGJ1aWxkaW5nIHRpbWVcblx0ICogYmFzZWQgYW5pbWF0aW9ucyBhbmQgc3lzdGVtcyB0byBwcmV2ZW50IGlzc3VlcyBjYXVzZWQgYnkgbGFyZ2UgdGltZSBnYXBzIGNhdXNlZCBieSBiYWNrZ3JvdW5kIHRhYnMsIHN5c3RlbSBzbGVlcCxcblx0ICogYWxlcnQgZGlhbG9ncywgb3Igb3RoZXIgYmxvY2tpbmcgcm91dGluZXMuIERvdWJsZSB0aGUgZXhwZWN0ZWQgZnJhbWUgZHVyYXRpb24gaXMgb2Z0ZW4gYW4gZWZmZWN0aXZlIHZhbHVlXG5cdCAqIChleC4gbWF4RGVsdGE9NTAgd2hlbiBydW5uaW5nIGF0IDQwZnBzKS5cblx0ICogXG5cdCAqIFRoaXMgZG9lcyBub3QgaW1wYWN0IGFueSBvdGhlciB2YWx1ZXMgKGV4LiB0aW1lLCBydW5UaW1lLCBldGMpLCBzbyB5b3UgbWF5IGV4cGVyaWVuY2UgaXNzdWVzIGlmIHlvdSBlbmFibGUgbWF4RGVsdGFcblx0ICogd2hlbiB1c2luZyBib3RoIGRlbHRhIGFuZCBvdGhlciB2YWx1ZXMuXG5cdCAqIFxuXHQgKiBJZiAwLCB0aGVyZSBpcyBubyBtYXhpbXVtLlxuXHQgKiBAcHJvcGVydHkgbWF4RGVsdGFcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAwXG5cdCAqL1xuXHRUaWNrZXIubWF4RGVsdGEgPSAwO1xuXHRcblx0LyoqXG5cdCAqIFdoZW4gdGhlIHRpY2tlciBpcyBwYXVzZWQsIGFsbCBsaXN0ZW5lcnMgd2lsbCBzdGlsbCByZWNlaXZlIGEgdGljayBldmVudCwgYnV0IHRoZSA8Y29kZT5wYXVzZWQ8L2NvZGU+IHByb3BlcnR5XG5cdCAqIG9mIHRoZSBldmVudCB3aWxsIGJlIGB0cnVlYC4gQWxzbywgd2hpbGUgcGF1c2VkIHRoZSBgcnVuVGltZWAgd2lsbCBub3QgaW5jcmVhc2UuIFNlZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fSxcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2dldFRpbWVcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvZ2V0RXZlbnRUaW1lXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlXG5cdCAqIGluZm8uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgaGFuZGxlVGljayk7XG5cdCAqICAgICAgY3JlYXRlanMuVGlja2VyLnBhdXNlZCA9IHRydWU7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlVGljayhldmVudCkge1xuXHQgKiAgICAgICAgICBjb25zb2xlLmxvZyhldmVudC5wYXVzZWQsXG5cdCAqICAgICAgICAgIFx0Y3JlYXRlanMuVGlja2VyLmdldFRpbWUoZmFsc2UpLFxuXHQgKiAgICAgICAgICBcdGNyZWF0ZWpzLlRpY2tlci5nZXRUaW1lKHRydWUpKTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBwYXVzZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICoqL1xuXHRUaWNrZXIucGF1c2VkID0gZmFsc2U7XG5cblxuLy8gbWl4LWluczpcblx0Ly8gRXZlbnREaXNwYXRjaGVyIG1ldGhvZHM6XG5cdFRpY2tlci5yZW1vdmVFdmVudExpc3RlbmVyID0gbnVsbDtcblx0VGlja2VyLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gbnVsbDtcblx0VGlja2VyLmRpc3BhdGNoRXZlbnQgPSBudWxsO1xuXHRUaWNrZXIuaGFzRXZlbnRMaXN0ZW5lciA9IG51bGw7XG5cdFRpY2tlci5fbGlzdGVuZXJzID0gbnVsbDtcblx0Y3JlYXRlanMuRXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUoVGlja2VyKTsgLy8gaW5qZWN0IEV2ZW50RGlzcGF0Y2hlciBtZXRob2RzLlxuXHRUaWNrZXIuX2FkZEV2ZW50TGlzdGVuZXIgPSBUaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcjtcblx0VGlja2VyLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcblx0XHQhVGlja2VyLl9pbml0ZWQmJlRpY2tlci5pbml0KCk7XG5cdFx0cmV0dXJuIFRpY2tlci5fYWRkRXZlbnRMaXN0ZW5lci5hcHBseShUaWNrZXIsIGFyZ3VtZW50cyk7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfaW5pdGVkXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX2luaXRlZCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3N0YXJ0VGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3N0YXJ0VGltZSA9IDA7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfcGF1c2VkVGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3BhdXNlZFRpbWU9MDtcblxuXHQvKipcblx0ICogVGhlIG51bWJlciBvZiB0aWNrcyB0aGF0IGhhdmUgcGFzc2VkXG5cdCAqIEBwcm9wZXJ0eSBfdGlja3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aWNrcyA9IDA7XG5cblx0LyoqXG5cdCAqIFRoZSBudW1iZXIgb2YgdGlja3MgdGhhdCBoYXZlIHBhc3NlZCB3aGlsZSBUaWNrZXIgaGFzIGJlZW4gcGF1c2VkXG5cdCAqIEBwcm9wZXJ0eSBfcGF1c2VkVGlja3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9wYXVzZWRUaWNrcyA9IDA7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfaW50ZXJ2YWxcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9pbnRlcnZhbCA9IDUwO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX2xhc3RUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fbGFzdFRpbWUgPSAwO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3RpbWVzXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aW1lcyA9IG51bGw7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfdGlja1RpbWVzXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aWNrVGltZXMgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBTdG9yZXMgdGhlIHRpbWVvdXQgb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGlkLlxuXHQgKiBAcHJvcGVydHkgX3RpbWVySWRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aW1lcklkID0gbnVsbDtcblx0XG5cdC8qKlxuXHQgKiBUcnVlIGlmIGN1cnJlbnRseSB1c2luZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGZhbHNlIGlmIHVzaW5nIHNldFRpbWVvdXQuIFRoaXMgbWF5IGJlIGRpZmZlcmVudCB0aGFuIHRpbWluZ01vZGVcblx0ICogaWYgdGhhdCBwcm9wZXJ0eSBjaGFuZ2VkIGFuZCBhIHRpY2sgaGFzbid0IGZpcmVkLlxuXHQgKiBAcHJvcGVydHkgX3JhZlxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9yYWYgPSB0cnVlO1xuXHRcblxuLy8gc3RhdGljIGdldHRlciAvIHNldHRlcnM6XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9pbnRlcnZhbDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIHNldEludGVydmFsXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGludGVydmFsXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLnNldEludGVydmFsID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcblx0XHRUaWNrZXIuX2ludGVydmFsID0gaW50ZXJ2YWw7XG5cdFx0aWYgKCFUaWNrZXIuX2luaXRlZCkgeyByZXR1cm47IH1cblx0XHRUaWNrZXIuX3NldHVwVGljaygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9pbnRlcnZhbDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldEludGVydmFsXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdFRpY2tlci5nZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBUaWNrZXIuX2ludGVydmFsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9mcmFtZXJhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBzZXRGUFNcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuc2V0RlBTID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRUaWNrZXIuc2V0SW50ZXJ2YWwoMTAwMC92YWx1ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2ZyYW1lcmF0ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldEZQU1xuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuZ2V0RlBTID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIDEwMDAvVGlja2VyLl9pbnRlcnZhbDtcblx0fTtcblxuXHQvKipcblx0ICogSW5kaWNhdGVzIHRoZSB0YXJnZXQgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSBiZXR3ZWVuIHRpY2tzLiBEZWZhdWx0IGlzIDUwICgyMCBGUFMpLlxuXHQgKiBOb3RlIHRoYXQgYWN0dWFsIHRpbWUgYmV0d2VlbiB0aWNrcyBtYXkgYmUgbW9yZSB0aGFuIHNwZWNpZmllZCBkZXBlbmRpbmcgb24gQ1BVIGxvYWQuXG5cdCAqIFRoaXMgcHJvcGVydHkgaXMgaWdub3JlZCBpZiB0aGUgdGlja2VyIGlzIHVzaW5nIHRoZSBgUkFGYCB0aW1pbmcgbW9kZS5cblx0ICogQHByb3BlcnR5IGludGVydmFsXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICoqL1xuXHQgXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgdGhlIHRhcmdldCBmcmFtZSByYXRlIGluIGZyYW1lcyBwZXIgc2Vjb25kIChGUFMpLiBFZmZlY3RpdmVseSBqdXN0IGEgc2hvcnRjdXQgdG8gYGludGVydmFsYCwgd2hlcmVcblx0ICogYGZyYW1lcmF0ZSA9PSAxMDAwL2ludGVydmFsYC5cblx0ICogQHByb3BlcnR5IGZyYW1lcmF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqKi9cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhUaWNrZXIsIHtcblx0XHRcdGludGVydmFsOiB7IGdldDogVGlja2VyLmdldEludGVydmFsLCBzZXQ6IFRpY2tlci5zZXRJbnRlcnZhbCB9LFxuXHRcdFx0ZnJhbWVyYXRlOiB7IGdldDogVGlja2VyLmdldEZQUywgc2V0OiBUaWNrZXIuc2V0RlBTIH1cblx0XHR9KTtcblx0fSBjYXRjaCAoZSkgeyBjb25zb2xlLmxvZyhlKTsgfVxuXG5cbi8vIHB1YmxpYyBzdGF0aWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFN0YXJ0cyB0aGUgdGljay4gVGhpcyBpcyBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBmaXJzdCBsaXN0ZW5lciBpcyBhZGRlZC5cblx0ICogQG1ldGhvZCBpbml0XG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUaWNrZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChUaWNrZXIuX2luaXRlZCkgeyByZXR1cm47IH1cblx0XHRUaWNrZXIuX2luaXRlZCA9IHRydWU7XG5cdFx0VGlja2VyLl90aW1lcyA9IFtdO1xuXHRcdFRpY2tlci5fdGlja1RpbWVzID0gW107XG5cdFx0VGlja2VyLl9zdGFydFRpbWUgPSBUaWNrZXIuX2dldFRpbWUoKTtcblx0XHRUaWNrZXIuX3RpbWVzLnB1c2goVGlja2VyLl9sYXN0VGltZSA9IDApO1xuXHRcdFRpY2tlci5pbnRlcnZhbCA9IFRpY2tlci5faW50ZXJ2YWw7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU3RvcHMgdGhlIFRpY2tlciBhbmQgcmVtb3ZlcyBhbGwgbGlzdGVuZXJzLiBVc2UgaW5pdCgpIHRvIHJlc3RhcnQgdGhlIFRpY2tlci5cblx0ICogQG1ldGhvZCByZXNldFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VGlja2VyLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKFRpY2tlci5fcmFmKSB7XG5cdFx0XHR2YXIgZiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5vQ2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cdFx0XHRmJiZmKFRpY2tlci5fdGltZXJJZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNsZWFyVGltZW91dChUaWNrZXIuX3RpbWVySWQpO1xuXHRcdH1cblx0XHRUaWNrZXIucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoXCJ0aWNrXCIpO1xuXHRcdFRpY2tlci5fdGltZXJJZCA9IFRpY2tlci5fdGltZXMgPSBUaWNrZXIuX3RpY2tUaW1lcyA9IG51bGw7XG5cdFx0VGlja2VyLl9zdGFydFRpbWUgPSBUaWNrZXIuX2xhc3RUaW1lID0gVGlja2VyLl90aWNrcyA9IDA7XG5cdFx0VGlja2VyLl9pbml0ZWQgPSBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYXZlcmFnZSB0aW1lIHNwZW50IHdpdGhpbiBhIHRpY2suIFRoaXMgY2FuIHZhcnkgc2lnbmlmaWNhbnRseSBmcm9tIHRoZSB2YWx1ZSBwcm92aWRlZCBieSBnZXRNZWFzdXJlZEZQU1xuXHQgKiBiZWNhdXNlIGl0IG9ubHkgbWVhc3VyZXMgdGhlIHRpbWUgc3BlbnQgd2l0aGluIHRoZSB0aWNrIGV4ZWN1dGlvbiBzdGFjay4gXG5cdCAqIFxuXHQgKiBFeGFtcGxlIDE6IFdpdGggYSB0YXJnZXQgRlBTIG9mIDIwLCBnZXRNZWFzdXJlZEZQUygpIHJldHVybnMgMjBmcHMsIHdoaWNoIGluZGljYXRlcyBhbiBhdmVyYWdlIG9mIDUwbXMgYmV0d2VlbiBcblx0ICogdGhlIGVuZCBvZiBvbmUgdGljayBhbmQgdGhlIGVuZCBvZiB0aGUgbmV4dC4gSG93ZXZlciwgZ2V0TWVhc3VyZWRUaWNrVGltZSgpIHJldHVybnMgMTVtcy4gVGhpcyBpbmRpY2F0ZXMgdGhhdCBcblx0ICogdGhlcmUgbWF5IGJlIHVwIHRvIDM1bXMgb2YgXCJpZGxlXCIgdGltZSBiZXR3ZWVuIHRoZSBlbmQgb2Ygb25lIHRpY2sgYW5kIHRoZSBzdGFydCBvZiB0aGUgbmV4dC5cblx0ICpcblx0ICogRXhhbXBsZSAyOiBXaXRoIGEgdGFyZ2V0IEZQUyBvZiAzMCwgZ2V0RlBTKCkgcmV0dXJucyAxMGZwcywgd2hpY2ggaW5kaWNhdGVzIGFuIGF2ZXJhZ2Ugb2YgMTAwbXMgYmV0d2VlbiB0aGUgZW5kIG9mXG5cdCAqIG9uZSB0aWNrIGFuZCB0aGUgZW5kIG9mIHRoZSBuZXh0LiBIb3dldmVyLCBnZXRNZWFzdXJlZFRpY2tUaW1lKCkgcmV0dXJucyAyMG1zLiBUaGlzIHdvdWxkIGluZGljYXRlIHRoYXQgc29tZXRoaW5nXG5cdCAqIG90aGVyIHRoYW4gdGhlIHRpY2sgaXMgdXNpbmcgfjgwbXMgKGFub3RoZXIgc2NyaXB0LCBET00gcmVuZGVyaW5nLCBldGMpLlxuXHQgKiBAbWV0aG9kIGdldE1lYXN1cmVkVGlja1RpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RpY2tzXSBUaGUgbnVtYmVyIG9mIHByZXZpb3VzIHRpY2tzIG92ZXIgd2hpY2ggdG8gbWVhc3VyZSB0aGUgYXZlcmFnZSB0aW1lIHNwZW50IGluIGEgdGljay5cblx0ICogRGVmYXVsdHMgdG8gdGhlIG51bWJlciBvZiB0aWNrcyBwZXIgc2Vjb25kLiBUbyBnZXQgb25seSB0aGUgbGFzdCB0aWNrJ3MgdGltZSwgcGFzcyBpbiAxLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBhdmVyYWdlIHRpbWUgc3BlbnQgaW4gYSB0aWNrIGluIG1pbGxpc2Vjb25kcy5cblx0ICoqL1xuXHRUaWNrZXIuZ2V0TWVhc3VyZWRUaWNrVGltZSA9IGZ1bmN0aW9uKHRpY2tzKSB7XG5cdFx0dmFyIHR0bD0wLCB0aW1lcz1UaWNrZXIuX3RpY2tUaW1lcztcblx0XHRpZiAoIXRpbWVzIHx8IHRpbWVzLmxlbmd0aCA8IDEpIHsgcmV0dXJuIC0xOyB9XG5cblx0XHQvLyBieSBkZWZhdWx0LCBjYWxjdWxhdGUgYXZlcmFnZSBmb3IgdGhlIHBhc3QgfjEgc2Vjb25kOlxuXHRcdHRpY2tzID0gTWF0aC5taW4odGltZXMubGVuZ3RoLCB0aWNrc3x8KFRpY2tlci5nZXRGUFMoKXwwKSk7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPHRpY2tzOyBpKyspIHsgdHRsICs9IHRpbWVzW2ldOyB9XG5cdFx0cmV0dXJuIHR0bC90aWNrcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYWN0dWFsIGZyYW1lcyAvIHRpY2tzIHBlciBzZWNvbmQuXG5cdCAqIEBtZXRob2QgZ2V0TWVhc3VyZWRGUFNcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RpY2tzXSBUaGUgbnVtYmVyIG9mIHByZXZpb3VzIHRpY2tzIG92ZXIgd2hpY2ggdG8gbWVhc3VyZSB0aGUgYWN0dWFsIGZyYW1lcyAvIHRpY2tzIHBlciBzZWNvbmQuXG5cdCAqIERlZmF1bHRzIHRvIHRoZSBudW1iZXIgb2YgdGlja3MgcGVyIHNlY29uZC5cblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgYWN0dWFsIGZyYW1lcyAvIHRpY2tzIHBlciBzZWNvbmQuIERlcGVuZGluZyBvbiBwZXJmb3JtYW5jZSwgdGhpcyBtYXkgZGlmZmVyXG5cdCAqIGZyb20gdGhlIHRhcmdldCBmcmFtZXMgcGVyIHNlY29uZC5cblx0ICoqL1xuXHRUaWNrZXIuZ2V0TWVhc3VyZWRGUFMgPSBmdW5jdGlvbih0aWNrcykge1xuXHRcdHZhciB0aW1lcyA9IFRpY2tlci5fdGltZXM7XG5cdFx0aWYgKCF0aW1lcyB8fCB0aW1lcy5sZW5ndGggPCAyKSB7IHJldHVybiAtMTsgfVxuXG5cdFx0Ly8gYnkgZGVmYXVsdCwgY2FsY3VsYXRlIGZwcyBmb3IgdGhlIHBhc3QgfjEgc2Vjb25kOlxuXHRcdHRpY2tzID0gTWF0aC5taW4odGltZXMubGVuZ3RoLTEsIHRpY2tzfHwoVGlja2VyLmdldEZQUygpfDApKTtcblx0XHRyZXR1cm4gMTAwMC8oKHRpbWVzWzBdLXRpbWVzW3RpY2tzXSkvdGlja3MpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9wYXVzZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBzZXRQYXVzZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLnNldFBhdXNlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0Ly8gVE9ETzogZGVwcmVjYXRlZC5cblx0XHRUaWNrZXIucGF1c2VkID0gdmFsdWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3BhdXNlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldFBhdXNlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLmdldFBhdXNlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFRPRE86IGRlcHJlY2F0ZWQuXG5cdFx0cmV0dXJuIFRpY2tlci5wYXVzZWQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2UgVGlja2VyIHdhcyBpbml0aWFsaXplZCB2aWEge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2luaXRcIn19LlxuXHQgKiBSZXR1cm5zIC0xIGlmIFRpY2tlciBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQuIEZvciBleGFtcGxlLCB5b3UgY291bGQgdXNlXG5cdCAqIHRoaXMgaW4gYSB0aW1lIHN5bmNocm9uaXplZCBhbmltYXRpb24gdG8gZGV0ZXJtaW5lIHRoZSBleGFjdCBhbW91bnQgb2YgdGltZSB0aGF0IGhhcyBlbGFwc2VkLlxuXHQgKiBAbWV0aG9kIGdldFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtydW5UaW1lPWZhbHNlXSBJZiB0cnVlIG9ubHkgdGltZSBlbGFwc2VkIHdoaWxlIFRpY2tlciB3YXMgbm90IHBhdXNlZCB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBJZiBmYWxzZSwgdGhlIHZhbHVlIHJldHVybmVkIHdpbGwgYmUgdG90YWwgdGltZSBlbGFwc2VkIHNpbmNlIHRoZSBmaXJzdCB0aWNrIGV2ZW50IGxpc3RlbmVyIHdhcyBhZGRlZC5cblx0ICogQHJldHVybiB7TnVtYmVyfSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlIFRpY2tlciB3YXMgaW5pdGlhbGl6ZWQgb3IgLTEuXG5cdCAqKi9cblx0VGlja2VyLmdldFRpbWUgPSBmdW5jdGlvbihydW5UaW1lKSB7XG5cdFx0cmV0dXJuIFRpY2tlci5fc3RhcnRUaW1lID8gVGlja2VyLl9nZXRUaW1lKCkgLSAocnVuVGltZSA/IFRpY2tlci5fcGF1c2VkVGltZSA6IDApIDogLTE7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNpbWlsYXIgdG8gdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9nZXRUaW1lXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCwgYnV0IHJldHVybnMgdGhlIHRpbWUgb24gdGhlIG1vc3QgcmVjZW50IHt7I2Nyb3NzTGluayBcIlRpY2tlci90aWNrOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IG9iamVjdC5cblx0ICogQG1ldGhvZCBnZXRFdmVudFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0gcnVuVGltZSB7Qm9vbGVhbn0gW3J1blRpbWU9ZmFsc2VdIElmIHRydWUsIHRoZSBydW5UaW1lIHByb3BlcnR5IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiB0aW1lLlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgdGltZSBvciBydW5UaW1lIHByb3BlcnR5IGZyb20gdGhlIG1vc3QgcmVjZW50IHRpY2sgZXZlbnQgb3IgLTEuXG5cdCAqL1xuXHRUaWNrZXIuZ2V0RXZlbnRUaW1lID0gZnVuY3Rpb24ocnVuVGltZSkge1xuXHRcdHJldHVybiBUaWNrZXIuX3N0YXJ0VGltZSA/IChUaWNrZXIuX2xhc3RUaW1lIHx8IFRpY2tlci5fc3RhcnRUaW1lKSAtIChydW5UaW1lID8gVGlja2VyLl9wYXVzZWRUaW1lIDogMCkgOiAtMTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGlja3MgdGhhdCBoYXZlIGJlZW4gYnJvYWRjYXN0IGJ5IFRpY2tlci5cblx0ICogQG1ldGhvZCBnZXRUaWNrc1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcGF1c2VhYmxlIEluZGljYXRlcyB3aGV0aGVyIHRvIGluY2x1ZGUgdGlja3MgdGhhdCB3b3VsZCBoYXZlIGJlZW4gYnJvYWRjYXN0XG5cdCAqIHdoaWxlIFRpY2tlciB3YXMgcGF1c2VkLiBJZiB0cnVlIG9ubHkgdGljayBldmVudHMgYnJvYWRjYXN0IHdoaWxlIFRpY2tlciBpcyBub3QgcGF1c2VkIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIElmIGZhbHNlLCB0aWNrIGV2ZW50cyB0aGF0IHdvdWxkIGhhdmUgYmVlbiBicm9hZGNhc3Qgd2hpbGUgVGlja2VyIHdhcyBwYXVzZWQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcmV0dXJuXG5cdCAqIHZhbHVlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBmYWxzZS5cblx0ICogQHJldHVybiB7TnVtYmVyfSBvZiB0aWNrcyB0aGF0IGhhdmUgYmVlbiBicm9hZGNhc3QuXG5cdCAqKi9cblx0VGlja2VyLmdldFRpY2tzID0gZnVuY3Rpb24ocGF1c2VhYmxlKSB7XG5cdFx0cmV0dXJuICBUaWNrZXIuX3RpY2tzIC0gKHBhdXNlYWJsZSA/IFRpY2tlci5fcGF1c2VkVGlja3MgOiAwKTtcblx0fTtcblxuXG4vLyBwcml2YXRlIHN0YXRpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlU3luY2hcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9oYW5kbGVTeW5jaCA9IGZ1bmN0aW9uKCkge1xuXHRcdFRpY2tlci5fdGltZXJJZCA9IG51bGw7XG5cdFx0VGlja2VyLl9zZXR1cFRpY2soKTtcblxuXHRcdC8vIHJ1biBpZiBlbm91Z2ggdGltZSBoYXMgZWxhcHNlZCwgd2l0aCBhIGxpdHRsZSBiaXQgb2YgZmxleGliaWxpdHkgdG8gYmUgZWFybHk6XG5cdFx0aWYgKFRpY2tlci5fZ2V0VGltZSgpIC0gVGlja2VyLl9sYXN0VGltZSA+PSAoVGlja2VyLl9pbnRlcnZhbC0xKSowLjk3KSB7XG5cdFx0XHRUaWNrZXIuX3RpY2soKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVJBRlxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX2hhbmRsZVJBRiA9IGZ1bmN0aW9uKCkge1xuXHRcdFRpY2tlci5fdGltZXJJZCA9IG51bGw7XG5cdFx0VGlja2VyLl9zZXR1cFRpY2soKTtcblx0XHRUaWNrZXIuX3RpY2soKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlVGltZW91dFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX2hhbmRsZVRpbWVvdXQgPSBmdW5jdGlvbigpIHtcblx0XHRUaWNrZXIuX3RpbWVySWQgPSBudWxsO1xuXHRcdFRpY2tlci5fc2V0dXBUaWNrKCk7XG5cdFx0VGlja2VyLl90aWNrKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3NldHVwVGlja1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3NldHVwVGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChUaWNrZXIuX3RpbWVySWQgIT0gbnVsbCkgeyByZXR1cm47IH0gLy8gYXZvaWQgZHVwbGljYXRlc1xuXG5cdFx0dmFyIG1vZGUgPSBUaWNrZXIudGltaW5nTW9kZXx8KFRpY2tlci51c2VSQUYmJlRpY2tlci5SQUZfU1lOQ0hFRCk7XG5cdFx0aWYgKG1vZGUgPT0gVGlja2VyLlJBRl9TWU5DSEVEIHx8IG1vZGUgPT0gVGlja2VyLlJBRikge1xuXHRcdFx0dmFyIGYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0XHRpZiAoZikge1xuXHRcdFx0XHRUaWNrZXIuX3RpbWVySWQgPSBmKG1vZGUgPT0gVGlja2VyLlJBRiA/IFRpY2tlci5faGFuZGxlUkFGIDogVGlja2VyLl9oYW5kbGVTeW5jaCk7XG5cdFx0XHRcdFRpY2tlci5fcmFmID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRUaWNrZXIuX3JhZiA9IGZhbHNlO1xuXHRcdFRpY2tlci5fdGltZXJJZCA9IHNldFRpbWVvdXQoVGlja2VyLl9oYW5kbGVUaW1lb3V0LCBUaWNrZXIuX2ludGVydmFsKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfdGlja1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3RpY2sgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGF1c2VkID0gVGlja2VyLnBhdXNlZDtcblx0XHR2YXIgdGltZSA9IFRpY2tlci5fZ2V0VGltZSgpO1xuXHRcdHZhciBlbGFwc2VkVGltZSA9IHRpbWUtVGlja2VyLl9sYXN0VGltZTtcblx0XHRUaWNrZXIuX2xhc3RUaW1lID0gdGltZTtcblx0XHRUaWNrZXIuX3RpY2tzKys7XG5cdFx0XG5cdFx0aWYgKHBhdXNlZCkge1xuXHRcdFx0VGlja2VyLl9wYXVzZWRUaWNrcysrO1xuXHRcdFx0VGlja2VyLl9wYXVzZWRUaW1lICs9IGVsYXBzZWRUaW1lO1xuXHRcdH1cblx0XHRcblx0XHRpZiAoVGlja2VyLmhhc0V2ZW50TGlzdGVuZXIoXCJ0aWNrXCIpKSB7XG5cdFx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJ0aWNrXCIpO1xuXHRcdFx0dmFyIG1heERlbHRhID0gVGlja2VyLm1heERlbHRhO1xuXHRcdFx0ZXZlbnQuZGVsdGEgPSAobWF4RGVsdGEgJiYgZWxhcHNlZFRpbWUgPiBtYXhEZWx0YSkgPyBtYXhEZWx0YSA6IGVsYXBzZWRUaW1lO1xuXHRcdFx0ZXZlbnQucGF1c2VkID0gcGF1c2VkO1xuXHRcdFx0ZXZlbnQudGltZSA9IHRpbWU7XG5cdFx0XHRldmVudC5ydW5UaW1lID0gdGltZS1UaWNrZXIuX3BhdXNlZFRpbWU7XG5cdFx0XHRUaWNrZXIuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdFx0fVxuXHRcdFxuXHRcdFRpY2tlci5fdGlja1RpbWVzLnVuc2hpZnQoVGlja2VyLl9nZXRUaW1lKCktdGltZSk7XG5cdFx0d2hpbGUgKFRpY2tlci5fdGlja1RpbWVzLmxlbmd0aCA+IDEwMCkgeyBUaWNrZXIuX3RpY2tUaW1lcy5wb3AoKTsgfVxuXG5cdFx0VGlja2VyLl90aW1lcy51bnNoaWZ0KHRpbWUpO1xuXHRcdHdoaWxlIChUaWNrZXIuX3RpbWVzLmxlbmd0aCA+IDEwMCkgeyBUaWNrZXIuX3RpbWVzLnBvcCgpOyB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0dmFyIG5vdyA9IHdpbmRvdy5wZXJmb3JtYW5jZSAmJiAocGVyZm9ybWFuY2Uubm93IHx8IHBlcmZvcm1hbmNlLm1vek5vdyB8fCBwZXJmb3JtYW5jZS5tc05vdyB8fCBwZXJmb3JtYW5jZS5vTm93IHx8IHBlcmZvcm1hbmNlLndlYmtpdE5vdyk7XG5cdFRpY2tlci5fZ2V0VGltZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAoKG5vdyYmbm93LmNhbGwocGVyZm9ybWFuY2UpKXx8KG5ldyBEYXRlKCkuZ2V0VGltZSgpKSkgLSBUaWNrZXIuX3N0YXJ0VGltZTtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLlRpY2tlciA9IFRpY2tlcjtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBVSUQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEdsb2JhbCB1dGlsaXR5IGZvciBnZW5lcmF0aW5nIHNlcXVlbnRpYWwgdW5pcXVlIElEIG51bWJlcnMuIFRoZSBVSUQgY2xhc3MgdXNlcyBhIHN0YXRpYyBpbnRlcmZhY2UgKGV4LiA8Y29kZT5VSUQuZ2V0KCk8L2NvZGU+KVxuXHQgKiBhbmQgc2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQuXG5cdCAqIEBjbGFzcyBVSURcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdGZ1bmN0aW9uIFVJRCgpIHtcblx0XHR0aHJvdyBcIlVJRCBjYW5ub3QgYmUgaW5zdGFudGlhdGVkXCI7XG5cdH1cblxuXG4vLyBwcml2YXRlIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQHByb3BlcnR5IF9uZXh0SURcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRVSUQuX25leHRJRCA9IDA7XG5cblxuLy8gcHVibGljIHN0YXRpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbmV4dCB1bmlxdWUgaWQuXG5cdCAqIEBtZXRob2QgZ2V0XG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIG5leHQgdW5pcXVlIGlkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRVSUQuZ2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFVJRC5fbmV4dElEKys7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5VSUQgPSBVSUQ7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gTW91c2VFdmVudC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogUGFzc2VkIGFzIHRoZSBwYXJhbWV0ZXIgdG8gYWxsIG1vdXNlL3BvaW50ZXIvdG91Y2ggcmVsYXRlZCBldmVudHMuIEZvciBhIGxpc3Rpbmcgb2YgbW91c2UgZXZlbnRzIGFuZCB0aGVpciBwcm9wZXJ0aWVzLFxuXHQgKiBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3RcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGxpc3RpbmdzLlxuXHQgKiBAY2xhc3MgTW91c2VFdmVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBidWJibGVzIEluZGljYXRlcyB3aGV0aGVyIHRoZSBldmVudCB3aWxsIGJ1YmJsZSB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FuY2VsYWJsZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdGhpcyBldmVudCBjYW4gYmUgY2FuY2VsbGVkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhZ2VYIFRoZSBub3JtYWxpemVkIHggcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHN0YWdlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhZ2VZIFRoZSBub3JtYWxpemVkIHkgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHN0YWdlLlxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IG5hdGl2ZUV2ZW50IFRoZSBuYXRpdmUgRE9NIGV2ZW50IHJlbGF0ZWQgdG8gdGhpcyBtb3VzZSBldmVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50ZXJJRCBUaGUgdW5pcXVlIGlkIGZvciB0aGUgcG9pbnRlci5cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmltYXJ5IEluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgdGhlIHByaW1hcnkgcG9pbnRlciBpbiBhIG11bHRpdG91Y2ggZW52aXJvbm1lbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYXdYIFRoZSByYXcgeCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhZ2UuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYXdZIFRoZSByYXcgeSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhZ2UuXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gcmVsYXRlZFRhcmdldCBUaGUgc2Vjb25kYXJ5IHRhcmdldCBmb3IgdGhlIGV2ZW50LlxuXHQgKiBAZXh0ZW5kcyBFdmVudFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBNb3VzZUV2ZW50KHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUsIHN0YWdlWCwgc3RhZ2VZLCBuYXRpdmVFdmVudCwgcG9pbnRlcklELCBwcmltYXJ5LCByYXdYLCByYXdZLCByZWxhdGVkVGFyZ2V0KSB7XG5cdFx0dGhpcy5FdmVudF9jb25zdHJ1Y3Rvcih0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlKTtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIG5vcm1hbGl6ZWQgeCBwb3NpdGlvbiBvbiB0aGUgc3RhZ2UuIFRoaXMgd2lsbCBhbHdheXMgYmUgd2l0aGluIHRoZSByYW5nZSAwIHRvIHN0YWdlIHdpZHRoLlxuXHRcdCAqIEBwcm9wZXJ0eSBzdGFnZVhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQqL1xuXHRcdHRoaXMuc3RhZ2VYID0gc3RhZ2VYO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgbm9ybWFsaXplZCB5IHBvc2l0aW9uIG9uIHRoZSBzdGFnZS4gVGhpcyB3aWxsIGFsd2F5cyBiZSB3aXRoaW4gdGhlIHJhbmdlIDAgdG8gc3RhZ2UgaGVpZ2h0LlxuXHRcdCAqIEBwcm9wZXJ0eSBzdGFnZVlcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5zdGFnZVkgPSBzdGFnZVk7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSByYXcgeCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhZ2UuIE5vcm1hbGx5IHRoaXMgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgc3RhZ2VYIHZhbHVlLCB1bmxlc3Ncblx0XHQgKiBzdGFnZS5tb3VzZU1vdmVPdXRzaWRlIGlzIHRydWUgYW5kIHRoZSBwb2ludGVyIGlzIG91dHNpZGUgb2YgdGhlIHN0YWdlIGJvdW5kcy5cblx0XHQgKiBAcHJvcGVydHkgcmF3WFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCovXG5cdFx0dGhpcy5yYXdYID0gKHJhd1g9PW51bGwpP3N0YWdlWDpyYXdYO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgcmF3IHkgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHN0YWdlLiBOb3JtYWxseSB0aGlzIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIHN0YWdlWSB2YWx1ZSwgdW5sZXNzXG5cdFx0ICogc3RhZ2UubW91c2VNb3ZlT3V0c2lkZSBpcyB0cnVlIGFuZCB0aGUgcG9pbnRlciBpcyBvdXRzaWRlIG9mIHRoZSBzdGFnZSBib3VuZHMuXG5cdFx0ICogQHByb3BlcnR5IHJhd1lcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQqL1xuXHRcdHRoaXMucmF3WSA9IChyYXdZPT1udWxsKT9zdGFnZVk6cmF3WTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIG5hdGl2ZSBNb3VzZUV2ZW50IGdlbmVyYXRlZCBieSB0aGUgYnJvd3Nlci4gVGhlIHByb3BlcnRpZXMgYW5kIEFQSSBmb3IgdGhpc1xuXHRcdCAqIGV2ZW50IG1heSBkaWZmZXIgYmV0d2VlbiBicm93c2Vycy4gVGhpcyBwcm9wZXJ0eSB3aWxsIGJlIG51bGwgaWYgdGhlXG5cdFx0ICogRWFzZWxKUyBwcm9wZXJ0eSB3YXMgbm90IGRpcmVjdGx5IGdlbmVyYXRlZCBmcm9tIGEgbmF0aXZlIE1vdXNlRXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IG5hdGl2ZUV2ZW50XG5cdFx0ICogQHR5cGUgSHRtbE1vdXNlRXZlbnRcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHVuaXF1ZSBpZCBmb3IgdGhlIHBvaW50ZXIgKHRvdWNoIHBvaW50IG9yIGN1cnNvcikuIFRoaXMgd2lsbCBiZSBlaXRoZXIgLTEgZm9yIHRoZSBtb3VzZSwgb3IgdGhlIHN5c3RlbVxuXHRcdCAqIHN1cHBsaWVkIGlkIHZhbHVlLlxuXHRcdCAqIEBwcm9wZXJ0eSBwb2ludGVySURcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMucG9pbnRlcklEID0gcG9pbnRlcklEO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIHRoZSBwcmltYXJ5IHBvaW50ZXIgaW4gYSBtdWx0aXRvdWNoIGVudmlyb25tZW50LiBUaGlzIHdpbGwgYWx3YXlzIGJlIHRydWUgZm9yIHRoZSBtb3VzZS5cblx0XHQgKiBGb3IgdG91Y2ggcG9pbnRlcnMsIHRoZSBmaXJzdCBwb2ludGVyIGluIHRoZSBjdXJyZW50IHN0YWNrIHdpbGwgYmUgY29uc2lkZXJlZCB0aGUgcHJpbWFyeSBwb2ludGVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBwcmltYXJ5XG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0dGhpcy5wcmltYXJ5ID0gISFwcmltYXJ5O1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBzZWNvbmRhcnkgdGFyZ2V0IGZvciB0aGUgZXZlbnQsIGlmIGFwcGxpY2FibGUuIFRoaXMgaXMgdXNlZCBmb3IgbW91c2VvdXQvcm9sbG91dFxuXHRcdCAqIGV2ZW50cyB0byBpbmRpY2F0ZSB0aGUgb2JqZWN0IHRoYXQgdGhlIG1vdXNlIGVudGVyZWQgZnJvbSwgbW91c2VvdmVyL3JvbGxvdmVyIGZvciB0aGUgb2JqZWN0IHRoZSBtb3VzZSBleGl0ZWQsXG5cdFx0ICogYW5kIHN0YWdlbW91c2Vkb3duL3N0YWdlbW91c2V1cCBldmVudHMgZm9yIHRoZSBvYmplY3QgdGhhdCB3YXMgdGhlIHVuZGVyIHRoZSBjdXJzb3IsIGlmIGFueS5cblx0XHQgKiBcblx0XHQgKiBPbmx5IHZhbGlkIGludGVyYWN0aW9uIHRhcmdldHMgd2lsbCBiZSByZXR1cm5lZCAoaWUuIG9iamVjdHMgd2l0aCBtb3VzZSBsaXN0ZW5lcnMgb3IgYSBjdXJzb3Igc2V0KS5cblx0XHQgKiBAcHJvcGVydHkgcmVsYXRlZFRhcmdldFxuXHRcdCAqIEB0eXBlIHtEaXNwbGF5T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHJlbGF0ZWRUYXJnZXQ7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoTW91c2VFdmVudCwgY3JlYXRlanMuRXZlbnQpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXHRcblx0XG4vLyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgbW91c2UgaW4gdGhlIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtIG9mIHRoZSBjdXJyZW50IHRhcmdldCAoaWUuIHRoZSBkaXNwYXRjaGVyKS5cblx0ICogQHByb3BlcnR5IGxvY2FsWFxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcmVhZG9ubHlcblx0ICovXG5cdHAuX2dldF9sb2NhbFggPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jdXJyZW50VGFyZ2V0Lmdsb2JhbFRvTG9jYWwodGhpcy5yYXdYLCB0aGlzLnJhd1kpLng7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgeSBwb3NpdGlvbiBvZiB0aGUgbW91c2UgaW4gdGhlIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtIG9mIHRoZSBjdXJyZW50IHRhcmdldCAoaWUuIHRoZSBkaXNwYXRjaGVyKS5cblx0ICogQHByb3BlcnR5IGxvY2FsWVxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcmVhZG9ubHlcblx0ICovXG5cdHAuX2dldF9sb2NhbFkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jdXJyZW50VGFyZ2V0Lmdsb2JhbFRvTG9jYWwodGhpcy5yYXdYLCB0aGlzLnJhd1kpLnk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IHdhcyBnZW5lcmF0ZWQgYnkgYSB0b3VjaCBpbnB1dCAodmVyc3VzIGEgbW91c2UgaW5wdXQpLlxuXHQgKiBAcHJvcGVydHkgaXNUb3VjaFxuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQHJlYWRvbmx5XG5cdCAqL1xuXHRwLl9nZXRfaXNUb3VjaCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnBvaW50ZXJJRCAhPT0gLTE7XG5cdH07XG5cdFxuXHRcblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cdFx0XHRsb2NhbFg6IHsgZ2V0OiBwLl9nZXRfbG9jYWxYIH0sXG5cdFx0XHRsb2NhbFk6IHsgZ2V0OiBwLl9nZXRfbG9jYWxZIH0sXG5cdFx0XHRpc1RvdWNoOiB7IGdldDogcC5fZ2V0X2lzVG91Y2ggfVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlKSB7fSAvLyBUT0RPOiB1c2UgTG9nXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIE1vdXNlRXZlbnQgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7TW91c2VFdmVudH0gYSBjbG9uZSBvZiB0aGUgTW91c2VFdmVudCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBNb3VzZUV2ZW50KHRoaXMudHlwZSwgdGhpcy5idWJibGVzLCB0aGlzLmNhbmNlbGFibGUsIHRoaXMuc3RhZ2VYLCB0aGlzLnN0YWdlWSwgdGhpcy5uYXRpdmVFdmVudCwgdGhpcy5wb2ludGVySUQsIHRoaXMucHJpbWFyeSwgdGhpcy5yYXdYLCB0aGlzLnJhd1kpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbTW91c2VFdmVudCAodHlwZT1cIit0aGlzLnR5cGUrXCIgc3RhZ2VYPVwiK3RoaXMuc3RhZ2VYK1wiIHN0YWdlWT1cIit0aGlzLnN0YWdlWStcIildXCI7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5Nb3VzZUV2ZW50ID0gY3JlYXRlanMucHJvbW90ZShNb3VzZUV2ZW50LCBcIkV2ZW50XCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIE1hdHJpeDJELmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBSZXByZXNlbnRzIGFuIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXgsIGFuZCBwcm92aWRlcyB0b29scyBmb3IgY29uc3RydWN0aW5nIGFuZCBjb25jYXRlbmF0aW5nIG1hdHJpY2VzLlxuXHQgKlxuXHQgKiBUaGlzIG1hdHJpeCBjYW4gYmUgdmlzdWFsaXplZCBhczpcblx0ICpcblx0ICogXHRbIGEgIGMgIHR4XG5cdCAqIFx0ICBiICBkICB0eVxuXHQgKiBcdCAgMCAgMCAgMSAgXVxuXHQgKlxuXHQgKiBOb3RlIHRoZSBsb2NhdGlvbnMgb2YgYiBhbmQgYy5cblx0ICpcblx0ICogQGNsYXNzIE1hdHJpeDJEXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYT0xXSBTcGVjaWZpZXMgdGhlIGEgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2I9MF0gU3BlY2lmaWVzIHRoZSBiIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtjPTBdIFNwZWNpZmllcyB0aGUgYyBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZD0xXSBTcGVjaWZpZXMgdGhlIGQgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3R4PTBdIFNwZWNpZmllcyB0aGUgdHggcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3R5PTBdIFNwZWNpZmllcyB0aGUgdHkgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBNYXRyaXgyRChhLCBiLCBjLCBkLCB0eCwgdHkpIHtcblx0XHR0aGlzLnNldFZhbHVlcyhhLGIsYyxkLHR4LHR5KTtcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0Ly8gYXNzaWduZWQgaW4gdGhlIHNldFZhbHVlcyBtZXRob2QuXG5cdFx0LyoqXG5cdFx0ICogUG9zaXRpb24gKDAsIDApIGluIGEgM3gzIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG5cdFx0ICogQHByb3BlcnR5IGFcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uICgwLCAxKSBpbiBhIDN4MyBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuXHRcdCAqIEBwcm9wZXJ0eSBiXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBQb3NpdGlvbiAoMSwgMCkgaW4gYSAzeDMgYWZmaW5lIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0XHQgKiBAcHJvcGVydHkgY1xuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogUG9zaXRpb24gKDEsIDEpIGluIGEgM3gzIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG5cdFx0ICogQHByb3BlcnR5IGRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uICgyLCAwKSBpbiBhIDN4MyBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuXHRcdCAqIEBwcm9wZXJ0eSB0eFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogUG9zaXRpb24gKDIsIDEpIGluIGEgM3gzIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG5cdFx0ICogQHByb3BlcnR5IHR5XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHR9XG5cdHZhciBwID0gTWF0cml4MkQucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBjb25zdGFudHM6XG5cdC8qKlxuXHQgKiBNdWx0aXBsaWVyIGZvciBjb252ZXJ0aW5nIGRlZ3JlZXMgdG8gcmFkaWFucy4gVXNlZCBpbnRlcm5hbGx5IGJ5IE1hdHJpeDJELlxuXHQgKiBAcHJvcGVydHkgREVHX1RPX1JBRFxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0TWF0cml4MkQuREVHX1RPX1JBRCA9IE1hdGguUEkvMTgwO1xuXG5cbi8vIHN0YXRpYyBwdWJsaWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIEFuIGlkZW50aXR5IG1hdHJpeCwgcmVwcmVzZW50aW5nIGEgbnVsbCB0cmFuc2Zvcm1hdGlvbi5cblx0ICogQHByb3BlcnR5IGlkZW50aXR5XG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUgTWF0cml4MkRcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0TWF0cml4MkQuaWRlbnRpdHkgPSBudWxsOyAvLyBzZXQgYXQgYm90dG9tIG9mIGNsYXNzIGRlZmluaXRpb24uXG5cdFxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFNldHMgdGhlIHNwZWNpZmllZCB2YWx1ZXMgb24gdGhpcyBpbnN0YW5jZS4gXG5cdCAqIEBtZXRob2Qgc2V0VmFsdWVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYT0xXSBTcGVjaWZpZXMgdGhlIGEgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2I9MF0gU3BlY2lmaWVzIHRoZSBiIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtjPTBdIFNwZWNpZmllcyB0aGUgYyBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZD0xXSBTcGVjaWZpZXMgdGhlIGQgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3R4PTBdIFNwZWNpZmllcyB0aGUgdHggcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3R5PTBdIFNwZWNpZmllcyB0aGUgdHkgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCovXG5cdHAuc2V0VmFsdWVzID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgdHgsIHR5KSB7XG5cdFx0Ly8gZG9uJ3QgZm9yZ2V0IHRvIHVwZGF0ZSBkb2NzIGluIHRoZSBjb25zdHJ1Y3RvciBpZiB0aGVzZSBjaGFuZ2U6XG5cdFx0dGhpcy5hID0gKGEgPT0gbnVsbCkgPyAxIDogYTtcblx0XHR0aGlzLmIgPSBiIHx8IDA7XG5cdFx0dGhpcy5jID0gYyB8fCAwO1xuXHRcdHRoaXMuZCA9IChkID09IG51bGwpID8gMSA6IGQ7XG5cdFx0dGhpcy50eCA9IHR4IHx8IDA7XG5cdFx0dGhpcy50eSA9IHR5IHx8IDA7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFwcGVuZHMgdGhlIHNwZWNpZmllZCBtYXRyaXggcHJvcGVydGllcyB0byB0aGlzIG1hdHJpeC4gQWxsIHBhcmFtZXRlcnMgYXJlIHJlcXVpcmVkLlxuXHQgKiBUaGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIG11bHRpcGx5aW5nIGAodGhpcyBtYXRyaXgpICogKHNwZWNpZmllZCBtYXRyaXgpYC5cblx0ICogQG1ldGhvZCBhcHBlbmRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHR4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0eVxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAuYXBwZW5kID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgdHgsIHR5KSB7XG5cdFx0dmFyIGExID0gdGhpcy5hO1xuXHRcdHZhciBiMSA9IHRoaXMuYjtcblx0XHR2YXIgYzEgPSB0aGlzLmM7XG5cdFx0dmFyIGQxID0gdGhpcy5kO1xuXHRcdGlmIChhICE9IDEgfHwgYiAhPSAwIHx8IGMgIT0gMCB8fCBkICE9IDEpIHtcblx0XHRcdHRoaXMuYSAgPSBhMSphK2MxKmI7XG5cdFx0XHR0aGlzLmIgID0gYjEqYStkMSpiO1xuXHRcdFx0dGhpcy5jICA9IGExKmMrYzEqZDtcblx0XHRcdHRoaXMuZCAgPSBiMSpjK2QxKmQ7XG5cdFx0fVxuXHRcdHRoaXMudHggPSBhMSp0eCtjMSp0eSt0aGlzLnR4O1xuXHRcdHRoaXMudHkgPSBiMSp0eCtkMSp0eSt0aGlzLnR5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcmVwZW5kcyB0aGUgc3BlY2lmaWVkIG1hdHJpeCBwcm9wZXJ0aWVzIHRvIHRoaXMgbWF0cml4LlxuXHQgKiBUaGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIG11bHRpcGx5aW5nIGAoc3BlY2lmaWVkIG1hdHJpeCkgKiAodGhpcyBtYXRyaXgpYC5cblx0ICogQWxsIHBhcmFtZXRlcnMgYXJlIHJlcXVpcmVkLlxuXHQgKiBAbWV0aG9kIHByZXBlbmRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHR4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0eVxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAucHJlcGVuZCA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuXHRcdHZhciBhMSA9IHRoaXMuYTtcblx0XHR2YXIgYzEgPSB0aGlzLmM7XG5cdFx0dmFyIHR4MSA9IHRoaXMudHg7XG5cblx0XHR0aGlzLmEgID0gYSphMStjKnRoaXMuYjtcblx0XHR0aGlzLmIgID0gYiphMStkKnRoaXMuYjtcblx0XHR0aGlzLmMgID0gYSpjMStjKnRoaXMuZDtcblx0XHR0aGlzLmQgID0gYipjMStkKnRoaXMuZDtcblx0XHR0aGlzLnR4ID0gYSp0eDErYyp0aGlzLnR5K3R4O1xuXHRcdHRoaXMudHkgPSBiKnR4MStkKnRoaXMudHkrdHk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFwcGVuZHMgdGhlIHNwZWNpZmllZCBtYXRyaXggdG8gdGhpcyBtYXRyaXguXG5cdCAqIFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgbXVsdGlwbHlpbmcgYCh0aGlzIG1hdHJpeCkgKiAoc3BlY2lmaWVkIG1hdHJpeClgLlxuXHQgKiBAbWV0aG9kIGFwcGVuZE1hdHJpeFxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXhcblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLmFwcGVuZE1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChtYXRyaXguYSwgbWF0cml4LmIsIG1hdHJpeC5jLCBtYXRyaXguZCwgbWF0cml4LnR4LCBtYXRyaXgudHkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcmVwZW5kcyB0aGUgc3BlY2lmaWVkIG1hdHJpeCB0byB0aGlzIG1hdHJpeC5cblx0ICogVGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiBtdWx0aXBseWluZyBgKHNwZWNpZmllZCBtYXRyaXgpICogKHRoaXMgbWF0cml4KWAuXG5cdCAqIEZvciBleGFtcGxlLCB5b3UgY291bGQgY2FsY3VsYXRlIHRoZSBjb21iaW5lZCB0cmFuc2Zvcm1hdGlvbiBmb3IgYSBjaGlsZCBvYmplY3QgdXNpbmc6XG5cdCAqIFxuXHQgKiBcdHZhciBvID0gbXlEaXNwbGF5T2JqZWN0O1xuXHQgKiBcdHZhciBtdHggPSBvLmdldE1hdHJpeCgpO1xuXHQgKiBcdHdoaWxlIChvID0gby5wYXJlbnQpIHtcblx0ICogXHRcdC8vIHByZXBlbmQgZWFjaCBwYXJlbnQncyB0cmFuc2Zvcm1hdGlvbiBpbiB0dXJuOlxuXHQgKiBcdFx0by5wcmVwZW5kTWF0cml4KG8uZ2V0TWF0cml4KCkpO1xuXHQgKiBcdH1cblx0ICogQG1ldGhvZCBwcmVwZW5kTWF0cml4XG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeFxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAucHJlcGVuZE1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHJldHVybiB0aGlzLnByZXBlbmQobWF0cml4LmEsIG1hdHJpeC5iLCBtYXRyaXguYywgbWF0cml4LmQsIG1hdHJpeC50eCwgbWF0cml4LnR5KTtcblx0fTtcblxuXHQvKipcblx0ICogR2VuZXJhdGVzIG1hdHJpeCBwcm9wZXJ0aWVzIGZyb20gdGhlIHNwZWNpZmllZCBkaXNwbGF5IG9iamVjdCB0cmFuc2Zvcm0gcHJvcGVydGllcywgYW5kIGFwcGVuZHMgdGhlbSB0byB0aGlzIG1hdHJpeC5cblx0ICogRm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlIHRoaXMgdG8gZ2VuZXJhdGUgYSBtYXRyaXggcmVwcmVzZW50aW5nIHRoZSB0cmFuc2Zvcm1hdGlvbnMgb2YgYSBkaXNwbGF5IG9iamVjdDpcblx0ICogXG5cdCAqIFx0dmFyIG10eCA9IG5ldyBNYXRyaXgyRCgpO1xuXHQgKiBcdG10eC5hcHBlbmRUcmFuc2Zvcm0oby54LCBvLnksIG8uc2NhbGVYLCBvLnNjYWxlWSwgby5yb3RhdGlvbik7XG5cdCAqIEBtZXRob2QgYXBwZW5kVHJhbnNmb3JtXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcm90YXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNrZXdYXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBza2V3WVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmVnWCBPcHRpb25hbC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJlZ1kgT3B0aW9uYWwuXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5hcHBlbmRUcmFuc2Zvcm0gPSBmdW5jdGlvbih4LCB5LCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHNrZXdYLCBza2V3WSwgcmVnWCwgcmVnWSkge1xuXHRcdGlmIChyb3RhdGlvbiUzNjApIHtcblx0XHRcdHZhciByID0gcm90YXRpb24qTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdHZhciBjb3MgPSBNYXRoLmNvcyhyKTtcblx0XHRcdHZhciBzaW4gPSBNYXRoLnNpbihyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29zID0gMTtcblx0XHRcdHNpbiA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKHNrZXdYIHx8IHNrZXdZKSB7XG5cdFx0XHQvLyBUT0RPOiBjYW4gdGhpcyBiZSBjb21iaW5lZCBpbnRvIGEgc2luZ2xlIGFwcGVuZCBvcGVyYXRpb24/XG5cdFx0XHRza2V3WCAqPSBNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0c2tld1kgKj0gTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdHRoaXMuYXBwZW5kKE1hdGguY29zKHNrZXdZKSwgTWF0aC5zaW4oc2tld1kpLCAtTWF0aC5zaW4oc2tld1gpLCBNYXRoLmNvcyhza2V3WCksIHgsIHkpO1xuXHRcdFx0dGhpcy5hcHBlbmQoY29zKnNjYWxlWCwgc2luKnNjYWxlWCwgLXNpbipzY2FsZVksIGNvcypzY2FsZVksIDAsIDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFwcGVuZChjb3Mqc2NhbGVYLCBzaW4qc2NhbGVYLCAtc2luKnNjYWxlWSwgY29zKnNjYWxlWSwgeCwgeSk7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChyZWdYIHx8IHJlZ1kpIHtcblx0XHRcdC8vIGFwcGVuZCB0aGUgcmVnaXN0cmF0aW9uIG9mZnNldDpcblx0XHRcdHRoaXMudHggLT0gcmVnWCp0aGlzLmErcmVnWSp0aGlzLmM7IFxuXHRcdFx0dGhpcy50eSAtPSByZWdYKnRoaXMuYityZWdZKnRoaXMuZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBtYXRyaXggcHJvcGVydGllcyBmcm9tIHRoZSBzcGVjaWZpZWQgZGlzcGxheSBvYmplY3QgdHJhbnNmb3JtIHByb3BlcnRpZXMsIGFuZCBwcmVwZW5kcyB0aGVtIHRvIHRoaXMgbWF0cml4LlxuXHQgKiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIGNhbGN1bGF0ZSB0aGUgY29tYmluZWQgdHJhbnNmb3JtYXRpb24gZm9yIGEgY2hpbGQgb2JqZWN0IHVzaW5nOlxuXHQgKiBcblx0ICogXHR2YXIgbyA9IG15RGlzcGxheU9iamVjdDtcblx0ICogXHR2YXIgbXR4ID0gbmV3IGNyZWF0ZWpzLk1hdHJpeDJEKCk7XG5cdCAqIFx0ZG8gIHtcblx0ICogXHRcdC8vIHByZXBlbmQgZWFjaCBwYXJlbnQncyB0cmFuc2Zvcm1hdGlvbiBpbiB0dXJuOlxuXHQgKiBcdFx0bXR4LnByZXBlbmRUcmFuc2Zvcm0oby54LCBvLnksIG8uc2NhbGVYLCBvLnNjYWxlWSwgby5yb3RhdGlvbiwgby5za2V3WCwgby5za2V3WSwgby5yZWdYLCBvLnJlZ1kpO1xuXHQgKiBcdH0gd2hpbGUgKG8gPSBvLnBhcmVudCk7XG5cdCAqIFx0XG5cdCAqIFx0Tm90ZSB0aGF0IHRoZSBhYm92ZSBleGFtcGxlIHdvdWxkIG5vdCBhY2NvdW50IGZvciB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3RyYW5zZm9ybU1hdHJpeDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBcdHZhbHVlcy4gU2VlIHt7I2Nyb3NzTGluayBcIk1hdHJpeDJEL3ByZXBlbmRNYXRyaXhcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGFuIGV4YW1wbGUgdGhhdCBkb2VzLlxuXHQgKiBAbWV0aG9kIHByZXBlbmRUcmFuc2Zvcm1cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVZXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByb3RhdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2tld1hcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNrZXdZXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByZWdYIE9wdGlvbmFsLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmVnWSBPcHRpb25hbC5cblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLnByZXBlbmRUcmFuc2Zvcm0gPSBmdW5jdGlvbih4LCB5LCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHNrZXdYLCBza2V3WSwgcmVnWCwgcmVnWSkge1xuXHRcdGlmIChyb3RhdGlvbiUzNjApIHtcblx0XHRcdHZhciByID0gcm90YXRpb24qTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdHZhciBjb3MgPSBNYXRoLmNvcyhyKTtcblx0XHRcdHZhciBzaW4gPSBNYXRoLnNpbihyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29zID0gMTtcblx0XHRcdHNpbiA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKHJlZ1ggfHwgcmVnWSkge1xuXHRcdFx0Ly8gcHJlcGVuZCB0aGUgcmVnaXN0cmF0aW9uIG9mZnNldDpcblx0XHRcdHRoaXMudHggLT0gcmVnWDsgdGhpcy50eSAtPSByZWdZO1xuXHRcdH1cblx0XHRpZiAoc2tld1ggfHwgc2tld1kpIHtcblx0XHRcdC8vIFRPRE86IGNhbiB0aGlzIGJlIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgcHJlcGVuZCBvcGVyYXRpb24/XG5cdFx0XHRza2V3WCAqPSBNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0c2tld1kgKj0gTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdHRoaXMucHJlcGVuZChjb3Mqc2NhbGVYLCBzaW4qc2NhbGVYLCAtc2luKnNjYWxlWSwgY29zKnNjYWxlWSwgMCwgMCk7XG5cdFx0XHR0aGlzLnByZXBlbmQoTWF0aC5jb3Moc2tld1kpLCBNYXRoLnNpbihza2V3WSksIC1NYXRoLnNpbihza2V3WCksIE1hdGguY29zKHNrZXdYKSwgeCwgeSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucHJlcGVuZChjb3Mqc2NhbGVYLCBzaW4qc2NhbGVYLCAtc2luKnNjYWxlWSwgY29zKnNjYWxlWSwgeCwgeSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIGEgY2xvY2t3aXNlIHJvdGF0aW9uIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBtYXRyaXguXG5cdCAqIEBtZXRob2Qgcm90YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBpbiBkZWdyZWVzLiBUbyB1c2UgYSB2YWx1ZSBpbiByYWRpYW5zLCBtdWx0aXBseSBpdCBieSBgMTgwL01hdGguUElgLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAucm90YXRlID0gZnVuY3Rpb24oYW5nbGUpIHtcblx0XHRhbmdsZSA9IGFuZ2xlKk1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0dmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHR2YXIgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXG5cdFx0dmFyIGExID0gdGhpcy5hO1xuXHRcdHZhciBiMSA9IHRoaXMuYjtcblxuXHRcdHRoaXMuYSA9IGExKmNvcyt0aGlzLmMqc2luO1xuXHRcdHRoaXMuYiA9IGIxKmNvcyt0aGlzLmQqc2luO1xuXHRcdHRoaXMuYyA9IC1hMSpzaW4rdGhpcy5jKmNvcztcblx0XHR0aGlzLmQgPSAtYjEqc2luK3RoaXMuZCpjb3M7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgYSBza2V3IHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBtYXRyaXguXG5cdCAqIEBtZXRob2Qgc2tld1xuXHQgKiBAcGFyYW0ge051bWJlcn0gc2tld1ggVGhlIGFtb3VudCB0byBza2V3IGhvcml6b250YWxseSBpbiBkZWdyZWVzLiBUbyB1c2UgYSB2YWx1ZSBpbiByYWRpYW5zLCBtdWx0aXBseSBpdCBieSBgMTgwL01hdGguUElgLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2tld1kgVGhlIGFtb3VudCB0byBza2V3IHZlcnRpY2FsbHkgaW4gZGVncmVlcy5cblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0Ki9cblx0cC5za2V3ID0gZnVuY3Rpb24oc2tld1gsIHNrZXdZKSB7XG5cdFx0c2tld1ggPSBza2V3WCpNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdHNrZXdZID0gc2tld1kqTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHR0aGlzLmFwcGVuZChNYXRoLmNvcyhza2V3WSksIE1hdGguc2luKHNrZXdZKSwgLU1hdGguc2luKHNrZXdYKSwgTWF0aC5jb3Moc2tld1gpLCAwLCAwKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQXBwbGllcyBhIHNjYWxlIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBtYXRyaXguXG5cdCAqIEBtZXRob2Qgc2NhbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGFtb3VudCB0byBzY2FsZSBob3Jpem9udGFsbHkuIEUuRy4gYSB2YWx1ZSBvZiAyIHdpbGwgZG91YmxlIHRoZSBzaXplIGluIHRoZSBYIGRpcmVjdGlvbiwgYW5kIDAuNSB3aWxsIGhhbHZlIGl0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgYW1vdW50IHRvIHNjYWxlIHZlcnRpY2FsbHkuXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5zY2FsZSA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLmEgKj0geDtcblx0XHR0aGlzLmIgKj0geDtcblx0XHR0aGlzLmMgKj0geTtcblx0XHR0aGlzLmQgKj0geTtcblx0XHQvL3RoaXMudHggKj0geDtcblx0XHQvL3RoaXMudHkgKj0geTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogVHJhbnNsYXRlcyB0aGUgbWF0cml4IG9uIHRoZSB4IGFuZCB5IGF4ZXMuXG5cdCAqIEBtZXRob2QgdHJhbnNsYXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC50cmFuc2xhdGUgPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0dGhpcy50eCArPSB0aGlzLmEqeCArIHRoaXMuYyp5O1xuXHRcdHRoaXMudHkgKz0gdGhpcy5iKnggKyB0aGlzLmQqeTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgcHJvcGVydGllcyBvZiB0aGUgbWF0cml4IHRvIHRob3NlIG9mIGFuIGlkZW50aXR5IG1hdHJpeCAob25lIHRoYXQgYXBwbGllcyBhIG51bGwgdHJhbnNmb3JtYXRpb24pLlxuXHQgKiBAbWV0aG9kIGlkZW50aXR5XG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5pZGVudGl0eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuYSA9IHRoaXMuZCA9IDE7XG5cdFx0dGhpcy5iID0gdGhpcy5jID0gdGhpcy50eCA9IHRoaXMudHkgPSAwO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnZlcnRzIHRoZSBtYXRyaXgsIGNhdXNpbmcgaXQgdG8gcGVyZm9ybSB0aGUgb3Bwb3NpdGUgdHJhbnNmb3JtYXRpb24uXG5cdCAqIEBtZXRob2QgaW52ZXJ0XG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5pbnZlcnQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgYTEgPSB0aGlzLmE7XG5cdFx0dmFyIGIxID0gdGhpcy5iO1xuXHRcdHZhciBjMSA9IHRoaXMuYztcblx0XHR2YXIgZDEgPSB0aGlzLmQ7XG5cdFx0dmFyIHR4MSA9IHRoaXMudHg7XG5cdFx0dmFyIG4gPSBhMSpkMS1iMSpjMTtcblxuXHRcdHRoaXMuYSA9IGQxL247XG5cdFx0dGhpcy5iID0gLWIxL247XG5cdFx0dGhpcy5jID0gLWMxL247XG5cdFx0dGhpcy5kID0gYTEvbjtcblx0XHR0aGlzLnR4ID0gKGMxKnRoaXMudHktZDEqdHgxKS9uO1xuXHRcdHRoaXMudHkgPSAtKGExKnRoaXMudHktYjEqdHgxKS9uO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1hdHJpeCBpcyBhbiBpZGVudGl0eSBtYXRyaXguXG5cdCAqIEBtZXRob2QgaXNJZGVudGl0eVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiovXG5cdHAuaXNJZGVudGl0eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnR4ID09PSAwICYmIHRoaXMudHkgPT09IDAgJiYgdGhpcy5hID09PSAxICYmIHRoaXMuYiA9PT0gMCAmJiB0aGlzLmMgPT09IDAgJiYgdGhpcy5kID09PSAxO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIG1hdHJpeCBpcyBlcXVhbCB0byB0aGUgc3BlY2lmaWVkIG1hdHJpeCAoYWxsIHByb3BlcnR5IHZhbHVlcyBhcmUgZXF1YWwpLlxuXHQgKiBAbWV0aG9kIGVxdWFsc1xuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXggVGhlIG1hdHJpeCB0byBjb21wYXJlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiovXG5cdHAuZXF1YWxzID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0cmV0dXJuIHRoaXMudHggPT09IG1hdHJpeC50eCAmJiB0aGlzLnR5ID09PSBtYXRyaXgudHkgJiYgdGhpcy5hID09PSBtYXRyaXguYSAmJiB0aGlzLmIgPT09IG1hdHJpeC5iICYmIHRoaXMuYyA9PT0gbWF0cml4LmMgJiYgdGhpcy5kID09PSBtYXRyaXguZDtcblx0fTtcblxuXHQvKipcblx0ICogVHJhbnNmb3JtcyBhIHBvaW50IGFjY29yZGluZyB0byB0aGlzIG1hdHJpeC5cblx0ICogQG1ldGhvZCB0cmFuc2Zvcm1Qb2ludFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHBvaW50IHRvIHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50IG9mIHRoZSBwb2ludCB0byB0cmFuc2Zvcm0uXG5cdCAqIEBwYXJhbSB7UG9pbnQgfCBPYmplY3R9IFtwdF0gQW4gb2JqZWN0IHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvLiBJZiBvbWl0dGVkIGEgZ2VuZXJpYyBvYmplY3Qgd2l0aCB4L3kgcHJvcGVydGllcyB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHtQb2ludH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAudHJhbnNmb3JtUG9pbnQgPSBmdW5jdGlvbih4LCB5LCBwdCkge1xuXHRcdHB0ID0gcHR8fHt9O1xuXHRcdHB0LnggPSB4KnRoaXMuYSt5KnRoaXMuYyt0aGlzLnR4O1xuXHRcdHB0LnkgPSB4KnRoaXMuYit5KnRoaXMuZCt0aGlzLnR5O1xuXHRcdHJldHVybiBwdDtcblx0fTtcblxuXHQvKipcblx0ICogRGVjb21wb3NlcyB0aGUgbWF0cml4IGludG8gdHJhbnNmb3JtIHByb3BlcnRpZXMgKHgsIHksIHNjYWxlWCwgc2NhbGVZLCBhbmQgcm90YXRpb24pLiBOb3RlIHRoYXQgdGhlc2UgdmFsdWVzXG5cdCAqIG1heSBub3QgbWF0Y2ggdGhlIHRyYW5zZm9ybSBwcm9wZXJ0aWVzIHlvdSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBtYXRyaXgsIHRob3VnaCB0aGV5IHdpbGwgcHJvZHVjZSB0aGUgc2FtZSB2aXN1YWxcblx0ICogcmVzdWx0cy5cblx0ICogQG1ldGhvZCBkZWNvbXBvc2Vcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRvIGFwcGx5IHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyB0by4gSWYgbnVsbCwgdGhlbiBhIG5ldyBvYmplY3Qgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgdGFyZ2V0LCBvciBhIG5ldyBnZW5lcmljIG9iamVjdCB3aXRoIHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyBhcHBsaWVkLlxuXHQqL1xuXHRwLmRlY29tcG9zZSA9IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdC8vIFRPRE86IGl0IHdvdWxkIGJlIG5pY2UgdG8gYmUgYWJsZSB0byBzb2x2ZSBmb3Igd2hldGhlciB0aGUgbWF0cml4IGNhbiBiZSBkZWNvbXBvc2VkIGludG8gb25seSBzY2FsZS9yb3RhdGlvbiBldmVuIHdoZW4gc2NhbGUgaXMgbmVnYXRpdmVcblx0XHRpZiAodGFyZ2V0ID09IG51bGwpIHsgdGFyZ2V0ID0ge307IH1cblx0XHR0YXJnZXQueCA9IHRoaXMudHg7XG5cdFx0dGFyZ2V0LnkgPSB0aGlzLnR5O1xuXHRcdHRhcmdldC5zY2FsZVggPSBNYXRoLnNxcnQodGhpcy5hICogdGhpcy5hICsgdGhpcy5iICogdGhpcy5iKTtcblx0XHR0YXJnZXQuc2NhbGVZID0gTWF0aC5zcXJ0KHRoaXMuYyAqIHRoaXMuYyArIHRoaXMuZCAqIHRoaXMuZCk7XG5cblx0XHR2YXIgc2tld1ggPSBNYXRoLmF0YW4yKC10aGlzLmMsIHRoaXMuZCk7XG5cdFx0dmFyIHNrZXdZID0gTWF0aC5hdGFuMih0aGlzLmIsIHRoaXMuYSk7XG5cblx0XHR2YXIgZGVsdGEgPSBNYXRoLmFicygxLXNrZXdYL3NrZXdZKTtcblx0XHRpZiAoZGVsdGEgPCAwLjAwMDAxKSB7IC8vIGVmZmVjdGl2ZWx5IGlkZW50aWNhbCwgY2FuIHVzZSByb3RhdGlvbjpcblx0XHRcdHRhcmdldC5yb3RhdGlvbiA9IHNrZXdZL01hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0XHRpZiAodGhpcy5hIDwgMCAmJiB0aGlzLmQgPj0gMCkge1xuXHRcdFx0XHR0YXJnZXQucm90YXRpb24gKz0gKHRhcmdldC5yb3RhdGlvbiA8PSAwKSA/IDE4MCA6IC0xODA7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXQuc2tld1ggPSB0YXJnZXQuc2tld1kgPSAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuc2tld1ggPSBza2V3WC9NYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0dGFyZ2V0LnNrZXdZID0gc2tld1kvTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDb3BpZXMgYWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgc3BlY2lmaWVkIG1hdHJpeCB0byB0aGlzIG1hdHJpeC5cblx0ICogQG1ldGhvZCBjb3B5XG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeCBUaGUgbWF0cml4IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQqL1xuXHRwLmNvcHkgPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRWYWx1ZXMobWF0cml4LmEsIG1hdHJpeC5iLCBtYXRyaXguYywgbWF0cml4LmQsIG1hdHJpeC50eCwgbWF0cml4LnR5KTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBNYXRyaXgyRCBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gYSBjbG9uZSBvZiB0aGUgTWF0cml4MkQgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgTWF0cml4MkQodGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdGhpcy5kLCB0aGlzLnR4LCB0aGlzLnR5KTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW01hdHJpeDJEIChhPVwiK3RoaXMuYStcIiBiPVwiK3RoaXMuYitcIiBjPVwiK3RoaXMuYytcIiBkPVwiK3RoaXMuZCtcIiB0eD1cIit0aGlzLnR4K1wiIHR5PVwiK3RoaXMudHkrXCIpXVwiO1xuXHR9O1xuXG5cdC8vIHRoaXMgaGFzIHRvIGJlIHBvcHVsYXRlZCBhZnRlciB0aGUgY2xhc3MgaXMgZGVmaW5lZDpcblx0TWF0cml4MkQuaWRlbnRpdHkgPSBuZXcgTWF0cml4MkQoKTtcblxuXG5cdGNyZWF0ZWpzLk1hdHJpeDJEID0gTWF0cml4MkQ7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRGlzcGxheVByb3BzLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIFVzZWQgZm9yIGNhbGN1bGF0aW5nIGFuZCBlbmNhcHN1bGF0aW5nIGRpc3BsYXkgcmVsYXRlZCBwcm9wZXJ0aWVzLlxuXHQgKiBAY2xhc3MgRGlzcGxheVByb3BzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdmlzaWJsZT10cnVlXSBWaXNpYmxlIHZhbHVlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2FscGhhPTBdIEFscGhhIHZhbHVlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NoYWRvdz1udWxsXSBBIFNoYWRvdyBpbnN0YW5jZSBvciBudWxsLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2NvbXBvc2l0ZU9wZXJhdGlvbj1udWxsXSBBIGNvbXBvc2l0ZU9wZXJhdGlvbiB2YWx1ZSBvciBudWxsLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW21hdHJpeF0gQSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguIERlZmF1bHRzIHRvIGEgbmV3IGlkZW50aXR5IG1hdHJpeC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gRGlzcGxheVByb3BzKHZpc2libGUsIGFscGhhLCBzaGFkb3csIGNvbXBvc2l0ZU9wZXJhdGlvbiwgbWF0cml4KSB7XG5cdFx0dGhpcy5zZXRWYWx1ZXModmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgY29tcG9zaXRlT3BlcmF0aW9uLCBtYXRyaXgpO1xuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvLyBhc3NpZ25lZCBpbiB0aGUgc2V0VmFsdWVzIG1ldGhvZC5cblx0XHQvKipcblx0XHQgKiBQcm9wZXJ0eSByZXByZXNlbnRpbmcgdGhlIGFscGhhIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGEgZGlzcGxheSBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IGFscGhhXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBQcm9wZXJ0eSByZXByZXNlbnRpbmcgdGhlIHNoYWRvdyB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBhIGRpc3BsYXkgb2JqZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBzaGFkb3dcblx0XHQgKiBAdHlwZSBTaGFkb3dcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFByb3BlcnR5IHJlcHJlc2VudGluZyB0aGUgY29tcG9zaXRlT3BlcmF0aW9uIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGEgZGlzcGxheSBvYmplY3QuXG5cdFx0ICogWW91IGNhbiBmaW5kIGEgbGlzdCBvZiB2YWxpZCBjb21wb3NpdGUgb3BlcmF0aW9ucyBhdDpcblx0XHQgKiA8YSBocmVmPVwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ2FudmFzX3R1dG9yaWFsL0NvbXBvc2l0aW5nXCI+aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ2FudmFzX3R1dG9yaWFsL0NvbXBvc2l0aW5nPC9hPlxuXHRcdCAqIEBwcm9wZXJ0eSBjb21wb3NpdGVPcGVyYXRpb25cblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiovXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUHJvcGVydHkgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBmb3IgdmlzaWJsZSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBhIGRpc3BsYXkgb2JqZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSB2aXNpYmxlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqKi9cblx0XHRcblx0XHQvKipcblx0XHQgKiBUaGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGEgZGlzcGxheSBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IG1hdHJpeFxuXHRcdCAqIEB0eXBlIE1hdHJpeDJEXG5cdFx0ICoqL1xuXHR9XG5cdHZhciBwID0gRGlzcGxheVByb3BzLnByb3RvdHlwZTtcblxuLy8gaW5pdGlhbGl6YXRpb246XG5cdC8qKlxuXHQgKiBSZWluaXRpYWxpemVzIHRoZSBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVzLlxuXHQgKiBAbWV0aG9kIHNldFZhbHVlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3Zpc2libGU9dHJ1ZV0gVmlzaWJsZSB2YWx1ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthbHBoYT0xXSBBbHBoYSB2YWx1ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzaGFkb3c9bnVsbF0gQSBTaGFkb3cgaW5zdGFuY2Ugb3IgbnVsbC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtjb21wb3NpdGVPcGVyYXRpb249bnVsbF0gQSBjb21wb3NpdGVPcGVyYXRpb24gdmFsdWUgb3IgbnVsbC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttYXRyaXhdIEEgdHJhbnNmb3JtYXRpb24gbWF0cml4LiBEZWZhdWx0cyB0byBhbiBpZGVudGl0eSBtYXRyaXguXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlQcm9wc30gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5zZXRWYWx1ZXMgPSBmdW5jdGlvbiAodmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgY29tcG9zaXRlT3BlcmF0aW9uLCBtYXRyaXgpIHtcblx0XHR0aGlzLnZpc2libGUgPSB2aXNpYmxlID09IG51bGwgPyB0cnVlIDogISF2aXNpYmxlO1xuXHRcdHRoaXMuYWxwaGEgPSBhbHBoYSA9PSBudWxsID8gMSA6IGFscGhhO1xuXHRcdHRoaXMuc2hhZG93ID0gc2hhZG93O1xuXHRcdHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uID0gc2hhZG93O1xuXHRcdHRoaXMubWF0cml4ID0gbWF0cml4IHx8ICh0aGlzLm1hdHJpeCYmdGhpcy5tYXRyaXguaWRlbnRpdHkoKSkgfHwgbmV3IGNyZWF0ZWpzLk1hdHJpeDJEKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQXBwZW5kcyB0aGUgc3BlY2lmaWVkIGRpc3BsYXkgcHJvcGVydGllcy4gVGhpcyBpcyBnZW5lcmFsbHkgdXNlZCB0byBhcHBseSBhIGNoaWxkJ3MgcHJvcGVydGllcyBpdHMgcGFyZW50J3MuXG5cdCAqIEBtZXRob2QgYXBwZW5kXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSBkZXNpcmVkIHZpc2libGUgdmFsdWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFscGhhIGRlc2lyZWQgYWxwaGEgdmFsdWVcblx0ICogQHBhcmFtIHtTaGFkb3d9IHNoYWRvdyBkZXNpcmVkIHNoYWRvdyB2YWx1ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9zaXRlT3BlcmF0aW9uIGRlc2lyZWQgY29tcG9zaXRlIG9wZXJhdGlvbiB2YWx1ZVxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBbbWF0cml4XSBhIE1hdHJpeDJEIGluc3RhbmNlXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlQcm9wc30gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5hcHBlbmQgPSBmdW5jdGlvbih2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBjb21wb3NpdGVPcGVyYXRpb24sIG1hdHJpeCkge1xuXHRcdHRoaXMuYWxwaGEgKj0gYWxwaGE7XG5cdFx0dGhpcy5zaGFkb3cgPSBzaGFkb3cgfHwgdGhpcy5zaGFkb3c7XG5cdFx0dGhpcy5jb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGVPcGVyYXRpb24gfHwgdGhpcy5jb21wb3NpdGVPcGVyYXRpb247XG5cdFx0dGhpcy52aXNpYmxlID0gdGhpcy52aXNpYmxlICYmIHZpc2libGU7XG5cdFx0bWF0cml4JiZ0aGlzLm1hdHJpeC5hcHBlbmRNYXRyaXgobWF0cml4KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBQcmVwZW5kcyB0aGUgc3BlY2lmaWVkIGRpc3BsYXkgcHJvcGVydGllcy4gVGhpcyBpcyBnZW5lcmFsbHkgdXNlZCB0byBhcHBseSBhIHBhcmVudCdzIHByb3BlcnRpZXMgdG8gYSBjaGlsZCdzLlxuXHQgKiBGb3IgZXhhbXBsZSwgdG8gZ2V0IHRoZSBjb21iaW5lZCBkaXNwbGF5IHByb3BlcnRpZXMgdGhhdCB3b3VsZCBiZSBhcHBsaWVkIHRvIGEgY2hpbGQsIHlvdSBjb3VsZCB1c2U6XG5cdCAqIFxuXHQgKiBcdHZhciBvID0gbXlEaXNwbGF5T2JqZWN0O1xuXHQgKiBcdHZhciBwcm9wcyA9IG5ldyBjcmVhdGVqcy5EaXNwbGF5UHJvcHMoKTtcblx0ICogXHRkbyB7XG5cdCAqIFx0XHQvLyBwcmVwZW5kIGVhY2ggcGFyZW50J3MgcHJvcHMgaW4gdHVybjpcblx0ICogXHRcdHByb3BzLnByZXBlbmQoby52aXNpYmxlLCBvLmFscGhhLCBvLnNoYWRvdywgby5jb21wb3NpdGVPcGVyYXRpb24sIG8uZ2V0TWF0cml4KCkpO1xuXHQgKiBcdH0gd2hpbGUgKG8gPSBvLnBhcmVudCk7XG5cdCAqIFx0XG5cdCAqIEBtZXRob2QgcHJlcGVuZFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGUgZGVzaXJlZCB2aXNpYmxlIHZhbHVlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbHBoYSBkZXNpcmVkIGFscGhhIHZhbHVlXG5cdCAqIEBwYXJhbSB7U2hhZG93fSBzaGFkb3cgZGVzaXJlZCBzaGFkb3cgdmFsdWVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvc2l0ZU9wZXJhdGlvbiBkZXNpcmVkIGNvbXBvc2l0ZSBvcGVyYXRpb24gdmFsdWVcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gW21hdHJpeF0gYSBNYXRyaXgyRCBpbnN0YW5jZVxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5UHJvcHN9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAucHJlcGVuZCA9IGZ1bmN0aW9uKHZpc2libGUsIGFscGhhLCBzaGFkb3csIGNvbXBvc2l0ZU9wZXJhdGlvbiwgbWF0cml4KSB7XG5cdFx0dGhpcy5hbHBoYSAqPSBhbHBoYTtcblx0XHR0aGlzLnNoYWRvdyA9IHRoaXMuc2hhZG93IHx8IHNoYWRvdztcblx0XHR0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uIHx8IGNvbXBvc2l0ZU9wZXJhdGlvbjtcblx0XHR0aGlzLnZpc2libGUgPSB0aGlzLnZpc2libGUgJiYgdmlzaWJsZTtcblx0XHRtYXRyaXgmJnRoaXMubWF0cml4LnByZXBlbmRNYXRyaXgobWF0cml4KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXNldHMgdGhpcyBpbnN0YW5jZSBhbmQgaXRzIG1hdHJpeCB0byBkZWZhdWx0IHZhbHVlcy5cblx0ICogQG1ldGhvZCBpZGVudGl0eVxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5UHJvcHN9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAuaWRlbnRpdHkgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXHRcdHRoaXMuYWxwaGEgPSAxO1xuXHRcdHRoaXMuc2hhZG93ID0gdGhpcy5jb21wb3NpdGVPcGVyYXRpb24gPSBudWxsO1xuXHRcdHRoaXMubWF0cml4LmlkZW50aXR5KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBEaXNwbGF5UHJvcHMgaW5zdGFuY2UuIENsb25lcyB0aGUgYXNzb2NpYXRlZCBtYXRyaXguXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7RGlzcGxheVByb3BzfSBhIGNsb25lIG9mIHRoZSBEaXNwbGF5UHJvcHMgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgRGlzcGxheVByb3BzKHRoaXMuYWxwaGEsIHRoaXMuc2hhZG93LCB0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbiwgdGhpcy52aXNpYmxlLCB0aGlzLm1hdHJpeC5jbG9uZSgpKTtcblx0fTtcblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXG5cdGNyZWF0ZWpzLkRpc3BsYXlQcm9wcyA9IERpc3BsYXlQcm9wcztcbn0pKCk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBQb2ludC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogUmVwcmVzZW50cyBhIHBvaW50IG9uIGEgMiBkaW1lbnNpb25hbCB4IC8geSBjb29yZGluYXRlIHN5c3RlbS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBcblx0ICogICAgICB2YXIgcG9pbnQgPSBuZXcgY3JlYXRlanMuUG9pbnQoMCwgMTAwKTtcblx0ICogXG5cdCAqIEBjbGFzcyBQb2ludFxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gWCBwb3NpdGlvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIFkgcG9zaXRpb24uXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcblx0IFx0dGhpcy5zZXRWYWx1ZXMoeCwgeSk7XG5cdCBcdFxuXHQgXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0Ly8gYXNzaWduZWQgaW4gdGhlIHNldFZhbHVlcyBtZXRob2QuXG5cdFx0LyoqXG5cdFx0ICogWCBwb3NpdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgeFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogWSBwb3NpdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgeVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0fVxuXHR2YXIgcCA9IFBvaW50LnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblx0XG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqIFxuXHQgKiBTZXRzIHRoZSBzcGVjaWZpZWQgdmFsdWVzIG9uIHRoaXMgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2Qgc2V0VmFsdWVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSBYIHBvc2l0aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gWSBwb3NpdGlvbi5cblx0ICogQHJldHVybiB7UG9pbnR9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAuc2V0VmFsdWVzID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMueCA9IHh8fDA7XG5cdFx0dGhpcy55ID0geXx8MDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDb3BpZXMgYWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgc3BlY2lmaWVkIHBvaW50IHRvIHRoaXMgcG9pbnQuXG5cdCAqIEBtZXRob2QgY29weVxuXHQgKiBAcGFyYW0ge1BvaW50fSBwb2ludCBUaGUgcG9pbnQgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG5cdCAqIEByZXR1cm4ge1BvaW50fSBUaGlzIHBvaW50LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLmNvcHkgPSBmdW5jdGlvbihwb2ludCkge1xuXHRcdHRoaXMueCA9IHBvaW50Lng7XG5cdFx0dGhpcy55ID0gcG9pbnQueTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFBvaW50IGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge1BvaW50fSBhIGNsb25lIG9mIHRoZSBQb2ludCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltQb2ludCAoeD1cIit0aGlzLngrXCIgeT1cIit0aGlzLnkrXCIpXVwiO1xuXHR9O1xuXHRcblx0XG5cdGNyZWF0ZWpzLlBvaW50ID0gUG9pbnQ7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gUmVjdGFuZ2xlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBSZXByZXNlbnRzIGEgcmVjdGFuZ2xlIGFzIGRlZmluZWQgYnkgdGhlIHBvaW50cyAoeCwgeSkgYW5kICh4K3dpZHRoLCB5K2hlaWdodCkuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgcmVjdCA9IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoMCwgMCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiBAY2xhc3MgUmVjdGFuZ2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSBYIHBvc2l0aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gWSBwb3NpdGlvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aD0wXSBUaGUgd2lkdGggb2YgdGhlIFJlY3RhbmdsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQ9MF0gVGhlIGhlaWdodCBvZiB0aGUgUmVjdGFuZ2xlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdHRoaXMuc2V0VmFsdWVzKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvLyBhc3NpZ25lZCBpbiB0aGUgc2V0VmFsdWVzIG1ldGhvZC5cblx0XHQvKipcblx0XHQgKiBYIHBvc2l0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSB4XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBZIHBvc2l0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSB5XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBXaWR0aC5cblx0XHQgKiBAcHJvcGVydHkgd2lkdGhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEhlaWdodC5cblx0XHQgKiBAcHJvcGVydHkgaGVpZ2h0XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHR9XG5cdHZhciBwID0gUmVjdGFuZ2xlLnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKiBcblx0ICogU2V0cyB0aGUgc3BlY2lmaWVkIHZhbHVlcyBvbiB0aGlzIGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIHNldFZhbHVlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gWCBwb3NpdGlvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIFkgcG9zaXRpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGg9MF0gVGhlIHdpZHRoIG9mIHRoZSBSZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0PTBdIFRoZSBoZWlnaHQgb2YgdGhlIFJlY3RhbmdsZS5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLnNldFZhbHVlcyA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHQvLyBkb24ndCBmb3JnZXQgdG8gdXBkYXRlIGRvY3MgaW4gdGhlIGNvbnN0cnVjdG9yIGlmIHRoZXNlIGNoYW5nZTpcblx0XHR0aGlzLnggPSB4fHwwO1xuXHRcdHRoaXMueSA9IHl8fDA7XG5cdFx0dGhpcy53aWR0aCA9IHdpZHRofHwwO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0fHwwO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqIFxuXHQgKiBFeHRlbmRzIHRoZSByZWN0YW5nbGUncyBib3VuZHMgdG8gaW5jbHVkZSB0aGUgZGVzY3JpYmVkIHBvaW50IG9yIHJlY3RhbmdsZS5cblx0ICogQG1ldGhvZCBleHRlbmRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggWCBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb3IgcmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBZIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvciByZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGg9MF0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0PTBdIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZS5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLmV4dGVuZCA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR3aWR0aCA9IHdpZHRofHwwO1xuXHRcdGhlaWdodCA9IGhlaWdodHx8MDtcblx0XHRpZiAoeCt3aWR0aCA+IHRoaXMueCt0aGlzLndpZHRoKSB7IHRoaXMud2lkdGggPSB4K3dpZHRoLXRoaXMueDsgfVxuXHRcdGlmICh5K2hlaWdodCA+IHRoaXMueSt0aGlzLmhlaWdodCkgeyB0aGlzLmhlaWdodCA9IHkraGVpZ2h0LXRoaXMueTsgfVxuXHRcdGlmICh4IDwgdGhpcy54KSB7IHRoaXMud2lkdGggKz0gdGhpcy54LXg7IHRoaXMueCA9IHg7IH1cblx0XHRpZiAoeSA8IHRoaXMueSkgeyB0aGlzLmhlaWdodCArPSB0aGlzLnkteTsgdGhpcy55ID0geTsgfVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqIFxuXHQgKiBBZGRzIHRoZSBzcGVjaWZpZWQgcGFkZGluZyB0byB0aGUgcmVjdGFuZ2xlJ3MgYm91bmRzLlxuXHQgKiBAbWV0aG9kIGV4dGVuZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RvcD0wXVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2xlZnQ9MF1cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtyaWdodD0wXVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2JvdHRvbT0wXVxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAucGFkID0gZnVuY3Rpb24odG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0KSB7XG5cdFx0dGhpcy54IC09IGxlZnQ7XG5cdFx0dGhpcy55IC09IHRvcDtcblx0XHR0aGlzLndpZHRoICs9IGxlZnQrcmlnaHQ7XG5cdFx0dGhpcy5oZWlnaHQgKz0gdG9wK2JvdHRvbTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDb3BpZXMgYWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgc3BlY2lmaWVkIHJlY3RhbmdsZSB0byB0aGlzIHJlY3RhbmdsZS5cblx0ICogQG1ldGhvZCBjb3B5XG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0YW5nbGUgVGhlIHJlY3RhbmdsZSB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBUaGlzIHJlY3RhbmdsZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5jb3B5ID0gZnVuY3Rpb24ocmVjdGFuZ2xlKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0VmFsdWVzKHJlY3RhbmdsZS54LCByZWN0YW5nbGUueSwgcmVjdGFuZ2xlLndpZHRoLCByZWN0YW5nbGUuaGVpZ2h0KTtcblx0fTtcblx0XG5cdC8qKiBcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcmVjdGFuZ2xlIGZ1bGx5IGVuY2xvc2VzIHRoZSBkZXNjcmliZWQgcG9pbnQgb3IgcmVjdGFuZ2xlLlxuXHQgKiBAbWV0aG9kIGNvbnRhaW5zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFggcG9zaXRpb24gb2YgdGhlIHBvaW50IG9yIHJlY3RhbmdsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb3IgcmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTBdIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodD0wXSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIGRlc2NyaWJlZCBwb2ludCBvciByZWN0YW5nbGUgaXMgY29udGFpbmVkIHdpdGhpbiB0aGlzIHJlY3RhbmdsZS5cblx0Ki9cblx0cC5jb250YWlucyA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR3aWR0aCA9IHdpZHRofHwwO1xuXHRcdGhlaWdodCA9IGhlaWdodHx8MDtcblx0XHRyZXR1cm4gKHggPj0gdGhpcy54ICYmIHgrd2lkdGggPD0gdGhpcy54K3RoaXMud2lkdGggJiYgeSA+PSB0aGlzLnkgJiYgeStoZWlnaHQgPD0gdGhpcy55K3RoaXMuaGVpZ2h0KTtcblx0fTtcblx0XG5cdC8qKiBcblx0ICogUmV0dXJucyBhIG5ldyByZWN0YW5nbGUgd2hpY2ggY29udGFpbnMgdGhpcyByZWN0YW5nbGUgYW5kIHRoZSBzcGVjaWZpZWQgcmVjdGFuZ2xlLlxuXHQgKiBAbWV0aG9kIHVuaW9uXG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IFRoZSByZWN0YW5nbGUgdG8gY2FsY3VsYXRlIGEgdW5pb24gd2l0aC5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBBIG5ldyByZWN0YW5nbGUgZGVzY3JpYmluZyB0aGUgdW5pb24uXG5cdCovXG5cdHAudW5pb24gPSBmdW5jdGlvbihyZWN0KSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5leHRlbmQocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcblx0fTtcblx0XG5cdC8qKiBcblx0ICogUmV0dXJucyBhIG5ldyByZWN0YW5nbGUgd2hpY2ggZGVzY3JpYmVzIHRoZSBpbnRlcnNlY3Rpb24gKG92ZXJsYXApIG9mIHRoaXMgcmVjdGFuZ2xlIGFuZCB0aGUgc3BlY2lmaWVkIHJlY3RhbmdsZSxcblx0ICogb3IgbnVsbCBpZiB0aGV5IGRvIG5vdCBpbnRlcnNlY3QuXG5cdCAqIEBtZXRob2QgaW50ZXJzZWN0aW9uXG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IFRoZSByZWN0YW5nbGUgdG8gY2FsY3VsYXRlIGFuIGludGVyc2VjdGlvbiB3aXRoLlxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IEEgbmV3IHJlY3RhbmdsZSBkZXNjcmliaW5nIHRoZSBpbnRlcnNlY3Rpb24gb3IgbnVsbC5cblx0Ki9cblx0cC5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihyZWN0KSB7XG5cdFx0dmFyIHgxID0gcmVjdC54LCB5MSA9IHJlY3QueSwgeDIgPSB4MStyZWN0LndpZHRoLCB5MiA9IHkxK3JlY3QuaGVpZ2h0O1xuXHRcdGlmICh0aGlzLnggPiB4MSkgeyB4MSA9IHRoaXMueDsgfVxuXHRcdGlmICh0aGlzLnkgPiB5MSkgeyB5MSA9IHRoaXMueTsgfVxuXHRcdGlmICh0aGlzLnggKyB0aGlzLndpZHRoIDwgeDIpIHsgeDIgPSB0aGlzLnggKyB0aGlzLndpZHRoOyB9XG5cdFx0aWYgKHRoaXMueSArIHRoaXMuaGVpZ2h0IDwgeTIpIHsgeTIgPSB0aGlzLnkgKyB0aGlzLmhlaWdodDsgfVxuXHRcdHJldHVybiAoeDIgPD0geDEgfHwgeTIgPD0geTEpID8gbnVsbCA6IG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4Mi14MSwgeTIteTEpO1xuXHR9O1xuXHRcblx0LyoqIFxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCByZWN0YW5nbGUgaW50ZXJzZWN0cyAoaGFzIGFueSBvdmVybGFwKSB3aXRoIHRoaXMgcmVjdGFuZ2xlLlxuXHQgKiBAbWV0aG9kIGludGVyc2VjdHNcblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QgVGhlIHJlY3RhbmdsZSB0byBjb21wYXJlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSByZWN0YW5nbGVzIGludGVyc2VjdC5cblx0Ki9cblx0cC5pbnRlcnNlY3RzID0gZnVuY3Rpb24ocmVjdCkge1xuXHRcdHJldHVybiAocmVjdC54IDw9IHRoaXMueCt0aGlzLndpZHRoICYmIHRoaXMueCA8PSByZWN0LngrcmVjdC53aWR0aCAmJiByZWN0LnkgPD0gdGhpcy55K3RoaXMuaGVpZ2h0ICYmIHRoaXMueSA8PSByZWN0LnkgKyByZWN0LmhlaWdodCk7XG5cdH07XG5cdFxuXHQvKiogXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgd2lkdGggb3IgaGVpZ2h0IGFyZSBlcXVhbCBvciBsZXNzIHRoYW4gMC5cblx0ICogQG1ldGhvZCBpc0VtcHR5XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHJlY3RhbmdsZSBpcyBlbXB0eS5cblx0Ki9cblx0cC5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgUmVjdGFuZ2xlIGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gYSBjbG9uZSBvZiB0aGUgUmVjdGFuZ2xlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbUmVjdGFuZ2xlICh4PVwiK3RoaXMueCtcIiB5PVwiK3RoaXMueStcIiB3aWR0aD1cIit0aGlzLndpZHRoK1wiIGhlaWdodD1cIit0aGlzLmhlaWdodCtcIildXCI7XG5cdH07XG5cdFxuXHRcblx0Y3JlYXRlanMuUmVjdGFuZ2xlID0gUmVjdGFuZ2xlO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEJ1dHRvbkhlbHBlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogVGhlIEJ1dHRvbkhlbHBlciBpcyBhIGhlbHBlciBjbGFzcyB0byBjcmVhdGUgaW50ZXJhY3RpdmUgYnV0dG9ucyBmcm9tIHt7I2Nyb3NzTGluayBcIk1vdmllQ2xpcFwifX17ey9jcm9zc0xpbmt9fSBvclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTcHJpdGVcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2VzLiBUaGlzIGNsYXNzIHdpbGwgaW50ZXJjZXB0IG1vdXNlIGV2ZW50cyBmcm9tIGFuIG9iamVjdCwgYW5kXG5cdCAqIGF1dG9tYXRpY2FsbHkgY2FsbCB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFN0b3BcIn19e3svY3Jvc3NMaW5rfX0gb3Ige3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiB0byB0aGUgcmVzcGVjdGl2ZSBhbmltYXRpb24gbGFiZWxzLCBhZGQgYSBwb2ludGVyIGN1cnNvciwgYW5kIGFsbG93cyB0aGUgdXNlciB0byBkZWZpbmUgYSBoaXQgc3RhdGUgZnJhbWUuXG5cdCAqXG5cdCAqIFRoZSBCdXR0b25IZWxwZXIgaW5zdGFuY2UgZG9lcyBub3QgbmVlZCB0byBiZSBhZGRlZCB0byB0aGUgc3RhZ2UsIGJ1dCBhIHJlZmVyZW5jZSBzaG91bGQgYmUgbWFpbnRhaW5lZCB0byBwcmV2ZW50XG5cdCAqIGdhcmJhZ2UgY29sbGVjdGlvbi5cblx0ICogXG5cdCAqIE5vdGUgdGhhdCBvdmVyIHN0YXRlcyB3aWxsIG5vdCB3b3JrIHVubGVzcyB5b3UgY2FsbCB7eyNjcm9zc0xpbmsgXCJTdGFnZS9lbmFibGVNb3VzZU92ZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgaGVscGVyID0gbmV3IGNyZWF0ZWpzLkJ1dHRvbkhlbHBlcihteUluc3RhbmNlLCBcIm91dFwiLCBcIm92ZXJcIiwgXCJkb3duXCIsIGZhbHNlLCBteUluc3RhbmNlLCBcImhpdFwiKTtcblx0ICogICAgICBteUluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljayk7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcblx0ICogICAgICAgICAgLy8gQ2xpY2sgSGFwcGVuZWQuXG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBAY2xhc3MgQnV0dG9uSGVscGVyXG5cdCAqIEBwYXJhbSB7U3ByaXRlfE1vdmllQ2xpcH0gdGFyZ2V0IFRoZSBpbnN0YW5jZSB0byBtYW5hZ2UuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbb3V0TGFiZWw9XCJvdXRcIl0gVGhlIGxhYmVsIG9yIGFuaW1hdGlvbiB0byBnbyB0byB3aGVuIHRoZSB1c2VyIHJvbGxzIG91dCBvZiB0aGUgYnV0dG9uLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW292ZXJMYWJlbD1cIm92ZXJcIl0gVGhlIGxhYmVsIG9yIGFuaW1hdGlvbiB0byBnbyB0byB3aGVuIHRoZSB1c2VyIHJvbGxzIG92ZXIgdGhlIGJ1dHRvbi5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtkb3duTGFiZWw9XCJkb3duXCJdIFRoZSBsYWJlbCBvciBhbmltYXRpb24gdG8gZ28gdG8gd2hlbiB0aGUgdXNlciBwcmVzc2VzIHRoZSBidXR0b24uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BsYXk9ZmFsc2VdIElmIHRoZSBoZWxwZXIgc2hvdWxkIGNhbGwgXCJnb3RvQW5kUGxheVwiIG9yIFwiZ290b0FuZFN0b3BcIiBvbiB0aGUgYnV0dG9uIHdoZW4gY2hhbmdpbmdcblx0ICogc3RhdGVzLlxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IFtoaXRBcmVhXSBBbiBvcHRpb25hbCBpdGVtIHRvIHVzZSBhcyB0aGUgaGl0IHN0YXRlIGZvciB0aGUgYnV0dG9uLiBJZiB0aGlzIGlzIG5vdCBkZWZpbmVkLFxuXHQgKiB0aGVuIHRoZSBidXR0b24ncyB2aXNpYmxlIHN0YXRlcyB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gTm90ZSB0aGF0IHRoZSBzYW1lIGluc3RhbmNlIGFzIHRoZSBcInRhcmdldFwiIGFyZ3VtZW50IGNhbiBiZVxuXHQgKiB1c2VkIGZvciB0aGUgaGl0U3RhdGUuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbaGl0TGFiZWxdIFRoZSBsYWJlbCBvciBhbmltYXRpb24gb24gdGhlIGhpdEFyZWEgaW5zdGFuY2UgdGhhdCBkZWZpbmVzIHRoZSBoaXRBcmVhIGJvdW5kcy4gSWYgdGhpcyBpc1xuXHQgKiBudWxsLCB0aGVuIHRoZSBkZWZhdWx0IHN0YXRlIG9mIHRoZSBoaXRBcmVhIHdpbGwgYmUgdXNlZC4gKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEJ1dHRvbkhlbHBlcih0YXJnZXQsIG91dExhYmVsLCBvdmVyTGFiZWwsIGRvd25MYWJlbCwgcGxheSwgaGl0QXJlYSwgaGl0TGFiZWwpIHtcblx0XHRpZiAoIXRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7IHJldHVybjsgfVxuXHRcblx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0YXJnZXQgZm9yIHRoaXMgYnV0dG9uIGhlbHBlci5cblx0XHQgKiBAcHJvcGVydHkgdGFyZ2V0XG5cdFx0ICogQHR5cGUgTW92aWVDbGlwIHwgU3ByaXRlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgbGFiZWwgbmFtZSBvciBmcmFtZSBudW1iZXIgdG8gZGlzcGxheSB3aGVuIHRoZSB1c2VyIG1vdXNlcyBvdXQgb2YgdGhlIHRhcmdldC4gRGVmYXVsdHMgdG8gXCJvdmVyXCIuXG5cdFx0ICogQHByb3BlcnR5IG92ZXJMYWJlbFxuXHRcdCAqIEB0eXBlIFN0cmluZyB8IE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLm92ZXJMYWJlbCA9IG92ZXJMYWJlbCA9PSBudWxsID8gXCJvdmVyXCIgOiBvdmVyTGFiZWw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsYWJlbCBuYW1lIG9yIGZyYW1lIG51bWJlciB0byBkaXNwbGF5IHdoZW4gdGhlIHVzZXIgbW91c2VzIG92ZXIgdGhlIHRhcmdldC4gRGVmYXVsdHMgdG8gXCJvdXRcIi5cblx0XHQgKiBAcHJvcGVydHkgb3V0TGFiZWxcblx0XHQgKiBAdHlwZSBTdHJpbmcgfCBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5vdXRMYWJlbCA9IG91dExhYmVsID09IG51bGwgPyBcIm91dFwiIDogb3V0TGFiZWw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsYWJlbCBuYW1lIG9yIGZyYW1lIG51bWJlciB0byBkaXNwbGF5IHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBvbiB0aGUgdGFyZ2V0LiBEZWZhdWx0cyB0byBcImRvd25cIi5cblx0XHQgKiBAcHJvcGVydHkgZG93bkxhYmVsXG5cdFx0ICogQHR5cGUgU3RyaW5nIHwgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuZG93bkxhYmVsID0gZG93bkxhYmVsID09IG51bGwgPyBcImRvd25cIiA6IGRvd25MYWJlbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgdHJ1ZSwgdGhlbiBCdXR0b25IZWxwZXIgd2lsbCBjYWxsIGdvdG9BbmRQbGF5LCBpZiBmYWxzZSwgaXQgd2lsbCB1c2UgZ290b0FuZFN0b3AuIERlZmF1bHQgaXMgZmFsc2UuXG5cdFx0ICogQHByb3BlcnR5IHBsYXlcblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiovXG5cdFx0dGhpcy5wbGF5ID0gcGxheTtcblx0XHRcblx0XHRcblx0Ly8gIHByaXZhdGUgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfaXNQcmVzc2VkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5faXNQcmVzc2VkID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfaXNPdmVyXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5faXNPdmVyID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfZW5hYmxlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcblx0XHRcblx0Ly8gc2V0dXA6XG5cdFx0dGFyZ2V0Lm1vdXNlQ2hpbGRyZW4gPSBmYWxzZTsgLy8gcHJldmVudHMgaXNzdWVzIHdoZW4gY2hpbGRyZW4gYXJlIHJlbW92ZWQgZnJvbSB0aGUgZGlzcGxheSBsaXN0IHdoZW4gc3RhdGUgY2hhbmdlcy5cblx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuaGFuZGxlRXZlbnQoe30pO1xuXHRcdGlmIChoaXRBcmVhKSB7XG5cdFx0XHRpZiAoaGl0TGFiZWwpIHtcblx0XHRcdFx0aGl0QXJlYS5hY3Rpb25zRW5hYmxlZCA9IGZhbHNlO1xuXHRcdFx0XHRoaXRBcmVhLmdvdG9BbmRTdG9wJiZoaXRBcmVhLmdvdG9BbmRTdG9wKGhpdExhYmVsKTtcblx0XHRcdH1cblx0XHRcdHRhcmdldC5oaXRBcmVhID0gaGl0QXJlYTtcblx0XHR9XG5cdH1cblx0dmFyIHAgPSBCdXR0b25IZWxwZXIucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXHRcbi8vIGdldHRlciAvIHNldHRlcnM6XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIkJ1dHRvbkhlbHBlci9lbmFibGVkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2Qgc2V0RW5hYmxlZFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0cC5zZXRFbmFibGVkID0gZnVuY3Rpb24odmFsdWUpIHsgLy8gVE9ETzogZGVwcmVjYXRlZC5cblx0XHRpZiAodmFsdWUgPT0gdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cblx0XHR2YXIgbyA9IHRoaXMudGFyZ2V0O1xuXHRcdHRoaXMuX2VuYWJsZWQgPSB2YWx1ZTtcblx0XHRpZiAodmFsdWUpIHtcblx0XHRcdG8uY3Vyc29yID0gXCJwb2ludGVyXCI7XG5cdFx0XHRvLmFkZEV2ZW50TGlzdGVuZXIoXCJyb2xsb3ZlclwiLCB0aGlzKTtcblx0XHRcdG8uYWRkRXZlbnRMaXN0ZW5lcihcInJvbGxvdXRcIiwgdGhpcyk7XG5cdFx0XHRvLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcyk7XG5cdFx0XHRvLmFkZEV2ZW50TGlzdGVuZXIoXCJwcmVzc3VwXCIsIHRoaXMpO1xuXHRcdFx0aWYgKG8uX3Jlc2V0KSB7IG8uX19yZXNldCA9IG8uX3Jlc2V0OyBvLl9yZXNldCA9IHRoaXMuX3Jlc2V0O31cblx0XHR9IGVsc2Uge1xuXHRcdFx0by5jdXJzb3IgPSBudWxsO1xuXHRcdFx0by5yZW1vdmVFdmVudExpc3RlbmVyKFwicm9sbG92ZXJcIiwgdGhpcyk7XG5cdFx0XHRvLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyb2xsb3V0XCIsIHRoaXMpO1xuXHRcdFx0by5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMpO1xuXHRcdFx0by5yZW1vdmVFdmVudExpc3RlbmVyKFwicHJlc3N1cFwiLCB0aGlzKTtcblx0XHRcdGlmIChvLl9fcmVzZXQpIHsgby5fcmVzZXQgPSBvLl9fcmVzZXQ7IGRlbGV0ZShvLl9fcmVzZXQpOyB9XG5cdFx0fVxuXHR9O1xuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJCdXR0b25IZWxwZXIvZW5hYmxlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldEVuYWJsZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRwLmdldEVuYWJsZWQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZW5hYmxlZDtcblx0fTtcblxuXHQvKipcblx0ICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgYnV0dG9uIGZ1bmN0aW9uYWxpdHkgb24gdGhlIHRhcmdldC5cblx0ICogQHByb3BlcnR5IGVuYWJsZWRcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqKi9cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cdFx0XHRlbmFibGVkOiB7IGdldDogcC5nZXRFbmFibGVkLCBzZXQ6IHAuc2V0RW5hYmxlZCB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHt9IC8vIFRPRE86IHVzZSBMb2dcblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltCdXR0b25IZWxwZXJdXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBoYW5kbGVFdmVudFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZ0IFRoZSBtb3VzZSBldmVudCB0byBoYW5kbGUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24oZXZ0KSB7XG5cdFx0dmFyIGxhYmVsLCB0ID0gdGhpcy50YXJnZXQsIHR5cGUgPSBldnQudHlwZTtcblx0XHRpZiAodHlwZSA9PSBcIm1vdXNlZG93blwiKSB7XG5cdFx0XHR0aGlzLl9pc1ByZXNzZWQgPSB0cnVlO1xuXHRcdFx0bGFiZWwgPSB0aGlzLmRvd25MYWJlbDtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT0gXCJwcmVzc3VwXCIpIHtcblx0XHRcdHRoaXMuX2lzUHJlc3NlZCA9IGZhbHNlO1xuXHRcdFx0bGFiZWwgPSB0aGlzLl9pc092ZXIgPyB0aGlzLm92ZXJMYWJlbCA6IHRoaXMub3V0TGFiZWw7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09IFwicm9sbG92ZXJcIikge1xuXHRcdFx0dGhpcy5faXNPdmVyID0gdHJ1ZTtcblx0XHRcdGxhYmVsID0gdGhpcy5faXNQcmVzc2VkID8gdGhpcy5kb3duTGFiZWwgOiB0aGlzLm92ZXJMYWJlbDtcblx0XHR9IGVsc2UgeyAvLyByb2xsb3V0IGFuZCBkZWZhdWx0XG5cdFx0XHR0aGlzLl9pc092ZXIgPSBmYWxzZTtcblx0XHRcdGxhYmVsID0gdGhpcy5faXNQcmVzc2VkID8gdGhpcy5vdmVyTGFiZWwgOiB0aGlzLm91dExhYmVsO1xuXHRcdH1cblx0XHRpZiAodGhpcy5wbGF5KSB7XG5cdFx0XHR0LmdvdG9BbmRQbGF5JiZ0LmdvdG9BbmRQbGF5KGxhYmVsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dC5nb3RvQW5kU3RvcCYmdC5nb3RvQW5kU3RvcChsYWJlbCk7XG5cdFx0fVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEluamVjdGVkIGludG8gdGFyZ2V0LiBQcmVzZXJ2ZXMgdGhlIHBhdXNlZCBzdGF0ZSB0aHJvdWdoIGEgcmVzZXQuXG5cdCAqIEBtZXRob2QgX3Jlc2V0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFRPRE86IGV4cGxvcmUgYmV0dGVyIHdheXMgdG8gaGFuZGxlIHRoaXMgaXNzdWUuIFRoaXMgaXMgaGFja3kgJiBkaXNydXB0cyBvYmplY3Qgc2lnbmF0dXJlcy5cblx0XHR2YXIgcCA9IHRoaXMucGF1c2VkO1xuXHRcdHRoaXMuX19yZXNldCgpO1xuXHRcdHRoaXMucGF1c2VkID0gcDtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLkJ1dHRvbkhlbHBlciA9IEJ1dHRvbkhlbHBlcjtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTaGFkb3cuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFRoaXMgY2xhc3MgZW5jYXBzdWxhdGVzIHRoZSBwcm9wZXJ0aWVzIHJlcXVpcmVkIHRvIGRlZmluZSBhIHNoYWRvdyB0byBhcHBseSB0byBhIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3RcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogdmlhIGl0cyA8Y29kZT5zaGFkb3c8L2NvZGU+IHByb3BlcnR5LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgbXlJbWFnZS5zaGFkb3cgPSBuZXcgY3JlYXRlanMuU2hhZG93KFwiIzAwMDAwMFwiLCA1LCA1LCAxMCk7XG5cdCAqXG5cdCAqIEBjbGFzcyBTaGFkb3dcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIHNoYWRvdy4gVGhpcyBjYW4gYmUgYW55IHZhbGlkIENTUyBjb2xvciB2YWx1ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFggVGhlIHggb2Zmc2V0IG9mIHRoZSBzaGFkb3cgaW4gcGl4ZWxzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0WSBUaGUgeSBvZmZzZXQgb2YgdGhlIHNoYWRvdyBpbiBwaXhlbHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBibHVyIFRoZSBzaXplIG9mIHRoZSBibHVycmluZyBlZmZlY3QuXG5cdCAqKi9cblx0ZnVuY3Rpb24gU2hhZG93KGNvbG9yLCBvZmZzZXRYLCBvZmZzZXRZLCBibHVyKSB7XG5cdFx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKiBcblx0XHQgKiBUaGUgY29sb3Igb2YgdGhlIHNoYWRvdy4gVGhpcyBjYW4gYmUgYW55IHZhbGlkIENTUyBjb2xvciB2YWx1ZS5cblx0XHQgKiBAcHJvcGVydHkgY29sb3Jcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5jb2xvciA9IGNvbG9yfHxcImJsYWNrXCI7XG5cdFxuXHRcdC8qKiBUaGUgeCBvZmZzZXQgb2YgdGhlIHNoYWRvdy5cblx0XHQgKiBAcHJvcGVydHkgb2Zmc2V0WFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLm9mZnNldFggPSBvZmZzZXRYfHwwO1xuXHRcblx0XHQvKiogVGhlIHkgb2Zmc2V0IG9mIHRoZSBzaGFkb3cuXG5cdFx0ICogQHByb3BlcnR5IG9mZnNldFlcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5vZmZzZXRZID0gb2Zmc2V0WXx8MDtcblx0XG5cdFx0LyoqIFRoZSBibHVyIG9mIHRoZSBzaGFkb3cuXG5cdFx0ICogQHByb3BlcnR5IGJsdXJcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5ibHVyID0gYmx1cnx8MDtcblx0fVxuXHR2YXIgcCA9IFNoYWRvdy5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cbi8vIHN0YXRpYyBwdWJsaWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIEFuIGlkZW50aXR5IHNoYWRvdyBvYmplY3QgKGFsbCBwcm9wZXJ0aWVzIGFyZSBzZXQgdG8gMCkuXG5cdCAqIEBwcm9wZXJ0eSBpZGVudGl0eVxuXHQgKiBAdHlwZSBTaGFkb3dcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0U2hhZG93LmlkZW50aXR5ID0gbmV3IFNoYWRvdyhcInRyYW5zcGFyZW50XCIsIDAsIDAsIDApO1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1NoYWRvd11cIjtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgU2hhZG93IGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge1NoYWRvd30gQSBjbG9uZSBvZiB0aGUgY3VycmVudCBTaGFkb3cgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2hhZG93KHRoaXMuY29sb3IsIHRoaXMub2Zmc2V0WCwgdGhpcy5vZmZzZXRZLCB0aGlzLmJsdXIpO1xuXHR9O1xuXHRcblxuXHRjcmVhdGVqcy5TaGFkb3cgPSBTaGFkb3c7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU3ByaXRlU2hlZXQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEVuY2Fwc3VsYXRlcyB0aGUgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBhc3NvY2lhdGVkIHdpdGggYSBzcHJpdGUgc2hlZXQuIEEgc3ByaXRlIHNoZWV0IGlzIGEgc2VyaWVzIG9mIGltYWdlcyAodXN1YWxseVxuXHQgKiBhbmltYXRpb24gZnJhbWVzKSBjb21iaW5lZCBpbnRvIGEgbGFyZ2VyIGltYWdlIChvciBpbWFnZXMpLiBGb3IgZXhhbXBsZSwgYW4gYW5pbWF0aW9uIGNvbnNpc3Rpbmcgb2YgZWlnaHQgMTAweDEwMFxuXHQgKiBpbWFnZXMgY291bGQgYmUgY29tYmluZWQgaW50byBhIHNpbmdsZSA0MDB4MjAwIHNwcml0ZSBzaGVldCAoNCBmcmFtZXMgYWNyb3NzIGJ5IDIgaGlnaCkuXG5cdCAqXG5cdCAqIFRoZSBkYXRhIHBhc3NlZCB0byB0aGUgU3ByaXRlU2hlZXQgY29uc3RydWN0b3IgZGVmaW5lczo8b2w+XG5cdCAqIFx0PGxpPiBUaGUgc291cmNlIGltYWdlIG9yIGltYWdlcyB0byB1c2UuPC9saT5cblx0ICogXHQ8bGk+IFRoZSBwb3NpdGlvbnMgb2YgaW5kaXZpZHVhbCBpbWFnZSBmcmFtZXMuPC9saT5cblx0ICogXHQ8bGk+IFNlcXVlbmNlcyBvZiBmcmFtZXMgdGhhdCBmb3JtIG5hbWVkIGFuaW1hdGlvbnMuIE9wdGlvbmFsLjwvbGk+XG5cdCAqIFx0PGxpPiBUaGUgdGFyZ2V0IHBsYXliYWNrIGZyYW1lcmF0ZS4gT3B0aW9uYWwuPC9saT5cblx0ICogPC9PTD5cblx0ICpcblx0ICogPGgzPlNwcml0ZVNoZWV0IEZvcm1hdDwvaDM+XG5cdCAqXG5cdCAqIFNwcml0ZVNoZWV0cyBhcmUgYW4gb2JqZWN0IHdpdGggdHdvIHJlcXVpcmVkIHByb3BlcnRpZXMgKGBpbWFnZXNgIGFuZCBgZnJhbWVzYCksIGFuZCB0d28gb3B0aW9uYWwgcHJvcGVydGllc1xuXHQgKiAoYGZyYW1lcmF0ZWAgYW5kIGBhbmltYXRpb25zYCkuIFRoaXMgbWFrZXMgdGhlbSBlYXN5IHRvIGRlZmluZSBpbiBqYXZhc2NyaXB0IGNvZGUsIG9yIGluIEpTT04uXG5cdCAqXG5cdCAqIDxoND5pbWFnZXM8L2g0PlxuXHQgKiBBbiBhcnJheSBvZiBzb3VyY2UgaW1hZ2VzLiBJbWFnZXMgY2FuIGJlIGVpdGhlciBhbiBIVE1MSW1hZ2Vcblx0ICogaW5zdGFuY2UsIG9yIGEgdXJpIHRvIGFuIGltYWdlLiBUaGUgZm9ybWVyIGlzIHJlY29tbWVuZGVkIHRvIGNvbnRyb2wgcHJlbG9hZGluZy5cblx0ICpcblx0ICogXHRpbWFnZXM6IFtpbWFnZTEsIFwicGF0aC90by9pbWFnZTIucG5nXCJdLFxuXHQgKlxuXHQgKiA8aDQ+ZnJhbWVzPC9oND5cblx0ICogRGVmaW5lcyB0aGUgaW5kaXZpZHVhbCBmcmFtZXMuIFRoZXJlIGFyZSB0d28gc3VwcG9ydGVkIGZvcm1hdHMgZm9yIGZyYW1lIGRhdGE6PE9MPlxuXHQgKiA8TEk+IHdoZW4gYWxsIG9mIHRoZSBmcmFtZXMgYXJlIHRoZSBzYW1lIHNpemUgKGluIGEgZ3JpZCksIHVzZSBhbiBvYmplY3Qgd2l0aCBgd2lkdGhgLCBgaGVpZ2h0YCwgYHJlZ1hgLCBgcmVnWWAsIGFuZCBgY291bnRgIHByb3BlcnRpZXMuXG5cdCAqIGB3aWR0aGAgJiBgaGVpZ2h0YCBhcmUgcmVxdWlyZWQgYW5kIHNwZWNpZnkgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGZyYW1lcy5cblx0ICogYHJlZ1hgICYgYHJlZ1lgIGluZGljYXRlIHRoZSByZWdpc3RyYXRpb24gcG9pbnQgb3IgXCJvcmlnaW5cIiBvZiB0aGUgZnJhbWVzLlxuXHQgKiBgc3BhY2luZ2AgaW5kaWNhdGUgdGhlIHNwYWNpbmcgYmV0d2VlbiBmcmFtZXMuXG5cdCAqIGBtYXJnaW5gIHNwZWNpZnkgdGhlIG1hcmdpbiBhcm91bmQgdGhlIGltYWdlKHMpLlxuXHQgKiBgY291bnRgIGFsbG93cyB5b3UgdG8gc3BlY2lmeSB0aGUgdG90YWwgbnVtYmVyIG9mIGZyYW1lcyBpbiB0aGUgc3ByaXRlc2hlZXQ7IGlmIG9taXR0ZWQsIHRoaXMgd2lsbCBiZSBjYWxjdWxhdGVkXG5cdCAqIGJhc2VkIG9uIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBzb3VyY2UgaW1hZ2VzIGFuZCB0aGUgZnJhbWVzLiBGcmFtZXMgd2lsbCBiZSBhc3NpZ25lZCBpbmRleGVzIGJhc2VkIG9uIHRoZWlyIHBvc2l0aW9uXG5cdCAqIGluIHRoZSBzb3VyY2UgaW1hZ2VzIChsZWZ0IHRvIHJpZ2h0LCB0b3AgdG8gYm90dG9tKS5cblx0ICpcblx0ICogXHRmcmFtZXM6IHt3aWR0aDo2NCwgaGVpZ2h0OjY0LCBjb3VudDoyMCwgcmVnWDogMzIsIHJlZ1k6NjQsIHNwYWNpbmc6MCwgbWFyZ2luOjB9XG5cdCAqXG5cdCAqIDxMST4gaWYgdGhlIGZyYW1lcyBhcmUgb2YgZGlmZmVyZW50IHNpemVzLCB1c2UgYW4gYXJyYXkgb2YgZnJhbWUgZGVmaW5pdGlvbnMuIEVhY2ggZGVmaW5pdGlvbiBpcyBpdHNlbGYgYW4gYXJyYXlcblx0ICogd2l0aCA0IHJlcXVpcmVkIGFuZCAzIG9wdGlvbmFsIGVudHJpZXMsIGluIHRoZSBvcmRlcjogYHhgLCBgeWAsIGB3aWR0aGAsIGBoZWlnaHRgLCBgaW1hZ2VJbmRleGAsIGByZWdYYCwgYHJlZ1lgLiBUaGUgZmlyc3Rcblx0ICogZm91ciBlbnRyaWVzIGFyZSByZXF1aXJlZCBhbmQgZGVmaW5lIHRoZSBmcmFtZSByZWN0YW5nbGUuIFRoZSBmaWZ0aCBzcGVjaWZpZXMgdGhlIGluZGV4IG9mIHRoZSBzb3VyY2UgaW1hZ2UgKGRlZmF1bHRzIHRvIDApLiBUaGVcblx0ICogbGFzdCB0d28gc3BlY2lmeSB0aGUgcmVnaXN0cmF0aW9uIHBvaW50IG9mIHRoZSBmcmFtZS5cblx0ICpcblx0ICogXHRmcmFtZXM6IFtcblx0ICogXHRcdC8vIHgsIHksIHdpZHRoLCBoZWlnaHQsIGltYWdlSW5kZXgqLCByZWdYKiwgcmVnWSpcblx0ICogXHRcdFs2NCwgMCwgOTYsIDY0XSxcblx0ICogXHRcdFswLCAwLCA2NCwgNjQsIDEsIDMyLCAzMl1cblx0ICogXHRcdC8vIGV0Yy5cblx0ICogXHRdXG5cdCAqXG5cdCAqIDwvT0w+XG5cdCAqXG5cdCAqIDxoND5hbmltYXRpb25zPC9oND5cblx0ICogT3B0aW9uYWwuIEFuIG9iamVjdCBkZWZpbmluZyBzZXF1ZW5jZXMgb2YgZnJhbWVzIHRvIHBsYXkgYXMgbmFtZWQgYW5pbWF0aW9ucy4gRWFjaCBwcm9wZXJ0eSBjb3JyZXNwb25kcyB0byBhblxuXHQgKiBhbmltYXRpb24gb2YgdGhlIHNhbWUgbmFtZS4gRWFjaCBhbmltYXRpb24gbXVzdCBzcGVjaWZ5IHRoZSBmcmFtZXMgdG8gcGxheSwgYW5kIG1heVxuXHQgKiBhbHNvIGluY2x1ZGUgYSByZWxhdGl2ZSBwbGF5YmFjayBgc3BlZWRgIChleC4gMiB3b3VsZCBwbGF5YmFjayBhdCBkb3VibGUgc3BlZWQsIDAuNSBhdCBoYWxmKSwgYW5kXG5cdCAqIHRoZSBuYW1lIG9mIHRoZSBgbmV4dGAgYW5pbWF0aW9uIHRvIHNlcXVlbmNlIHRvIGFmdGVyIGl0IGNvbXBsZXRlcy5cblx0ICpcblx0ICogVGhlcmUgYXJlIHRocmVlIGZvcm1hdHMgc3VwcG9ydGVkIGZvciBkZWZpbmluZyB0aGUgZnJhbWVzIGluIGFuIGFuaW1hdGlvbiwgd2hpY2ggY2FuIGJlIG1peGVkIGFuZCBtYXRjaGVkIGFzIGFwcHJvcHJpYXRlOjxPTD5cblx0ICogPExJPiBmb3IgYSBzaW5nbGUgZnJhbWUgYW5pbWF0aW9uLCB5b3UgY2FuIHNpbXBseSBzcGVjaWZ5IHRoZSBmcmFtZSBpbmRleFxuXHQgKlxuXHQgKiBcdGFuaW1hdGlvbnM6IHtcblx0ICogXHRcdHNpdDogN1xuXHQgKiBcdH1cblx0ICpcblx0ICogPExJPiBmb3IgYW4gYW5pbWF0aW9uIG9mIGNvbnNlY3V0aXZlIGZyYW1lcywgeW91IGNhbiB1c2UgYW4gYXJyYXkgd2l0aCB0d28gcmVxdWlyZWQsIGFuZCB0d28gb3B0aW9uYWwgZW50cmllc1xuXHQgKiBpbiB0aGUgb3JkZXI6IGBzdGFydGAsIGBlbmRgLCBgbmV4dGAsIGFuZCBgc3BlZWRgLiBUaGlzIHdpbGwgcGxheSB0aGUgZnJhbWVzIGZyb20gc3RhcnQgdG8gZW5kIGluY2x1c2l2ZS5cblx0ICpcblx0ICogXHRhbmltYXRpb25zOiB7XG5cdCAqIFx0XHQvLyBzdGFydCwgZW5kLCBuZXh0Kiwgc3BlZWQqXG5cdCAqIFx0XHRydW46IFswLCA4XSxcblx0ICogXHRcdGp1bXA6IFs5LCAxMiwgXCJydW5cIiwgMl1cblx0ICogXHR9XG5cdCAqXG5cdCAqIDxMST4gZm9yIG5vbi1jb25zZWN1dGl2ZSBmcmFtZXMsIHlvdSBjYW4gdXNlIGFuIG9iamVjdCB3aXRoIGEgYGZyYW1lc2AgcHJvcGVydHkgZGVmaW5pbmcgYW4gYXJyYXkgb2YgZnJhbWUgaW5kZXhlcyB0b1xuXHQgKiBwbGF5IGluIG9yZGVyLiBUaGUgb2JqZWN0IGNhbiBhbHNvIHNwZWNpZnkgYG5leHRgIGFuZCBgc3BlZWRgIHByb3BlcnRpZXMuXG5cdCAqXG5cdCAqIFx0YW5pbWF0aW9uczoge1xuXHQgKiBcdFx0d2Fsazoge1xuXHQgKiBcdFx0XHRmcmFtZXM6IFsxLDIsMywzLDIsMV1cblx0ICogXHRcdH0sXG5cdCAqIFx0XHRzaG9vdDoge1xuXHQgKiBcdFx0XHRmcmFtZXM6IFsxLDQsNSw2XSxcblx0ICogXHRcdFx0bmV4dDogXCJ3YWxrXCIsXG5cdCAqIFx0XHRcdHNwZWVkOiAwLjVcblx0ICogXHRcdH1cblx0ICogXHR9XG5cdCAqXG5cdCAqIDwvT0w+XG5cdCAqIDxzdHJvbmc+Tm90ZTo8L3N0cm9uZz4gdGhlIGBzcGVlZGAgcHJvcGVydHkgd2FzIGFkZGVkIGluIEVhc2VsSlMgMC43LjAuIEVhcmxpZXIgdmVyc2lvbnMgaGFkIGEgYGZyZXF1ZW5jeWBcblx0ICogcHJvcGVydHkgaW5zdGVhZCwgd2hpY2ggd2FzIHRoZSBpbnZlcnNlIG9mIGBzcGVlZGAuIEZvciBleGFtcGxlLCBhIHZhbHVlIG9mIFwiNFwiIHdvdWxkIGJlIDEvNCBub3JtYWwgc3BlZWQgaW4gZWFybGllclxuXHQgKiB2ZXJzaW9ucywgYnV0IGlzIDR4IG5vcm1hbCBzcGVlZCBpbiAwLjcuMCsuXG5cdCAqXG5cdCAqIDxoND5mcmFtZXJhdGU8L2g0PlxuXHQgKiBPcHRpb25hbC4gSW5kaWNhdGVzIHRoZSBkZWZhdWx0IGZyYW1lcmF0ZSB0byBwbGF5IHRoaXMgc3ByaXRlc2hlZXQgYXQgaW4gZnJhbWVzIHBlciBzZWNvbmQuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldC9mcmFtZXJhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqXG5cdCAqIFx0ZnJhbWVyYXRlOiAyMFxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIFRvIGRlZmluZSBhIHNpbXBsZSBzcHJpdGUgc2hlZXQsIHdpdGggYSBzaW5nbGUgaW1hZ2UgXCJzcHJpdGVzLmpwZ1wiIGFycmFuZ2VkIGluIGEgcmVndWxhciA1MHg1MCBncmlkIHdpdGggdGhyZWVcblx0ICogYW5pbWF0aW9uczogXCJzdGFuZFwiIHNob3dpbmcgdGhlIGZpcnN0IGZyYW1lLCBcInJ1blwiIGxvb3BpbmcgZnJhbWUgMS01IGluY2x1c2l2ZSwgYW5kIFwianVtcFwiIHBsYXlpbmcgIGZyYW1lIDYtOCBhbmQgc2VxdWVuY2luZyBiYWNrIHRvIHJ1bi5cblx0ICpcblx0ICogXHR2YXIgZGF0YSA9IHtcblx0ICogXHRcdGltYWdlczogW1wic3ByaXRlcy5qcGdcIl0sXG5cdCAqIFx0XHRmcmFtZXM6IHt3aWR0aDo1MCwgaGVpZ2h0OjUwfSxcblx0ICogXHRcdGFuaW1hdGlvbnM6IHtcblx0ICogXHRcdFx0c3RhbmQ6MCxcblx0ICogXHRcdFx0cnVuOlsxLDVdLFxuXHQgKiBcdFx0XHRqdW1wOls2LDgsXCJydW5cIl1cblx0ICogXHRcdH1cblx0ICogXHR9O1xuXHQgKiBcdHZhciBzcHJpdGVTaGVldCA9IG5ldyBjcmVhdGVqcy5TcHJpdGVTaGVldChkYXRhKTtcblx0ICogXHR2YXIgYW5pbWF0aW9uID0gbmV3IGNyZWF0ZWpzLlNwcml0ZShzcHJpdGVTaGVldCwgXCJydW5cIik7XG5cdCAqXG5cdCAqXG5cdCAqIDxzdHJvbmc+V2FybmluZzo8L3N0cm9uZz4gSW1hZ2VzIGxvYWRlZCBjcm9zcy1vcmlnaW4gd2lsbCB0aHJvdyBjcm9zcy1vcmlnaW4gc2VjdXJpdHkgZXJyb3JzIHdoZW4gaW50ZXJhY3RlZCB3aXRoXG5cdCAqIHVzaW5nIGEgbW91c2UsIHVzaW5nIG1ldGhvZHMgc3VjaCBhcyBgZ2V0T2JqZWN0VW5kZXJQb2ludGAsIHVzaW5nIGZpbHRlcnMsIG9yIGNhY2hpbmcuIFlvdSBjYW4gZ2V0IGFyb3VuZCB0aGlzIGJ5XG5cdCAqIHNldHRpbmcgYGNyb3NzT3JpZ2luYCBmbGFncyBvbiB5b3VyIGltYWdlcyBiZWZvcmUgcGFzc2luZyB0aGVtIHRvIEVhc2VsSlMsIGVnOiBgaW1nLmNyb3NzT3JpZ2luPVwiQW5vbnltb3VzXCI7YFxuXHQgKlxuXHQgKiBAY2xhc3MgU3ByaXRlU2hlZXRcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEFuIG9iamVjdCBkZXNjcmliaW5nIHRoZSBTcHJpdGVTaGVldCBkYXRhLlxuXHQgKiBAZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJcblx0ICoqL1xuXHRmdW5jdGlvbiBTcHJpdGVTaGVldChkYXRhKSB7XG5cdFx0dGhpcy5FdmVudERpc3BhdGNoZXJfY29uc3RydWN0b3IoKTtcblxuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgYWxsIGltYWdlcyBhcmUgZmluaXNoZWQgbG9hZGluZy5cblx0XHQgKiBAcHJvcGVydHkgY29tcGxldGVcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMuY29tcGxldGUgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogU3BlY2lmaWVzIHRoZSBmcmFtZXJhdGUgdG8gdXNlIGJ5IGRlZmF1bHQgZm9yIFNwcml0ZSBpbnN0YW5jZXMgdXNpbmcgdGhlIFNwcml0ZVNoZWV0LiBTZWVcblx0XHQgKiBTcHJpdGUuZnJhbWVyYXRlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBmcmFtZXJhdGVcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5mcmFtZXJhdGUgPSAwO1xuXG5cblx0XHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9hbmltYXRpb25zXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIEFycmF5XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2FuaW1hdGlvbnMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9mcmFtZXNcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgQXJyYXlcblx0XHQgKiovXG5cdFx0dGhpcy5fZnJhbWVzID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfaW1hZ2VzXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIEFycmF5XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2ltYWdlcyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2RhdGFcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2RhdGEgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkQ291bnRcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2xvYWRDb3VudCA9IDA7XG5cblx0XHQvLyBvbmx5IHVzZWQgZm9yIHNpbXBsZSBmcmFtZSBkZWZzOlxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfZnJhbWVIZWlnaHRcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2ZyYW1lSGVpZ2h0ID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfZnJhbWVXaWR0aFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fZnJhbWVXaWR0aCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX251bUZyYW1lc1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fbnVtRnJhbWVzID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmVnWFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fcmVnWCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3JlZ1lcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3JlZ1kgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9zcGFjaW5nXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9zcGFjaW5nID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbWFyZ2luXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9tYXJnaW4gPSAwO1xuXG5cdFx0Ly8gc2V0dXA6XG5cdFx0dGhpcy5fcGFyc2VEYXRhKGRhdGEpO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFNwcml0ZVNoZWV0LCBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cbi8vIGV2ZW50czpcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiBhbGwgaW1hZ2VzIGFyZSBsb2FkZWQuICBOb3RlIHRoYXQgdGhpcyBvbmx5IGZpcmVzIGlmIHRoZSBpbWFnZXNcblx0ICogd2VyZSBub3QgZnVsbHkgbG9hZGVkIHdoZW4gdGhlIHNwcml0ZSBzaGVldCB3YXMgaW5pdGlhbGl6ZWQuIFlvdSBzaG91bGQgY2hlY2sgdGhlIGNvbXBsZXRlIHByb3BlcnR5XG5cdCAqIHRvIHByaW9yIHRvIGFkZGluZyBhIGxpc3RlbmVyLiBFeC5cblx0ICpcblx0ICogXHR2YXIgc2hlZXQgPSBuZXcgU3ByaXRlU2hlZXQoZGF0YSk7XG5cdCAqIFx0aWYgKCFzaGVldC5jb21wbGV0ZSkge1xuXHQgKiBcdFx0Ly8gbm90IHByZWxvYWRlZCwgbGlzdGVuIGZvciB0aGUgY29tcGxldGUgZXZlbnQ6XG5cdCAqIFx0XHRzaGVldC5hZGRFdmVudExpc3RlbmVyKFwiY29tcGxldGVcIiwgaGFuZGxlcik7XG5cdCAqIFx0fVxuXHQgKlxuXHQgKiBAZXZlbnQgY29tcGxldGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiBnZXRGcmFtZSBpcyBjYWxsZWQgd2l0aCBhIHZhbGlkIGZyYW1lIGluZGV4LiBUaGlzIGlzIHByaW1hcmlseSBpbnRlbmRlZCBmb3IgdXNlIGJ5IHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0QnVpbGRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aGVuIGRvaW5nIG9uLWRlbWFuZCByZW5kZXJpbmcuXG5cdCAqIEBldmVudCBnZXRmcmFtZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGZyYW1lIGluZGV4LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZnJhbWUgVGhlIGZyYW1lIG9iamVjdCB0aGF0IGdldEZyYW1lIHdpbGwgcmV0dXJuLlxuXHQgKi9cblxuXG4vLyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldC9hbmltYXRpb25zOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgZ2V0QW5pbWF0aW9uc1xuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRwLmdldEFuaW1hdGlvbnMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYW5pbWF0aW9ucy5zbGljZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBhdmFpbGFibGUgYW5pbWF0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGlzIHNwcml0ZSBzaGVldCBhcyBzdHJpbmdzLlxuXHQgKiBAcHJvcGVydHkgYW5pbWF0aW9uc1xuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMocCwge1xuXHRcdFx0YW5pbWF0aW9uczogeyBnZXQ6IHAuZ2V0QW5pbWF0aW9ucyB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHt9XG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uLCBvciBpbiB0aGUgd2hvbGUgc3ByaXRlXG5cdCAqIHNoZWV0IGlmIHRoZSBhbmltYXRpb24gcGFyYW0gaXMgb21pdHRlZC4gUmV0dXJucyAwIGlmIHRoZSBzcHJpdGVzaGVldCByZWxpZXMgb24gY2FsY3VsYXRlZCBmcmFtZSBjb3VudHMsIGFuZFxuXHQgKiB0aGUgaW1hZ2VzIGhhdmUgbm90IGJlZW4gZnVsbHkgbG9hZGVkLlxuXHQgKiBAbWV0aG9kIGdldE51bUZyYW1lc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gYW5pbWF0aW9uIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gZ2V0IGEgZnJhbWUgY291bnQgZm9yLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBhbmltYXRpb24sIG9yIGluIHRoZSBlbnRpcmUgc3ByaXRlIHNoZWV0IGlmIHRoZSBhbmltYXRpb24gcGFyYW0gaXMgb21pdHRlZC5cblx0ICovXG5cdHAuZ2V0TnVtRnJhbWVzID0gZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG5cdFx0aWYgKGFuaW1hdGlvbiA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZnJhbWVzID8gdGhpcy5fZnJhbWVzLmxlbmd0aCA6IHRoaXMuX251bUZyYW1lcyB8fCAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgZGF0YSA9IHRoaXMuX2RhdGFbYW5pbWF0aW9uXTtcblx0XHRcdGlmIChkYXRhID09IG51bGwpIHsgcmV0dXJuIDA7IH1cblx0XHRcdGVsc2UgeyByZXR1cm4gZGF0YS5mcmFtZXMubGVuZ3RoOyB9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIG9iamVjdCBkZWZpbmluZyB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbi4gVGhlIHJldHVybmVkIG9iamVjdCBjb250YWluczo8VUw+XG5cdCAqIFx0PExJPmZyYW1lczogYW4gYXJyYXkgb2YgdGhlIGZyYW1lIGlkcyBpbiB0aGUgYW5pbWF0aW9uPC9MST5cblx0ICogXHQ8TEk+c3BlZWQ6IHRoZSBwbGF5YmFjayBzcGVlZCBmb3IgdGhpcyBhbmltYXRpb248L0xJPlxuXHQgKiBcdDxMST5uYW1lOiB0aGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uPC9MST5cblx0ICogXHQ8TEk+bmV4dDogdGhlIGRlZmF1bHQgYW5pbWF0aW9uIHRvIHBsYXkgbmV4dC4gSWYgdGhlIGFuaW1hdGlvbiBsb29wcywgdGhlIG5hbWUgYW5kIG5leHQgcHJvcGVydHkgd2lsbCBiZSB0aGVcblx0ICogXHRzYW1lLjwvTEk+XG5cdCAqIDwvVUw+XG5cdCAqIEBtZXRob2QgZ2V0QW5pbWF0aW9uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gZ2V0LlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IGEgZ2VuZXJpYyBvYmplY3Qgd2l0aCBmcmFtZXMsIHNwZWVkLCBuYW1lLCBhbmQgbmV4dCBwcm9wZXJ0aWVzLlxuXHQgKiovXG5cdHAuZ2V0QW5pbWF0aW9uID0gZnVuY3Rpb24obmFtZSkge1xuXHRcdHJldHVybiB0aGlzLl9kYXRhW25hbWVdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIG9iamVjdCBzcGVjaWZ5aW5nIHRoZSBpbWFnZSBhbmQgc291cmNlIHJlY3Qgb2YgdGhlIHNwZWNpZmllZCBmcmFtZS4gVGhlIHJldHVybmVkIG9iamVjdCBoYXM6PFVMPlxuXHQgKiBcdDxMST5hbiBpbWFnZSBwcm9wZXJ0eSBob2xkaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBpbWFnZSBvYmplY3QgaW4gd2hpY2ggdGhlIGZyYW1lIGlzIGZvdW5kPC9MST5cblx0ICogXHQ8TEk+YSByZWN0IHByb3BlcnR5IGNvbnRhaW5pbmcgYSBSZWN0YW5nbGUgaW5zdGFuY2Ugd2hpY2ggZGVmaW5lcyB0aGUgYm91bmRhcmllcyBmb3IgdGhlIGZyYW1lIHdpdGhpbiB0aGF0XG5cdCAqIFx0aW1hZ2UuPC9MST5cblx0ICogXHQ8TEk+IEEgcmVnWCBhbmQgcmVnWSBwcm9wZXJ0eSBjb3JyZXNwb25kaW5nIHRvIHRoZSByZWdYL1kgdmFsdWVzIGZvciB0aGUgZnJhbWUuXG5cdCAqIDwvVUw+XG5cdCAqIEBtZXRob2QgZ2V0RnJhbWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lSW5kZXggVGhlIGluZGV4IG9mIHRoZSBmcmFtZS5cblx0ICogQHJldHVybiB7T2JqZWN0fSBhIGdlbmVyaWMgb2JqZWN0IHdpdGggaW1hZ2UgYW5kIHJlY3QgcHJvcGVydGllcy4gUmV0dXJucyBudWxsIGlmIHRoZSBmcmFtZSBkb2VzIG5vdCBleGlzdC5cblx0ICoqL1xuXHRwLmdldEZyYW1lID0gZnVuY3Rpb24oZnJhbWVJbmRleCkge1xuXHRcdHZhciBmcmFtZTtcblx0XHRpZiAodGhpcy5fZnJhbWVzICYmIChmcmFtZT10aGlzLl9mcmFtZXNbZnJhbWVJbmRleF0pKSB7IHJldHVybiBmcmFtZTsgfVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge3sjY3Jvc3NMaW5rIFwiUmVjdGFuZ2xlXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlIGRlZmluaW5nIHRoZSBib3VuZHMgb2YgdGhlIHNwZWNpZmllZCBmcmFtZSByZWxhdGl2ZVxuXHQgKiB0byB0aGUgb3JpZ2luLiBGb3IgZXhhbXBsZSwgYSA5MCB4IDcwIGZyYW1lIHdpdGggYSByZWdYIG9mIDUwIGFuZCBhIHJlZ1kgb2YgNDAgd291bGQgcmV0dXJuOlxuXHQgKlxuXHQgKiBcdFt4PS01MCwgeT0tNDAsIHdpZHRoPTkwLCBoZWlnaHQ9NzBdXG5cdCAqXG5cdCAqIEBtZXRob2QgZ2V0RnJhbWVCb3VuZHNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lSW5kZXggVGhlIGluZGV4IG9mIHRoZSBmcmFtZS5cblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IFtyZWN0YW5nbGVdIEEgUmVjdGFuZ2xlIGluc3RhbmNlIHRvIGNvcHkgdGhlIHZhbHVlcyBpbnRvLiBCeSBkZWZhdWx0IGEgbmV3IGluc3RhbmNlIGlzIGNyZWF0ZWQuXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gQSBSZWN0YW5nbGUgaW5zdGFuY2UuIFJldHVybnMgbnVsbCBpZiB0aGUgZnJhbWUgZG9lcyBub3QgZXhpc3QsIG9yIHRoZSBpbWFnZSBpcyBub3QgZnVsbHkgbG9hZGVkLlxuXHQgKiovXG5cdHAuZ2V0RnJhbWVCb3VuZHMgPSBmdW5jdGlvbihmcmFtZUluZGV4LCByZWN0YW5nbGUpIHtcblx0XHR2YXIgZnJhbWUgPSB0aGlzLmdldEZyYW1lKGZyYW1lSW5kZXgpO1xuXHRcdHJldHVybiBmcmFtZSA/IChyZWN0YW5nbGV8fG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoKSkuc2V0VmFsdWVzKC1mcmFtZS5yZWdYLCAtZnJhbWUucmVnWSwgZnJhbWUucmVjdC53aWR0aCwgZnJhbWUucmVjdC5oZWlnaHQpIDogbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1Nwcml0ZVNoZWV0XVwiO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcHJpdGVTaGVldCBjYW5ub3QgYmUgY2xvbmVkLiBBIFNwcml0ZVNoZWV0IGNhbiBiZSBzaGFyZWQgYnkgbXVsdGlwbGUgU3ByaXRlIGluc3RhbmNlcyB3aXRob3V0IGNsb25pbmcgaXQuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3coXCJTcHJpdGVTaGVldCBjYW5ub3QgYmUgY2xvbmVkLlwiKVxuXHR9O1xuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9wYXJzZURhdGFcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIFNwcml0ZVNoZWV0IGRhdGEuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9wYXJzZURhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG5cdFx0dmFyIGksbCxvLGE7XG5cdFx0aWYgKGRhdGEgPT0gbnVsbCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuZnJhbWVyYXRlID0gZGF0YS5mcmFtZXJhdGV8fDA7XG5cblx0XHQvLyBwYXJzZSBpbWFnZXM6XG5cdFx0aWYgKGRhdGEuaW1hZ2VzICYmIChsPWRhdGEuaW1hZ2VzLmxlbmd0aCkgPiAwKSB7XG5cdFx0XHRhID0gdGhpcy5faW1hZ2VzID0gW107XG5cdFx0XHRmb3IgKGk9MDsgaTxsOyBpKyspIHtcblx0XHRcdFx0dmFyIGltZyA9IGRhdGEuaW1hZ2VzW2ldO1xuXHRcdFx0XHRpZiAodHlwZW9mIGltZyA9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0dmFyIHNyYyA9IGltZztcblx0XHRcdFx0XHRpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuXHRcdFx0XHRcdGltZy5zcmMgPSBzcmM7XG5cdFx0XHRcdH1cblx0XHRcdFx0YS5wdXNoKGltZyk7XG5cdFx0XHRcdGlmICghaW1nLmdldENvbnRleHQgJiYgIWltZy5uYXR1cmFsV2lkdGgpIHtcblx0XHRcdFx0XHR0aGlzLl9sb2FkQ291bnQrKztcblx0XHRcdFx0XHR0aGlzLmNvbXBsZXRlID0gZmFsc2U7XG5cdFx0XHRcdFx0KGZ1bmN0aW9uKG8pIHsgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyBvLl9oYW5kbGVJbWFnZUxvYWQoKTsgfSB9KSh0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHBhcnNlIGZyYW1lczpcblx0XHRpZiAoZGF0YS5mcmFtZXMgPT0gbnVsbCkgeyAvLyBub3RoaW5nXG5cdFx0fSBlbHNlIGlmIChkYXRhLmZyYW1lcyBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHR0aGlzLl9mcmFtZXMgPSBbXTtcblx0XHRcdGEgPSBkYXRhLmZyYW1lcztcblx0XHRcdGZvciAoaT0wLGw9YS5sZW5ndGg7aTxsO2krKykge1xuXHRcdFx0XHR2YXIgYXJyID0gYVtpXTtcblx0XHRcdFx0dGhpcy5fZnJhbWVzLnB1c2goe2ltYWdlOnRoaXMuX2ltYWdlc1thcnJbNF0/YXJyWzRdOjBdLCByZWN0Om5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoYXJyWzBdLGFyclsxXSxhcnJbMl0sYXJyWzNdKSwgcmVnWDphcnJbNV18fDAsIHJlZ1k6YXJyWzZdfHwwIH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvID0gZGF0YS5mcmFtZXM7XG5cdFx0XHR0aGlzLl9mcmFtZVdpZHRoID0gby53aWR0aDtcblx0XHRcdHRoaXMuX2ZyYW1lSGVpZ2h0ID0gby5oZWlnaHQ7XG5cdFx0XHR0aGlzLl9yZWdYID0gby5yZWdYfHwwO1xuXHRcdFx0dGhpcy5fcmVnWSA9IG8ucmVnWXx8MDtcblx0XHRcdHRoaXMuX3NwYWNpbmcgPSBvLnNwYWNpbmd8fDA7XG5cdFx0XHR0aGlzLl9tYXJnaW4gPSBvLm1hcmdpbnx8MDtcblx0XHRcdHRoaXMuX251bUZyYW1lcyA9IG8uY291bnQ7XG5cdFx0XHRpZiAodGhpcy5fbG9hZENvdW50ID09IDApIHsgdGhpcy5fY2FsY3VsYXRlRnJhbWVzKCk7IH1cblx0XHR9XG5cblx0XHQvLyBwYXJzZSBhbmltYXRpb25zOlxuXHRcdHRoaXMuX2FuaW1hdGlvbnMgPSBbXTtcblx0XHRpZiAoKG89ZGF0YS5hbmltYXRpb25zKSAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl9kYXRhID0ge307XG5cdFx0XHR2YXIgbmFtZTtcblx0XHRcdGZvciAobmFtZSBpbiBvKSB7XG5cdFx0XHRcdHZhciBhbmltID0ge25hbWU6bmFtZX07XG5cdFx0XHRcdHZhciBvYmogPSBvW25hbWVdO1xuXHRcdFx0XHRpZiAodHlwZW9mIG9iaiA9PSBcIm51bWJlclwiKSB7IC8vIHNpbmdsZSBmcmFtZVxuXHRcdFx0XHRcdGEgPSBhbmltLmZyYW1lcyA9IFtvYmpdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5KSB7IC8vIHNpbXBsZVxuXHRcdFx0XHRcdGlmIChvYmoubGVuZ3RoID09IDEpIHsgYW5pbS5mcmFtZXMgPSBbb2JqWzBdXTsgfVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0YW5pbS5zcGVlZCA9IG9ialszXTtcblx0XHRcdFx0XHRcdGFuaW0ubmV4dCA9IG9ialsyXTtcblx0XHRcdFx0XHRcdGEgPSBhbmltLmZyYW1lcyA9IFtdO1xuXHRcdFx0XHRcdFx0Zm9yIChpPW9ialswXTtpPD1vYmpbMV07aSsrKSB7XG5cdFx0XHRcdFx0XHRcdGEucHVzaChpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7IC8vIGNvbXBsZXhcblx0XHRcdFx0XHRhbmltLnNwZWVkID0gb2JqLnNwZWVkO1xuXHRcdFx0XHRcdGFuaW0ubmV4dCA9IG9iai5uZXh0O1xuXHRcdFx0XHRcdHZhciBmcmFtZXMgPSBvYmouZnJhbWVzO1xuXHRcdFx0XHRcdGEgPSBhbmltLmZyYW1lcyA9ICh0eXBlb2YgZnJhbWVzID09IFwibnVtYmVyXCIpID8gW2ZyYW1lc10gOiBmcmFtZXMuc2xpY2UoMCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGFuaW0ubmV4dCA9PT0gdHJ1ZSB8fCBhbmltLm5leHQgPT09IHVuZGVmaW5lZCkgeyBhbmltLm5leHQgPSBuYW1lOyB9IC8vIGxvb3Bcblx0XHRcdFx0aWYgKGFuaW0ubmV4dCA9PT0gZmFsc2UgfHwgKGEubGVuZ3RoIDwgMiAmJiBhbmltLm5leHQgPT0gbmFtZSkpIHsgYW5pbS5uZXh0ID0gbnVsbDsgfSAvLyBzdG9wXG5cdFx0XHRcdGlmICghYW5pbS5zcGVlZCkgeyBhbmltLnNwZWVkID0gMTsgfVxuXHRcdFx0XHR0aGlzLl9hbmltYXRpb25zLnB1c2gobmFtZSk7XG5cdFx0XHRcdHRoaXMuX2RhdGFbbmFtZV0gPSBhbmltO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlSW1hZ2VMb2FkXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9oYW5kbGVJbWFnZUxvYWQgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoLS10aGlzLl9sb2FkQ291bnQgPT0gMCkge1xuXHRcdFx0dGhpcy5fY2FsY3VsYXRlRnJhbWVzKCk7XG5cdFx0XHR0aGlzLmNvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfY2FsY3VsYXRlRnJhbWVzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9jYWxjdWxhdGVGcmFtZXMgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fZnJhbWVzIHx8IHRoaXMuX2ZyYW1lV2lkdGggPT0gMCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2ZyYW1lcyA9IFtdO1xuXG5cdFx0dmFyIG1heEZyYW1lcyA9IHRoaXMuX251bUZyYW1lcyB8fCAxMDAwMDA7IC8vIGlmIHdlIGdvIG92ZXIgdGhpcywgc29tZXRoaW5nIGlzIHdyb25nLlxuXHRcdHZhciBmcmFtZUNvdW50ID0gMCwgZnJhbWVXaWR0aCA9IHRoaXMuX2ZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0ID0gdGhpcy5fZnJhbWVIZWlnaHQ7XG5cdFx0dmFyIHNwYWNpbmcgPSB0aGlzLl9zcGFjaW5nLCBtYXJnaW4gPSB0aGlzLl9tYXJnaW47XG5cdFx0XG5cdFx0aW1nTG9vcDpcblx0XHRmb3IgKHZhciBpPTAsIGltZ3M9dGhpcy5faW1hZ2VzOyBpPGltZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpbWcgPSBpbWdzW2ldLCBpbWdXID0gaW1nLndpZHRoLCBpbWdIID0gaW1nLmhlaWdodDtcblxuXHRcdFx0dmFyIHkgPSBtYXJnaW47XG5cdFx0XHR3aGlsZSAoeSA8PSBpbWdILW1hcmdpbi1mcmFtZUhlaWdodCkge1xuXHRcdFx0XHR2YXIgeCA9IG1hcmdpbjtcblx0XHRcdFx0d2hpbGUgKHggPD0gaW1nVy1tYXJnaW4tZnJhbWVXaWR0aCkge1xuXHRcdFx0XHRcdGlmIChmcmFtZUNvdW50ID49IG1heEZyYW1lcykgeyBicmVhayBpbWdMb29wOyB9XG5cdFx0XHRcdFx0ZnJhbWVDb3VudCsrO1xuXHRcdFx0XHRcdHRoaXMuX2ZyYW1lcy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0aW1hZ2U6IGltZyxcblx0XHRcdFx0XHRcdFx0cmVjdDogbmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSh4LCB5LCBmcmFtZVdpZHRoLCBmcmFtZUhlaWdodCksXG5cdFx0XHRcdFx0XHRcdHJlZ1g6IHRoaXMuX3JlZ1gsXG5cdFx0XHRcdFx0XHRcdHJlZ1k6IHRoaXMuX3JlZ1lcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHggKz0gZnJhbWVXaWR0aCtzcGFjaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHkgKz0gZnJhbWVIZWlnaHQrc3BhY2luZztcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fbnVtRnJhbWVzID0gZnJhbWVDb3VudDtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLlNwcml0ZVNoZWV0ID0gY3JlYXRlanMucHJvbW90ZShTcHJpdGVTaGVldCwgXCJFdmVudERpc3BhdGNoZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gR3JhcGhpY3MuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFRoZSBHcmFwaGljcyBjbGFzcyBleHBvc2VzIGFuIGVhc3kgdG8gdXNlIEFQSSBmb3IgZ2VuZXJhdGluZyB2ZWN0b3IgZHJhd2luZyBpbnN0cnVjdGlvbnMgYW5kIGRyYXdpbmcgdGhlbSB0byBhXG5cdCAqIHNwZWNpZmllZCBjb250ZXh0LiBOb3RlIHRoYXQgeW91IGNhbiB1c2UgR3JhcGhpY3Mgd2l0aG91dCBhbnkgZGVwZW5kZW5jeSBvbiB0aGUgRWFzZWxKUyBmcmFtZXdvcmsgYnkgY2FsbGluZyB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGRpcmVjdGx5LCBvciBpdCBjYW4gYmUgdXNlZCB3aXRoIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBvYmplY3QgdG8gZHJhdyB2ZWN0b3IgZ3JhcGhpY3Mgd2l0aGluIHRoZVxuXHQgKiBjb250ZXh0IG9mIGFuIEVhc2VsSlMgZGlzcGxheSBsaXN0LlxuXHQgKlxuXHQgKiBUaGVyZSBhcmUgdHdvIGFwcHJvYWNoZXMgdG8gd29ya2luZyB3aXRoIEdyYXBoaWNzIG9iamVjdDogY2FsbGluZyBtZXRob2RzIG9uIGEgR3JhcGhpY3MgaW5zdGFuY2UgKHRoZSBcIkdyYXBoaWNzIEFQSVwiKSwgb3Jcblx0ICogaW5zdGFudGlhdGluZyBHcmFwaGljcyBjb21tYW5kIG9iamVjdHMgYW5kIGFkZGluZyB0aGVtIHRvIHRoZSBncmFwaGljcyBxdWV1ZSB2aWEge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBUaGUgZm9ybWVyIGFic3RyYWN0cyB0aGUgbGF0dGVyLCBzaW1wbGlmeWluZyBiZWdpbm5pbmcgYW5kIGVuZGluZyBwYXRocywgZmlsbHMsIGFuZCBzdHJva2VzLlxuXHQgKlxuXHQgKiAgICAgIHZhciBnID0gbmV3IGNyZWF0ZWpzLkdyYXBoaWNzKCk7XG5cdCAqICAgICAgZy5zZXRTdHJva2VTdHlsZSgxKTtcblx0ICogICAgICBnLmJlZ2luU3Ryb2tlKFwiIzAwMDAwMFwiKTtcblx0ICogICAgICBnLmJlZ2luRmlsbChcInJlZFwiKTtcblx0ICogICAgICBnLmRyYXdDaXJjbGUoMCwwLDMwKTtcblx0ICpcblx0ICogQWxsIGRyYXdpbmcgbWV0aG9kcyBpbiBHcmFwaGljcyByZXR1cm4gdGhlIEdyYXBoaWNzIGluc3RhbmNlLCBzbyB0aGV5IGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLiBGb3IgZXhhbXBsZSxcblx0ICogdGhlIGZvbGxvd2luZyBsaW5lIG9mIGNvZGUgd291bGQgZ2VuZXJhdGUgdGhlIGluc3RydWN0aW9ucyB0byBkcmF3IGEgcmVjdGFuZ2xlIHdpdGggYSByZWQgc3Ryb2tlIGFuZCBibHVlIGZpbGw6XG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5iZWdpblN0cm9rZShcInJlZFwiKS5iZWdpbkZpbGwoXCJibHVlXCIpLmRyYXdSZWN0KDIwLCAyMCwgMTAwLCA1MCk7XG5cdCAqXG5cdCAqIEVhY2ggZ3JhcGhpY3MgQVBJIGNhbGwgZ2VuZXJhdGVzIGEgY29tbWFuZCBvYmplY3QgKHNlZSBiZWxvdykuIFRoZSBsYXN0IGNvbW1hbmQgdG8gYmUgY3JlYXRlZCBjYW4gYmUgYWNjZXNzZWQgdmlhXG5cdCAqIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2NvbW1hbmQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06XG5cdCAqXG5cdCAqICAgICAgdmFyIGZpbGxDb21tYW5kID0gbXlHcmFwaGljcy5iZWdpbkZpbGwoXCJyZWRcIikuY29tbWFuZDtcblx0ICogICAgICAvLyAuLi4gbGF0ZXIsIHVwZGF0ZSB0aGUgZmlsbCBzdHlsZS9jb2xvcjpcblx0ICogICAgICBmaWxsQ29tbWFuZC5zdHlsZSA9IFwiYmx1ZVwiO1xuXHQgKiAgICAgIC8vIG9yIGNoYW5nZSBpdCB0byBhIGJpdG1hcCBmaWxsOlxuXHQgKiAgICAgIGZpbGxDb21tYW5kLmJpdG1hcChteUltYWdlKTtcblx0ICpcblx0ICogRm9yIG1vcmUgZGlyZWN0IGNvbnRyb2wgb2YgcmVuZGVyaW5nLCB5b3UgY2FuIGluc3RhbnRpYXRlIGFuZCBhcHBlbmQgY29tbWFuZCBvYmplY3RzIHRvIHRoZSBncmFwaGljcyBxdWV1ZSBkaXJlY3RseS4gSW4gdGhpcyBjYXNlLCB5b3Vcblx0ICogbmVlZCB0byBtYW5hZ2UgcGF0aCBjcmVhdGlvbiBtYW51YWxseSwgYW5kIGVuc3VyZSB0aGF0IGZpbGwvc3Ryb2tlIGlzIGFwcGxpZWQgdG8gYSBkZWZpbmVkIHBhdGg6XG5cdCAqXG5cdCAqICAgICAgLy8gc3RhcnQgYSBuZXcgcGF0aC4gR3JhcGhpY3MuYmVnaW5DbWQgaXMgYSByZXVzYWJsZSBCZWdpblBhdGggaW5zdGFuY2U6XG5cdCAqICAgICAgbXlHcmFwaGljcy5hcHBlbmQoY3JlYXRlanMuR3JhcGhpY3MuYmVnaW5DbWQpO1xuXHQgKiAgICAgIC8vIHdlIG5lZWQgdG8gZGVmaW5lIHRoZSBwYXRoIGJlZm9yZSBhcHBseWluZyB0aGUgZmlsbDpcblx0ICogICAgICB2YXIgY2lyY2xlID0gbmV3IGNyZWF0ZWpzLkdyYXBoaWNzLkNpcmNsZSgwLDAsMzApO1xuXHQgKiAgICAgIG15R3JhcGhpY3MuYXBwZW5kKGNpcmNsZSk7XG5cdCAqICAgICAgLy8gZmlsbCB0aGUgcGF0aCB3ZSBqdXN0IGRlZmluZWQ6XG5cdCAqICAgICAgdmFyIGZpbGwgPSBuZXcgY3JlYXRlanMuR3JhcGhpY3MuRmlsbChcInJlZFwiKTtcblx0ICogICAgICBteUdyYXBoaWNzLmFwcGVuZChmaWxsKTtcblx0ICpcblx0ICogVGhlc2UgYXBwcm9hY2hlcyBjYW4gYmUgdXNlZCB0b2dldGhlciwgZm9yIGV4YW1wbGUgdG8gaW5zZXJ0IGEgY3VzdG9tIGNvbW1hbmQ6XG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5iZWdpbkZpbGwoXCJyZWRcIik7XG5cdCAqICAgICAgdmFyIGN1c3RvbUNvbW1hbmQgPSBuZXcgQ3VzdG9tU3BpcmFsQ29tbWFuZChldGMpO1xuXHQgKiAgICAgIG15R3JhcGhpY3MuYXBwZW5kKGN1c3RvbUNvbW1hbmQpO1xuXHQgKiAgICAgIG15R3JhcGhpY3MuYmVnaW5GaWxsKFwiYmx1ZVwiKTtcblx0ICogICAgICBteUdyYXBoaWNzLmRyYXdDaXJjbGUoMCwgMCwgMzApO1xuXHQgKlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm8gb24gY3JlYXRpbmcgY3VzdG9tIGNvbW1hbmRzLlxuXHQgKlxuXHQgKiA8aDQ+VGlueSBBUEk8L2g0PlxuXHQgKiBUaGUgR3JhcGhpY3MgY2xhc3MgYWxzbyBpbmNsdWRlcyBhIFwidGlueSBBUElcIiwgd2hpY2ggaXMgb25lIG9yIHR3by1sZXR0ZXIgbWV0aG9kcyB0aGF0IGFyZSBzaG9ydGN1dHMgZm9yIGFsbCBvZiB0aGVcblx0ICogR3JhcGhpY3MgbWV0aG9kcy4gVGhlc2UgbWV0aG9kcyBhcmUgZ3JlYXQgZm9yIGNyZWF0aW5nIGNvbXBhY3QgaW5zdHJ1Y3Rpb25zLCBhbmQgaXMgdXNlZCBieSB0aGUgVG9vbGtpdCBmb3IgQ3JlYXRlSlNcblx0ICogdG8gZ2VuZXJhdGUgcmVhZGFibGUgY29kZS4gQWxsIHRpbnkgbWV0aG9kcyBhcmUgbWFya2VkIGFzIHByb3RlY3RlZCwgc28geW91IGNhbiB2aWV3IHRoZW0gYnkgZW5hYmxpbmcgcHJvdGVjdGVkXG5cdCAqIGRlc2NyaXB0aW9ucyBpbiB0aGUgZG9jcy5cblx0ICpcblx0ICogPHRhYmxlPlxuXHQgKiAgICAgPHRyPjx0ZD48Yj5UaW55PC9iPjwvdGQ+PHRkPjxiPk1ldGhvZDwvYj48L3RkPjx0ZD48Yj5UaW55PC9iPjwvdGQ+PHRkPjxiPk1ldGhvZDwvYj48L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPm10PC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvbW92ZVRvXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+bHQ8L3RkPiA8dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvbGluZVRvXCJ9fXt7L2Nyb3NzTGlua319PC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5hL2F0PC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXJjXCJ9fXt7L2Nyb3NzTGlua319IC8ge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXJjVG9cIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5idDwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlemllckN1cnZlVG9cIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5xdDwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3F1YWRyYXRpY0N1cnZlVG9cIn19e3svY3Jvc3NMaW5rfX0gKGFsc28gY3VydmVUbyk8L3RkPlxuXHQgKiAgICAgPHRkPnI8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9yZWN0XCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+Y3A8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9jbG9zZVBhdGhcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5jPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvY2xlYXJcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5mPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5GaWxsXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+bGY8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkxpbmVhckdyYWRpZW50RmlsbFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPnJmPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5SYWRpYWxHcmFkaWVudEZpbGxcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5iZjwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luQml0bWFwRmlsbFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPmVmPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZW5kRmlsbFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPnNzIC8gc2Q8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9zZXRTdHJva2VTdHlsZVwifX17ey9jcm9zc0xpbmt9fSAvIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3NldFN0cm9rZURhc2hcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5zPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5TdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5sczwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luTGluZWFyR3JhZGllbnRTdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5yczwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luUmFkaWFsR3JhZGllbnRTdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5iczwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luQml0bWFwU3Ryb2tlXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+ZXM8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9lbmRTdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5kcjwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdSZWN0XCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+cnI8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Um91bmRSZWN0XCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+cmM8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Um91bmRSZWN0Q29tcGxleFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPmRjPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd0NpcmNsZVwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPmRlPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd0VsbGlwc2VcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5kcDwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdQb2x5U3RhclwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPnA8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kZWNvZGVQYXRoXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogPC90YWJsZT5cblx0ICpcblx0ICogSGVyZSBpcyB0aGUgYWJvdmUgZXhhbXBsZSwgdXNpbmcgdGhlIHRpbnkgQVBJIGluc3RlYWQuXG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5zKFwicmVkXCIpLmYoXCJibHVlXCIpLnIoMjAsIDIwLCAxMDAsIDUwKTtcblx0ICpcblx0ICogQGNsYXNzIEdyYXBoaWNzXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIEdyYXBoaWNzKCkge1xuXG5cblx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBIb2xkcyBhIHJlZmVyZW5jZSB0byB0aGUgbGFzdCBjb21tYW5kIHRoYXQgd2FzIGNyZWF0ZWQgb3IgYXBwZW5kZWQuIEZvciBleGFtcGxlLCB5b3UgY291bGQgcmV0YWluIGEgcmVmZXJlbmNlXG5cdFx0ICogdG8gYSBGaWxsIGNvbW1hbmQgaW4gb3JkZXIgdG8gZHluYW1pY2FsbHkgdXBkYXRlIHRoZSBjb2xvciBsYXRlciBieSB1c2luZzpcblx0XHQgKiBcdFx0bXlGaWxsID0gbXlHcmFwaGljcy5iZWdpbkZpbGwoXCJyZWRcIikuY29tbWFuZDtcblx0XHQgKiBcdFx0Ly8gdXBkYXRlIGNvbG9yIGxhdGVyOlxuXHRcdCAqIFx0XHRteUZpbGwuc3R5bGUgPSBcInllbGxvd1wiO1xuXHRcdCAqIEBwcm9wZXJ0eSBjb21tYW5kXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICoqL1xuXHRcdHRoaXMuY29tbWFuZCA9IG51bGw7XG5cblxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3N0cm9rZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7U3Ryb2tlfVxuXHRcdCAqKi9cblx0XHR0aGlzLl9zdHJva2UgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9zdHJva2VTdHlsZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7U3Ryb2tlU3R5bGV9XG5cdFx0ICoqL1xuXHRcdHRoaXMuX3N0cm9rZVN0eWxlID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX29sZFN0cm9rZVN0eWxlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtTdHJva2VTdHlsZX1cblx0XHQgKiovXG5cdFx0dGhpcy5fb2xkU3Ryb2tlU3R5bGUgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfc3Ryb2tlRGFzaFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7U3Ryb2tlRGFzaH1cblx0XHQgKiovXG5cdFx0dGhpcy5fc3Ryb2tlRGFzaCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9vbGRTdHJva2VEYXNoXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtTdHJva2VEYXNofVxuXHRcdCAqKi9cblx0XHR0aGlzLl9vbGRTdHJva2VEYXNoID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfc3Ryb2tlSWdub3JlU2NhbGVcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqKi9cblx0XHR0aGlzLl9zdHJva2VJZ25vcmVTY2FsZSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9maWxsXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtGaWxsfVxuXHRcdCAqKi9cblx0XHR0aGlzLl9maWxsID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfaW5zdHJ1Y3Rpb25zXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiovXG5cdFx0dGhpcy5faW5zdHJ1Y3Rpb25zID0gW107XG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgdGhlIGxhc3QgaW5zdHJ1Y3Rpb24gaW5kZXggdGhhdCB3YXMgY29tbWl0dGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfY29tbWl0SW5kZXhcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiovXG5cdFx0dGhpcy5fY29tbWl0SW5kZXggPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVW5jb21taXR0ZWQgaW5zdHJ1Y3Rpb25zLlxuXHRcdCAqIEBwcm9wZXJ0eSBfYWN0aXZlSW5zdHJ1Y3Rpb25zXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiovXG5cdFx0dGhpcy5fYWN0aXZlSW5zdHJ1Y3Rpb25zID0gW107XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGluZGljYXRlcyB0aGF0IHRoZXJlIGhhdmUgYmVlbiBjaGFuZ2VzIHRvIHRoZSBhY3RpdmVJbnN0cnVjdGlvbiBsaXN0IHNpbmNlIHRoZSBsYXN0IHVwZGF0ZUluc3RydWN0aW9ucyBjYWxsLlxuXHRcdCAqIEBwcm9wZXJ0eSBfZGlydHlcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiovXG5cdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEluZGV4IHRvIGRyYXcgZnJvbSBpZiBhIHN0b3JlIG9wZXJhdGlvbiBoYXMgaGFwcGVuZWQuXG5cdFx0ICogQHByb3BlcnR5IF9zdG9yZUluZGV4XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLl9zdG9yZUluZGV4ID0gMDtcblxuXHQvLyBzZXR1cDpcblx0XHR0aGlzLmNsZWFyKCk7XG5cdH1cblx0dmFyIHAgPSBHcmFwaGljcy5wcm90b3R5cGU7XG5cdHZhciBHID0gR3JhcGhpY3M7IC8vIHNob3J0Y3V0XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cbi8vIHN0YXRpYyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgYSBDU1MgY29tcGF0aWJsZSBjb2xvciBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBSR0IgbnVtZXJpYyBjb2xvciB2YWx1ZXMgaW4gdGhlIGZvcm1hdFxuXHQgKiBcInJnYmEoMjU1LDI1NSwyNTUsMS4wKVwiLCBvciBpZiBhbHBoYSBpcyBudWxsIHRoZW4gaW4gdGhlIGZvcm1hdCBcInJnYigyNTUsMjU1LDI1NSlcIi4gRm9yIGV4YW1wbGUsXG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuR3JhcGhpY3MuZ2V0UkdCKDUwLCAxMDAsIDE1MCwgMC41KTtcblx0ICogICAgICAvLyBSZXR1cm5zIFwicmdiYSg1MCwxMDAsMTUwLDAuNSlcIlxuXHQgKlxuXHQgKiBJdCBhbHNvIHN1cHBvcnRzIHBhc3NpbmcgYSBzaW5nbGUgaGV4IGNvbG9yIHZhbHVlIGFzIHRoZSBmaXJzdCBwYXJhbSwgYW5kIGFuIG9wdGlvbmFsIGFscGhhIHZhbHVlIGFzIHRoZSBzZWNvbmRcblx0ICogcGFyYW0uIEZvciBleGFtcGxlLFxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLkdyYXBoaWNzLmdldFJHQigweEZGMDBGRiwgMC4yKTtcblx0ICogICAgICAvLyBSZXR1cm5zIFwicmdiYSgyNTUsMCwyNTUsMC4yKVwiXG5cdCAqXG5cdCAqIEBtZXRob2QgZ2V0UkdCXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIgVGhlIHJlZCBjb21wb25lbnQgZm9yIHRoZSBjb2xvciwgYmV0d2VlbiAwIGFuZCAweEZGICgyNTUpLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZyBUaGUgZ3JlZW4gY29tcG9uZW50IGZvciB0aGUgY29sb3IsIGJldHdlZW4gMCBhbmQgMHhGRiAoMjU1KS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIGJsdWUgY29tcG9uZW50IGZvciB0aGUgY29sb3IsIGJldHdlZW4gMCBhbmQgMHhGRiAoMjU1KS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthbHBoYV0gVGhlIGFscGhhIGNvbXBvbmVudCBmb3IgdGhlIGNvbG9yIHdoZXJlIDAgaXMgZnVsbHkgdHJhbnNwYXJlbnQgYW5kIDEgaXMgZnVsbHkgb3BhcXVlLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IEEgQ1NTIGNvbXBhdGlibGUgY29sb3Igc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgUkdCIG51bWVyaWMgY29sb3IgdmFsdWVzIGluIHRoZSBmb3JtYXRcblx0ICogXCJyZ2JhKDI1NSwyNTUsMjU1LDEuMClcIiwgb3IgaWYgYWxwaGEgaXMgbnVsbCB0aGVuIGluIHRoZSBmb3JtYXQgXCJyZ2IoMjU1LDI1NSwyNTUpXCIuXG5cdCAqKi9cblx0R3JhcGhpY3MuZ2V0UkdCID0gZnVuY3Rpb24ociwgZywgYiwgYWxwaGEpIHtcblx0XHRpZiAociAhPSBudWxsICYmIGIgPT0gbnVsbCkge1xuXHRcdFx0YWxwaGEgPSBnO1xuXHRcdFx0YiA9IHImMHhGRjtcblx0XHRcdGcgPSByPj44JjB4RkY7XG5cdFx0XHRyID0gcj4+MTYmMHhGRjtcblx0XHR9XG5cdFx0aWYgKGFscGhhID09IG51bGwpIHtcblx0XHRcdHJldHVybiBcInJnYihcIityK1wiLFwiK2crXCIsXCIrYitcIilcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFwicmdiYShcIityK1wiLFwiK2crXCIsXCIrYitcIixcIithbHBoYStcIilcIjtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBDU1MgY29tcGF0aWJsZSBjb2xvciBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBIU0wgbnVtZXJpYyBjb2xvciB2YWx1ZXMgaW4gdGhlIGZvcm1hdCBcImhzbGEoMzYwLDEwMCwxMDAsMS4wKVwiLFxuXHQgKiBvciBpZiBhbHBoYSBpcyBudWxsIHRoZW4gaW4gdGhlIGZvcm1hdCBcImhzbCgzNjAsMTAwLDEwMClcIi5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5HcmFwaGljcy5nZXRIU0woMTUwLCAxMDAsIDcwKTtcblx0ICogICAgICAvLyBSZXR1cm5zIFwiaHNsKDE1MCwxMDAsNzApXCJcblx0ICpcblx0ICogQG1ldGhvZCBnZXRIU0xcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaHVlIFRoZSBodWUgY29tcG9uZW50IGZvciB0aGUgY29sb3IsIGJldHdlZW4gMCBhbmQgMzYwLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvbiBUaGUgc2F0dXJhdGlvbiBjb21wb25lbnQgZm9yIHRoZSBjb2xvciwgYmV0d2VlbiAwIGFuZCAxMDAuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsaWdodG5lc3MgVGhlIGxpZ2h0bmVzcyBjb21wb25lbnQgZm9yIHRoZSBjb2xvciwgYmV0d2VlbiAwIGFuZCAxMDAuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYWxwaGFdIFRoZSBhbHBoYSBjb21wb25lbnQgZm9yIHRoZSBjb2xvciB3aGVyZSAwIGlzIGZ1bGx5IHRyYW5zcGFyZW50IGFuZCAxIGlzIGZ1bGx5IG9wYXF1ZS5cblx0ICogQHJldHVybiB7U3RyaW5nfSBBIENTUyBjb21wYXRpYmxlIGNvbG9yIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIEhTTCBudW1lcmljIGNvbG9yIHZhbHVlcyBpbiB0aGUgZm9ybWF0XG5cdCAqIFwiaHNsYSgzNjAsMTAwLDEwMCwxLjApXCIsIG9yIGlmIGFscGhhIGlzIG51bGwgdGhlbiBpbiB0aGUgZm9ybWF0IFwiaHNsKDM2MCwxMDAsMTAwKVwiLlxuXHQgKiovXG5cdEdyYXBoaWNzLmdldEhTTCA9IGZ1bmN0aW9uKGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBhbHBoYSkge1xuXHRcdGlmIChhbHBoYSA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gXCJoc2woXCIrKGh1ZSUzNjApK1wiLFwiK3NhdHVyYXRpb24rXCIlLFwiK2xpZ2h0bmVzcytcIiUpXCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBcImhzbGEoXCIrKGh1ZSUzNjApK1wiLFwiK3NhdHVyYXRpb24rXCIlLFwiK2xpZ2h0bmVzcytcIiUsXCIrYWxwaGErXCIpXCI7XG5cdFx0fVxuXHR9O1xuXG5cbi8vIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQSByZXVzYWJsZSBpbnN0YW5jZSBvZiB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9CZWdpblBhdGhcIn19e3svY3Jvc3NMaW5rfX0gdG8gYXZvaWRcblx0ICogdW5uZWNlc3NhcnkgaW5zdGFudGlhdGlvbi5cblx0ICogQHByb3BlcnR5IGJlZ2luQ21kXG5cdCAqIEB0eXBlIHtHcmFwaGljcy5CZWdpblBhdGh9XG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHQgLy8gZGVmaW5lZCBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cblxuXHQvKipcblx0ICogTWFwIG9mIEJhc2U2NCBjaGFyYWN0ZXJzIHRvIHZhbHVlcy4gVXNlZCBieSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kZWNvZGVQYXRoXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAcHJvcGVydHkgQkFTRV82NFxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHR5cGUge09iamVjdH1cblx0ICoqL1xuXHRHcmFwaGljcy5CQVNFXzY0ID0ge1wiQVwiOjAsXCJCXCI6MSxcIkNcIjoyLFwiRFwiOjMsXCJFXCI6NCxcIkZcIjo1LFwiR1wiOjYsXCJIXCI6NyxcIklcIjo4LFwiSlwiOjksXCJLXCI6MTAsXCJMXCI6MTEsXCJNXCI6MTIsXCJOXCI6MTMsXCJPXCI6MTQsXCJQXCI6MTUsXCJRXCI6MTYsXCJSXCI6MTcsXCJTXCI6MTgsXCJUXCI6MTksXCJVXCI6MjAsXCJWXCI6MjEsXCJXXCI6MjIsXCJYXCI6MjMsXCJZXCI6MjQsXCJaXCI6MjUsXCJhXCI6MjYsXCJiXCI6MjcsXCJjXCI6MjgsXCJkXCI6MjksXCJlXCI6MzAsXCJmXCI6MzEsXCJnXCI6MzIsXCJoXCI6MzMsXCJpXCI6MzQsXCJqXCI6MzUsXCJrXCI6MzYsXCJsXCI6MzcsXCJtXCI6MzgsXCJuXCI6MzksXCJvXCI6NDAsXCJwXCI6NDEsXCJxXCI6NDIsXCJyXCI6NDMsXCJzXCI6NDQsXCJ0XCI6NDUsXCJ1XCI6NDYsXCJ2XCI6NDcsXCJ3XCI6NDgsXCJ4XCI6NDksXCJ5XCI6NTAsXCJ6XCI6NTEsXCIwXCI6NTIsXCIxXCI6NTMsXCIyXCI6NTQsXCIzXCI6NTUsXCI0XCI6NTYsXCI1XCI6NTcsXCI2XCI6NTgsXCI3XCI6NTksXCI4XCI6NjAsXCI5XCI6NjEsXCIrXCI6NjIsXCIvXCI6NjN9O1xuXG5cdC8qKlxuXHQgKiBNYXBzIG51bWVyaWMgdmFsdWVzIGZvciB0aGUgY2FwcyBwYXJhbWV0ZXIgb2Yge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3Mvc2V0U3Ryb2tlU3R5bGVcIn19e3svY3Jvc3NMaW5rfX0gdG9cblx0ICogY29ycmVzcG9uZGluZyBzdHJpbmcgdmFsdWVzLiBUaGlzIGlzIHByaW1hcmlseSBmb3IgdXNlIHdpdGggdGhlIHRpbnkgQVBJLiBUaGUgbWFwcGluZ3MgYXJlIGFzIGZvbGxvd3M6IDAgdG9cblx0ICogXCJidXR0XCIsIDEgdG8gXCJyb3VuZFwiLCBhbmQgMiB0byBcInNxdWFyZVwiLlxuXHQgKiBGb3IgZXhhbXBsZSwgdG8gc2V0IHRoZSBsaW5lIGNhcHMgdG8gXCJzcXVhcmVcIjpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLnNzKDE2LCAyKTtcblx0ICpcblx0ICogQHByb3BlcnR5IFNUUk9LRV9DQVBTX01BUFxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiovXG5cdEdyYXBoaWNzLlNUUk9LRV9DQVBTX01BUCA9IFtcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiXTtcblxuXHQvKipcblx0ICogTWFwcyBudW1lcmljIHZhbHVlcyBmb3IgdGhlIGpvaW50cyBwYXJhbWV0ZXIgb2Yge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3Mvc2V0U3Ryb2tlU3R5bGVcIn19e3svY3Jvc3NMaW5rfX0gdG9cblx0ICogY29ycmVzcG9uZGluZyBzdHJpbmcgdmFsdWVzLiBUaGlzIGlzIHByaW1hcmlseSBmb3IgdXNlIHdpdGggdGhlIHRpbnkgQVBJLiBUaGUgbWFwcGluZ3MgYXJlIGFzIGZvbGxvd3M6IDAgdG9cblx0ICogXCJtaXRlclwiLCAxIHRvIFwicm91bmRcIiwgYW5kIDIgdG8gXCJiZXZlbFwiLlxuXHQgKiBGb3IgZXhhbXBsZSwgdG8gc2V0IHRoZSBsaW5lIGpvaW50cyB0byBcImJldmVsXCI6XG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5zcygxNiwgMCwgMik7XG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBTVFJPS0VfSk9JTlRTX01BUFxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiovXG5cdEdyYXBoaWNzLlNUUk9LRV9KT0lOVFNfTUFQID0gW1wibWl0ZXJcIiwgXCJyb3VuZFwiLCBcImJldmVsXCJdO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX2N0eFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cblx0ICoqL1xuXHR2YXIgY2FudmFzID0gKGNyZWF0ZWpzLmNyZWF0ZUNhbnZhcz9jcmVhdGVqcy5jcmVhdGVDYW52YXMoKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpKTtcblx0aWYgKGNhbnZhcy5nZXRDb250ZXh0KSB7XG5cdFx0R3JhcGhpY3MuX2N0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDE7XG5cdH1cblxuXG4vLyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9pbnN0cnVjdGlvbnM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXRJbnN0cnVjdGlvbnNcblx0ICogQHJldHVybiB7QXJyYXl9XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0cC5nZXRJbnN0cnVjdGlvbnMgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnMoKTtcblx0XHRyZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBncmFwaGljcyBpbnN0cnVjdGlvbnMgYXJyYXkuIEVhY2ggZW50cnkgaXMgYSBncmFwaGljcyBjb21tYW5kIG9iamVjdCAoZXguIEdyYXBoaWNzLkZpbGwsIEdyYXBoaWNzLlJlY3QpXG5cdCAqIE1vZGlmeWluZyB0aGUgcmV0dXJuZWQgYXJyYXkgZGlyZWN0bHkgaXMgbm90IHJlY29tbWVuZGVkLCBhbmQgaXMgbGlrZWx5IHRvIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW91ci5cblx0ICpcblx0ICogVGhpcyBwcm9wZXJ0eSBpcyBtYWlubHkgaW50ZW5kZWQgZm9yIGludHJvc3BlY3Rpb24gb2YgdGhlIGluc3RydWN0aW9ucyAoZXguIGZvciBncmFwaGljcyBleHBvcnQpLlxuXHQgKiBAcHJvcGVydHkgaW5zdHJ1Y3Rpb25zXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cdFx0XHRpbnN0cnVjdGlvbnM6IHsgZ2V0OiBwLmdldEluc3RydWN0aW9ucyB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHt9XG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBHcmFwaGljcyBpbnN0YW5jZSBoYXMgbm8gZHJhd2luZyBjb21tYW5kcy5cblx0ICogQG1ldGhvZCBpc0VtcHR5XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGlzIEdyYXBoaWNzIGluc3RhbmNlIGhhcyBubyBkcmF3aW5nIGNvbW1hbmRzLlxuXHQgKiovXG5cdHAuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhKHRoaXMuX2luc3RydWN0aW9ucy5sZW5ndGggfHwgdGhpcy5fYWN0aXZlSW5zdHJ1Y3Rpb25zLmxlbmd0aCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBkcmF3IHdhcyBoYW5kbGVkICh1c2VmdWwgZm9yIG92ZXJyaWRpbmcgZnVuY3Rpb25hbGl0eSkuXG5cdCAqXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBkcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIE9wdGlvbmFsIGRhdGEgdGhhdCBpcyBwYXNzZWQgdG8gZ3JhcGhpY3MgY29tbWFuZCBleGVjIG1ldGhvZHMuIFdoZW4gY2FsbGVkIGZyb20gYSBTaGFwZSBpbnN0YW5jZSwgdGhlIHNoYXBlIHBhc3NlcyBpdHNlbGYgYXMgdGhlIGRhdGEgcGFyYW1ldGVyLiBUaGlzIGNhbiBiZSB1c2VkIGJ5IGN1c3RvbSBncmFwaGljIGNvbW1hbmRzIHRvIGluc2VydCBjb250ZXh0dWFsIGRhdGEuXG5cdCAqKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBkYXRhKSB7XG5cdFx0dGhpcy5fdXBkYXRlSW5zdHJ1Y3Rpb25zKCk7XG5cdFx0dmFyIGluc3RyID0gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuXHRcdGZvciAodmFyIGk9dGhpcy5fc3RvcmVJbmRleCwgbD1pbnN0ci5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRpbnN0cltpXS5leGVjKGN0eCwgZGF0YSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBvbmx5IHRoZSBwYXRoIGRlc2NyaWJlZCBmb3IgdGhpcyBHcmFwaGljcyBpbnN0YW5jZSwgc2tpcHBpbmcgYW55IG5vbi1wYXRoIGluc3RydWN0aW9ucywgaW5jbHVkaW5nIGZpbGwgYW5kXG5cdCAqIHN0cm9rZSBkZXNjcmlwdGlvbnMuIFVzZWQgZm9yIDxjb2RlPkRpc3BsYXlPYmplY3QubWFzazwvY29kZT4gdG8gZHJhdyB0aGUgY2xpcHBpbmcgcGF0aCwgZm9yIGV4YW1wbGUuXG5cdCAqXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBkcmF3QXNQYXRoXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqKi9cblx0cC5kcmF3QXNQYXRoID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0dGhpcy5fdXBkYXRlSW5zdHJ1Y3Rpb25zKCk7XG5cdFx0dmFyIGluc3RyLCBpbnN0cnMgPSB0aGlzLl9pbnN0cnVjdGlvbnM7XG5cdFx0Zm9yICh2YXIgaT10aGlzLl9zdG9yZUluZGV4LCBsPWluc3Rycy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHQvLyB0aGUgZmlyc3QgY29tbWFuZCBpcyBhbHdheXMgYSBiZWdpblBhdGggY29tbWFuZC5cblx0XHRcdGlmICgoaW5zdHIgPSBpbnN0cnNbaV0pLnBhdGggIT09IGZhbHNlKSB7IGluc3RyLmV4ZWMoY3R4KTsgfVxuXHRcdH1cblx0fTtcblxuXG4vLyBwdWJsaWMgbWV0aG9kcyB0aGF0IG1hcCBkaXJlY3RseSB0byBjb250ZXh0IDJEIGNhbGxzOlxuXHQvKipcblx0ICogTW92ZXMgdGhlIGRyYXdpbmcgcG9pbnQgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbi4gQSB0aW55IEFQSSBtZXRob2QgXCJtdFwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIG1vdmVUb1xuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBtb3ZlIHRvLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBtb3ZlIHRvLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAubW92ZVRvID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5Nb3ZlVG8oeCx5KSwgdHJ1ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgbGluZSBmcm9tIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9pbnQgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbiwgd2hpY2ggYmVjb21lIHRoZSBuZXcgY3VycmVudCBkcmF3aW5nXG5cdCAqIHBvaW50LiBBIHRpbnkgQVBJIG1ldGhvZCBcImx0XCIgYWxzbyBleGlzdHMuXG5cdCAqXG5cdCAqIEZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiwgcmVhZCB0aGVcblx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2NvbXBsZXgtc2hhcGVzLShwYXRocylcIj5cblx0ICogd2hhdHdnIHNwZWM8L2E+LlxuXHQgKiBAbWV0aG9kIGxpbmVUb1xuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBkcmF3IHRvLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBkcmF3IHRvLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAubGluZVRvID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5MaW5lVG8oeCx5KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGFuIGFyYyB3aXRoIHRoZSBzcGVjaWZpZWQgY29udHJvbCBwb2ludHMgYW5kIHJhZGl1cy4gIEZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiwgcmVhZCB0aGVcblx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2RvbS1jb250ZXh0LTJkLWFyY3RvXCI+XG5cdCAqIHdoYXR3ZyBzcGVjPC9hPi4gQSB0aW55IEFQSSBtZXRob2QgXCJhdFwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGFyY1RvXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geTFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hcmNUbyA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuQXJjVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBhbiBhcmMgZGVmaW5lZCBieSB0aGUgcmFkaXVzLCBzdGFydEFuZ2xlIGFuZCBlbmRBbmdsZSBhcmd1bWVudHMsIGNlbnRlcmVkIGF0IHRoZSBwb3NpdGlvbiAoeCwgeSkuIEZvclxuXHQgKiBleGFtcGxlLCB0byBkcmF3IGEgZnVsbCBjaXJjbGUgd2l0aCBhIHJhZGl1cyBvZiAyMCBjZW50ZXJlZCBhdCAoMTAwLCAxMDApOlxuXHQgKlxuXHQgKiAgICAgIGFyYygxMDAsIDEwMCwgMjAsIDAsIE1hdGguUEkqMik7XG5cdCAqXG5cdCAqIEZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiwgcmVhZCB0aGVcblx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2RvbS1jb250ZXh0LTJkLWFyY1wiPndoYXR3ZyBzcGVjPC9hPi5cblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJhXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYXJjXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0QW5nbGUgTWVhc3VyZWQgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGVuZEFuZ2xlIE1lYXN1cmVkIGluIHJhZGlhbnMuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYW50aWNsb2Nrd2lzZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYXJjID0gZnVuY3Rpb24oeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5BcmMoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIHF1YWRyYXRpYyBjdXJ2ZSBmcm9tIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9pbnQgdG8gKHgsIHkpIHVzaW5nIHRoZSBjb250cm9sIHBvaW50IChjcHgsIGNweSkuIEZvciBkZXRhaWxlZFxuXHQgKiBpbmZvcm1hdGlvbiwgcmVhZCB0aGUgPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2RvbS1jb250ZXh0LTJkLXF1YWRyYXRpY2N1cnZldG9cIj5cblx0ICogd2hhdHdnIHNwZWM8L2E+LiBBIHRpbnkgQVBJIG1ldGhvZCBcInF0XCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgcXVhZHJhdGljQ3VydmVUb1xuXHQgKiBAcGFyYW0ge051bWJlcn0gY3B4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbihjcHgsIGNweSwgeCwgeSkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5RdWFkcmF0aWNDdXJ2ZVRvKGNweCwgY3B5LCB4LCB5KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgYmV6aWVyIGN1cnZlIGZyb20gdGhlIGN1cnJlbnQgZHJhd2luZyBwb2ludCB0byAoeCwgeSkgdXNpbmcgdGhlIGNvbnRyb2wgcG9pbnRzIChjcDF4LCBjcDF5KSBhbmQgKGNwMngsXG5cdCAqIGNwMnkpLiBGb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24sIHJlYWQgdGhlXG5cdCAqIDxhIGhyZWY9XCJodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCNkb20tY29udGV4dC0yZC1iZXppZXJjdXJ2ZXRvXCI+XG5cdCAqIHdoYXR3ZyBzcGVjPC9hPi4gQSB0aW55IEFQSSBtZXRob2QgXCJidFwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlemllckN1cnZlVG9cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMXhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMXlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMnhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMnlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlemllckN1cnZlVG8gPSBmdW5jdGlvbihjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLkJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIHJlY3RhbmdsZSBhdCAoeCwgeSkgd2l0aCB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQgdXNpbmcgdGhlIGN1cnJlbnQgZmlsbCBhbmQvb3Igc3Ryb2tlLlxuXHQgKiBGb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24sIHJlYWQgdGhlXG5cdCAqIDxhIGhyZWY9XCJodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCNkb20tY29udGV4dC0yZC1yZWN0XCI+XG5cdCAqIHdoYXR3ZyBzcGVjPC9hPi4gQSB0aW55IEFQSSBtZXRob2QgXCJyXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgcmVjdFxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdyBXaWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoIEhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5yZWN0ID0gZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5SZWN0KHgsIHksIHcsIGgpKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2xvc2VzIHRoZSBjdXJyZW50IHBhdGgsIGVmZmVjdGl2ZWx5IGRyYXdpbmcgYSBsaW5lIGZyb20gdGhlIGN1cnJlbnQgZHJhd2luZyBwb2ludCB0byB0aGUgZmlyc3QgZHJhd2luZyBwb2ludCBzcGVjaWZpZWRcblx0ICogc2luY2UgdGhlIGZpbGwgb3Igc3Ryb2tlIHdhcyBsYXN0IHNldC4gQSB0aW55IEFQSSBtZXRob2QgXCJjcFwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGNsb3NlUGF0aFxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuY2xvc2VQYXRoID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FjdGl2ZUluc3RydWN0aW9ucy5sZW5ndGggPyB0aGlzLmFwcGVuZChuZXcgRy5DbG9zZVBhdGgoKSkgOiB0aGlzO1xuXHR9O1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzIHRoYXQgcm91Z2hseSBtYXAgdG8gRmxhc2ggZ3JhcGhpY3MgQVBJczpcblx0LyoqXG5cdCAqIENsZWFycyBhbGwgZHJhd2luZyBpbnN0cnVjdGlvbnMsIGVmZmVjdGl2ZWx5IHJlc2V0dGluZyB0aGlzIEdyYXBoaWNzIGluc3RhbmNlLiBBbnkgbGluZSBhbmQgZmlsbCBzdHlsZXMgd2lsbCBuZWVkXG5cdCAqIHRvIGJlIHJlZGVmaW5lZCB0byBkcmF3IHNoYXBlcyBmb2xsb3dpbmcgYSBjbGVhciBjYWxsLiBBIHRpbnkgQVBJIG1ldGhvZCBcImNcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBjbGVhclxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9pbnN0cnVjdGlvbnMubGVuZ3RoID0gdGhpcy5fYWN0aXZlSW5zdHJ1Y3Rpb25zLmxlbmd0aCA9IHRoaXMuX2NvbW1pdEluZGV4ID0gMDtcblx0XHR0aGlzLl9zdHJva2VTdHlsZSA9IHRoaXMuX29sZFN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlID0gdGhpcy5fZmlsbCA9IHRoaXMuX3N0cm9rZURhc2ggPSB0aGlzLl9vbGRTdHJva2VEYXNoID0gbnVsbDtcblx0XHR0aGlzLl9kaXJ0eSA9IHRoaXMuX3N0cm9rZUlnbm9yZVNjYWxlID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2lucyBhIGZpbGwgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbG9yLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguIEEgdGlueSBBUEkgbWV0aG9kIFwiZlwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luRmlsbFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQSBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZSAoZXguIFwicmVkXCIsIFwiI0ZGMDAwMFwiLCBvciBcInJnYmEoMjU1LDAsMCwwLjUpXCIpLiBTZXR0aW5nIHRvXG5cdCAqIG51bGwgd2lsbCByZXN1bHQgaW4gbm8gZmlsbC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlZ2luRmlsbCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldEZpbGwoY29sb3IgPyBuZXcgRy5GaWxsKGNvbG9yKSA6IG51bGwpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSBsaW5lYXIgZ3JhZGllbnQgZmlsbCBkZWZpbmVkIGJ5IHRoZSBsaW5lICh4MCwgeTApIHRvICh4MSwgeTEpLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguIEZvclxuXHQgKiBleGFtcGxlLCB0aGUgZm9sbG93aW5nIGNvZGUgZGVmaW5lcyBhIGJsYWNrIHRvIHdoaXRlIHZlcnRpY2FsIGdyYWRpZW50IHJhbmdpbmcgZnJvbSAyMHB4IHRvIDEyMHB4LCBhbmQgZHJhd3MgYVxuXHQgKiBzcXVhcmUgdG8gZGlzcGxheSBpdDpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLmJlZ2luTGluZWFyR3JhZGllbnRGaWxsKFtcIiMwMDBcIixcIiNGRkZcIl0sIFswLCAxXSwgMCwgMjAsIDAsIDEyMCkuZHJhd1JlY3QoMjAsIDIwLCAxMjAsIDEyMCk7XG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwibGZcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBiZWdpbkxpbmVhckdyYWRpZW50RmlsbFxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnMgQW4gYXJyYXkgb2YgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWVzLiBGb3IgZXhhbXBsZSwgW1wiI0YwMFwiLFwiIzAwRlwiXSB3b3VsZCBkZWZpbmUgYSBncmFkaWVudFxuXHQgKiBkcmF3aW5nIGZyb20gcmVkIHRvIGJsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvcyBBbiBhcnJheSBvZiBncmFkaWVudCBwb3NpdGlvbnMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgY29sb3JzLiBGb3IgZXhhbXBsZSwgWzAuMSwgMC45XSB3b3VsZCBkcmF3XG5cdCAqIHRoZSBmaXJzdCBjb2xvciB0byAxMCUgdGhlbiBpbnRlcnBvbGF0aW5nIHRvIHRoZSBzZWNvbmQgY29sb3IgYXQgOTAlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDAgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwIFRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MSBUaGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmVnaW5MaW5lYXJHcmFkaWVudEZpbGwgPSBmdW5jdGlvbihjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCB4MSwgeTEpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0RmlsbChuZXcgRy5GaWxsKCkubGluZWFyR3JhZGllbnQoY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgeDEsIHkxKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2lucyBhIHJhZGlhbCBncmFkaWVudCBmaWxsLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIGNvZGUgZGVmaW5lcyBhIHJlZCB0b1xuXHQgKiBibHVlIHJhZGlhbCBncmFkaWVudCBjZW50ZXJlZCBhdCAoMTAwLCAxMDApLCB3aXRoIGEgcmFkaXVzIG9mIDUwLCBhbmQgZHJhd3MgYSBjaXJjbGUgdG8gZGlzcGxheSBpdDpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLmJlZ2luUmFkaWFsR3JhZGllbnRGaWxsKFtcIiNGMDBcIixcIiMwMEZcIl0sIFswLCAxXSwgMTAwLCAxMDAsIDAsIDEwMCwgMTAwLCA1MCkuZHJhd0NpcmNsZSgxMDAsIDEwMCwgNTApO1xuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcInJmXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYmVnaW5SYWRpYWxHcmFkaWVudEZpbGxcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzIEFuIGFycmF5IG9mIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlcy4gRm9yIGV4YW1wbGUsIFtcIiNGMDBcIixcIiMwMEZcIl0gd291bGQgZGVmaW5lXG5cdCAqIGEgZ3JhZGllbnQgZHJhd2luZyBmcm9tIHJlZCB0byBibHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3MgQW4gYXJyYXkgb2YgZ3JhZGllbnQgcG9zaXRpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNvbG9ycy4gRm9yIGV4YW1wbGUsIFswLjEsXG5cdCAqIDAuOV0gd291bGQgZHJhdyB0aGUgZmlyc3QgY29sb3IgdG8gMTAlIHRoZW4gaW50ZXJwb2xhdGluZyB0byB0aGUgc2Vjb25kIGNvbG9yIGF0IDkwJS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjAgUmFkaXVzIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjEgUmFkaXVzIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlZ2luUmFkaWFsR3JhZGllbnRGaWxsID0gZnVuY3Rpb24oY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0RmlsbChuZXcgRy5GaWxsKCkucmFkaWFsR3JhZGllbnQoY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpKTtcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW5zIGEgcGF0dGVybiBmaWxsIHVzaW5nIHRoZSBzcGVjaWZpZWQgaW1hZ2UuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC4gQSB0aW55IEFQSSBtZXRob2QgXCJiZlwiIGFsc29cblx0ICogZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luQml0bWFwRmlsbFxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnR9IGltYWdlIFRoZSBJbWFnZSwgQ2FudmFzLCBvciBWaWRlbyBvYmplY3QgdG8gdXNlXG5cdCAqIGFzIHRoZSBwYXR0ZXJuLiBNdXN0IGJlIGxvYWRlZCBwcmlvciB0byBjcmVhdGluZyBhIGJpdG1hcCBmaWxsLCBvciB0aGUgZmlsbCB3aWxsIGJlIGVtcHR5LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcmVwZXRpdGlvbiBPcHRpb25hbC4gSW5kaWNhdGVzIHdoZXRoZXIgdG8gcmVwZWF0IHRoZSBpbWFnZSBpbiB0aGUgZmlsbCBhcmVhLiBPbmUgb2YgXCJyZXBlYXRcIixcblx0ICogXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuIERlZmF1bHRzIHRvIFwicmVwZWF0XCIuIE5vdGUgdGhhdCBGaXJlZm94IGRvZXMgbm90IHN1cHBvcnQgXCJyZXBlYXQteFwiIG9yXG5cdCAqIFwicmVwZWF0LXlcIiAobGF0ZXN0IHRlc3RzIHdlcmUgaW4gRkYgMjAuMCksIGFuZCB3aWxsIGRlZmF1bHQgdG8gXCJyZXBlYXRcIi5cblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4IE9wdGlvbmFsLiBTcGVjaWZpZXMgYSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZm9yIHRoZSBiaXRtYXAgZmlsbC4gVGhpcyB0cmFuc2Zvcm1hdGlvblxuXHQgKiB3aWxsIGJlIGFwcGxpZWQgcmVsYXRpdmUgdG8gdGhlIHBhcmVudCB0cmFuc2Zvcm0uXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5iZWdpbkJpdG1hcEZpbGwgPSBmdW5jdGlvbihpbWFnZSwgcmVwZXRpdGlvbiwgbWF0cml4KSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldEZpbGwobmV3IEcuRmlsbChudWxsLG1hdHJpeCkuYml0bWFwKGltYWdlLCByZXBldGl0aW9uKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGgsIGFuZCBiZWdpbnMgYSBuZXcgb25lIHdpdGggbm8gZmlsbC4gRnVuY3Rpb25hbGx5IGlkZW50aWNhbCB0byA8Y29kZT5iZWdpbkZpbGwobnVsbCk8L2NvZGU+LlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImVmXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgZW5kRmlsbFxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuZW5kRmlsbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmJlZ2luRmlsbCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBzdHJva2Ugc3R5bGUuIExpa2UgYWxsIGRyYXdpbmcgbWV0aG9kcywgdGhpcyBjYW4gYmUgY2hhaW5lZCwgc28geW91IGNhbiBkZWZpbmVcblx0ICogdGhlIHN0cm9rZSBzdHlsZSBhbmQgY29sb3IgaW4gYSBzaW5nbGUgbGluZSBvZiBjb2RlIGxpa2Ugc286XG5cdCAqXG5cdCAqIFx0bXlHcmFwaGljcy5zZXRTdHJva2VTdHlsZSg4LFwicm91bmRcIikuYmVnaW5TdHJva2UoXCIjRjAwXCIpO1xuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcInNzXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2Qgc2V0U3Ryb2tlU3R5bGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRoaWNrbmVzcyBUaGUgd2lkdGggb2YgdGhlIHN0cm9rZS5cblx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IFtjYXBzPTBdIEluZGljYXRlcyB0aGUgdHlwZSBvZiBjYXBzIHRvIHVzZSBhdCB0aGUgZW5kIG9mIGxpbmVzLiBPbmUgb2YgYnV0dCxcblx0ICogcm91bmQsIG9yIHNxdWFyZS4gRGVmYXVsdHMgdG8gXCJidXR0XCIuIEFsc28gYWNjZXB0cyB0aGUgdmFsdWVzIDAgKGJ1dHQpLCAxIChyb3VuZCksIGFuZCAyIChzcXVhcmUpIGZvciB1c2Ugd2l0aFxuXHQgKiB0aGUgdGlueSBBUEkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBbam9pbnRzPTBdIFNwZWNpZmllcyB0aGUgdHlwZSBvZiBqb2ludHMgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVyZSB0d28gbGluZXMgbWVldC5cblx0ICogT25lIG9mIGJldmVsLCByb3VuZCwgb3IgbWl0ZXIuIERlZmF1bHRzIHRvIFwibWl0ZXJcIi4gQWxzbyBhY2NlcHRzIHRoZSB2YWx1ZXMgMCAobWl0ZXIpLCAxIChyb3VuZCksIGFuZCAyIChiZXZlbClcblx0ICogZm9yIHVzZSB3aXRoIHRoZSB0aW55IEFQSS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttaXRlckxpbWl0PTEwXSBJZiBqb2ludHMgaXMgc2V0IHRvIFwibWl0ZXJcIiwgdGhlbiB5b3UgY2FuIHNwZWNpZnkgYSBtaXRlciBsaW1pdCByYXRpbyB3aGljaFxuXHQgKiBjb250cm9scyBhdCB3aGF0IHBvaW50IGEgbWl0ZXJlZCBqb2ludCB3aWxsIGJlIGNsaXBwZWQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZVNjYWxlPWZhbHNlXSBJZiB0cnVlLCB0aGUgc3Ryb2tlIHdpbGwgYmUgZHJhd24gYXQgdGhlIHNwZWNpZmllZCB0aGlja25lc3MgcmVnYXJkbGVzc1xuXHQgKiBvZiBhY3RpdmUgdHJhbnNmb3JtYXRpb25zLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuc2V0U3Ryb2tlU3R5bGUgPSBmdW5jdGlvbih0aGlja25lc3MsIGNhcHMsIGpvaW50cywgbWl0ZXJMaW1pdCwgaWdub3JlU2NhbGUpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnModHJ1ZSk7XG5cdFx0dGhpcy5fc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbW1hbmQgPSBuZXcgRy5TdHJva2VTdHlsZSh0aGlja25lc3MsIGNhcHMsIGpvaW50cywgbWl0ZXJMaW1pdCwgaWdub3JlU2NhbGUpO1xuXG5cdFx0Ly8gaWdub3JlU2NhbGUgbGl2ZXMgb24gU3Ryb2tlLCBub3QgU3Ryb2tlU3R5bGUsIHNvIHdlIGRvIGEgbGl0dGxlIHRyaWNrZXJ5OlxuXHRcdGlmICh0aGlzLl9zdHJva2UpIHsgdGhpcy5fc3Ryb2tlLmlnbm9yZVNjYWxlID0gaWdub3JlU2NhbGU7IH1cblx0XHR0aGlzLl9zdHJva2VJZ25vcmVTY2FsZSA9IGlnbm9yZVNjYWxlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFNldHMgb3IgY2xlYXJzIHRoZSBzdHJva2UgZGFzaCBwYXR0ZXJuLlxuXHQgKlxuXHQgKiBcdG15R3JhcGhpY3Muc2V0U3Ryb2tlRGFzaChbMjAsIDEwXSwgMCk7XG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIGBzZGAgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2Qgc2V0U3Ryb2tlRGFzaFxuXHQgKiBAcGFyYW0ge0FycmF5fSBbc2VnbWVudHNdIEFuIGFycmF5IHNwZWNpZnlpbmcgdGhlIGRhc2ggcGF0dGVybiwgYWx0ZXJuYXRpbmcgYmV0d2VlbiBsaW5lIGFuZCBnYXAuXG5cdCAqIEZvciBleGFtcGxlLCBgWzIwLDEwXWAgd291bGQgY3JlYXRlIGEgcGF0dGVybiBvZiAyMCBwaXhlbCBsaW5lcyB3aXRoIDEwIHBpeGVsIGdhcHMgYmV0d2VlbiB0aGVtLlxuXHQgKiBQYXNzaW5nIG51bGwgb3IgYW4gZW1wdHkgYXJyYXkgd2lsbCBjbGVhciB0aGUgZXhpc3Rpbmcgc3Ryb2tlIGRhc2guXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0PTBdIFRoZSBvZmZzZXQgb2YgdGhlIGRhc2ggcGF0dGVybi4gRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCBpbmNyZW1lbnQgdGhpcyB2YWx1ZSB0byBjcmVhdGUgYSBcIm1hcmNoaW5nIGFudHNcIiBlZmZlY3QuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5zZXRTdHJva2VEYXNoID0gZnVuY3Rpb24oc2VnbWVudHMsIG9mZnNldCkge1xuXHRcdHRoaXMuX3VwZGF0ZUluc3RydWN0aW9ucyh0cnVlKTtcblx0XHR0aGlzLl9zdHJva2VEYXNoID0gdGhpcy5jb21tYW5kID0gbmV3IEcuU3Ryb2tlRGFzaChzZWdtZW50cywgb2Zmc2V0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW5zIGEgc3Ryb2tlIHdpdGggdGhlIHNwZWNpZmllZCBjb2xvci4gVGhpcyBlbmRzIHRoZSBjdXJyZW50IHN1Yi1wYXRoLiBBIHRpbnkgQVBJIG1ldGhvZCBcInNcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBiZWdpblN0cm9rZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQSBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZSAoZXguIFwiI0ZGMDAwMFwiLCBcInJlZFwiLCBvciBcInJnYmEoMjU1LDAsMCwwLjUpXCIpLiBTZXR0aW5nIHRvXG5cdCAqIG51bGwgd2lsbCByZXN1bHQgaW4gbm8gc3Ryb2tlLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmVnaW5TdHJva2UgPSBmdW5jdGlvbihjb2xvcikge1xuXHRcdHJldHVybiB0aGlzLl9zZXRTdHJva2UoY29sb3IgPyBuZXcgRy5TdHJva2UoY29sb3IpIDogbnVsbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2lucyBhIGxpbmVhciBncmFkaWVudCBzdHJva2UgZGVmaW5lZCBieSB0aGUgbGluZSAoeDAsIHkwKSB0byAoeDEsIHkxKS4gVGhpcyBlbmRzIHRoZSBjdXJyZW50IHN1Yi1wYXRoLiBGb3Jcblx0ICogZXhhbXBsZSwgdGhlIGZvbGxvd2luZyBjb2RlIGRlZmluZXMgYSBibGFjayB0byB3aGl0ZSB2ZXJ0aWNhbCBncmFkaWVudCByYW5naW5nIGZyb20gMjBweCB0byAxMjBweCwgYW5kIGRyYXdzIGFcblx0ICogc3F1YXJlIHRvIGRpc3BsYXkgaXQ6XG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5zZXRTdHJva2VTdHlsZSgxMCkuXG5cdCAqICAgICAgICAgIGJlZ2luTGluZWFyR3JhZGllbnRTdHJva2UoW1wiIzAwMFwiLFwiI0ZGRlwiXSwgWzAsIDFdLCAwLCAyMCwgMCwgMTIwKS5kcmF3UmVjdCgyMCwgMjAsIDEyMCwgMTIwKTtcblx0ICpcblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJsc1wiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luTGluZWFyR3JhZGllbnRTdHJva2Vcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzIEFuIGFycmF5IG9mIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlcy4gRm9yIGV4YW1wbGUsIFtcIiNGMDBcIixcIiMwMEZcIl0gd291bGQgZGVmaW5lXG5cdCAqIGEgZ3JhZGllbnQgZHJhd2luZyBmcm9tIHJlZCB0byBibHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3MgQW4gYXJyYXkgb2YgZ3JhZGllbnQgcG9zaXRpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNvbG9ycy4gRm9yIGV4YW1wbGUsIFswLjEsXG5cdCAqIDAuOV0gd291bGQgZHJhdyB0aGUgZmlyc3QgY29sb3IgdG8gMTAlIHRoZW4gaW50ZXJwb2xhdGluZyB0byB0aGUgc2Vjb25kIGNvbG9yIGF0IDkwJS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwIFRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDEgVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MSBUaGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlZ2luTGluZWFyR3JhZGllbnRTdHJva2UgPSBmdW5jdGlvbihjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCB4MSwgeTEpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0U3Ryb2tlKG5ldyBHLlN0cm9rZSgpLmxpbmVhckdyYWRpZW50KGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHgxLCB5MSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSByYWRpYWwgZ3JhZGllbnQgc3Ryb2tlLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIGNvZGUgZGVmaW5lcyBhIHJlZCB0b1xuXHQgKiBibHVlIHJhZGlhbCBncmFkaWVudCBjZW50ZXJlZCBhdCAoMTAwLCAxMDApLCB3aXRoIGEgcmFkaXVzIG9mIDUwLCBhbmQgZHJhd3MgYSByZWN0YW5nbGUgdG8gZGlzcGxheSBpdDpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLnNldFN0cm9rZVN0eWxlKDEwKVxuXHQgKiAgICAgICAgICAuYmVnaW5SYWRpYWxHcmFkaWVudFN0cm9rZShbXCIjRjAwXCIsXCIjMDBGXCJdLCBbMCwgMV0sIDEwMCwgMTAwLCAwLCAxMDAsIDEwMCwgNTApXG5cdCAqICAgICAgICAgIC5kcmF3UmVjdCg1MCwgOTAsIDE1MCwgMTEwKTtcblx0ICpcblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJyc1wiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luUmFkaWFsR3JhZGllbnRTdHJva2Vcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzIEFuIGFycmF5IG9mIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlcy4gRm9yIGV4YW1wbGUsIFtcIiNGMDBcIixcIiMwMEZcIl0gd291bGQgZGVmaW5lXG5cdCAqIGEgZ3JhZGllbnQgZHJhd2luZyBmcm9tIHJlZCB0byBibHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3MgQW4gYXJyYXkgb2YgZ3JhZGllbnQgcG9zaXRpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNvbG9ycy4gRm9yIGV4YW1wbGUsIFswLjEsXG5cdCAqIDAuOV0gd291bGQgZHJhdyB0aGUgZmlyc3QgY29sb3IgdG8gMTAlIHRoZW4gaW50ZXJwb2xhdGluZyB0byB0aGUgc2Vjb25kIGNvbG9yIGF0IDkwJSwgdGhlbiBkcmF3IHRoZSBzZWNvbmQgY29sb3Jcblx0ICogdG8gMTAwJS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjAgUmFkaXVzIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjEgUmFkaXVzIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlZ2luUmFkaWFsR3JhZGllbnRTdHJva2UgPSBmdW5jdGlvbihjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCByMCwgeDEsIHkxLCByMSkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRTdHJva2UobmV3IEcuU3Ryb2tlKCkucmFkaWFsR3JhZGllbnQoY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpKTtcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW5zIGEgcGF0dGVybiBmaWxsIHVzaW5nIHRoZSBzcGVjaWZpZWQgaW1hZ2UuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC4gTm90ZSB0aGF0IHVubGlrZSBiaXRtYXAgZmlsbHMsXG5cdCAqIHN0cm9rZXMgZG8gbm90IGN1cnJlbnRseSBzdXBwb3J0IGEgbWF0cml4IHBhcmFtZXRlciBkdWUgdG8gbGltaXRhdGlvbnMgaW4gdGhlIGNhbnZhcyBBUEkuIEEgdGlueSBBUEkgbWV0aG9kIFwiYnNcIlxuXHQgKiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBiZWdpbkJpdG1hcFN0cm9rZVxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnR9IGltYWdlIFRoZSBJbWFnZSwgQ2FudmFzLCBvciBWaWRlbyBvYmplY3QgdG8gdXNlXG5cdCAqIGFzIHRoZSBwYXR0ZXJuLiBNdXN0IGJlIGxvYWRlZCBwcmlvciB0byBjcmVhdGluZyBhIGJpdG1hcCBmaWxsLCBvciB0aGUgZmlsbCB3aWxsIGJlIGVtcHR5LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3JlcGV0aXRpb249cmVwZWF0XSBPcHRpb25hbC4gSW5kaWNhdGVzIHdoZXRoZXIgdG8gcmVwZWF0IHRoZSBpbWFnZSBpbiB0aGUgZmlsbCBhcmVhLiBPbmUgb2Zcblx0ICogXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuIERlZmF1bHRzIHRvIFwicmVwZWF0XCIuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5iZWdpbkJpdG1hcFN0cm9rZSA9IGZ1bmN0aW9uKGltYWdlLCByZXBldGl0aW9uKSB7XG5cdFx0Ly8gTk9URTogbWF0cml4IGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHN0cm9rZSBiZWNhdXNlIHRyYW5zZm9ybXMgb24gc3Ryb2tlcyBhbHNvIGFmZmVjdCB0aGUgZHJhd24gc3Ryb2tlIHdpZHRoLlxuXHRcdHJldHVybiB0aGlzLl9zZXRTdHJva2UobmV3IEcuU3Ryb2tlKCkuYml0bWFwKGltYWdlLCByZXBldGl0aW9uKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGgsIGFuZCBiZWdpbnMgYSBuZXcgb25lIHdpdGggbm8gc3Ryb2tlLiBGdW5jdGlvbmFsbHkgaWRlbnRpY2FsIHRvIDxjb2RlPmJlZ2luU3Ryb2tlKG51bGwpPC9jb2RlPi5cblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJlc1wiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGVuZFN0cm9rZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuZW5kU3Ryb2tlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYmVnaW5TdHJva2UoKTtcblx0fTtcblxuXHQvKipcblx0ICogTWFwcyB0aGUgZmFtaWxpYXIgQWN0aW9uU2NyaXB0IDxjb2RlPmN1cnZlVG8oKTwvY29kZT4gbWV0aG9kIHRvIHRoZSBmdW5jdGlvbmFsbHkgc2ltaWxhciB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9xdWFkcmF0aWNDdXJ2ZVRvXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC5cblx0ICogQG1ldGhvZCBxdWFkcmF0aWNDdXJ2ZVRvXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNweVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuY3VydmVUbyA9IHAucXVhZHJhdGljQ3VydmVUbztcblxuXHQvKipcblx0ICpcblx0ICogTWFwcyB0aGUgZmFtaWxpYXIgQWN0aW9uU2NyaXB0IDxjb2RlPmRyYXdSZWN0KCk8L2NvZGU+IG1ldGhvZCB0byB0aGUgZnVuY3Rpb25hbGx5IHNpbWlsYXIge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvcmVjdFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuXG5cdCAqIEBtZXRob2QgZHJhd1JlY3Rcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHcgV2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaCBIZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuZHJhd1JlY3QgPSBwLnJlY3Q7XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgcm91bmRlZCByZWN0YW5nbGUgd2l0aCBhbGwgY29ybmVycyB3aXRoIHRoZSBzcGVjaWZpZWQgcmFkaXVzLlxuXHQgKiBAbWV0aG9kIGRyYXdSb3VuZFJlY3Rcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBDb3JuZXIgcmFkaXVzLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuZHJhd1JvdW5kUmVjdCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgsIHJhZGl1cykge1xuXHRcdHJldHVybiB0aGlzLmRyYXdSb3VuZFJlY3RDb21wbGV4KHgsIHksIHcsIGgsIHJhZGl1cywgcmFkaXVzLCByYWRpdXMsIHJhZGl1cyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgcm91bmRlZCByZWN0YW5nbGUgd2l0aCBkaWZmZXJlbnQgY29ybmVyIHJhZGlpLiBTdXBwb3J0cyBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgY29ybmVyIHJhZGlpLiBBIHRpbnkgQVBJXG5cdCAqIG1ldGhvZCBcInJjXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgZHJhd1JvdW5kUmVjdENvbXBsZXhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZSB0byBkcmF3IHRoZSByb3VuZCByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgdmVydGljYWwgY29vcmRpbmF0ZSB0byBkcmF3IHRoZSByb3VuZCByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdyBUaGUgd2lkdGggb2YgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoIFRoZSBoZWlnaHQgb2YgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUTCBUb3AgbGVmdCBjb3JuZXIgcmFkaXVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzVFIgVG9wIHJpZ2h0IGNvcm5lciByYWRpdXMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCUiBCb3R0b20gcmlnaHQgY29ybmVyIHJhZGl1cy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c0JMIEJvdHRvbSBsZWZ0IGNvcm5lciByYWRpdXMuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5kcmF3Um91bmRSZWN0Q29tcGxleCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgsIHJhZGl1c1RMLCByYWRpdXNUUiwgcmFkaXVzQlIsIHJhZGl1c0JMKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLlJvdW5kUmVjdCh4LCB5LCB3LCBoLCByYWRpdXNUTCwgcmFkaXVzVFIsIHJhZGl1c0JSLCByYWRpdXNCTCkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIGNpcmNsZSB3aXRoIHRoZSBzcGVjaWZpZWQgcmFkaXVzIGF0ICh4LCB5KS5cblx0ICpcblx0ICogICAgICB2YXIgZyA9IG5ldyBjcmVhdGVqcy5HcmFwaGljcygpO1xuXHQgKlx0ICAgIGcuc2V0U3Ryb2tlU3R5bGUoMSk7XG5cdCAqXHQgICAgZy5iZWdpblN0cm9rZShjcmVhdGVqcy5HcmFwaGljcy5nZXRSR0IoMCwwLDApKTtcblx0ICpcdCAgICBnLmJlZ2luRmlsbChjcmVhdGVqcy5HcmFwaGljcy5nZXRSR0IoMjU1LDAsMCkpO1xuXHQgKlx0ICAgIGcuZHJhd0NpcmNsZSgwLDAsMyk7XG5cdCAqXG5cdCAqXHQgICAgdmFyIHMgPSBuZXcgY3JlYXRlanMuU2hhcGUoZyk7XG5cdCAqXHRcdHMueCA9IDEwMDtcblx0ICpcdFx0cy55ID0gMTAwO1xuXHQgKlxuXHQgKlx0ICAgIHN0YWdlLmFkZENoaWxkKHMpO1xuXHQgKlx0ICAgIHN0YWdlLnVwZGF0ZSgpO1xuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImRjXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgZHJhd0NpcmNsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0geCB4IGNvb3JkaW5hdGUgY2VudGVyIHBvaW50IG9mIGNpcmNsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgeSBjb29yZGluYXRlIGNlbnRlciBwb2ludCBvZiBjaXJjbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIGNpcmNsZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmRyYXdDaXJjbGUgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuQ2lyY2xlKHgsIHksIHJhZGl1cykpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBhbiBlbGxpcHNlIChvdmFsKSB3aXRoIGEgc3BlY2lmaWVkIHdpZHRoICh3KSBhbmQgaGVpZ2h0IChoKS4gU2ltaWxhciB0byB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Q2lyY2xlXCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBleGNlcHQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgY2FuIGJlIGRpZmZlcmVudC4gQSB0aW55IEFQSSBtZXRob2QgXCJkZVwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGRyYXdFbGxpcHNlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBsZWZ0IGNvb3JkaW5hdGUgcG9pbnQgb2YgdGhlIGVsbGlwc2UuIE5vdGUgdGhhdCB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdDaXJjbGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2hpY2ggZHJhd3MgZnJvbSBjZW50ZXIuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB0b3AgY29vcmRpbmF0ZSBwb2ludCBvZiB0aGUgZWxsaXBzZS4gTm90ZSB0aGF0IHRoaXMgaXMgZGlmZmVyZW50IGZyb20ge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd0NpcmNsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aGljaCBkcmF3cyBmcm9tIHRoZSBjZW50ZXIuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFRoZSBoZWlnaHQgKGhvcml6b250YWwgZGlhbWV0ZXIpIG9mIHRoZSBlbGxpcHNlLiBUaGUgaG9yaXpvbnRhbCByYWRpdXMgd2lsbCBiZSBoYWxmIG9mIHRoaXNcblx0ICogbnVtYmVyLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaCBUaGUgd2lkdGggKHZlcnRpY2FsIGRpYW1ldGVyKSBvZiB0aGUgZWxsaXBzZS4gVGhlIHZlcnRpY2FsIHJhZGl1cyB3aWxsIGJlIGhhbGYgb2YgdGhpcyBudW1iZXIuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5kcmF3RWxsaXBzZSA9IGZ1bmN0aW9uKHgsIHksIHcsIGgpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuRWxsaXBzZSh4LCB5LCB3LCBoKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgc3RhciBpZiBwb2ludFNpemUgaXMgZ3JlYXRlciB0aGFuIDAsIG9yIGEgcmVndWxhciBwb2x5Z29uIGlmIHBvaW50U2l6ZSBpcyAwIHdpdGggdGhlIHNwZWNpZmllZCBudW1iZXIgb2Zcblx0ICogcG9pbnRzLiBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyBjb2RlIHdpbGwgZHJhdyBhIGZhbWlsaWFyIDUgcG9pbnRlZCBzdGFyIHNoYXBlIGNlbnRlcmVkIGF0IDEwMCwgMTAwIGFuZCB3aXRoIGFcblx0ICogcmFkaXVzIG9mIDUwOlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3MuYmVnaW5GaWxsKFwiI0ZGMFwiKS5kcmF3UG9seVN0YXIoMTAwLCAxMDAsIDUwLCA1LCAwLjYsIC05MCk7XG5cdCAqICAgICAgLy8gTm90ZTogLTkwIG1ha2VzIHRoZSBmaXJzdCBwb2ludCB2ZXJ0aWNhbFxuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImRwXCIgYWxzbyBleGlzdHMuXG5cdCAqXG5cdCAqIEBtZXRob2QgZHJhd1BvbHlTdGFyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHNoYXBlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBQb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoZSBzaGFwZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBzaGFwZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNpZGVzIFRoZSBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBzdGFyIG9yIHNpZGVzIG9uIHRoZSBwb2x5Z29uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9pbnRTaXplIFRoZSBkZXB0aCBvciBcInBvaW50eS1uZXNzXCIgb2YgdGhlIHN0YXIgcG9pbnRzLiBBIHBvaW50U2l6ZSBvZiAwIHdpbGwgZHJhdyBhIHJlZ3VsYXJcblx0ICogcG9seWdvbiAobm8gcG9pbnRzKSwgYSBwb2ludFNpemUgb2YgMSB3aWxsIGRyYXcgbm90aGluZyBiZWNhdXNlIHRoZSBwb2ludHMgYXJlIGluZmluaXRlbHkgcG9pbnR5LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgVGhlIGFuZ2xlIG9mIHRoZSBmaXJzdCBwb2ludCAvIGNvcm5lci4gRm9yIGV4YW1wbGUgYSB2YWx1ZSBvZiAwIHdpbGwgZHJhdyB0aGUgZmlyc3QgcG9pbnRcblx0ICogZGlyZWN0bHkgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjZW50ZXIuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5kcmF3UG9seVN0YXIgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHNpZGVzLCBwb2ludFNpemUsIGFuZ2xlKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLlBvbHlTdGFyKHgsIHksIHJhZGl1cywgc2lkZXMsIHBvaW50U2l6ZSwgYW5nbGUpKTtcblx0fTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkLlxuXHQvKipcblx0ICogUmVtb3ZlZCBpbiBmYXZvdXIgb2YgdXNpbmcgY3VzdG9tIGNvbW1hbmQgb2JqZWN0cyB3aXRoIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBpbmplY3Rcblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXG5cdC8qKlxuXHQgKiBBcHBlbmRzIGEgZ3JhcGhpY3MgY29tbWFuZCBvYmplY3QgdG8gdGhlIGdyYXBoaWNzIHF1ZXVlLiBDb21tYW5kIG9iamVjdHMgZXhwb3NlIGFuIFwiZXhlY1wiIG1ldGhvZFxuXHQgKiB0aGF0IGFjY2VwdHMgdHdvIHBhcmFtZXRlcnM6IHRoZSBDb250ZXh0MkQgdG8gb3BlcmF0ZSBvbiwgYW5kIGFuIGFyYml0cmFyeSBkYXRhIG9iamVjdCBwYXNzZWQgaW50b1xuXHQgKiB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3XCJ9fXt7L2Nyb3NzTGlua319LiBUaGUgbGF0dGVyIHdpbGwgdXN1YWxseSBiZSB0aGUgU2hhcGUgaW5zdGFuY2UgdGhhdCBjYWxsZWQgZHJhdy5cblx0ICpcblx0ICogVGhpcyBtZXRob2QgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEdyYXBoaWNzIG1ldGhvZHMsIHN1Y2ggYXMgZHJhd0NpcmNsZSwgYnV0IGNhbiBhbHNvIGJlIHVzZWQgZGlyZWN0bHkgdG8gaW5zZXJ0XG5cdCAqIGJ1aWx0LWluIG9yIGN1c3RvbSBncmFwaGljcyBjb21tYW5kcy4gRm9yIGV4YW1wbGU6XG5cdCAqXG5cdCAqIFx0XHQvLyBhdHRhY2ggZGF0YSB0byBvdXIgc2hhcGUsIHNvIHdlIGNhbiBhY2Nlc3MgaXQgZHVyaW5nIHRoZSBkcmF3OlxuXHQgKiBcdFx0bXlTaGFwZS5jb2xvciA9IFwicmVkXCI7XG5cdCAqXG5cdCAqIFx0XHQvLyBhcHBlbmQgYSBDaXJjbGUgY29tbWFuZCBvYmplY3Q6XG5cdCAqIFx0XHRteVNoYXBlLmdyYXBoaWNzLmFwcGVuZChuZXcgR3JhcGhpY3MuQ2lyY2xlKDUwLCA1MCwgMzApKTtcblx0ICpcblx0ICogXHRcdC8vIGFwcGVuZCBhIGN1c3RvbSBjb21tYW5kIG9iamVjdCB3aXRoIGFuIGV4ZWMgbWV0aG9kIHRoYXQgc2V0cyB0aGUgZmlsbCBzdHlsZVxuXHQgKiBcdFx0Ly8gYmFzZWQgb24gdGhlIHNoYXBlJ3MgZGF0YSwgYW5kIHRoZW4gZmlsbHMgdGhlIGNpcmNsZS5cblx0ICogXHRcdG15U2hhcGUuZ3JhcGhpY3MuYXBwZW5kKHtleGVjOmZ1bmN0aW9uKGN0eCwgc2hhcGUpIHtcblx0ICogXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHNoYXBlLmNvbG9yO1xuXHQgKiBcdFx0XHRjdHguZmlsbCgpO1xuXHQgKiBcdFx0fX0pO1xuXHQgKlxuXHQgKiBAbWV0aG9kIGFwcGVuZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29tbWFuZCBBIGdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0IGV4cG9zaW5nIGFuIFwiZXhlY1wiIG1ldGhvZC5cblx0ICogQHBhcmFtIHtib29sZWFufSBjbGVhbiBUaGUgY2xlYW4gcGFyYW0gaXMgcHJpbWFyaWx5IGZvciBpbnRlcm5hbCB1c2UuIEEgdmFsdWUgb2YgdHJ1ZSBpbmRpY2F0ZXMgdGhhdCBhIGNvbW1hbmQgZG9lcyBub3QgZ2VuZXJhdGUgYSBwYXRoIHRoYXQgc2hvdWxkIGJlIHN0cm9rZWQgb3IgZmlsbGVkLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYXBwZW5kID0gZnVuY3Rpb24oY29tbWFuZCwgY2xlYW4pIHtcblx0XHR0aGlzLl9hY3RpdmVJbnN0cnVjdGlvbnMucHVzaChjb21tYW5kKTtcblx0XHR0aGlzLmNvbW1hbmQgPSBjb21tYW5kO1xuXHRcdGlmICghY2xlYW4pIHsgdGhpcy5fZGlydHkgPSB0cnVlOyB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlY29kZXMgYSBjb21wYWN0IGVuY29kZWQgcGF0aCBzdHJpbmcgaW50byBhIHNlcmllcyBvZiBkcmF3IGluc3RydWN0aW9ucy5cblx0ICogVGhpcyBmb3JtYXQgaXMgbm90IGludGVuZGVkIHRvIGJlIGh1bWFuIHJlYWRhYmxlLCBhbmQgaXMgbWVhbnQgZm9yIHVzZSBieSBhdXRob3JpbmcgdG9vbHMuXG5cdCAqIFRoZSBmb3JtYXQgdXNlcyBhIGJhc2U2NCBjaGFyYWN0ZXIgc2V0LCB3aXRoIGVhY2ggY2hhcmFjdGVyIHJlcHJlc2VudGluZyA2IGJpdHMsIHRvIGRlZmluZSBhIHNlcmllcyBvZiBkcmF3XG5cdCAqIGNvbW1hbmRzLlxuXHQgKlxuXHQgKiBFYWNoIGNvbW1hbmQgaXMgY29tcHJpc2VkIG9mIGEgc2luZ2xlIFwiaGVhZGVyXCIgY2hhcmFjdGVyIGZvbGxvd2VkIGJ5IGEgdmFyaWFibGUgbnVtYmVyIG9mIGFsdGVybmF0aW5nIHggYW5kIHlcblx0ICogcG9zaXRpb24gdmFsdWVzLiBSZWFkaW5nIHRoZSBoZWFkZXIgYml0cyBmcm9tIGxlZnQgdG8gcmlnaHQgKG1vc3QgdG8gbGVhc3Qgc2lnbmlmaWNhbnQpOiBiaXRzIDEgdG8gMyBzcGVjaWZ5IHRoZVxuXHQgKiB0eXBlIG9mIG9wZXJhdGlvbiAoMC1tb3ZlVG8sIDEtbGluZVRvLCAyLXF1YWRyYXRpY0N1cnZlVG8sIDMtYmV6aWVyQ3VydmVUbywgNC1jbG9zZVBhdGgsIDUtNyB1bnVzZWQpLiBCaXQgNFxuXHQgKiBpbmRpY2F0ZXMgd2hldGhlciBwb3NpdGlvbiB2YWx1ZXMgdXNlIDEyIGJpdHMgKDIgY2hhcmFjdGVycykgb3IgMTggYml0cyAoMyBjaGFyYWN0ZXJzKSwgd2l0aCBhIG9uZSBpbmRpY2F0aW5nIHRoZVxuXHQgKiBsYXR0ZXIuIEJpdHMgNSBhbmQgNiBhcmUgY3VycmVudGx5IHVudXNlZC5cblx0ICpcblx0ICogRm9sbG93aW5nIHRoZSBoZWFkZXIgaXMgYSBzZXJpZXMgb2YgMCAoY2xvc2VQYXRoKSwgMiAobW92ZVRvLCBsaW5lVG8pLCA0IChxdWFkcmF0aWNDdXJ2ZVRvKSwgb3IgNiAoYmV6aWVyQ3VydmVUbylcblx0ICogcGFyYW1ldGVycy4gVGhlc2UgcGFyYW1ldGVycyBhcmUgYWx0ZXJuYXRpbmcgeC95IHBvc2l0aW9ucyByZXByZXNlbnRlZCBieSAyIG9yIDMgY2hhcmFjdGVycyAoYXMgaW5kaWNhdGVkIGJ5IHRoZVxuXHQgKiA0dGggYml0IGluIHRoZSBjb21tYW5kIGNoYXIpLiBUaGVzZSBjaGFyYWN0ZXJzIGNvbnNpc3Qgb2YgYSAxIGJpdCBzaWduICgxIGlzIG5lZ2F0aXZlLCAwIGlzIHBvc2l0aXZlKSwgZm9sbG93ZWRcblx0ICogYnkgYW4gMTEgKDIgY2hhcikgb3IgMTcgKDMgY2hhcikgYml0IGludGVnZXIgdmFsdWUuIEFsbCBwb3NpdGlvbiB2YWx1ZXMgYXJlIGluIHRlbnRocyBvZiBhIHBpeGVsLiBFeGNlcHQgaW4gdGhlXG5cdCAqIGNhc2Ugb2YgbW92ZSBvcGVyYXRpb25zIHdoaWNoIGFyZSBhYnNvbHV0ZSwgdGhpcyB2YWx1ZSBpcyBhIGRlbHRhIGZyb20gdGhlIHByZXZpb3VzIHggb3IgeSBwb3NpdGlvbiAoYXNcblx0ICogYXBwcm9wcmlhdGUpLlxuXHQgKlxuXHQgKiBGb3IgZXhhbXBsZSwgdGhlIHN0cmluZyBcIkEzY0FBTUF1NEFBQVwiIHJlcHJlc2VudHMgYSBsaW5lIHN0YXJ0aW5nIGF0IC0xNTAsMCBhbmQgZW5kaW5nIGF0IDE1MCwwLlxuXHQgKiA8YnIgLz5BIC0gYml0cyAwMDAwMDAuIEZpcnN0IDMgYml0cyAoMDAwKSBpbmRpY2F0ZSBhIG1vdmVUbyBvcGVyYXRpb24uIDR0aCBiaXQgKDApIGluZGljYXRlcyAyIGNoYXJzIHBlclxuXHQgKiBwYXJhbWV0ZXIuXG5cdCAqIDxiciAvPm4wIC0gMTEwMTExMDExMTAwLiBBYnNvbHV0ZSB4IHBvc2l0aW9uIG9mIC0xNTAuMHB4LiBGaXJzdCBiaXQgaW5kaWNhdGVzIGEgbmVnYXRpdmUgdmFsdWUsIHJlbWFpbmluZyBiaXRzXG5cdCAqIGluZGljYXRlIDE1MDAgdGVudGhzIG9mIGEgcGl4ZWwuXG5cdCAqIDxiciAvPkFBIC0gMDAwMDAwMDAwMDAwLiBBYnNvbHV0ZSB5IHBvc2l0aW9uIG9mIDAuXG5cdCAqIDxiciAvPkkgLSAwMDExMDAuIEZpcnN0IDMgYml0cyAoMDAxKSBpbmRpY2F0ZSBhIGxpbmVUbyBvcGVyYXRpb24uIDR0aCBiaXQgKDEpIGluZGljYXRlcyAzIGNoYXJzIHBlciBwYXJhbWV0ZXIuXG5cdCAqIDxiciAvPkF1NCAtIDAwMDAwMDEwMTExMDExMTAwMC4gQW4geCBkZWx0YSBvZiAzMDAuMHB4LCB3aGljaCBpcyBhZGRlZCB0byB0aGUgcHJldmlvdXMgeCB2YWx1ZSBvZiAtMTUwLjBweCB0b1xuXHQgKiBwcm92aWRlIGFuIGFic29sdXRlIHBvc2l0aW9uIG9mICsxNTAuMHB4LlxuXHQgKiA8YnIgLz5BQUEgLSAwMDAwMDAwMDAwMDAwMDAwMDAuIEEgeSBkZWx0YSB2YWx1ZSBvZiAwLlxuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcInBcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBkZWNvZGVQYXRoXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHBhdGggc3RyaW5nIHRvIGRlY29kZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmRlY29kZVBhdGggPSBmdW5jdGlvbihzdHIpIHtcblx0XHR2YXIgaW5zdHJ1Y3Rpb25zID0gW3RoaXMubW92ZVRvLCB0aGlzLmxpbmVUbywgdGhpcy5xdWFkcmF0aWNDdXJ2ZVRvLCB0aGlzLmJlemllckN1cnZlVG8sIHRoaXMuY2xvc2VQYXRoXTtcblx0XHR2YXIgcGFyYW1Db3VudCA9IFsyLCAyLCA0LCA2LCAwXTtcblx0XHR2YXIgaT0wLCBsPXN0ci5sZW5ndGg7XG5cdFx0dmFyIHBhcmFtcyA9IFtdO1xuXHRcdHZhciB4PTAsIHk9MDtcblx0XHR2YXIgYmFzZTY0ID0gR3JhcGhpY3MuQkFTRV82NDtcblxuXHRcdHdoaWxlIChpPGwpIHtcblx0XHRcdHZhciBjID0gc3RyLmNoYXJBdChpKTtcblx0XHRcdHZhciBuID0gYmFzZTY0W2NdO1xuXHRcdFx0dmFyIGZpID0gbj4+MzsgLy8gaGlnaGVzdCBvcmRlciBiaXRzIDEtMyBjb2RlIGZvciBvcGVyYXRpb24uXG5cdFx0XHR2YXIgZiA9IGluc3RydWN0aW9uc1tmaV07XG5cdFx0XHQvLyBjaGVjayB0aGF0IHdlIGhhdmUgYSB2YWxpZCBpbnN0cnVjdGlvbiAmIHRoYXQgdGhlIHVudXNlZCBiaXRzIGFyZSBlbXB0eTpcblx0XHRcdGlmICghZiB8fCAobiYzKSkgeyB0aHJvdyhcImJhZCBwYXRoIGRhdGEgKEBcIitpK1wiKTogXCIrYyk7IH1cblx0XHRcdHZhciBwbCA9IHBhcmFtQ291bnRbZmldO1xuXHRcdFx0aWYgKCFmaSkgeyB4PXk9MDsgfSAvLyBtb3ZlIG9wZXJhdGlvbnMgcmVzZXQgdGhlIHBvc2l0aW9uLlxuXHRcdFx0cGFyYW1zLmxlbmd0aCA9IDA7XG5cdFx0XHRpKys7XG5cdFx0XHR2YXIgY2hhckNvdW50ID0gKG4+PjImMSkrMjsgIC8vIDR0aCBoZWFkZXIgYml0IGluZGljYXRlcyBudW1iZXIgc2l6ZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdFx0XHRmb3IgKHZhciBwPTA7IHA8cGw7IHArKykge1xuXHRcdFx0XHR2YXIgbnVtID0gYmFzZTY0W3N0ci5jaGFyQXQoaSldO1xuXHRcdFx0XHR2YXIgc2lnbiA9IChudW0+PjUpID8gLTEgOiAxO1xuXHRcdFx0XHRudW0gPSAoKG51bSYzMSk8PDYpfChiYXNlNjRbc3RyLmNoYXJBdChpKzEpXSk7XG5cdFx0XHRcdGlmIChjaGFyQ291bnQgPT0gMykgeyBudW0gPSAobnVtPDw2KXwoYmFzZTY0W3N0ci5jaGFyQXQoaSsyKV0pOyB9XG5cdFx0XHRcdG51bSA9IHNpZ24qbnVtLzEwO1xuXHRcdFx0XHRpZiAocCUyKSB7IHggPSAobnVtICs9IHgpOyB9XG5cdFx0XHRcdGVsc2UgeyB5ID0gKG51bSArPSB5KTsgfVxuXHRcdFx0XHRwYXJhbXNbcF0gPSBudW07XG5cdFx0XHRcdGkgKz0gY2hhckNvdW50O1xuXHRcdFx0fVxuXHRcdFx0Zi5hcHBseSh0aGlzLHBhcmFtcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9yZXMgYWxsIGdyYXBoaWNzIGNvbW1hbmRzIHNvIHRoZXkgd29uJ3QgYmUgZXhlY3V0ZWQgaW4gZnV0dXJlIGRyYXdzLiBDYWxsaW5nIHN0b3JlKCkgYSBzZWNvbmQgdGltZSBhZGRzIHRvXG5cdCAqIHRoZSBleGlzdGluZyBzdG9yZS4gVGhpcyBhbHNvIGFmZmVjdHMgYGRyYXdBc1BhdGgoKWAuXG5cdCAqXG5cdCAqIFRoaXMgaXMgdXNlZnVsIGluIGNhc2VzIHdoZXJlIHlvdSBhcmUgY3JlYXRpbmcgdmVjdG9yIGdyYXBoaWNzIGluIGFuIGl0ZXJhdGl2ZSBtYW5uZXIgKGV4LiBnZW5lcmF0aXZlIGFydCksIHNvXG5cdCAqIHRoYXQgb25seSBuZXcgZ3JhcGhpY3MgbmVlZCB0byBiZSBkcmF3biAod2hpY2ggY2FuIHByb3ZpZGUgaHVnZSBwZXJmb3JtYW5jZSBiZW5lZml0cyksIGJ1dCB5b3Ugd2lzaCB0byByZXRhaW4gYWxsXG5cdCAqIG9mIHRoZSB2ZWN0b3IgaW5zdHJ1Y3Rpb25zIGZvciBsYXRlciB1c2UgKGV4LiBzY2FsaW5nLCBtb2RpZnlpbmcsIG9yIGV4cG9ydGluZykuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBjYWxsaW5nIHN0b3JlKCkgd2lsbCBmb3JjZSB0aGUgYWN0aXZlIHBhdGggKGlmIGFueSkgdG8gYmUgZW5kZWQgaW4gYSBtYW5uZXIgc2ltaWxhciB0byBjaGFuZ2luZ1xuXHQgKiB0aGUgZmlsbCBvciBzdHJva2UuXG5cdCAqXG5cdCAqIEZvciBleGFtcGxlLCBjb25zaWRlciBhIGFwcGxpY2F0aW9uIHdoZXJlIHRoZSB1c2VyIGRyYXdzIGxpbmVzIHdpdGggdGhlIG1vdXNlLiBBcyBlYWNoIGxpbmUgc2VnbWVudCAob3IgY29sbGVjdGlvbiBvZlxuXHQgKiBzZWdtZW50cykgYXJlIGFkZGVkIHRvIGEgU2hhcGUsIGl0IGNhbiBiZSByYXN0ZXJpemVkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvdXBkYXRlQ2FjaGVcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIGFuZCB0aGVuIHN0b3JlZCwgc28gdGhhdCBpdCBjYW4gYmUgcmVkcmF3biBhdCBhIGRpZmZlcmVudCBzY2FsZSB3aGVuIHRoZSBhcHBsaWNhdGlvbiBpcyByZXNpemVkLCBvciBleHBvcnRlZCB0byBTVkcuXG5cdCAqXG5cdCAqIFx0Ly8gc2V0IHVwIGNhY2hlOlxuXHQgKiBcdG15U2hhcGUuY2FjaGUoMCwwLDUwMCw1MDAsc2NhbGUpO1xuXHQgKlxuXHQgKiBcdC8vIHdoZW4gdGhlIHVzZXIgZHJhZ3MsIGRyYXcgYSBuZXcgbGluZTpcblx0ICogXHRteVNoYXBlLmdyYXBoaWNzLm1vdmVUbyhvbGRYLG9sZFkpLmxpbmVUbyhuZXdYLG5ld1kpO1xuXHQgKiBcdC8vIHRoZW4gZHJhdyBpdCBpbnRvIHRoZSBleGlzdGluZyBjYWNoZTpcblx0ICogXHRteVNoYXBlLnVwZGF0ZUNhY2hlKFwic291cmNlLW92ZXJcIik7XG5cdCAqIFx0Ly8gc3RvcmUgdGhlIG5ldyBsaW5lLCBzbyBpdCBpc24ndCByZWRyYXduIG5leHQgdGltZTpcblx0ICogXHRteVNoYXBlLnN0b3JlKCk7XG5cdCAqXG5cdCAqIFx0Ly8gdGhlbiwgd2hlbiB0aGUgd2luZG93IHJlc2l6ZXMsIHdlIGNhbiByZS1yZW5kZXIgYXQgYSBkaWZmZXJlbnQgc2NhbGU6XG5cdCAqIFx0Ly8gZmlyc3QsIHVuc3RvcmUgYWxsIG91ciBsaW5lczpcblx0ICogXHRteVNoYXBlLnVuc3RvcmUoKTtcblx0ICogXHQvLyB0aGVuIGNhY2hlIHVzaW5nIHRoZSBuZXcgc2NhbGU6XG5cdCAqIFx0bXlTaGFwZS5jYWNoZSgwLDAsNTAwLDUwMCxuZXdTY2FsZSk7XG5cdCAqIFx0Ly8gZmluYWxseSwgc3RvcmUgdGhlIGV4aXN0aW5nIGNvbW1hbmRzIGFnYWluOlxuXHQgKiBcdG15U2hhcGUuc3RvcmUoKTtcblx0ICpcblx0ICogQG1ldGhvZCBzdG9yZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuc3RvcmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnModHJ1ZSk7XG5cdFx0dGhpcy5fc3RvcmVJbmRleCA9IHRoaXMuX2luc3RydWN0aW9ucy5sZW5ndGg7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVuc3RvcmVzIGFueSBncmFwaGljcyBjb21tYW5kcyB0aGF0IHdlcmUgcHJldmlvdXNseSBzdG9yZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3Mvc3RvcmVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogc28gdGhhdCB0aGV5IHdpbGwgYmUgZXhlY3V0ZWQgaW4gc3Vic2VxdWVudCBkcmF3IGNhbGxzLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHVuc3RvcmVcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLnVuc3RvcmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9zdG9yZUluZGV4ID0gMDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgR3JhcGhpY3MgaW5zdGFuY2UuIE5vdGUgdGhhdCB0aGUgaW5kaXZpZHVhbCBjb21tYW5kIG9iamVjdHMgYXJlIG5vdCBjbG9uZWQuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IEEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3MgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvID0gbmV3IEdyYXBoaWNzKCk7XG5cdFx0by5jb21tYW5kID0gdGhpcy5jb21tYW5kO1xuXHRcdG8uX3N0cm9rZSA9IHRoaXMuX3N0cm9rZTtcblx0XHRvLl9zdHJva2VTdHlsZSA9IHRoaXMuX3N0cm9rZVN0eWxlO1xuXHRcdG8uX3N0cm9rZURhc2ggPSB0aGlzLl9zdHJva2VEYXNoO1xuXHRcdG8uX3N0cm9rZUlnbm9yZVNjYWxlID0gdGhpcy5fc3Ryb2tlSWdub3JlU2NhbGU7XG5cdFx0by5fZmlsbCA9IHRoaXMuX2ZpbGw7XG5cdFx0by5faW5zdHJ1Y3Rpb25zID0gdGhpcy5faW5zdHJ1Y3Rpb25zLnNsaWNlKCk7XG5cdFx0by5fY29tbWl0SW5kZXggPSB0aGlzLl9jb21taXRJbmRleDtcblx0XHRvLl9hY3RpdmVJbnN0cnVjdGlvbnMgPSB0aGlzLl9hY3RpdmVJbnN0cnVjdGlvbnMuc2xpY2UoKTtcblx0XHRvLl9kaXJ0eSA9IHRoaXMuX2RpcnR5O1xuXHRcdG8uX3N0b3JlSW5kZXggPSB0aGlzLl9zdG9yZUluZGV4O1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbR3JhcGhpY3NdXCI7XG5cdH07XG5cblxuLy8gdGlueSBBUEk6XG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBtb3ZlVG8uXG5cdCAqIEBtZXRob2QgbXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggY29vcmRpbmF0ZSB0aGUgZHJhd2luZyBwb2ludCBzaG91bGQgbW92ZSB0by5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZSB0aGUgZHJhd2luZyBwb2ludCBzaG91bGQgbW92ZSB0by5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscykuXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAubXQgPSBwLm1vdmVUbztcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gbGluZVRvLlxuXHQgKiBAbWV0aG9kIGx0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgdGhlIGRyYXdpbmcgcG9pbnQgc2hvdWxkIGRyYXcgdG8uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgdGhlIGRyYXdpbmcgcG9pbnQgc2hvdWxkIGRyYXcgdG8uXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmx0ID0gcC5saW5lVG87XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGFyY1RvLlxuXHQgKiBAbWV0aG9kIGF0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geTFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmF0ID0gcC5hcmNUbztcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYmV6aWVyQ3VydmVUby5cblx0ICogQG1ldGhvZCBidFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AxeFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AxeVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AyeFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AyeVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5idCA9IHAuYmV6aWVyQ3VydmVUbztcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gcXVhZHJhdGljQ3VydmVUbyAvIGN1cnZlVG8uXG5cdCAqIEBtZXRob2QgcXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNweFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3B5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAucXQgPSBwLnF1YWRyYXRpY0N1cnZlVG87XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGFyYy5cblx0ICogQG1ldGhvZCBhXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0QW5nbGUgTWVhc3VyZWQgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGVuZEFuZ2xlIE1lYXN1cmVkIGluIHJhZGlhbnMuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYW50aWNsb2Nrd2lzZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hID0gcC5hcmM7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIHJlY3QuXG5cdCAqIEBtZXRob2QgclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdyBXaWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoIEhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnIgPSBwLnJlY3Q7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGNsb3NlUGF0aC5cblx0ICogQG1ldGhvZCBjcFxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5jcCA9IHAuY2xvc2VQYXRoO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBjbGVhci5cblx0ICogQG1ldGhvZCBjXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmMgPSBwLmNsZWFyO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpbkZpbGwuXG5cdCAqIEBtZXRob2QgZlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQSBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZSAoZXguIFwicmVkXCIsIFwiI0ZGMDAwMFwiLCBvciBcInJnYmEoMjU1LDAsMCwwLjUpXCIpLiBTZXR0aW5nIHRvXG5cdCAqIG51bGwgd2lsbCByZXN1bHQgaW4gbm8gZmlsbC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuZiA9IHAuYmVnaW5GaWxsO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpbkxpbmVhckdyYWRpZW50RmlsbC5cblx0ICogQG1ldGhvZCBsZlxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnMgQW4gYXJyYXkgb2YgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWVzLiBGb3IgZXhhbXBsZSwgW1wiI0YwMFwiLFwiIzAwRlwiXSB3b3VsZCBkZWZpbmUgYSBncmFkaWVudFxuXHQgKiBkcmF3aW5nIGZyb20gcmVkIHRvIGJsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvcyBBbiBhcnJheSBvZiBncmFkaWVudCBwb3NpdGlvbnMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgY29sb3JzLiBGb3IgZXhhbXBsZSwgWzAuMSwgMC45XSB3b3VsZCBkcmF3XG5cdCAqIHRoZSBmaXJzdCBjb2xvciB0byAxMCUgdGhlbiBpbnRlcnBvbGF0aW5nIHRvIHRoZSBzZWNvbmQgY29sb3IgYXQgOTAlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDAgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwIFRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MSBUaGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5sZiA9IHAuYmVnaW5MaW5lYXJHcmFkaWVudEZpbGw7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luUmFkaWFsR3JhZGllbnRGaWxsLlxuXHQgKiBAbWV0aG9kIHJmXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBBbiBhcnJheSBvZiBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZXMuIEZvciBleGFtcGxlLCBbXCIjRjAwXCIsXCIjMDBGXCJdIHdvdWxkIGRlZmluZVxuXHQgKiBhIGdyYWRpZW50IGRyYXdpbmcgZnJvbSByZWQgdG8gYmx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zIEFuIGFycmF5IG9mIGdyYWRpZW50IHBvc2l0aW9ucyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjb2xvcnMuIEZvciBleGFtcGxlLCBbMC4xLFxuXHQgKiAwLjldIHdvdWxkIGRyYXcgdGhlIGZpcnN0IGNvbG9yIHRvIDEwJSB0aGVuIGludGVycG9sYXRpbmcgdG8gdGhlIHNlY29uZCBjb2xvciBhdCA5MCUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTAgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIwIFJhZGl1cyBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTEgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIxIFJhZGl1cyBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnJmID0gcC5iZWdpblJhZGlhbEdyYWRpZW50RmlsbDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYmVnaW5CaXRtYXBGaWxsLlxuXHQgKiBAbWV0aG9kIGJmXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgVGhlIEltYWdlLCBDYW52YXMsIG9yIFZpZGVvIG9iamVjdCB0byB1c2Vcblx0ICogYXMgdGhlIHBhdHRlcm4uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSByZXBldGl0aW9uIE9wdGlvbmFsLiBJbmRpY2F0ZXMgd2hldGhlciB0byByZXBlYXQgdGhlIGltYWdlIGluIHRoZSBmaWxsIGFyZWEuIE9uZSBvZiBcInJlcGVhdFwiLFxuXHQgKiBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gRGVmYXVsdHMgdG8gXCJyZXBlYXRcIi4gTm90ZSB0aGF0IEZpcmVmb3ggZG9lcyBub3Qgc3VwcG9ydCBcInJlcGVhdC14XCIgb3Jcblx0ICogXCJyZXBlYXQteVwiIChsYXRlc3QgdGVzdHMgd2VyZSBpbiBGRiAyMC4wKSwgYW5kIHdpbGwgZGVmYXVsdCB0byBcInJlcGVhdFwiLlxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXggT3B0aW9uYWwuIFNwZWNpZmllcyBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBmb3IgdGhlIGJpdG1hcCBmaWxsLiBUaGlzIHRyYW5zZm9ybWF0aW9uXG5cdCAqIHdpbGwgYmUgYXBwbGllZCByZWxhdGl2ZSB0byB0aGUgcGFyZW50IHRyYW5zZm9ybS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuYmYgPSBwLmJlZ2luQml0bWFwRmlsbDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gZW5kRmlsbC5cblx0ICogQG1ldGhvZCBlZlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5lZiA9IHAuZW5kRmlsbDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gc2V0U3Ryb2tlU3R5bGUuXG5cdCAqIEBtZXRob2Qgc3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRoaWNrbmVzcyBUaGUgd2lkdGggb2YgdGhlIHN0cm9rZS5cblx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IFtjYXBzPTBdIEluZGljYXRlcyB0aGUgdHlwZSBvZiBjYXBzIHRvIHVzZSBhdCB0aGUgZW5kIG9mIGxpbmVzLiBPbmUgb2YgYnV0dCxcblx0ICogcm91bmQsIG9yIHNxdWFyZS4gRGVmYXVsdHMgdG8gXCJidXR0XCIuIEFsc28gYWNjZXB0cyB0aGUgdmFsdWVzIDAgKGJ1dHQpLCAxIChyb3VuZCksIGFuZCAyIChzcXVhcmUpIGZvciB1c2Ugd2l0aFxuXHQgKiB0aGUgdGlueSBBUEkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBbam9pbnRzPTBdIFNwZWNpZmllcyB0aGUgdHlwZSBvZiBqb2ludHMgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVyZSB0d28gbGluZXMgbWVldC5cblx0ICogT25lIG9mIGJldmVsLCByb3VuZCwgb3IgbWl0ZXIuIERlZmF1bHRzIHRvIFwibWl0ZXJcIi4gQWxzbyBhY2NlcHRzIHRoZSB2YWx1ZXMgMCAobWl0ZXIpLCAxIChyb3VuZCksIGFuZCAyIChiZXZlbClcblx0ICogZm9yIHVzZSB3aXRoIHRoZSB0aW55IEFQSS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttaXRlckxpbWl0PTEwXSBJZiBqb2ludHMgaXMgc2V0IHRvIFwibWl0ZXJcIiwgdGhlbiB5b3UgY2FuIHNwZWNpZnkgYSBtaXRlciBsaW1pdCByYXRpbyB3aGljaFxuXHQgKiBjb250cm9scyBhdCB3aGF0IHBvaW50IGEgbWl0ZXJlZCBqb2ludCB3aWxsIGJlIGNsaXBwZWQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZVNjYWxlPWZhbHNlXSBJZiB0cnVlLCB0aGUgc3Ryb2tlIHdpbGwgYmUgZHJhd24gYXQgdGhlIHNwZWNpZmllZCB0aGlja25lc3MgcmVnYXJkbGVzc1xuXHQgKiBvZiBhY3RpdmUgdHJhbnNmb3JtYXRpb25zLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5zcyA9IHAuc2V0U3Ryb2tlU3R5bGU7XG5cdFxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gc2V0U3Ryb2tlRGFzaC5cblx0ICogQG1ldGhvZCBzZFxuXHQgKiBAcGFyYW0ge0FycmF5fSBbc2VnbWVudHNdIEFuIGFycmF5IHNwZWNpZnlpbmcgdGhlIGRhc2ggcGF0dGVybiwgYWx0ZXJuYXRpbmcgYmV0d2VlbiBsaW5lIGFuZCBnYXAuXG5cdCAqIEZvciBleGFtcGxlLCBbMjAsMTBdIHdvdWxkIGNyZWF0ZSBhIHBhdHRlcm4gb2YgMjAgcGl4ZWwgbGluZXMgd2l0aCAxMCBwaXhlbCBnYXBzIGJldHdlZW4gdGhlbS5cblx0ICogUGFzc2luZyBudWxsIG9yIGFuIGVtcHR5IGFycmF5IHdpbGwgY2xlYXIgYW55IGV4aXN0aW5nIGRhc2guXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0PTBdIFRoZSBvZmZzZXQgb2YgdGhlIGRhc2ggcGF0dGVybi4gRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCBpbmNyZW1lbnQgdGhpcyB2YWx1ZSB0byBjcmVhdGUgYSBcIm1hcmNoaW5nIGFudHNcIiBlZmZlY3QuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnNkID0gcC5zZXRTdHJva2VEYXNoO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpblN0cm9rZS5cblx0ICogQG1ldGhvZCBzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBBIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlIChleC4gXCIjRkYwMDAwXCIsIFwicmVkXCIsIG9yIFwicmdiYSgyNTUsMCwwLDAuNSlcIikuIFNldHRpbmcgdG9cblx0ICogbnVsbCB3aWxsIHJlc3VsdCBpbiBubyBzdHJva2UuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnMgPSBwLmJlZ2luU3Ryb2tlO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpbkxpbmVhckdyYWRpZW50U3Ryb2tlLlxuXHQgKiBAbWV0aG9kIGxzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBBbiBhcnJheSBvZiBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZXMuIEZvciBleGFtcGxlLCBbXCIjRjAwXCIsXCIjMDBGXCJdIHdvdWxkIGRlZmluZVxuXHQgKiBhIGdyYWRpZW50IGRyYXdpbmcgZnJvbSByZWQgdG8gYmx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zIEFuIGFycmF5IG9mIGdyYWRpZW50IHBvc2l0aW9ucyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjb2xvcnMuIEZvciBleGFtcGxlLCBbMC4xLFxuXHQgKiAwLjldIHdvdWxkIGRyYXcgdGhlIGZpcnN0IGNvbG9yIHRvIDEwJSB0aGVuIGludGVycG9sYXRpbmcgdG8gdGhlIHNlY29uZCBjb2xvciBhdCA5MCUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTAgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTEgVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmxzID0gcC5iZWdpbkxpbmVhckdyYWRpZW50U3Ryb2tlO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpblJhZGlhbEdyYWRpZW50U3Ryb2tlLlxuXHQgKiBAbWV0aG9kIHJzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBBbiBhcnJheSBvZiBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZXMuIEZvciBleGFtcGxlLCBbXCIjRjAwXCIsXCIjMDBGXCJdIHdvdWxkIGRlZmluZVxuXHQgKiBhIGdyYWRpZW50IGRyYXdpbmcgZnJvbSByZWQgdG8gYmx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zIEFuIGFycmF5IG9mIGdyYWRpZW50IHBvc2l0aW9ucyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjb2xvcnMuIEZvciBleGFtcGxlLCBbMC4xLFxuXHQgKiAwLjldIHdvdWxkIGRyYXcgdGhlIGZpcnN0IGNvbG9yIHRvIDEwJSB0aGVuIGludGVycG9sYXRpbmcgdG8gdGhlIHNlY29uZCBjb2xvciBhdCA5MCUsIHRoZW4gZHJhdyB0aGUgc2Vjb25kIGNvbG9yXG5cdCAqIHRvIDEwMCUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTAgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIwIFJhZGl1cyBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTEgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIxIFJhZGl1cyBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnJzID0gcC5iZWdpblJhZGlhbEdyYWRpZW50U3Ryb2tlO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpbkJpdG1hcFN0cm9rZS5cblx0ICogQG1ldGhvZCBic1xuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnR9IGltYWdlIFRoZSBJbWFnZSwgQ2FudmFzLCBvciBWaWRlbyBvYmplY3QgdG8gdXNlXG5cdCAqIGFzIHRoZSBwYXR0ZXJuLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3JlcGV0aXRpb249cmVwZWF0XSBPcHRpb25hbC4gSW5kaWNhdGVzIHdoZXRoZXIgdG8gcmVwZWF0IHRoZSBpbWFnZSBpbiB0aGUgZmlsbCBhcmVhLiBPbmUgb2Zcblx0ICogXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuIERlZmF1bHRzIHRvIFwicmVwZWF0XCIuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmJzID0gcC5iZWdpbkJpdG1hcFN0cm9rZTtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gZW5kU3Ryb2tlLlxuXHQgKiBAbWV0aG9kIGVzXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmVzID0gcC5lbmRTdHJva2U7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGRyYXdSZWN0LlxuXHQgKiBAbWV0aG9kIGRyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFdpZHRoIG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGggSGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuZHIgPSBwLmRyYXdSZWN0O1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBkcmF3Um91bmRSZWN0LlxuXHQgKiBAbWV0aG9kIHJyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgQ29ybmVyIHJhZGl1cy5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAucnIgPSBwLmRyYXdSb3VuZFJlY3Q7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGRyYXdSb3VuZFJlY3RDb21wbGV4LlxuXHQgKiBAbWV0aG9kIHJjXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUgdG8gZHJhdyB0aGUgcm91bmQgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUgdG8gZHJhdyB0aGUgcm91bmQgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHcgVGhlIHdpZHRoIG9mIHRoZSByb3VuZCByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaCBUaGUgaGVpZ2h0IG9mIHRoZSByb3VuZCByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzVEwgVG9wIGxlZnQgY29ybmVyIHJhZGl1cy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1RSIFRvcCByaWdodCBjb3JuZXIgcmFkaXVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzQlIgQm90dG9tIHJpZ2h0IGNvcm5lciByYWRpdXMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCTCBCb3R0b20gbGVmdCBjb3JuZXIgcmFkaXVzLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5yYyA9IHAuZHJhd1JvdW5kUmVjdENvbXBsZXg7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGRyYXdDaXJjbGUuXG5cdCAqIEBtZXRob2QgZGNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggeCBjb29yZGluYXRlIGNlbnRlciBwb2ludCBvZiBjaXJjbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IHkgY29vcmRpbmF0ZSBjZW50ZXIgcG9pbnQgb2YgY2lyY2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiBjaXJjbGUuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmRjID0gcC5kcmF3Q2lyY2xlO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBkcmF3RWxsaXBzZS5cblx0ICogQG1ldGhvZCBkZVxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgbGVmdCBjb29yZGluYXRlIHBvaW50IG9mIHRoZSBlbGxpcHNlLiBOb3RlIHRoYXQgdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Q2lyY2xlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdoaWNoIGRyYXdzIGZyb20gY2VudGVyLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgdG9wIGNvb3JkaW5hdGUgcG9pbnQgb2YgdGhlIGVsbGlwc2UuIE5vdGUgdGhhdCB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdDaXJjbGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2hpY2ggZHJhd3MgZnJvbSB0aGUgY2VudGVyLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdyBUaGUgaGVpZ2h0IChob3Jpem9udGFsIGRpYW1ldGVyKSBvZiB0aGUgZWxsaXBzZS4gVGhlIGhvcml6b250YWwgcmFkaXVzIHdpbGwgYmUgaGFsZiBvZiB0aGlzXG5cdCAqIG51bWJlci5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGggVGhlIHdpZHRoICh2ZXJ0aWNhbCBkaWFtZXRlcikgb2YgdGhlIGVsbGlwc2UuIFRoZSB2ZXJ0aWNhbCByYWRpdXMgd2lsbCBiZSBoYWxmIG9mIHRoaXMgbnVtYmVyLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5kZSA9IHAuZHJhd0VsbGlwc2U7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGRyYXdQb2x5U3Rhci5cblx0ICogQG1ldGhvZCBkcFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBQb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoZSBzaGFwZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgUG9zaXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGUgc2hhcGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgc2hhcGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzaWRlcyBUaGUgbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgc3RhciBvciBzaWRlcyBvbiB0aGUgcG9seWdvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50U2l6ZSBUaGUgZGVwdGggb3IgXCJwb2ludHktbmVzc1wiIG9mIHRoZSBzdGFyIHBvaW50cy4gQSBwb2ludFNpemUgb2YgMCB3aWxsIGRyYXcgYSByZWd1bGFyXG5cdCAqIHBvbHlnb24gKG5vIHBvaW50cyksIGEgcG9pbnRTaXplIG9mIDEgd2lsbCBkcmF3IG5vdGhpbmcgYmVjYXVzZSB0aGUgcG9pbnRzIGFyZSBpbmZpbml0ZWx5IHBvaW50eS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIFRoZSBhbmdsZSBvZiB0aGUgZmlyc3QgcG9pbnQgLyBjb3JuZXIuIEZvciBleGFtcGxlIGEgdmFsdWUgb2YgMCB3aWxsIGRyYXcgdGhlIGZpcnN0IHBvaW50XG5cdCAqIGRpcmVjdGx5IHRvIHRoZSByaWdodCBvZiB0aGUgY2VudGVyLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5kcCA9IHAuZHJhd1BvbHlTdGFyO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBkZWNvZGVQYXRoLlxuXHQgKiBAbWV0aG9kIHBcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgcGF0aCBzdHJpbmcgdG8gZGVjb2RlLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5wID0gcC5kZWNvZGVQYXRoO1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX3VwZGF0ZUluc3RydWN0aW9uc1xuXHQgKiBAcGFyYW0gY29tbWl0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl91cGRhdGVJbnN0cnVjdGlvbnMgPSBmdW5jdGlvbihjb21taXQpIHtcblx0XHR2YXIgaW5zdHIgPSB0aGlzLl9pbnN0cnVjdGlvbnMsIGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZUluc3RydWN0aW9ucywgY29tbWl0SW5kZXggPSB0aGlzLl9jb21taXRJbmRleDtcblxuXHRcdGlmICh0aGlzLl9kaXJ0eSAmJiBhY3RpdmUubGVuZ3RoKSB7XG5cdFx0XHRpbnN0ci5sZW5ndGggPSBjb21taXRJbmRleDsgLy8gcmVtb3ZlIG9sZCwgdW5jb21taXR0ZWQgY29tbWFuZHNcblx0XHRcdGluc3RyLnB1c2goR3JhcGhpY3MuYmVnaW5DbWQpO1xuXG5cdFx0XHR2YXIgbCA9IGFjdGl2ZS5sZW5ndGgsIGxsID0gaW5zdHIubGVuZ3RoO1xuXHRcdFx0aW5zdHIubGVuZ3RoID0gbGwrbDtcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKyspIHsgaW5zdHJbaStsbF0gPSBhY3RpdmVbaV07IH1cblxuXHRcdFx0aWYgKHRoaXMuX2ZpbGwpIHsgaW5zdHIucHVzaCh0aGlzLl9maWxsKTsgfVxuXHRcdFx0aWYgKHRoaXMuX3N0cm9rZSkge1xuXHRcdFx0XHQvLyBkb2Vzbid0IG5lZWQgdG8gYmUgcmUtYXBwbGllZCBpZiBpdCBoYXNuJ3QgY2hhbmdlZC5cblx0XHRcdFx0aWYgKHRoaXMuX3N0cm9rZURhc2ggIT09IHRoaXMuX29sZFN0cm9rZURhc2gpIHtcblx0XHRcdFx0XHR0aGlzLl9vbGRTdHJva2VEYXNoID0gdGhpcy5fc3Ryb2tlRGFzaDtcblx0XHRcdFx0XHRpbnN0ci5wdXNoKHRoaXMuX3N0cm9rZURhc2gpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl9zdHJva2VTdHlsZSAhPT0gdGhpcy5fb2xkU3Ryb2tlU3R5bGUpIHtcblx0XHRcdFx0XHR0aGlzLl9vbGRTdHJva2VTdHlsZSA9IHRoaXMuX3N0cm9rZVN0eWxlO1xuXHRcdFx0XHRcdGluc3RyLnB1c2godGhpcy5fc3Ryb2tlU3R5bGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluc3RyLnB1c2godGhpcy5fc3Ryb2tlKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoY29tbWl0KSB7XG5cdFx0XHRhY3RpdmUubGVuZ3RoID0gMDtcblx0XHRcdHRoaXMuX2NvbW1pdEluZGV4ID0gaW5zdHIubGVuZ3RoO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfc2V0RmlsbFxuXHQgKiBAcGFyYW0gZmlsbFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fc2V0RmlsbCA9IGZ1bmN0aW9uKGZpbGwpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnModHJ1ZSk7XG5cdFx0dGhpcy5jb21tYW5kID0gdGhpcy5fZmlsbCA9IGZpbGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3NldFN0cm9rZVxuXHQgKiBAcGFyYW0gc3Ryb2tlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9zZXRTdHJva2UgPSBmdW5jdGlvbihzdHJva2UpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnModHJ1ZSk7XG5cdFx0aWYgKHRoaXMuY29tbWFuZCA9IHRoaXMuX3N0cm9rZSA9IHN0cm9rZSkge1xuXHRcdFx0c3Ryb2tlLmlnbm9yZVNjYWxlID0gdGhpcy5fc3Ryb2tlSWdub3JlU2NhbGU7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG4vLyBDb21tYW5kIE9iamVjdHM6XG5cdC8qKlxuXHQgKiBAbmFtZXNwYWNlIEdyYXBoaWNzXG5cdCAqL1xuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9saW5lVG9cIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBMaW5lVG9cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqL1xuXHQoRy5MaW5lVG8gPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LmxpbmVUbyh0aGlzLngsdGhpcy55KTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9tb3ZlVG9cIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIE1vdmVUb1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdChHLk1vdmVUbyA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHgubW92ZVRvKHRoaXMueCwgdGhpcy55KTsgfTtcblxuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FyY1RvXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBBcmNUb1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geDJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHgxXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5MVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeDJcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHkyXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSByYWRpdXNcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdChHLkFyY1RvID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuXHRcdHRoaXMueDEgPSB4MTsgdGhpcy55MSA9IHkxO1xuXHRcdHRoaXMueDIgPSB4MjsgdGhpcy55MiA9IHkyO1xuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHguYXJjVG8odGhpcy54MSwgdGhpcy55MSwgdGhpcy54MiwgdGhpcy55MiwgdGhpcy5yYWRpdXMpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FyY1wifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgQXJjXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEFuZ2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBlbmRBbmdsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW50aWNsb2Nrd2lzZVxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcmFkaXVzXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBzdGFydEFuZ2xlXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBlbmRBbmdsZVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgYW50aWNsb2Nrd2lzZVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKi9cblx0KEcuQXJjID0gZnVuY3Rpb24oeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdFx0dGhpcy5zdGFydEFuZ2xlID0gc3RhcnRBbmdsZTsgdGhpcy5lbmRBbmdsZSA9IGVuZEFuZ2xlO1xuXHRcdHRoaXMuYW50aWNsb2Nrd2lzZSA9ICEhYW50aWNsb2Nrd2lzZTtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LmFyYyh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMsIHRoaXMuc3RhcnRBbmdsZSwgdGhpcy5lbmRBbmdsZSwgdGhpcy5hbnRpY2xvY2t3aXNlKTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9xdWFkcmF0aWNDdXJ2ZVRvXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBRdWFkcmF0aWNDdXJ2ZVRvXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3B4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGNweFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgY3B5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqL1xuXHQoRy5RdWFkcmF0aWNDdXJ2ZVRvID0gZnVuY3Rpb24oY3B4LCBjcHksIHgsIHkpIHtcblx0XHR0aGlzLmNweCA9IGNweDsgdGhpcy5jcHkgPSBjcHk7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LnF1YWRyYXRpY0N1cnZlVG8odGhpcy5jcHgsIHRoaXMuY3B5LCB0aGlzLngsIHRoaXMueSk7IH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmV6aWVyQ3VydmVUb1wifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgQmV6aWVyQ3VydmVUb1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMXhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMXlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMnhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMnlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGNwMXhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGNwMXlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGNwMnhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGNwMnlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdChHLkJlemllckN1cnZlVG8gPSBmdW5jdGlvbihjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSB7XG5cdFx0dGhpcy5jcDF4ID0gY3AxeDsgdGhpcy5jcDF5ID0gY3AxeTtcblx0XHR0aGlzLmNwMnggPSBjcDJ4OyB0aGlzLmNwMnkgPSBjcDJ5O1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7IGN0eC5iZXppZXJDdXJ2ZVRvKHRoaXMuY3AxeCwgdGhpcy5jcDF5LCB0aGlzLmNwMngsIHRoaXMuY3AyeSwgdGhpcy54LCB0aGlzLnkpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3JlY3RcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIFJlY3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB3XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBoXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqL1xuXHQoRy5SZWN0ID0gZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdFx0dGhpcy53ID0gdzsgdGhpcy5oID0gaDtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LnJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMudywgdGhpcy5oKTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9jbG9zZVBhdGhcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIENsb3NlUGF0aFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdChHLkNsb3NlUGF0aCA9IGZ1bmN0aW9uKCkge1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHguY2xvc2VQYXRoKCk7IH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0IHRvIGJlZ2luIGEgbmV3IHBhdGguIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljc1wifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgQmVnaW5QYXRoXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKi9cblx0KEcuQmVnaW5QYXRoID0gZnVuY3Rpb24oKSB7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7IGN0eC5iZWdpblBhdGgoKTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkZpbGxcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIEZpbGxcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSBBIHZhbGlkIENvbnRleHQyRCBmaWxsU3R5bGUuXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeFxuXHQgKiovXG5cdC8qKlxuXHQgKiBBIHZhbGlkIENvbnRleHQyRCBmaWxsU3R5bGUuXG5cdCAqIEBwcm9wZXJ0eSBzdHlsZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgbWF0cml4XG5cdCAqIEB0eXBlIE1hdHJpeDJEXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdHAgPSAoRy5GaWxsID0gZnVuY3Rpb24oc3R5bGUsIG1hdHJpeCkge1xuXHRcdHRoaXMuc3R5bGUgPSBzdHlsZTtcblx0XHR0aGlzLm1hdHJpeCA9IG1hdHJpeDtcblx0fSkucHJvdG90eXBlO1xuXHRwLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHtcblx0XHRpZiAoIXRoaXMuc3R5bGUpIHsgcmV0dXJuOyB9XG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHRoaXMuc3R5bGU7XG5cdFx0dmFyIG10eCA9IHRoaXMubWF0cml4O1xuXHRcdGlmIChtdHgpIHsgY3R4LnNhdmUoKTsgY3R4LnRyYW5zZm9ybShtdHguYSwgbXR4LmIsIG10eC5jLCBtdHguZCwgbXR4LnR4LCBtdHgudHkpOyB9XG5cdFx0Y3R4LmZpbGwoKTtcblx0XHRpZiAobXR4KSB7IGN0eC5yZXN0b3JlKCk7IH1cblx0fTtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBsaW5lYXIgZ3JhZGllbnQgc3R5bGUgYW5kIGFzc2lnbnMgaXQgdG8ge3sjY3Jvc3NMaW5rIFwiRmlsbC9zdHlsZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luTGluZWFyR3JhZGllbnRGaWxsXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIGxpbmVhckdyYWRpZW50XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9yc1xuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MFxuXHQgKiBAcGFyYW0ge051bWJlcn0geDFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxXG5cdCAqIEByZXR1cm4ge0ZpbGx9IFJldHVybnMgdGhpcyBGaWxsIG9iamVjdCBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cblx0ICovXG5cdHAubGluZWFyR3JhZGllbnQgPSBmdW5jdGlvbihjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCB4MSwgeTEpIHtcblx0XHR2YXIgbyA9IHRoaXMuc3R5bGUgPSAgR3JhcGhpY3MuX2N0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4MCwgeTAsIHgxLCB5MSk7XG5cdFx0Zm9yICh2YXIgaT0wLCBsPWNvbG9ycy5sZW5ndGg7IGk8bDsgaSsrKSB7IG8uYWRkQ29sb3JTdG9wKHJhdGlvc1tpXSwgY29sb3JzW2ldKTsgfVxuXHRcdG8ucHJvcHMgPSB7Y29sb3JzOmNvbG9ycywgcmF0aW9zOnJhdGlvcywgeDA6eDAsIHkwOnkwLCB4MTp4MSwgeTE6eTEsIHR5cGU6XCJsaW5lYXJcIn07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgcmFkaWFsIGdyYWRpZW50IHN0eWxlIGFuZCBhc3NpZ25zIGl0IHRvIHt7I2Nyb3NzTGluayBcIkZpbGwvc3R5bGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpblJhZGlhbEdyYWRpZW50RmlsbFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQG1ldGhvZCByYWRpYWxHcmFkaWVudFxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnNcblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MFxuXHQgKiBAcGFyYW0ge051bWJlcn0geTBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geTFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIxXG5cdCAqIEByZXR1cm4ge0ZpbGx9IFJldHVybnMgdGhpcyBGaWxsIG9iamVjdCBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cblx0ICovXG5cdHAucmFkaWFsR3JhZGllbnQgPSBmdW5jdGlvbihjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCByMCwgeDEsIHkxLCByMSkge1xuXHRcdHZhciBvID0gdGhpcy5zdHlsZSA9ICBHcmFwaGljcy5fY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpO1xuXHRcdGZvciAodmFyIGk9MCwgbD1jb2xvcnMubGVuZ3RoOyBpPGw7IGkrKykgeyBvLmFkZENvbG9yU3RvcChyYXRpb3NbaV0sIGNvbG9yc1tpXSk7IH1cblx0XHRvLnByb3BzID0ge2NvbG9yczpjb2xvcnMsIHJhdGlvczpyYXRpb3MsIHgwOngwLCB5MDp5MCwgcjA6cjAsIHgxOngxLCB5MTp5MSwgcjE6cjEsIHR5cGU6XCJyYWRpYWxcIn07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgYml0bWFwIGZpbGwgc3R5bGUgYW5kIGFzc2lnbnMgaXQgdG8gdGhlIHt7I2Nyb3NzTGluayBcIkZpbGwvc3R5bGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkJpdG1hcEZpbGxcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBtZXRob2QgYml0bWFwXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgIE11c3QgYmUgbG9hZGVkIHByaW9yIHRvIGNyZWF0aW5nIGEgYml0bWFwIGZpbGwsIG9yIHRoZSBmaWxsIHdpbGwgYmUgZW1wdHkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcmVwZXRpdGlvbl0gT25lIG9mOiByZXBlYXQsIHJlcGVhdC14LCByZXBlYXQteSwgb3Igbm8tcmVwZWF0LlxuXHQgKiBAcmV0dXJuIHtGaWxsfSBSZXR1cm5zIHRoaXMgRmlsbCBvYmplY3QgZm9yIGNoYWluaW5nIG9yIGFzc2lnbm1lbnQuXG5cdCAqL1xuXHRwLmJpdG1hcCA9IGZ1bmN0aW9uKGltYWdlLCByZXBldGl0aW9uKSB7XG5cdFx0aWYgKGltYWdlLm5hdHVyYWxXaWR0aCB8fCBpbWFnZS5nZXRDb250ZXh0IHx8IGltYWdlLnJlYWR5U3RhdGUgPj0gMikge1xuXHRcdFx0dmFyIG8gPSB0aGlzLnN0eWxlID0gR3JhcGhpY3MuX2N0eC5jcmVhdGVQYXR0ZXJuKGltYWdlLCByZXBldGl0aW9uIHx8IFwiXCIpO1xuXHRcdFx0by5wcm9wcyA9IHtpbWFnZTogaW1hZ2UsIHJlcGV0aXRpb246IHJlcGV0aXRpb24sIHR5cGU6IFwiYml0bWFwXCJ9O1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0cC5wYXRoID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5TdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIFN0cm9rZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIEEgdmFsaWQgQ29udGV4dDJEIGZpbGxTdHlsZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVTY2FsZVxuXHQgKiovXG5cdC8qKlxuXHQgKiBBIHZhbGlkIENvbnRleHQyRCBzdHJva2VTdHlsZS5cblx0ICogQHByb3BlcnR5IHN0eWxlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBpZ25vcmVTY2FsZVxuXHQgKiBAdHlwZSBCb29sZWFuXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdHAgPSAoRy5TdHJva2UgPSBmdW5jdGlvbihzdHlsZSwgaWdub3JlU2NhbGUpIHtcblx0XHR0aGlzLnN0eWxlID0gc3R5bGU7XG5cdFx0dGhpcy5pZ25vcmVTY2FsZSA9IGlnbm9yZVNjYWxlO1xuXHR9KS5wcm90b3R5cGU7XG5cdHAuZXhlYyA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGlmICghdGhpcy5zdHlsZSkgeyByZXR1cm47IH1cblx0XHRjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnN0eWxlO1xuXHRcdGlmICh0aGlzLmlnbm9yZVNjYWxlKSB7IGN0eC5zYXZlKCk7IGN0eC5zZXRUcmFuc2Zvcm0oMSwwLDAsMSwwLDApOyB9XG5cdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdGlmICh0aGlzLmlnbm9yZVNjYWxlKSB7IGN0eC5yZXN0b3JlKCk7IH1cblx0fTtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBsaW5lYXIgZ3JhZGllbnQgc3R5bGUgYW5kIGFzc2lnbnMgaXQgdG8ge3sjY3Jvc3NMaW5rIFwiU3Ryb2tlL3N0eWxlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5MaW5lYXJHcmFkaWVudFN0cm9rZVwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQG1ldGhvZCBsaW5lYXJHcmFkaWVudFxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnNcblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MFxuXHQgKiBAcGFyYW0ge051bWJlcn0geTBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuXHQgKiBAcmV0dXJuIHtGaWxsfSBSZXR1cm5zIHRoaXMgU3Ryb2tlIG9iamVjdCBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cblx0ICovXG5cdHAubGluZWFyR3JhZGllbnQgPSBHLkZpbGwucHJvdG90eXBlLmxpbmVhckdyYWRpZW50O1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIHJhZGlhbCBncmFkaWVudCBzdHlsZSBhbmQgYXNzaWducyBpdCB0byB7eyNjcm9zc0xpbmsgXCJTdHJva2Uvc3R5bGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpblJhZGlhbEdyYWRpZW50U3Ryb2tlXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIHJhZGlhbEdyYWRpZW50XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9yc1xuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjFcblx0ICogQHJldHVybiB7RmlsbH0gUmV0dXJucyB0aGlzIFN0cm9rZSBvYmplY3QgZm9yIGNoYWluaW5nIG9yIGFzc2lnbm1lbnQuXG5cdCAqL1xuXHRwLnJhZGlhbEdyYWRpZW50ID0gRy5GaWxsLnByb3RvdHlwZS5yYWRpYWxHcmFkaWVudDtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBiaXRtYXAgZmlsbCBzdHlsZSBhbmQgYXNzaWducyBpdCB0byB7eyNjcm9zc0xpbmsgXCJTdHJva2Uvc3R5bGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkJpdG1hcFN0cm9rZVwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQG1ldGhvZCBiaXRtYXBcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBpbWFnZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3JlcGV0aXRpb25dIE9uZSBvZjogcmVwZWF0LCByZXBlYXQteCwgcmVwZWF0LXksIG9yIG5vLXJlcGVhdC5cblx0ICogQHJldHVybiB7RmlsbH0gUmV0dXJucyB0aGlzIFN0cm9rZSBvYmplY3QgZm9yIGNoYWluaW5nIG9yIGFzc2lnbm1lbnQuXG5cdCAqL1xuXHRwLmJpdG1hcCA9IEcuRmlsbC5wcm90b3R5cGUuYml0bWFwO1xuXHRwLnBhdGggPSBmYWxzZTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9zZXRTdHJva2VTdHlsZVwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgU3Ryb2tlU3R5bGVcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2NhcHNdXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbam9pbnRzXVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW21pdGVyTGltaXRdXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB3aWR0aFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBPbmUgb2Y6IGJ1dHQsIHJvdW5kLCBzcXVhcmVcblx0ICogQHByb3BlcnR5IGNhcHNcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqL1xuXHQvKipcblx0ICogT25lIG9mOiByb3VuZCwgYmV2ZWwsIG1pdGVyXG5cdCAqIEBwcm9wZXJ0eSBqb2ludHNcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IG1pdGVyTGltaXRcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdHAgPSAoRy5TdHJva2VTdHlsZSA9IGZ1bmN0aW9uKHdpZHRoLCBjYXBzLCBqb2ludHMsIG1pdGVyTGltaXQpIHtcblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5jYXBzID0gY2Fwcztcblx0XHR0aGlzLmpvaW50cyA9IGpvaW50cztcblx0XHR0aGlzLm1pdGVyTGltaXQgPSBtaXRlckxpbWl0O1xuXHR9KS5wcm90b3R5cGU7XG5cdHAuZXhlYyA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGN0eC5saW5lV2lkdGggPSAodGhpcy53aWR0aCA9PSBudWxsID8gXCIxXCIgOiB0aGlzLndpZHRoKTtcblx0XHRjdHgubGluZUNhcCA9ICh0aGlzLmNhcHMgPT0gbnVsbCA/IFwiYnV0dFwiIDogKGlzTmFOKHRoaXMuY2FwcykgPyB0aGlzLmNhcHMgOiBHcmFwaGljcy5TVFJPS0VfQ0FQU19NQVBbdGhpcy5jYXBzXSkpO1xuXHRcdGN0eC5saW5lSm9pbiA9ICh0aGlzLmpvaW50cyA9PSBudWxsID8gXCJtaXRlclwiIDogKGlzTmFOKHRoaXMuam9pbnRzKSA/IHRoaXMuam9pbnRzIDogR3JhcGhpY3MuU1RST0tFX0pPSU5UU19NQVBbdGhpcy5qb2ludHNdKSk7XG5cdFx0Y3R4Lm1pdGVyTGltaXQgPSAodGhpcy5taXRlckxpbWl0ID09IG51bGwgPyBcIjEwXCIgOiB0aGlzLm1pdGVyTGltaXQpO1xuXHR9O1xuXHRwLnBhdGggPSBmYWxzZTtcblx0XG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3NldFN0cm9rZURhc2hcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIFN0cm9rZURhc2hcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtzZWdtZW50c11cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXQ9MF1cblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHNlZ21lbnRzXG5cdCAqIEB0eXBlIEFycmF5XG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IG9mZnNldFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKi9cblx0KEcuU3Ryb2tlRGFzaCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBvZmZzZXQpIHtcblx0XHR0aGlzLnNlZ21lbnRzID0gc2VnbWVudHM7XG5cdFx0dGhpcy5vZmZzZXQgPSBvZmZzZXR8fDA7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkgeyAvLyBmZWF0dXJlIGRldGVjdGlvbi5cblx0XHRcdGN0eC5zZXRMaW5lRGFzaCh0aGlzLnNlZ21lbnRzfHwgRy5TdHJva2VEYXNoLkVNUFRZX1NFR01FTlRTKTsgLy8gaW5zdGVhZCBvZiBbXSB0byByZWR1Y2UgY2h1cm4uXG5cdFx0XHRjdHgubGluZURhc2hPZmZzZXQgPSB0aGlzLm9mZnNldHx8MDtcblx0XHR9XG5cdH07XG5cdC8qKlxuXHQgKiBUaGUgZGVmYXVsdCB2YWx1ZSBmb3Igc2VnbWVudHMgKGllLiBubyBkYXNoKS5cblx0ICogQHByb3BlcnR5IEVNUFRZX1NFR01FTlRTXG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqIEByZWFkb25seVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICoqL1xuXHRHLlN0cm9rZURhc2guRU1QVFlfU0VHTUVOVFMgPSBbXTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Um91bmRSZWN0Q29tcGxleFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgUm91bmRSZWN0XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gd1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzVExcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1RSXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCUlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzQkxcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHdcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHJhZGl1c1RMXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSByYWRpdXNUUlxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcmFkaXVzQlJcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHJhZGl1c0JMXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqL1xuXHQoRy5Sb3VuZFJlY3QgPSBmdW5jdGlvbih4LCB5LCB3LCBoLCByYWRpdXNUTCwgcmFkaXVzVFIsIHJhZGl1c0JSLCByYWRpdXNCTCkge1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdFx0dGhpcy53ID0gdzsgdGhpcy5oID0gaDtcblx0XHR0aGlzLnJhZGl1c1RMID0gcmFkaXVzVEw7IHRoaXMucmFkaXVzVFIgPSByYWRpdXNUUjtcblx0XHR0aGlzLnJhZGl1c0JSID0gcmFkaXVzQlI7IHRoaXMucmFkaXVzQkwgPSByYWRpdXNCTDtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHtcblx0XHR2YXIgbWF4ID0gKHc8aD93OmgpLzI7XG5cdFx0dmFyIG1UTD0wLCBtVFI9MCwgbUJSPTAsIG1CTD0wO1xuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB3ID0gdGhpcy53LCBoID0gdGhpcy5oO1xuXHRcdHZhciByVEwgPSB0aGlzLnJhZGl1c1RMLCByVFIgPSB0aGlzLnJhZGl1c1RSLCByQlIgPSB0aGlzLnJhZGl1c0JSLCByQkwgPSB0aGlzLnJhZGl1c0JMO1xuXG5cdFx0aWYgKHJUTCA8IDApIHsgclRMICo9IChtVEw9LTEpOyB9XG5cdFx0aWYgKHJUTCA+IG1heCkgeyByVEwgPSBtYXg7IH1cblx0XHRpZiAoclRSIDwgMCkgeyByVFIgKj0gKG1UUj0tMSk7IH1cblx0XHRpZiAoclRSID4gbWF4KSB7IHJUUiA9IG1heDsgfVxuXHRcdGlmIChyQlIgPCAwKSB7IHJCUiAqPSAobUJSPS0xKTsgfVxuXHRcdGlmIChyQlIgPiBtYXgpIHsgckJSID0gbWF4OyB9XG5cdFx0aWYgKHJCTCA8IDApIHsgckJMICo9IChtQkw9LTEpOyB9XG5cdFx0aWYgKHJCTCA+IG1heCkgeyByQkwgPSBtYXg7IH1cblxuXHRcdGN0eC5tb3ZlVG8oeCt3LXJUUiwgeSk7XG5cdFx0Y3R4LmFyY1RvKHgrdytyVFIqbVRSLCB5LXJUUiptVFIsIHgrdywgeStyVFIsIHJUUik7XG5cdFx0Y3R4LmxpbmVUbyh4K3csIHkraC1yQlIpO1xuXHRcdGN0eC5hcmNUbyh4K3crckJSKm1CUiwgeStoK3JCUiptQlIsIHgrdy1yQlIsIHkraCwgckJSKTtcblx0XHRjdHgubGluZVRvKHgrckJMLCB5K2gpO1xuXHRcdGN0eC5hcmNUbyh4LXJCTCptQkwsIHkraCtyQkwqbUJMLCB4LCB5K2gtckJMLCByQkwpO1xuXHRcdGN0eC5saW5lVG8oeCwgeStyVEwpO1xuXHRcdGN0eC5hcmNUbyh4LXJUTCptVEwsIHktclRMKm1UTCwgeCtyVEwsIHksIHJUTCk7XG5cdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdDaXJjbGVcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIENpcmNsZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcmFkaXVzXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqL1xuXHQoRy5DaXJjbGUgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMpIHtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHguYXJjKHRoaXMueCwgdGhpcy55LCB0aGlzLnJhZGl1cywgMCwgTWF0aC5QSSoyKTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3RWxsaXBzZVwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgRWxsaXBzZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHdcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdChHLkVsbGlwc2UgPSBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0XHR0aGlzLncgPSB3OyB0aGlzLmggPSBoO1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xuXHRcdHZhciB3ID0gdGhpcy53LCBoID0gdGhpcy5oO1xuXG5cdFx0dmFyIGsgPSAwLjU1MjI4NDg7XG5cdFx0dmFyIG94ID0gKHcgLyAyKSAqIGs7XG5cdFx0dmFyIG95ID0gKGggLyAyKSAqIGs7XG5cdFx0dmFyIHhlID0geCArIHc7XG5cdFx0dmFyIHllID0geSArIGg7XG5cdFx0dmFyIHhtID0geCArIHcgLyAyO1xuXHRcdHZhciB5bSA9IHkgKyBoIC8gMjtcblxuXHRcdGN0eC5tb3ZlVG8oeCwgeW0pO1xuXHRcdGN0eC5iZXppZXJDdXJ2ZVRvKHgsIHltLW95LCB4bS1veCwgeSwgeG0sIHkpO1xuXHRcdGN0eC5iZXppZXJDdXJ2ZVRvKHhtK294LCB5LCB4ZSwgeW0tb3ksIHhlLCB5bSk7XG5cdFx0Y3R4LmJlemllckN1cnZlVG8oeGUsIHltK295LCB4bStveCwgeWUsIHhtLCB5ZSk7XG5cdFx0Y3R4LmJlemllckN1cnZlVG8oeG0tb3gsIHllLCB4LCB5bStveSwgeCwgeW0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdQb2x5U3RhclwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgUG9seVN0YXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNpZGVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludFNpemVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSByYWRpdXNcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHNpZGVzXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBwb2ludFNpemVcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGFuZ2xlXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqL1xuXHQoRy5Qb2x5U3RhciA9IGZ1bmN0aW9uKHgsIHksIHJhZGl1cywgc2lkZXMsIHBvaW50U2l6ZSwgYW5nbGUpIHtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXHRcdHRoaXMuc2lkZXMgPSBzaWRlcztcblx0XHR0aGlzLnBvaW50U2l6ZSA9IHBvaW50U2l6ZTtcblx0XHR0aGlzLmFuZ2xlID0gYW5nbGU7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG5cdFx0dmFyIHJhZGl1cyA9IHRoaXMucmFkaXVzO1xuXHRcdHZhciBhbmdsZSA9ICh0aGlzLmFuZ2xlfHwwKS8xODAqTWF0aC5QSTtcblx0XHR2YXIgc2lkZXMgPSB0aGlzLnNpZGVzO1xuXHRcdHZhciBwcyA9IDEtKHRoaXMucG9pbnRTaXplfHwwKTtcblx0XHR2YXIgYSA9IE1hdGguUEkvc2lkZXM7XG5cblx0XHRjdHgubW92ZVRvKHgrTWF0aC5jb3MoYW5nbGUpKnJhZGl1cywgeStNYXRoLnNpbihhbmdsZSkqcmFkaXVzKTtcblx0XHRmb3IgKHZhciBpPTA7IGk8c2lkZXM7IGkrKykge1xuXHRcdFx0YW5nbGUgKz0gYTtcblx0XHRcdGlmIChwcyAhPSAxKSB7XG5cdFx0XHRcdGN0eC5saW5lVG8oeCtNYXRoLmNvcyhhbmdsZSkqcmFkaXVzKnBzLCB5K01hdGguc2luKGFuZ2xlKSpyYWRpdXMqcHMpO1xuXHRcdFx0fVxuXHRcdFx0YW5nbGUgKz0gYTtcblx0XHRcdGN0eC5saW5lVG8oeCtNYXRoLmNvcyhhbmdsZSkqcmFkaXVzLCB5K01hdGguc2luKGFuZ2xlKSpyYWRpdXMpO1xuXHRcdH1cblx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdH07XG5cblx0Ly8gZG9jY2VkIGFib3ZlLlxuXHRHcmFwaGljcy5iZWdpbkNtZCA9IG5ldyBHLkJlZ2luUGF0aCgpOyAvLyBzbyB3ZSBkb24ndCBoYXZlIHRvIGluc3RhbnRpYXRlIG11bHRpcGxlIGluc3RhbmNlcy5cblxuXG5cdGNyZWF0ZWpzLkdyYXBoaWNzID0gR3JhcGhpY3M7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRGlzcGxheU9iamVjdC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbi8vIGNvbnN0cnVjdG9yOlxyXG5cdC8qKlxyXG5cdCAqIERpc3BsYXlPYmplY3QgaXMgYW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBzaG91bGQgbm90IGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5LiBJbnN0ZWFkIGNvbnN0cnVjdCBzdWJjbGFzc2VzIHN1Y2ggYXNcclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIkJpdG1hcFwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHt7I2Nyb3NzTGluayBcIlNoYXBlXCJ9fXt7L2Nyb3NzTGlua319LlxyXG5cdCAqIERpc3BsYXlPYmplY3QgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBkaXNwbGF5IGNsYXNzZXMgaW4gdGhlIEVhc2VsSlMgbGlicmFyeS4gSXQgZGVmaW5lcyB0aGUgY29yZSBwcm9wZXJ0aWVzIGFuZFxyXG5cdCAqIG1ldGhvZHMgdGhhdCBhcmUgc2hhcmVkIGJldHdlZW4gYWxsIGRpc3BsYXkgb2JqZWN0cywgc3VjaCBhcyB0cmFuc2Zvcm1hdGlvbiBwcm9wZXJ0aWVzICh4LCB5LCBzY2FsZVgsIHNjYWxlWSwgZXRjKSxcclxuXHQgKiBjYWNoaW5nLCBhbmQgbW91c2UgaGFuZGxlcnMuXHJcblx0ICogQGNsYXNzIERpc3BsYXlPYmplY3RcclxuXHQgKiBAZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJcclxuXHQgKiBAY29uc3RydWN0b3JcclxuXHQgKiovXHJcblx0ZnVuY3Rpb24gRGlzcGxheU9iamVjdCgpIHtcclxuXHRcdHRoaXMuRXZlbnREaXNwYXRjaGVyX2NvbnN0cnVjdG9yKCk7XHJcblx0XHRcclxuXHRcdFxyXG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgYWxwaGEgKHRyYW5zcGFyZW5jeSkgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QuIDAgaXMgZnVsbHkgdHJhbnNwYXJlbnQsIDEgaXMgZnVsbHkgb3BhcXVlLlxyXG5cdFx0ICogQHByb3BlcnR5IGFscGhhXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMVxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5hbHBoYSA9IDE7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIElmIGEgY2FjaGUgaXMgYWN0aXZlLCB0aGlzIHJldHVybnMgdGhlIGNhbnZhcyB0aGF0IGhvbGRzIHRoZSBjYWNoZWQgdmVyc2lvbiBvZiB0aGlzIGRpc3BsYXkgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiY2FjaGVcIn19e3svY3Jvc3NMaW5rfX1cclxuXHRcdCAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG5cdFx0ICogQHByb3BlcnR5IGNhY2hlQ2FudmFzXHJcblx0XHQgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnQgfCBPYmplY3R9XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKiBAcmVhZG9ubHlcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuY2FjaGVDYW52YXMgPSBudWxsO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXR1cm5zIGFuIElEIG51bWJlciB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgdGhlIGN1cnJlbnQgY2FjaGUgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWQgdG9cclxuXHRcdCAqIGRldGVybWluZSBpZiB0aGUgY2FjaGUgaGFzIGNoYW5nZWQgc2luY2UgYSBwcmV2aW91cyBjaGVjay5cclxuXHRcdCAqIEBwcm9wZXJ0eSBjYWNoZUlEXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmNhY2hlSUQgPSAwO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBVbmlxdWUgSUQgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QuIE1ha2VzIGRpc3BsYXkgb2JqZWN0cyBlYXNpZXIgZm9yIHNvbWUgdXNlcy5cclxuXHRcdCAqIEBwcm9wZXJ0eSBpZFxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IC0xXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLmlkID0gY3JlYXRlanMuVUlELmdldCgpO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0byBpbmNsdWRlIHRoaXMgb2JqZWN0IHdoZW4gcnVubmluZyBtb3VzZSBpbnRlcmFjdGlvbnMuIFNldHRpbmcgdGhpcyB0byBgZmFsc2VgIGZvciBjaGlsZHJlblxyXG5cdFx0ICogb2YgYSB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX0gd2lsbCBjYXVzZSBldmVudHMgb24gdGhlIENvbnRhaW5lciB0byBub3QgZmlyZSB3aGVuIHRoYXQgY2hpbGQgaXNcclxuXHRcdCAqIGNsaWNrZWQuIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSB0byBgZmFsc2VgIGRvZXMgbm90IHByZXZlbnQgdGhlIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lci9nZXRPYmplY3RzVW5kZXJQb2ludFwifX17ey9jcm9zc0xpbmt9fVxyXG5cdFx0ICogbWV0aG9kIGZyb20gcmV0dXJuaW5nIHRoZSBjaGlsZC5cclxuXHRcdCAqXHJcblx0XHQgKiA8c3Ryb25nPk5vdGU6PC9zdHJvbmc+IEluIEVhc2VsSlMgMC43LjAsIHRoZSBtb3VzZUVuYWJsZWQgcHJvcGVydHkgd2lsbCBub3Qgd29yayBwcm9wZXJseSB3aXRoIG5lc3RlZCBDb250YWluZXJzLiBQbGVhc2VcclxuXHRcdCAqIGNoZWNrIG91dCB0aGUgbGF0ZXN0IE5FWFQgdmVyc2lvbiBpbiA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL0NyZWF0ZUpTL0Vhc2VsSlMvdHJlZS9tYXN0ZXIvbGliXCI+R2l0SHViPC9hPiBmb3IgYW4gdXBkYXRlZCB2ZXJzaW9uIHdpdGggdGhpcyBpc3N1ZSByZXNvbHZlZC4gVGhlIGZpeCB3aWxsIGJlXHJcblx0XHQgKiBwcm92aWRlZCBpbiB0aGUgbmV4dCByZWxlYXNlIG9mIEVhc2VsSlMuXHJcblx0XHQgKiBAcHJvcGVydHkgbW91c2VFbmFibGVkXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMubW91c2VFbmFibGVkID0gdHJ1ZTtcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBJZiBmYWxzZSwgdGhlIHRpY2sgd2lsbCBub3QgcnVuIG9uIHRoaXMgZGlzcGxheSBvYmplY3QgKG9yIGl0cyBjaGlsZHJlbikuIFRoaXMgY2FuIHByb3ZpZGUgc29tZSBwZXJmb3JtYW5jZSBiZW5lZml0cy5cclxuXHRcdCAqIEluIGFkZGl0aW9uIHRvIHByZXZlbnRpbmcgdGhlIFwidGlja1wiIGV2ZW50IGZyb20gYmVpbmcgZGlzcGF0Y2hlZCwgaXQgd2lsbCBhbHNvIHByZXZlbnQgdGljayByZWxhdGVkIHVwZGF0ZXNcclxuXHRcdCAqIG9uIHNvbWUgZGlzcGxheSBvYmplY3RzIChleC4gU3ByaXRlICYgTW92aWVDbGlwIGZyYW1lIGFkdmFuY2luZywgRE9NRWxlbWVudCB2aXNpYmlsaXR5IGhhbmRsaW5nKS5cclxuXHRcdCAqIEBwcm9wZXJ0eSB0aWNrRW5hYmxlZFxyXG5cdFx0ICogQHR5cGUgQm9vbGVhblxyXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy50aWNrRW5hYmxlZCA9IHRydWU7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIEFuIG9wdGlvbmFsIG5hbWUgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QuIEluY2x1ZGVkIGluIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvdG9TdHJpbmdcIn19e3svY3Jvc3NMaW5rfX0gLiBVc2VmdWwgZm9yXHJcblx0XHQgKiBkZWJ1Z2dpbmcuXHJcblx0XHQgKiBAcHJvcGVydHkgbmFtZVxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMubmFtZSA9IG51bGw7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIEEgcmVmZXJlbmNlIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX0gb3Ige3sjY3Jvc3NMaW5rIFwiU3RhZ2VcIn19e3svY3Jvc3NMaW5rfX0gb2JqZWN0IHRoYXRcclxuXHRcdCAqIGNvbnRhaW5zIHRoaXMgZGlzcGxheSBvYmplY3QsIG9yIG51bGwgaWYgaXQgaGFzIG5vdCBiZWVuIGFkZGVkXHJcblx0XHQgKiB0byBvbmUuXHJcblx0XHQgKiBAcHJvcGVydHkgcGFyZW50XHJcblx0XHQgKiBAZmluYWxcclxuXHRcdCAqIEB0eXBlIHtDb250YWluZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKiBAcmVhZG9ubHlcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMucGFyZW50ID0gbnVsbDtcclxuXHRcclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGxlZnQgb2Zmc2V0IGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0J3MgcmVnaXN0cmF0aW9uIHBvaW50LiBGb3IgZXhhbXBsZSwgdG8gbWFrZSBhIDEwMHgxMDBweCBCaXRtYXAgcm90YXRlXHJcblx0XHQgKiBhcm91bmQgaXRzIGNlbnRlciwgeW91IHdvdWxkIHNldCByZWdYIGFuZCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3JlZ1k6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gdG8gNTAuXHJcblx0XHQgKiBAcHJvcGVydHkgcmVnWFxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IDBcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMucmVnWCA9IDA7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSB5IG9mZnNldCBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdCdzIHJlZ2lzdHJhdGlvbiBwb2ludC4gRm9yIGV4YW1wbGUsIHRvIG1ha2UgYSAxMDB4MTAwcHggQml0bWFwIHJvdGF0ZSBhcm91bmRcclxuXHRcdCAqIGl0cyBjZW50ZXIsIHlvdSB3b3VsZCBzZXQge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9yZWdYOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGFuZCByZWdZIHRvIDUwLlxyXG5cdFx0ICogQHByb3BlcnR5IHJlZ1lcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAwXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLnJlZ1kgPSAwO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgcm90YXRpb24gaW4gZGVncmVlcyBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdC5cclxuXHRcdCAqIEBwcm9wZXJ0eSByb3RhdGlvblxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IDBcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMucm90YXRpb24gPSAwO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgZmFjdG9yIHRvIHN0cmV0Y2ggdGhpcyBkaXNwbGF5IG9iamVjdCBob3Jpem9udGFsbHkuIEZvciBleGFtcGxlLCBzZXR0aW5nIHNjYWxlWCB0byAyIHdpbGwgc3RyZXRjaCB0aGUgZGlzcGxheVxyXG5cdFx0ICogb2JqZWN0IHRvIHR3aWNlIGl0cyBub21pbmFsIHdpZHRoLiBUbyBob3Jpem9udGFsbHkgZmxpcCBhbiBvYmplY3QsIHNldCB0aGUgc2NhbGUgdG8gYSBuZWdhdGl2ZSBudW1iZXIuXHJcblx0XHQgKiBAcHJvcGVydHkgc2NhbGVYXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMVxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5zY2FsZVggPSAxO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgZmFjdG9yIHRvIHN0cmV0Y2ggdGhpcyBkaXNwbGF5IG9iamVjdCB2ZXJ0aWNhbGx5LiBGb3IgZXhhbXBsZSwgc2V0dGluZyBzY2FsZVkgdG8gMC41IHdpbGwgc3RyZXRjaCB0aGUgZGlzcGxheVxyXG5cdFx0ICogb2JqZWN0IHRvIGhhbGYgaXRzIG5vbWluYWwgaGVpZ2h0LiBUbyB2ZXJ0aWNhbGx5IGZsaXAgYW4gb2JqZWN0LCBzZXQgdGhlIHNjYWxlIHRvIGEgbmVnYXRpdmUgbnVtYmVyLlxyXG5cdFx0ICogQHByb3BlcnR5IHNjYWxlWVxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IDFcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuc2NhbGVZID0gMTtcclxuXHRcclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGZhY3RvciB0byBza2V3IHRoaXMgZGlzcGxheSBvYmplY3QgaG9yaXpvbnRhbGx5LlxyXG5cdFx0ICogQHByb3BlcnR5IHNrZXdYXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5za2V3WCA9IDA7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBmYWN0b3IgdG8gc2tldyB0aGlzIGRpc3BsYXkgb2JqZWN0IHZlcnRpY2FsbHkuXHJcblx0XHQgKiBAcHJvcGVydHkgc2tld1lcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAwXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLnNrZXdZID0gMDtcclxuXHRcclxuXHRcdC8qKlxyXG5cdFx0ICogQSBzaGFkb3cgb2JqZWN0IHRoYXQgZGVmaW5lcyB0aGUgc2hhZG93IHRvIHJlbmRlciBvbiB0aGlzIGRpc3BsYXkgb2JqZWN0LiBTZXQgdG8gYG51bGxgIHRvIHJlbW92ZSBhIHNoYWRvdy4gSWZcclxuXHRcdCAqIG51bGwsIHRoaXMgcHJvcGVydHkgaXMgaW5oZXJpdGVkIGZyb20gdGhlIHBhcmVudCBjb250YWluZXIuXHJcblx0XHQgKiBAcHJvcGVydHkgc2hhZG93XHJcblx0XHQgKiBAdHlwZSB7U2hhZG93fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5zaGFkb3cgPSBudWxsO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGRpc3BsYXkgb2JqZWN0IHNob3VsZCBiZSByZW5kZXJlZCB0byB0aGUgY2FudmFzIGFuZCBpbmNsdWRlZCB3aGVuIHJ1bm5pbmcgdGhlIFN0YWdlXHJcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJTdGFnZS9nZXRPYmplY3RzVW5kZXJQb2ludFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXHJcblx0XHQgKiBAcHJvcGVydHkgdmlzaWJsZVxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLnZpc2libGUgPSB0cnVlO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgeCAoaG9yaXpvbnRhbCkgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0LCByZWxhdGl2ZSB0byBpdHMgcGFyZW50LlxyXG5cdFx0ICogQHByb3BlcnR5IHhcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAwXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLnggPSAwO1xyXG5cdFxyXG5cdFx0LyoqIFRoZSB5ICh2ZXJ0aWNhbCkgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0LCByZWxhdGl2ZSB0byBpdHMgcGFyZW50LlxyXG5cdFx0ICogQHByb3BlcnR5IHlcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAwXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLnkgPSAwO1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIElmIHNldCwgZGVmaW5lcyB0aGUgdHJhbnNmb3JtYXRpb24gZm9yIHRoaXMgZGlzcGxheSBvYmplY3QsIG92ZXJyaWRpbmcgYWxsIG90aGVyIHRyYW5zZm9ybWF0aW9uIHByb3BlcnRpZXNcclxuXHRcdCAqICh4LCB5LCByb3RhdGlvbiwgc2NhbGUsIHNrZXcpLlxyXG5cdFx0ICogQHByb3BlcnR5IHRyYW5zZm9ybU1hdHJpeFxyXG5cdFx0ICogQHR5cGUge01hdHJpeDJEfVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy50cmFuc2Zvcm1NYXRyaXggPSBudWxsO1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBjb21wb3NpdGUgb3BlcmF0aW9uIGluZGljYXRlcyBob3cgdGhlIHBpeGVscyBvZiB0aGlzIGRpc3BsYXkgb2JqZWN0IHdpbGwgYmUgY29tcG9zaXRlZCB3aXRoIHRoZSBlbGVtZW50c1xyXG5cdFx0ICogYmVoaW5kIGl0LiBJZiBgbnVsbGAsIHRoaXMgcHJvcGVydHkgaXMgaW5oZXJpdGVkIGZyb20gdGhlIHBhcmVudCBjb250YWluZXIuIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWFkIHRoZVxyXG5cdFx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2NvbXBvc2l0aW5nXCI+XHJcblx0XHQgKiB3aGF0d2cgc3BlYyBvbiBjb21wb3NpdGluZzwvYT4uXHJcblx0XHQgKiBAcHJvcGVydHkgY29tcG9zaXRlT3BlcmF0aW9uXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5jb21wb3NpdGVPcGVyYXRpb24gPSBudWxsO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgc2hvdWxkIGJlIGRyYXduIHRvIGEgd2hvbGUgcGl4ZWwgd2hlblxyXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiU3RhZ2Uvc25hcFRvUGl4ZWxFbmFibGVkXCJ9fXt7L2Nyb3NzTGlua319IGlzIHRydWUuIFRvIGVuYWJsZS9kaXNhYmxlIHNuYXBwaW5nIG9uIHdob2xlXHJcblx0XHQgKiBjYXRlZ29yaWVzIG9mIGRpc3BsYXkgb2JqZWN0cywgc2V0IHRoaXMgdmFsdWUgb24gdGhlIHByb3RvdHlwZSAoRXguIFRleHQucHJvdG90eXBlLnNuYXBUb1BpeGVsID0gdHJ1ZSkuXHJcblx0XHQgKiBAcHJvcGVydHkgc25hcFRvUGl4ZWxcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5zbmFwVG9QaXhlbCA9IHRydWU7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIEFuIGFycmF5IG9mIEZpbHRlciBvYmplY3RzIHRvIGFwcGx5IHRvIHRoaXMgZGlzcGxheSBvYmplY3QuIEZpbHRlcnMgYXJlIG9ubHkgYXBwbGllZCAvIHVwZGF0ZWQgd2hlbiB7eyNjcm9zc0xpbmsgXCJjYWNoZVwifX17ey9jcm9zc0xpbmt9fVxyXG5cdFx0ICogb3Ige3sjY3Jvc3NMaW5rIFwidXBkYXRlQ2FjaGVcIn19e3svY3Jvc3NMaW5rfX0gaXMgY2FsbGVkIG9uIHRoZSBkaXNwbGF5IG9iamVjdCwgYW5kIG9ubHkgYXBwbHkgdG8gdGhlIGFyZWEgdGhhdCBpc1xyXG5cdFx0ICogY2FjaGVkLlxyXG5cdFx0ICogQHByb3BlcnR5IGZpbHRlcnNcclxuXHRcdCAqIEB0eXBlIHtBcnJheX1cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuZmlsdGVycyA9IG51bGw7XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogQSBTaGFwZSBpbnN0YW5jZSB0aGF0IGRlZmluZXMgYSB2ZWN0b3IgbWFzayAoY2xpcHBpbmcgcGF0aCkgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QuICBUaGUgc2hhcGUncyB0cmFuc2Zvcm1hdGlvblxyXG5cdFx0ICogd2lsbCBiZSBhcHBsaWVkIHJlbGF0aXZlIHRvIHRoZSBkaXNwbGF5IG9iamVjdCdzIHBhcmVudCBjb29yZGluYXRlcyAoYXMgaWYgaXQgd2VyZSBhIGNoaWxkIG9mIHRoZSBwYXJlbnQpLlxyXG5cdFx0ICogQHByb3BlcnR5IG1hc2tcclxuXHRcdCAqIEB0eXBlIHtTaGFwZX1cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5tYXNrID0gbnVsbDtcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGRpc3BsYXkgb2JqZWN0IHRoYXQgd2lsbCBiZSB0ZXN0ZWQgd2hlbiBjaGVja2luZyBtb3VzZSBpbnRlcmFjdGlvbnMgb3IgdGVzdGluZyB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvZ2V0T2JqZWN0c1VuZGVyUG9pbnRcIn19e3svY3Jvc3NMaW5rfX0uXHJcblx0XHQgKiBUaGUgaGl0IGFyZWEgd2lsbCBoYXZlIGl0cyB0cmFuc2Zvcm1hdGlvbiBhcHBsaWVkIHJlbGF0aXZlIHRvIHRoaXMgZGlzcGxheSBvYmplY3QncyBjb29yZGluYXRlIHNwYWNlIChhcyB0aG91Z2hcclxuXHRcdCAqIHRoZSBoaXQgdGVzdCBvYmplY3Qgd2VyZSBhIGNoaWxkIG9mIHRoaXMgZGlzcGxheSBvYmplY3QgYW5kIHJlbGF0aXZlIHRvIGl0cyByZWdYL1kpLiBUaGUgaGl0QXJlYSB3aWxsIGJlIHRlc3RlZFxyXG5cdFx0ICogdXNpbmcgb25seSBpdHMgb3duIGBhbHBoYWAgdmFsdWUgcmVnYXJkbGVzcyBvZiB0aGUgYWxwaGEgdmFsdWUgb24gdGhlIHRhcmdldCBkaXNwbGF5IG9iamVjdCwgb3IgdGhlIHRhcmdldCdzXHJcblx0XHQgKiBhbmNlc3RvcnMgKHBhcmVudHMpLlxyXG5cdFx0ICogXHJcblx0XHQgKiBJZiBzZXQgb24gYSB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX0sIGNoaWxkcmVuIG9mIHRoZSBDb250YWluZXIgd2lsbCBub3QgcmVjZWl2ZSBtb3VzZSBldmVudHMuXHJcblx0XHQgKiBUaGlzIGlzIHNpbWlsYXIgdG8gc2V0dGluZyB7eyNjcm9zc0xpbmsgXCJtb3VzZUNoaWxkcmVuXCJ9fXt7L2Nyb3NzTGlua319IHRvIGZhbHNlLlxyXG5cdFx0ICpcclxuXHRcdCAqIE5vdGUgdGhhdCBoaXRBcmVhIGlzIE5PVCBjdXJyZW50bHkgdXNlZCBieSB0aGUgYGhpdFRlc3QoKWAgbWV0aG9kLCBub3IgaXMgaXQgc3VwcG9ydGVkIGZvciB7eyNjcm9zc0xpbmsgXCJTdGFnZVwifX17ey9jcm9zc0xpbmt9fS5cclxuXHRcdCAqIEBwcm9wZXJ0eSBoaXRBcmVhXHJcblx0XHQgKiBAdHlwZSB7RGlzcGxheU9iamVjdH1cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5oaXRBcmVhID0gbnVsbDtcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIENTUyBjdXJzb3IgKGV4LiBcInBvaW50ZXJcIiwgXCJoZWxwXCIsIFwidGV4dFwiLCBldGMpIHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQgd2hlbiB0aGUgdXNlciBob3ZlcnMgb3ZlciB0aGlzIGRpc3BsYXlcclxuXHRcdCAqIG9iamVjdC4gWW91IG11c3QgZW5hYmxlIG1vdXNlb3ZlciBldmVudHMgdXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcIlN0YWdlL2VuYWJsZU1vdXNlT3ZlclwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgdG9cclxuXHRcdCAqIHVzZSB0aGlzIHByb3BlcnR5LiBTZXR0aW5nIGEgbm9uLW51bGwgY3Vyc29yIG9uIGEgQ29udGFpbmVyIHdpbGwgb3ZlcnJpZGUgdGhlIGN1cnNvciBzZXQgb24gaXRzIGRlc2NlbmRhbnRzLlxyXG5cdFx0ICogQHByb3BlcnR5IGN1cnNvclxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5jdXJzb3IgPSBudWxsO1xyXG5cdFxyXG5cdFxyXG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcclxuXHRcdC8qKlxyXG5cdFx0ICogQHByb3BlcnR5IF9jYWNoZU9mZnNldFhcclxuXHRcdCAqIEBwcm90ZWN0ZWRcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAwXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLl9jYWNoZU9mZnNldFggPSAwO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJvcGVydHkgX2NhY2hlT2Zmc2V0WVxyXG5cdFx0ICogQHByb3RlY3RlZFxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IDBcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuX2NhY2hlT2Zmc2V0WSA9IDA7XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogQHByb3BlcnR5IF9maWx0ZXJPZmZzZXRYXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5fZmlsdGVyT2Zmc2V0WCA9IDA7XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogQHByb3BlcnR5IF9maWx0ZXJPZmZzZXRZXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5fZmlsdGVyT2Zmc2V0WSA9IDA7XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogQHByb3BlcnR5IF9jYWNoZVNjYWxlXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMVxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5fY2FjaGVTY2FsZSA9IDE7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCogQHByb3BlcnR5IF9jYWNoZURhdGFVUkxJRFxyXG5cdFx0KiBAcHJvdGVjdGVkXHJcblx0XHQqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQqIEBkZWZhdWx0IDBcclxuXHRcdCovXHJcblx0XHR0aGlzLl9jYWNoZURhdGFVUkxJRCA9IDA7XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0KiBAcHJvcGVydHkgX2NhY2hlRGF0YVVSTFxyXG5cdFx0KiBAcHJvdGVjdGVkXHJcblx0XHQqIEB0eXBlIHtTdHJpbmd9XHJcblx0XHQqIEBkZWZhdWx0IG51bGxcclxuXHRcdCovXHJcblx0XHR0aGlzLl9jYWNoZURhdGFVUkwgPSBudWxsO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJvcGVydHkgX3Byb3BzXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAdHlwZSB7RGlzcGxheU9iamVjdH1cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuX3Byb3BzID0gbmV3IGNyZWF0ZWpzLkRpc3BsYXlQcm9wcygpO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJvcGVydHkgX3JlY3RhbmdsZVxyXG5cdFx0ICogQHByb3RlY3RlZFxyXG5cdFx0ICogQHR5cGUge1JlY3RhbmdsZX1cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuX3JlY3RhbmdsZSA9IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoKTtcclxuXHRcclxuXHRcdC8qKlxyXG5cdFx0ICogQHByb3BlcnR5IF9ib3VuZHNcclxuXHRcdCAqIEBwcm90ZWN0ZWRcclxuXHRcdCAqIEB0eXBlIHtSZWN0YW5nbGV9XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLl9ib3VuZHMgPSBudWxsO1xyXG5cdH1cclxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChEaXNwbGF5T2JqZWN0LCBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIpO1xyXG5cclxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXHJcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxyXG5cdFxyXG4vLyBzdGF0aWMgcHJvcGVydGllczpcclxuXHQvKipcclxuXHQgKiBMaXN0aW5nIG9mIG1vdXNlIGV2ZW50IG5hbWVzLiBVc2VkIGluIF9oYXNNb3VzZUV2ZW50TGlzdGVuZXIuXHJcblx0ICogQHByb3BlcnR5IF9NT1VTRV9FVkVOVFNcclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICogQHN0YXRpY1xyXG5cdCAqIEB0eXBlIHtBcnJheX1cclxuXHQgKiovXHJcblx0RGlzcGxheU9iamVjdC5fTU9VU0VfRVZFTlRTID0gW1wiY2xpY2tcIixcImRibGNsaWNrXCIsXCJtb3VzZWRvd25cIixcIm1vdXNlb3V0XCIsXCJtb3VzZW92ZXJcIixcInByZXNzbW92ZVwiLFwicHJlc3N1cFwiLFwicm9sbG91dFwiLFwicm9sbG92ZXJcIl07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFN1cHByZXNzZXMgZXJyb3JzIGdlbmVyYXRlZCB3aGVuIHVzaW5nIGZlYXR1cmVzIGxpa2UgaGl0VGVzdCwgbW91c2UgZXZlbnRzLCBhbmQge3sjY3Jvc3NMaW5rIFwiZ2V0T2JqZWN0c1VuZGVyUG9pbnRcIn19e3svY3Jvc3NMaW5rfX1cclxuXHQgKiB3aXRoIGNyb3NzIGRvbWFpbiBjb250ZW50LlxyXG5cdCAqIEBwcm9wZXJ0eSBzdXBwcmVzc0Nyb3NzRG9tYWluRXJyb3JzXHJcblx0ICogQHN0YXRpY1xyXG5cdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0ICoqL1xyXG5cdERpc3BsYXlPYmplY3Quc3VwcHJlc3NDcm9zc0RvbWFpbkVycm9ycyA9IGZhbHNlO1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEBwcm9wZXJ0eSBfc25hcFRvUGl4ZWxFbmFibGVkXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqIEBzdGF0aWNcclxuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdCAqKi9cclxuXHREaXNwbGF5T2JqZWN0Ll9zbmFwVG9QaXhlbEVuYWJsZWQgPSBmYWxzZTsgLy8gc3RhZ2Uuc25hcFRvUGl4ZWxFbmFibGVkIGlzIHRlbXBvcmFyaWx5IGNvcGllZCBoZXJlIGR1cmluZyBhIGRyYXcgdG8gcHJvdmlkZSBnbG9iYWwgYWNjZXNzLlxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJvcGVydHkgX2hpdFRlc3RDYW52YXNcclxuXHQgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnQgfCBPYmplY3R9XHJcblx0ICogQHN0YXRpY1xyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiovXHJcblx0LyoqXHJcblx0ICogQHByb3BlcnR5IF9oaXRUZXN0Q29udGV4dFxyXG5cdCAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XHJcblx0ICogQHN0YXRpY1xyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiovXHJcblx0dmFyIGNhbnZhcyA9IGNyZWF0ZWpzLmNyZWF0ZUNhbnZhcz9jcmVhdGVqcy5jcmVhdGVDYW52YXMoKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpOyAvLyBwcmV2ZW50IGVycm9ycyBvbiBsb2FkIGluIGJyb3dzZXJzIHdpdGhvdXQgY2FudmFzLlxyXG5cdGlmIChjYW52YXMuZ2V0Q29udGV4dCkge1xyXG5cdFx0RGlzcGxheU9iamVjdC5faGl0VGVzdENhbnZhcyA9IGNhbnZhcztcclxuXHRcdERpc3BsYXlPYmplY3QuX2hpdFRlc3RDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHRcdGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAxO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQHByb3BlcnR5IF9uZXh0Q2FjaGVJRFxyXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0ICogQHN0YXRpY1xyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiovXHJcblx0RGlzcGxheU9iamVjdC5fbmV4dENhY2hlSUQgPSAxO1xyXG5cclxuXHJcbi8vIGV2ZW50czpcclxuXHQvKipcclxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyB0aGVpciBsZWZ0IG1vdXNlIGJ1dHRvbiBvdmVyIHRoZSBkaXNwbGF5IG9iamVjdC4gU2VlIHRoZSBcclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cclxuXHQgKiBAZXZlbnQgbW91c2Vkb3duXHJcblx0ICogQHNpbmNlIDAuNi4wXHJcblx0ICovXHJcblx0IFxyXG5cdC8qKlxyXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIHRoZWlyIGxlZnQgbW91c2UgYnV0dG9uIGFuZCB0aGVuIHJlbGVhc2VzIGl0IHdoaWxlIG92ZXIgdGhlIGRpc3BsYXkgb2JqZWN0LlxyXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXHJcblx0ICogQGV2ZW50IGNsaWNrXHJcblx0ICogQHNpbmNlIDAuNi4wXHJcblx0ICovXHJcblx0IFxyXG5cdC8qKlxyXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgdXNlciBkb3VibGUgY2xpY2tzIHRoZWlyIGxlZnQgbW91c2UgYnV0dG9uIG92ZXIgdGhpcyBkaXNwbGF5IG9iamVjdC5cclxuXHQgKiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxyXG5cdCAqIEBldmVudCBkYmxjbGlja1xyXG5cdCAqIEBzaW5jZSAwLjYuMFxyXG5cdCAqL1xyXG5cdCBcclxuXHQvKipcclxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIncyBtb3VzZSBlbnRlcnMgdGhpcyBkaXNwbGF5IG9iamVjdC4gVGhpcyBldmVudCBtdXN0IGJlIGVuYWJsZWQgdXNpbmcgXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvZW5hYmxlTW91c2VPdmVyXCJ9fXt7L2Nyb3NzTGlua319LiBTZWUgYWxzbyB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3JvbGxvdmVyOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LlxyXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXHJcblx0ICogQGV2ZW50IG1vdXNlb3ZlclxyXG5cdCAqIEBzaW5jZSAwLjYuMFxyXG5cdCAqL1xyXG5cclxuXHQvKipcclxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIncyBtb3VzZSBsZWF2ZXMgdGhpcyBkaXNwbGF5IG9iamVjdC4gVGhpcyBldmVudCBtdXN0IGJlIGVuYWJsZWQgdXNpbmcgXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvZW5hYmxlTW91c2VPdmVyXCJ9fXt7L2Nyb3NzTGlua319LiBTZWUgYWxzbyB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3JvbGxvdXQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uXHJcblx0ICogU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cclxuXHQgKiBAZXZlbnQgbW91c2VvdXRcclxuXHQgKiBAc2luY2UgMC42LjBcclxuXHQgKi9cclxuXHQgXHJcblx0LyoqXHJcblx0ICogVGhpcyBldmVudCBpcyBzaW1pbGFyIHRvIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2VvdmVyOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LCB3aXRoIHRoZSBmb2xsb3dpbmdcclxuXHQgKiBkaWZmZXJlbmNlczogaXQgZG9lcyBub3QgYnViYmxlLCBhbmQgaXQgY29uc2lkZXJzIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZXMgYXMgYW5cclxuXHQgKiBhZ2dyZWdhdGUgb2YgdGhlaXIgY29udGVudC5cclxuXHQgKiBcclxuXHQgKiBGb3IgZXhhbXBsZSwgbXlDb250YWluZXIgY29udGFpbnMgdHdvIG92ZXJsYXBwaW5nIGNoaWxkcmVuOiBzaGFwZUEgYW5kIHNoYXBlQi4gVGhlIHVzZXIgbW92ZXMgdGhlaXIgbW91c2Ugb3ZlclxyXG5cdCAqIHNoYXBlQSBhbmQgdGhlbiBkaXJlY3RseSBvbiB0byBzaGFwZUIuIFdpdGggYSBsaXN0ZW5lciBmb3Ige3sjY3Jvc3NMaW5rIFwibW91c2VvdmVyOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IG9uXHJcblx0ICogbXlDb250YWluZXIsIHR3byBldmVudHMgd291bGQgYmUgcmVjZWl2ZWQsIGVhY2ggdGFyZ2V0aW5nIGEgY2hpbGQgZWxlbWVudDo8T0w+XHJcblx0ICogPExJPndoZW4gdGhlIG1vdXNlIGVudGVycyBzaGFwZUEgKHRhcmdldD1zaGFwZUEpPC9MST5cclxuXHQgKiA8TEk+d2hlbiB0aGUgbW91c2UgZW50ZXJzIHNoYXBlQiAodGFyZ2V0PXNoYXBlQik8L0xJPlxyXG5cdCAqIDwvT0w+XHJcblx0ICogSG93ZXZlciwgd2l0aCBhIGxpc3RlbmVyIGZvciBcInJvbGxvdmVyXCIgaW5zdGVhZCwgb25seSBhIHNpbmdsZSBldmVudCBpcyByZWNlaXZlZCB3aGVuIHRoZSBtb3VzZSBmaXJzdCBlbnRlcnNcclxuXHQgKiB0aGUgYWdncmVnYXRlIG15Q29udGFpbmVyIGNvbnRlbnQgKHRhcmdldD1teUNvbnRhaW5lcikuXHJcblx0ICogXHJcblx0ICogVGhpcyBldmVudCBtdXN0IGJlIGVuYWJsZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvZW5hYmxlTW91c2VPdmVyXCJ9fXt7L2Nyb3NzTGlua319LlxyXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXHJcblx0ICogQGV2ZW50IHJvbGxvdmVyXHJcblx0ICogQHNpbmNlIDAuNy4wXHJcblx0ICovXHJcblx0IFxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgZXZlbnQgaXMgc2ltaWxhciB0byB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlb3V0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LCB3aXRoIHRoZSBmb2xsb3dpbmdcclxuXHQgKiBkaWZmZXJlbmNlczogaXQgZG9lcyBub3QgYnViYmxlLCBhbmQgaXQgY29uc2lkZXJzIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZXMgYXMgYW5cclxuXHQgKiBhZ2dyZWdhdGUgb2YgdGhlaXIgY29udGVudC5cclxuXHQgKiBcclxuXHQgKiBGb3IgZXhhbXBsZSwgbXlDb250YWluZXIgY29udGFpbnMgdHdvIG92ZXJsYXBwaW5nIGNoaWxkcmVuOiBzaGFwZUEgYW5kIHNoYXBlQi4gVGhlIHVzZXIgbW92ZXMgdGhlaXIgbW91c2Ugb3ZlclxyXG5cdCAqIHNoYXBlQSwgdGhlbiBkaXJlY3RseSBvbiB0byBzaGFwZUIsIHRoZW4gb2ZmIGJvdGguIFdpdGggYSBsaXN0ZW5lciBmb3Ige3sjY3Jvc3NMaW5rIFwibW91c2VvdXQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cclxuXHQgKiBvbiBteUNvbnRhaW5lciwgdHdvIGV2ZW50cyB3b3VsZCBiZSByZWNlaXZlZCwgZWFjaCB0YXJnZXRpbmcgYSBjaGlsZCBlbGVtZW50OjxPTD5cclxuXHQgKiA8TEk+d2hlbiB0aGUgbW91c2UgbGVhdmVzIHNoYXBlQSAodGFyZ2V0PXNoYXBlQSk8L0xJPlxyXG5cdCAqIDxMST53aGVuIHRoZSBtb3VzZSBsZWF2ZXMgc2hhcGVCICh0YXJnZXQ9c2hhcGVCKTwvTEk+XHJcblx0ICogPC9PTD5cclxuXHQgKiBIb3dldmVyLCB3aXRoIGEgbGlzdGVuZXIgZm9yIFwicm9sbG91dFwiIGluc3RlYWQsIG9ubHkgYSBzaW5nbGUgZXZlbnQgaXMgcmVjZWl2ZWQgd2hlbiB0aGUgbW91c2UgbGVhdmVzXHJcblx0ICogdGhlIGFnZ3JlZ2F0ZSBteUNvbnRhaW5lciBjb250ZW50ICh0YXJnZXQ9bXlDb250YWluZXIpLlxyXG5cdCAqIFxyXG5cdCAqIFRoaXMgZXZlbnQgbXVzdCBiZSBlbmFibGVkIHVzaW5nIHt7I2Nyb3NzTGluayBcIlN0YWdlL2VuYWJsZU1vdXNlT3ZlclwifX17ey9jcm9zc0xpbmt9fS5cclxuXHQgKiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxyXG5cdCAqIEBldmVudCByb2xsb3V0XHJcblx0ICogQHNpbmNlIDAuNy4wXHJcblx0ICovXHJcblx0IFxyXG5cdC8qKlxyXG5cdCAqIEFmdGVyIGEge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9tb3VzZWRvd246ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gb2NjdXJzIG9uIGEgZGlzcGxheSBvYmplY3QsIGEgcHJlc3Ntb3ZlXHJcblx0ICogZXZlbnQgd2lsbCBiZSBnZW5lcmF0ZWQgb24gdGhhdCBvYmplY3Qgd2hlbmV2ZXIgdGhlIG1vdXNlIG1vdmVzIHVudGlsIHRoZSBtb3VzZSBwcmVzcyBpcyByZWxlYXNlZC4gVGhpcyBjYW4gYmVcclxuXHQgKiB1c2VmdWwgZm9yIGRyYWdnaW5nIGFuZCBzaW1pbGFyIG9wZXJhdGlvbnMuXHJcblx0ICogQGV2ZW50IHByZXNzbW92ZVxyXG5cdCAqIEBzaW5jZSAwLjcuMFxyXG5cdCAqL1xyXG5cdCBcclxuXHQvKipcclxuXHQgKiBBZnRlciBhIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2Vkb3duOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IG9jY3VycyBvbiBhIGRpc3BsYXkgb2JqZWN0LCBhIHByZXNzdXAgZXZlbnRcclxuXHQgKiB3aWxsIGJlIGdlbmVyYXRlZCBvbiB0aGF0IG9iamVjdCB3aGVuIHRoYXQgbW91c2UgcHJlc3MgaXMgcmVsZWFzZWQuIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3IgZHJhZ2dpbmcgYW5kIHNpbWlsYXJcclxuXHQgKiBvcGVyYXRpb25zLlxyXG5cdCAqIEBldmVudCBwcmVzc3VwXHJcblx0ICogQHNpbmNlIDAuNy4wXHJcblx0ICovXHJcblx0IFxyXG5cdC8qKlxyXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgZGlzcGxheSBvYmplY3QgaXMgYWRkZWQgdG8gYSBwYXJlbnQgY29udGFpbmVyLlxyXG5cdCAqIEBldmVudCBhZGRlZFxyXG5cdCAqL1xyXG5cdCBcclxuXHQvKipcclxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIGRpc3BsYXkgb2JqZWN0IGlzIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50IGNvbnRhaW5lci5cclxuXHQgKiBAZXZlbnQgcmVtb3ZlZFxyXG5cdCAqL1xyXG5cdCBcclxuXHQvKipcclxuXHQgKiBEaXNwYXRjaGVkIG9uIGVhY2ggZGlzcGxheSBvYmplY3Qgb24gYSBzdGFnZSB3aGVuZXZlciB0aGUgc3RhZ2UgdXBkYXRlcy4gVGhpcyBvY2N1cnMgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZVxyXG5cdCAqIHJlbmRlcmluZyAoZHJhdykgcGFzcy4gV2hlbiB7eyNjcm9zc0xpbmsgXCJTdGFnZS91cGRhdGVcIn19e3svY3Jvc3NMaW5rfX0gaXMgY2FsbGVkLCBmaXJzdCBhbGwgZGlzcGxheSBvYmplY3RzIG9uXHJcblx0ICogdGhlIHN0YWdlIGRpc3BhdGNoIHRoZSB0aWNrIGV2ZW50LCB0aGVuIGFsbCBvZiB0aGUgZGlzcGxheSBvYmplY3RzIGFyZSBkcmF3biB0byBzdGFnZS4gQ2hpbGRyZW4gd2lsbCBoYXZlIHRoZWlyXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwidGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBkaXNwYXRjaGVkIGluIG9yZGVyIG9mIHRoZWlyIGRlcHRoIHByaW9yIHRvIHRoZSBldmVudCBiZWluZ1xyXG5cdCAqIGRpc3BhdGNoZWQgb24gdGhlaXIgcGFyZW50LlxyXG5cdCAqIEBldmVudCB0aWNrXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXHJcblx0ICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIEFuIGFycmF5IGNvbnRhaW5pbmcgYW55IGFyZ3VtZW50cyB0aGF0IHdlcmUgcGFzc2VkIHRvIHRoZSBTdGFnZS51cGRhdGUoKSBtZXRob2QuIEZvclxyXG5cdCAqICAgICAgZXhhbXBsZSBpZiB5b3UgY2FsbGVkIHN0YWdlLnVwZGF0ZShcImhlbGxvXCIpLCB0aGVuIHRoZSBwYXJhbXMgd291bGQgYmUgW1wiaGVsbG9cIl0uXHJcblx0ICogQHNpbmNlIDAuNi4wXHJcblx0ICovXHJcblx0XHJcblx0XHJcbi8vIGdldHRlciAvIHNldHRlcnM6XHJcblx0LyoqXHJcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3N0YWdlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXHJcblx0ICogQG1ldGhvZCBnZXRTdGFnZVxyXG5cdCAqIEByZXR1cm4ge1N0YWdlfVxyXG5cdCAqIEBkZXByZWNhdGVkXHJcblx0ICoqL1xyXG5cdHAuZ2V0U3RhZ2UgPSBmdW5jdGlvbigpIHtcclxuXHRcdC8vIHVzZXMgZHluYW1pYyBhY2Nlc3MgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzO1xyXG5cdFx0dmFyIG8gPSB0aGlzLCBfU3RhZ2UgPSBjcmVhdGVqc1tcIlN0YWdlXCJdO1xyXG5cdFx0d2hpbGUgKG8ucGFyZW50KSB7IG8gPSBvLnBhcmVudDsgfVxyXG5cdFx0aWYgKG8gaW5zdGFuY2VvZiBfU3RhZ2UpIHsgcmV0dXJuIG87IH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIFN0YWdlIGluc3RhbmNlIHRoYXQgdGhpcyBkaXNwbGF5IG9iamVjdCB3aWxsIGJlIHJlbmRlcmVkIG9uLCBvciBudWxsIGlmIGl0IGhhcyBub3QgYmVlbiBhZGRlZCB0byBvbmUuXHJcblx0ICogQHByb3BlcnR5IHN0YWdlXHJcblx0ICogQHR5cGUge1N0YWdlfVxyXG5cdCAqIEByZWFkb25seVxyXG5cdCAqKi9cclxuXHR0cnkge1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMocCwge1xyXG5cdFx0XHRzdGFnZTogeyBnZXQ6IHAuZ2V0U3RhZ2UgfVxyXG5cdFx0fSk7XHJcblx0fSBjYXRjaCAoZSkge31cclxuXHJcblxyXG4vLyBwdWJsaWMgbWV0aG9kczpcclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxyXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXHJcblx0ICpcclxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXHJcblx0ICogQG1ldGhvZCBpc1Zpc2libGVcclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhc1xyXG5cdCAqKi9cclxuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPSAwICYmIHRoaXMuc2NhbGVZICE9IDApO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cclxuXHQgKiBSZXR1cm5zIDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZSBkcmF3IHdhcyBoYW5kbGVkICh1c2VmdWwgZm9yIG92ZXJyaWRpbmcgZnVuY3Rpb25hbGl0eSkuXHJcblx0ICpcclxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXHJcblx0ICogQG1ldGhvZCBkcmF3XHJcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtpZ25vcmVDYWNoZT1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRyYXcgb3BlcmF0aW9uIHNob3VsZCBpZ25vcmUgYW55IGN1cnJlbnQgY2FjaGUuIEZvciBleGFtcGxlLFxyXG5cdCAqIHVzZWQgZm9yIGRyYXdpbmcgdGhlIGNhY2hlICh0byBwcmV2ZW50IGl0IGZyb20gc2ltcGx5IGRyYXdpbmcgYW4gZXhpc3RpbmcgY2FjaGUgYmFjayBpbnRvIGl0c2VsZikuXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cclxuXHQgKiovXHJcblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBpZ25vcmVDYWNoZSkge1xyXG5cdFx0dmFyIGNhY2hlQ2FudmFzID0gdGhpcy5jYWNoZUNhbnZhcztcclxuXHRcdGlmIChpZ25vcmVDYWNoZSB8fCAhY2FjaGVDYW52YXMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9jYWNoZVNjYWxlO1xyXG5cdFx0Y3R4LmRyYXdJbWFnZShjYWNoZUNhbnZhcywgdGhpcy5fY2FjaGVPZmZzZXRYK3RoaXMuX2ZpbHRlck9mZnNldFgsIHRoaXMuX2NhY2hlT2Zmc2V0WSt0aGlzLl9maWx0ZXJPZmZzZXRZLCBjYWNoZUNhbnZhcy53aWR0aC9zY2FsZSwgY2FjaGVDYW52YXMuaGVpZ2h0L3NjYWxlKTtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogQXBwbGllcyB0aGlzIGRpc3BsYXkgb2JqZWN0J3MgdHJhbnNmb3JtYXRpb24sIGFscGhhLCBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24sIGNsaXBwaW5nIHBhdGggKG1hc2spLCBhbmQgc2hhZG93XHJcblx0ICogdG8gdGhlIHNwZWNpZmllZCBjb250ZXh0LiBUaGlzIGlzIHR5cGljYWxseSBjYWxsZWQgcHJpb3IgdG8ge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9kcmF3XCJ9fXt7L2Nyb3NzTGlua319LlxyXG5cdCAqIEBtZXRob2QgdXBkYXRlQ29udGV4dFxyXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCB0byB1cGRhdGUuXHJcblx0ICoqL1xyXG5cdHAudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0dmFyIG89dGhpcywgbWFzaz1vLm1hc2ssIG10eD0gby5fcHJvcHMubWF0cml4O1xyXG5cdFx0XHJcblx0XHRpZiAobWFzayAmJiBtYXNrLmdyYXBoaWNzICYmICFtYXNrLmdyYXBoaWNzLmlzRW1wdHkoKSkge1xyXG5cdFx0XHRtYXNrLmdldE1hdHJpeChtdHgpO1xyXG5cdFx0XHRjdHgudHJhbnNmb3JtKG10eC5hLCAgbXR4LmIsIG10eC5jLCBtdHguZCwgbXR4LnR4LCBtdHgudHkpO1xyXG5cdFx0XHRcclxuXHRcdFx0bWFzay5ncmFwaGljcy5kcmF3QXNQYXRoKGN0eCk7XHJcblx0XHRcdGN0eC5jbGlwKCk7XHJcblx0XHRcdFxyXG5cdFx0XHRtdHguaW52ZXJ0KCk7XHJcblx0XHRcdGN0eC50cmFuc2Zvcm0obXR4LmEsICBtdHguYiwgbXR4LmMsIG10eC5kLCBtdHgudHgsIG10eC50eSk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHRoaXMuZ2V0TWF0cml4KG10eCk7XHJcblx0XHR2YXIgdHggPSBtdHgudHgsIHR5ID0gbXR4LnR5O1xyXG5cdFx0aWYgKERpc3BsYXlPYmplY3QuX3NuYXBUb1BpeGVsRW5hYmxlZCAmJiBvLnNuYXBUb1BpeGVsKSB7XHJcblx0XHRcdHR4ID0gdHggKyAodHggPCAwID8gLTAuNSA6IDAuNSkgfCAwO1xyXG5cdFx0XHR0eSA9IHR5ICsgKHR5IDwgMCA/IC0wLjUgOiAwLjUpIHwgMDtcclxuXHRcdH1cclxuXHRcdGN0eC50cmFuc2Zvcm0obXR4LmEsICBtdHguYiwgbXR4LmMsIG10eC5kLCB0eCwgdHkpO1xyXG5cdFx0Y3R4Lmdsb2JhbEFscGhhICo9IG8uYWxwaGE7XHJcblx0XHRpZiAoby5jb21wb3NpdGVPcGVyYXRpb24pIHsgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IG8uY29tcG9zaXRlT3BlcmF0aW9uOyB9XHJcblx0XHRpZiAoby5zaGFkb3cpIHsgdGhpcy5fYXBwbHlTaGFkb3coY3R4LCBvLnNoYWRvdyk7IH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBEcmF3cyB0aGUgZGlzcGxheSBvYmplY3QgaW50byBhIG5ldyBjYW52YXMsIHdoaWNoIGlzIHRoZW4gdXNlZCBmb3Igc3Vic2VxdWVudCBkcmF3cy4gRm9yIGNvbXBsZXggY29udGVudFxyXG5cdCAqIHRoYXQgZG9lcyBub3QgY2hhbmdlIGZyZXF1ZW50bHkgKGV4LiBhIENvbnRhaW5lciB3aXRoIG1hbnkgY2hpbGRyZW4gdGhhdCBkbyBub3QgbW92ZSwgb3IgYSBjb21wbGV4IHZlY3RvciBTaGFwZSksXHJcblx0ICogdGhpcyBjYW4gcHJvdmlkZSBmb3IgbXVjaCBmYXN0ZXIgcmVuZGVyaW5nIGJlY2F1c2UgdGhlIGNvbnRlbnQgZG9lcyBub3QgbmVlZCB0byBiZSByZS1yZW5kZXJlZCBlYWNoIHRpY2suIFRoZVxyXG5cdCAqIGNhY2hlZCBkaXNwbGF5IG9iamVjdCBjYW4gYmUgbW92ZWQsIHJvdGF0ZWQsIGZhZGVkLCBldGMgZnJlZWx5LCBob3dldmVyIGlmIGl0cyBjb250ZW50IGNoYW5nZXMsIHlvdSBtdXN0XHJcblx0ICogbWFudWFsbHkgdXBkYXRlIHRoZSBjYWNoZSBieSBjYWxsaW5nIDxjb2RlPnVwZGF0ZUNhY2hlKCk8L2NvZGU+IG9yIDxjb2RlPmNhY2hlKCk8L2NvZGU+IGFnYWluLiBZb3UgbXVzdCBzcGVjaWZ5XHJcblx0ICogdGhlIGNhY2hlIGFyZWEgdmlhIHRoZSB4LCB5LCB3LCBhbmQgaCBwYXJhbWV0ZXJzLiBUaGlzIGRlZmluZXMgdGhlIHJlY3RhbmdsZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgYW5kIGNhY2hlZFxyXG5cdCAqIHVzaW5nIHRoaXMgZGlzcGxheSBvYmplY3QncyBjb29yZGluYXRlcy5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKiBGb3IgZXhhbXBsZSBpZiB5b3UgZGVmaW5lZCBhIFNoYXBlIHRoYXQgZHJldyBhIGNpcmNsZSBhdCAwLCAwIHdpdGggYSByYWRpdXMgb2YgMjU6XHJcblx0ICpcclxuXHQgKiAgICAgIHZhciBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xyXG5cdCAqICAgICAgc2hhcGUuZ3JhcGhpY3MuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3Q2lyY2xlKDAsIDAsIDI1KTtcclxuXHQgKiAgICAgIG15U2hhcGUuY2FjaGUoLTI1LCAtMjUsIDUwLCA1MCk7XHJcblx0ICpcclxuXHQgKiBOb3RlIHRoYXQgZmlsdGVycyBuZWVkIHRvIGJlIGRlZmluZWQgPGVtPmJlZm9yZTwvZW0+IHRoZSBjYWNoZSBpcyBhcHBsaWVkLiBDaGVjayBvdXQgdGhlIHt7I2Nyb3NzTGluayBcIkZpbHRlclwifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIGNsYXNzIGZvciBtb3JlIGluZm9ybWF0aW9uLiBTb21lIGZpbHRlcnMgKGV4LiBCbHVyRmlsdGVyKSB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIHNjYWxlIHBhcmFtLlxyXG5cdCAqIFxyXG5cdCAqIFVzdWFsbHksIHRoZSByZXN1bHRpbmcgY2FjaGVDYW52YXMgd2lsbCBoYXZlIHRoZSBkaW1lbnNpb25zIHdpZHRoKnNjYWxlIGJ5IGhlaWdodCpzY2FsZSwgaG93ZXZlciBzb21lIGZpbHRlcnMgKGV4LiBCbHVyRmlsdGVyKVxyXG5cdCAqIHdpbGwgYWRkIHBhZGRpbmcgdG8gdGhlIGNhbnZhcyBkaW1lbnNpb25zLlxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBjYWNoZVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgb3JpZ2luIGZvciB0aGUgY2FjaGUgcmVnaW9uLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgb3JpZ2luIGZvciB0aGUgY2FjaGUgcmVnaW9uLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIGNhY2hlIHJlZ2lvbi5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGNhY2hlIHJlZ2lvbi5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlPTFdIFRoZSBzY2FsZSBhdCB3aGljaCB0aGUgY2FjaGUgd2lsbCBiZSBjcmVhdGVkLiBGb3IgZXhhbXBsZSwgaWYgeW91IGNhY2hlIGEgdmVjdG9yIHNoYXBlIHVzaW5nXHJcblx0ICogXHRteVNoYXBlLmNhY2hlKDAsMCwxMDAsMTAwLDIpIHRoZW4gdGhlIHJlc3VsdGluZyBjYWNoZUNhbnZhcyB3aWxsIGJlIDIwMHgyMDAgcHguIFRoaXMgbGV0cyB5b3Ugc2NhbGUgYW5kIHJvdGF0ZVxyXG5cdCAqIFx0Y2FjaGVkIGVsZW1lbnRzIHdpdGggZ3JlYXRlciBmaWRlbGl0eS4gRGVmYXVsdCBpcyAxLlxyXG5cdCAqKi9cclxuXHRwLmNhY2hlID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCwgc2NhbGUpIHtcclxuXHRcdC8vIGRyYXcgdG8gY2FudmFzLlxyXG5cdFx0c2NhbGUgPSBzY2FsZXx8MTtcclxuXHRcdGlmICghdGhpcy5jYWNoZUNhbnZhcykgeyB0aGlzLmNhY2hlQ2FudmFzID0gY3JlYXRlanMuY3JlYXRlQ2FudmFzP2NyZWF0ZWpzLmNyZWF0ZUNhbnZhcygpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7IH1cclxuXHRcdHRoaXMuX2NhY2hlV2lkdGggPSB3aWR0aDtcclxuXHRcdHRoaXMuX2NhY2hlSGVpZ2h0ID0gaGVpZ2h0O1xyXG5cdFx0dGhpcy5fY2FjaGVPZmZzZXRYID0geDtcclxuXHRcdHRoaXMuX2NhY2hlT2Zmc2V0WSA9IHk7XHJcblx0XHR0aGlzLl9jYWNoZVNjYWxlID0gc2NhbGU7XHJcblx0XHR0aGlzLnVwZGF0ZUNhY2hlKCk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmVkcmF3cyB0aGUgZGlzcGxheSBvYmplY3QgdG8gaXRzIGNhY2hlLiBDYWxsaW5nIHVwZGF0ZUNhY2hlIHdpdGhvdXQgYW4gYWN0aXZlIGNhY2hlIHdpbGwgdGhyb3cgYW4gZXJyb3IuXHJcblx0ICogSWYgY29tcG9zaXRlT3BlcmF0aW9uIGlzIG51bGwgdGhlIGN1cnJlbnQgY2FjaGUgd2lsbCBiZSBjbGVhcmVkIHByaW9yIHRvIGRyYXdpbmcuIE90aGVyd2lzZSB0aGUgZGlzcGxheSBvYmplY3RcclxuXHQgKiB3aWxsIGJlIGRyYXduIG92ZXIgdGhlIGV4aXN0aW5nIGNhY2hlIHVzaW5nIHRoZSBzcGVjaWZpZWQgY29tcG9zaXRlT3BlcmF0aW9uLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqIENsZWFyIHRoZSBjdXJyZW50IGdyYXBoaWNzIG9mIGEgY2FjaGVkIHNoYXBlLCBkcmF3IHNvbWUgbmV3IGluc3RydWN0aW9ucywgYW5kIHRoZW4gdXBkYXRlIHRoZSBjYWNoZS4gVGhlIG5ldyBsaW5lXHJcblx0ICogd2lsbCBiZSBkcmF3biBvbiB0b3Agb2YgdGhlIG9sZCBvbmUuXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIE5vdCBzaG93bjogQ3JlYXRpbmcgdGhlIHNoYXBlLCBhbmQgY2FjaGluZyBpdC5cclxuXHQgKiAgICAgIHNoYXBlSW5zdGFuY2UuY2xlYXIoKTtcclxuXHQgKiAgICAgIHNoYXBlSW5zdGFuY2Uuc2V0U3Ryb2tlU3R5bGUoMykuYmVnaW5TdHJva2UoXCIjZmYwMDAwXCIpLm1vdmVUbygxMDAsIDEwMCkubGluZVRvKDIwMCwyMDApO1xyXG5cdCAqICAgICAgc2hhcGVJbnN0YW5jZS51cGRhdGVDYWNoZSgpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCB1cGRhdGVDYWNoZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb3NpdGVPcGVyYXRpb24gVGhlIGNvbXBvc2l0ZU9wZXJhdGlvbiB0byB1c2UsIG9yIG51bGwgdG8gY2xlYXIgdGhlIGNhY2hlIGFuZCByZWRyYXcgaXQuXHJcblx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2NvbXBvc2l0aW5nXCI+XHJcblx0ICogd2hhdHdnIHNwZWMgb24gY29tcG9zaXRpbmc8L2E+LlxyXG5cdCAqKi9cclxuXHRwLnVwZGF0ZUNhY2hlID0gZnVuY3Rpb24oY29tcG9zaXRlT3BlcmF0aW9uKSB7XHJcblx0XHR2YXIgY2FjaGVDYW52YXMgPSB0aGlzLmNhY2hlQ2FudmFzO1xyXG5cdFx0aWYgKCFjYWNoZUNhbnZhcykgeyB0aHJvdyBcImNhY2hlKCkgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHVwZGF0ZUNhY2hlKClcIjsgfVxyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fY2FjaGVTY2FsZSwgb2ZmWCA9IHRoaXMuX2NhY2hlT2Zmc2V0WCpzY2FsZSwgb2ZmWSA9IHRoaXMuX2NhY2hlT2Zmc2V0WSpzY2FsZTtcclxuXHRcdHZhciB3ID0gdGhpcy5fY2FjaGVXaWR0aCwgaCA9IHRoaXMuX2NhY2hlSGVpZ2h0LCBjdHggPSBjYWNoZUNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblx0XHRcclxuXHRcdHZhciBmQm91bmRzID0gdGhpcy5fZ2V0RmlsdGVyQm91bmRzKCk7XHJcblx0XHRvZmZYICs9ICh0aGlzLl9maWx0ZXJPZmZzZXRYID0gZkJvdW5kcy54KTtcclxuXHRcdG9mZlkgKz0gKHRoaXMuX2ZpbHRlck9mZnNldFkgPSBmQm91bmRzLnkpO1xyXG5cdFx0XHJcblx0XHR3ID0gTWF0aC5jZWlsKHcqc2NhbGUpICsgZkJvdW5kcy53aWR0aDtcclxuXHRcdGggPSBNYXRoLmNlaWwoaCpzY2FsZSkgKyBmQm91bmRzLmhlaWdodDtcclxuXHRcdGlmICh3ICE9IGNhY2hlQ2FudmFzLndpZHRoIHx8IGggIT0gY2FjaGVDYW52YXMuaGVpZ2h0KSB7XHJcblx0XHRcdC8vIFRPRE86IGl0IHdvdWxkIGJlIG5pY2UgdG8gcHJlc2VydmUgdGhlIGNvbnRlbnQgaWYgdGhlcmUgaXMgYSBjb21wb3NpdGVPcGVyYXRpb24uXHJcblx0XHRcdGNhY2hlQ2FudmFzLndpZHRoID0gdztcclxuXHRcdFx0Y2FjaGVDYW52YXMuaGVpZ2h0ID0gaDtcclxuXHRcdH0gZWxzZSBpZiAoIWNvbXBvc2l0ZU9wZXJhdGlvbikge1xyXG5cdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHcrMSwgaCsxKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Y3R4LnNhdmUoKTtcclxuXHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGVPcGVyYXRpb247XHJcblx0XHRjdHguc2V0VHJhbnNmb3JtKHNjYWxlLCAwLCAwLCBzY2FsZSwgLW9mZlgsIC1vZmZZKTtcclxuXHRcdHRoaXMuZHJhdyhjdHgsIHRydWUpO1xyXG5cdFx0Ly8gVE9ETzogZmlsdGVycyBhbmQgY2FjaGUgc2NhbGUgZG9uJ3QgcGxheSB3ZWxsIHRvZ2V0aGVyIGF0IHByZXNlbnQuXHJcblx0XHR0aGlzLl9hcHBseUZpbHRlcnMoKTtcclxuXHRcdGN0eC5yZXN0b3JlKCk7XHJcblx0XHR0aGlzLmNhY2hlSUQgPSBEaXNwbGF5T2JqZWN0Ll9uZXh0Q2FjaGVJRCsrO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIENsZWFycyB0aGUgY3VycmVudCBjYWNoZS4gU2VlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvY2FjaGVcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcblx0ICogQG1ldGhvZCB1bmNhY2hlXHJcblx0ICoqL1xyXG5cdHAudW5jYWNoZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5fY2FjaGVEYXRhVVJMID0gdGhpcy5jYWNoZUNhbnZhcyA9IG51bGw7XHJcblx0XHR0aGlzLmNhY2hlSUQgPSB0aGlzLl9jYWNoZU9mZnNldFggPSB0aGlzLl9jYWNoZU9mZnNldFkgPSB0aGlzLl9maWx0ZXJPZmZzZXRYID0gdGhpcy5fZmlsdGVyT2Zmc2V0WSA9IDA7XHJcblx0XHR0aGlzLl9jYWNoZVNjYWxlID0gMTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBkYXRhIFVSTCBmb3IgdGhlIGNhY2hlLCBvciBudWxsIGlmIHRoaXMgZGlzcGxheSBvYmplY3QgaXMgbm90IGNhY2hlZC5cclxuXHQgKiBVc2VzIGNhY2hlSUQgdG8gZW5zdXJlIGEgbmV3IGRhdGEgVVJMIGlzIG5vdCBnZW5lcmF0ZWQgaWYgdGhlIGNhY2hlIGhhcyBub3QgY2hhbmdlZC5cclxuXHQgKiBAbWV0aG9kIGdldENhY2hlRGF0YVVSTFxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGltYWdlIGRhdGEgdXJsIGZvciB0aGUgY2FjaGUuXHJcblx0ICoqL1xyXG5cdHAuZ2V0Q2FjaGVEYXRhVVJMID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZiAoIXRoaXMuY2FjaGVDYW52YXMpIHsgcmV0dXJuIG51bGw7IH1cclxuXHRcdGlmICh0aGlzLmNhY2hlSUQgIT0gdGhpcy5fY2FjaGVEYXRhVVJMSUQpIHsgdGhpcy5fY2FjaGVEYXRhVVJMID0gdGhpcy5jYWNoZUNhbnZhcy50b0RhdGFVUkwoKTsgfVxyXG5cdFx0cmV0dXJuIHRoaXMuX2NhY2hlRGF0YVVSTDtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBUcmFuc2Zvcm1zIHRoZSBzcGVjaWZpZWQgeCBhbmQgeSBwb3NpdGlvbiBmcm9tIHRoZSBjb29yZGluYXRlIHNwYWNlIG9mIHRoZSBkaXNwbGF5IG9iamVjdFxyXG5cdCAqIHRvIHRoZSBnbG9iYWwgKHN0YWdlKSBjb29yZGluYXRlIHNwYWNlLiBGb3IgZXhhbXBsZSwgdGhpcyBjb3VsZCBiZSB1c2VkIHRvIHBvc2l0aW9uIGFuIEhUTUwgbGFiZWxcclxuXHQgKiBvdmVyIGEgc3BlY2lmaWMgcG9pbnQgb24gYSBuZXN0ZWQgZGlzcGxheSBvYmplY3QuIFJldHVybnMgYSBQb2ludCBpbnN0YW5jZSB3aXRoIHggYW5kIHkgcHJvcGVydGllc1xyXG5cdCAqIGNvcnJlbGF0aW5nIHRvIHRoZSB0cmFuc2Zvcm1lZCBjb29yZGluYXRlcyBvbiB0aGUgc3RhZ2UuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QueCA9IDMwMDtcclxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QueSA9IDIwMDtcclxuXHQgKiAgICAgIHN0YWdlLmFkZENoaWxkKGRpc3BsYXlPYmplY3QpO1xyXG5cdCAqICAgICAgdmFyIHBvaW50ID0gbXlEaXNwbGF5T2JqZWN0LmxvY2FsVG9HbG9iYWwoMTAwLCAxMDApO1xyXG5cdCAqICAgICAgLy8gUmVzdWx0cyBpbiB4PTQwMCwgeT0zMDBcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgbG9jYWxUb0dsb2JhbFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIGluIHRoZSBzb3VyY2UgZGlzcGxheSBvYmplY3QgdG8gdHJhbnNmb3JtLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uIGluIHRoZSBzb3VyY2UgZGlzcGxheSBvYmplY3QgdG8gdHJhbnNmb3JtLlxyXG5cdCAqIEBwYXJhbSB7UG9pbnQgfCBPYmplY3R9IFtwdF0gQW4gb2JqZWN0IHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvLiBJZiBvbWl0dGVkIGEgbmV3IFBvaW50IG9iamVjdCB3aXRoIHgveSBwcm9wZXJ0aWVzIHdpbGwgYmUgcmV0dXJuZWQuIFxyXG5cdCAqIEByZXR1cm4ge1BvaW50fSBBIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzIGNvcnJlbGF0aW5nIHRvIHRoZSB0cmFuc2Zvcm1lZCBjb29yZGluYXRlc1xyXG5cdCAqIG9uIHRoZSBzdGFnZS5cclxuXHQgKiovXHJcblx0cC5sb2NhbFRvR2xvYmFsID0gZnVuY3Rpb24oeCwgeSwgcHQpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldENvbmNhdGVuYXRlZE1hdHJpeCh0aGlzLl9wcm9wcy5tYXRyaXgpLnRyYW5zZm9ybVBvaW50KHgseSwgcHR8fG5ldyBjcmVhdGVqcy5Qb2ludCgpKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBUcmFuc2Zvcm1zIHRoZSBzcGVjaWZpZWQgeCBhbmQgeSBwb3NpdGlvbiBmcm9tIHRoZSBnbG9iYWwgKHN0YWdlKSBjb29yZGluYXRlIHNwYWNlIHRvIHRoZVxyXG5cdCAqIGNvb3JkaW5hdGUgc3BhY2Ugb2YgdGhlIGRpc3BsYXkgb2JqZWN0LiBGb3IgZXhhbXBsZSwgdGhpcyBjb3VsZCBiZSB1c2VkIHRvIGRldGVybWluZVxyXG5cdCAqIHRoZSBjdXJyZW50IG1vdXNlIHBvc2l0aW9uIHdpdGhpbiB0aGUgZGlzcGxheSBvYmplY3QuIFJldHVybnMgYSBQb2ludCBpbnN0YW5jZSB3aXRoIHggYW5kIHkgcHJvcGVydGllc1xyXG5cdCAqIGNvcnJlbGF0aW5nIHRvIHRoZSB0cmFuc2Zvcm1lZCBwb3NpdGlvbiBpbiB0aGUgZGlzcGxheSBvYmplY3QncyBjb29yZGluYXRlIHNwYWNlLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnggPSAzMDA7XHJcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnkgPSAyMDA7XHJcblx0ICogICAgICBzdGFnZS5hZGRDaGlsZChkaXNwbGF5T2JqZWN0KTtcclxuXHQgKiAgICAgIHZhciBwb2ludCA9IG15RGlzcGxheU9iamVjdC5nbG9iYWxUb0xvY2FsKDEwMCwgMTAwKTtcclxuXHQgKiAgICAgIC8vIFJlc3VsdHMgaW4geD0tMjAwLCB5PS0xMDBcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgZ2xvYmFsVG9Mb2NhbFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIG9uIHRoZSBzdGFnZSB0byB0cmFuc2Zvcm0uXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gb24gdGhlIHN0YWdlIHRvIHRyYW5zZm9ybS5cclxuXHQgKiBAcGFyYW0ge1BvaW50IHwgT2JqZWN0fSBbcHRdIEFuIG9iamVjdCB0byBjb3B5IHRoZSByZXN1bHQgaW50by4gSWYgb21pdHRlZCBhIG5ldyBQb2ludCBvYmplY3Qgd2l0aCB4L3kgcHJvcGVydGllcyB3aWxsIGJlIHJldHVybmVkLiBcclxuXHQgKiBAcmV0dXJuIHtQb2ludH0gQSBQb2ludCBpbnN0YW5jZSB3aXRoIHggYW5kIHkgcHJvcGVydGllcyBjb3JyZWxhdGluZyB0byB0aGUgdHJhbnNmb3JtZWQgcG9zaXRpb24gaW4gdGhlXHJcblx0ICogZGlzcGxheSBvYmplY3QncyBjb29yZGluYXRlIHNwYWNlLlxyXG5cdCAqKi9cclxuXHRwLmdsb2JhbFRvTG9jYWwgPSBmdW5jdGlvbih4LCB5LCBwdCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29uY2F0ZW5hdGVkTWF0cml4KHRoaXMuX3Byb3BzLm1hdHJpeCkuaW52ZXJ0KCkudHJhbnNmb3JtUG9pbnQoeCx5LCBwdHx8bmV3IGNyZWF0ZWpzLlBvaW50KCkpO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRyYW5zZm9ybXMgdGhlIHNwZWNpZmllZCB4IGFuZCB5IHBvc2l0aW9uIGZyb20gdGhlIGNvb3JkaW5hdGUgc3BhY2Ugb2YgdGhpcyBkaXNwbGF5IG9iamVjdCB0byB0aGUgY29vcmRpbmF0ZVxyXG5cdCAqIHNwYWNlIG9mIHRoZSB0YXJnZXQgZGlzcGxheSBvYmplY3QuIFJldHVybnMgYSBQb2ludCBpbnN0YW5jZSB3aXRoIHggYW5kIHkgcHJvcGVydGllcyBjb3JyZWxhdGluZyB0byB0aGVcclxuXHQgKiB0cmFuc2Zvcm1lZCBwb3NpdGlvbiBpbiB0aGUgdGFyZ2V0J3MgY29vcmRpbmF0ZSBzcGFjZS4gRWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgdXNpbmcgdGhlIGZvbGxvd2luZyBjb2RlIHdpdGhcclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2xvY2FsVG9HbG9iYWxcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvZ2xvYmFsVG9Mb2NhbFwifX17ey9jcm9zc0xpbmt9fS5cclxuXHQgKlxyXG5cdCAqICAgICAgdmFyIHB0ID0gdGhpcy5sb2NhbFRvR2xvYmFsKHgsIHkpO1xyXG5cdCAqICAgICAgcHQgPSB0YXJnZXQuZ2xvYmFsVG9Mb2NhbChwdC54LCBwdC55KTtcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgbG9jYWxUb0xvY2FsXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gaW4gdGhlIHNvdXJjZSBkaXNwbGF5IG9iamVjdCB0byB0cmFuc2Zvcm0uXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gb24gdGhlIHNvdXJjZSBkaXNwbGF5IG9iamVjdCB0byB0cmFuc2Zvcm0uXHJcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBkaXNwbGF5IG9iamVjdCB0byB3aGljaCB0aGUgY29vcmRpbmF0ZXMgd2lsbCBiZSB0cmFuc2Zvcm1lZC5cclxuXHQgKiBAcGFyYW0ge1BvaW50IHwgT2JqZWN0fSBbcHRdIEFuIG9iamVjdCB0byBjb3B5IHRoZSByZXN1bHQgaW50by4gSWYgb21pdHRlZCBhIG5ldyBQb2ludCBvYmplY3Qgd2l0aCB4L3kgcHJvcGVydGllcyB3aWxsIGJlIHJldHVybmVkLiBcclxuXHQgKiBAcmV0dXJuIHtQb2ludH0gUmV0dXJucyBhIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzIGNvcnJlbGF0aW5nIHRvIHRoZSB0cmFuc2Zvcm1lZCBwb3NpdGlvblxyXG5cdCAqIGluIHRoZSB0YXJnZXQncyBjb29yZGluYXRlIHNwYWNlLlxyXG5cdCAqKi9cclxuXHRwLmxvY2FsVG9Mb2NhbCA9IGZ1bmN0aW9uKHgsIHksIHRhcmdldCwgcHQpIHtcclxuXHRcdHB0ID0gdGhpcy5sb2NhbFRvR2xvYmFsKHgsIHksIHB0KTtcclxuXHRcdHJldHVybiB0YXJnZXQuZ2xvYmFsVG9Mb2NhbChwdC54LCBwdC55LCBwdCk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogU2hvcnRjdXQgbWV0aG9kIHRvIHF1aWNrbHkgc2V0IHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyBvbiB0aGUgZGlzcGxheSBvYmplY3QuIEFsbCBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbC5cclxuXHQgKiBPbWl0dGVkIHBhcmFtZXRlcnMgd2lsbCBoYXZlIHRoZSBkZWZhdWx0IHZhbHVlIHNldC5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5zZXRUcmFuc2Zvcm0oMTAwLCAxMDAsIDIsIDIpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBzZXRUcmFuc2Zvcm1cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gVGhlIGhvcml6b250YWwgdHJhbnNsYXRpb24gKHggcG9zaXRpb24pIGluIHBpeGVsc1xyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSBUaGUgdmVydGljYWwgdHJhbnNsYXRpb24gKHkgcG9zaXRpb24pIGluIHBpeGVsc1xyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVYPTFdIFRoZSBob3Jpem9udGFsIHNjYWxlLCBhcyBhIHBlcmNlbnRhZ2Ugb2YgMVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVZPTFdIHRoZSB2ZXJ0aWNhbCBzY2FsZSwgYXMgYSBwZXJjZW50YWdlIG9mIDFcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3JvdGF0aW9uPTBdIFRoZSByb3RhdGlvbiwgaW4gZGVncmVlc1xyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2tld1g9MF0gVGhlIGhvcml6b250YWwgc2tldyBmYWN0b3JcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NrZXdZPTBdIFRoZSB2ZXJ0aWNhbCBza2V3IGZhY3RvclxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcmVnWD0wXSBUaGUgaG9yaXpvbnRhbCByZWdpc3RyYXRpb24gcG9pbnQgaW4gcGl4ZWxzXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtyZWdZPTBdIFRoZSB2ZXJ0aWNhbCByZWdpc3RyYXRpb24gcG9pbnQgaW4gcGl4ZWxzXHJcblx0ICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gUmV0dXJucyB0aGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIGNvbW1hbmRzLlxyXG5cdCAqIEBjaGFpbmFibGVcclxuXHQqL1xyXG5cdHAuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24oeCwgeSwgc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uLCBza2V3WCwgc2tld1ksIHJlZ1gsIHJlZ1kpIHtcclxuXHRcdHRoaXMueCA9IHggfHwgMDtcclxuXHRcdHRoaXMueSA9IHkgfHwgMDtcclxuXHRcdHRoaXMuc2NhbGVYID0gc2NhbGVYID09IG51bGwgPyAxIDogc2NhbGVYO1xyXG5cdFx0dGhpcy5zY2FsZVkgPSBzY2FsZVkgPT0gbnVsbCA/IDEgOiBzY2FsZVk7XHJcblx0XHR0aGlzLnJvdGF0aW9uID0gcm90YXRpb24gfHwgMDtcclxuXHRcdHRoaXMuc2tld1ggPSBza2V3WCB8fCAwO1xyXG5cdFx0dGhpcy5za2V3WSA9IHNrZXdZIHx8IDA7XHJcblx0XHR0aGlzLnJlZ1ggPSByZWdYIHx8IDA7XHJcblx0XHR0aGlzLnJlZ1kgPSByZWdZIHx8IDA7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBtYXRyaXggYmFzZWQgb24gdGhpcyBvYmplY3QncyBjdXJyZW50IHRyYW5zZm9ybS5cclxuXHQgKiBAbWV0aG9kIGdldE1hdHJpeFxyXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeCBPcHRpb25hbC4gQSBNYXRyaXgyRCBvYmplY3QgdG8gcG9wdWxhdGUgd2l0aCB0aGUgY2FsY3VsYXRlZCB2YWx1ZXMuIElmIG51bGwsIGEgbmV3XHJcblx0ICogTWF0cml4IG9iamVjdCBpcyByZXR1cm5lZC5cclxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gQSBtYXRyaXggcmVwcmVzZW50aW5nIHRoaXMgZGlzcGxheSBvYmplY3QncyB0cmFuc2Zvcm0uXHJcblx0ICoqL1xyXG5cdHAuZ2V0TWF0cml4ID0gZnVuY3Rpb24obWF0cml4KSB7XHJcblx0XHR2YXIgbyA9IHRoaXMsIG10eCA9IG1hdHJpeCYmbWF0cml4LmlkZW50aXR5KCkgfHwgbmV3IGNyZWF0ZWpzLk1hdHJpeDJEKCk7XHJcblx0XHRyZXR1cm4gby50cmFuc2Zvcm1NYXRyaXggPyAgbXR4LmNvcHkoby50cmFuc2Zvcm1NYXRyaXgpIDogbXR4LmFwcGVuZFRyYW5zZm9ybShvLngsIG8ueSwgby5zY2FsZVgsIG8uc2NhbGVZLCBvLnJvdGF0aW9uLCBvLnNrZXdYLCBvLnNrZXdZLCBvLnJlZ1gsIG8ucmVnWSk7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZXMgYSBNYXRyaXgyRCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjb21iaW5lZCB0cmFuc2Zvcm0gb2YgdGhlIGRpc3BsYXkgb2JqZWN0IGFuZCBhbGwgb2YgaXRzXHJcblx0ICogcGFyZW50IENvbnRhaW5lcnMgdXAgdG8gdGhlIGhpZ2hlc3QgbGV2ZWwgYW5jZXN0b3IgKHVzdWFsbHkgdGhlIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319KS4gVGhpcyBjYW5cclxuXHQgKiBiZSB1c2VkIHRvIHRyYW5zZm9ybSBwb3NpdGlvbnMgYmV0d2VlbiBjb29yZGluYXRlIHNwYWNlcywgc3VjaCBhcyB3aXRoIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbG9jYWxUb0dsb2JhbFwifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIGFuZCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2dsb2JhbFRvTG9jYWxcIn19e3svY3Jvc3NMaW5rfX0uXHJcblx0ICogQG1ldGhvZCBnZXRDb25jYXRlbmF0ZWRNYXRyaXhcclxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBbbWF0cml4XSBBIHt7I2Nyb3NzTGluayBcIk1hdHJpeDJEXCJ9fXt7L2Nyb3NzTGlua319IG9iamVjdCB0byBwb3B1bGF0ZSB3aXRoIHRoZSBjYWxjdWxhdGVkIHZhbHVlcy5cclxuXHQgKiBJZiBudWxsLCBhIG5ldyBNYXRyaXgyRCBvYmplY3QgaXMgcmV0dXJuZWQuXHJcblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoZSBjb21iaW5lZCBtYXRyaXguXHJcblx0ICoqL1xyXG5cdHAuZ2V0Q29uY2F0ZW5hdGVkTWF0cml4ID0gZnVuY3Rpb24obWF0cml4KSB7XHJcblx0XHR2YXIgbyA9IHRoaXMsIG10eCA9IHRoaXMuZ2V0TWF0cml4KG1hdHJpeCk7XHJcblx0XHR3aGlsZSAobyA9IG8ucGFyZW50KSB7XHJcblx0XHRcdG10eC5wcmVwZW5kTWF0cml4KG8uZ2V0TWF0cml4KG8uX3Byb3BzLm1hdHJpeCkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG10eDtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlcyBhIERpc3BsYXlQcm9wcyBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjb21iaW5lZCBkaXNwbGF5IHByb3BlcnRpZXMgb2YgdGhlICBvYmplY3QgYW5kIGFsbCBvZiBpdHNcclxuXHQgKiBwYXJlbnQgQ29udGFpbmVycyB1cCB0byB0aGUgaGlnaGVzdCBsZXZlbCBhbmNlc3RvciAodXN1YWxseSB0aGUge3sjY3Jvc3NMaW5rIFwiU3RhZ2VcIn19e3svY3Jvc3NMaW5rfX0pLlxyXG5cdCAqIEBtZXRob2QgZ2V0Q29uY2F0ZW5hdGVkRGlzcGxheVByb3BzXHJcblx0ICogQHBhcmFtIHtEaXNwbGF5UHJvcHN9IFtwcm9wc10gQSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5UHJvcHNcIn19e3svY3Jvc3NMaW5rfX0gb2JqZWN0IHRvIHBvcHVsYXRlIHdpdGggdGhlIGNhbGN1bGF0ZWQgdmFsdWVzLlxyXG5cdCAqIElmIG51bGwsIGEgbmV3IERpc3BsYXlQcm9wcyBvYmplY3QgaXMgcmV0dXJuZWQuXHJcblx0ICogQHJldHVybiB7RGlzcGxheVByb3BzfSBUaGUgY29tYmluZWQgZGlzcGxheSBwcm9wZXJ0aWVzLlxyXG5cdCAqKi9cclxuXHRwLmdldENvbmNhdGVuYXRlZERpc3BsYXlQcm9wcyA9IGZ1bmN0aW9uKHByb3BzKSB7XHJcblx0XHRwcm9wcyA9IHByb3BzID8gcHJvcHMuaWRlbnRpdHkoKSA6IG5ldyBjcmVhdGVqcy5EaXNwbGF5UHJvcHMoKTtcclxuXHRcdHZhciBvID0gdGhpcywgbXR4ID0gby5nZXRNYXRyaXgocHJvcHMubWF0cml4KTsgXHJcblx0XHRkbyB7XHJcblx0XHRcdHByb3BzLnByZXBlbmQoby52aXNpYmxlLCBvLmFscGhhLCBvLnNoYWRvdywgby5jb21wb3NpdGVPcGVyYXRpb24pO1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gd2UgZG8gdGhpcyB0byBhdm9pZCBwcm9ibGVtcyB3aXRoIHRoZSBtYXRyaXggYmVpbmcgdXNlZCBmb3IgYm90aCBvcGVyYXRpb25zIHdoZW4gby5fcHJvcHMubWF0cml4IGlzIHBhc3NlZCBpbiBhcyB0aGUgcHJvcHMgcGFyYW0uXHJcblx0XHRcdC8vIHRoaXMgY291bGQgYmUgc2ltcGxpZmllZCAoaWUuIGp1c3QgZG9uZSBhcyBwYXJ0IG9mIHRoZSBwcmVwZW5kIGFib3ZlKSBpZiB3ZSBzd2l0Y2hlZCB0byB1c2luZyBhIHBvb2wuXHJcblx0XHRcdGlmIChvICE9IHRoaXMpIHsgbXR4LnByZXBlbmRNYXRyaXgoby5nZXRNYXRyaXgoby5fcHJvcHMubWF0cml4KSk7IH1cclxuXHRcdH0gd2hpbGUgKG8gPSBvLnBhcmVudCk7XHJcblx0XHRyZXR1cm4gcHJvcHM7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogVGVzdHMgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3QgaW50ZXJzZWN0cyB0aGUgc3BlY2lmaWVkIHBvaW50IGluIGxvY2FsIGNvb3JkaW5hdGVzIChpZS4gZHJhd3MgYSBwaXhlbCB3aXRoIGFscGhhID4gMCBhdFxyXG5cdCAqIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24pLiBUaGlzIGlnbm9yZXMgdGhlIGFscGhhLCBzaGFkb3csIGhpdEFyZWEsIG1hc2ssIGFuZCBjb21wb3NpdGVPcGVyYXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICBzdGFnZS5hZGRFdmVudExpc3RlbmVyKFwic3RhZ2Vtb3VzZWRvd25cIiwgaGFuZGxlTW91c2VEb3duKTtcclxuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xyXG5cdCAqICAgICAgICAgIHZhciBoaXQgPSBteVNoYXBlLmhpdFRlc3QoZXZlbnQuc3RhZ2VYLCBldmVudC5zdGFnZVkpO1xyXG5cdCAqICAgICAgfVxyXG5cdCAqXHJcblx0ICogUGxlYXNlIG5vdGUgdGhhdCBzaGFwZS10by1zaGFwZSBjb2xsaXNpb24gaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgRWFzZWxKUy5cclxuXHQgKiBAbWV0aG9kIGhpdFRlc3RcclxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvbiB0byBjaGVjayBpbiB0aGUgZGlzcGxheSBvYmplY3QncyBsb2NhbCBjb29yZGluYXRlcy5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiB0byBjaGVjayBpbiB0aGUgZGlzcGxheSBvYmplY3QncyBsb2NhbCBjb29yZGluYXRlcy5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGEgdmlzaWJsZSBwb3J0aW9uIG9mIHRoZSBEaXNwbGF5T2JqZWN0IGludGVyc2VjdCB0aGUgc3BlY2lmaWVkXHJcblx0ICogbG9jYWwgUG9pbnQuXHJcblx0Ki9cclxuXHRwLmhpdFRlc3QgPSBmdW5jdGlvbih4LCB5KSB7XHJcblx0XHR2YXIgY3R4ID0gRGlzcGxheU9iamVjdC5faGl0VGVzdENvbnRleHQ7XHJcblx0XHRjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIC14LCAteSk7XHJcblx0XHR0aGlzLmRyYXcoY3R4KTtcclxuXHJcblx0XHR2YXIgaGl0ID0gdGhpcy5fdGVzdEhpdChjdHgpO1xyXG5cdFx0Y3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcclxuXHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgMiwgMik7XHJcblx0XHRyZXR1cm4gaGl0O1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogUHJvdmlkZXMgYSBjaGFpbmFibGUgc2hvcnRjdXQgbWV0aG9kIGZvciBzZXR0aW5nIGEgbnVtYmVyIG9mIHByb3BlcnRpZXMgb24gdGhlIGluc3RhbmNlLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICB2YXIgbXlHcmFwaGljcyA9IG5ldyBjcmVhdGVqcy5HcmFwaGljcygpLmJlZ2luRmlsbChcIiNmZjAwMDBcIikuZHJhd0NpcmNsZSgwLCAwLCAyNSk7XHJcblx0ICogICAgICB2YXIgc2hhcGUgPSBzdGFnZS5hZGRDaGlsZChuZXcgU2hhcGUoKSkuc2V0KHtncmFwaGljczpteUdyYXBoaWNzLCB4OjEwMCwgeToxMDAsIGFscGhhOjAuNX0pO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBzZXRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQSBnZW5lcmljIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gY29weSB0byB0aGUgRGlzcGxheU9iamVjdCBpbnN0YW5jZS5cclxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBSZXR1cm5zIHRoZSBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXHJcblx0ICogQGNoYWluYWJsZVxyXG5cdCovXHJcblx0cC5zZXQgPSBmdW5jdGlvbihwcm9wcykge1xyXG5cdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykgeyB0aGlzW25dID0gcHJvcHNbbl07IH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHJlY3RhbmdsZSByZXByZXNlbnRpbmcgdGhpcyBvYmplY3QncyBib3VuZHMgaW4gaXRzIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtIChpZS4gd2l0aCBubyB0cmFuc2Zvcm1hdGlvbikuXHJcblx0ICogT2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBjYWNoZWQgd2lsbCByZXR1cm4gdGhlIGJvdW5kcyBvZiB0aGUgY2FjaGUuXHJcblx0ICogXHJcblx0ICogTm90IGFsbCBkaXNwbGF5IG9iamVjdHMgY2FuIGNhbGN1bGF0ZSB0aGVpciBvd24gYm91bmRzIChleC4gU2hhcGUpLiBGb3IgdGhlc2Ugb2JqZWN0cywgeW91IGNhbiB1c2UgXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9zZXRCb3VuZHNcIn19e3svY3Jvc3NMaW5rfX0gc28gdGhhdCB0aGV5IGFyZSBpbmNsdWRlZCB3aGVuIGNhbGN1bGF0aW5nIENvbnRhaW5lclxyXG5cdCAqIGJvdW5kcy5cclxuXHQgKiBcclxuXHQgKiA8dGFibGU+XHJcblx0ICogXHQ8dHI+PHRkPjxiPkFsbDwvYj48L3RkPjx0ZD5cclxuXHQgKiBcdFx0QWxsIGRpc3BsYXkgb2JqZWN0cyBzdXBwb3J0IHNldHRpbmcgYm91bmRzIG1hbnVhbGx5IHVzaW5nIHNldEJvdW5kcygpLiBMaWtld2lzZSwgZGlzcGxheSBvYmplY3RzIHRoYXRcclxuXHQgKiBcdFx0aGF2ZSBiZWVuIGNhY2hlZCB1c2luZyBjYWNoZSgpIHdpbGwgcmV0dXJuIHRoZSBib3VuZHMgb2YgdGhlaXIgY2FjaGUuIE1hbnVhbCBhbmQgY2FjaGUgYm91bmRzIHdpbGwgb3ZlcnJpZGVcclxuXHQgKiBcdFx0dGhlIGF1dG9tYXRpYyBjYWxjdWxhdGlvbnMgbGlzdGVkIGJlbG93LlxyXG5cdCAqIFx0PC90ZD48L3RyPlxyXG5cdCAqIFx0PHRyPjx0ZD48Yj5CaXRtYXA8L2I+PC90ZD48dGQ+XHJcblx0ICogXHRcdFJldHVybnMgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHNvdXJjZVJlY3QgKGlmIHNwZWNpZmllZCkgb3IgaW1hZ2UsIGV4dGVuZGluZyBmcm9tICh4PTAseT0wKS5cclxuXHQgKiBcdDwvdGQ+PC90cj5cclxuXHQgKiBcdDx0cj48dGQ+PGI+U3ByaXRlPC9iPjwvdGQ+PHRkPlxyXG5cdCAqIFx0XHRSZXR1cm5zIHRoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnQgZnJhbWUuIE1heSBoYXZlIG5vbi16ZXJvIHgveSBpZiBhIGZyYW1lIHJlZ2lzdHJhdGlvbiBwb2ludCB3YXMgc3BlY2lmaWVkXHJcblx0ICogXHRcdGluIHRoZSBzcHJpdGVzaGVldCBkYXRhLiBTZWUgYWxzbyB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldC9nZXRGcmFtZUJvdW5kc1wifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIFx0PC90ZD48L3RyPlxyXG5cdCAqIFx0PHRyPjx0ZD48Yj5Db250YWluZXI8L2I+PC90ZD48dGQ+XHJcblx0ICogXHRcdFJldHVybnMgdGhlIGFnZ3JlZ2F0ZSAoY29tYmluZWQpIGJvdW5kcyBvZiBhbGwgY2hpbGRyZW4gdGhhdCByZXR1cm4gYSBub24tbnVsbCB2YWx1ZSBmcm9tIGdldEJvdW5kcygpLlxyXG5cdCAqIFx0PC90ZD48L3RyPlxyXG5cdCAqIFx0PHRyPjx0ZD48Yj5TaGFwZTwvYj48L3RkPjx0ZD5cclxuXHQgKiBcdFx0RG9lcyBub3QgY3VycmVudGx5IHN1cHBvcnQgYXV0b21hdGljIGJvdW5kcyBjYWxjdWxhdGlvbnMuIFVzZSBzZXRCb3VuZHMoKSB0byBtYW51YWxseSBkZWZpbmUgYm91bmRzLlxyXG5cdCAqIFx0PC90ZD48L3RyPlxyXG5cdCAqIFx0PHRyPjx0ZD48Yj5UZXh0PC9iPjwvdGQ+PHRkPlxyXG5cdCAqIFx0XHRSZXR1cm5zIGFwcHJveGltYXRlIGJvdW5kcy4gSG9yaXpvbnRhbCB2YWx1ZXMgKHgvd2lkdGgpIGFyZSBxdWl0ZSBhY2N1cmF0ZSwgYnV0IHZlcnRpY2FsIHZhbHVlcyAoeS9oZWlnaHQpIGFyZVxyXG5cdCAqIFx0XHRub3QsIGVzcGVjaWFsbHkgd2hlbiB1c2luZyB0ZXh0QmFzZWxpbmUgdmFsdWVzIG90aGVyIHRoYW4gXCJ0b3BcIi5cclxuXHQgKiBcdDwvdGQ+PC90cj5cclxuXHQgKiBcdDx0cj48dGQ+PGI+Qml0bWFwVGV4dDwvYj48L3RkPjx0ZD5cclxuXHQgKiBcdFx0UmV0dXJucyBhcHByb3hpbWF0ZSBib3VuZHMuIFZhbHVlcyB3aWxsIGJlIG1vcmUgYWNjdXJhdGUgaWYgc3ByaXRlc2hlZXQgZnJhbWUgcmVnaXN0cmF0aW9uIHBvaW50cyBhcmUgY2xvc2VcclxuXHQgKiBcdFx0dG8gKHg9MCx5PTApLlxyXG5cdCAqIFx0PC90ZD48L3RyPlxyXG5cdCogPC90YWJsZT5cclxuXHQgKiBcclxuXHQgKiBCb3VuZHMgY2FuIGJlIGV4cGVuc2l2ZSB0byBjYWxjdWxhdGUgZm9yIHNvbWUgb2JqZWN0cyAoZXguIHRleHQsIG9yIGNvbnRhaW5lcnMgd2l0aCBtYW55IGNoaWxkcmVuKSwgYW5kXHJcblx0ICogYXJlIHJlY2FsY3VsYXRlZCBlYWNoIHRpbWUgeW91IGNhbGwgZ2V0Qm91bmRzKCkuIFlvdSBjYW4gcHJldmVudCByZWNhbGN1bGF0aW9uIG9uIHN0YXRpYyBvYmplY3RzIGJ5IHNldHRpbmcgdGhlXHJcblx0ICogYm91bmRzIGV4cGxpY2l0bHk6XHJcblx0ICogXHJcblx0ICogXHR2YXIgYm91bmRzID0gb2JqLmdldEJvdW5kcygpO1xyXG5cdCAqIFx0b2JqLnNldEJvdW5kcyhib3VuZHMueCwgYm91bmRzLnksIGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCk7XHJcblx0ICogXHQvLyBnZXRCb3VuZHMgd2lsbCBub3cgdXNlIHRoZSBzZXQgdmFsdWVzLCBpbnN0ZWFkIG9mIHJlY2FsY3VsYXRpbmdcclxuXHQgKiBcclxuXHQgKiBUbyByZWR1Y2UgbWVtb3J5IGltcGFjdCwgdGhlIHJldHVybmVkIFJlY3RhbmdsZSBpbnN0YW5jZSBtYXkgYmUgcmV1c2VkIGludGVybmFsbHk7IGNsb25lIHRoZSBpbnN0YW5jZSBvciBjb3B5IGl0c1xyXG5cdCAqIHZhbHVlcyBpZiB5b3UgbmVlZCB0byByZXRhaW4gaXQuXHJcblx0ICogXHJcblx0ICogXHR2YXIgbXlCb3VuZHMgPSBvYmouZ2V0Qm91bmRzKCkuY2xvbmUoKTtcclxuXHQgKiBcdC8vIE9SOlxyXG5cdCAqIFx0bXlSZWN0LmNvcHkob2JqLmdldEJvdW5kcygpKTtcclxuXHQgKiBcclxuXHQgKiBAbWV0aG9kIGdldEJvdW5kc1xyXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gQSBSZWN0YW5nbGUgaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoZSBib3VuZHMsIG9yIG51bGwgaWYgYm91bmRzIGFyZSBub3QgYXZhaWxhYmxlIGZvciB0aGlzXHJcblx0ICogb2JqZWN0LlxyXG5cdCAqKi9cclxuXHRwLmdldEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYgKHRoaXMuX2JvdW5kcykgeyByZXR1cm4gdGhpcy5fcmVjdGFuZ2xlLmNvcHkodGhpcy5fYm91bmRzKTsgfVxyXG5cdFx0dmFyIGNhY2hlQ2FudmFzID0gdGhpcy5jYWNoZUNhbnZhcztcclxuXHRcdGlmIChjYWNoZUNhbnZhcykge1xyXG5cdFx0XHR2YXIgc2NhbGUgPSB0aGlzLl9jYWNoZVNjYWxlO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVjdGFuZ2xlLnNldFZhbHVlcyh0aGlzLl9jYWNoZU9mZnNldFgsIHRoaXMuX2NhY2hlT2Zmc2V0WSwgY2FjaGVDYW52YXMud2lkdGgvc2NhbGUsIGNhY2hlQ2FudmFzLmhlaWdodC9zY2FsZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSByZWN0YW5nbGUgcmVwcmVzZW50aW5nIHRoaXMgb2JqZWN0J3MgYm91bmRzIGluIGl0cyBwYXJlbnQncyBjb29yZGluYXRlIHN5c3RlbSAoaWUuIHdpdGggdHJhbnNmb3JtYXRpb25zIGFwcGxpZWQpLlxyXG5cdCAqIE9iamVjdHMgdGhhdCBoYXZlIGJlZW4gY2FjaGVkIHdpbGwgcmV0dXJuIHRoZSB0cmFuc2Zvcm1lZCBib3VuZHMgb2YgdGhlIGNhY2hlLlxyXG5cdCAqIFxyXG5cdCAqIE5vdCBhbGwgZGlzcGxheSBvYmplY3RzIGNhbiBjYWxjdWxhdGUgdGhlaXIgb3duIGJvdW5kcyAoZXguIFNoYXBlKS4gRm9yIHRoZXNlIG9iamVjdHMsIHlvdSBjYW4gdXNlIFxyXG5cdCAqIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3Qvc2V0Qm91bmRzXCJ9fXt7L2Nyb3NzTGlua319IHNvIHRoYXQgdGhleSBhcmUgaW5jbHVkZWQgd2hlbiBjYWxjdWxhdGluZyBDb250YWluZXJcclxuXHQgKiBib3VuZHMuXHJcblx0ICogXHJcblx0ICogVG8gcmVkdWNlIG1lbW9yeSBpbXBhY3QsIHRoZSByZXR1cm5lZCBSZWN0YW5nbGUgaW5zdGFuY2UgbWF5IGJlIHJldXNlZCBpbnRlcm5hbGx5OyBjbG9uZSB0aGUgaW5zdGFuY2Ugb3IgY29weSBpdHNcclxuXHQgKiB2YWx1ZXMgaWYgeW91IG5lZWQgdG8gcmV0YWluIGl0LlxyXG5cdCAqIFxyXG5cdCAqIENvbnRhaW5lciBpbnN0YW5jZXMgY2FsY3VsYXRlIGFnZ3JlZ2F0ZSBib3VuZHMgZm9yIGFsbCBjaGlsZHJlbiB0aGF0IHJldHVybiBib3VuZHMgdmlhIGdldEJvdW5kcy5cclxuXHQgKiBAbWV0aG9kIGdldFRyYW5zZm9ybWVkQm91bmRzXHJcblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBBIFJlY3RhbmdsZSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlIGJvdW5kcywgb3IgbnVsbCBpZiBib3VuZHMgYXJlIG5vdCBhdmFpbGFibGUgZm9yIHRoaXMgb2JqZWN0LlxyXG5cdCAqKi9cclxuXHRwLmdldFRyYW5zZm9ybWVkQm91bmRzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fZ2V0Qm91bmRzKCk7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBBbGxvd3MgeW91IHRvIG1hbnVhbGx5IHNwZWNpZnkgdGhlIGJvdW5kcyBvZiBhbiBvYmplY3QgdGhhdCBlaXRoZXIgY2Fubm90IGNhbGN1bGF0ZSB0aGVpciBvd24gYm91bmRzIChleC4gU2hhcGUgJlxyXG5cdCAqIFRleHQpIGZvciBmdXR1cmUgcmVmZXJlbmNlLCBvciBzbyB0aGUgb2JqZWN0IGNhbiBiZSBpbmNsdWRlZCBpbiBDb250YWluZXIgYm91bmRzLiBNYW51YWxseSBzZXQgYm91bmRzIHdpbGwgYWx3YXlzXHJcblx0ICogb3ZlcnJpZGUgY2FsY3VsYXRlZCBib3VuZHMuXHJcblx0ICogXHJcblx0ICogVGhlIGJvdW5kcyBzaG91bGQgYmUgc3BlY2lmaWVkIGluIHRoZSBvYmplY3QncyBsb2NhbCAodW50cmFuc2Zvcm1lZCkgY29vcmRpbmF0ZXMuIEZvciBleGFtcGxlLCBhIFNoYXBlIGluc3RhbmNlXHJcblx0ICogd2l0aCBhIDI1cHggcmFkaXVzIGNpcmNsZSBjZW50ZXJlZCBhdCAwLDAgd291bGQgaGF2ZSBib3VuZHMgb2YgKC0yNSwgLTI1LCA1MCwgNTApLlxyXG5cdCAqIEBtZXRob2Qgc2V0Qm91bmRzXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggb3JpZ2luIG9mIHRoZSBib3VuZHMuIFBhc3MgbnVsbCB0byByZW1vdmUgdGhlIG1hbnVhbCBib3VuZHMuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgb3JpZ2luIG9mIHRoZSBib3VuZHMuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgYm91bmRzLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgYm91bmRzLlxyXG5cdCAqKi9cclxuXHRwLnNldEJvdW5kcyA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuXHRcdGlmICh4ID09IG51bGwpIHsgdGhpcy5fYm91bmRzID0geDsgfVxyXG5cdFx0dGhpcy5fYm91bmRzID0gKHRoaXMuX2JvdW5kcyB8fCBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKCkpLnNldFZhbHVlcyh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBEaXNwbGF5T2JqZWN0LiBTb21lIHByb3BlcnRpZXMgdGhhdCBhcmUgc3BlY2lmaWMgdG8gdGhpcyBpbnN0YW5jZSdzIGN1cnJlbnQgY29udGV4dCBhcmVcclxuXHQgKiByZXZlcnRlZCB0byB0aGVpciBkZWZhdWx0cyAoZm9yIGV4YW1wbGUgLnBhcmVudCkuIENhY2hlcyBhcmUgbm90IG1haW50YWluZWQgYWNyb3NzIGNsb25lcywgYW5kIHNvbWUgZWxlbWVudHNcclxuXHQgKiBhcmUgY29waWVkIGJ5IHJlZmVyZW5jZSAobWFza3MsIGluZGl2aWR1YWwgZmlsdGVyIGluc3RhbmNlcywgaGl0IGFyZWEpXHJcblx0ICogQG1ldGhvZCBjbG9uZVxyXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IEEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgRGlzcGxheU9iamVjdCBpbnN0YW5jZS5cclxuXHQgKiovXHJcblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lUHJvcHMobmV3IERpc3BsYXlPYmplY3QoKSk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cclxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXHJcblx0ICoqL1xyXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBcIltEaXNwbGF5T2JqZWN0IChuYW1lPVwiKyAgdGhpcy5uYW1lICtcIildXCI7XHJcblx0fTtcclxuXHJcblxyXG4vLyBwcml2YXRlIG1ldGhvZHM6XHJcblx0Ly8gc2VwYXJhdGVkIHNvIGl0IGNhbiBiZSB1c2VkIG1vcmUgZWFzaWx5IGluIHN1YmNsYXNzZXM6XHJcblx0LyoqXHJcblx0ICogQG1ldGhvZCBfY2xvbmVQcm9wc1xyXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gbyBUaGUgRGlzcGxheU9iamVjdCBpbnN0YW5jZSB3aGljaCB3aWxsIGhhdmUgcHJvcGVydGllcyBmcm9tIHRoZSBjdXJyZW50IERpc3BsYXlPYmplY3RcclxuXHQgKiBpbnN0YW5jZSBjb3BpZWQgaW50by5cclxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBvXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqKi9cclxuXHRwLl9jbG9uZVByb3BzID0gZnVuY3Rpb24obykge1xyXG5cdFx0by5hbHBoYSA9IHRoaXMuYWxwaGE7XHJcblx0XHRvLm1vdXNlRW5hYmxlZCA9IHRoaXMubW91c2VFbmFibGVkO1xyXG5cdFx0by50aWNrRW5hYmxlZCA9IHRoaXMudGlja0VuYWJsZWQ7XHJcblx0XHRvLm5hbWUgPSB0aGlzLm5hbWU7XHJcblx0XHRvLnJlZ1ggPSB0aGlzLnJlZ1g7XHJcblx0XHRvLnJlZ1kgPSB0aGlzLnJlZ1k7XHJcblx0XHRvLnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcclxuXHRcdG8uc2NhbGVYID0gdGhpcy5zY2FsZVg7XHJcblx0XHRvLnNjYWxlWSA9IHRoaXMuc2NhbGVZO1xyXG5cdFx0by5zaGFkb3cgPSB0aGlzLnNoYWRvdztcclxuXHRcdG8uc2tld1ggPSB0aGlzLnNrZXdYO1xyXG5cdFx0by5za2V3WSA9IHRoaXMuc2tld1k7XHJcblx0XHRvLnZpc2libGUgPSB0aGlzLnZpc2libGU7XHJcblx0XHRvLnggID0gdGhpcy54O1xyXG5cdFx0by55ID0gdGhpcy55O1xyXG5cdFx0by5jb21wb3NpdGVPcGVyYXRpb24gPSB0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbjtcclxuXHRcdG8uc25hcFRvUGl4ZWwgPSB0aGlzLnNuYXBUb1BpeGVsO1xyXG5cdFx0by5maWx0ZXJzID0gdGhpcy5maWx0ZXJzPT1udWxsP251bGw6dGhpcy5maWx0ZXJzLnNsaWNlKDApO1xyXG5cdFx0by5tYXNrID0gdGhpcy5tYXNrO1xyXG5cdFx0by5oaXRBcmVhID0gdGhpcy5oaXRBcmVhO1xyXG5cdFx0by5jdXJzb3IgPSB0aGlzLmN1cnNvcjtcclxuXHRcdG8uX2JvdW5kcyA9IHRoaXMuX2JvdW5kcztcclxuXHRcdHJldHVybiBvO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBtZXRob2QgX2FwcGx5U2hhZG93XHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcclxuXHQgKiBAcGFyYW0ge1NoYWRvd30gc2hhZG93XHJcblx0ICoqL1xyXG5cdHAuX2FwcGx5U2hhZG93ID0gZnVuY3Rpb24oY3R4LCBzaGFkb3cpIHtcclxuXHRcdHNoYWRvdyA9IHNoYWRvdyB8fCBTaGFkb3cuaWRlbnRpdHk7XHJcblx0XHRjdHguc2hhZG93Q29sb3IgPSBzaGFkb3cuY29sb3I7XHJcblx0XHRjdHguc2hhZG93T2Zmc2V0WCA9IHNoYWRvdy5vZmZzZXRYO1xyXG5cdFx0Y3R4LnNoYWRvd09mZnNldFkgPSBzaGFkb3cub2Zmc2V0WTtcclxuXHRcdGN0eC5zaGFkb3dCbHVyID0gc2hhZG93LmJsdXI7XHJcblx0fTtcclxuXHRcclxuXHRcclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIF90aWNrXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2dE9iaiBBbiBldmVudCBvYmplY3QgdGhhdCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gYWxsIHRpY2sgbGlzdGVuZXJzLiBUaGlzIG9iamVjdCBpcyByZXVzZWQgYmV0d2VlbiBkaXNwYXRjaGVycyB0byByZWR1Y2UgY29uc3RydWN0aW9uICYgR0MgY29zdHMuXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqKi9cclxuXHRwLl90aWNrID0gZnVuY3Rpb24oZXZ0T2JqKSB7XHJcblx0XHQvLyBiZWNhdXNlIHRpY2sgY2FuIGJlIHJlYWxseSBwZXJmb3JtYW5jZSBzZW5zaXRpdmUsIGNoZWNrIGZvciBsaXN0ZW5lcnMgYmVmb3JlIGNhbGxpbmcgZGlzcGF0Y2hFdmVudC5cclxuXHRcdHZhciBscyA9IHRoaXMuX2xpc3RlbmVycztcclxuXHRcdGlmIChscyAmJiBsc1tcInRpY2tcIl0pIHtcclxuXHRcdFx0Ly8gcmVzZXQgJiByZXVzZSB0aGUgZXZlbnQgb2JqZWN0IHRvIGF2b2lkIGNvbnN0cnVjdGlvbiAvIEdDIGNvc3RzOlxyXG5cdFx0XHRldnRPYmoudGFyZ2V0ID0gbnVsbDtcclxuXHRcdFx0ZXZ0T2JqLnByb3BhZ2F0aW9uU3RvcHBlZCA9IGV2dE9iai5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2dE9iaik7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQG1ldGhvZCBfdGVzdEhpdFxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cclxuXHQgKiovXHJcblx0cC5fdGVzdEhpdCA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0dmFyIGhpdCA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YVszXSA+IDE7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdGlmICghRGlzcGxheU9iamVjdC5zdXBwcmVzc0Nyb3NzRG9tYWluRXJyb3JzKSB7XHJcblx0XHRcdFx0dGhyb3cgXCJBbiBlcnJvciBoYXMgb2NjdXJyZWQuIFRoaXMgaXMgbW9zdCBsaWtlbHkgZHVlIHRvIHNlY3VyaXR5IHJlc3RyaWN0aW9ucyBvbiByZWFkaW5nIGNhbnZhcyBwaXhlbCBkYXRhIHdpdGggbG9jYWwgb3IgY3Jvc3MtZG9tYWluIGltYWdlcy5cIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGhpdDtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIF9hcHBseUZpbHRlcnNcclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICoqL1xyXG5cdHAuX2FwcGx5RmlsdGVycyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYgKCF0aGlzLmZpbHRlcnMgfHwgdGhpcy5maWx0ZXJzLmxlbmd0aCA9PSAwIHx8ICF0aGlzLmNhY2hlQ2FudmFzKSB7IHJldHVybjsgfVxyXG5cdFx0dmFyIGwgPSB0aGlzLmZpbHRlcnMubGVuZ3RoO1xyXG5cdFx0dmFyIGN0eCA9IHRoaXMuY2FjaGVDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cdFx0dmFyIHcgPSB0aGlzLmNhY2hlQ2FudmFzLndpZHRoO1xyXG5cdFx0dmFyIGggPSB0aGlzLmNhY2hlQ2FudmFzLmhlaWdodDtcclxuXHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKyspIHtcclxuXHRcdFx0dGhpcy5maWx0ZXJzW2ldLmFwcGx5RmlsdGVyKGN0eCwgMCwgMCwgdywgaCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIF9nZXRGaWx0ZXJCb3VuZHNcclxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9XHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqKi9cclxuXHRwLl9nZXRGaWx0ZXJCb3VuZHMgPSBmdW5jdGlvbihyZWN0KSB7XHJcblx0XHR2YXIgbCwgZmlsdGVycyA9IHRoaXMuZmlsdGVycywgYm91bmRzID0gdGhpcy5fcmVjdGFuZ2xlLnNldFZhbHVlcygwLDAsMCwwKTtcclxuXHRcdGlmICghZmlsdGVycyB8fCAhKGw9ZmlsdGVycy5sZW5ndGgpKSB7IHJldHVybiBib3VuZHM7IH1cclxuXHRcdFxyXG5cdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykge1xyXG5cdFx0XHR2YXIgZiA9IHRoaXMuZmlsdGVyc1tpXTtcclxuXHRcdFx0Zi5nZXRCb3VuZHMmJmYuZ2V0Qm91bmRzKGJvdW5kcyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogQG1ldGhvZCBfZ2V0Qm91bmRzXHJcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4XHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVUcmFuc2Zvcm0gSWYgdHJ1ZSwgZG9lcyBub3QgYXBwbHkgdGhpcyBvYmplY3QncyB0cmFuc2Zvcm0uXHJcblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfVxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiovXHJcblx0cC5fZ2V0Qm91bmRzID0gZnVuY3Rpb24obWF0cml4LCBpZ25vcmVUcmFuc2Zvcm0pe1xyXG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybUJvdW5kcyh0aGlzLmdldEJvdW5kcygpLCBtYXRyaXgsIGlnbm9yZVRyYW5zZm9ybSk7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIF90cmFuc2Zvcm1Cb3VuZHNcclxuXHQgKiBAcGFyYW0ge1JlY3RhbmdsZX0gYm91bmRzXHJcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4XHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVUcmFuc2Zvcm1cclxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9XHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqKi9cclxuXHRwLl90cmFuc2Zvcm1Cb3VuZHMgPSBmdW5jdGlvbihib3VuZHMsIG1hdHJpeCwgaWdub3JlVHJhbnNmb3JtKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gYm91bmRzOyB9XHJcblx0XHR2YXIgeCA9IGJvdW5kcy54LCB5ID0gYm91bmRzLnksIHdpZHRoID0gYm91bmRzLndpZHRoLCBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0LCBtdHggPSB0aGlzLl9wcm9wcy5tYXRyaXg7XHJcblx0XHRtdHggPSBpZ25vcmVUcmFuc2Zvcm0gPyBtdHguaWRlbnRpdHkoKSA6IHRoaXMuZ2V0TWF0cml4KG10eCk7XHJcblx0XHRcclxuXHRcdGlmICh4IHx8IHkpIHsgbXR4LmFwcGVuZFRyYW5zZm9ybSgwLDAsMSwxLDAsMCwwLC14LC15KTsgfSAvLyBUT0RPOiBzaW1wbGlmeSB0aGlzLlxyXG5cdFx0aWYgKG1hdHJpeCkgeyBtdHgucHJlcGVuZE1hdHJpeChtYXRyaXgpOyB9XHJcblx0XHRcclxuXHRcdHZhciB4X2EgPSB3aWR0aCptdHguYSwgeF9iID0gd2lkdGgqbXR4LmI7XHJcblx0XHR2YXIgeV9jID0gaGVpZ2h0Km10eC5jLCB5X2QgPSBoZWlnaHQqbXR4LmQ7XHJcblx0XHR2YXIgdHggPSBtdHgudHgsIHR5ID0gbXR4LnR5O1xyXG5cdFx0XHJcblx0XHR2YXIgbWluWCA9IHR4LCBtYXhYID0gdHgsIG1pblkgPSB0eSwgbWF4WSA9IHR5O1xyXG5cclxuXHRcdGlmICgoeCA9IHhfYSArIHR4KSA8IG1pblgpIHsgbWluWCA9IHg7IH0gZWxzZSBpZiAoeCA+IG1heFgpIHsgbWF4WCA9IHg7IH1cclxuXHRcdGlmICgoeCA9IHhfYSArIHlfYyArIHR4KSA8IG1pblgpIHsgbWluWCA9IHg7IH0gZWxzZSBpZiAoeCA+IG1heFgpIHsgbWF4WCA9IHg7IH1cclxuXHRcdGlmICgoeCA9IHlfYyArIHR4KSA8IG1pblgpIHsgbWluWCA9IHg7IH0gZWxzZSBpZiAoeCA+IG1heFgpIHsgbWF4WCA9IHg7IH1cclxuXHRcdFxyXG5cdFx0aWYgKCh5ID0geF9iICsgdHkpIDwgbWluWSkgeyBtaW5ZID0geTsgfSBlbHNlIGlmICh5ID4gbWF4WSkgeyBtYXhZID0geTsgfVxyXG5cdFx0aWYgKCh5ID0geF9iICsgeV9kICsgdHkpIDwgbWluWSkgeyBtaW5ZID0geTsgfSBlbHNlIGlmICh5ID4gbWF4WSkgeyBtYXhZID0geTsgfVxyXG5cdFx0aWYgKCh5ID0geV9kICsgdHkpIDwgbWluWSkgeyBtaW5ZID0geTsgfSBlbHNlIGlmICh5ID4gbWF4WSkgeyBtYXhZID0geTsgfVxyXG5cdFx0XHJcblx0XHRyZXR1cm4gYm91bmRzLnNldFZhbHVlcyhtaW5YLCBtaW5ZLCBtYXhYLW1pblgsIG1heFktbWluWSk7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3QgaGFzIGFueSBtb3VzZSBldmVudCBsaXN0ZW5lcnMgb3IgYSBjdXJzb3IuXHJcblx0ICogQG1ldGhvZCBfaXNNb3VzZU9wYXF1ZVxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqKi9cclxuXHRwLl9oYXNNb3VzZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBldnRzID0gRGlzcGxheU9iamVjdC5fTU9VU0VfRVZFTlRTO1xyXG5cdFx0Zm9yICh2YXIgaT0gMCwgbD1ldnRzLmxlbmd0aDsgaTxsOyBpKyspIHtcclxuXHRcdFx0aWYgKHRoaXMuaGFzRXZlbnRMaXN0ZW5lcihldnRzW2ldKSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuICEhdGhpcy5jdXJzb3I7XHJcblx0fTtcclxuXHJcblx0Y3JlYXRlanMuRGlzcGxheU9iamVjdCA9IGNyZWF0ZWpzLnByb21vdGUoRGlzcGxheU9iamVjdCwgXCJFdmVudERpc3BhdGNoZXJcIik7XHJcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBDb250YWluZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRcclxuXHJcbi8vIGNvbnN0cnVjdG9yOlxyXG4vKipcclxuICogQSBDb250YWluZXIgaXMgYSBuZXN0YWJsZSBkaXNwbGF5IGxpc3QgdGhhdCBhbGxvd3MgeW91IHRvIHdvcmsgd2l0aCBjb21wb3VuZCBkaXNwbGF5IGVsZW1lbnRzLiBGb3IgIGV4YW1wbGUgeW91IGNvdWxkXHJcbiAqIGdyb3VwIGFybSwgbGVnLCB0b3JzbyBhbmQgaGVhZCB7eyNjcm9zc0xpbmsgXCJCaXRtYXBcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2VzIHRvZ2V0aGVyIGludG8gYSBQZXJzb24gQ29udGFpbmVyLCBhbmRcclxuICogdHJhbnNmb3JtIHRoZW0gYXMgYSBncm91cCwgd2hpbGUgc3RpbGwgYmVpbmcgYWJsZSB0byBtb3ZlIHRoZSBpbmRpdmlkdWFsIHBhcnRzIHJlbGF0aXZlIHRvIGVhY2ggb3RoZXIuIENoaWxkcmVuIG9mXHJcbiAqIGNvbnRhaW5lcnMgaGF2ZSB0aGVpciA8Y29kZT50cmFuc2Zvcm08L2NvZGU+IGFuZCA8Y29kZT5hbHBoYTwvY29kZT4gcHJvcGVydGllcyBjb25jYXRlbmF0ZWQgd2l0aCB0aGVpciBwYXJlbnRcclxuICogQ29udGFpbmVyLlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZSwgYSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSB3aXRoIHg9MTAwIGFuZCBhbHBoYT0wLjUsIHBsYWNlZCBpbiBhIENvbnRhaW5lciB3aXRoIDxjb2RlPng9NTA8L2NvZGU+XHJcbiAqIGFuZCA8Y29kZT5hbHBoYT0wLjc8L2NvZGU+IHdpbGwgYmUgcmVuZGVyZWQgdG8gdGhlIGNhbnZhcyBhdCA8Y29kZT54PTE1MDwvY29kZT4gYW5kIDxjb2RlPmFscGhhPTAuMzU8L2NvZGU+LlxyXG4gKiBDb250YWluZXJzIGhhdmUgc29tZSBvdmVyaGVhZCwgc28geW91IGdlbmVyYWxseSBzaG91bGRuJ3QgY3JlYXRlIGEgQ29udGFpbmVyIHRvIGhvbGQgYSBzaW5nbGUgY2hpbGQuXHJcbiAqXHJcbiAqIDxoND5FeGFtcGxlPC9oND5cclxuICpcclxuICogICAgICB2YXIgY29udGFpbmVyID0gbmV3IGNyZWF0ZWpzLkNvbnRhaW5lcigpO1xyXG4gKiAgICAgIGNvbnRhaW5lci5hZGRDaGlsZChiaXRtYXBJbnN0YW5jZSwgc2hhcGVJbnN0YW5jZSk7XHJcbiAqICAgICAgY29udGFpbmVyLnggPSAxMDA7XHJcbiAqXHJcbiAqIEBjbGFzcyBDb250YWluZXJcclxuICogQGV4dGVuZHMgRGlzcGxheU9iamVjdFxyXG4gKiBAY29uc3RydWN0b3JcclxuICoqL1xyXG5cdGZ1bmN0aW9uIENvbnRhaW5lcigpIHtcclxuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9jb25zdHJ1Y3RvcigpO1xyXG5cdFx0XHJcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBhcnJheSBvZiBjaGlsZHJlbiBpbiB0aGUgZGlzcGxheSBsaXN0LiBZb3Ugc2hvdWxkIHVzdWFsbHkgdXNlIHRoZSBjaGlsZCBtYW5hZ2VtZW50IG1ldGhvZHMgc3VjaCBhc1xyXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyL2FkZENoaWxkXCJ9fXt7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvcmVtb3ZlQ2hpbGRcIn19e3svY3Jvc3NMaW5rfX0sXHJcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvc3dhcENoaWxkcmVuXCJ9fXt7L2Nyb3NzTGlua319LCBldGMsIHJhdGhlciB0aGFuIGFjY2Vzc2luZyB0aGlzIGRpcmVjdGx5LCBidXQgaXQgaXNcclxuXHRcdCAqIGluY2x1ZGVkIGZvciBhZHZhbmNlZCB1c2VzLlxyXG5cdFx0ICogQHByb3BlcnR5IGNoaWxkcmVuXHJcblx0XHQgKiBAdHlwZSBBcnJheVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjaGlsZHJlbiBvZiB0aGlzIGNvbnRhaW5lciBhcmUgaW5kZXBlbmRlbnRseSBlbmFibGVkIGZvciBtb3VzZS9wb2ludGVyIGludGVyYWN0aW9uLlxyXG5cdFx0ICogSWYgZmFsc2UsIHRoZSBjaGlsZHJlbiB3aWxsIGJlIGFnZ3JlZ2F0ZWQgdW5kZXIgdGhlIGNvbnRhaW5lciAtIGZvciBleGFtcGxlLCBhIGNsaWNrIG9uIGEgY2hpbGQgc2hhcGUgd291bGRcclxuXHRcdCAqIHRyaWdnZXIgYSBjbGljayBldmVudCBvbiB0aGUgY29udGFpbmVyLlxyXG5cdFx0ICogQHByb3BlcnR5IG1vdXNlQ2hpbGRyZW5cclxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMubW91c2VDaGlsZHJlbiA9IHRydWU7XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogSWYgZmFsc2UsIHRoZSB0aWNrIHdpbGwgbm90IGJlIHByb3BhZ2F0ZWQgdG8gY2hpbGRyZW4gb2YgdGhpcyBDb250YWluZXIuIFRoaXMgY2FuIHByb3ZpZGUgc29tZSBwZXJmb3JtYW5jZSBiZW5lZml0cy5cclxuXHRcdCAqIEluIGFkZGl0aW9uIHRvIHByZXZlbnRpbmcgdGhlIFwidGlja1wiIGV2ZW50IGZyb20gYmVpbmcgZGlzcGF0Y2hlZCwgaXQgd2lsbCBhbHNvIHByZXZlbnQgdGljayByZWxhdGVkIHVwZGF0ZXNcclxuXHRcdCAqIG9uIHNvbWUgZGlzcGxheSBvYmplY3RzIChleC4gU3ByaXRlICYgTW92aWVDbGlwIGZyYW1lIGFkdmFuY2luZywgRE9NRWxlbWVudCB2aXNpYmlsaXR5IGhhbmRsaW5nKS5cclxuXHRcdCAqIEBwcm9wZXJ0eSB0aWNrQ2hpbGRyZW5cclxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMudGlja0NoaWxkcmVuID0gdHJ1ZTtcclxuXHR9XHJcblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQ29udGFpbmVyLCBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0KTtcclxuXHRcclxuXHRcclxuLy8gZ2V0dGVyIC8gc2V0dGVyczpcclxuXHQvKipcclxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lci9udW1DaGlsZHJlbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxyXG5cdCAqIEBtZXRob2QgZ2V0TnVtQ2hpbGRyZW5cclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcblx0ICogQGRlcHJlY2F0ZWRcclxuXHQgKiovXHJcblx0cC5nZXROdW1DaGlsZHJlbiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGUgY29udGFpbmVyLlxyXG5cdCAqIEBwcm9wZXJ0eSBudW1DaGlsZHJlblxyXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0ICogQHJlYWRvbmx5XHJcblx0ICoqL1xyXG5cdHRyeSB7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XHJcblx0XHRcdG51bUNoaWxkcmVuOiB7IGdldDogcC5nZXROdW1DaGlsZHJlbiB9XHJcblx0XHR9KTtcclxuXHR9IGNhdGNoIChlKSB7fVxyXG5cdFxyXG5cclxuLy8gcHVibGljIG1ldGhvZHM6XHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0b3IgYWxpYXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBUaGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zLlxyXG5cdCAqIFN1YmNsYXNzZXMgc2hvdWxkIGJlIHVwZGF0ZWQgdG8gdXNlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRzXCJ9fXt7L2Nyb3NzTGlua319LlxyXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxyXG5cdCAqIEBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBgY3JlYXRlanMucHJvbW90ZSgpYFxyXG5cdCAqKi9cclxuXHRwLmluaXRpYWxpemUgPSBDb250YWluZXI7IC8vIFRPRE86IGRlcHJlY2F0ZWQuXHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhcy5cclxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxyXG5cdCAqXHJcblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxyXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcclxuXHQgKiovXHJcblx0cC5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBoYXNDb250ZW50ID0gdGhpcy5jYWNoZUNhbnZhcyB8fCB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcclxuXHRcdHJldHVybiAhISh0aGlzLnZpc2libGUgJiYgdGhpcy5hbHBoYSA+IDAgJiYgdGhpcy5zY2FsZVggIT0gMCAmJiB0aGlzLnNjYWxlWSAhPSAwICYmIGhhc0NvbnRlbnQpO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cclxuXHQgKlxyXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cclxuXHQgKiBAbWV0aG9kIGRyYXdcclxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZUNhY2hlPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZHJhdyBvcGVyYXRpb24gc2hvdWxkIGlnbm9yZSBhbnkgY3VycmVudCBjYWNoZS5cclxuXHQgKiBGb3IgZXhhbXBsZSwgdXNlZCBmb3IgZHJhd2luZyB0aGUgY2FjaGUgKHRvIHByZXZlbnQgaXQgZnJvbSBzaW1wbHkgZHJhd2luZyBhbiBleGlzdGluZyBjYWNoZSBiYWNrXHJcblx0ICogaW50byBpdHNlbGYpLlxyXG5cdCAqKi9cclxuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGlnbm9yZUNhY2hlKSB7XHJcblx0XHRpZiAodGhpcy5EaXNwbGF5T2JqZWN0X2RyYXcoY3R4LCBpZ25vcmVDYWNoZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFxyXG5cdFx0Ly8gdGhpcyBlbnN1cmVzIHdlIGRvbid0IGhhdmUgaXNzdWVzIHdpdGggZGlzcGxheSBsaXN0IGNoYW5nZXMgdGhhdCBvY2N1ciBkdXJpbmcgYSBkcmF3OlxyXG5cdFx0dmFyIGxpc3QgPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XHJcblx0XHRmb3IgKHZhciBpPTAsbD1saXN0Lmxlbmd0aDsgaTxsOyBpKyspIHtcclxuXHRcdFx0dmFyIGNoaWxkID0gbGlzdFtpXTtcclxuXHRcdFx0aWYgKCFjaGlsZC5pc1Zpc2libGUoKSkgeyBjb250aW51ZTsgfVxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gZHJhdyB0aGUgY2hpbGQ6XHJcblx0XHRcdGN0eC5zYXZlKCk7XHJcblx0XHRcdGNoaWxkLnVwZGF0ZUNvbnRleHQoY3R4KTtcclxuXHRcdFx0Y2hpbGQuZHJhdyhjdHgpO1xyXG5cdFx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBBZGRzIGEgY2hpbGQgdG8gdGhlIHRvcCBvZiB0aGUgZGlzcGxheSBsaXN0LlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogXHRcdGNvbnRhaW5lci5hZGRDaGlsZChiaXRtYXBJbnN0YW5jZSk7XHJcblx0ICpcclxuXHQgKiBZb3UgY2FuIGFsc28gYWRkIG11bHRpcGxlIGNoaWxkcmVuIGF0IG9uY2U6XHJcblx0ICpcclxuXHQgKiBcdFx0Y29udGFpbmVyLmFkZENoaWxkKGJpdG1hcEluc3RhbmNlLCBzaGFwZUluc3RhbmNlLCB0ZXh0SW5zdGFuY2UpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBhZGRDaGlsZFxyXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gY2hpbGQgVGhlIGRpc3BsYXkgb2JqZWN0IHRvIGFkZC5cclxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgdGhhdCB3YXMgYWRkZWQsIG9yIHRoZSBsYXN0IGNoaWxkIGlmIG11bHRpcGxlIGNoaWxkcmVuIHdlcmUgYWRkZWQuXHJcblx0ICoqL1xyXG5cdHAuYWRkQ2hpbGQgPSBmdW5jdGlvbihjaGlsZCkge1xyXG5cdFx0aWYgKGNoaWxkID09IG51bGwpIHsgcmV0dXJuIGNoaWxkOyB9XHJcblx0XHR2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcblx0XHRpZiAobCA+IDEpIHtcclxuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykgeyB0aGlzLmFkZENoaWxkKGFyZ3VtZW50c1tpXSk7IH1cclxuXHRcdFx0cmV0dXJuIGFyZ3VtZW50c1tsLTFdO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNoaWxkLnBhcmVudCkgeyBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpOyB9XHJcblx0XHRjaGlsZC5wYXJlbnQgPSB0aGlzO1xyXG5cdFx0dGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuXHRcdGNoaWxkLmRpc3BhdGNoRXZlbnQoXCJhZGRlZFwiKTtcclxuXHRcdHJldHVybiBjaGlsZDtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBBZGRzIGEgY2hpbGQgdG8gdGhlIGRpc3BsYXkgbGlzdCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LCBidW1waW5nIGNoaWxkcmVuIGF0IGVxdWFsIG9yIGdyZWF0ZXIgaW5kZXhlcyB1cCBvbmUsIGFuZFxyXG5cdCAqIHNldHRpbmcgaXRzIHBhcmVudCB0byB0aGlzIENvbnRhaW5lci5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgYWRkQ2hpbGRBdChjaGlsZDEsIGluZGV4KTtcclxuXHQgKlxyXG5cdCAqIFlvdSBjYW4gYWxzbyBhZGQgbXVsdGlwbGUgY2hpbGRyZW4sIHN1Y2ggYXM6XHJcblx0ICpcclxuXHQgKiAgICAgIGFkZENoaWxkQXQoY2hpbGQxLCBjaGlsZDIsIC4uLiwgaW5kZXgpO1xyXG5cdCAqXHJcblx0ICogVGhlIGluZGV4IG11c3QgYmUgYmV0d2VlbiAwIGFuZCBudW1DaGlsZHJlbi4gRm9yIGV4YW1wbGUsIHRvIGFkZCBteVNoYXBlIHVuZGVyIG90aGVyU2hhcGUgaW4gdGhlIGRpc3BsYXkgbGlzdCxcclxuXHQgKiB5b3UgY291bGQgdXNlOlxyXG5cdCAqXHJcblx0ICogICAgICBjb250YWluZXIuYWRkQ2hpbGRBdChteVNoYXBlLCBjb250YWluZXIuZ2V0Q2hpbGRJbmRleChvdGhlclNoYXBlKSk7XHJcblx0ICpcclxuXHQgKiBUaGlzIHdvdWxkIGFsc28gYnVtcCBvdGhlclNoYXBlJ3MgaW5kZXggdXAgYnkgb25lLiBGYWlscyBzaWxlbnRseSBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBhZGRDaGlsZEF0XHJcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBjaGlsZCBUaGUgZGlzcGxheSBvYmplY3QgdG8gYWRkLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gYWRkIHRoZSBjaGlsZCBhdC5cclxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBSZXR1cm5zIHRoZSBsYXN0IGNoaWxkIHRoYXQgd2FzIGFkZGVkLCBvciB0aGUgbGFzdCBjaGlsZCBpZiBtdWx0aXBsZSBjaGlsZHJlbiB3ZXJlIGFkZGVkLlxyXG5cdCAqKi9cclxuXHRwLmFkZENoaWxkQXQgPSBmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcclxuXHRcdHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcclxuXHRcdHZhciBpbmR4ID0gYXJndW1lbnRzW2wtMV07IC8vIGNhbid0IHVzZSB0aGUgc2FtZSBuYW1lIGFzIHRoZSBpbmRleCBwYXJhbSBvciBpdCByZXBsYWNlcyBhcmd1bWVudHNbMV1cclxuXHRcdGlmIChpbmR4IDwgMCB8fCBpbmR4ID4gdGhpcy5jaGlsZHJlbi5sZW5ndGgpIHsgcmV0dXJuIGFyZ3VtZW50c1tsLTJdOyB9XHJcblx0XHRpZiAobCA+IDIpIHtcclxuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGwtMTsgaSsrKSB7IHRoaXMuYWRkQ2hpbGRBdChhcmd1bWVudHNbaV0sIGluZHgraSk7IH1cclxuXHRcdFx0cmV0dXJuIGFyZ3VtZW50c1tsLTJdO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNoaWxkLnBhcmVudCkgeyBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpOyB9XHJcblx0XHRjaGlsZC5wYXJlbnQgPSB0aGlzO1xyXG5cdFx0dGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcclxuXHRcdGNoaWxkLmRpc3BhdGNoRXZlbnQoXCJhZGRlZFwiKTtcclxuXHRcdHJldHVybiBjaGlsZDtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgY2hpbGQgZnJvbSB0aGUgZGlzcGxheSBsaXN0LiBOb3RlIHRoYXQgaXQgaXMgZmFzdGVyIHRvIHVzZSByZW1vdmVDaGlsZEF0KCkgaWYgdGhlIGluZGV4IGlzXHJcblx0ICogYWxyZWFkeSBrbm93bi5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcclxuXHQgKlxyXG5cdCAqIFlvdSBjYW4gYWxzbyByZW1vdmUgbXVsdGlwbGUgY2hpbGRyZW46XHJcblx0ICpcclxuXHQgKiAgICAgIHJlbW92ZUNoaWxkKGNoaWxkMSwgY2hpbGQyLCAuLi4pO1xyXG5cdCAqXHJcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBjaGlsZCAob3IgY2hpbGRyZW4pIHdhcyByZW1vdmVkLCBvciBmYWxzZSBpZiBpdCB3YXMgbm90IGluIHRoZSBkaXNwbGF5IGxpc3QuXHJcblx0ICogQG1ldGhvZCByZW1vdmVDaGlsZFxyXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gY2hpbGQgVGhlIGNoaWxkIHRvIHJlbW92ZS5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBjaGlsZCAob3IgY2hpbGRyZW4pIHdhcyByZW1vdmVkLCBvciBmYWxzZSBpZiBpdCB3YXMgbm90IGluIHRoZSBkaXNwbGF5IGxpc3QuXHJcblx0ICoqL1xyXG5cdHAucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbihjaGlsZCkge1xyXG5cdFx0dmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xyXG5cdFx0aWYgKGwgPiAxKSB7XHJcblx0XHRcdHZhciBnb29kID0gdHJ1ZTtcclxuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykgeyBnb29kID0gZ29vZCAmJiB0aGlzLnJlbW92ZUNoaWxkKGFyZ3VtZW50c1tpXSk7IH1cclxuXHRcdFx0cmV0dXJuIGdvb2Q7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVDaGlsZEF0KGNyZWF0ZWpzLmluZGV4T2YodGhpcy5jaGlsZHJlbiwgY2hpbGQpKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIHRoZSBjaGlsZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IGZyb20gdGhlIGRpc3BsYXkgbGlzdCwgYW5kIHNldHMgaXRzIHBhcmVudCB0byBudWxsLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGRBdCgyKTtcclxuXHQgKlxyXG5cdCAqIFlvdSBjYW4gYWxzbyByZW1vdmUgbXVsdGlwbGUgY2hpbGRyZW46XHJcblx0ICpcclxuXHQgKiAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZCgyLCA3LCAuLi4pXHJcblx0ICpcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNoaWxkIChvciBjaGlsZHJlbikgd2FzIHJlbW92ZWQsIG9yIGZhbHNlIGlmIGFueSBpbmRleCB3YXMgb3V0IG9mIHJhbmdlLlxyXG5cdCAqIEBtZXRob2QgcmVtb3ZlQ2hpbGRBdFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGNoaWxkIHRvIHJlbW92ZS5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBjaGlsZCAob3IgY2hpbGRyZW4pIHdhcyByZW1vdmVkLCBvciBmYWxzZSBpZiBhbnkgaW5kZXggd2FzIG91dCBvZiByYW5nZS5cclxuXHQgKiovXHJcblx0cC5yZW1vdmVDaGlsZEF0ID0gZnVuY3Rpb24oaW5kZXgpIHtcclxuXHRcdHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcclxuXHRcdGlmIChsID4gMSkge1xyXG5cdFx0XHR2YXIgYSA9IFtdO1xyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7IGFbaV0gPSBhcmd1bWVudHNbaV07IH1cclxuXHRcdFx0YS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGItYTsgfSk7XHJcblx0XHRcdHZhciBnb29kID0gdHJ1ZTtcclxuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykgeyBnb29kID0gZ29vZCAmJiB0aGlzLnJlbW92ZUNoaWxkQXQoYVtpXSk7IH1cclxuXHRcdFx0cmV0dXJuIGdvb2Q7XHJcblx0XHR9XHJcblx0XHRpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGhpcy5jaGlsZHJlbi5sZW5ndGgtMSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baW5kZXhdO1xyXG5cdFx0aWYgKGNoaWxkKSB7IGNoaWxkLnBhcmVudCA9IG51bGw7IH1cclxuXHRcdHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcclxuXHRcdGNoaWxkLmRpc3BhdGNoRXZlbnQoXCJyZW1vdmVkXCIpO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyBhbGwgY2hpbGRyZW4gZnJvbSB0aGUgZGlzcGxheSBsaXN0LlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogXHRjb250YWluZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgcmVtb3ZlQWxsQ2hpbGRyZW5cclxuXHQgKiovXHJcblx0cC5yZW1vdmVBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGtpZHMgPSB0aGlzLmNoaWxkcmVuO1xyXG5cdFx0d2hpbGUgKGtpZHMubGVuZ3RoKSB7IHRoaXMucmVtb3ZlQ2hpbGRBdCgwKTsgfVxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGNoaWxkIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIGNvbnRhaW5lci5nZXRDaGlsZEF0KDIpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBnZXRDaGlsZEF0XHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgY2hpbGQgdG8gcmV0dXJuLlxyXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LiBSZXR1cm5zIG51bGwgaWYgdGhlcmUgaXMgbm8gY2hpbGQgYXQgdGhlIGluZGV4LlxyXG5cdCAqKi9cclxuXHRwLmdldENoaWxkQXQgPSBmdW5jdGlvbihpbmRleCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2hpbGRyZW5baW5kZXhdO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY2hpbGQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcblx0ICogQG1ldGhvZCBnZXRDaGlsZEJ5TmFtZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjaGlsZCB0byByZXR1cm4uXHJcblx0ICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG5cdCAqKi9cclxuXHRwLmdldENoaWxkQnlOYW1lID0gZnVuY3Rpb24obmFtZSkge1xyXG5cdFx0dmFyIGtpZHMgPSB0aGlzLmNoaWxkcmVuO1xyXG5cdFx0Zm9yICh2YXIgaT0wLGw9a2lkcy5sZW5ndGg7aTxsO2krKykge1xyXG5cdFx0XHRpZihraWRzW2ldLm5hbWUgPT0gbmFtZSkgeyByZXR1cm4ga2lkc1tpXTsgfVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUGVyZm9ybXMgYW4gYXJyYXkgc29ydCBvcGVyYXRpb24gb24gdGhlIGNoaWxkIGxpc3QuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTogRGlzcGxheSBjaGlsZHJlbiB3aXRoIGEgaGlnaGVyIHkgaW4gZnJvbnQuPC9oND5cclxuXHQgKiBcclxuXHQgKiAgICAgIHZhciBzb3J0RnVuY3Rpb24gPSBmdW5jdGlvbihvYmoxLCBvYmoyLCBvcHRpb25zKSB7XHJcblx0ICogICAgICAgICAgaWYgKG9iajEueSA+IG9iajIueSkgeyByZXR1cm4gMTsgfVxyXG5cdCAqICAgICAgICAgIGlmIChvYmoxLnkgPCBvYmoyLnkpIHsgcmV0dXJuIC0xOyB9XHJcblx0ICogICAgICAgICAgcmV0dXJuIDA7XHJcblx0ICogICAgICB9XHJcblx0ICogICAgICBjb250YWluZXIuc29ydENoaWxkcmVuKHNvcnRGdW5jdGlvbik7XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIHNvcnRDaGlsZHJlblxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHNvcnRGdW5jdGlvbiB0aGUgZnVuY3Rpb24gdG8gdXNlIHRvIHNvcnQgdGhlIGNoaWxkIGxpc3QuIFNlZSBKYXZhU2NyaXB0J3MgPGNvZGU+QXJyYXkuc29ydDwvY29kZT5cclxuXHQgKiBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLlxyXG5cdCAqKi9cclxuXHRwLnNvcnRDaGlsZHJlbiA9IGZ1bmN0aW9uKHNvcnRGdW5jdGlvbikge1xyXG5cdFx0dGhpcy5jaGlsZHJlbi5zb3J0KHNvcnRGdW5jdGlvbik7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIHNwZWNpZmllZCBjaGlsZCBpbiB0aGUgZGlzcGxheSBsaXN0LCBvciAtMSBpZiBpdCBpcyBub3QgaW4gdGhlIGRpc3BsYXkgbGlzdC5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgdmFyIGluZGV4ID0gY29udGFpbmVyLmdldENoaWxkSW5kZXgoY2hpbGQpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBnZXRDaGlsZEluZGV4XHJcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBjaGlsZCBUaGUgY2hpbGQgdG8gcmV0dXJuIHRoZSBpbmRleCBvZi5cclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgc3BlY2lmaWVkIGNoaWxkLiAtMSBpZiB0aGUgY2hpbGQgaXMgbm90IGZvdW5kLlxyXG5cdCAqKi9cclxuXHRwLmdldENoaWxkSW5kZXggPSBmdW5jdGlvbihjaGlsZCkge1xyXG5cdFx0cmV0dXJuIGNyZWF0ZWpzLmluZGV4T2YodGhpcy5jaGlsZHJlbiwgY2hpbGQpO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogU3dhcHMgdGhlIGNoaWxkcmVuIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlcy4gRmFpbHMgc2lsZW50bHkgaWYgZWl0aGVyIGluZGV4IGlzIG91dCBvZiByYW5nZS5cclxuXHQgKiBAbWV0aG9kIHN3YXBDaGlsZHJlbkF0XHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4MVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleDJcclxuXHQgKiovXHJcblx0cC5zd2FwQ2hpbGRyZW5BdCA9IGZ1bmN0aW9uKGluZGV4MSwgaW5kZXgyKSB7XHJcblx0XHR2YXIga2lkcyA9IHRoaXMuY2hpbGRyZW47XHJcblx0XHR2YXIgbzEgPSBraWRzW2luZGV4MV07XHJcblx0XHR2YXIgbzIgPSBraWRzW2luZGV4Ml07XHJcblx0XHRpZiAoIW8xIHx8ICFvMikgeyByZXR1cm47IH1cclxuXHRcdGtpZHNbaW5kZXgxXSA9IG8yO1xyXG5cdFx0a2lkc1tpbmRleDJdID0gbzE7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBTd2FwcyB0aGUgc3BlY2lmaWVkIGNoaWxkcmVuJ3MgZGVwdGggaW4gdGhlIGRpc3BsYXkgbGlzdC4gRmFpbHMgc2lsZW50bHkgaWYgZWl0aGVyIGNoaWxkIGlzIG5vdCBhIGNoaWxkIG9mIHRoaXNcclxuXHQgKiBDb250YWluZXIuXHJcblx0ICogQG1ldGhvZCBzd2FwQ2hpbGRyZW5cclxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IGNoaWxkMVxyXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gY2hpbGQyXHJcblx0ICoqL1xyXG5cdHAuc3dhcENoaWxkcmVuID0gZnVuY3Rpb24oY2hpbGQxLCBjaGlsZDIpIHtcclxuXHRcdHZhciBraWRzID0gdGhpcy5jaGlsZHJlbjtcclxuXHRcdHZhciBpbmRleDEsaW5kZXgyO1xyXG5cdFx0Zm9yICh2YXIgaT0wLGw9a2lkcy5sZW5ndGg7aTxsO2krKykge1xyXG5cdFx0XHRpZiAoa2lkc1tpXSA9PSBjaGlsZDEpIHsgaW5kZXgxID0gaTsgfVxyXG5cdFx0XHRpZiAoa2lkc1tpXSA9PSBjaGlsZDIpIHsgaW5kZXgyID0gaTsgfVxyXG5cdFx0XHRpZiAoaW5kZXgxICE9IG51bGwgJiYgaW5kZXgyICE9IG51bGwpIHsgYnJlYWs7IH1cclxuXHRcdH1cclxuXHRcdGlmIChpPT1sKSB7IHJldHVybjsgfSAvLyBUT0RPOiB0aHJvdyBlcnJvcj9cclxuXHRcdGtpZHNbaW5kZXgxXSA9IGNoaWxkMjtcclxuXHRcdGtpZHNbaW5kZXgyXSA9IGNoaWxkMTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIENoYW5nZXMgdGhlIGRlcHRoIG9mIHRoZSBzcGVjaWZpZWQgY2hpbGQuIEZhaWxzIHNpbGVudGx5IGlmIHRoZSBjaGlsZCBpcyBub3QgYSBjaGlsZCBvZiB0aGlzIGNvbnRhaW5lciwgb3IgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZS5cclxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IGNoaWxkXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4ICBcclxuXHQgKiBAbWV0aG9kIHNldENoaWxkSW5kZXhcclxuXHQgKiovXHJcblx0cC5zZXRDaGlsZEluZGV4ID0gZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XHJcblx0XHR2YXIga2lkcyA9IHRoaXMuY2hpbGRyZW4sIGw9a2lkcy5sZW5ndGg7XHJcblx0XHRpZiAoY2hpbGQucGFyZW50ICE9IHRoaXMgfHwgaW5kZXggPCAwIHx8IGluZGV4ID49IGwpIHsgcmV0dXJuOyB9XHJcblx0XHRmb3IgKHZhciBpPTA7aTxsO2krKykge1xyXG5cdFx0XHRpZiAoa2lkc1tpXSA9PSBjaGlsZCkgeyBicmVhazsgfVxyXG5cdFx0fVxyXG5cdFx0aWYgKGk9PWwgfHwgaSA9PSBpbmRleCkgeyByZXR1cm47IH1cclxuXHRcdGtpZHMuc3BsaWNlKGksMSk7XHJcblx0XHRraWRzLnNwbGljZShpbmRleCwwLGNoaWxkKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBkaXNwbGF5IG9iamVjdCBlaXRoZXIgaXMgdGhpcyBjb250YWluZXIgb3IgaXMgYSBkZXNjZW5kZW50IChjaGlsZCwgZ3JhbmRjaGlsZCwgZXRjKVxyXG5cdCAqIG9mIHRoaXMgY29udGFpbmVyLlxyXG5cdCAqIEBtZXRob2QgY29udGFpbnNcclxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IGNoaWxkIFRoZSBEaXNwbGF5T2JqZWN0IHRvIGJlIGNoZWNrZWQuXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGRpc3BsYXkgb2JqZWN0IGVpdGhlciBpcyB0aGlzIGNvbnRhaW5lciBvciBpcyBhIGRlc2NlbmRlbnQuXHJcblx0ICoqL1xyXG5cdHAuY29udGFpbnMgPSBmdW5jdGlvbihjaGlsZCkge1xyXG5cdFx0d2hpbGUgKGNoaWxkKSB7XHJcblx0XHRcdGlmIChjaGlsZCA9PSB0aGlzKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcdGNoaWxkID0gY2hpbGQucGFyZW50O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRlc3RzIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IGludGVyc2VjdHMgdGhlIHNwZWNpZmllZCBsb2NhbCBwb2ludCAoaWUuIGRyYXdzIGEgcGl4ZWwgd2l0aCBhbHBoYSA+IDAgYXQgdGhlXHJcblx0ICogc3BlY2lmaWVkIHBvc2l0aW9uKS4gVGhpcyBpZ25vcmVzIHRoZSBhbHBoYSwgc2hhZG93IGFuZCBjb21wb3NpdGVPcGVyYXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0LCBhbmQgYWxsXHJcblx0ICogdHJhbnNmb3JtIHByb3BlcnRpZXMgaW5jbHVkaW5nIHJlZ1gvWS5cclxuXHQgKiBAbWV0aG9kIGhpdFRlc3RcclxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvbiB0byBjaGVjayBpbiB0aGUgZGlzcGxheSBvYmplY3QncyBsb2NhbCBjb29yZGluYXRlcy5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiB0byBjaGVjayBpbiB0aGUgZGlzcGxheSBvYmplY3QncyBsb2NhbCBjb29yZGluYXRlcy5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZXJlIGlzIGEgdmlzaWJsZSBzZWN0aW9uIG9mIGEgRGlzcGxheU9iamVjdCB0aGF0IG92ZXJsYXBzIHRoZSBzcGVjaWZpZWRcclxuXHQgKiBjb29yZGluYXRlcy5cclxuXHQgKiovXHJcblx0cC5oaXRUZXN0ID0gZnVuY3Rpb24oeCwgeSkge1xyXG5cdFx0Ly8gVE9ETzogb3B0aW1pemUgdG8gdXNlIHRoZSBmYXN0IGNhY2hlIGNoZWNrIHdoZXJlIHBvc3NpYmxlLlxyXG5cdFx0cmV0dXJuICh0aGlzLmdldE9iamVjdFVuZGVyUG9pbnQoeCwgeSkgIT0gbnVsbCk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgZGlzcGxheSBvYmplY3RzIHVuZGVyIHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZXMgdGhhdCBhcmUgaW4gdGhpcyBjb250YWluZXIncyBkaXNwbGF5XHJcblx0ICogbGlzdC4gVGhpcyByb3V0aW5lIGlnbm9yZXMgYW55IGRpc3BsYXkgb2JqZWN0cyB3aXRoIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2VFbmFibGVkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XHJcblx0ICogc2V0IHRvIGBmYWxzZWAuIFRoZSBhcnJheSB3aWxsIGJlIHNvcnRlZCBpbiBvcmRlciBvZiB2aXN1YWwgZGVwdGgsIHdpdGggdGhlIHRvcC1tb3N0IGRpc3BsYXkgb2JqZWN0IGF0IGluZGV4IDAuXHJcblx0ICogVGhpcyB1c2VzIHNoYXBlIGJhc2VkIGhpdCBkZXRlY3Rpb24sIGFuZCBjYW4gYmUgYW4gZXhwZW5zaXZlIG9wZXJhdGlvbiB0byBydW4sIHNvIGl0IGlzIGJlc3QgdG8gdXNlIGl0IGNhcmVmdWxseS5cclxuXHQgKiBGb3IgZXhhbXBsZSwgaWYgdGVzdGluZyBmb3Igb2JqZWN0cyB1bmRlciB0aGUgbW91c2UsIHRlc3Qgb24gdGljayAoaW5zdGVhZCBvZiBvbiB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlbW92ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fSksXHJcblx0ICogYW5kIG9ubHkgaWYgdGhlIG1vdXNlJ3MgcG9zaXRpb24gaGFzIGNoYW5nZWQuXHJcblx0ICogXHJcblx0ICogPHVsPlxyXG5cdCAqICAgICA8bGk+QnkgZGVmYXVsdCAobW9kZT0wKSB0aGlzIG1ldGhvZCBldmFsdWF0ZXMgYWxsIGRpc3BsYXkgb2JqZWN0cy48L2xpPlxyXG5cdCAqICAgICA8bGk+Qnkgc2V0dGluZyB0aGUgYG1vZGVgIHBhcmFtZXRlciB0byBgMWAsIHRoZSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlRW5hYmxlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIFx0XHRhbmQge3sjY3Jvc3NMaW5rIFwibW91c2VDaGlsZHJlbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0aWVzIHdpbGwgYmUgcmVzcGVjdGVkLjwvbGk+XHJcblx0ICogXHQgICA8bGk+U2V0dGluZyB0aGUgYG1vZGVgIHRvIGAyYCBhZGRpdGlvbmFsbHkgZXhjbHVkZXMgZGlzcGxheSBvYmplY3RzIHRoYXQgZG8gbm90IGhhdmUgYWN0aXZlIG1vdXNlIGV2ZW50XHJcblx0ICogXHQgICBcdGxpc3RlbmVycyBvciBhIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3Q6Y3Vyc29yOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5LiBUaGF0IGlzLCBvbmx5IG9iamVjdHNcclxuXHQgKiBcdCAgIFx0dGhhdCB3b3VsZCBub3JtYWxseSBpbnRlcmNlcHQgbW91c2UgaW50ZXJhY3Rpb24gd2lsbCBiZSBpbmNsdWRlZC4gVGhpcyBjYW4gc2lnbmlmaWNhbnRseSBpbXByb3ZlIHBlcmZvcm1hbmNlXHJcblx0ICogXHQgICBcdGluIHNvbWUgY2FzZXMgYnkgcmVkdWNpbmcgdGhlIG51bWJlciBvZiBkaXNwbGF5IG9iamVjdHMgdGhhdCBuZWVkIHRvIGJlIHRlc3RlZC48L2xpPlxyXG5cdCAqIDwvbGk+XHJcblx0ICogXHJcblx0ICogVGhpcyBtZXRob2QgYWNjb3VudHMgZm9yIGJvdGgge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9oaXRBcmVhOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21hc2s6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXHJcblx0ICogQG1ldGhvZCBnZXRPYmplY3RzVW5kZXJQb2ludFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIGluIHRoZSBjb250YWluZXIgdG8gdGVzdC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiBpbiB0aGUgY29udGFpbmVyIHRvIHRlc3QuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttb2RlPTBdIFRoZSBtb2RlIHRvIHVzZSB0byBkZXRlcm1pbmUgd2hpY2ggZGlzcGxheSBvYmplY3RzIHRvIGluY2x1ZGUuIDAtYWxsLCAxLXJlc3BlY3QgbW91c2VFbmFibGVkL21vdXNlQ2hpbGRyZW4sIDItb25seSBtb3VzZSBvcGFxdWUgb2JqZWN0cy5cclxuXHQgKiBAcmV0dXJuIHtBcnJheX0gQW4gQXJyYXkgb2YgRGlzcGxheU9iamVjdHMgdW5kZXIgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlcy5cclxuXHQgKiovXHJcblx0cC5nZXRPYmplY3RzVW5kZXJQb2ludCA9IGZ1bmN0aW9uKHgsIHksIG1vZGUpIHtcclxuXHRcdHZhciBhcnIgPSBbXTtcclxuXHRcdHZhciBwdCA9IHRoaXMubG9jYWxUb0dsb2JhbCh4LCB5KTtcclxuXHRcdHRoaXMuX2dldE9iamVjdHNVbmRlclBvaW50KHB0LngsIHB0LnksIGFyciwgbW9kZT4wLCBtb2RlPT0xKTtcclxuXHRcdHJldHVybiBhcnI7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogU2ltaWxhciB0byB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvZ2V0T2JqZWN0c1VuZGVyUG9pbnRcIn19e3svY3Jvc3NMaW5rfX0sIGJ1dCByZXR1cm5zIG9ubHkgdGhlIHRvcC1tb3N0IGRpc3BsYXlcclxuXHQgKiBvYmplY3QuIFRoaXMgcnVucyBzaWduaWZpY2FudGx5IGZhc3RlciB0aGFuIDxjb2RlPmdldE9iamVjdHNVbmRlclBvaW50KCk8L2NvZGU+LCBidXQgaXMgc3RpbGwgcG90ZW50aWFsbHkgYW4gZXhwZW5zaXZlXHJcblx0ICogb3BlcmF0aW9uLiBTZWUge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyL2dldE9iamVjdHNVbmRlclBvaW50XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG5cdCAqIEBtZXRob2QgZ2V0T2JqZWN0VW5kZXJQb2ludFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIGluIHRoZSBjb250YWluZXIgdG8gdGVzdC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiBpbiB0aGUgY29udGFpbmVyIHRvIHRlc3QuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1vZGUgVGhlIG1vZGUgdG8gdXNlIHRvIGRldGVybWluZSB3aGljaCBkaXNwbGF5IG9iamVjdHMgdG8gaW5jbHVkZS4gIDAtYWxsLCAxLXJlc3BlY3QgbW91c2VFbmFibGVkL21vdXNlQ2hpbGRyZW4sIDItb25seSBtb3VzZSBvcGFxdWUgb2JqZWN0cy5cclxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBUaGUgdG9wLW1vc3QgZGlzcGxheSBvYmplY3QgdW5kZXIgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlcy5cclxuXHQgKiovXHJcblx0cC5nZXRPYmplY3RVbmRlclBvaW50ID0gZnVuY3Rpb24oeCwgeSwgbW9kZSkge1xyXG5cdFx0dmFyIHB0ID0gdGhpcy5sb2NhbFRvR2xvYmFsKHgsIHkpO1xyXG5cdFx0cmV0dXJuIHRoaXMuX2dldE9iamVjdHNVbmRlclBvaW50KHB0LngsIHB0LnksIG51bGwsIG1vZGU+MCwgbW9kZT09MSk7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBEb2NjZWQgaW4gc3VwZXJjbGFzcy5cclxuXHQgKi9cclxuXHRwLmdldEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2dldEJvdW5kcyhudWxsLCB0cnVlKTtcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIERvY2NlZCBpbiBzdXBlcmNsYXNzLlxyXG5cdCAqL1xyXG5cdHAuZ2V0VHJhbnNmb3JtZWRCb3VuZHMgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLl9nZXRCb3VuZHMoKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBDb250YWluZXIuIFNvbWUgcHJvcGVydGllcyB0aGF0IGFyZSBzcGVjaWZpYyB0byB0aGlzIGluc3RhbmNlJ3MgY3VycmVudCBjb250ZXh0IGFyZVxyXG5cdCAqIHJldmVydGVkIHRvIHRoZWlyIGRlZmF1bHRzIChmb3IgZXhhbXBsZSAucGFyZW50KS5cclxuXHQgKiBAbWV0aG9kIGNsb25lXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbcmVjdXJzaXZlPWZhbHNlXSBJZiB0cnVlLCBhbGwgb2YgdGhlIGRlc2NlbmRhbnRzIG9mIHRoaXMgY29udGFpbmVyIHdpbGwgYmUgY2xvbmVkIHJlY3Vyc2l2ZWx5LiBJZiBmYWxzZSwgdGhlXHJcblx0ICogcHJvcGVydGllcyBvZiB0aGUgY29udGFpbmVyIHdpbGwgYmUgY2xvbmVkLCBidXQgdGhlIG5ldyBpbnN0YW5jZSB3aWxsIG5vdCBoYXZlIGFueSBjaGlsZHJlbi5cclxuXHQgKiBAcmV0dXJuIHtDb250YWluZXJ9IEEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgQ29udGFpbmVyIGluc3RhbmNlLlxyXG5cdCAqKi9cclxuXHRwLmNsb25lID0gZnVuY3Rpb24ocmVjdXJzaXZlKSB7XHJcblx0XHR2YXIgbyA9IHRoaXMuX2Nsb25lUHJvcHMobmV3IENvbnRhaW5lcigpKTtcclxuXHRcdGlmIChyZWN1cnNpdmUpIHsgdGhpcy5fY2xvbmVDaGlsZHJlbihvKTsgfVxyXG5cdFx0cmV0dXJuIG87XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cclxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXHJcblx0ICoqL1xyXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBcIltDb250YWluZXIgKG5hbWU9XCIrICB0aGlzLm5hbWUgK1wiKV1cIjtcclxuXHR9O1xyXG5cclxuXHJcbi8vIHByaXZhdGUgbWV0aG9kczpcclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIF90aWNrXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2dE9iaiBBbiBldmVudCBvYmplY3QgdGhhdCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gYWxsIHRpY2sgbGlzdGVuZXJzLiBUaGlzIG9iamVjdCBpcyByZXVzZWQgYmV0d2VlbiBkaXNwYXRjaGVycyB0byByZWR1Y2UgY29uc3RydWN0aW9uICYgR0MgY29zdHMuXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqKi9cclxuXHRwLl90aWNrID0gZnVuY3Rpb24oZXZ0T2JqKSB7XHJcblx0XHRpZiAodGhpcy50aWNrQ2hpbGRyZW4pIHtcclxuXHRcdFx0Zm9yICh2YXIgaT10aGlzLmNoaWxkcmVuLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcclxuXHRcdFx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xyXG5cdFx0XHRcdGlmIChjaGlsZC50aWNrRW5hYmxlZCAmJiBjaGlsZC5fdGljaykgeyBjaGlsZC5fdGljayhldnRPYmopOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9fdGljayhldnRPYmopO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmVjdXJzaXZlbHkgY2xvbmVzIGFsbCBjaGlsZHJlbiBvZiB0aGlzIGNvbnRhaW5lciwgYW5kIGFkZHMgdGhlbSB0byB0aGUgdGFyZ2V0IGNvbnRhaW5lci5cclxuXHQgKiBAbWV0aG9kIGNsb25lQ2hpbGRyZW5cclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICogQHBhcmFtIHtDb250YWluZXJ9IG8gVGhlIHRhcmdldCBjb250YWluZXIuXHJcblx0ICoqL1xyXG5cdHAuX2Nsb25lQ2hpbGRyZW4gPSBmdW5jdGlvbihvKSB7XHJcblx0XHRpZiAoby5jaGlsZHJlbi5sZW5ndGgpIHsgby5yZW1vdmVBbGxDaGlsZHJlbigpOyB9XHJcblx0XHR2YXIgYXJyID0gby5jaGlsZHJlbjtcclxuXHRcdGZvciAodmFyIGk9MCwgbD10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxsOyBpKyspIHtcclxuXHRcdFx0dmFyIGNsb25lID0gdGhpcy5jaGlsZHJlbltpXS5jbG9uZSh0cnVlKTtcclxuXHRcdFx0Y2xvbmUucGFyZW50ID0gbztcclxuXHRcdFx0YXJyLnB1c2goY2xvbmUpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBtZXRob2QgX2dldE9iamVjdHNVbmRlclBvaW50XHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFyclxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gbW91c2UgSWYgdHJ1ZSwgaXQgd2lsbCByZXNwZWN0IG1vdXNlIGludGVyYWN0aW9uIHByb3BlcnRpZXMgbGlrZSBtb3VzZUVuYWJsZWQsIG1vdXNlQ2hpbGRyZW4sIGFuZCBhY3RpdmUgbGlzdGVuZXJzLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYWN0aXZlTGlzdGVuZXIgSWYgdHJ1ZSwgdGhlcmUgaXMgYW4gYWN0aXZlIG1vdXNlIGV2ZW50IGxpc3RlbmVyIG9uIGEgcGFyZW50IG9iamVjdC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3VycmVudERlcHRoIEluZGljYXRlcyB0aGUgY3VycmVudCBkZXB0aCBvZiB0aGUgc2VhcmNoLlxyXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9XHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqKi9cclxuXHRwLl9nZXRPYmplY3RzVW5kZXJQb2ludCA9IGZ1bmN0aW9uKHgsIHksIGFyciwgbW91c2UsIGFjdGl2ZUxpc3RlbmVyLCBjdXJyZW50RGVwdGgpIHtcclxuXHRcdGN1cnJlbnREZXB0aCA9IGN1cnJlbnREZXB0aCB8fCAwO1xyXG5cdFx0aWYgKCFjdXJyZW50RGVwdGggJiYgIXRoaXMuX3Rlc3RNYXNrKHRoaXMsIHgsIHkpKSB7IHJldHVybiBudWxsOyB9XHJcblx0XHR2YXIgbXR4LCBjdHggPSBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0Ll9oaXRUZXN0Q29udGV4dDtcclxuXHRcdGFjdGl2ZUxpc3RlbmVyID0gYWN0aXZlTGlzdGVuZXIgfHwgKG1vdXNlJiZ0aGlzLl9oYXNNb3VzZUV2ZW50TGlzdGVuZXIoKSk7XHJcblxyXG5cdFx0Ly8gZHJhdyBjaGlsZHJlbiBvbmUgYXQgYSB0aW1lLCBhbmQgY2hlY2sgaWYgd2UgZ2V0IGEgaGl0OlxyXG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiwgbCA9IGNoaWxkcmVuLmxlbmd0aDtcclxuXHRcdGZvciAodmFyIGk9bC0xOyBpPj0wOyBpLS0pIHtcclxuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV07XHJcblx0XHRcdHZhciBoaXRBcmVhID0gY2hpbGQuaGl0QXJlYTtcclxuXHRcdFx0aWYgKCFjaGlsZC52aXNpYmxlIHx8ICghaGl0QXJlYSAmJiAhY2hpbGQuaXNWaXNpYmxlKCkpIHx8IChtb3VzZSAmJiAhY2hpbGQubW91c2VFbmFibGVkKSkgeyBjb250aW51ZTsgfVxyXG5cdFx0XHRpZiAoIWhpdEFyZWEgJiYgIXRoaXMuX3Rlc3RNYXNrKGNoaWxkLCB4LCB5KSkgeyBjb250aW51ZTsgfVxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gaWYgYSBjaGlsZCBjb250YWluZXIgaGFzIGEgaGl0QXJlYSB0aGVuIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpdHMgaGl0QXJlYSwgc28gd2UgY2FuIHRyZWF0IGl0IGFzIGEgbm9ybWFsIERPOlxyXG5cdFx0XHRpZiAoIWhpdEFyZWEgJiYgY2hpbGQgaW5zdGFuY2VvZiBDb250YWluZXIpIHtcclxuXHRcdFx0XHR2YXIgcmVzdWx0ID0gY2hpbGQuX2dldE9iamVjdHNVbmRlclBvaW50KHgsIHksIGFyciwgbW91c2UsIGFjdGl2ZUxpc3RlbmVyLCBjdXJyZW50RGVwdGgrMSk7XHJcblx0XHRcdFx0aWYgKCFhcnIgJiYgcmVzdWx0KSB7IHJldHVybiAobW91c2UgJiYgIXRoaXMubW91c2VDaGlsZHJlbikgPyB0aGlzIDogcmVzdWx0OyB9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKG1vdXNlICYmICFhY3RpdmVMaXN0ZW5lciAmJiAhY2hpbGQuX2hhc01vdXNlRXZlbnRMaXN0ZW5lcigpKSB7IGNvbnRpbnVlOyB9XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gVE9ETzogY2FuIHdlIHBhc3MgZGlzcGxheVByb3BzIGZvcndhcmQsIHRvIGF2b2lkIGhhdmluZyB0byBjYWxjdWxhdGUgdGhpcyBiYWNrd2FyZHMgZXZlcnkgdGltZT8gSXQncyBraW5kIG9mIGEgbWl4ZWQgYmFnLiBXaGVuIHdlJ3JlIG9ubHkgaHVudGluZyBmb3IgRE9zIHdpdGggZXZlbnQgbGlzdGVuZXJzLCBpdCBtYXkgbm90IG1ha2Ugc2Vuc2UuXHJcblx0XHRcdFx0dmFyIHByb3BzID0gY2hpbGQuZ2V0Q29uY2F0ZW5hdGVkRGlzcGxheVByb3BzKGNoaWxkLl9wcm9wcyk7XHJcblx0XHRcdFx0bXR4ID0gcHJvcHMubWF0cml4O1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGlmIChoaXRBcmVhKSB7XHJcblx0XHRcdFx0XHRtdHguYXBwZW5kTWF0cml4KGhpdEFyZWEuZ2V0TWF0cml4KGhpdEFyZWEuX3Byb3BzLm1hdHJpeCkpO1xyXG5cdFx0XHRcdFx0cHJvcHMuYWxwaGEgPSBoaXRBcmVhLmFscGhhO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRcclxuXHRcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBwcm9wcy5hbHBoYTtcclxuXHRcdFx0XHRjdHguc2V0VHJhbnNmb3JtKG10eC5hLCAgbXR4LmIsIG10eC5jLCBtdHguZCwgbXR4LnR4LXgsIG10eC50eS15KTtcclxuXHRcdFx0XHQoaGl0QXJlYXx8Y2hpbGQpLmRyYXcoY3R4KTtcclxuXHRcdFx0XHRpZiAoIXRoaXMuX3Rlc3RIaXQoY3R4KSkgeyBjb250aW51ZTsgfVxyXG5cdFx0XHRcdGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XHJcblx0XHRcdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCAyLCAyKTtcclxuXHRcdFx0XHRpZiAoYXJyKSB7IGFyci5wdXNoKGNoaWxkKTsgfVxyXG5cdFx0XHRcdGVsc2UgeyByZXR1cm4gKG1vdXNlICYmICF0aGlzLm1vdXNlQ2hpbGRyZW4pID8gdGhpcyA6IGNoaWxkOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogQG1ldGhvZCBfdGVzdE1hc2tcclxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IHRhcmdldFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgeC95IGlzIHdpdGhpbiB0aGUgbWFza2VkIHJlZ2lvbi5cclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICoqL1xyXG5cdHAuX3Rlc3RNYXNrID0gZnVuY3Rpb24odGFyZ2V0LCB4LCB5KSB7XHJcblx0XHR2YXIgbWFzayA9IHRhcmdldC5tYXNrO1xyXG5cdFx0aWYgKCFtYXNrIHx8ICFtYXNrLmdyYXBoaWNzIHx8IG1hc2suZ3JhcGhpY3MuaXNFbXB0eSgpKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcclxuXHRcdHZhciBtdHggPSB0aGlzLl9wcm9wcy5tYXRyaXgsIHBhcmVudCA9IHRhcmdldC5wYXJlbnQ7XHJcblx0XHRtdHggPSBwYXJlbnQgPyBwYXJlbnQuZ2V0Q29uY2F0ZW5hdGVkTWF0cml4KG10eCkgOiBtdHguaWRlbnRpdHkoKTtcclxuXHRcdG10eCA9IG1hc2suZ2V0TWF0cml4KG1hc2suX3Byb3BzLm1hdHJpeCkucHJlcGVuZE1hdHJpeChtdHgpO1xyXG5cdFx0XHJcblx0XHR2YXIgY3R4ID0gY3JlYXRlanMuRGlzcGxheU9iamVjdC5faGl0VGVzdENvbnRleHQ7XHJcblx0XHRjdHguc2V0VHJhbnNmb3JtKG10eC5hLCAgbXR4LmIsIG10eC5jLCBtdHguZCwgbXR4LnR4LXgsIG10eC50eS15KTtcclxuXHRcdFxyXG5cdFx0Ly8gZHJhdyB0aGUgbWFzayBhcyBhIHNvbGlkIGZpbGw6XHJcblx0XHRtYXNrLmdyYXBoaWNzLmRyYXdBc1BhdGgoY3R4KTtcclxuXHRcdGN0eC5maWxsU3R5bGUgPSBcIiMwMDBcIjtcclxuXHRcdGN0eC5maWxsKCk7XHJcblx0XHRcclxuXHRcdGlmICghdGhpcy5fdGVzdEhpdChjdHgpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0Y3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcclxuXHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgMiwgMik7XHJcblx0XHRcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogQG1ldGhvZCBfZ2V0Qm91bmRzXHJcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4XHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVUcmFuc2Zvcm0gSWYgdHJ1ZSwgZG9lcyBub3QgYXBwbHkgdGhpcyBvYmplY3QncyB0cmFuc2Zvcm0uXHJcblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfVxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiovXHJcblx0cC5fZ2V0Qm91bmRzID0gZnVuY3Rpb24obWF0cml4LCBpZ25vcmVUcmFuc2Zvcm0pIHtcclxuXHRcdHZhciBib3VuZHMgPSB0aGlzLkRpc3BsYXlPYmplY3RfZ2V0Qm91bmRzKCk7XHJcblx0XHRpZiAoYm91bmRzKSB7IHJldHVybiB0aGlzLl90cmFuc2Zvcm1Cb3VuZHMoYm91bmRzLCBtYXRyaXgsIGlnbm9yZVRyYW5zZm9ybSk7IH1cclxuXHRcdFxyXG5cdFx0dmFyIG10eCA9IHRoaXMuX3Byb3BzLm1hdHJpeDtcclxuXHRcdG10eCA9IGlnbm9yZVRyYW5zZm9ybSA/IG10eC5pZGVudGl0eSgpIDogdGhpcy5nZXRNYXRyaXgobXR4KTtcclxuXHRcdGlmIChtYXRyaXgpIHsgbXR4LnByZXBlbmRNYXRyaXgobWF0cml4KTsgfVxyXG5cdFx0XHJcblx0XHR2YXIgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoLCByZWN0PW51bGw7XHJcblx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7XHJcblx0XHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XHJcblx0XHRcdGlmICghY2hpbGQudmlzaWJsZSB8fCAhKGJvdW5kcyA9IGNoaWxkLl9nZXRCb3VuZHMobXR4KSkpIHsgY29udGludWU7IH1cclxuXHRcdFx0aWYgKHJlY3QpIHsgcmVjdC5leHRlbmQoYm91bmRzLngsIGJvdW5kcy55LCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpOyB9XHJcblx0XHRcdGVsc2UgeyByZWN0ID0gYm91bmRzLmNsb25lKCk7IH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZWN0O1xyXG5cdH07XHJcblxyXG5cclxuXHRjcmVhdGVqcy5Db250YWluZXIgPSBjcmVhdGVqcy5wcm9tb3RlKENvbnRhaW5lciwgXCJEaXNwbGF5T2JqZWN0XCIpO1xyXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU3RhZ2UuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEEgc3RhZ2UgaXMgdGhlIHJvb3QgbGV2ZWwge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhIGRpc3BsYXkgbGlzdC4gRWFjaCB0aW1lIGl0cyB7eyNjcm9zc0xpbmsgXCJTdGFnZS90aWNrXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZCBpcyBjYWxsZWQsIGl0IHdpbGwgcmVuZGVyIGl0cyBkaXNwbGF5IGxpc3QgdG8gaXRzIHRhcmdldCBjYW52YXMuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogVGhpcyBleGFtcGxlIGNyZWF0ZXMgYSBzdGFnZSwgYWRkcyBhIGNoaWxkIHRvIGl0LCB0aGVuIHVzZXMge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319IHRvIHVwZGF0ZSB0aGUgY2hpbGRcblx0ICogYW5kIHJlZHJhdyB0aGUgc3RhZ2UgdXNpbmcge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdXBkYXRlXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiAgICAgIHZhciBzdGFnZSA9IG5ldyBjcmVhdGVqcy5TdGFnZShcImNhbnZhc0VsZW1lbnRJZFwiKTtcblx0ICogICAgICB2YXIgaW1hZ2UgPSBuZXcgY3JlYXRlanMuQml0bWFwKFwiaW1hZ2VQYXRoLnBuZ1wiKTtcblx0ICogICAgICBzdGFnZS5hZGRDaGlsZChpbWFnZSk7XG5cdCAqICAgICAgY3JlYXRlanMuVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIGhhbmRsZVRpY2spO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZVRpY2soZXZlbnQpIHtcblx0ICogICAgICAgICAgaW1hZ2UueCArPSAxMDtcblx0ICogICAgICAgICAgc3RhZ2UudXBkYXRlKCk7XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBAY2xhc3MgU3RhZ2Vcblx0ICogQGV4dGVuZHMgQ29udGFpbmVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50IHwgU3RyaW5nIHwgT2JqZWN0fSBjYW52YXMgQSBjYW52YXMgb2JqZWN0IHRoYXQgdGhlIFN0YWdlIHdpbGwgcmVuZGVyIHRvLCBvciB0aGUgc3RyaW5nIGlkXG5cdCAqIG9mIGEgY2FudmFzIG9iamVjdCBpbiB0aGUgY3VycmVudCBkb2N1bWVudC5cblx0ICoqL1xuXHRmdW5jdGlvbiBTdGFnZShjYW52YXMpIHtcblx0XHR0aGlzLkNvbnRhaW5lcl9jb25zdHJ1Y3RvcigpO1xuXHRcblx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdGFnZSBzaG91bGQgYXV0b21hdGljYWxseSBjbGVhciB0aGUgY2FudmFzIGJlZm9yZSBlYWNoIHJlbmRlci4gWW91IGNhbiBzZXQgdGhpcyB0byA8Y29kZT5mYWxzZTwvY29kZT5cblx0XHQgKiB0byBtYW51YWxseSBjb250cm9sIGNsZWFyaW5nIChmb3IgZ2VuZXJhdGl2ZSBhcnQsIG9yIHdoZW4gcG9pbnRpbmcgbXVsdGlwbGUgc3RhZ2VzIGF0IHRoZSBzYW1lIGNhbnZhcyBmb3Jcblx0XHQgKiBleGFtcGxlKS5cblx0XHQgKlxuXHRcdCAqIDxoND5FeGFtcGxlPC9oND5cblx0XHQgKlxuXHRcdCAqICAgICAgdmFyIHN0YWdlID0gbmV3IGNyZWF0ZWpzLlN0YWdlKFwiY2FudmFzSWRcIik7XG5cdFx0ICogICAgICBzdGFnZS5hdXRvQ2xlYXIgPSBmYWxzZTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBhdXRvQ2xlYXJcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqKi9cblx0XHR0aGlzLmF1dG9DbGVhciA9IHRydWU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjYW52YXMgdGhlIHN0YWdlIHdpbGwgcmVuZGVyIHRvLiBNdWx0aXBsZSBzdGFnZXMgY2FuIHNoYXJlIGEgc2luZ2xlIGNhbnZhcywgYnV0IHlvdSBtdXN0IGRpc2FibGUgYXV0b0NsZWFyIGZvciBhbGwgYnV0IHRoZVxuXHRcdCAqIGZpcnN0IHN0YWdlIHRoYXQgd2lsbCBiZSB0aWNrZWQgKG9yIHRoZXkgd2lsbCBjbGVhciBlYWNoIG90aGVyJ3MgcmVuZGVyKS5cblx0XHQgKlxuXHRcdCAqIFdoZW4gY2hhbmdpbmcgdGhlIGNhbnZhcyBwcm9wZXJ0eSB5b3UgbXVzdCBkaXNhYmxlIHRoZSBldmVudHMgb24gdGhlIG9sZCBjYW52YXMsIGFuZCBlbmFibGUgZXZlbnRzIG9uIHRoZVxuXHRcdCAqIG5ldyBjYW52YXMgb3IgbW91c2UgZXZlbnRzIHdpbGwgbm90IHdvcmsgYXMgZXhwZWN0ZWQuIEZvciBleGFtcGxlOlxuXHRcdCAqXG5cdFx0ICogICAgICBteVN0YWdlLmVuYWJsZURPTUV2ZW50cyhmYWxzZSk7XG5cdFx0ICogICAgICBteVN0YWdlLmNhbnZhcyA9IGFub3RoZXJDYW52YXM7XG5cdFx0ICogICAgICBteVN0YWdlLmVuYWJsZURPTUV2ZW50cyh0cnVlKTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBjYW52YXNcblx0XHQgKiBAdHlwZSBIVE1MQ2FudmFzRWxlbWVudCB8IE9iamVjdFxuXHRcdCAqKi9cblx0XHR0aGlzLmNhbnZhcyA9ICh0eXBlb2YgY2FudmFzID09IFwic3RyaW5nXCIpID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzKSA6IGNhbnZhcztcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgbW91c2UgWCBwb3NpdGlvbiBvbiB0aGUgY2FudmFzLiBJZiB0aGUgbW91c2UgbGVhdmVzIHRoZSBjYW52YXMsIHRoaXMgd2lsbCBpbmRpY2F0ZSB0aGUgbW9zdCByZWNlbnRcblx0XHQgKiBwb3NpdGlvbiBvdmVyIHRoZSBjYW52YXMsIGFuZCBtb3VzZUluQm91bmRzIHdpbGwgYmUgc2V0IHRvIGZhbHNlLlxuXHRcdCAqIEBwcm9wZXJ0eSBtb3VzZVhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5tb3VzZVggPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY3VycmVudCBtb3VzZSBZIHBvc2l0aW9uIG9uIHRoZSBjYW52YXMuIElmIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIGNhbnZhcywgdGhpcyB3aWxsIGluZGljYXRlIHRoZSBtb3N0IHJlY2VudFxuXHRcdCAqIHBvc2l0aW9uIG92ZXIgdGhlIGNhbnZhcywgYW5kIG1vdXNlSW5Cb3VuZHMgd2lsbCBiZSBzZXQgdG8gZmFsc2UuXG5cdFx0ICogQHByb3BlcnR5IG1vdXNlWVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLm1vdXNlWSA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNwZWNpZmllcyB0aGUgYXJlYSBvZiB0aGUgc3RhZ2UgdG8gYWZmZWN0IHdoZW4gY2FsbGluZyB1cGRhdGUuIFRoaXMgY2FuIGJlIHVzZSB0byBzZWxlY3RpdmVseVxuXHRcdCAqIHJlLWRyYXcgc3BlY2lmaWMgcmVnaW9ucyBvZiB0aGUgY2FudmFzLiBJZiBudWxsLCB0aGUgd2hvbGUgY2FudmFzIGFyZWEgaXMgZHJhd24uXG5cdFx0ICogQHByb3BlcnR5IGRyYXdSZWN0XG5cdFx0ICogQHR5cGUge1JlY3RhbmdsZX1cblx0XHQgKi9cblx0XHR0aGlzLmRyYXdSZWN0ID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgZGlzcGxheSBvYmplY3RzIHNob3VsZCBiZSByZW5kZXJlZCBvbiB3aG9sZSBwaXhlbHMuIFlvdSBjYW4gc2V0IHRoZVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3Qvc25hcFRvUGl4ZWxcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgb2Zcblx0XHQgKiBkaXNwbGF5IG9iamVjdHMgdG8gZmFsc2UgdG8gZW5hYmxlL2Rpc2FibGUgdGhpcyBiZWhhdmlvdXIgb24gYSBwZXIgaW5zdGFuY2UgYmFzaXMuXG5cdFx0ICogQHByb3BlcnR5IHNuYXBUb1BpeGVsRW5hYmxlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqKi9cblx0XHR0aGlzLnNuYXBUb1BpeGVsRW5hYmxlZCA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbW91c2UgaXMgY3VycmVudGx5IHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoZSBjYW52YXMuXG5cdFx0ICogQHByb3BlcnR5IG1vdXNlSW5Cb3VuZHNcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiovXG5cdFx0dGhpcy5tb3VzZUluQm91bmRzID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIHRydWUsIHRpY2sgY2FsbGJhY2tzIHdpbGwgYmUgY2FsbGVkIG9uIGFsbCBkaXNwbGF5IG9iamVjdHMgb24gdGhlIHN0YWdlIHByaW9yIHRvIHJlbmRlcmluZyB0byB0aGUgY2FudmFzLlxuXHRcdCAqIEBwcm9wZXJ0eSB0aWNrT25VcGRhdGVcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqKi9cblx0XHR0aGlzLnRpY2tPblVwZGF0ZSA9IHRydWU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIHRydWUsIG1vdXNlIG1vdmUgZXZlbnRzIHdpbGwgY29udGludWUgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgdGFyZ2V0IGNhbnZhcy4gU2VlXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvbW91c2VJbkJvdW5kczpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiB4L3kvcmF3WC9yYXdZLlxuXHRcdCAqIEBwcm9wZXJ0eSBtb3VzZU1vdmVPdXRzaWRlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICoqL1xuXHRcdHRoaXMubW91c2VNb3ZlT3V0c2lkZSA9IGZhbHNlO1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFByZXZlbnRzIHNlbGVjdGlvbiBvZiBvdGhlciBlbGVtZW50cyBpbiB0aGUgaHRtbCBwYWdlIGlmIHRoZSB1c2VyIGNsaWNrcyBhbmQgZHJhZ3MsIG9yIGRvdWJsZSBjbGlja3Mgb24gdGhlIGNhbnZhcy5cblx0XHQgKiBUaGlzIHdvcmtzIGJ5IGNhbGxpbmcgYHByZXZlbnREZWZhdWx0KClgIG9uIGFueSBtb3VzZWRvd24gZXZlbnRzIChvciB0b3VjaCBlcXVpdmFsZW50KSBvcmlnaW5hdGluZyBvbiB0aGUgY2FudmFzLlxuXHRcdCAqIEBwcm9wZXJ0eSBwcmV2ZW50U2VsZWN0aW9uXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKiovXG5cdFx0dGhpcy5wcmV2ZW50U2VsZWN0aW9uID0gdHJ1ZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGhpdEFyZWEgcHJvcGVydHkgaXMgbm90IHN1cHBvcnRlZCBmb3IgU3RhZ2UuXG5cdFx0ICogQHByb3BlcnR5IGhpdEFyZWFcblx0XHQgKiBAdHlwZSB7RGlzcGxheU9iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0IFxuXHRcdCBcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIG9iamVjdHMgd2l0aCBkYXRhIGZvciBlYWNoIGFjdGl2ZSBwb2ludGVyIGlkLiBFYWNoIG9iamVjdCBoYXMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXHRcdCAqIHgsIHksIGV2ZW50LCB0YXJnZXQsIG92ZXJUYXJnZXQsIG92ZXJYLCBvdmVyWSwgaW5Cb3VuZHMsIHBvc0V2dE9iaiAobmF0aXZlIGV2ZW50IHRoYXQgbGFzdCB1cGRhdGVkIHBvc2l0aW9uKVxuXHRcdCAqIEBwcm9wZXJ0eSBfcG9pbnRlckRhdGFcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcG9pbnRlckRhdGEgPSB7fTtcblx0XG5cdFx0LyoqXG5cdFx0ICogTnVtYmVyIG9mIGFjdGl2ZSBwb2ludGVycy5cblx0XHQgKiBAcHJvcGVydHkgX3BvaW50ZXJDb3VudFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9wb2ludGVyQ291bnQgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgSUQgb2YgdGhlIHByaW1hcnkgcG9pbnRlci5cblx0XHQgKiBAcHJvcGVydHkgX3ByaW1hcnlQb2ludGVySURcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcHJpbWFyeVBvaW50ZXJJRCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbW91c2VPdmVySW50ZXJ2YWxJRFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fbW91c2VPdmVySW50ZXJ2YWxJRCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9uZXh0U3RhZ2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgU3RhZ2Vcblx0XHQgKiovXG5cdFx0dGhpcy5fbmV4dFN0YWdlID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3ByZXZTdGFnZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBTdGFnZVxuXHRcdCAqKi9cblx0XHR0aGlzLl9wcmV2U3RhZ2UgPSBudWxsO1xuXHRcdFxuXHRcdFxuXHQvLyBpbml0aWFsaXplOlxuXHRcdHRoaXMuZW5hYmxlRE9NRXZlbnRzKHRydWUpO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFN0YWdlLCBjcmVhdGVqcy5Db250YWluZXIpO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBldmVudHM6XG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIgbW92ZXMgdGhlIG1vdXNlIG92ZXIgdGhlIGNhbnZhcy5cblx0ICogU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cblx0ICogQGV2ZW50IHN0YWdlbW91c2Vtb3ZlXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgdGhlaXIgbGVmdCBtb3VzZSBidXR0b24gb24gdGhlIGNhbnZhcy4gU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cblx0ICogQGV2ZW50IHN0YWdlbW91c2Vkb3duXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB1c2VyIHRoZSB1c2VyIHByZXNzZXMgc29tZXdoZXJlIG9uIHRoZSBzdGFnZSwgdGhlbiByZWxlYXNlcyB0aGUgbW91c2UgYnV0dG9uIGFueXdoZXJlIHRoYXQgdGhlIHBhZ2UgY2FuIGRldGVjdCBpdCAodGhpcyB2YXJpZXMgc2xpZ2h0bHkgYmV0d2VlbiBicm93c2VycykuXG5cdCAqIFlvdSBjYW4gdXNlIHt7I2Nyb3NzTGluayBcIlN0YWdlL21vdXNlSW5Cb3VuZHM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gdG8gY2hlY2sgd2hldGhlciB0aGUgbW91c2UgaXMgY3VycmVudGx5IHdpdGhpbiB0aGUgc3RhZ2UgYm91bmRzLlxuXHQgKiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxuXHQgKiBAZXZlbnQgc3RhZ2Vtb3VzZXVwXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBmcm9tIHdpdGhpbiB0aGUgY2FudmFzIGFyZWEgKG1vdXNlSW5Cb3VuZHMgPT0gdHJ1ZSkgdG8gb3V0c2lkZSBpdCAobW91c2VJbkJvdW5kcyA9PSBmYWxzZSkuXG5cdCAqIFRoaXMgaXMgY3VycmVudGx5IG9ubHkgZGlzcGF0Y2hlZCBmb3IgbW91c2UgaW5wdXQgKG5vdCB0b3VjaCkuIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXG5cdCAqIEBldmVudCBtb3VzZWxlYXZlXG5cdCAqIEBzaW5jZSAwLjcuMFxuXHQgKi9cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBpbnRvIHRoZSBjYW52YXMgYXJlYSAobW91c2VJbkJvdW5kcyA9PSBmYWxzZSkgZnJvbSBvdXRzaWRlIGl0IChtb3VzZUluQm91bmRzID09IHRydWUpLlxuXHQgKiBUaGlzIGlzIGN1cnJlbnRseSBvbmx5IGRpc3BhdGNoZWQgZm9yIG1vdXNlIGlucHV0IChub3QgdG91Y2gpLiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxuXHQgKiBAZXZlbnQgbW91c2VlbnRlclxuXHQgKiBAc2luY2UgMC43LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgZWFjaCB1cGRhdGUgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSB0aWNrIGV2ZW50IGlzIHByb3BhZ2F0ZWQgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKiBZb3UgY2FuIGNhbGwgcHJldmVudERlZmF1bHQgb24gdGhlIGV2ZW50IG9iamVjdCB0byBjYW5jZWwgcHJvcGFnYXRpbmcgdGhlIHRpY2sgZXZlbnQuXG5cdCAqIEBldmVudCB0aWNrc3RhcnRcblx0ICogQHNpbmNlIDAuNy4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIGVhY2ggdXBkYXRlIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSB0aWNrIGV2ZW50IGlzIHByb3BhZ2F0ZWQgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LiBEb2VzIG5vdCBmaXJlIGlmXG5cdCAqIHRpY2tPblVwZGF0ZSBpcyBmYWxzZS4gUHJlY2VkZXMgdGhlIFwiZHJhd3N0YXJ0XCIgZXZlbnQuXG5cdCAqIEBldmVudCB0aWNrZW5kXG5cdCAqIEBzaW5jZSAwLjcuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCBlYWNoIHVwZGF0ZSBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNhbnZhcyBpcyBjbGVhcmVkIGFuZCB0aGUgZGlzcGxheSBsaXN0IGlzIGRyYXduIHRvIGl0LlxuXHQgKiBZb3UgY2FuIGNhbGwgcHJldmVudERlZmF1bHQgb24gdGhlIGV2ZW50IG9iamVjdCB0byBjYW5jZWwgdGhlIGRyYXcuXG5cdCAqIEBldmVudCBkcmF3c3RhcnRcblx0ICogQHNpbmNlIDAuNy4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIGVhY2ggdXBkYXRlIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBkaXNwbGF5IGxpc3QgaXMgZHJhd24gdG8gdGhlIGNhbnZhcyBhbmQgdGhlIGNhbnZhcyBjb250ZXh0IGlzIHJlc3RvcmVkLlxuXHQgKiBAZXZlbnQgZHJhd2VuZFxuXHQgKiBAc2luY2UgMC43LjBcblx0ICovXG5cblx0IFxuLy8gZ2V0dGVyIC8gc2V0dGVyczpcblx0LyoqXG5cdCAqIFNwZWNpZmllcyBhIHRhcmdldCBzdGFnZSB0aGF0IHdpbGwgaGF2ZSBtb3VzZSAvIHRvdWNoIGludGVyYWN0aW9ucyByZWxheWVkIHRvIGl0IGFmdGVyIHRoaXMgc3RhZ2UgaGFuZGxlcyB0aGVtLlxuXHQgKiBUaGlzIGNhbiBiZSB1c2VmdWwgaW4gY2FzZXMgd2hlcmUgeW91IGhhdmUgbXVsdGlwbGUgbGF5ZXJlZCBjYW52YXNlcyBhbmQgd2FudCB1c2VyIGludGVyYWN0aW9uc1xuXHQgKiBldmVudHMgdG8gcGFzcyB0aHJvdWdoLiBGb3IgZXhhbXBsZSwgdGhpcyB3b3VsZCByZWxheSBtb3VzZSBldmVudHMgZnJvbSB0b3BTdGFnZSB0byBib3R0b21TdGFnZTpcblx0ICpcblx0ICogICAgICB0b3BTdGFnZS5uZXh0U3RhZ2UgPSBib3R0b21TdGFnZTtcblx0ICpcblx0ICogVG8gZGlzYWJsZSByZWxheWluZywgc2V0IG5leHRTdGFnZSB0byBudWxsLlxuXHQgKiBcblx0ICogTW91c2VPdmVyLCBNb3VzZU91dCwgUm9sbE92ZXIsIGFuZCBSb2xsT3V0IGludGVyYWN0aW9ucyBhcmUgYWxzbyBwYXNzZWQgdGhyb3VnaCB1c2luZyB0aGUgbW91c2Ugb3ZlciBzZXR0aW5nc1xuXHQgKiBvZiB0aGUgdG9wLW1vc3Qgc3RhZ2UsIGJ1dCBhcmUgb25seSBwcm9jZXNzZWQgaWYgdGhlIHRhcmdldCBzdGFnZSBoYXMgbW91c2Ugb3ZlciBpbnRlcmFjdGlvbnMgZW5hYmxlZC5cblx0ICogQ29uc2lkZXJhdGlvbnMgd2hlbiB1c2luZyByb2xsIG92ZXIgaW4gcmVsYXkgdGFyZ2V0czo8T0w+XG5cdCAqIDxMST4gVGhlIHRvcC1tb3N0IChmaXJzdCkgc3RhZ2UgbXVzdCBoYXZlIG1vdXNlIG92ZXIgaW50ZXJhY3Rpb25zIGVuYWJsZWQgKHZpYSBlbmFibGVNb3VzZU92ZXIpPC9MST5cblx0ICogPExJPiBBbGwgc3RhZ2VzIHRoYXQgd2lzaCB0byBwYXJ0aWNpcGF0ZSBpbiBtb3VzZSBvdmVyIGludGVyYWN0aW9uIG11c3QgZW5hYmxlIHRoZW0gdmlhIGVuYWJsZU1vdXNlT3ZlcjwvTEk+XG5cdCAqIDxMST4gQWxsIHJlbGF5IHRhcmdldHMgd2lsbCBzaGFyZSB0aGUgZnJlcXVlbmN5IHZhbHVlIG9mIHRoZSB0b3AtbW9zdCBzdGFnZTwvTEk+XG5cdCAqIDwvT0w+XG5cdCAqIFRvIGlsbHVzdHJhdGUsIGluIHRoaXMgZXhhbXBsZSB0aGUgdGFyZ2V0U3RhZ2Ugd291bGQgcHJvY2VzcyBtb3VzZSBvdmVyIGludGVyYWN0aW9ucyBhdCAxMGh6IChkZXNwaXRlIHBhc3Npbmdcblx0ICogMzAgYXMgaXQncyBkZXNpcmVkIGZyZXF1ZW5jeSk6XG5cdCAqIFx0dG9wU3RhZ2UubmV4dFN0YWdlID0gdGFyZ2V0U3RhZ2U7XG5cdCAqIFx0dG9wU3RhZ2UuZW5hYmxlTW91c2VPdmVyKDEwKTtcblx0ICogXHR0YXJnZXRTdGFnZS5lbmFibGVNb3VzZU92ZXIoMzApO1xuXHQgKiBcblx0ICogSWYgdGhlIHRhcmdldCBzdGFnZSdzIGNhbnZhcyBpcyBjb21wbGV0ZWx5IGNvdmVyZWQgYnkgdGhpcyBzdGFnZSdzIGNhbnZhcywgeW91IG1heSBhbHNvIHdhbnQgdG8gZGlzYWJsZSBpdHNcblx0ICogRE9NIGV2ZW50cyB1c2luZzpcblx0ICogXG5cdCAqXHR0YXJnZXRTdGFnZS5lbmFibGVET01FdmVudHMoZmFsc2UpO1xuXHQgKiBcblx0ICogQHByb3BlcnR5IG5leHRTdGFnZVxuXHQgKiBAdHlwZSB7U3RhZ2V9XG5cdCAqKi9cblx0cC5fZ2V0X25leHRTdGFnZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9uZXh0U3RhZ2U7XG5cdH07XG5cdHAuX3NldF9uZXh0U3RhZ2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh0aGlzLl9uZXh0U3RhZ2UpIHsgdGhpcy5fbmV4dFN0YWdlLl9wcmV2U3RhZ2UgPSBudWxsOyB9XG5cdFx0aWYgKHZhbHVlKSB7IHZhbHVlLl9wcmV2U3RhZ2UgPSB0aGlzOyB9XG5cdFx0dGhpcy5fbmV4dFN0YWdlID0gdmFsdWU7XG5cdH07XG5cdFxuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcblx0XHRcdG5leHRTdGFnZTogeyBnZXQ6IHAuX2dldF9uZXh0U3RhZ2UsIHNldDogcC5fc2V0X25leHRTdGFnZSB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHt9IC8vIFRPRE86IHVzZSBMb2dcblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEVhY2ggdGltZSB0aGUgdXBkYXRlIG1ldGhvZCBpcyBjYWxsZWQsIHRoZSBzdGFnZSB3aWxsIGNhbGwge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdGlja1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB1bmxlc3Mge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdGlja09uVXBkYXRlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlzIHNldCB0byBmYWxzZSxcblx0ICogYW5kIHRoZW4gcmVuZGVyIHRoZSBkaXNwbGF5IGxpc3QgdG8gdGhlIGNhbnZhcy5cblx0ICpcblx0ICogQG1ldGhvZCB1cGRhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gUHJvcHMgb2JqZWN0IHRvIHBhc3MgdG8gYHRpY2soKWAuIFNob3VsZCB1c3VhbGx5IGJlIGEge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IG9iamVjdCwgb3Igc2ltaWxhciBvYmplY3Qgd2l0aCBhIGRlbHRhIHByb3BlcnR5LlxuXHQgKiovXG5cdHAudXBkYXRlID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRpZiAoIXRoaXMuY2FudmFzKSB7IHJldHVybjsgfVxuXHRcdGlmICh0aGlzLnRpY2tPblVwZGF0ZSkgeyB0aGlzLnRpY2socHJvcHMpOyB9XG5cdFx0aWYgKHRoaXMuZGlzcGF0Y2hFdmVudChcImRyYXdzdGFydFwiLCBmYWxzZSwgdHJ1ZSkgPT09IGZhbHNlKSB7IHJldHVybjsgfVxuXHRcdGNyZWF0ZWpzLkRpc3BsYXlPYmplY3QuX3NuYXBUb1BpeGVsRW5hYmxlZCA9IHRoaXMuc25hcFRvUGl4ZWxFbmFibGVkO1xuXHRcdHZhciByID0gdGhpcy5kcmF3UmVjdCwgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0aWYgKHRoaXMuYXV0b0NsZWFyKSB7XG5cdFx0XHRpZiAocikgeyBjdHguY2xlYXJSZWN0KHIueCwgci55LCByLndpZHRoLCByLmhlaWdodCk7IH1cblx0XHRcdGVsc2UgeyBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoKzEsIHRoaXMuY2FudmFzLmhlaWdodCsxKTsgfVxuXHRcdH1cblx0XHRjdHguc2F2ZSgpO1xuXHRcdGlmICh0aGlzLmRyYXdSZWN0KSB7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHgucmVjdChyLngsIHIueSwgci53aWR0aCwgci5oZWlnaHQpO1xuXHRcdFx0Y3R4LmNsaXAoKTtcblx0XHR9XG5cdFx0dGhpcy51cGRhdGVDb250ZXh0KGN0eCk7XG5cdFx0dGhpcy5kcmF3KGN0eCwgZmFsc2UpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiZHJhd2VuZFwiKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBQcm9wYWdhdGVzIGEgdGljayBldmVudCB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuIFRoaXMgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgYnkge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdXBkYXRlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHVubGVzcyB7eyNjcm9zc0xpbmsgXCJTdGFnZS90aWNrT25VcGRhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaXMgc2V0IHRvIGZhbHNlLlxuXHQgKlxuXHQgKiBJZiBhIHByb3BzIG9iamVjdCBpcyBwYXNzZWQgdG8gYHRpY2soKWAsIHRoZW4gYWxsIG9mIGl0cyBwcm9wZXJ0aWVzIHdpbGwgYmUgY29waWVkIHRvIHRoZSBldmVudCBvYmplY3QgdGhhdCBpc1xuXHQgKiBwcm9wYWdhdGVkIHRvIGxpc3RlbmVycy5cblx0ICpcblx0ICogU29tZSB0aW1lLWJhc2VkIGZlYXR1cmVzIGluIEVhc2VsSlMgKGZvciBleGFtcGxlIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9mcmFtZXJhdGVcIn19e3svY3Jvc3NMaW5rfX0gcmVxdWlyZSB0aGF0XG5cdCAqIGEge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgb2JqZWN0IChvciBlcXVpdmFsZW50IG9iamVjdCB3aXRoIGEgZGVsdGEgcHJvcGVydHkpIGJlXG5cdCAqIHBhc3NlZCBhcyB0aGUgYHByb3BzYCBwYXJhbWV0ZXIgdG8gYHRpY2soKWAuIEZvciBleGFtcGxlOlxuXHQgKlxuXHQgKiBcdFRpY2tlci5vbihcInRpY2tcIiwgaGFuZGxlVGljayk7XG5cdCAqIFx0ZnVuY3Rpb24gaGFuZGxlVGljayhldnRPYmopIHtcblx0ICogXHRcdC8vIGNsb25lIHRoZSBldmVudCBvYmplY3QgZnJvbSBUaWNrZXIsIGFuZCBhZGQgc29tZSBjdXN0b20gZGF0YSB0byBpdDpcblx0ICogXHRcdHZhciBldnQgPSBldnRPYmouY2xvbmUoKS5zZXQoe2dyZWV0aW5nOlwiaGVsbG9cIiwgbmFtZTpcIndvcmxkXCJ9KTtcblx0ICogXHRcdFxuXHQgKiBcdFx0Ly8gcGFzcyBpdCB0byBzdGFnZS51cGRhdGUoKTpcblx0ICogXHRcdG15U3RhZ2UudXBkYXRlKGV2dCk7IC8vIHN1YnNlcXVlbnRseSBjYWxscyB0aWNrKCkgd2l0aCB0aGUgc2FtZSBwYXJhbVxuXHQgKiBcdH1cblx0ICogXHRcblx0ICogXHQvLyAuLi5cblx0ICogXHRteURpc3BsYXlPYmplY3Qub24oXCJ0aWNrXCIsIGhhbmRsZURpc3BsYXlPYmplY3RUaWNrKTtcblx0ICogXHRmdW5jdGlvbiBoYW5kbGVEaXNwbGF5T2JqZWN0VGljayhldnQpIHtcblx0ICogXHRcdGNvbnNvbGUubG9nKGV2dC5kZWx0YSk7IC8vIHRoZSBkZWx0YSBwcm9wZXJ0eSBmcm9tIHRoZSBUaWNrZXIgdGljayBldmVudCBvYmplY3Rcblx0ICogXHRcdGNvbnNvbGUubG9nKGV2dC5ncmVldGluZywgZXZ0Lm5hbWUpOyAvLyBjdXN0b20gZGF0YTogXCJoZWxsbyB3b3JsZFwiXG5cdCAqIFx0fVxuXHQgKiBcblx0ICogQG1ldGhvZCB0aWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIEFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgY29waWVkIHRvIHRoZSBldmVudCBvYmplY3QuIFNob3VsZCB1c3VhbGx5IGJlIGEgVGlja2VyIGV2ZW50IG9iamVjdCwgb3Igc2ltaWxhciBvYmplY3Qgd2l0aCBhIGRlbHRhIHByb3BlcnR5LlxuXHQgKiovXG5cdHAudGljayA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0aWYgKCF0aGlzLnRpY2tFbmFibGVkIHx8IHRoaXMuZGlzcGF0Y2hFdmVudChcInRpY2tzdGFydFwiLCBmYWxzZSwgdHJ1ZSkgPT09IGZhbHNlKSB7IHJldHVybjsgfVxuXHRcdHZhciBldnRPYmogPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJ0aWNrXCIpO1xuXHRcdGlmIChwcm9wcykge1xuXHRcdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykge1xuXHRcdFx0XHRpZiAocHJvcHMuaGFzT3duUHJvcGVydHkobikpIHsgZXZ0T2JqW25dID0gcHJvcHNbbl07IH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fdGljayhldnRPYmopO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcInRpY2tlbmRcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlZmF1bHQgZXZlbnQgaGFuZGxlciB0aGF0IGNhbGxzIHRoZSBTdGFnZSB7eyNjcm9zc0xpbmsgXCJTdGFnZS91cGRhdGVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIHdoZW4gYSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgaXMgcmVjZWl2ZWQuIFRoaXMgYWxsb3dzIHlvdSB0byByZWdpc3RlciBhIFN0YWdlIGluc3RhbmNlIGFzIGEgZXZlbnQgbGlzdGVuZXIgb24ge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGRpcmVjdGx5LCB1c2luZzpcblx0ICpcblx0ICogICAgICBUaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgbXlTdGFnZVwiKTtcblx0ICpcblx0ICogTm90ZSB0aGF0IGlmIHlvdSBzdWJzY3JpYmUgdG8gdGlja3MgdXNpbmcgdGhpcyBwYXR0ZXJuLCB0aGVuIHRoZSB0aWNrIGV2ZW50IG9iamVjdCB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHRvXG5cdCAqIGRpc3BsYXkgb2JqZWN0IHRpY2sgaGFuZGxlcnMsIGluc3RlYWQgb2YgPGNvZGU+ZGVsdGE8L2NvZGU+IGFuZCA8Y29kZT5wYXVzZWQ8L2NvZGU+IHBhcmFtZXRlcnMuXG5cdCAqIEBwcm9wZXJ0eSBoYW5kbGVFdmVudFxuXHQgKiBAdHlwZSBGdW5jdGlvblxuXHQgKiovXG5cdHAuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbihldnQpIHtcblx0XHRpZiAoZXZ0LnR5cGUgPT0gXCJ0aWNrXCIpIHsgdGhpcy51cGRhdGUoZXZ0KTsgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhcnMgdGhlIHRhcmdldCBjYW52YXMuIFVzZWZ1bCBpZiB7eyNjcm9zc0xpbmsgXCJTdGFnZS9hdXRvQ2xlYXI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaXMgc2V0IHRvIGBmYWxzZWAuXG5cdCAqIEBtZXRob2QgY2xlYXJcblx0ICoqL1xuXHRwLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmNhbnZhcykgeyByZXR1cm47IH1cblx0XHR2YXIgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCsxLCB0aGlzLmNhbnZhcy5oZWlnaHQrMSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBkYXRhIHVybCB0aGF0IGNvbnRhaW5zIGEgQmFzZTY0LWVuY29kZWQgaW1hZ2Ugb2YgdGhlIGNvbnRlbnRzIG9mIHRoZSBzdGFnZS4gVGhlIHJldHVybmVkIGRhdGEgdXJsIGNhblxuXHQgKiBiZSBzcGVjaWZpZWQgYXMgdGhlIHNyYyB2YWx1ZSBvZiBhbiBpbWFnZSBlbGVtZW50LlxuXHQgKiBAbWV0aG9kIHRvRGF0YVVSTFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2JhY2tncm91bmRDb2xvcl0gVGhlIGJhY2tncm91bmQgY29sb3IgdG8gYmUgdXNlZCBmb3IgdGhlIGdlbmVyYXRlZCBpbWFnZS4gQW55IHZhbGlkIENTUyBjb2xvclxuXHQgKiB2YWx1ZSBpcyBhbGxvd2VkLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBhIHRyYW5zcGFyZW50IGJhY2tncm91bmQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbbWltZVR5cGU9XCJpbWFnZS9wbmdcIl0gVGhlIE1JTUUgdHlwZSBvZiB0aGUgaW1hZ2UgZm9ybWF0IHRvIGJlIGNyZWF0ZS4gVGhlIGRlZmF1bHQgaXMgXCJpbWFnZS9wbmdcIi4gSWYgYW4gdW5rbm93biBNSU1FIHR5cGVcblx0ICogaXMgcGFzc2VkIGluLCBvciBpZiB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBzcGVjaWZpZWQgTUlNRSB0eXBlLCB0aGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBCYXNlNjQgZW5jb2RlZCBpbWFnZS5cblx0ICoqL1xuXHRwLnRvRGF0YVVSTCA9IGZ1bmN0aW9uKGJhY2tncm91bmRDb2xvciwgbWltZVR5cGUpIHtcblx0XHR2YXIgZGF0YSwgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKSwgdyA9IHRoaXMuY2FudmFzLndpZHRoLCBoID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuXG5cdFx0aWYgKGJhY2tncm91bmRDb2xvcikge1xuXHRcdFx0ZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdywgaCk7XG5cdFx0XHR2YXIgY29tcG9zaXRlT3BlcmF0aW9uID0gY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcblx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLW92ZXJcIjtcblx0XHRcdFxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcblx0XHRcdGN0eC5maWxsUmVjdCgwLCAwLCB3LCBoKTtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVVSTCA9IHRoaXMuY2FudmFzLnRvRGF0YVVSTChtaW1lVHlwZXx8XCJpbWFnZS9wbmdcIik7XG5cblx0XHRpZihiYWNrZ3JvdW5kQ29sb3IpIHtcblx0XHRcdGN0eC5wdXRJbWFnZURhdGEoZGF0YSwgMCwgMCk7XG5cdFx0XHRjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gY29tcG9zaXRlT3BlcmF0aW9uO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhVVJMO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbmFibGVzIG9yIGRpc2FibGVzIChieSBwYXNzaW5nIGEgZnJlcXVlbmN5IG9mIDApIG1vdXNlIG92ZXIgKHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2VvdmVyOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFuZCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlb3V0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319KSBhbmQgcm9sbCBvdmVyIGV2ZW50cyAoe3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9yb2xsb3ZlcjpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBhbmQge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9yb2xsb3V0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319KSBmb3IgdGhpcyBzdGFnZSdzIGRpc3BsYXkgbGlzdC4gVGhlc2UgZXZlbnRzIGNhblxuXHQgKiBiZSBleHBlbnNpdmUgdG8gZ2VuZXJhdGUsIHNvIHRoZXkgYXJlIGRpc2FibGVkIGJ5IGRlZmF1bHQuIFRoZSBmcmVxdWVuY3kgb2YgdGhlIGV2ZW50cyBjYW4gYmUgY29udHJvbGxlZFxuXHQgKiBpbmRlcGVuZGVudGx5IG9mIG1vdXNlIG1vdmUgZXZlbnRzIHZpYSB0aGUgb3B0aW9uYWwgYGZyZXF1ZW5jeWAgcGFyYW1ldGVyLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIHN0YWdlID0gbmV3IGNyZWF0ZWpzLlN0YWdlKFwiY2FudmFzSWRcIik7XG5cdCAqICAgICAgc3RhZ2UuZW5hYmxlTW91c2VPdmVyKDEwKTsgLy8gMTAgdXBkYXRlcyBwZXIgc2Vjb25kXG5cdCAqXG5cdCAqIEBtZXRob2QgZW5hYmxlTW91c2VPdmVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZnJlcXVlbmN5PTIwXSBPcHRpb25hbCBwYXJhbSBzcGVjaWZ5aW5nIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyBwZXIgc2Vjb25kIHRvIGJyb2FkY2FzdFxuXHQgKiBtb3VzZSBvdmVyL291dCBldmVudHMuIFNldCB0byAwIHRvIGRpc2FibGUgbW91c2Ugb3ZlciBldmVudHMgY29tcGxldGVseS4gTWF4aW11bSBpcyA1MC4gQSBsb3dlciBmcmVxdWVuY3kgaXMgbGVzc1xuXHQgKiByZXNwb25zaXZlLCBidXQgdXNlcyBsZXNzIENQVS5cblx0ICoqL1xuXHRwLmVuYWJsZU1vdXNlT3ZlciA9IGZ1bmN0aW9uKGZyZXF1ZW5jeSkge1xuXHRcdGlmICh0aGlzLl9tb3VzZU92ZXJJbnRlcnZhbElEKSB7XG5cdFx0XHRjbGVhckludGVydmFsKHRoaXMuX21vdXNlT3ZlckludGVydmFsSUQpO1xuXHRcdFx0dGhpcy5fbW91c2VPdmVySW50ZXJ2YWxJRCA9IG51bGw7XG5cdFx0XHRpZiAoZnJlcXVlbmN5ID09IDApIHtcblx0XHRcdFx0dGhpcy5fdGVzdE1vdXNlT3Zlcih0cnVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGZyZXF1ZW5jeSA9PSBudWxsKSB7IGZyZXF1ZW5jeSA9IDIwOyB9XG5cdFx0ZWxzZSBpZiAoZnJlcXVlbmN5IDw9IDApIHsgcmV0dXJuOyB9XG5cdFx0dmFyIG8gPSB0aGlzO1xuXHRcdHRoaXMuX21vdXNlT3ZlckludGVydmFsSUQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpeyBvLl90ZXN0TW91c2VPdmVyKCk7IH0sIDEwMDAvTWF0aC5taW4oNTAsZnJlcXVlbmN5KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHN0YWdlIGFkZHMgdG8gRE9NIGVsZW1lbnRzICh3aW5kb3csIGRvY3VtZW50IGFuZCBjYW52YXMpLiBJdCBpcyBnb29kXG5cdCAqIHByYWN0aWNlIHRvIGRpc2FibGUgZXZlbnRzIHdoZW4gZGlzcG9zaW5nIG9mIGEgU3RhZ2UgaW5zdGFuY2UsIG90aGVyd2lzZSB0aGUgc3RhZ2Ugd2lsbCBjb250aW51ZSB0byByZWNlaXZlXG5cdCAqIGV2ZW50cyBmcm9tIHRoZSBwYWdlLlxuXHQgKlxuXHQgKiBXaGVuIGNoYW5naW5nIHRoZSBjYW52YXMgcHJvcGVydHkgeW91IG11c3QgZGlzYWJsZSB0aGUgZXZlbnRzIG9uIHRoZSBvbGQgY2FudmFzLCBhbmQgZW5hYmxlIGV2ZW50cyBvbiB0aGVcblx0ICogbmV3IGNhbnZhcyBvciBtb3VzZSBldmVudHMgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZC4gRm9yIGV4YW1wbGU6XG5cdCAqXG5cdCAqICAgICAgbXlTdGFnZS5lbmFibGVET01FdmVudHMoZmFsc2UpO1xuXHQgKiAgICAgIG15U3RhZ2UuY2FudmFzID0gYW5vdGhlckNhbnZhcztcblx0ICogICAgICBteVN0YWdlLmVuYWJsZURPTUV2ZW50cyh0cnVlKTtcblx0ICpcblx0ICogQG1ldGhvZCBlbmFibGVET01FdmVudHNcblx0ICogQHBhcmFtIHtCb29sZWFufSBbZW5hYmxlPXRydWVdIEluZGljYXRlcyB3aGV0aGVyIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBldmVudHMuIERlZmF1bHQgaXMgdHJ1ZS5cblx0ICoqL1xuXHRwLmVuYWJsZURPTUV2ZW50cyA9IGZ1bmN0aW9uKGVuYWJsZSkge1xuXHRcdGlmIChlbmFibGUgPT0gbnVsbCkgeyBlbmFibGUgPSB0cnVlOyB9XG5cdFx0dmFyIG4sIG8sIGxzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnM7XG5cdFx0aWYgKCFlbmFibGUgJiYgbHMpIHtcblx0XHRcdGZvciAobiBpbiBscykge1xuXHRcdFx0XHRvID0gbHNbbl07XG5cdFx0XHRcdG8udC5yZW1vdmVFdmVudExpc3RlbmVyKG4sIG8uZiwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSBudWxsO1xuXHRcdH0gZWxzZSBpZiAoZW5hYmxlICYmICFscyAmJiB0aGlzLmNhbnZhcykge1xuXHRcdFx0dmFyIHQgPSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciA/IHdpbmRvdyA6IGRvY3VtZW50O1xuXHRcdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHRcdGxzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSB7fTtcblx0XHRcdGxzW1wibW91c2V1cFwiXSA9IHt0OnQsIGY6ZnVuY3Rpb24oZSkgeyBfdGhpcy5faGFuZGxlTW91c2VVcChlKX0gfTtcblx0XHRcdGxzW1wibW91c2Vtb3ZlXCJdID0ge3Q6dCwgZjpmdW5jdGlvbihlKSB7IF90aGlzLl9oYW5kbGVNb3VzZU1vdmUoZSl9IH07XG5cdFx0XHRsc1tcImRibGNsaWNrXCJdID0ge3Q6dGhpcy5jYW52YXMsIGY6ZnVuY3Rpb24oZSkgeyBfdGhpcy5faGFuZGxlRG91YmxlQ2xpY2soZSl9IH07XG5cdFx0XHRsc1tcIm1vdXNlZG93blwiXSA9IHt0OnRoaXMuY2FudmFzLCBmOmZ1bmN0aW9uKGUpIHsgX3RoaXMuX2hhbmRsZU1vdXNlRG93bihlKX0gfTtcblxuXHRcdFx0Zm9yIChuIGluIGxzKSB7XG5cdFx0XHRcdG8gPSBsc1tuXTtcblx0XHRcdFx0by50LmFkZEV2ZW50TGlzdGVuZXIobiwgby5mLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdGFnZSBpbnN0YW5jZXMgY2Fubm90IGJlIGNsb25lZC5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyhcIlN0YWdlIGNhbm5vdCBiZSBjbG9uZWQuXCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbU3RhZ2UgKG5hbWU9XCIrICB0aGlzLm5hbWUgK1wiKV1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRFbGVtZW50UmVjdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVcblx0ICoqL1xuXHRwLl9nZXRFbGVtZW50UmVjdCA9IGZ1bmN0aW9uKGUpIHtcblx0XHR2YXIgYm91bmRzO1xuXHRcdHRyeSB7IGJvdW5kcyA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IH0gLy8gdGhpcyBjYW4gZmFpbCBvbiBkaXNjb25uZWN0ZWQgRE9NIGVsZW1lbnRzIGluIElFOVxuXHRcdGNhdGNoIChlcnIpIHsgYm91bmRzID0ge3RvcDogZS5vZmZzZXRUb3AsIGxlZnQ6IGUub2Zmc2V0TGVmdCwgd2lkdGg6ZS5vZmZzZXRXaWR0aCwgaGVpZ2h0OmUub2Zmc2V0SGVpZ2h0fTsgfVxuXG5cdFx0dmFyIG9mZlggPSAod2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LnNjcm9sbExlZnQgfHwgMCkgLSAoZG9jdW1lbnQuY2xpZW50TGVmdCB8fCBkb2N1bWVudC5ib2R5LmNsaWVudExlZnQgfHwgMCk7XG5cdFx0dmFyIG9mZlkgPSAod2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LnNjcm9sbFRvcCB8fCAwKSAtIChkb2N1bWVudC5jbGllbnRUb3AgIHx8IGRvY3VtZW50LmJvZHkuY2xpZW50VG9wICB8fCAwKTtcblxuXHRcdHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA/IGdldENvbXB1dGVkU3R5bGUoZSxudWxsKSA6IGUuY3VycmVudFN0eWxlOyAvLyBJRSA8OSBjb21wYXRpYmlsaXR5LlxuXHRcdHZhciBwYWRMID0gcGFyc2VJbnQoc3R5bGVzLnBhZGRpbmdMZWZ0KStwYXJzZUludChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoKTtcblx0XHR2YXIgcGFkVCA9IHBhcnNlSW50KHN0eWxlcy5wYWRkaW5nVG9wKStwYXJzZUludChzdHlsZXMuYm9yZGVyVG9wV2lkdGgpO1xuXHRcdHZhciBwYWRSID0gcGFyc2VJbnQoc3R5bGVzLnBhZGRpbmdSaWdodCkrcGFyc2VJbnQoc3R5bGVzLmJvcmRlclJpZ2h0V2lkdGgpO1xuXHRcdHZhciBwYWRCID0gcGFyc2VJbnQoc3R5bGVzLnBhZGRpbmdCb3R0b20pK3BhcnNlSW50KHN0eWxlcy5ib3JkZXJCb3R0b21XaWR0aCk7XG5cblx0XHQvLyBub3RlOiBpbiBzb21lIGJyb3dzZXJzIGJvdW5kcyBwcm9wZXJ0aWVzIGFyZSByZWFkIG9ubHkuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGxlZnQ6IGJvdW5kcy5sZWZ0K29mZlgrcGFkTCxcblx0XHRcdHJpZ2h0OiBib3VuZHMucmlnaHQrb2ZmWC1wYWRSLFxuXHRcdFx0dG9wOiBib3VuZHMudG9wK29mZlkrcGFkVCxcblx0XHRcdGJvdHRvbTogYm91bmRzLmJvdHRvbStvZmZZLXBhZEJcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldFBvaW50ZXJEYXRhXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGlkXG5cdCAqKi9cblx0cC5fZ2V0UG9pbnRlckRhdGEgPSBmdW5jdGlvbihpZCkge1xuXHRcdHZhciBkYXRhID0gdGhpcy5fcG9pbnRlckRhdGFbaWRdO1xuXHRcdGlmICghZGF0YSkgeyBkYXRhID0gdGhpcy5fcG9pbnRlckRhdGFbaWRdID0ge3g6MCx5OjB9OyB9XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1vdXNlTW92ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuXHQgKiovXG5cdHAuX2hhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uKGUpIHtcblx0XHRpZighZSl7IGUgPSB3aW5kb3cuZXZlbnQ7IH1cblx0XHR0aGlzLl9oYW5kbGVQb2ludGVyTW92ZSgtMSwgZSwgZS5wYWdlWCwgZS5wYWdlWSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVBvaW50ZXJNb3ZlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGlkXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2VYXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlWVxuXHQgKiBAcGFyYW0ge1N0YWdlfSBvd25lciBJbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgaGFzIGFscmVhZHkgYmVlbiBjYXB0dXJlZCAmIGhhbmRsZWQgYnkgdGhlIGluZGljYXRlZCBzdGFnZS5cblx0ICoqL1xuXHRwLl9oYW5kbGVQb2ludGVyTW92ZSA9IGZ1bmN0aW9uKGlkLCBlLCBwYWdlWCwgcGFnZVksIG93bmVyKSB7XG5cdFx0aWYgKHRoaXMuX3ByZXZTdGFnZSAmJiBvd25lciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfSAvLyByZWR1bmRhbnQgbGlzdGVuZXIuXG5cdFx0aWYgKCF0aGlzLmNhbnZhcykgeyByZXR1cm47IH1cblx0XHR2YXIgbmV4dFN0YWdlPXRoaXMuX25leHRTdGFnZSwgbz10aGlzLl9nZXRQb2ludGVyRGF0YShpZCk7XG5cblx0XHR2YXIgaW5Cb3VuZHMgPSBvLmluQm91bmRzO1xuXHRcdHRoaXMuX3VwZGF0ZVBvaW50ZXJQb3NpdGlvbihpZCwgZSwgcGFnZVgsIHBhZ2VZKTtcblx0XHRpZiAoaW5Cb3VuZHMgfHwgby5pbkJvdW5kcyB8fCB0aGlzLm1vdXNlTW92ZU91dHNpZGUpIHtcblx0XHRcdGlmIChpZCA9PT0gLTEgJiYgby5pbkJvdW5kcyA9PSAhaW5Cb3VuZHMpIHtcblx0XHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRoaXMsIChpbkJvdW5kcyA/IFwibW91c2VsZWF2ZVwiIDogXCJtb3VzZWVudGVyXCIpLCBmYWxzZSwgaWQsIG8sIGUpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQodGhpcywgXCJzdGFnZW1vdXNlbW92ZVwiLCBmYWxzZSwgaWQsIG8sIGUpO1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KG8udGFyZ2V0LCBcInByZXNzbW92ZVwiLCB0cnVlLCBpZCwgbywgZSk7XG5cdFx0fVxuXHRcdFxuXHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl9oYW5kbGVQb2ludGVyTW92ZShpZCwgZSwgcGFnZVgsIHBhZ2VZLCBudWxsKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfdXBkYXRlUG9pbnRlclBvc2l0aW9uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGlkXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2VYXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlWVxuXHQgKiovXG5cdHAuX3VwZGF0ZVBvaW50ZXJQb3NpdGlvbiA9IGZ1bmN0aW9uKGlkLCBlLCBwYWdlWCwgcGFnZVkpIHtcblx0XHR2YXIgcmVjdCA9IHRoaXMuX2dldEVsZW1lbnRSZWN0KHRoaXMuY2FudmFzKTtcblx0XHRwYWdlWCAtPSByZWN0LmxlZnQ7XG5cdFx0cGFnZVkgLT0gcmVjdC50b3A7XG5cblx0XHR2YXIgdyA9IHRoaXMuY2FudmFzLndpZHRoO1xuXHRcdHZhciBoID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuXHRcdHBhZ2VYIC89IChyZWN0LnJpZ2h0LXJlY3QubGVmdCkvdztcblx0XHRwYWdlWSAvPSAocmVjdC5ib3R0b20tcmVjdC50b3ApL2g7XG5cdFx0dmFyIG8gPSB0aGlzLl9nZXRQb2ludGVyRGF0YShpZCk7XG5cdFx0aWYgKG8uaW5Cb3VuZHMgPSAocGFnZVggPj0gMCAmJiBwYWdlWSA+PSAwICYmIHBhZ2VYIDw9IHctMSAmJiBwYWdlWSA8PSBoLTEpKSB7XG5cdFx0XHRvLnggPSBwYWdlWDtcblx0XHRcdG8ueSA9IHBhZ2VZO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5tb3VzZU1vdmVPdXRzaWRlKSB7XG5cdFx0XHRvLnggPSBwYWdlWCA8IDAgPyAwIDogKHBhZ2VYID4gdy0xID8gdy0xIDogcGFnZVgpO1xuXHRcdFx0by55ID0gcGFnZVkgPCAwID8gMCA6IChwYWdlWSA+IGgtMSA/IGgtMSA6IHBhZ2VZKTtcblx0XHR9XG5cblx0XHRvLnBvc0V2dE9iaiA9IGU7XG5cdFx0by5yYXdYID0gcGFnZVg7XG5cdFx0by5yYXdZID0gcGFnZVk7XG5cblx0XHRpZiAoaWQgPT09IHRoaXMuX3ByaW1hcnlQb2ludGVySUQgfHwgaWQgPT09IC0xKSB7XG5cdFx0XHR0aGlzLm1vdXNlWCA9IG8ueDtcblx0XHRcdHRoaXMubW91c2VZID0gby55O1xuXHRcdFx0dGhpcy5tb3VzZUluQm91bmRzID0gby5pbkJvdW5kcztcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1vdXNlVXBcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcblx0ICoqL1xuXHRwLl9oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24oZSkge1xuXHRcdHRoaXMuX2hhbmRsZVBvaW50ZXJVcCgtMSwgZSwgZmFsc2UpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVQb2ludGVyVXBcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaWRcblx0ICogQHBhcmFtIHtFdmVudH0gZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNsZWFyXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IG93bmVyIEluZGljYXRlcyB0aGF0IHRoZSBldmVudCBoYXMgYWxyZWFkeSBiZWVuIGNhcHR1cmVkICYgaGFuZGxlZCBieSB0aGUgaW5kaWNhdGVkIHN0YWdlLlxuXHQgKiovXG5cdHAuX2hhbmRsZVBvaW50ZXJVcCA9IGZ1bmN0aW9uKGlkLCBlLCBjbGVhciwgb3duZXIpIHtcblx0XHR2YXIgbmV4dFN0YWdlID0gdGhpcy5fbmV4dFN0YWdlLCBvID0gdGhpcy5fZ2V0UG9pbnRlckRhdGEoaWQpO1xuXHRcdGlmICh0aGlzLl9wcmV2U3RhZ2UgJiYgb3duZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm47IH0gLy8gcmVkdW5kYW50IGxpc3RlbmVyLlxuXHRcdFxuXHRcdHZhciB0YXJnZXQ9bnVsbCwgb1RhcmdldCA9IG8udGFyZ2V0O1xuXHRcdGlmICghb3duZXIgJiYgKG9UYXJnZXQgfHwgbmV4dFN0YWdlKSkgeyB0YXJnZXQgPSB0aGlzLl9nZXRPYmplY3RzVW5kZXJQb2ludChvLngsIG8ueSwgbnVsbCwgdHJ1ZSk7IH1cblx0XHRcblx0XHRpZiAoby5kb3duKSB7IHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudCh0aGlzLCBcInN0YWdlbW91c2V1cFwiLCBmYWxzZSwgaWQsIG8sIGUsIHRhcmdldCk7IG8uZG93biA9IGZhbHNlOyB9XG5cdFx0XG5cdFx0aWYgKHRhcmdldCA9PSBvVGFyZ2V0KSB7IHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudChvVGFyZ2V0LCBcImNsaWNrXCIsIHRydWUsIGlkLCBvLCBlKTsgfVxuXHRcdHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudChvVGFyZ2V0LCBcInByZXNzdXBcIiwgdHJ1ZSwgaWQsIG8sIGUpO1xuXHRcdFxuXHRcdGlmIChjbGVhcikge1xuXHRcdFx0aWYgKGlkPT10aGlzLl9wcmltYXJ5UG9pbnRlcklEKSB7IHRoaXMuX3ByaW1hcnlQb2ludGVySUQgPSBudWxsOyB9XG5cdFx0XHRkZWxldGUodGhpcy5fcG9pbnRlckRhdGFbaWRdKTtcblx0XHR9IGVsc2UgeyBvLnRhcmdldCA9IG51bGw7IH1cblx0XHRcblx0XHRuZXh0U3RhZ2UmJm5leHRTdGFnZS5faGFuZGxlUG9pbnRlclVwKGlkLCBlLCBjbGVhciwgb3duZXIgfHwgdGFyZ2V0ICYmIHRoaXMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNb3VzZURvd25cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcblx0ICoqL1xuXHRwLl9oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbihlKSB7XG5cdFx0dGhpcy5faGFuZGxlUG9pbnRlckRvd24oLTEsIGUsIGUucGFnZVgsIGUucGFnZVkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVQb2ludGVyRG93blxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlWFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGFnZVlcblx0ICogQHBhcmFtIHtTdGFnZX0gb3duZXIgSW5kaWNhdGVzIHRoYXQgdGhlIGV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gY2FwdHVyZWQgJiBoYW5kbGVkIGJ5IHRoZSBpbmRpY2F0ZWQgc3RhZ2UuXG5cdCAqKi9cblx0cC5faGFuZGxlUG9pbnRlckRvd24gPSBmdW5jdGlvbihpZCwgZSwgcGFnZVgsIHBhZ2VZLCBvd25lcikge1xuXHRcdGlmICh0aGlzLnByZXZlbnRTZWxlY3Rpb24pIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG5cdFx0aWYgKHRoaXMuX3ByaW1hcnlQb2ludGVySUQgPT0gbnVsbCB8fCBpZCA9PT0gLTEpIHsgdGhpcy5fcHJpbWFyeVBvaW50ZXJJRCA9IGlkOyB9IC8vIG1vdXNlIGFsd2F5cyB0YWtlcyBvdmVyLlxuXHRcdFxuXHRcdGlmIChwYWdlWSAhPSBudWxsKSB7IHRoaXMuX3VwZGF0ZVBvaW50ZXJQb3NpdGlvbihpZCwgZSwgcGFnZVgsIHBhZ2VZKTsgfVxuXHRcdHZhciB0YXJnZXQgPSBudWxsLCBuZXh0U3RhZ2UgPSB0aGlzLl9uZXh0U3RhZ2UsIG8gPSB0aGlzLl9nZXRQb2ludGVyRGF0YShpZCk7XG5cdFx0aWYgKCFvd25lcikgeyB0YXJnZXQgPSBvLnRhcmdldCA9IHRoaXMuX2dldE9iamVjdHNVbmRlclBvaW50KG8ueCwgby55LCBudWxsLCB0cnVlKTsgfVxuXG5cdFx0aWYgKG8uaW5Cb3VuZHMpIHsgdGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRoaXMsIFwic3RhZ2Vtb3VzZWRvd25cIiwgZmFsc2UsIGlkLCBvLCBlLCB0YXJnZXQpOyBvLmRvd24gPSB0cnVlOyB9XG5cdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRhcmdldCwgXCJtb3VzZWRvd25cIiwgdHJ1ZSwgaWQsIG8sIGUpO1xuXHRcdFxuXHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl9oYW5kbGVQb2ludGVyRG93bihpZCwgZSwgcGFnZVgsIHBhZ2VZLCBvd25lciB8fCB0YXJnZXQgJiYgdGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3Rlc3RNb3VzZU92ZXJcblx0ICogQHBhcmFtIHtCb29sZWFufSBjbGVhciBJZiB0cnVlLCBjbGVhcnMgdGhlIG1vdXNlb3ZlciAvIHJvbGxvdmVyIChpZS4gbm8gdGFyZ2V0KVxuXHQgKiBAcGFyYW0ge1N0YWdlfSBvd25lciBJbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgaGFzIGFscmVhZHkgYmVlbiBjYXB0dXJlZCAmIGhhbmRsZWQgYnkgdGhlIGluZGljYXRlZCBzdGFnZS5cblx0ICogQHBhcmFtIHtTdGFnZX0gZXZlbnRUYXJnZXQgVGhlIHN0YWdlIHRoYXQgdGhlIGN1cnNvciBpcyBhY3RpdmVseSBvdmVyLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fdGVzdE1vdXNlT3ZlciA9IGZ1bmN0aW9uKGNsZWFyLCBvd25lciwgZXZlbnRUYXJnZXQpIHtcblx0XHRpZiAodGhpcy5fcHJldlN0YWdlICYmIG93bmVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9IC8vIHJlZHVuZGFudCBsaXN0ZW5lci5cblx0XHRcblx0XHR2YXIgbmV4dFN0YWdlID0gdGhpcy5fbmV4dFN0YWdlO1xuXHRcdGlmICghdGhpcy5fbW91c2VPdmVySW50ZXJ2YWxJRCkge1xuXHRcdFx0Ly8gbm90IGVuYWJsZWQgZm9yIG1vdXNlb3ZlciwgYnV0IHNob3VsZCBzdGlsbCByZWxheSB0aGUgZXZlbnQuXG5cdFx0XHRuZXh0U3RhZ2UmJm5leHRTdGFnZS5fdGVzdE1vdXNlT3ZlcihjbGVhciwgb3duZXIsIGV2ZW50VGFyZ2V0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIG8gPSB0aGlzLl9nZXRQb2ludGVyRGF0YSgtMSk7XG5cdFx0Ly8gb25seSB1cGRhdGUgaWYgdGhlIG1vdXNlIHBvc2l0aW9uIGhhcyBjaGFuZ2VkLiBUaGlzIHByb3ZpZGVzIGEgbG90IG9mIG9wdGltaXphdGlvbiwgYnV0IGhhcyBzb21lIHRyYWRlLW9mZnMuXG5cdFx0aWYgKCFvIHx8ICghY2xlYXIgJiYgdGhpcy5tb3VzZVggPT0gdGhpcy5fbW91c2VPdmVyWCAmJiB0aGlzLm1vdXNlWSA9PSB0aGlzLl9tb3VzZU92ZXJZICYmIHRoaXMubW91c2VJbkJvdW5kcykpIHsgcmV0dXJuOyB9XG5cdFx0XG5cdFx0dmFyIGUgPSBvLnBvc0V2dE9iajtcblx0XHR2YXIgaXNFdmVudFRhcmdldCA9IGV2ZW50VGFyZ2V0IHx8IGUmJihlLnRhcmdldCA9PSB0aGlzLmNhbnZhcyk7XG5cdFx0dmFyIHRhcmdldD1udWxsLCBjb21tb24gPSAtMSwgY3Vyc29yPVwiXCIsIHQsIGksIGw7XG5cdFx0XG5cdFx0aWYgKCFvd25lciAmJiAoY2xlYXIgfHwgdGhpcy5tb3VzZUluQm91bmRzICYmIGlzRXZlbnRUYXJnZXQpKSB7XG5cdFx0XHR0YXJnZXQgPSB0aGlzLl9nZXRPYmplY3RzVW5kZXJQb2ludCh0aGlzLm1vdXNlWCwgdGhpcy5tb3VzZVksIG51bGwsIHRydWUpO1xuXHRcdFx0dGhpcy5fbW91c2VPdmVyWCA9IHRoaXMubW91c2VYO1xuXHRcdFx0dGhpcy5fbW91c2VPdmVyWSA9IHRoaXMubW91c2VZO1xuXHRcdH1cblxuXHRcdHZhciBvbGRMaXN0ID0gdGhpcy5fbW91c2VPdmVyVGFyZ2V0fHxbXTtcblx0XHR2YXIgb2xkVGFyZ2V0ID0gb2xkTGlzdFtvbGRMaXN0Lmxlbmd0aC0xXTtcblx0XHR2YXIgbGlzdCA9IHRoaXMuX21vdXNlT3ZlclRhcmdldCA9IFtdO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgYW5jZXN0b3IgbGlzdCBhbmQgY2hlY2sgZm9yIGN1cnNvcjpcblx0XHR0ID0gdGFyZ2V0O1xuXHRcdHdoaWxlICh0KSB7XG5cdFx0XHRsaXN0LnVuc2hpZnQodCk7XG5cdFx0XHRpZiAoIWN1cnNvcikgeyBjdXJzb3IgPSB0LmN1cnNvcjsgfVxuXHRcdFx0dCA9IHQucGFyZW50O1xuXHRcdH1cblx0XHR0aGlzLmNhbnZhcy5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG5cdFx0aWYgKCFvd25lciAmJiBldmVudFRhcmdldCkgeyBldmVudFRhcmdldC5jYW52YXMuc3R5bGUuY3Vyc29yID0gY3Vyc29yOyB9XG5cblx0XHQvLyBmaW5kIGNvbW1vbiBhbmNlc3Rvcjpcblx0XHRmb3IgKGk9MCxsPWxpc3QubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0aWYgKGxpc3RbaV0gIT0gb2xkTGlzdFtpXSkgeyBicmVhazsgfVxuXHRcdFx0Y29tbW9uID0gaTtcblx0XHR9XG5cblx0XHRpZiAob2xkVGFyZ2V0ICE9IHRhcmdldCkge1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KG9sZFRhcmdldCwgXCJtb3VzZW91dFwiLCB0cnVlLCAtMSwgbywgZSwgdGFyZ2V0KTtcblx0XHR9XG5cblx0XHRmb3IgKGk9b2xkTGlzdC5sZW5ndGgtMTsgaT5jb21tb247IGktLSkge1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KG9sZExpc3RbaV0sIFwicm9sbG91dFwiLCBmYWxzZSwgLTEsIG8sIGUsIHRhcmdldCk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpPWxpc3QubGVuZ3RoLTE7IGk+Y29tbW9uOyBpLS0pIHtcblx0XHRcdHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudChsaXN0W2ldLCBcInJvbGxvdmVyXCIsIGZhbHNlLCAtMSwgbywgZSwgb2xkVGFyZ2V0KTtcblx0XHR9XG5cblx0XHRpZiAob2xkVGFyZ2V0ICE9IHRhcmdldCkge1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRhcmdldCwgXCJtb3VzZW92ZXJcIiwgdHJ1ZSwgLTEsIG8sIGUsIG9sZFRhcmdldCk7XG5cdFx0fVxuXHRcdFxuXHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl90ZXN0TW91c2VPdmVyKGNsZWFyLCBvd25lciB8fCB0YXJnZXQgJiYgdGhpcywgZXZlbnRUYXJnZXQgfHwgaXNFdmVudFRhcmdldCAmJiB0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlRG91YmxlQ2xpY2tcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcblx0ICogQHBhcmFtIHtTdGFnZX0gb3duZXIgSW5kaWNhdGVzIHRoYXQgdGhlIGV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gY2FwdHVyZWQgJiBoYW5kbGVkIGJ5IHRoZSBpbmRpY2F0ZWQgc3RhZ2UuXG5cdCAqKi9cblx0cC5faGFuZGxlRG91YmxlQ2xpY2sgPSBmdW5jdGlvbihlLCBvd25lcikge1xuXHRcdHZhciB0YXJnZXQ9bnVsbCwgbmV4dFN0YWdlPXRoaXMuX25leHRTdGFnZSwgbz10aGlzLl9nZXRQb2ludGVyRGF0YSgtMSk7XG5cdFx0aWYgKCFvd25lcikge1xuXHRcdFx0dGFyZ2V0ID0gdGhpcy5fZ2V0T2JqZWN0c1VuZGVyUG9pbnQoby54LCBvLnksIG51bGwsIHRydWUpO1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRhcmdldCwgXCJkYmxjbGlja1wiLCB0cnVlLCAtMSwgbywgZSk7XG5cdFx0fVxuXHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl9oYW5kbGVEb3VibGVDbGljayhlLCBvd25lciB8fCB0YXJnZXQgJiYgdGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2Rpc3BhdGNoTW91c2VFdmVudFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gdGFyZ2V0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYnViYmxlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9pbnRlcklkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvXG5cdCAqIEBwYXJhbSB7TW91c2VFdmVudH0gW25hdGl2ZUV2ZW50XVxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IFtyZWxhdGVkVGFyZ2V0XVxuXHQgKiovXG5cdHAuX2Rpc3BhdGNoTW91c2VFdmVudCA9IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgYnViYmxlcywgcG9pbnRlcklkLCBvLCBuYXRpdmVFdmVudCwgcmVsYXRlZFRhcmdldCkge1xuXHRcdC8vIFRPRE86IG1pZ2h0IGJlIHdvcnRoIGVpdGhlciByZXVzaW5nIE1vdXNlRXZlbnQgaW5zdGFuY2VzLCBvciBhZGRpbmcgYSB3aWxsVHJpZ2dlciBtZXRob2QgdG8gYXZvaWQgR0MuXG5cdFx0aWYgKCF0YXJnZXQgfHwgKCFidWJibGVzICYmICF0YXJnZXQuaGFzRXZlbnRMaXN0ZW5lcih0eXBlKSkpIHsgcmV0dXJuOyB9XG5cdFx0Lypcblx0XHQvLyBUT0RPOiBhY2NvdW50IGZvciBzdGFnZSB0cmFuc2Zvcm1hdGlvbnM/XG5cdFx0dGhpcy5fbXR4ID0gdGhpcy5nZXRDb25jYXRlbmF0ZWRNYXRyaXgodGhpcy5fbXR4KS5pbnZlcnQoKTtcblx0XHR2YXIgcHQgPSB0aGlzLl9tdHgudHJhbnNmb3JtUG9pbnQoby54LCBvLnkpO1xuXHRcdHZhciBldnQgPSBuZXcgY3JlYXRlanMuTW91c2VFdmVudCh0eXBlLCBidWJibGVzLCBmYWxzZSwgcHQueCwgcHQueSwgbmF0aXZlRXZlbnQsIHBvaW50ZXJJZCwgcG9pbnRlcklkPT10aGlzLl9wcmltYXJ5UG9pbnRlcklEIHx8IHBvaW50ZXJJZD09LTEsIG8ucmF3WCwgby5yYXdZKTtcblx0XHQqL1xuXHRcdHZhciBldnQgPSBuZXcgY3JlYXRlanMuTW91c2VFdmVudCh0eXBlLCBidWJibGVzLCBmYWxzZSwgby54LCBvLnksIG5hdGl2ZUV2ZW50LCBwb2ludGVySWQsIHBvaW50ZXJJZCA9PT0gdGhpcy5fcHJpbWFyeVBvaW50ZXJJRCB8fCBwb2ludGVySWQgPT09IC0xLCBvLnJhd1gsIG8ucmF3WSwgcmVsYXRlZFRhcmdldCk7XG5cdFx0dGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZ0KTtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLlN0YWdlID0gY3JlYXRlanMucHJvbW90ZShTdGFnZSwgXCJDb250YWluZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQml0bWFwLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XG5cdC8qKlxuXHQgKiBBIEJpdG1hcCByZXByZXNlbnRzIGFuIEltYWdlLCBDYW52YXMsIG9yIFZpZGVvIGluIHRoZSBkaXNwbGF5IGxpc3QuIEEgQml0bWFwIGNhbiBiZSBpbnN0YW50aWF0ZWQgdXNpbmcgYW4gZXhpc3Rpbmdcblx0ICogSFRNTCBlbGVtZW50LCBvciBhIHN0cmluZy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBiaXRtYXAgPSBuZXcgY3JlYXRlanMuQml0bWFwKFwiaW1hZ2VQYXRoLmpwZ1wiKTtcblx0ICpcblx0ICogPHN0cm9uZz5Ob3Rlczo8L3N0cm9uZz5cblx0ICogPG9sPlxuXHQgKiAgICAgPGxpPldoZW4gYSBzdHJpbmcgcGF0aCBvciBpbWFnZSB0YWcgdGhhdCBpcyBub3QgeWV0IGxvYWRlZCBpcyB1c2VkLCB0aGUgc3RhZ2UgbWF5IG5lZWQgdG8gYmUgcmVkcmF3biBiZWZvcmUgaXRcblx0ICogICAgICB3aWxsIGJlIGRpc3BsYXllZC48L2xpPlxuXHQgKiAgICAgPGxpPkJpdG1hcHMgd2l0aCBhbiBTVkcgc291cmNlIGN1cnJlbnRseSB3aWxsIG5vdCByZXNwZWN0IGFuIGFscGhhIHZhbHVlIG90aGVyIHRoYW4gMCBvciAxLiBUbyBnZXQgYXJvdW5kIHRoaXMsXG5cdCAqICAgICB0aGUgQml0bWFwIGNhbiBiZSBjYWNoZWQuPC9saT5cblx0ICogICAgIDxsaT5CaXRtYXBzIHdpdGggYW4gU1ZHIHNvdXJjZSB3aWxsIHRhaW50IHRoZSBjYW52YXMgd2l0aCBjcm9zcy1vcmlnaW4gZGF0YSwgd2hpY2ggcHJldmVudHMgaW50ZXJhY3Rpdml0eS4gVGhpc1xuXHQgKiAgICAgaGFwcGVucyBpbiBhbGwgYnJvd3NlcnMgZXhjZXB0IHJlY2VudCBGaXJlZm94IGJ1aWxkcy48L2xpPlxuXHQgKiAgICAgPGxpPkltYWdlcyBsb2FkZWQgY3Jvc3Mtb3JpZ2luIHdpbGwgdGhyb3cgY3Jvc3Mtb3JpZ2luIHNlY3VyaXR5IGVycm9ycyB3aGVuIGludGVyYWN0ZWQgd2l0aCB1c2luZyBhIG1vdXNlLCB1c2luZ1xuXHQgKiAgICAgbWV0aG9kcyBzdWNoIGFzIGBnZXRPYmplY3RVbmRlclBvaW50YCwgb3IgdXNpbmcgZmlsdGVycywgb3IgY2FjaGluZy4gWW91IGNhbiBnZXQgYXJvdW5kIHRoaXMgYnkgc2V0dGluZ1xuXHQgKiAgICAgYGNyb3NzT3JpZ2luYCBmbGFncyBvbiB5b3VyIGltYWdlcyBiZWZvcmUgcGFzc2luZyB0aGVtIHRvIEVhc2VsSlMsIGVnOiBgaW1nLmNyb3NzT3JpZ2luPVwiQW5vbnltb3VzXCI7YDwvbGk+XG5cdCAqIDwvb2w+XG5cdCAqXG5cdCAqIEBjbGFzcyBCaXRtYXBcblx0ICogQGV4dGVuZHMgRGlzcGxheU9iamVjdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50IHwgU3RyaW5nfSBpbWFnZU9yVXJpIFRoZSBzb3VyY2Ugb2JqZWN0IG9yIFVSSSB0byBhbiBpbWFnZSB0b1xuXHQgKiBkaXNwbGF5LiBUaGlzIGNhbiBiZSBlaXRoZXIgYW4gSW1hZ2UsIENhbnZhcywgb3IgVmlkZW8gb2JqZWN0LCBvciBhIHN0cmluZyBVUkkgdG8gYW4gaW1hZ2UgZmlsZSB0byBsb2FkIGFuZCB1c2UuXG5cdCAqIElmIGl0IGlzIGEgVVJJLCBhIG5ldyBJbWFnZSBvYmplY3Qgd2lsbCBiZSBjb25zdHJ1Y3RlZCBhbmQgYXNzaWduZWQgdG8gdGhlIC5pbWFnZSBwcm9wZXJ0eS5cblx0ICoqL1xuXHRmdW5jdGlvbiBCaXRtYXAoaW1hZ2VPclVyaSkge1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9jb25zdHJ1Y3RvcigpO1xuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgaW1hZ2UgdG8gcmVuZGVyLiBUaGlzIGNhbiBiZSBhbiBJbWFnZSwgYSBDYW52YXMsIG9yIGEgVmlkZW8uIE5vdCBhbGwgYnJvd3NlcnMgKGVzcGVjaWFsbHlcblx0XHQgKiBtb2JpbGUgYnJvd3NlcnMpIHN1cHBvcnQgZHJhd2luZyB2aWRlbyB0byBhIGNhbnZhcy5cblx0XHQgKiBAcHJvcGVydHkgaW1hZ2Vcblx0XHQgKiBAdHlwZSBIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50XG5cdFx0ICoqL1xuXHRcdGlmICh0eXBlb2YgaW1hZ2VPclVyaSA9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR0aGlzLmltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcblx0XHRcdHRoaXMuaW1hZ2Uuc3JjID0gaW1hZ2VPclVyaTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5pbWFnZSA9IGltYWdlT3JVcmk7XG5cdFx0fVxuXHRcblx0XHQvKipcblx0XHQgKiBTcGVjaWZpZXMgYW4gYXJlYSBvZiB0aGUgc291cmNlIGltYWdlIHRvIGRyYXcuIElmIG9taXR0ZWQsIHRoZSB3aG9sZSBpbWFnZSB3aWxsIGJlIGRyYXduLlxuXHRcdCAqIE5vdGUgdGhhdCB2aWRlbyBzb3VyY2VzIG11c3QgaGF2ZSBhIHdpZHRoIC8gaGVpZ2h0IHNldCB0byB3b3JrIGNvcnJlY3RseSB3aXRoIGBzb3VyY2VSZWN0YC5cblx0XHQgKiBAcHJvcGVydHkgc291cmNlUmVjdFxuXHRcdCAqIEB0eXBlIFJlY3RhbmdsZVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnNvdXJjZVJlY3QgPSBudWxsO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEJpdG1hcCwgY3JlYXRlanMuRGlzcGxheU9iamVjdCk7XG5cdFxuXHRcbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQ29uc3RydWN0b3IgYWxpYXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBUaGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zLlxuXHQgKiBTdWJjbGFzc2VzIHNob3VsZCBiZSB1cGRhdGVkIHRvIHVzZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kc1wifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBgY3JlYXRlanMucHJvbW90ZSgpYFxuXHQgKiovXG5cdHAuaW5pdGlhbGl6ZSA9IEJpdG1hcDsgLy8gVE9ETzogZGVwcmVjYXRlZC5cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhcy5cblx0ICogVGhpcyBkb2VzIG5vdCBhY2NvdW50IGZvciB3aGV0aGVyIGl0IHdvdWxkIGJlIHZpc2libGUgd2l0aGluIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBzdGFnZS5cblx0ICpcblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGlzVmlzaWJsZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhc1xuXHQgKiovXG5cdHAuaXNWaXNpYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGltYWdlID0gdGhpcy5pbWFnZTtcblx0XHR2YXIgaGFzQ29udGVudCA9IHRoaXMuY2FjaGVDYW52YXMgfHwgKGltYWdlICYmIChpbWFnZS5uYXR1cmFsV2lkdGggfHwgaW1hZ2UuZ2V0Q29udGV4dCB8fCBpbWFnZS5yZWFkeVN0YXRlID49IDIpKTtcblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9IDAgJiYgdGhpcy5zY2FsZVkgIT0gMCAmJiBoYXNDb250ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgdGhlIGRpc3BsYXkgb2JqZWN0IGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IGlnbm9yaW5nIGl0cyB2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBhbmQgdHJhbnNmb3JtLlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cblx0ICpcblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGRyYXdcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbaWdub3JlQ2FjaGU9ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkcmF3IG9wZXJhdGlvbiBzaG91bGQgaWdub3JlIGFueSBjdXJyZW50IGNhY2hlLlxuXHQgKiBGb3IgZXhhbXBsZSwgdXNlZCBmb3IgZHJhd2luZyB0aGUgY2FjaGUgKHRvIHByZXZlbnQgaXQgZnJvbSBzaW1wbHkgZHJhd2luZyBhbiBleGlzdGluZyBjYWNoZSBiYWNrXG5cdCAqIGludG8gaXRzZWxmKS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICoqL1xuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGlnbm9yZUNhY2hlKSB7XG5cdFx0aWYgKHRoaXMuRGlzcGxheU9iamVjdF9kcmF3KGN0eCwgaWdub3JlQ2FjaGUpIHx8ICF0aGlzLmltYWdlKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0dmFyIGltZyA9IHRoaXMuaW1hZ2UsIHJlY3QgPSB0aGlzLnNvdXJjZVJlY3Q7XG5cdFx0aWYgKHJlY3QpIHtcblx0XHRcdC8vIHNvbWUgYnJvd3NlcnMgY2hva2Ugb24gb3V0IG9mIGJvdW5kIHZhbHVlcywgc28gd2UnbGwgZml4IHRoZW06XG5cdFx0XHR2YXIgeDEgPSByZWN0LngsIHkxID0gcmVjdC55LCB4MiA9IHgxICsgcmVjdC53aWR0aCwgeTIgPSB5MSArIHJlY3QuaGVpZ2h0LCB4ID0gMCwgeSA9IDAsIHcgPSBpbWcud2lkdGgsIGggPSBpbWcuaGVpZ2h0O1xuXHRcdFx0aWYgKHgxIDwgMCkgeyB4IC09IHgxOyB4MSA9IDA7IH1cblx0XHRcdGlmICh4MiA+IHcpIHsgeDIgPSB3OyB9XG5cdFx0XHRpZiAoeTEgPCAwKSB7IHkgLT0geTE7IHkxID0gMDsgfVxuXHRcdFx0aWYgKHkyID4gaCkgeyB5MiA9IGg7IH1cblx0XHRcdGN0eC5kcmF3SW1hZ2UoaW1nLCB4MSwgeTEsIHgyLXgxLCB5Mi15MSwgeCwgeSwgeDIteDEsIHkyLXkxKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdC8vTm90ZSwgdGhlIGRvYyBzZWN0aW9ucyBiZWxvdyBkb2N1bWVudCB1c2luZyB0aGUgc3BlY2lmaWVkIEFQSXMgKGZyb20gRGlzcGxheU9iamVjdCkgIGZyb21cblx0Ly9CaXRtYXAuIFRoaXMgaXMgd2h5IHRoZXkgaGF2ZSBubyBtZXRob2QgaW1wbGVtZW50YXRpb25zLlxuXHRcblx0LyoqXG5cdCAqIEJlY2F1c2UgdGhlIGNvbnRlbnQgb2YgYSBCaXRtYXAgaXMgYWxyZWFkeSBpbiBhIHNpbXBsZSBmb3JtYXQsIGNhY2hlIGlzIHVubmVjZXNzYXJ5IGZvciBCaXRtYXAgaW5zdGFuY2VzLlxuXHQgKiBZb3Ugc2hvdWxkIDxiPm5vdDwvYj4gY2FjaGUgQml0bWFwIGluc3RhbmNlcyBhcyBpdCBjYW4gZGVncmFkZSBwZXJmb3JtYW5jZS5cblx0ICpcblx0ICogPHN0cm9uZz5Ib3dldmVyOiBJZiB5b3Ugd2FudCB0byB1c2UgYSBmaWx0ZXIgb24gYSBCaXRtYXAsIHlvdSA8ZW0+TVVTVDwvZW0+IGNhY2hlIGl0LCBvciBpdCB3aWxsIG5vdCB3b3JrLjwvc3Ryb25nPlxuXHQgKiBUbyBzZWUgdGhlIEFQSSBmb3IgY2FjaGluZywgcGxlYXNlIHZpc2l0IHRoZSBEaXNwbGF5T2JqZWN0IHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvY2FjaGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLlxuXHQgKiBAbWV0aG9kIGNhY2hlXG5cdCAqKi9cblx0XG5cdC8qKlxuXHQgKiBCZWNhdXNlIHRoZSBjb250ZW50IG9mIGEgQml0bWFwIGlzIGFscmVhZHkgaW4gYSBzaW1wbGUgZm9ybWF0LCBjYWNoZSBpcyB1bm5lY2Vzc2FyeSBmb3IgQml0bWFwIGluc3RhbmNlcy5cblx0ICogWW91IHNob3VsZCA8Yj5ub3Q8L2I+IGNhY2hlIEJpdG1hcCBpbnN0YW5jZXMgYXMgaXQgY2FuIGRlZ3JhZGUgcGVyZm9ybWFuY2UuXG5cdCAqXG5cdCAqIDxzdHJvbmc+SG93ZXZlcjogSWYgeW91IHdhbnQgdG8gdXNlIGEgZmlsdGVyIG9uIGEgQml0bWFwLCB5b3UgPGVtPk1VU1Q8L2VtPiBjYWNoZSBpdCwgb3IgaXQgd2lsbCBub3Qgd29yay48L3N0cm9uZz5cblx0ICogVG8gc2VlIHRoZSBBUEkgZm9yIGNhY2hpbmcsIHBsZWFzZSB2aXNpdCB0aGUgRGlzcGxheU9iamVjdCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2NhY2hlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC5cblx0ICogQG1ldGhvZCB1cGRhdGVDYWNoZVxuXHQgKiovXG5cdFxuXHQvKipcblx0ICogQmVjYXVzZSB0aGUgY29udGVudCBvZiBhIEJpdG1hcCBpcyBhbHJlYWR5IGluIGEgc2ltcGxlIGZvcm1hdCwgY2FjaGUgaXMgdW5uZWNlc3NhcnkgZm9yIEJpdG1hcCBpbnN0YW5jZXMuXG5cdCAqIFlvdSBzaG91bGQgPGI+bm90PC9iPiBjYWNoZSBCaXRtYXAgaW5zdGFuY2VzIGFzIGl0IGNhbiBkZWdyYWRlIHBlcmZvcm1hbmNlLlxuXHQgKlxuXHQgKiA8c3Ryb25nPkhvd2V2ZXI6IElmIHlvdSB3YW50IHRvIHVzZSBhIGZpbHRlciBvbiBhIEJpdG1hcCwgeW91IDxlbT5NVVNUPC9lbT4gY2FjaGUgaXQsIG9yIGl0IHdpbGwgbm90IHdvcmsuPC9zdHJvbmc+XG5cdCAqIFRvIHNlZSB0aGUgQVBJIGZvciBjYWNoaW5nLCBwbGVhc2UgdmlzaXQgdGhlIERpc3BsYXlPYmplY3Qge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9jYWNoZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuXG5cdCAqIEBtZXRob2QgdW5jYWNoZVxuXHQgKiovXG5cblx0LyoqXG5cdCAqIERvY2NlZCBpbiBzdXBlcmNsYXNzLlxuXHQgKi9cblx0cC5nZXRCb3VuZHMgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IHRoaXMuRGlzcGxheU9iamVjdF9nZXRCb3VuZHMoKTtcblx0XHRpZiAocmVjdCkgeyByZXR1cm4gcmVjdDsgfVxuXHRcdHZhciBpbWFnZSA9IHRoaXMuaW1hZ2UsIG8gPSB0aGlzLnNvdXJjZVJlY3QgfHwgaW1hZ2U7XG5cdFx0dmFyIGhhc0NvbnRlbnQgPSAoaW1hZ2UgJiYgKGltYWdlLm5hdHVyYWxXaWR0aCB8fCBpbWFnZS5nZXRDb250ZXh0IHx8IGltYWdlLnJlYWR5U3RhdGUgPj0gMikpO1xuXHRcdHJldHVybiBoYXNDb250ZW50ID8gdGhpcy5fcmVjdGFuZ2xlLnNldFZhbHVlcygwLCAwLCBvLndpZHRoLCBvLmhlaWdodCkgOiBudWxsO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgQml0bWFwIGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge0JpdG1hcH0gYSBjbG9uZSBvZiB0aGUgQml0bWFwIGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbyA9IG5ldyBCaXRtYXAodGhpcy5pbWFnZSk7XG5cdFx0aWYgKHRoaXMuc291cmNlUmVjdCkgeyBvLnNvdXJjZVJlY3QgPSB0aGlzLnNvdXJjZVJlY3QuY2xvbmUoKTsgfVxuXHRcdHRoaXMuX2Nsb25lUHJvcHMobyk7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0JpdG1hcCAobmFtZT1cIisgIHRoaXMubmFtZSArXCIpXVwiO1xuXHR9O1xuXG5cdFxuXHRjcmVhdGVqcy5CaXRtYXAgPSBjcmVhdGVqcy5wcm9tb3RlKEJpdG1hcCwgXCJEaXNwbGF5T2JqZWN0XCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNwcml0ZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogRGlzcGxheXMgYSBmcmFtZSBvciBzZXF1ZW5jZSBvZiBmcmFtZXMgKGllLiBhbiBhbmltYXRpb24pIGZyb20gYSBTcHJpdGVTaGVldCBpbnN0YW5jZS4gQSBzcHJpdGUgc2hlZXQgaXMgYSBzZXJpZXMgb2Zcblx0ICogaW1hZ2VzICh1c3VhbGx5IGFuaW1hdGlvbiBmcmFtZXMpIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgaW1hZ2UuIEZvciBleGFtcGxlLCBhbiBhbmltYXRpb24gY29uc2lzdGluZyBvZiA4IDEwMHgxMDBcblx0ICogaW1hZ2VzIGNvdWxkIGJlIGNvbWJpbmVkIGludG8gYSA0MDB4MjAwIHNwcml0ZSBzaGVldCAoNCBmcmFtZXMgYWNyb3NzIGJ5IDIgaGlnaCkuIFlvdSBjYW4gZGlzcGxheSBpbmRpdmlkdWFsIGZyYW1lcyxcblx0ICogcGxheSBmcmFtZXMgYXMgYW4gYW5pbWF0aW9uLCBhbmQgZXZlbiBzZXF1ZW5jZSBhbmltYXRpb25zIHRvZ2V0aGVyLlxuXHQgKlxuXHQgKiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHNldHRpbmcgdXAgZnJhbWVzIGFuZCBhbmltYXRpb25zLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIGluc3RhbmNlID0gbmV3IGNyZWF0ZWpzLlNwcml0ZShzcHJpdGVTaGVldCk7XG5cdCAqICAgICAgaW5zdGFuY2UuZ290b0FuZFN0b3AoXCJmcmFtZU5hbWVcIik7XG5cdCAqXG5cdCAqIFVudGlsIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9nb3RvQW5kU3RvcFwifX17ey9jcm9zc0xpbmt9fSBvciB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX0gaXMgY2FsbGVkLFxuXHQgKiBvbmx5IHRoZSBmaXJzdCBkZWZpbmVkIGZyYW1lIGRlZmluZWQgaW4gdGhlIHNwcml0ZSBzaGVldCB3aWxsIGJlIGRpc3BsYXllZC5cblx0ICpcblx0ICogQGNsYXNzIFNwcml0ZVxuXHQgKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge1Nwcml0ZVNoZWV0fSBzcHJpdGVTaGVldCBUaGUgU3ByaXRlU2hlZXQgaW5zdGFuY2UgdG8gcGxheSBiYWNrLiBUaGlzIGluY2x1ZGVzIHRoZSBzb3VyY2UgaW1hZ2UocyksIGZyYW1lXG5cdCAqIGRpbWVuc2lvbnMsIGFuZCBmcmFtZSBkYXRhLiBTZWUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gW2ZyYW1lT3JBbmltYXRpb25dIFRoZSBmcmFtZSBudW1iZXIgb3IgYW5pbWF0aW9uIHRvIHBsYXkgaW5pdGlhbGx5LlxuXHQgKiovXG5cdGZ1bmN0aW9uIFNwcml0ZShzcHJpdGVTaGVldCwgZnJhbWVPckFuaW1hdGlvbikge1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9jb25zdHJ1Y3RvcigpO1xuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgZnJhbWUgaW5kZXggdGhhdCB3aWxsIGJlIGRyYXduIHdoZW4gZHJhdyBpcyBjYWxsZWQuIE5vdGUgdGhhdCB3aXRoIHNvbWUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBkZWZpbml0aW9ucywgdGhpcyB3aWxsIGFkdmFuY2Ugbm9uLXNlcXVlbnRpYWxseS4gVGhpcyB3aWxsIGFsd2F5cyBiZSBhbiBpbnRlZ2VyIHZhbHVlLlxuXHRcdCAqIEBwcm9wZXJ0eSBjdXJyZW50RnJhbWVcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5jdXJyZW50RnJhbWUgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgcGxheWluZyBhbmltYXRpb24uXG5cdFx0ICogQHByb3BlcnR5IGN1cnJlbnRBbmltYXRpb25cblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBmaW5hbFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBQcmV2ZW50cyB0aGUgYW5pbWF0aW9uIGZyb20gYWR2YW5jaW5nIGVhY2ggdGljayBhdXRvbWF0aWNhbGx5LiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIGNyZWF0ZSBhIHNwcml0ZVxuXHRcdCAqIHNoZWV0IG9mIGljb25zLCBzZXQgcGF1c2VkIHRvIHRydWUsIGFuZCBkaXNwbGF5IHRoZSBhcHByb3ByaWF0ZSBpY29uIGJ5IHNldHRpbmcgPGNvZGU+Y3VycmVudEZyYW1lPC9jb2RlPi5cblx0XHQgKiBAcHJvcGVydHkgcGF1c2VkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiovXG5cdFx0dGhpcy5wYXVzZWQgPSB0cnVlO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgU3ByaXRlU2hlZXQgaW5zdGFuY2UgdG8gcGxheSBiYWNrLiBUaGlzIGluY2x1ZGVzIHRoZSBzb3VyY2UgaW1hZ2UsIGZyYW1lIGRpbWVuc2lvbnMsIGFuZCBmcmFtZVxuXHRcdCAqIGRhdGEuIFNlZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgc3ByaXRlU2hlZXRcblx0XHQgKiBAdHlwZSB7U3ByaXRlU2hlZXR9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMuc3ByaXRlU2hlZXQgPSBzcHJpdGVTaGVldDtcblx0XG5cdFx0LyoqXG5cdFx0ICogU3BlY2lmaWVzIHRoZSBjdXJyZW50IGZyYW1lIGluZGV4IHdpdGhpbiB0aGUgY3VycmVudGx5IHBsYXlpbmcgYW5pbWF0aW9uLiBXaGVuIHBsYXlpbmcgbm9ybWFsbHksIHRoaXMgd2lsbCBpbmNyZWFzZVxuXHRcdCAqIGZyb20gMCB0byBuLTEsIHdoZXJlIG4gaXMgdGhlIG51bWJlciBvZiBmcmFtZXMgaW4gdGhlIGN1cnJlbnQgYW5pbWF0aW9uLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBjb3VsZCBiZSBhIG5vbi1pbnRlZ2VyIHZhbHVlIGlmXG5cdFx0ICogdXNpbmcgdGltZS1iYXNlZCBwbGF5YmFjayAoc2VlIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9mcmFtZXJhdGVcIn19e3svY3Jvc3NMaW5rfX0sIG9yIGlmIHRoZSBhbmltYXRpb24ncyBzcGVlZCBpc1xuXHRcdCAqIG5vdCBhbiBpbnRlZ2VyLlxuXHRcdCAqIEBwcm9wZXJ0eSBjdXJyZW50QW5pbWF0aW9uRnJhbWVcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWUgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBCeSBkZWZhdWx0IFNwcml0ZSBpbnN0YW5jZXMgYWR2YW5jZSBvbmUgZnJhbWUgcGVyIHRpY2suIFNwZWNpZnlpbmcgYSBmcmFtZXJhdGUgZm9yIHRoZSBTcHJpdGUgKG9yIGl0cyByZWxhdGVkXG5cdFx0ICogU3ByaXRlU2hlZXQpIHdpbGwgY2F1c2UgaXQgdG8gYWR2YW5jZSBiYXNlZCBvbiBlbGFwc2VkIHRpbWUgYmV0d2VlbiB0aWNrcyBhcyBhcHByb3ByaWF0ZSB0byBtYWludGFpbiB0aGUgdGFyZ2V0XG5cdFx0ICogZnJhbWVyYXRlLlxuXHRcdCAqXG5cdFx0ICogRm9yIGV4YW1wbGUsIGlmIGEgU3ByaXRlIHdpdGggYSBmcmFtZXJhdGUgb2YgMTAgaXMgcGxhY2VkIG9uIGEgU3RhZ2UgYmVpbmcgdXBkYXRlZCBhdCA0MGZwcywgdGhlbiB0aGUgU3ByaXRlIHdpbGxcblx0XHQgKiBhZHZhbmNlIHJvdWdobHkgb25lIGZyYW1lIGV2ZXJ5IDQgdGlja3MuIFRoaXMgd2lsbCBub3QgYmUgZXhhY3QsIGJlY2F1c2UgdGhlIHRpbWUgYmV0d2VlbiBlYWNoIHRpY2sgd2lsbFxuXHRcdCAqIHZhcnkgc2xpZ2h0bHkgYmV0d2VlbiBmcmFtZXMuXG5cdFx0ICpcblx0XHQgKiBUaGlzIGZlYXR1cmUgaXMgZGVwZW5kZW50IG9uIHRoZSB0aWNrIGV2ZW50IG9iamVjdCAob3IgYW4gb2JqZWN0IHdpdGggYW4gYXBwcm9wcmlhdGUgXCJkZWx0YVwiIHByb3BlcnR5KSBiZWluZ1xuXHRcdCAqIHBhc3NlZCBpbnRvIHt7I2Nyb3NzTGluayBcIlN0YWdlL3VwZGF0ZVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgZnJhbWVyYXRlXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMuZnJhbWVyYXRlID0gMDtcblx0XG5cdFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQ3VycmVudCBhbmltYXRpb24gb2JqZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBfYW5pbWF0aW9uXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLl9hbmltYXRpb24gPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBDdXJyZW50IGZyYW1lIGluZGV4LlxuXHRcdCAqIEBwcm9wZXJ0eSBfY3VycmVudEZyYW1lXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLl9jdXJyZW50RnJhbWUgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNraXBzIHRoZSBuZXh0IGF1dG8gYWR2YW5jZS4gVXNlZCBieSBnb3RvQW5kUGxheSB0byBhdm9pZCBpbW1lZGlhdGVseSBqdW1waW5nIHRvIHRoZSBuZXh0IGZyYW1lXG5cdFx0ICogQHByb3BlcnR5IF9za2lwQWR2YW5jZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqKi9cblx0XHR0aGlzLl9za2lwQWR2YW5jZSA9IGZhbHNlO1xuXHRcdFxuXHRcdFxuXHRcdGlmIChmcmFtZU9yQW5pbWF0aW9uICE9IG51bGwpIHsgdGhpcy5nb3RvQW5kUGxheShmcmFtZU9yQW5pbWF0aW9uKTsgfVxuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFNwcml0ZSwgY3JlYXRlanMuRGlzcGxheU9iamVjdCk7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdG9yIGFsaWFzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gVGhpcyBtZXRob2Qgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucy5cblx0ICogU3ViY2xhc3NlcyBzaG91bGQgYmUgdXBkYXRlZCB0byB1c2Uge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZHNcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2YgYGNyZWF0ZWpzLnByb21vdGUoKWBcblx0ICoqL1xuXHRwLmluaXRpYWxpemUgPSBTcHJpdGU7IC8vIFRPRE86IERlcHJlY2F0ZWQuIFRoaXMgaXMgZm9yIGJhY2t3YXJkcyBzdXBwb3J0IG9mIEZsYXNoQ0Mgc3ByaXRlc2hlZXQgZXhwb3J0LlxuXG5cbi8vIGV2ZW50czpcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiBhbiBhbmltYXRpb24gcmVhY2hlcyBpdHMgZW5kcy5cblx0ICogQGV2ZW50IGFuaW1hdGlvbmVuZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdGhhdCBqdXN0IGVuZGVkLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmV4dCBUaGUgbmFtZSBvZiB0aGUgbmV4dCBhbmltYXRpb24gdGhhdCB3aWxsIGJlIHBsYXllZCwgb3IgbnVsbC4gVGhpcyB3aWxsIGJlIHRoZSBzYW1lIGFzIG5hbWUgaWYgdGhlIGFuaW1hdGlvbiBpcyBsb29waW5nLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgYW55IHRpbWUgdGhlIGN1cnJlbnQgZnJhbWUgY2hhbmdlcy4gRm9yIGV4YW1wbGUsIHRoaXMgY291bGQgYmUgZHVlIHRvIGF1dG9tYXRpYyBhZHZhbmNlbWVudCBvbiBhIHRpY2ssXG5cdCAqIG9yIGNhbGxpbmcgZ290b0FuZFBsYXkoKSBvciBnb3RvQW5kU3RvcCgpLlxuXHQgKiBAZXZlbnQgY2hhbmdlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICovXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzXG5cdCAqKi9cblx0cC5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFzQ29udGVudCA9IHRoaXMuY2FjaGVDYW52YXMgfHwgdGhpcy5zcHJpdGVTaGVldC5jb21wbGV0ZTtcblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9IDAgJiYgdGhpcy5zY2FsZVkgIT0gMCAmJiBoYXNDb250ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgdGhlIGRpc3BsYXkgb2JqZWN0IGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IGlnbm9yaW5nIGl0cyB2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBhbmQgdHJhbnNmb3JtLlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGRyYXdcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVDYWNoZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZHJhdyBvcGVyYXRpb24gc2hvdWxkIGlnbm9yZSBhbnkgY3VycmVudCBjYWNoZS5cblx0ICogRm9yIGV4YW1wbGUsIHVzZWQgZm9yIGRyYXdpbmcgdGhlIGNhY2hlICh0byBwcmV2ZW50IGl0IGZyb20gc2ltcGx5IGRyYXdpbmcgYW4gZXhpc3RpbmcgY2FjaGUgYmFja1xuXHQgKiBpbnRvIGl0c2VsZikuXG5cdCAqKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBpZ25vcmVDYWNoZSkge1xuXHRcdGlmICh0aGlzLkRpc3BsYXlPYmplY3RfZHJhdyhjdHgsIGlnbm9yZUNhY2hlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdHRoaXMuX25vcm1hbGl6ZUZyYW1lKCk7XG5cdFx0dmFyIG8gPSB0aGlzLnNwcml0ZVNoZWV0LmdldEZyYW1lKHRoaXMuX2N1cnJlbnRGcmFtZXwwKTtcblx0XHRpZiAoIW8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dmFyIHJlY3QgPSBvLnJlY3Q7XG5cdFx0aWYgKHJlY3Qud2lkdGggJiYgcmVjdC5oZWlnaHQpIHsgY3R4LmRyYXdJbWFnZShvLmltYWdlLCByZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQsIC1vLnJlZ1gsIC1vLnJlZ1ksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTsgfVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8vTm90ZSwgdGhlIGRvYyBzZWN0aW9ucyBiZWxvdyBkb2N1bWVudCB1c2luZyB0aGUgc3BlY2lmaWVkIEFQSXMgKGZyb20gRGlzcGxheU9iamVjdCkgIGZyb21cblx0Ly9CaXRtYXAuIFRoaXMgaXMgd2h5IHRoZXkgaGF2ZSBubyBtZXRob2QgaW1wbGVtZW50YXRpb25zLlxuXG5cdC8qKlxuXHQgKiBCZWNhdXNlIHRoZSBjb250ZW50IG9mIGEgU3ByaXRlIGlzIGFscmVhZHkgaW4gYSByYXN0ZXIgZm9ybWF0LCBjYWNoZSBpcyB1bm5lY2Vzc2FyeSBmb3IgU3ByaXRlIGluc3RhbmNlcy5cblx0ICogWW91IHNob3VsZCBub3QgY2FjaGUgU3ByaXRlIGluc3RhbmNlcyBhcyBpdCBjYW4gZGVncmFkZSBwZXJmb3JtYW5jZS5cblx0ICogQG1ldGhvZCBjYWNoZVxuXHQgKiovXG5cblx0LyoqXG5cdCAqIEJlY2F1c2UgdGhlIGNvbnRlbnQgb2YgYSBTcHJpdGUgaXMgYWxyZWFkeSBpbiBhIHJhc3RlciBmb3JtYXQsIGNhY2hlIGlzIHVubmVjZXNzYXJ5IGZvciBTcHJpdGUgaW5zdGFuY2VzLlxuXHQgKiBZb3Ugc2hvdWxkIG5vdCBjYWNoZSBTcHJpdGUgaW5zdGFuY2VzIGFzIGl0IGNhbiBkZWdyYWRlIHBlcmZvcm1hbmNlLlxuXHQgKiBAbWV0aG9kIHVwZGF0ZUNhY2hlXG5cdCAqKi9cblxuXHQvKipcblx0ICogQmVjYXVzZSB0aGUgY29udGVudCBvZiBhIFNwcml0ZSBpcyBhbHJlYWR5IGluIGEgcmFzdGVyIGZvcm1hdCwgY2FjaGUgaXMgdW5uZWNlc3NhcnkgZm9yIFNwcml0ZSBpbnN0YW5jZXMuXG5cdCAqIFlvdSBzaG91bGQgbm90IGNhY2hlIFNwcml0ZSBpbnN0YW5jZXMgYXMgaXQgY2FuIGRlZ3JhZGUgcGVyZm9ybWFuY2UuXG5cdCAqIEBtZXRob2QgdW5jYWNoZVxuXHQgKiovXG5cblx0LyoqXG5cdCAqIFBsYXkgKHVucGF1c2UpIHRoZSBjdXJyZW50IGFuaW1hdGlvbi4gVGhlIFNwcml0ZSB3aWxsIGJlIHBhdXNlZCBpZiBlaXRoZXIge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL3N0b3BcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogb3Ige3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319IGlzIGNhbGxlZC4gU2luZ2xlIGZyYW1lIGFuaW1hdGlvbnMgd2lsbCByZW1haW5cblx0ICogdW5jaGFuZ2VkLlxuXHQgKiBAbWV0aG9kIHBsYXlcblx0ICoqL1xuXHRwLnBsYXkgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9wIHBsYXlpbmcgYSBydW5uaW5nIGFuaW1hdGlvbi4gVGhlIFNwcml0ZSB3aWxsIGJlIHBsYXlpbmcgaWYge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGlzIGNhbGxlZC4gTm90ZSB0aGF0IGNhbGxpbmcge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319IG9yIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9wbGF5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdpbGwgcmVzdW1lIHBsYXliYWNrLlxuXHQgKiBAbWV0aG9kIHN0b3Bcblx0ICoqL1xuXHRwLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnBhdXNlZCA9IHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgcGF1c2VkIHRvIGZhbHNlIGFuZCBwbGF5cyB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbiBuYW1lLCBuYW1lZCBmcmFtZSwgb3IgZnJhbWUgbnVtYmVyLlxuXHQgKiBAbWV0aG9kIGdvdG9BbmRQbGF5XG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gZnJhbWVPckFuaW1hdGlvbiBUaGUgZnJhbWUgbnVtYmVyIG9yIGFuaW1hdGlvbiBuYW1lIHRoYXQgdGhlIHBsYXloZWFkIHNob3VsZCBtb3ZlIHRvXG5cdCAqIGFuZCBiZWdpbiBwbGF5aW5nLlxuXHQgKiovXG5cdHAuZ290b0FuZFBsYXkgPSBmdW5jdGlvbihmcmFtZU9yQW5pbWF0aW9uKSB7XG5cdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9za2lwQWR2YW5jZSA9IHRydWU7XG5cdFx0dGhpcy5fZ290byhmcmFtZU9yQW5pbWF0aW9uKTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyBwYXVzZWQgdG8gdHJ1ZSBhbmQgc2Vla3MgdG8gdGhlIHNwZWNpZmllZCBhbmltYXRpb24gbmFtZSwgbmFtZWQgZnJhbWUsIG9yIGZyYW1lIG51bWJlci5cblx0ICogQG1ldGhvZCBnb3RvQW5kU3RvcFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGZyYW1lT3JBbmltYXRpb24gVGhlIGZyYW1lIG51bWJlciBvciBhbmltYXRpb24gbmFtZSB0aGF0IHRoZSBwbGF5aGVhZCBzaG91bGQgbW92ZSB0b1xuXHQgKiBhbmQgc3RvcC5cblx0ICoqL1xuXHRwLmdvdG9BbmRTdG9wID0gZnVuY3Rpb24oZnJhbWVPckFuaW1hdGlvbikge1xuXHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0XHR0aGlzLl9nb3RvKGZyYW1lT3JBbmltYXRpb24pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZHZhbmNlcyB0aGUgcGxheWhlYWQuIFRoaXMgb2NjdXJzIGF1dG9tYXRpY2FsbHkgZWFjaCB0aWNrIGJ5IGRlZmF1bHQuXG5cdCAqIEBwYXJhbSBbdGltZV0ge051bWJlcn0gVGhlIGFtb3VudCBvZiB0aW1lIGluIG1zIHRvIGFkdmFuY2UgYnkuIE9ubHkgYXBwbGljYWJsZSBpZiBmcmFtZXJhdGUgaXMgc2V0IG9uIHRoZSBTcHJpdGVcblx0ICogb3IgaXRzIFNwcml0ZVNoZWV0LlxuXHQgKiBAbWV0aG9kIGFkdmFuY2Vcblx0Ki9cblx0cC5hZHZhbmNlID0gZnVuY3Rpb24odGltZSkge1xuXHRcdHZhciBmcHMgPSB0aGlzLmZyYW1lcmF0ZSB8fCB0aGlzLnNwcml0ZVNoZWV0LmZyYW1lcmF0ZTtcblx0XHR2YXIgdCA9IChmcHMgJiYgdGltZSAhPSBudWxsKSA/IHRpbWUvKDEwMDAvZnBzKSA6IDE7XG5cdFx0dGhpcy5fbm9ybWFsaXplRnJhbWUodCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIHt7I2Nyb3NzTGluayBcIlJlY3RhbmdsZVwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZSBkZWZpbmluZyB0aGUgYm91bmRzIG9mIHRoZSBjdXJyZW50IGZyYW1lIHJlbGF0aXZlIHRvXG5cdCAqIHRoZSBvcmlnaW4uIEZvciBleGFtcGxlLCBhIDkwIHggNzAgZnJhbWUgd2l0aCA8Y29kZT5yZWdYPTUwPC9jb2RlPiBhbmQgPGNvZGU+cmVnWT00MDwvY29kZT4gd291bGQgcmV0dXJuIGFcblx0ICogcmVjdGFuZ2xlIHdpdGggW3g9LTUwLCB5PS00MCwgd2lkdGg9OTAsIGhlaWdodD03MF0uIFRoaXMgaWdub3JlcyB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGRpc3BsYXkgb2JqZWN0LlxuXHQgKlxuXHQgKiBBbHNvIHNlZSB0aGUgU3ByaXRlU2hlZXQge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXQvZ2V0RnJhbWVCb3VuZHNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXHQgKiBAbWV0aG9kIGdldEJvdW5kc1xuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IEEgUmVjdGFuZ2xlIGluc3RhbmNlLiBSZXR1cm5zIG51bGwgaWYgdGhlIGZyYW1lIGRvZXMgbm90IGV4aXN0LCBvciB0aGUgaW1hZ2UgaXMgbm90IGZ1bGx5XG5cdCAqIGxvYWRlZC5cblx0ICoqL1xuXHRwLmdldEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFRPRE86IHNob3VsZCB0aGlzIG5vcm1hbGl6ZUZyYW1lP1xuXHRcdHJldHVybiB0aGlzLkRpc3BsYXlPYmplY3RfZ2V0Qm91bmRzKCkgfHwgdGhpcy5zcHJpdGVTaGVldC5nZXRGcmFtZUJvdW5kcyh0aGlzLmN1cnJlbnRGcmFtZSwgdGhpcy5fcmVjdGFuZ2xlKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBTcHJpdGUgaW5zdGFuY2UuIE5vdGUgdGhhdCB0aGUgc2FtZSBTcHJpdGVTaGVldCBpcyBzaGFyZWQgYmV0d2VlbiBjbG9uZWRcblx0ICogaW5zdGFuY2VzLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge1Nwcml0ZX0gYSBjbG9uZSBvZiB0aGUgU3ByaXRlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmVQcm9wcyhuZXcgU3ByaXRlKHRoaXMuc3ByaXRlU2hlZXQpKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1Nwcml0ZSAobmFtZT1cIisgIHRoaXMubmFtZSArXCIpXVwiO1xuXHR9O1xuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9jbG9uZVByb3BzXG5cdCAqIEBwYXJhbSB7U3ByaXRlfSBvXG5cdCAqIEByZXR1cm4ge1Nwcml0ZX0gb1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fY2xvbmVQcm9wcyA9IGZ1bmN0aW9uKG8pIHtcblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfX2Nsb25lUHJvcHMobyk7XG5cdFx0by5jdXJyZW50RnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcblx0XHRvLmN1cnJlbnRBbmltYXRpb24gPSB0aGlzLmN1cnJlbnRBbmltYXRpb247XG5cdFx0by5wYXVzZWQgPSB0aGlzLnBhdXNlZDtcblx0XHRvLmN1cnJlbnRBbmltYXRpb25GcmFtZSA9IHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lO1xuXHRcdG8uZnJhbWVyYXRlID0gdGhpcy5mcmFtZXJhdGU7XG5cdFx0XG5cdFx0by5fYW5pbWF0aW9uID0gdGhpcy5fYW5pbWF0aW9uO1xuXHRcdG8uX2N1cnJlbnRGcmFtZSA9IHRoaXMuX2N1cnJlbnRGcmFtZTtcblx0XHRvLl9za2lwQWR2YW5jZSA9IHRoaXMuX3NraXBBZHZhbmNlO1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoZSA8Y29kZT5jdXJyZW50RnJhbWU8L2NvZGU+IGlmIHBhdXNlZCBpcyBub3QgdHJ1ZS4gVGhpcyBpcyBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSB7eyNjcm9zc0xpbmsgXCJTdGFnZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB0aWNrcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IGV2dE9iaiBBbiBldmVudCBvYmplY3QgdGhhdCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gYWxsIHRpY2sgbGlzdGVuZXJzLiBUaGlzIG9iamVjdCBpcyByZXVzZWQgYmV0d2VlbiBkaXNwYXRjaGVycyB0byByZWR1Y2UgY29uc3RydWN0aW9uICYgR0MgY29zdHMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQG1ldGhvZCBfdGlja1xuXHQgKiovXG5cdHAuX3RpY2sgPSBmdW5jdGlvbihldnRPYmopIHtcblx0XHRpZiAoIXRoaXMucGF1c2VkKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3NraXBBZHZhbmNlKSB7IHRoaXMuYWR2YW5jZShldnRPYmomJmV2dE9iai5kZWx0YSk7IH1cblx0XHRcdHRoaXMuX3NraXBBZHZhbmNlID0gZmFsc2U7XG5cdFx0fVxuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9fdGljayhldnRPYmopO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE5vcm1hbGl6ZXMgdGhlIGN1cnJlbnQgZnJhbWUsIGFkdmFuY2luZyBhbmltYXRpb25zIGFuZCBkaXNwYXRjaGluZyBjYWxsYmFja3MgYXMgYXBwcm9wcmlhdGUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQG1ldGhvZCBfbm9ybWFsaXplRnJhbWVcblx0ICoqL1xuXHRwLl9ub3JtYWxpemVGcmFtZSA9IGZ1bmN0aW9uKGZyYW1lRGVsdGEpIHtcblx0XHRmcmFtZURlbHRhID0gZnJhbWVEZWx0YSB8fCAwO1xuXHRcdHZhciBhbmltYXRpb24gPSB0aGlzLl9hbmltYXRpb247XG5cdFx0dmFyIHBhdXNlZCA9IHRoaXMucGF1c2VkO1xuXHRcdHZhciBmcmFtZSA9IHRoaXMuX2N1cnJlbnRGcmFtZTtcblx0XHR2YXIgbDtcblx0XHRcblx0XHRpZiAoYW5pbWF0aW9uKSB7XG5cdFx0XHR2YXIgc3BlZWQgPSBhbmltYXRpb24uc3BlZWQgfHwgMTtcblx0XHRcdHZhciBhbmltRnJhbWUgPSB0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZTtcblx0XHRcdGwgPSBhbmltYXRpb24uZnJhbWVzLmxlbmd0aDtcblx0XHRcdGlmIChhbmltRnJhbWUgKyBmcmFtZURlbHRhICogc3BlZWQgPj0gbCkge1xuXHRcdFx0XHR2YXIgbmV4dCA9IGFuaW1hdGlvbi5uZXh0O1xuXHRcdFx0XHRpZiAodGhpcy5fZGlzcGF0Y2hBbmltYXRpb25FbmQoYW5pbWF0aW9uLCBmcmFtZSwgcGF1c2VkLCBuZXh0LCBsIC0gMSkpIHtcblx0XHRcdFx0XHQvLyBzb21ldGhpbmcgY2hhbmdlZCBpbiB0aGUgZXZlbnQgc3RhY2ssIHNvIHdlIHNob3VsZG4ndCBtYWtlIGFueSBtb3JlIGNoYW5nZXMgaGVyZS5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH0gZWxzZSBpZiAobmV4dCkge1xuXHRcdFx0XHRcdC8vIHNlcXVlbmNlLiBBdXRvbWF0aWNhbGx5IGNhbGxzIF9ub3JtYWxpemVGcmFtZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgZnJhbWVzLlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9nb3RvKG5leHQsIGZyYW1lRGVsdGEgLSAobCAtIGFuaW1GcmFtZSkgLyBzcGVlZCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gZW5kLlxuXHRcdFx0XHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRhbmltRnJhbWUgPSBhbmltYXRpb24uZnJhbWVzLmxlbmd0aCAtIDE7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFuaW1GcmFtZSArPSBmcmFtZURlbHRhICogc3BlZWQ7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZSA9IGFuaW1GcmFtZTtcblx0XHRcdHRoaXMuX2N1cnJlbnRGcmFtZSA9IGFuaW1hdGlvbi5mcmFtZXNbYW5pbUZyYW1lIHwgMF1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZnJhbWUgPSAodGhpcy5fY3VycmVudEZyYW1lICs9IGZyYW1lRGVsdGEpO1xuXHRcdFx0bCA9IHRoaXMuc3ByaXRlU2hlZXQuZ2V0TnVtRnJhbWVzKCk7XG5cdFx0XHRpZiAoZnJhbWUgPj0gbCAmJiBsID4gMCkge1xuXHRcdFx0XHRpZiAoIXRoaXMuX2Rpc3BhdGNoQW5pbWF0aW9uRW5kKGFuaW1hdGlvbiwgZnJhbWUsIHBhdXNlZCwgbCAtIDEpKSB7XG5cdFx0XHRcdFx0Ly8gbG9vcGVkLlxuXHRcdFx0XHRcdGlmICgodGhpcy5fY3VycmVudEZyYW1lIC09IGwpID49IGwpIHsgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZUZyYW1lKCk7IH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRmcmFtZSA9IHRoaXMuX2N1cnJlbnRGcmFtZSB8IDA7XG5cdFx0aWYgKHRoaXMuY3VycmVudEZyYW1lICE9IGZyYW1lKSB7XG5cdFx0XHR0aGlzLmN1cnJlbnRGcmFtZSA9IGZyYW1lO1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiY2hhbmdlXCIpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRGlzcGF0Y2hlcyB0aGUgXCJhbmltYXRpb25lbmRcIiBldmVudC4gUmV0dXJucyB0cnVlIGlmIGEgaGFuZGxlciBjaGFuZ2VkIHRoZSBhbmltYXRpb24gKGV4LiBjYWxsaW5nIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9zdG9wXCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX0sIGV0Yy4pXG5cdCAqIEBwcm9wZXJ0eSBfZGlzcGF0Y2hBbmltYXRpb25FbmRcblx0ICogQHByaXZhdGVcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHQgKiovXG5cdHAuX2Rpc3BhdGNoQW5pbWF0aW9uRW5kID0gZnVuY3Rpb24oYW5pbWF0aW9uLCBmcmFtZSwgcGF1c2VkLCBuZXh0LCBlbmQpIHtcblx0XHR2YXIgbmFtZSA9IGFuaW1hdGlvbiA/IGFuaW1hdGlvbi5uYW1lIDogbnVsbDtcblx0XHRpZiAodGhpcy5oYXNFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIpKSB7XG5cdFx0XHR2YXIgZXZ0ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiYW5pbWF0aW9uZW5kXCIpO1xuXHRcdFx0ZXZ0Lm5hbWUgPSBuYW1lO1xuXHRcdFx0ZXZ0Lm5leHQgPSBuZXh0O1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cdFx0fVxuXHRcdC8vIGRpZCB0aGUgYW5pbWF0aW9uIGdldCBjaGFuZ2VkIGluIHRoZSBldmVudCBzdGFjaz86XG5cdFx0dmFyIGNoYW5nZWQgPSAodGhpcy5fYW5pbWF0aW9uICE9IGFuaW1hdGlvbiB8fCB0aGlzLl9jdXJyZW50RnJhbWUgIT0gZnJhbWUpO1xuXHRcdC8vIGlmIHRoZSBhbmltYXRpb24gaGFzbid0IGNoYW5nZWQsIGJ1dCB0aGUgc3ByaXRlIHdhcyBwYXVzZWQsIHRoZW4gd2Ugd2FudCB0byBzdGljayB0byB0aGUgbGFzdCBmcmFtZTpcblx0XHRpZiAoIWNoYW5nZWQgJiYgIXBhdXNlZCAmJiB0aGlzLnBhdXNlZCkgeyB0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZSA9IGVuZDsgY2hhbmdlZCA9IHRydWU7IH1cblx0XHRyZXR1cm4gY2hhbmdlZDtcblx0fTtcblxuXHQvKipcblx0ICogTW92ZXMgdGhlIHBsYXloZWFkIHRvIHRoZSBzcGVjaWZpZWQgZnJhbWUgbnVtYmVyIG9yIGFuaW1hdGlvbi5cblx0ICogQG1ldGhvZCBfZ290b1xuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGZyYW1lT3JBbmltYXRpb24gVGhlIGZyYW1lIG51bWJlciBvciBhbmltYXRpb24gdGhhdCB0aGUgcGxheWhlYWQgc2hvdWxkIG1vdmUgdG8uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZyYW1lXSBUaGUgZnJhbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBnbyB0by4gRGVmYXVsdHMgdG8gMC5cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dvdG8gPSBmdW5jdGlvbihmcmFtZU9yQW5pbWF0aW9uLCBmcmFtZSkge1xuXHRcdHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lID0gMDtcblx0XHRpZiAoaXNOYU4oZnJhbWVPckFuaW1hdGlvbikpIHtcblx0XHRcdHZhciBkYXRhID0gdGhpcy5zcHJpdGVTaGVldC5nZXRBbmltYXRpb24oZnJhbWVPckFuaW1hdGlvbik7XG5cdFx0XHRpZiAoZGF0YSkge1xuXHRcdFx0XHR0aGlzLl9hbmltYXRpb24gPSBkYXRhO1xuXHRcdFx0XHR0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBmcmFtZU9yQW5pbWF0aW9uO1xuXHRcdFx0XHR0aGlzLl9ub3JtYWxpemVGcmFtZShmcmFtZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IHRoaXMuX2FuaW1hdGlvbiA9IG51bGw7XG5cdFx0XHR0aGlzLl9jdXJyZW50RnJhbWUgPSBmcmFtZU9yQW5pbWF0aW9uO1xuXHRcdFx0dGhpcy5fbm9ybWFsaXplRnJhbWUoKTtcblx0XHR9XG5cdH07XG5cblxuXHRjcmVhdGVqcy5TcHJpdGUgPSBjcmVhdGVqcy5wcm9tb3RlKFNwcml0ZSwgXCJEaXNwbGF5T2JqZWN0XCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNoYXBlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBBIFNoYXBlIGFsbG93cyB5b3UgdG8gZGlzcGxheSB2ZWN0b3IgYXJ0IGluIHRoZSBkaXNwbGF5IGxpc3QuIEl0IGNvbXBvc2l0ZXMgYSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljc1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpbnN0YW5jZSB3aGljaCBleHBvc2VzIGFsbCBvZiB0aGUgdmVjdG9yIGRyYXdpbmcgbWV0aG9kcy4gVGhlIEdyYXBoaWNzIGluc3RhbmNlIGNhbiBiZSBzaGFyZWQgYmV0d2VlbiBtdWx0aXBsZSBTaGFwZVxuXHQgKiBpbnN0YW5jZXMgdG8gZGlzcGxheSB0aGUgc2FtZSB2ZWN0b3IgZ3JhcGhpY3Mgd2l0aCBkaWZmZXJlbnQgcG9zaXRpb25zIG9yIHRyYW5zZm9ybXMuXG5cdCAqXG5cdCAqIElmIHRoZSB2ZWN0b3IgYXJ0IHdpbGwgbm90XG5cdCAqIGNoYW5nZSBiZXR3ZWVuIGRyYXdzLCB5b3UgbWF5IHdhbnQgdG8gdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2NhY2hlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCB0byByZWR1Y2UgdGhlXG5cdCAqIHJlbmRlcmluZyBjb3N0LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IGNyZWF0ZWpzLkdyYXBoaWNzKCkuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3UmVjdCgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqICAgICAgdmFyIHNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKGdyYXBoaWNzKTtcblx0ICpcblx0ICogICAgICAvL0FsdGVybmF0aXZlbHkgdXNlIGNhbiBhbHNvIHVzZSB0aGUgZ3JhcGhpY3MgcHJvcGVydHkgb2YgdGhlIFNoYXBlIGNsYXNzIHRvIHJlbmRlcmVyIHRoZSBzYW1lIGFzIGFib3ZlLlxuXHQgKiAgICAgIHZhciBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuXHQgKiAgICAgIHNoYXBlLmdyYXBoaWNzLmJlZ2luRmlsbChcIiNmZjAwMDBcIikuZHJhd1JlY3QoMCwgMCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiBAY2xhc3MgU2hhcGVcblx0ICogQGV4dGVuZHMgRGlzcGxheU9iamVjdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtHcmFwaGljc30gZ3JhcGhpY3MgT3B0aW9uYWwuIFRoZSBncmFwaGljcyBpbnN0YW5jZSB0byBkaXNwbGF5LiBJZiBudWxsLCBhIG5ldyBHcmFwaGljcyBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWQuXG5cdCAqKi9cblx0ZnVuY3Rpb24gU2hhcGUoZ3JhcGhpY3MpIHtcblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfY29uc3RydWN0b3IoKTtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIGdyYXBoaWNzIGluc3RhbmNlIHRvIGRpc3BsYXkuXG5cdFx0ICogQHByb3BlcnR5IGdyYXBoaWNzXG5cdFx0ICogQHR5cGUgR3JhcGhpY3Ncblx0XHQgKiovXG5cdFx0dGhpcy5ncmFwaGljcyA9IGdyYXBoaWNzID8gZ3JhcGhpY3MgOiBuZXcgY3JlYXRlanMuR3JhcGhpY3MoKTtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTaGFwZSwgY3JlYXRlanMuRGlzcGxheU9iamVjdCk7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBTaGFwZSB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBTaGFwZSB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzXG5cdCAqKi9cblx0cC5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFzQ29udGVudCA9IHRoaXMuY2FjaGVDYW52YXMgfHwgKHRoaXMuZ3JhcGhpY3MgJiYgIXRoaXMuZ3JhcGhpY3MuaXNFbXB0eSgpKTtcblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9IDAgJiYgdGhpcy5zY2FsZVkgIT0gMCAmJiBoYXNDb250ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgdGhlIFNoYXBlIGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IGlnbm9yaW5nIGl0cyB2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBhbmQgdHJhbnNmb3JtLiBSZXR1cm5zIHRydWUgaWZcblx0ICogdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cblx0ICpcblx0ICogPGk+Tk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLjwvaT5cblx0ICogQG1ldGhvZCBkcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZUNhY2hlPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZHJhdyBvcGVyYXRpb24gc2hvdWxkIGlnbm9yZSBhbnkgY3VycmVudCBjYWNoZS4gRm9yIGV4YW1wbGUsXG5cdCAqIHVzZWQgZm9yIGRyYXdpbmcgdGhlIGNhY2hlICh0byBwcmV2ZW50IGl0IGZyb20gc2ltcGx5IGRyYXdpbmcgYW4gZXhpc3RpbmcgY2FjaGUgYmFjayBpbnRvIGl0c2VsZikuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBpZ25vcmVDYWNoZSkge1xuXHRcdGlmICh0aGlzLkRpc3BsYXlPYmplY3RfZHJhdyhjdHgsIGlnbm9yZUNhY2hlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdHRoaXMuZ3JhcGhpY3MuZHJhdyhjdHgsIHRoaXMpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBTaGFwZS4gU29tZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIHNwZWNpZmljIHRvIHRoaXMgaW5zdGFuY2UncyBjdXJyZW50IGNvbnRleHQgYXJlIHJldmVydGVkIHRvXG5cdCAqIHRoZWlyIGRlZmF1bHRzIChmb3IgZXhhbXBsZSAucGFyZW50KS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlY3Vyc2l2ZSBJZiB0cnVlLCB0aGlzIFNoYXBlJ3Mge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3NcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2Ugd2lsbCBhbHNvIGJlXG5cdCAqIGNsb25lZC4gSWYgZmFsc2UsIHRoZSBHcmFwaGljcyBpbnN0YW5jZSB3aWxsIGJlIHNoYXJlZCB3aXRoIHRoZSBuZXcgU2hhcGUuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKHJlY3Vyc2l2ZSkge1xuXHRcdHZhciBnID0gKHJlY3Vyc2l2ZSAmJiB0aGlzLmdyYXBoaWNzKSA/IHRoaXMuZ3JhcGhpY3MuY2xvbmUoKSA6IHRoaXMuZ3JhcGhpY3M7XG5cdFx0cmV0dXJuICB0aGlzLl9jbG9uZVByb3BzKG5ldyBTaGFwZShnKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltTaGFwZSAobmFtZT1cIisgIHRoaXMubmFtZSArXCIpXVwiO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuU2hhcGUgPSBjcmVhdGVqcy5wcm9tb3RlKFNoYXBlLCBcIkRpc3BsYXlPYmplY3RcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVGV4dC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogRGlzcGxheSBvbmUgb3IgbW9yZSBsaW5lcyBvZiBkeW5hbWljIHRleHQgKG5vdCB1c2VyIGVkaXRhYmxlKSBpbiB0aGUgZGlzcGxheSBsaXN0LiBMaW5lIHdyYXBwaW5nIHN1cHBvcnQgKHVzaW5nIHRoZVxuXHQgKiBsaW5lV2lkdGgpIGlzIHZlcnkgYmFzaWMsIHdyYXBwaW5nIG9uIHNwYWNlcyBhbmQgdGFicyBvbmx5LiBOb3RlIHRoYXQgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gVGV4dCwgeW91IGNhbiBwb3NpdGlvbiBIVE1MXG5cdCAqIHRleHQgYWJvdmUgb3IgYmVsb3cgdGhlIGNhbnZhcyByZWxhdGl2ZSB0byBpdGVtcyBpbiB0aGUgZGlzcGxheSBsaXN0IHVzaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2xvY2FsVG9HbG9iYWxcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLCBvciB1c2luZyB7eyNjcm9zc0xpbmsgXCJET01FbGVtZW50XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiA8Yj5QbGVhc2Ugbm90ZSB0aGF0IFRleHQgZG9lcyBub3Qgc3VwcG9ydCBIVE1MIHRleHQsIGFuZCBjYW4gb25seSBkaXNwbGF5IG9uZSBmb250IHN0eWxlIGF0IGEgdGltZS48L2I+IFRvIHVzZVxuXHQgKiBtdWx0aXBsZSBmb250IHN0eWxlcywgeW91IHdpbGwgbmVlZCB0byBjcmVhdGUgbXVsdGlwbGUgdGV4dCBpbnN0YW5jZXMsIGFuZCBwb3NpdGlvbiB0aGVtIG1hbnVhbGx5LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIHRleHQgPSBuZXcgY3JlYXRlanMuVGV4dChcIkhlbGxvIFdvcmxkXCIsIFwiMjBweCBBcmlhbFwiLCBcIiNmZjc3MDBcIik7XG5cdCAqICAgICAgdGV4dC54ID0gMTAwO1xuXHQgKiAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gXCJhbHBoYWJldGljXCI7XG5cdCAqXG5cdCAqIENyZWF0ZUpTIFRleHQgc3VwcG9ydHMgd2ViIGZvbnRzICh0aGUgc2FtZSBydWxlcyBhcyBDYW52YXMpLiBUaGUgZm9udCBtdXN0IGJlIGxvYWRlZCBhbmQgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyXG5cdCAqIGJlZm9yZSBpdCBjYW4gYmUgZGlzcGxheWVkLlxuXHQgKlxuXHQgKiA8c3Ryb25nPk5vdGU6PC9zdHJvbmc+IFRleHQgY2FuIGJlIGV4cGVuc2l2ZSB0byBnZW5lcmF0ZSwgc28gY2FjaGUgaW5zdGFuY2VzIHdoZXJlIHBvc3NpYmxlLiBCZSBhd2FyZSB0aGF0IG5vdCBhbGxcblx0ICogYnJvd3NlcnMgd2lsbCByZW5kZXIgVGV4dCBleGFjdGx5IHRoZSBzYW1lLlxuXHQgKiBAY2xhc3MgVGV4dFxuXHQgKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3RleHRdIFRoZSB0ZXh0IHRvIGRpc3BsYXkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbZm9udF0gVGhlIGZvbnQgc3R5bGUgdG8gdXNlLiBBbnkgdmFsaWQgdmFsdWUgZm9yIHRoZSBDU1MgZm9udCBhdHRyaWJ1dGUgaXMgYWNjZXB0YWJsZSAoZXguIFwiYm9sZFxuXHQgKiAzNnB4IEFyaWFsXCIpLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2NvbG9yXSBUaGUgY29sb3IgdG8gZHJhdyB0aGUgdGV4dCBpbi4gQW55IHZhbGlkIHZhbHVlIGZvciB0aGUgQ1NTIGNvbG9yIGF0dHJpYnV0ZSBpcyBhY2NlcHRhYmxlIChleC5cblx0ICogXCIjRjAwXCIsIFwicmVkXCIsIG9yIFwiI0ZGMDAwMFwiKS5cblx0ICoqL1xuXHRmdW5jdGlvbiBUZXh0KHRleHQsIGZvbnQsIGNvbG9yKSB7XG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X2NvbnN0cnVjdG9yKCk7XG5cdFx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0ZXh0IHRvIGRpc3BsYXkuXG5cdFx0ICogQHByb3BlcnR5IHRleHRcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiovXG5cdFx0dGhpcy50ZXh0ID0gdGV4dDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGZvbnQgc3R5bGUgdG8gdXNlLiBBbnkgdmFsaWQgdmFsdWUgZm9yIHRoZSBDU1MgZm9udCBhdHRyaWJ1dGUgaXMgYWNjZXB0YWJsZSAoZXguIFwiYm9sZCAzNnB4IEFyaWFsXCIpLlxuXHRcdCAqIEBwcm9wZXJ0eSBmb250XG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICoqL1xuXHRcdHRoaXMuZm9udCA9IGZvbnQ7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjb2xvciB0byBkcmF3IHRoZSB0ZXh0IGluLiBBbnkgdmFsaWQgdmFsdWUgZm9yIHRoZSBDU1MgY29sb3IgYXR0cmlidXRlIGlzIGFjY2VwdGFibGUgKGV4LiBcIiNGMDBcIikuIERlZmF1bHQgaXMgXCIjMDAwXCIuXG5cdFx0ICogSXQgd2lsbCBhbHNvIGFjY2VwdCB2YWxpZCBjYW52YXMgZmlsbFN0eWxlIHZhbHVlcy5cblx0XHQgKiBAcHJvcGVydHkgY29sb3Jcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiovXG5cdFx0dGhpcy5jb2xvciA9IGNvbG9yO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgaG9yaXpvbnRhbCB0ZXh0IGFsaWdubWVudC4gQW55IG9mIFwic3RhcnRcIiwgXCJlbmRcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIiwgYW5kIFwiY2VudGVyXCIuIEZvciBkZXRhaWxlZFxuXHRcdCAqIGluZm9ybWF0aW9uIHZpZXcgdGhlXG5cdFx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI3RleHQtc3R5bGVzXCI+XG5cdFx0ICogd2hhdHdnIHNwZWM8L2E+LiBEZWZhdWx0IGlzIFwibGVmdFwiLlxuXHRcdCAqIEBwcm9wZXJ0eSB0ZXh0QWxpZ25cblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiovXG5cdFx0dGhpcy50ZXh0QWxpZ24gPSBcImxlZnRcIjtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHZlcnRpY2FsIGFsaWdubWVudCBwb2ludCBvbiB0aGUgZm9udC4gQW55IG9mIFwidG9wXCIsIFwiaGFuZ2luZ1wiLCBcIm1pZGRsZVwiLCBcImFscGhhYmV0aWNcIiwgXCJpZGVvZ3JhcGhpY1wiLCBvclxuXHRcdCAqIFwiYm90dG9tXCIuIEZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiB2aWV3IHRoZSA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjdGV4dC1zdHlsZXNcIj5cblx0XHQgKiB3aGF0d2cgc3BlYzwvYT4uIERlZmF1bHQgaXMgXCJ0b3BcIi5cblx0XHQgKiBAcHJvcGVydHkgdGV4dEJhc2VsaW5lXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0Ki9cblx0XHR0aGlzLnRleHRCYXNlbGluZSA9IFwidG9wXCI7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBtYXhpbXVtIHdpZHRoIHRvIGRyYXcgdGhlIHRleHQuIElmIG1heFdpZHRoIGlzIHNwZWNpZmllZCAobm90IG51bGwpLCB0aGUgdGV4dCB3aWxsIGJlIGNvbmRlbnNlZCBvclxuXHRcdCAqIHNocnVuayB0byBtYWtlIGl0IGZpdCBpbiB0aGlzIHdpZHRoLiBGb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gdmlldyB0aGVcblx0XHQgKiA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjdGV4dC1zdHlsZXNcIj5cblx0XHQgKiB3aGF0d2cgc3BlYzwvYT4uXG5cdFx0ICogQHByb3BlcnR5IG1heFdpZHRoXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0Ki9cblx0XHR0aGlzLm1heFdpZHRoID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgZ3JlYXRlciB0aGFuIDAsIHRoZSB0ZXh0IHdpbGwgYmUgZHJhd24gYXMgYSBzdHJva2UgKG91dGxpbmUpIG9mIHRoZSBzcGVjaWZpZWQgd2lkdGguXG5cdFx0ICogQHByb3BlcnR5IG91dGxpbmVcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5vdXRsaW5lID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoZSBsaW5lIGhlaWdodCAodmVydGljYWwgZGlzdGFuY2UgYmV0d2VlbiBiYXNlbGluZXMpIGZvciBtdWx0aS1saW5lIHRleHQuIElmIG51bGwgb3IgMCxcblx0XHQgKiB0aGUgdmFsdWUgb2YgZ2V0TWVhc3VyZWRMaW5lSGVpZ2h0IGlzIHVzZWQuXG5cdFx0ICogQHByb3BlcnR5IGxpbmVIZWlnaHRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5saW5lSGVpZ2h0ID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoZSBtYXhpbXVtIHdpZHRoIGZvciBhIGxpbmUgb2YgdGV4dCBiZWZvcmUgaXQgaXMgd3JhcHBlZCB0byBtdWx0aXBsZSBsaW5lcy4gSWYgbnVsbCxcblx0XHQgKiB0aGUgdGV4dCB3aWxsIG5vdCBiZSB3cmFwcGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBsaW5lV2lkdGhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5saW5lV2lkdGggPSBudWxsO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFRleHQsIGNyZWF0ZWpzLkRpc3BsYXlPYmplY3QpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cdFxuLy8gc3RhdGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3dvcmtpbmdDb250ZXh0XG5cdCAqIEB0eXBlIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiovXG5cdHZhciBjYW52YXMgPSAoY3JlYXRlanMuY3JlYXRlQ2FudmFzP2NyZWF0ZWpzLmNyZWF0ZUNhbnZhcygpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikpO1xuXHRpZiAoY2FudmFzLmdldENvbnRleHQpIHsgVGV4dC5fd29ya2luZ0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpOyBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMTsgfVxuXHRcblx0XG4vLyBjb25zdGFudHM6XG5cdC8qKlxuXHQgKiBMb29rdXAgdGFibGUgZm9yIHRoZSByYXRpbyB0byBvZmZzZXQgYm91bmRzIHggY2FsY3VsYXRpb25zIGJhc2VkIG9uIHRoZSB0ZXh0QWxpZ24gcHJvcGVydHkuXG5cdCAqIEBwcm9wZXJ0eSBIX09GRlNFVFNcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRleHQuSF9PRkZTRVRTID0ge3N0YXJ0OiAwLCBsZWZ0OiAwLCBjZW50ZXI6IC0wLjUsIGVuZDogLTEsIHJpZ2h0OiAtMX07XG5cdFxuXHQvKipcblx0ICogTG9va3VwIHRhYmxlIGZvciB0aGUgcmF0aW8gdG8gb2Zmc2V0IGJvdW5kcyB5IGNhbGN1bGF0aW9ucyBiYXNlZCBvbiB0aGUgdGV4dEJhc2VsaW5lIHByb3BlcnR5LlxuXHQgKiBAcHJvcGVydHkgSF9PRkZTRVRTXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUZXh0LlZfT0ZGU0VUUyA9IHt0b3A6IDAsIGhhbmdpbmc6IC0wLjAxLCBtaWRkbGU6IC0wLjQsIGFscGhhYmV0aWM6IC0wLjgsIGlkZW9ncmFwaGljOiAtMC44NSwgYm90dG9tOiAtMX07XG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcblx0ICoqL1xuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYXNDb250ZW50ID0gdGhpcy5jYWNoZUNhbnZhcyB8fCAodGhpcy50ZXh0ICE9IG51bGwgJiYgdGhpcy50ZXh0ICE9PSBcIlwiKTtcblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9IDAgJiYgdGhpcy5zY2FsZVkgIT0gMCAmJiBoYXNDb250ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgdGhlIFRleHQgaW50byB0aGUgc3BlY2lmaWVkIGNvbnRleHQgaWdub3JpbmcgaXRzIHZpc2libGUsIGFscGhhLCBzaGFkb3csIGFuZCB0cmFuc2Zvcm0uXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZHJhdyB3YXMgaGFuZGxlZCAodXNlZnVsIGZvciBvdmVycmlkaW5nIGZ1bmN0aW9uYWxpdHkpLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgZHJhd1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZUNhY2hlIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkcmF3IG9wZXJhdGlvbiBzaG91bGQgaWdub3JlIGFueSBjdXJyZW50IGNhY2hlLlxuXHQgKiBGb3IgZXhhbXBsZSwgdXNlZCBmb3IgZHJhd2luZyB0aGUgY2FjaGUgKHRvIHByZXZlbnQgaXQgZnJvbSBzaW1wbHkgZHJhd2luZyBhbiBleGlzdGluZyBjYWNoZSBiYWNrXG5cdCAqIGludG8gaXRzZWxmKS5cblx0ICoqL1xuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGlnbm9yZUNhY2hlKSB7XG5cdFx0aWYgKHRoaXMuRGlzcGxheU9iamVjdF9kcmF3KGN0eCwgaWdub3JlQ2FjaGUpKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHR2YXIgY29sID0gdGhpcy5jb2xvciB8fCBcIiMwMDBcIjtcblx0XHRpZiAodGhpcy5vdXRsaW5lKSB7IGN0eC5zdHJva2VTdHlsZSA9IGNvbDsgY3R4LmxpbmVXaWR0aCA9IHRoaXMub3V0bGluZSoxOyB9XG5cdFx0ZWxzZSB7IGN0eC5maWxsU3R5bGUgPSBjb2w7IH1cblx0XHRcblx0XHR0aGlzLl9kcmF3VGV4dCh0aGlzLl9wcmVwQ29udGV4dChjdHgpKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbWVhc3VyZWQsIHVudHJhbnNmb3JtZWQgd2lkdGggb2YgdGhlIHRleHQgd2l0aG91dCB3cmFwcGluZy4gVXNlIGdldEJvdW5kcyBmb3IgYSBtb3JlIHJvYnVzdCB2YWx1ZS5cblx0ICogQG1ldGhvZCBnZXRNZWFzdXJlZFdpZHRoXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1lYXN1cmVkLCB1bnRyYW5zZm9ybWVkIHdpZHRoIG9mIHRoZSB0ZXh0LlxuXHQgKiovXG5cdHAuZ2V0TWVhc3VyZWRXaWR0aCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9nZXRNZWFzdXJlZFdpZHRoKHRoaXMudGV4dCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXBwcm94aW1hdGUgbGluZSBoZWlnaHQgb2YgdGhlIHRleHQsIGlnbm9yaW5nIHRoZSBsaW5lSGVpZ2h0IHByb3BlcnR5LiBUaGlzIGlzIGJhc2VkIG9uIHRoZSBtZWFzdXJlZFxuXHQgKiB3aWR0aCBvZiBhIFwiTVwiIGNoYXJhY3RlciBtdWx0aXBsaWVkIGJ5IDEuMiwgd2hpY2ggcHJvdmlkZXMgYW4gYXBwcm94aW1hdGUgbGluZSBoZWlnaHQgZm9yIG1vc3QgZm9udHMuXG5cdCAqIEBtZXRob2QgZ2V0TWVhc3VyZWRMaW5lSGVpZ2h0XG5cdCAqIEByZXR1cm4ge051bWJlcn0gYW4gYXBwcm94aW1hdGUgbGluZSBoZWlnaHQgb2YgdGhlIHRleHQsIGlnbm9yaW5nIHRoZSBsaW5lSGVpZ2h0IHByb3BlcnR5LiBUaGlzIGlzXG5cdCAqIGJhc2VkIG9uIHRoZSBtZWFzdXJlZCB3aWR0aCBvZiBhIFwiTVwiIGNoYXJhY3RlciBtdWx0aXBsaWVkIGJ5IDEuMiwgd2hpY2ggYXBwcm94aW1hdGVzIGVtIGZvciBtb3N0IGZvbnRzLlxuXHQgKiovXG5cdHAuZ2V0TWVhc3VyZWRMaW5lSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldE1lYXN1cmVkV2lkdGgoXCJNXCIpKjEuMjtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYXBwcm94aW1hdGUgaGVpZ2h0IG9mIG11bHRpLWxpbmUgdGV4dCBieSBtdWx0aXBseWluZyB0aGUgbnVtYmVyIG9mIGxpbmVzIGFnYWluc3QgZWl0aGVyIHRoZVxuXHQgKiA8Y29kZT5saW5lSGVpZ2h0PC9jb2RlPiAoaWYgc3BlY2lmaWVkKSBvciB7eyNjcm9zc0xpbmsgXCJUZXh0L2dldE1lYXN1cmVkTGluZUhlaWdodFwifX17ey9jcm9zc0xpbmt9fS4gTm90ZSB0aGF0XG5cdCAqIHRoaXMgb3BlcmF0aW9uIHJlcXVpcmVzIHRoZSB0ZXh0IGZsb3dpbmcgbG9naWMgdG8gcnVuLCB3aGljaCBoYXMgYW4gYXNzb2NpYXRlZCBDUFUgY29zdC5cblx0ICogQG1ldGhvZCBnZXRNZWFzdXJlZEhlaWdodFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBhcHByb3hpbWF0ZSBoZWlnaHQgb2YgdGhlIHVudHJhbnNmb3JtZWQgbXVsdGktbGluZSB0ZXh0LlxuXHQgKiovXG5cdHAuZ2V0TWVhc3VyZWRIZWlnaHQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhd1RleHQobnVsbCx7fSkuaGVpZ2h0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEb2NjZWQgaW4gc3VwZXJjbGFzcy5cblx0ICovXG5cdHAuZ2V0Qm91bmRzID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSB0aGlzLkRpc3BsYXlPYmplY3RfZ2V0Qm91bmRzKCk7XG5cdFx0aWYgKHJlY3QpIHsgcmV0dXJuIHJlY3Q7IH1cblx0XHRpZiAodGhpcy50ZXh0ID09IG51bGwgfHwgdGhpcy50ZXh0ID09PSBcIlwiKSB7IHJldHVybiBudWxsOyB9XG5cdFx0dmFyIG8gPSB0aGlzLl9kcmF3VGV4dChudWxsLCB7fSk7XG5cdFx0dmFyIHcgPSAodGhpcy5tYXhXaWR0aCAmJiB0aGlzLm1heFdpZHRoIDwgby53aWR0aCkgPyB0aGlzLm1heFdpZHRoIDogby53aWR0aDtcblx0XHR2YXIgeCA9IHcgKiBUZXh0LkhfT0ZGU0VUU1t0aGlzLnRleHRBbGlnbnx8XCJsZWZ0XCJdO1xuXHRcdHZhciBsaW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0fHx0aGlzLmdldE1lYXN1cmVkTGluZUhlaWdodCgpO1xuXHRcdHZhciB5ID0gbGluZUhlaWdodCAqIFRleHQuVl9PRkZTRVRTW3RoaXMudGV4dEJhc2VsaW5lfHxcInRvcFwiXTtcblx0XHRyZXR1cm4gdGhpcy5fcmVjdGFuZ2xlLnNldFZhbHVlcyh4LCB5LCB3LCBvLmhlaWdodCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB3aWR0aCwgaGVpZ2h0LCBhbmQgbGluZXMgcHJvcGVydGllcy4gVGhlIHdpZHRoIGFuZCBoZWlnaHQgYXJlIHRoZSB2aXN1YWwgd2lkdGggYW5kIGhlaWdodFxuXHQgKiBvZiB0aGUgZHJhd24gdGV4dC4gVGhlIGxpbmVzIHByb3BlcnR5IGNvbnRhaW5zIGFuIGFycmF5IG9mIHN0cmluZ3MsIG9uZSBmb3Jcblx0ICogZWFjaCBsaW5lIG9mIHRleHQgdGhhdCB3aWxsIGJlIGRyYXduLCBhY2NvdW50aW5nIGZvciBsaW5lIGJyZWFrcyBhbmQgd3JhcHBpbmcuIFRoZXNlIHN0cmluZ3MgaGF2ZSB0cmFpbGluZ1xuXHQgKiB3aGl0ZXNwYWNlIHJlbW92ZWQuXG5cdCAqIEBtZXRob2QgZ2V0TWV0cmljc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHdpZHRoLCBoZWlnaHQsIGFuZCBsaW5lcyBwcm9wZXJ0aWVzLlxuXHQgKiovXG5cdHAuZ2V0TWV0cmljcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvID0ge2xpbmVzOltdfTtcblx0XHRvLmxpbmVIZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHQgfHwgdGhpcy5nZXRNZWFzdXJlZExpbmVIZWlnaHQoKTtcblx0XHRvLnZPZmZzZXQgPSBvLmxpbmVIZWlnaHQgKiBUZXh0LlZfT0ZGU0VUU1t0aGlzLnRleHRCYXNlbGluZXx8XCJ0b3BcIl07XG5cdFx0cmV0dXJuIHRoaXMuX2RyYXdUZXh0KG51bGwsIG8sIG8ubGluZXMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFRleHQgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7VGV4dH0gYSBjbG9uZSBvZiB0aGUgVGV4dCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lUHJvcHMobmV3IFRleHQodGhpcy50ZXh0LCB0aGlzLmZvbnQsIHRoaXMuY29sb3IpKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1RleHQgKHRleHQ9XCIrICAodGhpcy50ZXh0Lmxlbmd0aCA+IDIwID8gdGhpcy50ZXh0LnN1YnN0cigwLCAxNykrXCIuLi5cIiA6IHRoaXMudGV4dCkgK1wiKV1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9jbG9uZVByb3BzXG5cdCAqIEBwYXJhbSB7VGV4dH0gb1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge1RleHR9IG9cblx0ICoqL1xuXHRwLl9jbG9uZVByb3BzID0gZnVuY3Rpb24obykge1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9fY2xvbmVQcm9wcyhvKTtcblx0XHRvLnRleHRBbGlnbiA9IHRoaXMudGV4dEFsaWduO1xuXHRcdG8udGV4dEJhc2VsaW5lID0gdGhpcy50ZXh0QmFzZWxpbmU7XG5cdFx0by5tYXhXaWR0aCA9IHRoaXMubWF4V2lkdGg7XG5cdFx0by5vdXRsaW5lID0gdGhpcy5vdXRsaW5lO1xuXHRcdG8ubGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodDtcblx0XHRvLmxpbmVXaWR0aCA9IHRoaXMubGluZVdpZHRoO1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRXb3JraW5nQ29udGV4dFxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3ByZXBDb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0Y3R4LmZvbnQgPSB0aGlzLmZvbnR8fFwiMTBweCBzYW5zLXNlcmlmXCI7XG5cdFx0Y3R4LnRleHRBbGlnbiA9IHRoaXMudGV4dEFsaWdufHxcImxlZnRcIjtcblx0XHRjdHgudGV4dEJhc2VsaW5lID0gdGhpcy50ZXh0QmFzZWxpbmV8fFwidG9wXCI7XG5cdFx0cmV0dXJuIGN0eDtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgbXVsdGlsaW5lIHRleHQuXG5cdCAqIEBtZXRob2QgX2RyYXdUZXh0XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICogQHBhcmFtIHtPYmplY3R9IG9cblx0ICogQHBhcmFtIHtBcnJheX0gbGluZXNcblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZHJhd1RleHQgPSBmdW5jdGlvbihjdHgsIG8sIGxpbmVzKSB7XG5cdFx0dmFyIHBhaW50ID0gISFjdHg7XG5cdFx0aWYgKCFwYWludCkge1xuXHRcdFx0Y3R4ID0gVGV4dC5fd29ya2luZ0NvbnRleHQ7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0dGhpcy5fcHJlcENvbnRleHQoY3R4KTtcblx0XHR9XG5cdFx0dmFyIGxpbmVIZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHR8fHRoaXMuZ2V0TWVhc3VyZWRMaW5lSGVpZ2h0KCk7XG5cdFx0XG5cdFx0dmFyIG1heFcgPSAwLCBjb3VudCA9IDA7XG5cdFx0dmFyIGhhcmRMaW5lcyA9IFN0cmluZyh0aGlzLnRleHQpLnNwbGl0KC8oPzpcXHJcXG58XFxyfFxcbikvKTtcblx0XHRmb3IgKHZhciBpPTAsIGw9aGFyZExpbmVzLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdHZhciBzdHIgPSBoYXJkTGluZXNbaV07XG5cdFx0XHR2YXIgdyA9IG51bGw7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmxpbmVXaWR0aCAhPSBudWxsICYmICh3ID0gY3R4Lm1lYXN1cmVUZXh0KHN0cikud2lkdGgpID4gdGhpcy5saW5lV2lkdGgpIHtcblx0XHRcdFx0Ly8gdGV4dCB3cmFwcGluZzpcblx0XHRcdFx0dmFyIHdvcmRzID0gc3RyLnNwbGl0KC8oXFxzKS8pO1xuXHRcdFx0XHRzdHIgPSB3b3Jkc1swXTtcblx0XHRcdFx0dyA9IGN0eC5tZWFzdXJlVGV4dChzdHIpLndpZHRoO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yICh2YXIgaj0xLCBqbD13b3Jkcy5sZW5ndGg7IGo8amw7IGorPTIpIHtcblx0XHRcdFx0XHQvLyBMaW5lIG5lZWRzIHRvIHdyYXA6XG5cdFx0XHRcdFx0dmFyIHdvcmRXID0gY3R4Lm1lYXN1cmVUZXh0KHdvcmRzW2pdICsgd29yZHNbaisxXSkud2lkdGg7XG5cdFx0XHRcdFx0aWYgKHcgKyB3b3JkVyA+IHRoaXMubGluZVdpZHRoKSB7XG5cdFx0XHRcdFx0XHRpZiAocGFpbnQpIHsgdGhpcy5fZHJhd1RleHRMaW5lKGN0eCwgc3RyLCBjb3VudCpsaW5lSGVpZ2h0KTsgfVxuXHRcdFx0XHRcdFx0aWYgKGxpbmVzKSB7IGxpbmVzLnB1c2goc3RyKTsgfVxuXHRcdFx0XHRcdFx0aWYgKHcgPiBtYXhXKSB7IG1heFcgPSB3OyB9XG5cdFx0XHRcdFx0XHRzdHIgPSB3b3Jkc1tqKzFdO1xuXHRcdFx0XHRcdFx0dyA9IGN0eC5tZWFzdXJlVGV4dChzdHIpLndpZHRoO1xuXHRcdFx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3RyICs9IHdvcmRzW2pdICsgd29yZHNbaisxXTtcblx0XHRcdFx0XHRcdHcgKz0gd29yZFc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChwYWludCkgeyB0aGlzLl9kcmF3VGV4dExpbmUoY3R4LCBzdHIsIGNvdW50KmxpbmVIZWlnaHQpOyB9XG5cdFx0XHRpZiAobGluZXMpIHsgbGluZXMucHVzaChzdHIpOyB9XG5cdFx0XHRpZiAobyAmJiB3ID09IG51bGwpIHsgdyA9IGN0eC5tZWFzdXJlVGV4dChzdHIpLndpZHRoOyB9XG5cdFx0XHRpZiAodyA+IG1heFcpIHsgbWF4VyA9IHc7IH1cblx0XHRcdGNvdW50Kys7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChvKSB7XG5cdFx0XHRvLndpZHRoID0gbWF4Vztcblx0XHRcdG8uaGVpZ2h0ID0gY291bnQqbGluZUhlaWdodDtcblx0XHR9XG5cdFx0aWYgKCFwYWludCkgeyBjdHgucmVzdG9yZSgpOyB9XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2RyYXdUZXh0TGluZVxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9kcmF3VGV4dExpbmUgPSBmdW5jdGlvbihjdHgsIHRleHQsIHkpIHtcblx0XHQvLyBDaHJvbWUgMTcgd2lsbCBmYWlsIHRvIGRyYXcgdGhlIHRleHQgaWYgdGhlIGxhc3QgcGFyYW0gaXMgaW5jbHVkZWQgYnV0IG51bGwsIHNvIHdlIGZlZWQgaXQgYSBsYXJnZSB2YWx1ZSBpbnN0ZWFkOlxuXHRcdGlmICh0aGlzLm91dGxpbmUpIHsgY3R4LnN0cm9rZVRleHQodGV4dCwgMCwgeSwgdGhpcy5tYXhXaWR0aHx8MHhGRkZGKTsgfVxuXHRcdGVsc2UgeyBjdHguZmlsbFRleHQodGV4dCwgMCwgeSwgdGhpcy5tYXhXaWR0aHx8MHhGRkZGKTsgfVxuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRNZWFzdXJlZFdpZHRoXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nZXRNZWFzdXJlZFdpZHRoID0gZnVuY3Rpb24odGV4dCkge1xuXHRcdHZhciBjdHggPSBUZXh0Ll93b3JraW5nQ29udGV4dDtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdHZhciB3ID0gdGhpcy5fcHJlcENvbnRleHQoY3R4KS5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdHJldHVybiB3O1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuVGV4dCA9IGNyZWF0ZWpzLnByb21vdGUoVGV4dCwgXCJEaXNwbGF5T2JqZWN0XCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEJpdG1hcFRleHQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIERpc3BsYXlzIHRleHQgdXNpbmcgYml0bWFwIGdseXBocyBkZWZpbmVkIGluIGEgc3ByaXRlIHNoZWV0LiBNdWx0aS1saW5lIHRleHQgaXMgc3VwcG9ydGVkXG5cdCAqIHVzaW5nIG5ldyBsaW5lIGNoYXJhY3RlcnMsIGJ1dCBhdXRvbWF0aWMgd3JhcHBpbmcgaXMgbm90IHN1cHBvcnRlZC4gU2VlIHRoZSBcblx0ICoge3sjY3Jvc3NMaW5rIFwiQml0bWFwVGV4dC9zcHJpdGVTaGVldDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBwcm9wZXJ0eSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBkZWZpbmluZyBnbHlwaHMuXG5cdCAqIFxuXHQgKiA8c3Ryb25nPkltcG9ydGFudDo8L3N0cm9uZz4gQml0bWFwVGV4dCBleHRlbmRzIENvbnRhaW5lciwgYnV0IGlzIG5vdCBkZXNpZ25lZCB0byBiZSB1c2VkIGFzIG9uZS5cblx0ICogQXMgc3VjaCwgbWV0aG9kcyBsaWtlIGFkZENoaWxkIGFuZCByZW1vdmVDaGlsZCBhcmUgZGlzYWJsZWQuXG5cdCAqIEBjbGFzcyBCaXRtYXBUZXh0XG5cdCAqIEBleHRlbmRzIERpc3BsYXlPYmplY3Rcblx0ICogQHBhcmFtIHtTdHJpbmd9IFt0ZXh0PVwiXCJdIFRoZSB0ZXh0IHRvIGRpc3BsYXkuXG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IFtzcHJpdGVTaGVldD1udWxsXSBUaGUgc3ByaXRlc2hlZXQgdGhhdCBkZWZpbmVzIHRoZSBjaGFyYWN0ZXIgZ2x5cGhzLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBCaXRtYXBUZXh0KHRleHQsIHNwcml0ZVNoZWV0KSB7XG5cdFx0dGhpcy5Db250YWluZXJfY29uc3RydWN0b3IoKTtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIHRleHQgdG8gZGlzcGxheS5cblx0XHQgKiBAcHJvcGVydHkgdGV4dFxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqIEBkZWZhdWx0IFwiXCJcblx0XHQgKiovXG5cdFx0dGhpcy50ZXh0ID0gdGV4dHx8XCJcIjtcblx0XHRcblx0XHQvKipcblx0XHQgKiBBIFNwcml0ZVNoZWV0IGluc3RhbmNlIHRoYXQgZGVmaW5lcyB0aGUgZ2x5cGhzIGZvciB0aGlzIGJpdG1hcCB0ZXh0LiBFYWNoIGdseXBoL2NoYXJhY3RlclxuXHRcdCAqIHNob3VsZCBoYXZlIGEgc2luZ2xlIGZyYW1lIGFuaW1hdGlvbiBkZWZpbmVkIGluIHRoZSBzcHJpdGUgc2hlZXQgbmFtZWQgdGhlIHNhbWUgYXNcblx0XHQgKiBjb3JyZXNwb25kaW5nIGNoYXJhY3Rlci4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgYW5pbWF0aW9uIGRlZmluaXRpb246XG5cdFx0ICpcblx0XHQgKiBcdFx0XCJBXCI6IHtmcmFtZXM6IFswXX1cblx0XHQgKlxuXHRcdCAqIHdvdWxkIGluZGljYXRlIHRoYXQgdGhlIGZyYW1lIGF0IGluZGV4IDAgb2YgdGhlIHNwcml0ZXNoZWV0IHNob3VsZCBiZSBkcmF3biBmb3IgdGhlIFwiQVwiIGNoYXJhY3Rlci4gVGhlIHNob3J0IGZvcm1cblx0XHQgKiBpcyBhbHNvIGFjY2VwdGFibGU6XG5cdFx0ICogXG5cdFx0ICogXHRcdFwiQVwiOiAwXG5cdFx0ICpcblx0XHQgKiBOb3RlIHRoYXQgaWYgYSBjaGFyYWN0ZXIgaW4gdGhlIHRleHQgaXMgbm90IGZvdW5kIGluIHRoZSBzcHJpdGUgc2hlZXQsIGl0IHdpbGwgYWxzb1xuXHRcdCAqIHRyeSB0byB1c2UgdGhlIGFsdGVybmF0ZSBjYXNlICh1cHBlciBvciBsb3dlcikuXG5cdFx0ICpcblx0XHQgKiBTZWUgU3ByaXRlU2hlZXQgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gZGVmaW5pbmcgc3ByaXRlIHNoZWV0IGRhdGEuXG5cdFx0ICogQHByb3BlcnR5IHNwcml0ZVNoZWV0XG5cdFx0ICogQHR5cGUgU3ByaXRlU2hlZXRcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMuc3ByaXRlU2hlZXQgPSBzcHJpdGVTaGVldDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGhlaWdodCBvZiBlYWNoIGxpbmUgb2YgdGV4dC4gSWYgMCwgdGhlbiBpdCB3aWxsIHVzZSBhIGxpbmUgaGVpZ2h0IGNhbGN1bGF0ZWRcblx0XHQgKiBieSBjaGVja2luZyBmb3IgdGhlIGhlaWdodCBvZiB0aGUgXCIxXCIsIFwiVFwiLCBvciBcIkxcIiBjaGFyYWN0ZXIgKGluIHRoYXQgb3JkZXIpLiBJZlxuXHRcdCAqIHRob3NlIGNoYXJhY3RlcnMgYXJlIG5vdCBkZWZpbmVkLCBpdCB3aWxsIHVzZSB0aGUgaGVpZ2h0IG9mIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGVcblx0XHQgKiBzcHJpdGUgc2hlZXQuXG5cdFx0ICogQHByb3BlcnR5IGxpbmVIZWlnaHRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMubGluZUhlaWdodCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgc3BhY2luZyAoaW4gcGl4ZWxzKSB3aWxsIGJlIGFkZGVkIGFmdGVyIGVhY2ggY2hhcmFjdGVyIGluIHRoZSBvdXRwdXQuXG5cdFx0ICogQHByb3BlcnR5IGxldHRlclNwYWNpbmdcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMubGV0dGVyU3BhY2luZyA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIGEgc3BhY2UgY2hhcmFjdGVyIGlzIG5vdCBkZWZpbmVkIGluIHRoZSBzcHJpdGUgc2hlZXQsIHRoZW4gZW1wdHkgcGl4ZWxzIGVxdWFsIHRvXG5cdFx0ICogc3BhY2VXaWR0aCB3aWxsIGJlIGluc2VydGVkIGluc3RlYWQuIElmIDAsIHRoZW4gaXQgd2lsbCB1c2UgYSB2YWx1ZSBjYWxjdWxhdGVkXG5cdFx0ICogYnkgY2hlY2tpbmcgZm9yIHRoZSB3aWR0aCBvZiB0aGUgXCIxXCIsIFwibFwiLCBcIkVcIiwgb3IgXCJBXCIgY2hhcmFjdGVyIChpbiB0aGF0IG9yZGVyKS4gSWZcblx0XHQgKiB0aG9zZSBjaGFyYWN0ZXJzIGFyZSBub3QgZGVmaW5lZCwgaXQgd2lsbCB1c2UgdGhlIHdpZHRoIG9mIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGVcblx0XHQgKiBzcHJpdGUgc2hlZXQuXG5cdFx0ICogQHByb3BlcnR5IHNwYWNlV2lkdGhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMuc3BhY2VXaWR0aCA9IDA7XG5cdFx0XG5cdFx0XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0IFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9vbGRQcm9wc1xuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5fb2xkUHJvcHMgPSB7dGV4dDowLHNwcml0ZVNoZWV0OjAsbGluZUhlaWdodDowLGxldHRlclNwYWNpbmc6MCxzcGFjZVdpZHRoOjB9O1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEJpdG1hcFRleHQsIGNyZWF0ZWpzLkNvbnRhaW5lcik7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG4vLyBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIEJpdG1hcFRleHQgdXNlcyBTcHJpdGUgaW5zdGFuY2VzIHRvIGRyYXcgdGV4dC4gVG8gcmVkdWNlIHRoZSBjcmVhdGlvbiBhbmQgZGVzdHJ1Y3Rpb24gb2YgaW5zdGFuY2VzIChhbmQgdGh1cyBnYXJiYWdlIGNvbGxlY3Rpb24pLCBpdCBtYWludGFpbnNcblx0ICogYW4gaW50ZXJuYWwgb2JqZWN0IHBvb2wgb2Ygc3ByaXRlIGluc3RhbmNlcyB0byByZXVzZS4gSW5jcmVhc2luZyB0aGlzIHZhbHVlIGNhbiBjYXVzZSBtb3JlIHNwcml0ZXMgdG8gYmVcblx0ICogcmV0YWluZWQsIHNsaWdodGx5IGluY3JlYXNpbmcgbWVtb3J5IHVzZSwgYnV0IHJlZHVjaW5nIGluc3RhbnRpYXRpb24uXG5cdCAqIEBwcm9wZXJ0eSBtYXhQb29sU2l6ZVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVmYXVsdCAxMDBcblx0ICoqL1xuXHRCaXRtYXBUZXh0Lm1heFBvb2xTaXplID0gMTAwO1xuXHRcblx0LyoqXG5cdCAqIFNwcml0ZSBvYmplY3QgcG9vbC5cblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRCaXRtYXBUZXh0Ll9zcHJpdGVQb29sID0gW107XG5cblx0XG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIERvY2NlZCBpbiBzdXBlcmNsYXNzLlxuXHQgKiovXG5cdHAuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgaWdub3JlQ2FjaGUpIHtcblx0XHRpZiAodGhpcy5EaXNwbGF5T2JqZWN0X2RyYXcoY3R4LCBpZ25vcmVDYWNoZSkpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5fdXBkYXRlVGV4dCgpO1xuXHRcdHRoaXMuQ29udGFpbmVyX2RyYXcoY3R4LCBpZ25vcmVDYWNoZSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogRG9jY2VkIGluIHN1cGVyY2xhc3MuXG5cdCAqKi9cblx0cC5nZXRCb3VuZHMgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl91cGRhdGVUZXh0KCk7XG5cdFx0cmV0dXJuIHRoaXMuQ29udGFpbmVyX2dldEJvdW5kcygpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXMuXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBpc1Zpc2libGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcblx0ICoqL1xuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYXNDb250ZW50ID0gdGhpcy5jYWNoZUNhbnZhcyB8fCAodGhpcy5zcHJpdGVTaGVldCAmJiB0aGlzLnNwcml0ZVNoZWV0LmNvbXBsZXRlICYmIHRoaXMudGV4dCk7XG5cdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPT0gMCAmJiB0aGlzLnNjYWxlWSAhPT0gMCAmJiBoYXNDb250ZW50KTtcblx0fTtcblx0XG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmVQcm9wcyhuZXcgQml0bWFwVGV4dCh0aGlzLnRleHQsIHRoaXMuc3ByaXRlU2hlZXQpKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiA8c3Ryb25nPkRpc2FibGVkIGluIEJpdG1hcFRleHQuPC9zdHJvbmc+XG5cdCAqIEBtZXRob2QgYWRkQ2hpbGRcblx0ICoqL1xuXHQvKipcblx0ICogPHN0cm9uZz5EaXNhYmxlZCBpbiBCaXRtYXBUZXh0Ljwvc3Ryb25nPlxuXHQgKiBAbWV0aG9kIGFkZENoaWxkQXRcblx0ICoqL1xuXHQvKipcblx0ICogPHN0cm9uZz5EaXNhYmxlZCBpbiBCaXRtYXBUZXh0Ljwvc3Ryb25nPlxuXHQgKiBAbWV0aG9kIHJlbW92ZUNoaWxkXG5cdCAqKi9cblx0LyoqXG5cdCAqIDxzdHJvbmc+RGlzYWJsZWQgaW4gQml0bWFwVGV4dC48L3N0cm9uZz5cblx0ICogQG1ldGhvZCByZW1vdmVDaGlsZEF0XG5cdCAqKi9cblx0LyoqXG5cdCAqIDxzdHJvbmc+RGlzYWJsZWQgaW4gQml0bWFwVGV4dC48L3N0cm9uZz5cblx0ICogQG1ldGhvZCByZW1vdmVBbGxDaGlsZHJlblxuXHQgKiovXG5cdHAuYWRkQ2hpbGQgPSBwLmFkZENoaWxkQXQgPSBwLnJlbW92ZUNoaWxkID0gcC5yZW1vdmVDaGlsZEF0ID0gcC5yZW1vdmVBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uKCkge307XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuIFx0LyoqXG5cdCAqIEBtZXRob2QgX2Nsb25lUHJvcHNcblx0ICogQHBhcmFtIHtCaXRtYXBUZXh0fSBvXG5cdCAqIEByZXR1cm4ge0JpdG1hcFRleHR9IG9cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2Nsb25lUHJvcHMgPSBmdW5jdGlvbihvKSB7XG5cdFx0dGhpcy5Db250YWluZXJfX2Nsb25lUHJvcHMobyk7XG5cdFx0by5saW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0O1xuXHRcdG8ubGV0dGVyU3BhY2luZyA9IHRoaXMubGV0dGVyU3BhY2luZztcblx0XHRvLnNwYWNlV2lkdGggPSB0aGlzLnNwYWNlV2lkdGg7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0RnJhbWVJbmRleFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY2hhcmFjdGVyXG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IHNwcml0ZVNoZWV0XG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dldEZyYW1lSW5kZXggPSBmdW5jdGlvbihjaGFyYWN0ZXIsIHNwcml0ZVNoZWV0KSB7XG5cdFx0dmFyIGMsIG8gPSBzcHJpdGVTaGVldC5nZXRBbmltYXRpb24oY2hhcmFjdGVyKTtcblx0XHRpZiAoIW8pIHtcblx0XHRcdChjaGFyYWN0ZXIgIT0gKGMgPSBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKSkpIHx8IChjaGFyYWN0ZXIgIT0gKGMgPSBjaGFyYWN0ZXIudG9Mb3dlckNhc2UoKSkpIHx8IChjPW51bGwpO1xuXHRcdFx0aWYgKGMpIHsgbyA9IHNwcml0ZVNoZWV0LmdldEFuaW1hdGlvbihjKTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gbyAmJiBvLmZyYW1lc1swXTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRGcmFtZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY2hhcmFjdGVyXG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IHNwcml0ZVNoZWV0XG5cdCAqIEByZXR1cm4ge09iamVjdH1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dldEZyYW1lID0gZnVuY3Rpb24oY2hhcmFjdGVyLCBzcHJpdGVTaGVldCkge1xuXHRcdHZhciBpbmRleCA9IHRoaXMuX2dldEZyYW1lSW5kZXgoY2hhcmFjdGVyLCBzcHJpdGVTaGVldCk7XG5cdFx0cmV0dXJuIGluZGV4ID09IG51bGwgPyBpbmRleCA6IHNwcml0ZVNoZWV0LmdldEZyYW1lKGluZGV4KTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRMaW5lSGVpZ2h0XG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IHNzXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dldExpbmVIZWlnaHQgPSBmdW5jdGlvbihzcykge1xuXHRcdHZhciBmcmFtZSA9IHRoaXMuX2dldEZyYW1lKFwiMVwiLHNzKSB8fCB0aGlzLl9nZXRGcmFtZShcIlRcIixzcykgfHwgdGhpcy5fZ2V0RnJhbWUoXCJMXCIsc3MpIHx8IHNzLmdldEZyYW1lKDApO1xuXHRcdHJldHVybiBmcmFtZSA/IGZyYW1lLnJlY3QuaGVpZ2h0IDogMTtcblx0fTtcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldFNwYWNlV2lkdGhcblx0ICogQHBhcmFtIHtTcHJpdGVTaGVldH0gc3Ncblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ2V0U3BhY2VXaWR0aCA9IGZ1bmN0aW9uKHNzKSB7XG5cdFx0dmFyIGZyYW1lID0gdGhpcy5fZ2V0RnJhbWUoXCIxXCIsc3MpIHx8IHRoaXMuX2dldEZyYW1lKFwibFwiLHNzKSB8fCB0aGlzLl9nZXRGcmFtZShcImVcIixzcykgfHwgdGhpcy5fZ2V0RnJhbWUoXCJhXCIsc3MpIHx8IHNzLmdldEZyYW1lKDApO1xuXHRcdHJldHVybiBmcmFtZSA/IGZyYW1lLnJlY3Qud2lkdGggOiAxO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2RyYXdUZXh0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl91cGRhdGVUZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHg9MCwgeT0wLCBvPXRoaXMuX29sZFByb3BzLCBjaGFuZ2U9ZmFsc2UsIHNwYWNlVz10aGlzLnNwYWNlV2lkdGgsIGxpbmVIPXRoaXMubGluZUhlaWdodCwgc3M9dGhpcy5zcHJpdGVTaGVldDtcblx0XHR2YXIgcG9vbD1CaXRtYXBUZXh0Ll9zcHJpdGVQb29sLCBraWRzPXRoaXMuY2hpbGRyZW4sIGNoaWxkSW5kZXg9MCwgbnVtS2lkcz1raWRzLmxlbmd0aCwgc3ByaXRlO1xuXHRcdFxuXHRcdGZvciAodmFyIG4gaW4gbykge1xuXHRcdFx0aWYgKG9bbl0gIT0gdGhpc1tuXSkge1xuXHRcdFx0XHRvW25dID0gdGhpc1tuXTtcblx0XHRcdFx0Y2hhbmdlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFjaGFuZ2UpIHsgcmV0dXJuOyB9XG5cdFx0XG5cdFx0dmFyIGhhc1NwYWNlID0gISF0aGlzLl9nZXRGcmFtZShcIiBcIiwgc3MpO1xuXHRcdGlmICghaGFzU3BhY2UgJiYgIXNwYWNlVykgeyBzcGFjZVcgPSB0aGlzLl9nZXRTcGFjZVdpZHRoKHNzKTsgfVxuXHRcdGlmICghbGluZUgpIHsgbGluZUggPSB0aGlzLl9nZXRMaW5lSGVpZ2h0KHNzKTsgfVxuXHRcdFxuXHRcdGZvcih2YXIgaT0wLCBsPXRoaXMudGV4dC5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hhcmFjdGVyID0gdGhpcy50ZXh0LmNoYXJBdChpKTtcblx0XHRcdGlmIChjaGFyYWN0ZXIgPT0gXCIgXCIgJiYgIWhhc1NwYWNlKSB7XG5cdFx0XHRcdHggKz0gc3BhY2VXO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSBpZiAoY2hhcmFjdGVyPT1cIlxcblwiIHx8IGNoYXJhY3Rlcj09XCJcXHJcIikge1xuXHRcdFx0XHRpZiAoY2hhcmFjdGVyPT1cIlxcclwiICYmIHRoaXMudGV4dC5jaGFyQXQoaSsxKSA9PSBcIlxcblwiKSB7IGkrKzsgfSAvLyBjcmxmXG5cdFx0XHRcdHggPSAwO1xuXHRcdFx0XHR5ICs9IGxpbmVIO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGluZGV4ID0gdGhpcy5fZ2V0RnJhbWVJbmRleChjaGFyYWN0ZXIsIHNzKTtcblx0XHRcdGlmIChpbmRleCA9PSBudWxsKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRcblx0XHRcdGlmIChjaGlsZEluZGV4IDwgbnVtS2lkcykge1xuXHRcdFx0XHRzcHJpdGUgPSBraWRzW2NoaWxkSW5kZXhdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2lkcy5wdXNoKHNwcml0ZSA9IHBvb2wubGVuZ3RoID8gcG9vbC5wb3AoKSA6IG5ldyBjcmVhdGVqcy5TcHJpdGUoKSk7XG5cdFx0XHRcdHNwcml0ZS5wYXJlbnQgPSB0aGlzO1xuXHRcdFx0XHRudW1LaWRzKys7XG5cdFx0XHR9XG5cdFx0XHRzcHJpdGUuc3ByaXRlU2hlZXQgPSBzcztcblx0XHRcdHNwcml0ZS5nb3RvQW5kU3RvcChpbmRleCk7XG5cdFx0XHRzcHJpdGUueCA9IHg7XG5cdFx0XHRzcHJpdGUueSA9IHk7XG5cdFx0XHRjaGlsZEluZGV4Kys7XG5cdFx0XHRcblx0XHRcdHggKz0gc3ByaXRlLmdldEJvdW5kcygpLndpZHRoICsgdGhpcy5sZXR0ZXJTcGFjaW5nO1xuXHRcdH1cblx0XHR3aGlsZSAobnVtS2lkcyA+IGNoaWxkSW5kZXgpIHtcblx0XHRcdCAvLyBmYXN0ZXIgdGhhbiByZW1vdmVDaGlsZC5cblx0XHRcdHBvb2wucHVzaChzcHJpdGUgPSBraWRzLnBvcCgpKTtcblx0XHRcdHNwcml0ZS5wYXJlbnQgPSBudWxsO1xuXHRcdFx0bnVtS2lkcy0tO1xuXHRcdH1cblx0XHRpZiAocG9vbC5sZW5ndGggPiBCaXRtYXBUZXh0Lm1heFBvb2xTaXplKSB7IHBvb2wubGVuZ3RoID0gQml0bWFwVGV4dC5tYXhQb29sU2l6ZTsgfVxuXHR9O1xuXG5cblx0Y3JlYXRlanMuQml0bWFwVGV4dCA9IGNyZWF0ZWpzLnByb21vdGUoQml0bWFwVGV4dCwgXCJDb250YWluZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU3ByaXRlU2hlZXRVdGlscy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdFxyXG5cdFxyXG4vLyBjb25zdHJ1Y3RvcjpcclxuXHQvKipcclxuXHQgKiBUaGUgU3ByaXRlU2hlZXRVdGlscyBjbGFzcyBpcyBhIGNvbGxlY3Rpb24gb2Ygc3RhdGljIG1ldGhvZHMgZm9yIHdvcmtpbmcgd2l0aCB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fXMuXHJcblx0ICogQSBzcHJpdGUgc2hlZXQgaXMgYSBzZXJpZXMgb2YgaW1hZ2VzICh1c3VhbGx5IGFuaW1hdGlvbiBmcmFtZXMpIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgaW1hZ2Ugb24gYSByZWd1bGFyIGdyaWQuIEZvclxyXG5cdCAqIGV4YW1wbGUsIGFuIGFuaW1hdGlvbiBjb25zaXN0aW5nIG9mIDggMTAweDEwMCBpbWFnZXMgY291bGQgYmUgY29tYmluZWQgaW50byBhIDQwMHgyMDAgc3ByaXRlIHNoZWV0ICg0IGZyYW1lcyBhY3Jvc3NcclxuXHQgKiBieSAyIGhpZ2gpLiBUaGUgU3ByaXRlU2hlZXRVdGlscyBjbGFzcyB1c2VzIGEgc3RhdGljIGludGVyZmFjZSBhbmQgc2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQuXHJcblx0ICogQGNsYXNzIFNwcml0ZVNoZWV0VXRpbHNcclxuXHQgKiBAc3RhdGljXHJcblx0ICoqL1xyXG5cdGZ1bmN0aW9uIFNwcml0ZVNoZWV0VXRpbHMoKSB7XHJcblx0XHR0aHJvdyBcIlNwcml0ZVNoZWV0VXRpbHMgY2Fubm90IGJlIGluc3RhbnRpYXRlZFwiO1xyXG5cdH1cclxuXHJcblxyXG4vLyBwcml2YXRlIHN0YXRpYyBwcm9wZXJ0aWVzOlxyXG5cdC8qKlxyXG5cdCAqIEBwcm9wZXJ0eSBfd29ya2luZ0NhbnZhc1xyXG5cdCAqIEBzdGF0aWNcclxuXHQgKiBAdHlwZSBIVE1MQ2FudmFzRWxlbWVudCB8IE9iamVjdFxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQqL1xyXG5cdC8qKlxyXG5cdCAqIEBwcm9wZXJ0eSBfd29ya2luZ0NvbnRleHRcclxuXHQgKiBAc3RhdGljXHJcblx0ICogQHR5cGUgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCovXHJcblx0dmFyIGNhbnZhcyA9IChjcmVhdGVqcy5jcmVhdGVDYW52YXM/Y3JlYXRlanMuY3JlYXRlQ2FudmFzKCk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSk7XHJcblx0aWYgKGNhbnZhcy5nZXRDb250ZXh0KSB7XHJcblx0XHRTcHJpdGVTaGVldFV0aWxzLl93b3JraW5nQ2FudmFzID0gY2FudmFzO1xyXG5cdFx0U3ByaXRlU2hlZXRVdGlscy5fd29ya2luZ0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDE7XHJcblx0fVxyXG5cclxuXHJcbi8vIHB1YmxpYyBzdGF0aWMgbWV0aG9kczpcclxuXHQvKipcclxuXHQgKiA8Yj5UaGlzIGlzIGFuIGV4cGVyaW1lbnRhbCBtZXRob2QsIGFuZCBtYXkgYmUgYnVnZ3kuIFBsZWFzZSByZXBvcnQgaXNzdWVzLjwvYj48YnIvPjxici8+XHJcblx0ICogRXh0ZW5kcyB0aGUgZXhpc3Rpbmcgc3ByaXRlIHNoZWV0IGJ5IGZsaXBwaW5nIHRoZSBvcmlnaW5hbCBmcmFtZXMgaG9yaXpvbnRhbGx5LCB2ZXJ0aWNhbGx5LCBvciBib3RoLFxyXG5cdCAqIGFuZCBhZGRpbmcgYXBwcm9wcmlhdGUgYW5pbWF0aW9uICYgZnJhbWUgZGF0YS4gVGhlIGZsaXBwZWQgYW5pbWF0aW9ucyB3aWxsIGhhdmUgYSBzdWZmaXggYWRkZWQgdG8gdGhlaXIgbmFtZXNcclxuXHQgKiAoX2gsIF92LCBfaHYgYXMgYXBwcm9wcmlhdGUpLiBNYWtlIHN1cmUgdGhlIHNwcml0ZSBzaGVldCBpbWFnZXMgYXJlIGZ1bGx5IGxvYWRlZCBiZWZvcmUgdXNpbmcgdGhpcyBtZXRob2QuXHJcblx0ICogPGJyLz48YnIvPlxyXG5cdCAqIEZvciBleGFtcGxlOjxici8+XHJcblx0ICogU3ByaXRlU2hlZXRVdGlscy5hZGRGbGlwcGVkRnJhbWVzKG15U3ByaXRlU2hlZXQsIHRydWUsIHRydWUpO1xyXG5cdCAqIFRoZSBhYm92ZSB3b3VsZCBhZGQgZnJhbWVzIHRoYXQgYXJlIGZsaXBwZWQgaG9yaXpvbnRhbGx5IEFORCBmcmFtZXMgdGhhdCBhcmUgZmxpcHBlZCB2ZXJ0aWNhbGx5LlxyXG5cdCAqIDxici8+PGJyLz5cclxuXHQgKiBOb3RlIHRoYXQgeW91IGNhbiBhbHNvIGZsaXAgYW55IGRpc3BsYXkgb2JqZWN0IGJ5IHNldHRpbmcgaXRzIHNjYWxlWCBvciBzY2FsZVkgdG8gYSBuZWdhdGl2ZSB2YWx1ZS4gT24gc29tZVxyXG5cdCAqIGJyb3dzZXJzIChlc3BlY2lhbGx5IHRob3NlIHdpdGhvdXQgaGFyZHdhcmUgYWNjZWxlcmF0ZWQgY2FudmFzKSB0aGlzIGNhbiByZXN1bHQgaW4gc2xpZ2h0bHkgZGVncmFkZWQgcGVyZm9ybWFuY2UsXHJcblx0ICogd2hpY2ggaXMgd2h5IGFkZEZsaXBwZWRGcmFtZXMgaXMgYXZhaWxhYmxlLlxyXG5cdCAqIEBtZXRob2QgYWRkRmxpcHBlZEZyYW1lc1xyXG5cdCAqIEBzdGF0aWNcclxuXHQgKiBAcGFyYW0ge1Nwcml0ZVNoZWV0fSBzcHJpdGVTaGVldFxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaG9yaXpvbnRhbCBJZiB0cnVlLCBob3Jpem9udGFsbHkgZmxpcHBlZCBmcmFtZXMgd2lsbCBiZSBhZGRlZC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZlcnRpY2FsIElmIHRydWUsIHZlcnRpY2FsbHkgZmxpcHBlZCBmcmFtZXMgd2lsbCBiZSBhZGRlZC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGJvdGggSWYgdHJ1ZSwgZnJhbWVzIHRoYXQgYXJlIGZsaXBwZWQgYm90aCBob3Jpem9udGFsbHkgYW5kIHZlcnRpY2FsbHkgd2lsbCBiZSBhZGRlZC5cclxuXHQgKiBAZGVwcmVjYXRlZCBNb2Rlcm4gYnJvd3NlcnMgcGVyZm9ybSBiZXR0ZXIgd2hlbiBmbGlwcGluZyB2aWEgYSB0cmFuc2Zvcm0gKGV4LiBzY2FsZVg9LTEpIHJlbmRlcmluZyB0aGlzIG9ic29sZXRlLlxyXG5cdCAqKi9cclxuXHRTcHJpdGVTaGVldFV0aWxzLmFkZEZsaXBwZWRGcmFtZXMgPSBmdW5jdGlvbihzcHJpdGVTaGVldCwgaG9yaXpvbnRhbCwgdmVydGljYWwsIGJvdGgpIHtcclxuXHRcdGlmICghaG9yaXpvbnRhbCAmJiAhdmVydGljYWwgJiYgIWJvdGgpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGNvdW50ID0gMDtcclxuXHRcdGlmIChob3Jpem9udGFsKSB7IFNwcml0ZVNoZWV0VXRpbHMuX2ZsaXAoc3ByaXRlU2hlZXQsKytjb3VudCx0cnVlLGZhbHNlKTsgfVxyXG5cdFx0aWYgKHZlcnRpY2FsKSB7IFNwcml0ZVNoZWV0VXRpbHMuX2ZsaXAoc3ByaXRlU2hlZXQsKytjb3VudCxmYWxzZSx0cnVlKTsgfVxyXG5cdFx0aWYgKGJvdGgpIHsgU3ByaXRlU2hlZXRVdGlscy5fZmxpcChzcHJpdGVTaGVldCwrK2NvdW50LHRydWUsdHJ1ZSk7IH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgc2luZ2xlIGZyYW1lIG9mIHRoZSBzcGVjaWZpZWQgc3ByaXRlIHNoZWV0IGFzIGEgbmV3IFBORyBpbWFnZS4gQW4gZXhhbXBsZSBvZiB3aGVuIHRoaXMgbWF5IGJlIHVzZWZ1bCBpc1xyXG5cdCAqIHRvIHVzZSBhIHNwcml0ZXNoZWV0IGZyYW1lIGFzIHRoZSBzb3VyY2UgZm9yIGEgYml0bWFwIGZpbGwuXHJcblx0ICpcclxuXHQgKiA8c3Ryb25nPldBUk5JTkc6PC9zdHJvbmc+IEluIGFsbW9zdCBhbGwgY2FzZXMgaXQgaXMgYmV0dGVyIHRvIGRpc3BsYXkgYSBzaW5nbGUgZnJhbWUgdXNpbmcgYSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVcIn19e3svY3Jvc3NMaW5rfX1cclxuXHQgKiB3aXRoIGEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319IGNhbGwgdGhhbiBpdCBpcyB0byBzbGljZSBvdXQgYSBmcmFtZSB1c2luZyB0aGlzXHJcblx0ICogbWV0aG9kIGFuZCBkaXNwbGF5IGl0IHdpdGggYSBCaXRtYXAgaW5zdGFuY2UuIFlvdSBjYW4gYWxzbyBjcm9wIGFuIGltYWdlIHVzaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJCaXRtYXAvc291cmNlUmVjdFwifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIHByb3BlcnR5IG9mIHt7I2Nyb3NzTGluayBcIkJpdG1hcFwifX17ey9jcm9zc0xpbmt9fS5cclxuXHQgKlxyXG5cdCAqIFRoZSBleHRyYWN0RnJhbWUgbWV0aG9kIG1heSBjYXVzZSBjcm9zcy1kb21haW4gd2FybmluZ3Mgc2luY2UgaXQgYWNjZXNzZXMgcGl4ZWxzIGRpcmVjdGx5IG9uIHRoZSBjYW52YXMuXHJcblx0ICogQG1ldGhvZCBleHRyYWN0RnJhbWVcclxuXHQgKiBAc3RhdGljXHJcblx0ICogQHBhcmFtIHtTcHJpdGVTaGVldH0gc3ByaXRlU2hlZXQgVGhlIFNwcml0ZVNoZWV0IGluc3RhbmNlIHRvIGV4dHJhY3QgYSBmcmFtZSBmcm9tLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gZnJhbWVPckFuaW1hdGlvbiBUaGUgZnJhbWUgbnVtYmVyIG9yIGFuaW1hdGlvbiBuYW1lIHRvIGV4dHJhY3QuIElmIGFuIGFuaW1hdGlvblxyXG5cdCAqIG5hbWUgaXMgc3BlY2lmaWVkLCBvbmx5IHRoZSBmaXJzdCBmcmFtZSBvZiB0aGUgYW5pbWF0aW9uIHdpbGwgYmUgZXh0cmFjdGVkLlxyXG5cdCAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IGEgc2luZ2xlIGZyYW1lIG9mIHRoZSBzcGVjaWZpZWQgc3ByaXRlIHNoZWV0IGFzIGEgbmV3IFBORyBpbWFnZS5cclxuXHQqL1xyXG5cdFNwcml0ZVNoZWV0VXRpbHMuZXh0cmFjdEZyYW1lID0gZnVuY3Rpb24oc3ByaXRlU2hlZXQsIGZyYW1lT3JBbmltYXRpb24pIHtcclxuXHRcdGlmIChpc05hTihmcmFtZU9yQW5pbWF0aW9uKSkge1xyXG5cdFx0XHRmcmFtZU9yQW5pbWF0aW9uID0gc3ByaXRlU2hlZXQuZ2V0QW5pbWF0aW9uKGZyYW1lT3JBbmltYXRpb24pLmZyYW1lc1swXTtcclxuXHRcdH1cclxuXHRcdHZhciBkYXRhID0gc3ByaXRlU2hlZXQuZ2V0RnJhbWUoZnJhbWVPckFuaW1hdGlvbik7XHJcblx0XHRpZiAoIWRhdGEpIHsgcmV0dXJuIG51bGw7IH1cclxuXHRcdHZhciByID0gZGF0YS5yZWN0O1xyXG5cdFx0dmFyIGNhbnZhcyA9IFNwcml0ZVNoZWV0VXRpbHMuX3dvcmtpbmdDYW52YXM7XHJcblx0XHRjYW52YXMud2lkdGggPSByLndpZHRoO1xyXG5cdFx0Y2FudmFzLmhlaWdodCA9IHIuaGVpZ2h0O1xyXG5cdFx0U3ByaXRlU2hlZXRVdGlscy5fd29ya2luZ0NvbnRleHQuZHJhd0ltYWdlKGRhdGEuaW1hZ2UsIHIueCwgci55LCByLndpZHRoLCByLmhlaWdodCwgMCwgMCwgci53aWR0aCwgci5oZWlnaHQpO1xyXG5cdFx0dmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XHJcblx0XHRpbWcuc3JjID0gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcclxuXHRcdHJldHVybiBpbWc7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogTWVyZ2VzIHRoZSByZ2IgY2hhbm5lbHMgb2Ygb25lIGltYWdlIHdpdGggdGhlIGFscGhhIGNoYW5uZWwgb2YgYW5vdGhlci4gVGhpcyBjYW4gYmUgdXNlZCB0byBjb21iaW5lIGEgY29tcHJlc3NlZFxyXG5cdCAqIEpQRUcgaW1hZ2UgY29udGFpbmluZyBjb2xvciBkYXRhIHdpdGggYSBQTkczMiBtb25vY2hyb21hdGljIGltYWdlIGNvbnRhaW5pbmcgYWxwaGEgZGF0YS4gV2l0aCBjZXJ0YWluIHR5cGVzIG9mXHJcblx0ICogaW1hZ2VzICh0aG9zZSB3aXRoIGRldGFpbCB0aGF0IGxlbmQgaXRzZWxmIHRvIEpQRUcgY29tcHJlc3Npb24pIHRoaXMgY2FuIHByb3ZpZGUgc2lnbmlmaWNhbnQgZmlsZSBzaXplIHNhdmluZ3NcclxuXHQgKiB2ZXJzdXMgYSBzaW5nbGUgUkdCQSBQTkczMi4gVGhpcyBtZXRob2QgaXMgdmVyeSBmYXN0IChnZW5lcmFsbHkgb24gdGhlIG9yZGVyIG9mIDEtMiBtcyB0byBydW4pLlxyXG5cdCAqIEBtZXRob2QgbWVyZ2VBbHBoYVxyXG5cdCAqIEBzdGF0aWNcclxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IHJiZ0ltYWdlIFRoZSBpbWFnZSAob3IgY2FudmFzKSBjb250YWluaW5nIHRoZSBSR0IgY2hhbm5lbHMgdG8gdXNlLlxyXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gYWxwaGFJbWFnZSBUaGUgaW1hZ2UgKG9yIGNhbnZhcykgY29udGFpbmluZyB0aGUgYWxwaGEgY2hhbm5lbCB0byB1c2UuXHJcblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgY2FudmFzIHdpbGwgYmUgdXNlZCBhbmQgcmV0dXJuZWQuIElmIG5vdCwgYSBuZXcgY2FudmFzIHdpbGwgYmUgY3JlYXRlZC5cclxuXHQgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gQSBjYW52YXMgd2l0aCB0aGUgY29tYmluZWQgaW1hZ2UgZGF0YS4gVGhpcyBjYW4gYmUgdXNlZCBhcyBhIHNvdXJjZSBmb3IgQml0bWFwIG9yIFNwcml0ZVNoZWV0LlxyXG5cdCAqIEBkZXByZWNhdGVkIFRvb2xzIHN1Y2ggYXMgSW1hZ2VBbHBoYSBnZW5lcmFsbHkgcHJvdmlkZSBiZXR0ZXIgcmVzdWx0cy4gVGhpcyB3aWxsIGJlIG1vdmVkIHRvIHNhbmRib3ggaW4gdGhlIGZ1dHVyZS5cclxuXHQqL1xyXG5cdFNwcml0ZVNoZWV0VXRpbHMubWVyZ2VBbHBoYSA9IGZ1bmN0aW9uKHJnYkltYWdlLCBhbHBoYUltYWdlLCBjYW52YXMpIHtcclxuXHRcdGlmICghY2FudmFzKSB7IGNhbnZhcyA9IGNyZWF0ZWpzLmNyZWF0ZUNhbnZhcz9jcmVhdGVqcy5jcmVhdGVDYW52YXMoKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpOyB9XHJcblx0XHRjYW52YXMud2lkdGggPSBNYXRoLm1heChhbHBoYUltYWdlLndpZHRoLCByZ2JJbWFnZS53aWR0aCk7XHJcblx0XHRjYW52YXMuaGVpZ2h0ID0gTWF0aC5tYXgoYWxwaGFJbWFnZS5oZWlnaHQsIHJnYkltYWdlLmhlaWdodCk7XHJcblx0XHR2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHRcdGN0eC5zYXZlKCk7XHJcblx0XHRjdHguZHJhd0ltYWdlKHJnYkltYWdlLDAsMCk7XHJcblx0XHRjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1pblwiO1xyXG5cdFx0Y3R4LmRyYXdJbWFnZShhbHBoYUltYWdlLDAsMCk7XHJcblx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdFx0cmV0dXJuIGNhbnZhcztcclxuXHR9O1xyXG5cclxuXHJcbi8vIHByaXZhdGUgc3RhdGljIG1ldGhvZHM6XHJcblx0U3ByaXRlU2hlZXRVdGlscy5fZmxpcCA9IGZ1bmN0aW9uKHNwcml0ZVNoZWV0LCBjb3VudCwgaCwgdikge1xyXG5cdFx0dmFyIGltZ3MgPSBzcHJpdGVTaGVldC5faW1hZ2VzO1xyXG5cdFx0dmFyIGNhbnZhcyA9IFNwcml0ZVNoZWV0VXRpbHMuX3dvcmtpbmdDYW52YXM7XHJcblx0XHR2YXIgY3R4ID0gU3ByaXRlU2hlZXRVdGlscy5fd29ya2luZ0NvbnRleHQ7XHJcblx0XHR2YXIgaWwgPSBpbWdzLmxlbmd0aC9jb3VudDtcclxuXHRcdGZvciAodmFyIGk9MDtpPGlsO2krKykge1xyXG5cdFx0XHR2YXIgc3JjID0gaW1nc1tpXTtcclxuXHRcdFx0c3JjLl9fdG1wID0gaTsgLy8gYSBiaXQgaGFja3ksIGJ1dCBmYXN0ZXIgdGhhbiBkb2luZyBpbmRleE9mIGJlbG93LlxyXG5cdFx0XHRjdHguc2V0VHJhbnNmb3JtKDEsMCwwLDEsMCwwKTtcclxuXHRcdFx0Y3R4LmNsZWFyUmVjdCgwLDAsY2FudmFzLndpZHRoKzEsY2FudmFzLmhlaWdodCsxKTtcclxuXHRcdFx0Y2FudmFzLndpZHRoID0gc3JjLndpZHRoO1xyXG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gc3JjLmhlaWdodDtcclxuXHRcdFx0Y3R4LnNldFRyYW5zZm9ybShoPy0xOjEsIDAsIDAsIHY/LTE6MSwgaD9zcmMud2lkdGg6MCwgdj9zcmMuaGVpZ2h0OjApO1xyXG5cdFx0XHRjdHguZHJhd0ltYWdlKHNyYywwLDApO1xyXG5cdFx0XHR2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcclxuXHRcdFx0aW1nLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XHJcblx0XHRcdC8vIHdvcmsgYXJvdW5kIGEgc3RyYW5nZSBidWcgaW4gU2FmYXJpOlxyXG5cdFx0XHRpbWcud2lkdGggPSBzcmMud2lkdGg7XHJcblx0XHRcdGltZy5oZWlnaHQgPSBzcmMuaGVpZ2h0O1xyXG5cdFx0XHRpbWdzLnB1c2goaW1nKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZnJhbWVzID0gc3ByaXRlU2hlZXQuX2ZyYW1lcztcclxuXHRcdHZhciBmbCA9IGZyYW1lcy5sZW5ndGgvY291bnQ7XHJcblx0XHRmb3IgKGk9MDtpPGZsO2krKykge1xyXG5cdFx0XHRzcmMgPSBmcmFtZXNbaV07XHJcblx0XHRcdHZhciByZWN0ID0gc3JjLnJlY3QuY2xvbmUoKTtcclxuXHRcdFx0aW1nID0gaW1nc1tzcmMuaW1hZ2UuX190bXAraWwqY291bnRdO1xyXG5cclxuXHRcdFx0dmFyIGZyYW1lID0ge2ltYWdlOmltZyxyZWN0OnJlY3QscmVnWDpzcmMucmVnWCxyZWdZOnNyYy5yZWdZfTtcclxuXHRcdFx0aWYgKGgpIHtcclxuXHRcdFx0XHRyZWN0LnggPSBpbWcud2lkdGgtcmVjdC54LXJlY3Qud2lkdGg7IC8vIHVwZGF0ZSByZWN0XHJcblx0XHRcdFx0ZnJhbWUucmVnWCA9IHJlY3Qud2lkdGgtc3JjLnJlZ1g7IC8vIHVwZGF0ZSByZWdpc3RyYXRpb24gcG9pbnRcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodikge1xyXG5cdFx0XHRcdHJlY3QueSA9IGltZy5oZWlnaHQtcmVjdC55LXJlY3QuaGVpZ2h0OyAgLy8gdXBkYXRlIHJlY3RcclxuXHRcdFx0XHRmcmFtZS5yZWdZID0gcmVjdC5oZWlnaHQtc3JjLnJlZ1k7IC8vIHVwZGF0ZSByZWdpc3RyYXRpb24gcG9pbnRcclxuXHRcdFx0fVxyXG5cdFx0XHRmcmFtZXMucHVzaChmcmFtZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNmeCA9IFwiX1wiKyhoP1wiaFwiOlwiXCIpKyh2P1widlwiOlwiXCIpO1xyXG5cdFx0dmFyIG5hbWVzID0gc3ByaXRlU2hlZXQuX2FuaW1hdGlvbnM7XHJcblx0XHR2YXIgZGF0YSA9IHNwcml0ZVNoZWV0Ll9kYXRhO1xyXG5cdFx0dmFyIGFsID0gbmFtZXMubGVuZ3RoL2NvdW50O1xyXG5cdFx0Zm9yIChpPTA7aTxhbDtpKyspIHtcclxuXHRcdFx0dmFyIG5hbWUgPSBuYW1lc1tpXTtcclxuXHRcdFx0c3JjID0gZGF0YVtuYW1lXTtcclxuXHRcdFx0dmFyIGFuaW0gPSB7bmFtZTpuYW1lK3NmeCxzcGVlZDpzcmMuc3BlZWQsbmV4dDpzcmMubmV4dCxmcmFtZXM6W119O1xyXG5cdFx0XHRpZiAoc3JjLm5leHQpIHsgYW5pbS5uZXh0ICs9IHNmeDsgfVxyXG5cdFx0XHRmcmFtZXMgPSBzcmMuZnJhbWVzO1xyXG5cdFx0XHRmb3IgKHZhciBqPTAsbD1mcmFtZXMubGVuZ3RoO2o8bDtqKyspIHtcclxuXHRcdFx0XHRhbmltLmZyYW1lcy5wdXNoKGZyYW1lc1tqXStmbCpjb3VudCk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZGF0YVthbmltLm5hbWVdID0gYW5pbTtcclxuXHRcdFx0bmFtZXMucHVzaChhbmltLm5hbWUpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cclxuXHRjcmVhdGVqcy5TcHJpdGVTaGVldFV0aWxzID0gU3ByaXRlU2hlZXRVdGlscztcclxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNwcml0ZVNoZWV0QnVpbGRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogVGhlIFNwcml0ZVNoZWV0QnVpbGRlciBhbGxvd3MgeW91IHRvIGdlbmVyYXRlIHNwcml0ZSBzaGVldHMgYXQgcnVuIHRpbWUgZnJvbSBhbnkgZGlzcGxheSBvYmplY3QuIFRoaXMgY2FuIGFsbG93XG5cdCAqIHlvdSB0byBtYWludGFpbiB5b3VyIGFzc2V0cyBhcyB2ZWN0b3IgZ3JhcGhpY3MgKGZvciBsb3cgZmlsZSBzaXplKSwgYW5kIHJlbmRlciB0aGVtIGF0IHJ1biB0aW1lIGFzIHNwcml0ZSBzaGVldHNcblx0ICogZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cblx0ICpcblx0ICogU3ByaXRlIHNoZWV0cyBjYW4gYmUgYnVpbHQgZWl0aGVyIHN5bmNocm9ub3VzbHksIG9yIGFzeW5jaHJvbm91c2x5LCBzbyB0aGF0IGxhcmdlIHNwcml0ZSBzaGVldHMgY2FuIGJlIGdlbmVyYXRlZFxuXHQgKiB3aXRob3V0IGxvY2tpbmcgdGhlIFVJLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIFwiaW1hZ2VzXCIgdXNlZCBpbiB0aGUgZ2VuZXJhdGVkIHNwcml0ZSBzaGVldCBhcmUgYWN0dWFsbHkgY2FudmFzIGVsZW1lbnRzLCBhbmQgdGhhdCB0aGV5IHdpbGwgYmUgc2l6ZWRcblx0ICogdG8gdGhlIG5lYXJlc3QgcG93ZXIgb2YgMiB1cCB0byB0aGUgdmFsdWUgb2YgPGNvZGU+bWF4V2lkdGg8L2NvZGU+IG9yIDxjb2RlPm1heEhlaWdodDwvY29kZT4uXG5cdCAqIEBjbGFzcyBTcHJpdGVTaGVldEJ1aWxkZXJcblx0ICogQGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIFNwcml0ZVNoZWV0QnVpbGRlcigpIHtcblx0XHR0aGlzLkV2ZW50RGlzcGF0Y2hlcl9jb25zdHJ1Y3RvcigpO1xuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgbWF4aW11bSB3aWR0aCBmb3IgdGhlIGltYWdlcyAobm90IGluZGl2aWR1YWwgZnJhbWVzKSBpbiB0aGUgZ2VuZXJhdGVkIHNwcml0ZSBzaGVldC4gSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlXG5cdFx0ICogYSBwb3dlciBvZiAyIGZvciB0aGlzIHZhbHVlIChleC4gMTAyNCwgMjA0OCwgNDA5NikuIElmIHRoZSBmcmFtZXMgY2Fubm90IGFsbCBmaXQgd2l0aGluIHRoZSBtYXggZGltZW5zaW9ucywgdGhlblxuXHRcdCAqIGFkZGl0aW9uYWwgaW1hZ2VzIHdpbGwgYmUgY3JlYXRlZCBhcyBuZWVkZWQuXG5cdFx0ICogQHByb3BlcnR5IG1heFdpZHRoXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMjA0OFxuXHRcdCovXG5cdFx0dGhpcy5tYXhXaWR0aCA9IDIwNDg7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBtYXhpbXVtIGhlaWdodCBmb3IgdGhlIGltYWdlcyAobm90IGluZGl2aWR1YWwgZnJhbWVzKSBpbiB0aGUgZ2VuZXJhdGVkIHNwcml0ZSBzaGVldC4gSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlXG5cdFx0ICogYSBwb3dlciBvZiAyIGZvciB0aGlzIHZhbHVlIChleC4gMTAyNCwgMjA0OCwgNDA5NikuIElmIHRoZSBmcmFtZXMgY2Fubm90IGFsbCBmaXQgd2l0aGluIHRoZSBtYXggZGltZW5zaW9ucywgdGhlblxuXHRcdCAqIGFkZGl0aW9uYWwgaW1hZ2VzIHdpbGwgYmUgY3JlYXRlZCBhcyBuZWVkZWQuXG5cdFx0ICogQHByb3BlcnR5IG1heEhlaWdodFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDIwNDhcblx0XHQgKiovXG5cdFx0dGhpcy5tYXhIZWlnaHQgPSAyMDQ4O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgc3ByaXRlIHNoZWV0IHRoYXQgd2FzIGdlbmVyYXRlZC4gVGhpcyB3aWxsIGJlIG51bGwgYmVmb3JlIGEgYnVpbGQgaXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cblx0XHQgKiBAcHJvcGVydHkgc3ByaXRlU2hlZXRcblx0XHQgKiBAdHlwZSBTcHJpdGVTaGVldFxuXHRcdCAqKi9cblx0XHR0aGlzLnNwcml0ZVNoZWV0ID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHNjYWxlIHRvIGFwcGx5IHdoZW4gZHJhd2luZyBhbGwgZnJhbWVzIHRvIHRoZSBzcHJpdGUgc2hlZXQuIFRoaXMgaXMgbXVsdGlwbGllZCBhZ2FpbnN0IGFueSBzY2FsZSBzcGVjaWZpZWRcblx0XHQgKiBpbiB0aGUgYWRkRnJhbWUgY2FsbC4gVGhpcyBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIHRvIGdlbmVyYXRlIGEgc3ByaXRlIHNoZWV0IGF0IHJ1biB0aW1lIHRoYXQgaXMgdGFpbG9yZWQgdG9cblx0XHQgKiB0aGUgYSBzcGVjaWZpYyBkZXZpY2UgcmVzb2x1dGlvbiAoZXguIHRhYmxldCB2cyBtb2JpbGUpLlxuXHRcdCAqIEBwcm9wZXJ0eSBzY2FsZVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKiovXG5cdFx0dGhpcy5zY2FsZSA9IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCogVGhlIHBhZGRpbmcgdG8gdXNlIGJldHdlZW4gZnJhbWVzLiBUaGlzIGlzIGhlbHBmdWwgdG8gcHJlc2VydmUgYW50aWFsaWFzaW5nIG9uIGRyYXduIHZlY3RvciBjb250ZW50LlxuXHRcdCogQHByb3BlcnR5IHBhZGRpbmdcblx0XHQqIEB0eXBlIE51bWJlclxuXHRcdCogQGRlZmF1bHQgMVxuXHRcdCoqL1xuXHRcdHRoaXMucGFkZGluZyA9IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEEgbnVtYmVyIGZyb20gMC4wMSB0byAwLjk5IHRoYXQgaW5kaWNhdGVzIHdoYXQgcGVyY2VudGFnZSBvZiB0aW1lIHRoZSBidWlsZGVyIGNhbiB1c2UuIFRoaXMgY2FuIGJlXG5cdFx0ICogdGhvdWdodCBvZiBhcyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgcGVyIHNlY29uZCB0aGUgYnVpbGRlciB3aWxsIHVzZS4gRm9yIGV4YW1wbGUsIHdpdGggYSB0aW1lU2xpY2UgdmFsdWUgb2YgMC4zLFxuXHRcdCAqIHRoZSBidWlsZGVyIHdpbGwgcnVuIDIwIHRpbWVzIHBlciBzZWNvbmQsIHVzaW5nIGFwcHJveGltYXRlbHkgMTVtcyBwZXIgYnVpbGQgKDMwJSBvZiBhdmFpbGFibGUgdGltZSwgb3IgMC4zcyBwZXIgc2Vjb25kKS5cblx0XHQgKiBEZWZhdWx0cyB0byAwLjMuXG5cdFx0ICogQHByb3BlcnR5IHRpbWVTbGljZVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDAuM1xuXHRcdCAqKi9cblx0XHR0aGlzLnRpbWVTbGljZSA9IDAuMztcblx0XG5cdFx0LyoqXG5cdFx0ICogQSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEgdGhhdCBpbmRpY2F0ZXMgdGhlIHByb2dyZXNzIG9mIGEgYnVpbGQsIG9yIC0xIGlmIGEgYnVpbGQgaGFzIG5vdFxuXHRcdCAqIGJlZW4gaW5pdGlhdGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBwcm9ncmVzc1xuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IC0xXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSAtMTtcblx0XG5cdFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9mcmFtZXNcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgQXJyYXlcblx0XHQgKiovXG5cdFx0dGhpcy5fZnJhbWVzID0gW107XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfYW5pbWF0aW9uc1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBBcnJheVxuXHRcdCAqKi9cblx0XHR0aGlzLl9hbmltYXRpb25zID0ge307XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfZGF0YVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBBcnJheVxuXHRcdCAqKi9cblx0XHR0aGlzLl9kYXRhID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9uZXh0RnJhbWVJbmRleFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fbmV4dEZyYW1lSW5kZXggPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2luZGV4XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9pbmRleCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfdGltZXJJRFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fdGltZXJJRCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfc2NhbGVcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3NjYWxlID0gMTtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTcHJpdGVTaGVldEJ1aWxkZXIsIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlcik7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cbi8vIGNvbnN0YW50czpcblx0U3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9ESU1FTlNJT05TID0gXCJmcmFtZSBkaW1lbnNpb25zIGV4Y2VlZCBtYXggc3ByaXRlc2hlZXQgZGltZW5zaW9uc1wiO1xuXHRTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX1JVTk5JTkcgPSBcImEgYnVpbGQgaXMgYWxyZWFkeSBydW5uaW5nXCI7XG5cbi8vIGV2ZW50czpcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiBhIGJ1aWxkIGNvbXBsZXRlcy5cblx0ICogQGV2ZW50IGNvbXBsZXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gYW4gYXN5bmNocm9ub3VzIGJ1aWxkIGhhcyBwcm9ncmVzcy5cblx0ICogQGV2ZW50IHByb2dyZXNzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHByb2dyZXNzIFRoZSBjdXJyZW50IHByb2dyZXNzIHZhbHVlICgwLTEpLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBBZGRzIGEgZnJhbWUgdG8gdGhlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319LiBOb3RlIHRoYXQgdGhlIGZyYW1lIHdpbGwgbm90IGJlIGRyYXduIHVudGlsIHlvdVxuXHQgKiBjYWxsIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0QnVpbGRlci9idWlsZFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuIFRoZSBvcHRpb25hbCBzZXR1cCBwYXJhbXMgYWxsb3cgeW91IHRvIGhhdmVcblx0ICogYSBmdW5jdGlvbiBydW4gaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkcmF3IG9jY3Vycy4gRm9yIGV4YW1wbGUsIHRoaXMgYWxsb3dzIHlvdSB0byBhZGQgYSBzaW5nbGUgc291cmNlIG11bHRpcGxlXG5cdCAqIHRpbWVzLCBidXQgbWFuaXB1bGF0ZSBpdCBvciBpdHMgY2hpbGRyZW4gdG8gY2hhbmdlIGl0IHRvIGdlbmVyYXRlIGRpZmZlcmVudCBmcmFtZXMuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgc291cmNlJ3MgdHJhbnNmb3JtYXRpb25zICh4LCB5LCBzY2FsZSwgcm90YXRlLCBhbHBoYSkgd2lsbCBiZSBpZ25vcmVkLCBleGNlcHQgZm9yIHJlZ1gvWS4gVG8gYXBwbHlcblx0ICogdHJhbnNmb3JtcyB0byBhIHNvdXJjZSBvYmplY3QgYW5kIGhhdmUgdGhlbSBjYXB0dXJlZCBpbiB0aGUgc3ByaXRlIHNoZWV0LCBzaW1wbHkgcGxhY2UgaXQgaW50byBhIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBhbmQgcGFzcyBpbiB0aGUgQ29udGFpbmVyIGFzIHRoZSBzb3VyY2UuXG5cdCAqIEBtZXRob2QgYWRkRnJhbWVcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0XCJ9fXt7L2Nyb3NzTGlua319ICB0byBkcmF3IGFzIHRoZSBmcmFtZS5cblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IFtzb3VyY2VSZWN0XSBBIHt7I2Nyb3NzTGluayBcIlJlY3RhbmdsZVwifX17ey9jcm9zc0xpbmt9fSBkZWZpbmluZyB0aGUgcG9ydGlvbiBvZiB0aGVcblx0ICogc291cmNlIHRvIGRyYXcgdG8gdGhlIGZyYW1lLiBJZiBub3Qgc3BlY2lmaWVkLCBpdCB3aWxsIGxvb2sgZm9yIGEgPGNvZGU+Z2V0Qm91bmRzPC9jb2RlPiBtZXRob2QsIGJvdW5kcyBwcm9wZXJ0eSxcblx0ICogb3IgPGNvZGU+bm9taW5hbEJvdW5kczwvY29kZT4gcHJvcGVydHkgb24gdGhlIHNvdXJjZSB0byB1c2UuIElmIG9uZSBpcyBub3QgZm91bmQsIHRoZSBmcmFtZSB3aWxsIGJlIHNraXBwZWQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGU9MV0gT3B0aW9uYWwuIFRoZSBzY2FsZSB0byBkcmF3IHRoaXMgZnJhbWUgYXQuIERlZmF1bHQgaXMgMS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW3NldHVwRnVuY3Rpb25dIEEgZnVuY3Rpb24gdG8gY2FsbCBpbW1lZGlhdGVseSBiZWZvcmUgZHJhd2luZyB0aGlzIGZyYW1lLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHR3byBwYXJhbWV0ZXJzOiB0aGUgc291cmNlLCBhbmQgc2V0dXBEYXRhLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3NldHVwRGF0YV0gQXJiaXRyYXJ5IHNldHVwIGRhdGEgdG8gcGFzcyB0byBzZXR1cEZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgZnJhbWUgdGhhdCB3YXMganVzdCBhZGRlZCwgb3IgbnVsbCBpZiBhIHNvdXJjZVJlY3QgY291bGQgbm90IGJlIGRldGVybWluZWQuXG5cdCAqKi9cblx0cC5hZGRGcmFtZSA9IGZ1bmN0aW9uKHNvdXJjZSwgc291cmNlUmVjdCwgc2NhbGUsIHNldHVwRnVuY3Rpb24sIHNldHVwRGF0YSkge1xuXHRcdGlmICh0aGlzLl9kYXRhKSB7IHRocm93IFNwcml0ZVNoZWV0QnVpbGRlci5FUlJfUlVOTklORzsgfVxuXHRcdHZhciByZWN0ID0gc291cmNlUmVjdHx8c291cmNlLmJvdW5kc3x8c291cmNlLm5vbWluYWxCb3VuZHM7XG5cdFx0aWYgKCFyZWN0JiZzb3VyY2UuZ2V0Qm91bmRzKSB7IHJlY3QgPSBzb3VyY2UuZ2V0Qm91bmRzKCk7IH1cblx0XHRpZiAoIXJlY3QpIHsgcmV0dXJuIG51bGw7IH1cblx0XHRzY2FsZSA9IHNjYWxlfHwxO1xuXHRcdHJldHVybiB0aGlzLl9mcmFtZXMucHVzaCh7c291cmNlOnNvdXJjZSwgc291cmNlUmVjdDpyZWN0LCBzY2FsZTpzY2FsZSwgZnVuY3Q6c2V0dXBGdW5jdGlvbiwgZGF0YTpzZXR1cERhdGEsIGluZGV4OnRoaXMuX2ZyYW1lcy5sZW5ndGgsIGhlaWdodDpyZWN0LmhlaWdodCpzY2FsZX0pLTE7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gYW5pbWF0aW9uIHRoYXQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgY3JlYXRlZCBzcHJpdGUgc2hlZXQuXG5cdCAqIEBtZXRob2QgYWRkQW5pbWF0aW9uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIGZvciB0aGUgYW5pbWF0aW9uLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBmcmFtZXMgQW4gYXJyYXkgb2YgZnJhbWUgaW5kZXhlcyB0aGF0IGNvbXByaXNlIHRoZSBhbmltYXRpb24uIEV4LiBbMyw2LDVdIHdvdWxkIGRlc2NyaWJlIGFuIGFuaW1hdGlvblxuXHQgKiB0aGF0IHBsYXllZCBmcmFtZSBpbmRleGVzIDMsIDYsIGFuZCA1IGluIHRoYXQgb3JkZXIuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbbmV4dF0gU3BlY2lmaWVzIHRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gY29udGludWUgdG8gYWZ0ZXIgdGhpcyBhbmltYXRpb24gZW5kcy4gWW91IGNhblxuXHQgKiBhbHNvIHBhc3MgZmFsc2UgdG8gaGF2ZSB0aGUgYW5pbWF0aW9uIHN0b3Agd2hlbiBpdCBlbmRzLiBCeSBkZWZhdWx0IGl0IHdpbGwgbG9vcCB0byB0aGUgc3RhcnQgb2YgdGhlIHNhbWUgYW5pbWF0aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2ZyZXF1ZW5jeV0gU3BlY2lmaWVzIGEgZnJhbWUgYWR2YW5jZSBmcmVxdWVuY3kgZm9yIHRoaXMgYW5pbWF0aW9uLiBGb3IgZXhhbXBsZSwgYSB2YWx1ZVxuXHQgKiBvZiAyIHdvdWxkIGNhdXNlIHRoZSBhbmltYXRpb24gdG8gYWR2YW5jZSBldmVyeSBzZWNvbmQgdGljay5cblx0ICoqL1xuXHRwLmFkZEFuaW1hdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIGZyYW1lcywgbmV4dCwgZnJlcXVlbmN5KSB7XG5cdFx0aWYgKHRoaXMuX2RhdGEpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9SVU5OSU5HOyB9XG5cdFx0dGhpcy5fYW5pbWF0aW9uc1tuYW1lXSA9IHtmcmFtZXM6ZnJhbWVzLCBuZXh0Om5leHQsIGZyZXF1ZW5jeTpmcmVxdWVuY3l9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGlzIHdpbGwgdGFrZSBhIE1vdmllQ2xpcCBpbnN0YW5jZSwgYW5kIGFkZCBpdHMgZnJhbWVzIGFuZCBsYWJlbHMgdG8gdGhpcyBidWlsZGVyLiBMYWJlbHMgd2lsbCBiZSBhZGRlZCBhcyBhbiBhbmltYXRpb25cblx0ICogcnVubmluZyBmcm9tIHRoZSBsYWJlbCBpbmRleCB0byB0aGUgbmV4dCBsYWJlbC4gRm9yIGV4YW1wbGUsIGlmIHRoZXJlIGlzIGEgbGFiZWwgbmFtZWQgXCJmb29cIiBhdCBmcmFtZSAwIGFuZCBhIGxhYmVsXG5cdCAqIG5hbWVkIFwiYmFyXCIgYXQgZnJhbWUgMTAsIGluIGEgTW92aWVDbGlwIHdpdGggMTUgZnJhbWVzLCBpdCB3aWxsIGFkZCBhbiBhbmltYXRpb24gbmFtZWQgXCJmb29cIiB0aGF0IHJ1bnMgZnJvbSBmcmFtZVxuXHQgKiBpbmRleCAwIHRvIDksIGFuZCBhbiBhbmltYXRpb24gbmFtZWQgXCJiYXJcIiB0aGF0IHJ1bnMgZnJvbSBmcmFtZSBpbmRleCAxMCB0byAxNC5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoaXMgd2lsbCBpdGVyYXRlIHRocm91Z2ggdGhlIGZ1bGwgTW92aWVDbGlwIHdpdGggYWN0aW9uc0VuYWJsZWQgc2V0IHRvIGZhbHNlLCBlbmRpbmcgb24gdGhlIGxhc3QgZnJhbWUuXG5cdCAqIEBtZXRob2QgYWRkTW92aWVDbGlwXG5cdCAqIEBwYXJhbSB7TW92aWVDbGlwfSBzb3VyY2UgVGhlIHNvdXJjZSBNb3ZpZUNsaXAgaW5zdGFuY2UgdG8gYWRkIHRvIHRoZSBzcHJpdGUgc2hlZXQuXG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBbc291cmNlUmVjdF0gQSB7eyNjcm9zc0xpbmsgXCJSZWN0YW5nbGVcIn19e3svY3Jvc3NMaW5rfX0gZGVmaW5pbmcgdGhlIHBvcnRpb24gb2YgdGhlIHNvdXJjZSB0b1xuXHQgKiBkcmF3IHRvIHRoZSBmcmFtZS4gSWYgbm90IHNwZWNpZmllZCwgaXQgd2lsbCBsb29rIGZvciBhIDxjb2RlPmdldEJvdW5kczwvY29kZT4gbWV0aG9kLCA8Y29kZT5mcmFtZUJvdW5kczwvY29kZT5cblx0ICogQXJyYXksIDxjb2RlPmJvdW5kczwvY29kZT4gcHJvcGVydHksIG9yIDxjb2RlPm5vbWluYWxCb3VuZHM8L2NvZGU+IHByb3BlcnR5IG9uIHRoZSBzb3VyY2UgdG8gdXNlLiBJZiBvbmUgaXMgbm90XG5cdCAqIGZvdW5kLCB0aGUgTW92aWVDbGlwIHdpbGwgYmUgc2tpcHBlZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZT0xXSBUaGUgc2NhbGUgdG8gZHJhdyB0aGUgbW92aWUgY2xpcCBhdC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW3NldHVwRnVuY3Rpb25dIEEgZnVuY3Rpb24gdG8gY2FsbCBpbW1lZGlhdGVseSBiZWZvcmUgZHJhd2luZyBlYWNoIGZyYW1lLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRocmVlIHBhcmFtZXRlcnM6IHRoZSBzb3VyY2UsIHNldHVwRGF0YSwgYW5kIHRoZSBmcmFtZSBpbmRleC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtzZXR1cERhdGFdIEFyYml0cmFyeSBzZXR1cCBkYXRhIHRvIHBhc3MgdG8gc2V0dXBGdW5jdGlvbiBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2xhYmVsRnVuY3Rpb25dIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIG1vdmllY2xpcCBsYWJlbCB0aGF0IGlzIGFkZGVkIHdpdGggZm91ciBwYXJhbWV0ZXJzOiB0aGUgbGFiZWwgbmFtZSwgdGhlIHNvdXJjZSBtb3ZpZWNsaXAgaW5zdGFuY2UsIHRoZSBzdGFydGluZyBmcmFtZSBpbmRleCAoaW4gdGhlIG1vdmllY2xpcCB0aW1lbGluZSkgYW5kIHRoZSBlbmQgaW5kZXguIEl0IG11c3QgcmV0dXJuIGEgbmV3IG5hbWUgZm9yIHRoZSBsYWJlbC9hbmltYXRpb24sIG9yIGZhbHNlIHRvIGV4Y2x1ZGUgdGhlIGxhYmVsLlxuXHQgKiovXG5cdHAuYWRkTW92aWVDbGlwID0gZnVuY3Rpb24oc291cmNlLCBzb3VyY2VSZWN0LCBzY2FsZSwgc2V0dXBGdW5jdGlvbiwgc2V0dXBEYXRhLCBsYWJlbEZ1bmN0aW9uKSB7XG5cdFx0aWYgKHRoaXMuX2RhdGEpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9SVU5OSU5HOyB9XG5cdFx0dmFyIHJlY3RzID0gc291cmNlLmZyYW1lQm91bmRzO1xuXHRcdHZhciByZWN0ID0gc291cmNlUmVjdHx8c291cmNlLmJvdW5kc3x8c291cmNlLm5vbWluYWxCb3VuZHM7XG5cdFx0aWYgKCFyZWN0JiZzb3VyY2UuZ2V0Qm91bmRzKSB7IHJlY3QgPSBzb3VyY2UuZ2V0Qm91bmRzKCk7IH1cblx0XHRpZiAoIXJlY3QgJiYgIXJlY3RzKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGksIGwsIGJhc2VGcmFtZUluZGV4ID0gdGhpcy5fZnJhbWVzLmxlbmd0aDtcblx0XHR2YXIgZHVyYXRpb24gPSBzb3VyY2UudGltZWxpbmUuZHVyYXRpb247XG5cdFx0Zm9yIChpPTA7IGk8ZHVyYXRpb247IGkrKykge1xuXHRcdFx0dmFyIHIgPSAocmVjdHMmJnJlY3RzW2ldKSA/IHJlY3RzW2ldIDogcmVjdDtcblx0XHRcdHRoaXMuYWRkRnJhbWUoc291cmNlLCByLCBzY2FsZSwgdGhpcy5fc2V0dXBNb3ZpZUNsaXBGcmFtZSwge2k6aSwgZjpzZXR1cEZ1bmN0aW9uLCBkOnNldHVwRGF0YX0pO1xuXHRcdH1cblx0XHR2YXIgbGFiZWxzID0gc291cmNlLnRpbWVsaW5lLl9sYWJlbHM7XG5cdFx0dmFyIGxibHMgPSBbXTtcblx0XHRmb3IgKHZhciBuIGluIGxhYmVscykge1xuXHRcdFx0bGJscy5wdXNoKHtpbmRleDpsYWJlbHNbbl0sIGxhYmVsOm59KTtcblx0XHR9XG5cdFx0aWYgKGxibHMubGVuZ3RoKSB7XG5cdFx0XHRsYmxzLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEuaW5kZXgtYi5pbmRleDsgfSk7XG5cdFx0XHRmb3IgKGk9MCxsPWxibHMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0XHR2YXIgbGFiZWwgPSBsYmxzW2ldLmxhYmVsO1xuXHRcdFx0XHR2YXIgc3RhcnQgPSBiYXNlRnJhbWVJbmRleCtsYmxzW2ldLmluZGV4O1xuXHRcdFx0XHR2YXIgZW5kID0gYmFzZUZyYW1lSW5kZXgrKChpID09IGwtMSkgPyBkdXJhdGlvbiA6IGxibHNbaSsxXS5pbmRleCk7XG5cdFx0XHRcdHZhciBmcmFtZXMgPSBbXTtcblx0XHRcdFx0Zm9yICh2YXIgaj1zdGFydDsgajxlbmQ7IGorKykgeyBmcmFtZXMucHVzaChqKTsgfVxuXHRcdFx0XHRpZiAobGFiZWxGdW5jdGlvbikge1xuXHRcdFx0XHRcdGxhYmVsID0gbGFiZWxGdW5jdGlvbihsYWJlbCwgc291cmNlLCBzdGFydCwgZW5kKTtcblx0XHRcdFx0XHRpZiAoIWxhYmVsKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5hZGRBbmltYXRpb24obGFiZWwsIGZyYW1lcywgdHJ1ZSk7IC8vIGZvciBub3csIHRoaXMgbG9vcHMgYWxsIGFuaW1hdGlvbnMuXG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBCdWlsZHMgYSBTcHJpdGVTaGVldCBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBmcmFtZXMuXG5cdCAqIEBtZXRob2QgYnVpbGRcblx0ICogQHJldHVybiB7U3ByaXRlU2hlZXR9IFRoZSBjcmVhdGVkIFNwcml0ZVNoZWV0IGluc3RhbmNlLCBvciBudWxsIGlmIGEgYnVpbGQgaXMgYWxyZWFkeSBydW5uaW5nIG9yIGFuIGVycm9yIG9jY3VycmVkLlxuXHQgKiovXG5cdHAuYnVpbGQgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fZGF0YSkgeyB0aHJvdyBTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX1JVTk5JTkc7IH1cblx0XHR0aGlzLl9zdGFydEJ1aWxkKCk7XG5cdFx0d2hpbGUgKHRoaXMuX2RyYXdOZXh0KCkpIHt9XG5cdFx0dGhpcy5fZW5kQnVpbGQoKTtcblx0XHRyZXR1cm4gdGhpcy5zcHJpdGVTaGVldDtcblx0fTtcblxuXHQvKipcblx0ICogQXN5bmNocm9ub3VzbHkgYnVpbGRzIGEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZnJhbWVzLiBJdCB3aWxsXG5cdCAqIHJ1biAyMCB0aW1lcyBwZXIgc2Vjb25kLCB1c2luZyBhbiBhbW91bnQgb2YgdGltZSBkZWZpbmVkIGJ5IDxjb2RlPnRpbWVTbGljZTwvY29kZT4uIFdoZW4gaXQgaXMgY29tcGxldGUgaXQgd2lsbFxuXHQgKiBjYWxsIHRoZSBzcGVjaWZpZWQgY2FsbGJhY2suXG5cdCAqIEBtZXRob2QgYnVpbGRBc3luY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVTbGljZV0gU2V0cyB0aGUgdGltZVNsaWNlIHByb3BlcnR5IG9uIHRoaXMgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5idWlsZEFzeW5jID0gZnVuY3Rpb24odGltZVNsaWNlKSB7XG5cdFx0aWYgKHRoaXMuX2RhdGEpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9SVU5OSU5HOyB9XG5cdFx0dGhpcy50aW1lU2xpY2UgPSB0aW1lU2xpY2U7XG5cdFx0dGhpcy5fc3RhcnRCdWlsZCgpO1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dGhpcy5fdGltZXJJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IF90aGlzLl9ydW4oKTsgfSwgNTAtTWF0aC5tYXgoMC4wMSwgTWF0aC5taW4oMC45OSwgdGhpcy50aW1lU2xpY2V8fDAuMykpKjUwKTtcblx0fTtcblxuXHQvKipcblx0ICogU3RvcHMgdGhlIGN1cnJlbnQgYXN5bmNocm9ub3VzIGJ1aWxkLlxuXHQgKiBAbWV0aG9kIHN0b3BBc3luY1xuXHQgKiovXG5cdHAuc3RvcEFzeW5jID0gZnVuY3Rpb24oKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVySUQpO1xuXHRcdHRoaXMuX2RhdGEgPSBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcHJpdGVTaGVldEJ1aWxkZXIgaW5zdGFuY2VzIGNhbm5vdCBiZSBjbG9uZWQuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3coXCJTcHJpdGVTaGVldEJ1aWxkZXIgY2Fubm90IGJlIGNsb25lZC5cIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltTcHJpdGVTaGVldEJ1aWxkZXJdXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfc3RhcnRCdWlsZFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fc3RhcnRCdWlsZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYWQgPSB0aGlzLnBhZGRpbmd8fDA7XG5cdFx0dGhpcy5wcm9ncmVzcyA9IDA7XG5cdFx0dGhpcy5zcHJpdGVTaGVldCA9IG51bGw7XG5cdFx0dGhpcy5faW5kZXggPSAwO1xuXHRcdHRoaXMuX3NjYWxlID0gdGhpcy5zY2FsZTtcblx0XHR2YXIgZGF0YUZyYW1lcyA9IFtdO1xuXHRcdHRoaXMuX2RhdGEgPSB7XG5cdFx0XHRpbWFnZXM6IFtdLFxuXHRcdFx0ZnJhbWVzOiBkYXRhRnJhbWVzLFxuXHRcdFx0YW5pbWF0aW9uczogdGhpcy5fYW5pbWF0aW9ucyAvLyBUT0RPOiBzaG91bGQgd2UgXCJjbG9uZVwiIF9hbmltYXRpb25zIGluIGNhc2Ugc29tZW9uZSBhZGRzIG1vcmUgYW5pbWF0aW9ucyBhZnRlciBhIGJ1aWxkP1xuXHRcdH07XG5cblx0XHR2YXIgZnJhbWVzID0gdGhpcy5fZnJhbWVzLnNsaWNlKCk7XG5cdFx0ZnJhbWVzLnNvcnQoZnVuY3Rpb24oYSxiKSB7IHJldHVybiAoYS5oZWlnaHQ8PWIuaGVpZ2h0KSA/IC0xIDogMTsgfSk7XG5cblx0XHRpZiAoZnJhbWVzW2ZyYW1lcy5sZW5ndGgtMV0uaGVpZ2h0K3BhZCoyID4gdGhpcy5tYXhIZWlnaHQpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9ESU1FTlNJT05TOyB9XG5cdFx0dmFyIHk9MCwgeD0wO1xuXHRcdHZhciBpbWcgPSAwO1xuXHRcdHdoaWxlIChmcmFtZXMubGVuZ3RoKSB7XG5cdFx0XHR2YXIgbyA9IHRoaXMuX2ZpbGxSb3coZnJhbWVzLCB5LCBpbWcsIGRhdGFGcmFtZXMsIHBhZCk7XG5cdFx0XHRpZiAoby53ID4geCkgeyB4ID0gby53OyB9XG5cdFx0XHR5ICs9IG8uaDtcblx0XHRcdGlmICghby5oIHx8ICFmcmFtZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBjYW52YXMgPSBjcmVhdGVqcy5jcmVhdGVDYW52YXM/Y3JlYXRlanMuY3JlYXRlQ2FudmFzKCk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblx0XHRcdFx0Y2FudmFzLndpZHRoID0gdGhpcy5fZ2V0U2l6ZSh4LHRoaXMubWF4V2lkdGgpO1xuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gdGhpcy5fZ2V0U2l6ZSh5LHRoaXMubWF4SGVpZ2h0KTtcblx0XHRcdFx0dGhpcy5fZGF0YS5pbWFnZXNbaW1nXSA9IGNhbnZhcztcblx0XHRcdFx0aWYgKCFvLmgpIHtcblx0XHRcdFx0XHR4PXk9MDtcblx0XHRcdFx0XHRpbWcrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9zZXR1cE1vdmllQ2xpcEZyYW1lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgd2lkdGggJiBoZWlnaHQgb2YgdGhlIHJvdy5cblx0ICoqL1xuXHRwLl9zZXR1cE1vdmllQ2xpcEZyYW1lID0gZnVuY3Rpb24oc291cmNlLCBkYXRhKSB7XG5cdFx0dmFyIGFlID0gc291cmNlLmFjdGlvbnNFbmFibGVkO1xuXHRcdHNvdXJjZS5hY3Rpb25zRW5hYmxlZCA9IGZhbHNlO1xuXHRcdHNvdXJjZS5nb3RvQW5kU3RvcChkYXRhLmkpO1xuXHRcdHNvdXJjZS5hY3Rpb25zRW5hYmxlZCA9IGFlO1xuXHRcdGRhdGEuZiYmZGF0YS5mKHNvdXJjZSwgZGF0YS5kLCBkYXRhLmkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRTaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgd2lkdGggJiBoZWlnaHQgb2YgdGhlIHJvdy5cblx0ICoqL1xuXHRwLl9nZXRTaXplID0gZnVuY3Rpb24oc2l6ZSxtYXgpIHtcblx0XHR2YXIgcG93ID0gNDtcblx0XHR3aGlsZSAoTWF0aC5wb3coMiwrK3BvdykgPCBzaXplKXt9XG5cdFx0cmV0dXJuIE1hdGgubWluKG1heCxNYXRoLnBvdygyLHBvdykpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9maWxsUm93XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGZyYW1lc1xuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IGltZ1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YUZyYW1lc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcGFkXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgd2lkdGggJiBoZWlnaHQgb2YgdGhlIHJvdy5cblx0ICoqL1xuXHRwLl9maWxsUm93ID0gZnVuY3Rpb24oZnJhbWVzLCB5LCBpbWcsIGRhdGFGcmFtZXMsIHBhZCkge1xuXHRcdHZhciB3ID0gdGhpcy5tYXhXaWR0aDtcblx0XHR2YXIgbWF4SCA9IHRoaXMubWF4SGVpZ2h0O1xuXHRcdHkgKz0gcGFkO1xuXHRcdHZhciBoID0gbWF4SC15O1xuXHRcdHZhciB4ID0gcGFkO1xuXHRcdHZhciBoZWlnaHQgPSAwO1xuXHRcdGZvciAodmFyIGk9ZnJhbWVzLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcblx0XHRcdHZhciBmcmFtZSA9IGZyYW1lc1tpXTtcblx0XHRcdHZhciBzYyA9IHRoaXMuX3NjYWxlKmZyYW1lLnNjYWxlO1xuXHRcdFx0dmFyIHJlY3QgPSBmcmFtZS5zb3VyY2VSZWN0O1xuXHRcdFx0dmFyIHNvdXJjZSA9IGZyYW1lLnNvdXJjZTtcblx0XHRcdHZhciByeCA9IE1hdGguZmxvb3Ioc2MqcmVjdC54LXBhZCk7XG5cdFx0XHR2YXIgcnkgPSBNYXRoLmZsb29yKHNjKnJlY3QueS1wYWQpO1xuXHRcdFx0dmFyIHJoID0gTWF0aC5jZWlsKHNjKnJlY3QuaGVpZ2h0K3BhZCoyKTtcblx0XHRcdHZhciBydyA9IE1hdGguY2VpbChzYypyZWN0LndpZHRoK3BhZCoyKTtcblx0XHRcdGlmIChydyA+IHcpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9ESU1FTlNJT05TOyB9XG5cdFx0XHRpZiAocmggPiBoIHx8IHgrcncgPiB3KSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRmcmFtZS5pbWcgPSBpbWc7XG5cdFx0XHRmcmFtZS5yZWN0ID0gbmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSh4LHkscncscmgpO1xuXHRcdFx0aGVpZ2h0ID0gaGVpZ2h0IHx8IHJoO1xuXHRcdFx0ZnJhbWVzLnNwbGljZShpLDEpO1xuXHRcdFx0ZGF0YUZyYW1lc1tmcmFtZS5pbmRleF0gPSBbeCx5LHJ3LHJoLGltZyxNYXRoLnJvdW5kKC1yeCtzYypzb3VyY2UucmVnWC1wYWQpLE1hdGgucm91bmQoLXJ5K3NjKnNvdXJjZS5yZWdZLXBhZCldO1xuXHRcdFx0eCArPSBydztcblx0XHR9XG5cdFx0cmV0dXJuIHt3OngsIGg6aGVpZ2h0fTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZW5kQnVpbGRcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2VuZEJ1aWxkID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zcHJpdGVTaGVldCA9IG5ldyBjcmVhdGVqcy5TcHJpdGVTaGVldCh0aGlzLl9kYXRhKTtcblx0XHR0aGlzLl9kYXRhID0gbnVsbDtcblx0XHR0aGlzLnByb2dyZXNzID0gMTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfcnVuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9ydW4gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdHMgPSBNYXRoLm1heCgwLjAxLCBNYXRoLm1pbigwLjk5LCB0aGlzLnRpbWVTbGljZXx8MC4zKSkqNTA7XG5cdFx0dmFyIHQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpK3RzO1xuXHRcdHZhciBjb21wbGV0ZSA9IGZhbHNlO1xuXHRcdHdoaWxlICh0ID4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSkge1xuXHRcdFx0aWYgKCF0aGlzLl9kcmF3TmV4dCgpKSB7IGNvbXBsZXRlID0gdHJ1ZTsgYnJlYWs7IH1cblx0XHR9XG5cdFx0aWYgKGNvbXBsZXRlKSB7XG5cdFx0XHR0aGlzLl9lbmRCdWlsZCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdFx0dGhpcy5fdGltZXJJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IF90aGlzLl9ydW4oKTsgfSwgNTAtdHMpO1xuXHRcdH1cblx0XHR2YXIgcCA9IHRoaXMucHJvZ3Jlc3MgPSB0aGlzLl9pbmRleC90aGlzLl9mcmFtZXMubGVuZ3RoO1xuXHRcdGlmICh0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiKSkge1xuXHRcdFx0dmFyIGV2dCA9IG5ldyBjcmVhdGVqcy5FdmVudChcInByb2dyZXNzXCIpO1xuXHRcdFx0ZXZ0LnByb2dyZXNzID0gcDtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZHJhd05leHRcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIEJvb2xlYW4gUmV0dXJucyBmYWxzZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGRyYXcuXG5cdCAqKi9cblx0cC5fZHJhd05leHQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgZnJhbWUgPSB0aGlzLl9mcmFtZXNbdGhpcy5faW5kZXhdO1xuXHRcdHZhciBzYyA9IGZyYW1lLnNjYWxlKnRoaXMuX3NjYWxlO1xuXHRcdHZhciByZWN0ID0gZnJhbWUucmVjdDtcblx0XHR2YXIgc291cmNlUmVjdCA9IGZyYW1lLnNvdXJjZVJlY3Q7XG5cdFx0dmFyIGNhbnZhcyA9IHRoaXMuX2RhdGEuaW1hZ2VzW2ZyYW1lLmltZ107XG5cdFx0dmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0ZnJhbWUuZnVuY3QmJmZyYW1lLmZ1bmN0KGZyYW1lLnNvdXJjZSwgZnJhbWUuZGF0YSk7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LnJlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcblx0XHRjdHguY2xpcCgpO1xuXHRcdGN0eC50cmFuc2xhdGUoTWF0aC5jZWlsKHJlY3QueC1zb3VyY2VSZWN0Lngqc2MpLCBNYXRoLmNlaWwocmVjdC55LXNvdXJjZVJlY3QueSpzYykpO1xuXHRcdGN0eC5zY2FsZShzYyxzYyk7XG5cdFx0ZnJhbWUuc291cmNlLmRyYXcoY3R4KTsgLy8gZGlzcGxheSBvYmplY3Qgd2lsbCBkcmF3IGl0c2VsZi5cblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdHJldHVybiAoKyt0aGlzLl9pbmRleCkgPCB0aGlzLl9mcmFtZXMubGVuZ3RoO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuU3ByaXRlU2hlZXRCdWlsZGVyID0gY3JlYXRlanMucHJvbW90ZShTcHJpdGVTaGVldEJ1aWxkZXIsIFwiRXZlbnREaXNwYXRjaGVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIERPTUVsZW1lbnQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIDxiPlRoaXMgY2xhc3MgaXMgc3RpbGwgZXhwZXJpbWVudGFsLCBhbmQgbW9yZSBhZHZhbmNlZCB1c2UgaXMgbGlrZWx5IHRvIGJlIGJ1Z2d5LiBQbGVhc2UgcmVwb3J0IGJ1Z3MuPC9iPlxuXHQgKlxuXHQgKiBBIERPTUVsZW1lbnQgYWxsb3dzIHlvdSB0byBhc3NvY2lhdGUgYSBIVE1MRWxlbWVudCB3aXRoIHRoZSBkaXNwbGF5IGxpc3QuIEl0IHdpbGwgYmUgdHJhbnNmb3JtZWRcblx0ICogd2l0aGluIHRoZSBET00gYXMgdGhvdWdoIGl0IGlzIGNoaWxkIG9mIHRoZSB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX0gaXQgaXMgYWRkZWQgdG8uIEhvd2V2ZXIsIGl0IGlzXG5cdCAqIG5vdCByZW5kZXJlZCB0byBjYW52YXMsIGFuZCBhcyBzdWNoIHdpbGwgcmV0YWluIHdoYXRldmVyIHotaW5kZXggaXQgaGFzIHJlbGF0aXZlIHRvIHRoZSBjYW52YXMgKGllLiBpdCB3aWxsIGJlXG5cdCAqIGRyYXduIGluIGZyb250IG9mIG9yIGJlaGluZCB0aGUgY2FudmFzKS5cblx0ICpcblx0ICogVGhlIHBvc2l0aW9uIG9mIGEgRE9NRWxlbWVudCBpcyByZWxhdGl2ZSB0byB0aGVpciBwYXJlbnQgbm9kZSBpbiB0aGUgRE9NLiBJdCBpcyByZWNvbW1lbmRlZCB0aGF0XG5cdCAqIHRoZSBET00gT2JqZWN0IGJlIGFkZGVkIHRvIGEgZGl2IHRoYXQgYWxzbyBjb250YWlucyB0aGUgY2FudmFzIHNvIHRoYXQgdGhleSBzaGFyZSB0aGUgc2FtZSBwb3NpdGlvblxuXHQgKiBvbiB0aGUgcGFnZS5cblx0ICpcblx0ICogRE9NRWxlbWVudCBpcyB1c2VmdWwgZm9yIHBvc2l0aW9uaW5nIEhUTUwgZWxlbWVudHMgb3ZlciB0b3Agb2YgY2FudmFzIGNvbnRlbnQsIGFuZCBmb3IgZWxlbWVudHNcblx0ICogdGhhdCB5b3Ugd2FudCB0byBkaXNwbGF5IG91dHNpZGUgdGhlIGJvdW5kcyBvZiB0aGUgY2FudmFzLiBGb3IgZXhhbXBsZSwgYSB0b29sdGlwIHdpdGggcmljaCBIVE1MXG5cdCAqIGNvbnRlbnQuXG5cdCAqXG5cdCAqIDxoND5Nb3VzZSBJbnRlcmFjdGlvbjwvaDQ+XG5cdCAqXG5cdCAqIERPTUVsZW1lbnQgaW5zdGFuY2VzIGFyZSBub3QgZnVsbCBFYXNlbEpTIGRpc3BsYXkgb2JqZWN0cywgYW5kIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBFYXNlbEpTIG1vdXNlXG5cdCAqIGV2ZW50cyBvciBzdXBwb3J0IG1ldGhvZHMgbGlrZSBoaXRUZXN0LiBUbyBnZXQgbW91c2UgZXZlbnRzIGZyb20gYSBET01FbGVtZW50LCB5b3UgbXVzdCBpbnN0ZWFkIGFkZCBoYW5kbGVycyB0b1xuXHQgKiB0aGUgaHRtbEVsZW1lbnQgKG5vdGUsIHRoaXMgZG9lcyBub3Qgc3VwcG9ydCBFdmVudERpc3BhdGNoZXIpXG5cdCAqXG5cdCAqICAgICAgdmFyIGRvbUVsZW1lbnQgPSBuZXcgY3JlYXRlanMuRE9NRWxlbWVudChodG1sRWxlbWVudCk7XG5cdCAqICAgICAgZG9tRWxlbWVudC5odG1sRWxlbWVudC5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2xpY2tlZFwiKTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBjbGFzcyBET01FbGVtZW50XG5cdCAqIEBleHRlbmRzIERpc3BsYXlPYmplY3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGh0bWxFbGVtZW50IEEgcmVmZXJlbmNlIG9yIGlkIGZvciB0aGUgRE9NIGVsZW1lbnQgdG8gbWFuYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gRE9NRWxlbWVudChodG1sRWxlbWVudCkge1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9jb25zdHJ1Y3RvcigpO1xuXHRcdFxuXHRcdGlmICh0eXBlb2YoaHRtbEVsZW1lbnQpPT1cInN0cmluZ1wiKSB7IGh0bWxFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaHRtbEVsZW1lbnQpOyB9XG5cdFx0dGhpcy5tb3VzZUVuYWJsZWQgPSBmYWxzZTtcblx0XHRcblx0XHR2YXIgc3R5bGUgPSBodG1sRWxlbWVudC5zdHlsZTtcblx0XHRzdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBzdHlsZS5XZWJraXRUcmFuc2Zvcm1PcmlnaW4gPSBzdHlsZS5tc1RyYW5zZm9ybU9yaWdpbiA9IHN0eWxlLk1velRyYW5zZm9ybU9yaWdpbiA9IHN0eWxlLk9UcmFuc2Zvcm1PcmlnaW4gPSBcIjAlIDAlXCI7XG5cdFx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSBET00gb2JqZWN0IHRvIG1hbmFnZS5cblx0XHQgKiBAcHJvcGVydHkgaHRtbEVsZW1lbnRcblx0XHQgKiBAdHlwZSBIVE1MRWxlbWVudFxuXHRcdCAqL1xuXHRcdHRoaXMuaHRtbEVsZW1lbnQgPSBodG1sRWxlbWVudDtcblx0XG5cdFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9vbGRNdHhcblx0XHQgKiBAdHlwZSBNYXRyaXgyRFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9vbGRQcm9wcyA9IG51bGw7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoRE9NRWxlbWVudCwgY3JlYXRlanMuRGlzcGxheU9iamVjdCk7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzXG5cdCAqL1xuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmh0bWxFbGVtZW50ICE9IG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBkcmF3IHdhcyBoYW5kbGVkICh1c2VmdWwgZm9yIG92ZXJyaWRpbmcgZnVuY3Rpb25hbGl0eSkuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBkcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlQ2FjaGUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRyYXcgb3BlcmF0aW9uIHNob3VsZCBpZ25vcmUgYW55IGN1cnJlbnQgY2FjaGUuXG5cdCAqIEZvciBleGFtcGxlLCB1c2VkIGZvciBkcmF3aW5nIHRoZSBjYWNoZSAodG8gcHJldmVudCBpdCBmcm9tIHNpbXBseSBkcmF3aW5nIGFuIGV4aXN0aW5nIGNhY2hlIGJhY2tcblx0ICogaW50byBpdHNlbGYpLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBpZ25vcmVDYWNoZSkge1xuXHRcdC8vIHRoaXMgcmVsaWVzIG9uIHRoZSBfdGljayBtZXRob2QgYmVjYXVzZSBkcmF3IGlzbid0IGNhbGxlZCBpZiB0aGUgcGFyZW50IGlzIG5vdCB2aXNpYmxlLlxuXHRcdC8vIHRoZSBhY3R1YWwgdXBkYXRlIGhhcHBlbnMgaW4gX2hhbmRsZURyYXdFbmRcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogTm90IGFwcGxpY2FibGUgdG8gRE9NRWxlbWVudC5cblx0ICogQG1ldGhvZCBjYWNoZVxuXHQgKi9cblx0cC5jYWNoZSA9IGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIE5vdCBhcHBsaWNhYmxlIHRvIERPTUVsZW1lbnQuXG5cdCAqIEBtZXRob2QgdW5jYWNoZVxuXHQgKi9cblx0cC51bmNhY2hlID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKipcblx0ICogTm90IGFwcGxpY2FibGUgdG8gRE9NRWxlbWVudC5cblx0ICogQG1ldGhvZCB1cGRhdGVDYWNoZVxuXHQgKi9cblx0cC51cGRhdGVDYWNoZSA9IGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIE5vdCBhcHBsaWNhYmxlIHRvIERPTUVsZW1lbnQuXG5cdCAqIEBtZXRob2QgaGl0VGVzdFxuXHQgKi9cblx0cC5oaXRUZXN0ID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKipcblx0ICogTm90IGFwcGxpY2FibGUgdG8gRE9NRWxlbWVudC5cblx0ICogQG1ldGhvZCBsb2NhbFRvR2xvYmFsXG5cdCAqL1xuXHRwLmxvY2FsVG9HbG9iYWwgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBOb3QgYXBwbGljYWJsZSB0byBET01FbGVtZW50LlxuXHQgKiBAbWV0aG9kIGdsb2JhbFRvTG9jYWxcblx0ICovXG5cdHAuZ2xvYmFsVG9Mb2NhbCA9IGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIE5vdCBhcHBsaWNhYmxlIHRvIERPTUVsZW1lbnQuXG5cdCAqIEBtZXRob2QgbG9jYWxUb0xvY2FsXG5cdCAqL1xuXHRwLmxvY2FsVG9Mb2NhbCA9IGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIERPTUVsZW1lbnQgY2Fubm90IGJlIGNsb25lZC4gVGhyb3dzIGFuIGVycm9yLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3coXCJET01FbGVtZW50IGNhbm5vdCBiZSBjbG9uZWQuXCIpXG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0RPTUVsZW1lbnQgKG5hbWU9XCIrICB0aGlzLm5hbWUgK1wiKV1cIjtcblx0fTtcblxuXHQvKipcbiAgICAgKiBJbnRlcmFjdGlvbiBldmVudHMgc2hvdWxkIGJlIGFkZGVkIHRvIGBodG1sRWxlbWVudGAsIGFuZCBub3QgdGhlIERPTUVsZW1lbnQgaW5zdGFuY2UsIHNpbmNlIERPTUVsZW1lbnQgaW5zdGFuY2VzXG5cdCAqIGFyZSBub3QgZnVsbCBFYXNlbEpTIGRpc3BsYXkgb2JqZWN0cyBhbmQgZG8gbm90IHBhcnRpY2lwYXRlIGluIEVhc2VsSlMgbW91c2UgZXZlbnRzLlxuXHQgKiBAZXZlbnQgY2xpY2tcblx0ICovXG5cbiAgICAgLyoqXG4gICAgICogSW50ZXJhY3Rpb24gZXZlbnRzIHNob3VsZCBiZSBhZGRlZCB0byBgaHRtbEVsZW1lbnRgLCBhbmQgbm90IHRoZSBET01FbGVtZW50IGluc3RhbmNlLCBzaW5jZSBET01FbGVtZW50IGluc3RhbmNlc1xuIFx0ICogYXJlIG5vdCBmdWxsIEVhc2VsSlMgZGlzcGxheSBvYmplY3RzIGFuZCBkbyBub3QgcGFydGljaXBhdGUgaW4gRWFzZWxKUyBtb3VzZSBldmVudHMuXG5cdCAqIEBldmVudCBkYmxDbGlja1xuXHQgKi9cblxuICAgICAvKipcbiAgICAgICogSW50ZXJhY3Rpb24gZXZlbnRzIHNob3VsZCBiZSBhZGRlZCB0byBgaHRtbEVsZW1lbnRgLCBhbmQgbm90IHRoZSBET01FbGVtZW50IGluc3RhbmNlLCBzaW5jZSBET01FbGVtZW50IGluc3RhbmNlc1xuIFx0ICAqIGFyZSBub3QgZnVsbCBFYXNlbEpTIGRpc3BsYXkgb2JqZWN0cyBhbmQgZG8gbm90IHBhcnRpY2lwYXRlIGluIEVhc2VsSlMgbW91c2UgZXZlbnRzLlxuXHQgICogQGV2ZW50IG1vdXNlZG93blxuXHQgICovXG5cbiAgICAgLyoqXG4gICAgICAqIFRoZSBIVE1MRWxlbWVudCBjYW4gbGlzdGVuIGZvciB0aGUgbW91c2VvdmVyIGV2ZW50LCBub3QgdGhlIERPTUVsZW1lbnQgaW5zdGFuY2UuXG4gICAgICAqIFNpbmNlIERPTUVsZW1lbnQgaW5zdGFuY2VzIGFyZSBub3QgZnVsbCBFYXNlbEpTIGRpc3BsYXkgb2JqZWN0cyBhbmQgZG8gbm90IHBhcnRpY2lwYXRlIGluIEVhc2VsSlMgbW91c2UgZXZlbnRzLlxuICAgICAgKiBAZXZlbnQgbW91c2VvdmVyXG5cdCAgKi9cblxuICAgICAvKipcbiAgICAgICogTm90IGFwcGxpY2FibGUgdG8gRE9NRWxlbWVudC5cblx0ICAqIEBldmVudCB0aWNrXG5cdCAgKi9cblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF90aWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldnRPYmogQW4gZXZlbnQgb2JqZWN0IHRoYXQgd2lsbCBiZSBkaXNwYXRjaGVkIHRvIGFsbCB0aWNrIGxpc3RlbmVycy4gVGhpcyBvYmplY3QgaXMgcmV1c2VkIGJldHdlZW4gZGlzcGF0Y2hlcnMgdG8gcmVkdWNlIGNvbnN0cnVjdGlvbiAmIEdDIGNvc3RzLlxuXHQgKiBmdW5jdGlvbi5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fdGljayA9IGZ1bmN0aW9uKGV2dE9iaikge1xuXHRcdHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcblx0XHRzdGFnZSYmc3RhZ2Uub24oXCJkcmF3ZW5kXCIsIHRoaXMuX2hhbmRsZURyYXdFbmQsIHRoaXMsIHRydWUpO1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9fdGljayhldnRPYmopO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZURyYXdFbmRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZ0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2hhbmRsZURyYXdFbmQgPSBmdW5jdGlvbihldnQpIHtcblx0XHR2YXIgbyA9IHRoaXMuaHRtbEVsZW1lbnQ7XG5cdFx0aWYgKCFvKSB7IHJldHVybjsgfVxuXHRcdHZhciBzdHlsZSA9IG8uc3R5bGU7XG5cdFx0XG5cdFx0dmFyIHByb3BzID0gdGhpcy5nZXRDb25jYXRlbmF0ZWREaXNwbGF5UHJvcHModGhpcy5fcHJvcHMpLCBtdHggPSBwcm9wcy5tYXRyaXg7XG5cdFx0XG5cdFx0dmFyIHZpc2liaWxpdHkgPSBwcm9wcy52aXNpYmxlID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiO1xuXHRcdGlmICh2aXNpYmlsaXR5ICE9IHN0eWxlLnZpc2liaWxpdHkpIHsgc3R5bGUudmlzaWJpbGl0eSA9IHZpc2liaWxpdHk7IH1cblx0XHRpZiAoIXByb3BzLnZpc2libGUpIHsgcmV0dXJuOyB9XG5cdFx0XG5cdFx0dmFyIG9sZFByb3BzID0gdGhpcy5fb2xkUHJvcHMsIG9sZE10eCA9IG9sZFByb3BzJiZvbGRQcm9wcy5tYXRyaXg7XG5cdFx0dmFyIG4gPSAxMDAwMDsgLy8gcHJlY2lzaW9uXG5cdFx0XG5cdFx0aWYgKCFvbGRNdHggfHwgIW9sZE10eC5lcXVhbHMobXR4KSkge1xuXHRcdFx0dmFyIHN0ciA9IFwibWF0cml4KFwiICsgKG10eC5hKm58MCkvbiArXCIsXCIrIChtdHguYipufDApL24gK1wiLFwiKyAobXR4LmMqbnwwKS9uICtcIixcIisgKG10eC5kKm58MCkvbiArXCIsXCIrIChtdHgudHgrMC41fDApO1xuXHRcdFx0c3R5bGUudHJhbnNmb3JtID0gc3R5bGUuV2Via2l0VHJhbnNmb3JtID0gc3R5bGUuT1RyYW5zZm9ybSA9IHN0eWxlLm1zVHJhbnNmb3JtID0gc3RyICtcIixcIisgKG10eC50eSswLjV8MCkgK1wiKVwiO1xuXHRcdFx0c3R5bGUuTW96VHJhbnNmb3JtID0gc3RyICtcInB4LFwiKyAobXR4LnR5KzAuNXwwKSArXCJweClcIjtcblx0XHRcdGlmICghb2xkUHJvcHMpIHsgb2xkUHJvcHMgPSB0aGlzLl9vbGRQcm9wcyA9IG5ldyBjcmVhdGVqcy5EaXNwbGF5UHJvcHModHJ1ZSwgTmFOKTsgfVxuXHRcdFx0b2xkUHJvcHMubWF0cml4LmNvcHkobXR4KTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKG9sZFByb3BzLmFscGhhICE9IHByb3BzLmFscGhhKSB7XG5cdFx0XHRzdHlsZS5vcGFjaXR5ID0gXCJcIisocHJvcHMuYWxwaGEqbnwwKS9uO1xuXHRcdFx0b2xkUHJvcHMuYWxwaGEgPSBwcm9wcy5hbHBoYTtcblx0XHR9XG5cdH07XG5cblxuXHRjcmVhdGVqcy5ET01FbGVtZW50ID0gY3JlYXRlanMucHJvbW90ZShET01FbGVtZW50LCBcIkRpc3BsYXlPYmplY3RcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRmlsdGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBCYXNlIGNsYXNzIHRoYXQgYWxsIGZpbHRlcnMgc2hvdWxkIGluaGVyaXQgZnJvbS4gRmlsdGVycyBuZWVkIHRvIGJlIGFwcGxpZWQgdG8gb2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBjYWNoZWQgdXNpbmdcblx0ICogdGhlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvY2FjaGVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLiBJZiBhbiBvYmplY3QgY2hhbmdlcywgcGxlYXNlIGNhY2hlIGl0IGFnYWluLCBvciB1c2Vcblx0ICoge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC91cGRhdGVDYWNoZVwifX17ey9jcm9zc0xpbmt9fS4gTm90ZSB0aGF0IHRoZSBmaWx0ZXJzIG11c3QgYmUgYXBwbGllZCBiZWZvcmUgY2FjaGluZy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIG15SW5zdGFuY2UuZmlsdGVycyA9IFtcblx0ICogICAgICAgICAgbmV3IGNyZWF0ZWpzLkNvbG9yRmlsdGVyKDAsIDAsIDAsIDEsIDI1NSwgMCwgMCksXG5cdCAqICAgICAgICAgIG5ldyBjcmVhdGVqcy5CbHVyRmlsdGVyKDUsIDUsIDEwKVxuXHQgKiAgICAgIF07XG5cdCAqICAgICAgbXlJbnN0YW5jZS5jYWNoZSgwLDAsIDEwMCwgMTAwKTtcblx0ICpcblx0ICogTm90ZSB0aGF0IGVhY2ggZmlsdGVyIGNhbiBpbXBsZW1lbnQgYSB7eyNjcm9zc0xpbmsgXCJGaWx0ZXIvZ2V0Qm91bmRzXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCwgd2hpY2ggcmV0dXJucyB0aGVcblx0ICogbWFyZ2lucyB0aGF0IG5lZWQgdG8gYmUgYXBwbGllZCBpbiBvcmRlciB0byBmdWxseSBkaXNwbGF5IHRoZSBmaWx0ZXIuIEZvciBleGFtcGxlLCB0aGUge3sjY3Jvc3NMaW5rIFwiQmx1ckZpbHRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aWxsIGNhdXNlIGFuIG9iamVjdCB0byBmZWF0aGVyIG91dHdhcmRzLCByZXN1bHRpbmcgaW4gYSBtYXJnaW4gYXJvdW5kIHRoZSBzaGFwZS5cblx0ICpcblx0ICogPGg0PkVhc2VsSlMgRmlsdGVyczwvaDQ+XG5cdCAqIEVhc2VsSlMgY29tZXMgd2l0aCBhIG51bWJlciBvZiBwcmUtYnVpbHQgZmlsdGVycy4gTm90ZSB0aGF0IGluZGl2aWR1YWwgZmlsdGVycyBhcmUgbm90IGNvbXBpbGVkIGludG8gdGhlIG1pbmlmaWVkXG5cdCAqIHZlcnNpb24gb2YgRWFzZWxKUy4gVG8gdXNlIHRoZW0sIHlvdSBtdXN0IGluY2x1ZGUgdGhlbSBtYW51YWxseSBpbiB0aGUgSFRNTC5cblx0ICogPHVsPjxsaT57eyNjcm9zc0xpbmsgXCJBbHBoYU1hcEZpbHRlclwifX17ey9jcm9zc0xpbmt9fSA6IE1hcCBhIGdyZXlzY2FsZSBpbWFnZSB0byB0aGUgYWxwaGEgY2hhbm5lbCBvZiBhIGRpc3BsYXkgb2JqZWN0PC9saT5cblx0ICogICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWxwaGFNYXNrRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319OiBNYXAgYW4gaW1hZ2UncyBhbHBoYSBjaGFubmVsIHRvIHRoZSBhbHBoYSBjaGFubmVsIG9mIGEgZGlzcGxheSBvYmplY3Q8L2xpPlxuXHQgKiAgICAgIDxsaT57eyNjcm9zc0xpbmsgXCJCbHVyRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319OiBBcHBseSB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBibHVyIHRvIGEgZGlzcGxheSBvYmplY3Q8L2xpPlxuXHQgKiAgICAgIDxsaT57eyNjcm9zc0xpbmsgXCJDb2xvckZpbHRlclwifX17ey9jcm9zc0xpbmt9fTogQ29sb3IgdHJhbnNmb3JtIGEgZGlzcGxheSBvYmplY3Q8L2xpPlxuXHQgKiAgICAgIDxsaT57eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeEZpbHRlclwifX17ey9jcm9zc0xpbmt9fTogVHJhbnNmb3JtIGFuIGltYWdlIHVzaW5nIGEge3sjY3Jvc3NMaW5rIFwiQ29sb3JNYXRyaXhcIn19e3svY3Jvc3NMaW5rfX08L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiBAY2xhc3MgRmlsdGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIEZpbHRlcigpIHt9XG5cdHZhciBwID0gRmlsdGVyLnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBQcm92aWRlcyBwYWRkaW5nIHZhbHVlcyBmb3IgdGhpcyBmaWx0ZXIuIFRoYXQgaXMsIGhvdyBtdWNoIHRoZSBmaWx0ZXIgd2lsbCBleHRlbmQgdGhlIHZpc3VhbCBib3VuZHMgb2YgYW4gb2JqZWN0IGl0IGlzIGFwcGxpZWQgdG8uXG5cdCAqIEBtZXRob2QgZ2V0Qm91bmRzXG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBbcmVjdF0gSWYgc3BlY2lmaWVkLCB0aGUgcHJvdmlkZWQgUmVjdGFuZ2xlIGluc3RhbmNlIHdpbGwgYmUgZXhwYW5kZWQgYnkgdGhlIHBhZGRpbmcgYW1vdW50cyBhbmQgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gSWYgYSBgcmVjdGAgcGFyYW0gd2FzIHByb3ZpZGVkLCBpdCBpcyByZXR1cm5lZC4gSWYgbm90LCBlaXRoZXIgYSBuZXcgcmVjdGFuZ2xlIHdpdGggdGhlIHBhZGRpbmcgdmFsdWVzLCBvciBudWxsIGlmIG5vIHBhZGRpbmcgaXMgcmVxdWlyZWQgZm9yIHRoaXMgZmlsdGVyLlxuXHQgKiovXG5cdHAuZ2V0Qm91bmRzID0gZnVuY3Rpb24ocmVjdCkge1xuXHRcdHJldHVybiByZWN0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIHRoZSBmaWx0ZXIgdG8gdGhlIHNwZWNpZmllZCBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGFwcGx5RmlsdGVyXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIDJEIGNvbnRleHQgdG8gdXNlIGFzIHRoZSBzb3VyY2UuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiB0byB1c2UgZm9yIHRoZSBzb3VyY2UgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCB0byB1c2UgZm9yIHRoZSBzb3VyY2UgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gW3RhcmdldEN0eF0gVGhlIDJEIGNvbnRleHQgdG8gZHJhdyB0aGUgcmVzdWx0IHRvLiBEZWZhdWx0cyB0byB0aGUgY29udGV4dCBwYXNzZWQgdG8gY3R4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RhcmdldFhdIFRoZSB4IHBvc2l0aW9uIHRvIGRyYXcgdGhlIHJlc3VsdCB0by4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIHBhc3NlZCB0byB4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RhcmdldFldIFRoZSB5IHBvc2l0aW9uIHRvIGRyYXcgdGhlIHJlc3VsdCB0by4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIHBhc3NlZCB0byB5LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgZmlsdGVyIHdhcyBhcHBsaWVkIHN1Y2Nlc3NmdWxseS5cblx0ICoqL1xuXHRwLmFwcGx5RmlsdGVyID0gZnVuY3Rpb24oY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0YXJnZXRDdHgsIHRhcmdldFgsIHRhcmdldFkpIHtcblx0XHQvLyB0aGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBiZWNhdXNlIG1vc3QgZmlsdGVycyBhY2Nlc3MgcGl4ZWwgZGF0YS4gSXQgaXMgb3ZlcnJpZGRlbiB3aGVuIG5vdCBuZWVkZWQuXG5cdFx0dGFyZ2V0Q3R4ID0gdGFyZ2V0Q3R4IHx8IGN0eDtcblx0XHRpZiAodGFyZ2V0WCA9PSBudWxsKSB7IHRhcmdldFggPSB4OyB9XG5cdFx0aWYgKHRhcmdldFkgPT0gbnVsbCkgeyB0YXJnZXRZID0geTsgfVxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9hcHBseUZpbHRlcihpbWFnZURhdGEpKSB7XG5cdFx0XHR0YXJnZXRDdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgdGFyZ2V0WCwgdGFyZ2V0WSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbRmlsdGVyXVwiO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBGaWx0ZXIgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7RmlsdGVyfSBBIGNsb25lIG9mIHRoZSBjdXJyZW50IEZpbHRlciBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoKTtcblx0fTtcblx0XG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9hcHBseUZpbHRlclxuXHQgKiBAcGFyYW0ge0ltYWdlRGF0YX0gaW1hZ2VEYXRhIFRhcmdldCBJbWFnZURhdGEgaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqKi9cblx0cC5fYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbihpbWFnZURhdGEpIHsgcmV0dXJuIHRydWU7IH07XG5cblxuXHRjcmVhdGVqcy5GaWx0ZXIgPSBGaWx0ZXI7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQmx1ckZpbHRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQXBwbGllcyBhIGJveCBibHVyIHRvIERpc3BsYXlPYmplY3RzLiBOb3RlIHRoYXQgdGhpcyBmaWx0ZXIgaXMgZmFpcmx5IENQVSBpbnRlbnNpdmUsIHBhcnRpY3VsYXJseSBpZiB0aGUgcXVhbGl0eSBpc1xuXHQgKiBzZXQgaGlnaGVyIHRoYW4gMS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBUaGlzIGV4YW1wbGUgY3JlYXRlcyBhIHJlZCBjaXJjbGUsIGFuZCB0aGVuIGFwcGxpZXMgYSA1IHBpeGVsIGJsdXIgdG8gaXQuIEl0IHVzZXMgdGhlIHt7I2Nyb3NzTGluayBcIkZpbHRlci9nZXRCb3VuZHNcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kIHRvIGFjY291bnQgZm9yIHRoZSBzcHJlYWQgdGhhdCB0aGUgYmx1ciBjYXVzZXMuXG5cdCAqXG5cdCAqICAgICAgdmFyIHNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCkuc2V0KHt4OjEwMCx5OjEwMH0pO1xuXHQgKiAgICAgIHNoYXBlLmdyYXBoaWNzLmJlZ2luRmlsbChcIiNmZjAwMDBcIikuZHJhd0NpcmNsZSgwLDAsNTApO1xuXHQgKlxuXHQgKiAgICAgIHZhciBibHVyRmlsdGVyID0gbmV3IGNyZWF0ZWpzLkJsdXJGaWx0ZXIoNSwgNSwgMSk7XG5cdCAqICAgICAgc2hhcGUuZmlsdGVycyA9IFtibHVyRmlsdGVyXTtcblx0ICogICAgICB2YXIgYm91bmRzID0gYmx1ckZpbHRlci5nZXRCb3VuZHMoKTtcblx0ICpcblx0ICogICAgICBzaGFwZS5jYWNoZSgtNTArYm91bmRzLngsIC01MCtib3VuZHMueSwgMTAwK2JvdW5kcy53aWR0aCwgMTAwK2JvdW5kcy5oZWlnaHQpO1xuXHQgKlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhbiBtb3JlIGluZm9ybWF0aW9uIG9uIGFwcGx5aW5nIGZpbHRlcnMuXG5cdCAqIEBjbGFzcyBCbHVyRmlsdGVyXG5cdCAqIEBleHRlbmRzIEZpbHRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtibHVyWD0wXSBUaGUgaG9yaXpvbnRhbCBibHVyIHJhZGl1cyBpbiBwaXhlbHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYmx1clk9MF0gVGhlIHZlcnRpY2FsIGJsdXIgcmFkaXVzIGluIHBpeGVscy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtxdWFsaXR5PTFdIFRoZSBudW1iZXIgb2YgYmx1ciBpdGVyYXRpb25zLlxuXHQgKiovXG5cdGZ1bmN0aW9uIEJsdXJGaWx0ZXIoIGJsdXJYLCBibHVyWSwgcXVhbGl0eSkge1xuXHRcdGlmICggaXNOYU4oYmx1clgpIHx8IGJsdXJYIDwgMCApIGJsdXJYID0gMDtcblx0XHRpZiAoIGlzTmFOKGJsdXJZKSB8fCBibHVyWSA8IDAgKSBibHVyWSA9IDA7XG5cdFx0aWYgKCBpc05hTihxdWFsaXR5KSB8fCBxdWFsaXR5IDwgMSAgKSBxdWFsaXR5ID0gMTtcblxuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogSG9yaXpvbnRhbCBibHVyIHJhZGl1cyBpbiBwaXhlbHNcblx0XHQgKiBAcHJvcGVydHkgYmx1clhcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuYmx1clggPSBibHVyWCB8IDA7XG5cblx0XHQvKipcblx0XHQgKiBWZXJ0aWNhbCBibHVyIHJhZGl1cyBpbiBwaXhlbHNcblx0XHQgKiBAcHJvcGVydHkgYmx1cllcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuYmx1clkgPSBibHVyWSB8IDA7XG5cblx0XHQvKipcblx0XHQgKiBOdW1iZXIgb2YgYmx1ciBpdGVyYXRpb25zLiBGb3IgZXhhbXBsZSwgYSB2YWx1ZSBvZiAxIHdpbGwgcHJvZHVjZSBhIHJvdWdoIGJsdXIuIEEgdmFsdWUgb2YgMiB3aWxsIHByb2R1Y2UgYVxuXHRcdCAqIHNtb290aGVyIGJsdXIsIGJ1dCB0YWtlIHR3aWNlIGFzIGxvbmcgdG8gcnVuLlxuXHRcdCAqIEBwcm9wZXJ0eSBxdWFsaXR5XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLnF1YWxpdHkgPSBxdWFsaXR5IHwgMDtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChCbHVyRmlsdGVyLCBjcmVhdGVqcy5GaWx0ZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cbi8vIGNvbnN0YW50czpcblx0LyoqXG5cdCAqIEFycmF5IG9mIG11bHRpcGx5IHZhbHVlcyBmb3IgYmx1ciBjYWxjdWxhdGlvbnMuXG5cdCAqIEBwcm9wZXJ0eSBNVUxfVEFCTEVcblx0ICogQHR5cGUgQXJyYXlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0Qmx1ckZpbHRlci5NVUxfVEFCTEUgPSBbMSwgMTcxLCAyMDUsIDI5MywgNTcsIDM3MywgNzksIDEzNywgMjQxLCAyNywgMzkxLCAzNTcsIDQxLCAxOSwgMjgzLCAyNjUsIDQ5NywgNDY5LCA0NDMsIDQyMSwgMjUsIDE5MSwgMzY1LCAzNDksIDMzNSwgMTYxLCAxNTUsIDE0OSwgOSwgMjc4LCAyNjksIDI2MSwgNTA1LCAyNDUsIDQ3NSwgMjMxLCA0NDksIDQzNywgMjEzLCA0MTUsIDQwNSwgMzk1LCAxOTMsIDM3NywgMzY5LCAzNjEsIDM1MywgMzQ1LCAxNjksIDMzMSwgMzI1LCAzMTksIDMxMywgMzA3LCAzMDEsIDM3LCAxNDUsIDI4NSwgMjgxLCA2OSwgMjcxLCAyNjcsIDI2MywgMjU5LCA1MDksIDUwMSwgNDkzLCAyNDMsIDQ3OSwgMTE4LCA0NjUsIDQ1OSwgMTEzLCA0NDYsIDU1LCA0MzUsIDQyOSwgNDIzLCAyMDksIDQxMywgNTEsIDQwMywgMTk5LCAzOTMsIDk3LCAzLCAzNzksIDM3NSwgMzcxLCAzNjcsIDM2MywgMzU5LCAzNTUsIDM1MSwgMzQ3LCA0MywgODUsIDMzNywgMzMzLCAxNjUsIDMyNywgMzIzLCA1LCAzMTcsIDE1NywgMzExLCA3NywgMzA1LCAzMDMsIDc1LCAyOTcsIDI5NCwgNzMsIDI4OSwgMjg3LCA3MSwgMTQxLCAyNzksIDI3NywgMjc1LCA2OCwgMTM1LCA2NywgMTMzLCAzMywgMjYyLCAyNjAsIDEyOSwgNTExLCA1MDcsIDUwMywgNDk5LCA0OTUsIDQ5MSwgNjEsIDEyMSwgNDgxLCA0NzcsIDIzNywgMjM1LCA0NjcsIDIzMiwgMTE1LCA0NTcsIDIyNywgNDUxLCA3LCA0NDUsIDIyMSwgNDM5LCAyMTgsIDQzMywgMjE1LCA0MjcsIDQyNSwgMjExLCA0MTksIDQxNywgMjA3LCA0MTEsIDQwOSwgMjAzLCAyMDIsIDQwMSwgMzk5LCAzOTYsIDE5NywgNDksIDM4OSwgMzg3LCAzODUsIDM4MywgOTUsIDE4OSwgNDcsIDE4NywgOTMsIDE4NSwgMjMsIDE4MywgOTEsIDE4MSwgNDUsIDE3OSwgODksIDE3NywgMTEsIDE3NSwgODcsIDE3MywgMzQ1LCAzNDMsIDM0MSwgMzM5LCAzMzcsIDIxLCAxNjcsIDgzLCAzMzEsIDMyOSwgMzI3LCAxNjMsIDgxLCAzMjMsIDMyMSwgMzE5LCAxNTksIDc5LCAzMTUsIDMxMywgMzksIDE1NSwgMzA5LCAzMDcsIDE1MywgMzA1LCAzMDMsIDE1MSwgNzUsIDI5OSwgMTQ5LCAzNywgMjk1LCAxNDcsIDczLCAyOTEsIDE0NSwgMjg5LCAyODcsIDE0MywgMjg1LCA3MSwgMTQxLCAyODEsIDM1LCAyNzksIDEzOSwgNjksIDI3NSwgMTM3LCAyNzMsIDE3LCAyNzEsIDEzNSwgMjY5LCAyNjcsIDEzMywgMjY1LCAzMywgMjYzLCAxMzEsIDI2MSwgMTMwLCAyNTksIDEyOSwgMjU3LCAxXTtcblxuXHQvKipcblx0ICogQXJyYXkgb2Ygc2hpZnQgdmFsdWVzIGZvciBibHVyIGNhbGN1bGF0aW9ucy5cblx0ICogQHByb3BlcnR5IFNIR19UQUJMRVxuXHQgKiBAdHlwZSBBcnJheVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRCbHVyRmlsdGVyLlNIR19UQUJMRSA9IFswLCA5LCAxMCwgMTEsIDksIDEyLCAxMCwgMTEsIDEyLCA5LCAxMywgMTMsIDEwLCA5LCAxMywgMTMsIDE0LCAxNCwgMTQsIDE0LCAxMCwgMTMsIDE0LCAxNCwgMTQsIDEzLCAxMywgMTMsIDksIDE0LCAxNCwgMTQsIDE1LCAxNCwgMTUsIDE0LCAxNSwgMTUsIDE0LCAxNSwgMTUsIDE1LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTIsIDE0LCAxNSwgMTUsIDEzLCAxNSwgMTUsIDE1LCAxNSwgMTYsIDE2LCAxNiwgMTUsIDE2LCAxNCwgMTYsIDE2LCAxNCwgMTYsIDEzLCAxNiwgMTYsIDE2LCAxNSwgMTYsIDEzLCAxNiwgMTUsIDE2LCAxNCwgOSwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTMsIDE0LCAxNiwgMTYsIDE1LCAxNiwgMTYsIDEwLCAxNiwgMTUsIDE2LCAxNCwgMTYsIDE2LCAxNCwgMTYsIDE2LCAxNCwgMTYsIDE2LCAxNCwgMTUsIDE2LCAxNiwgMTYsIDE0LCAxNSwgMTQsIDE1LCAxMywgMTYsIDE2LCAxNSwgMTcsIDE3LCAxNywgMTcsIDE3LCAxNywgMTQsIDE1LCAxNywgMTcsIDE2LCAxNiwgMTcsIDE2LCAxNSwgMTcsIDE2LCAxNywgMTEsIDE3LCAxNiwgMTcsIDE2LCAxNywgMTYsIDE3LCAxNywgMTYsIDE3LCAxNywgMTYsIDE3LCAxNywgMTYsIDE2LCAxNywgMTcsIDE3LCAxNiwgMTQsIDE3LCAxNywgMTcsIDE3LCAxNSwgMTYsIDE0LCAxNiwgMTUsIDE2LCAxMywgMTYsIDE1LCAxNiwgMTQsIDE2LCAxNSwgMTYsIDEyLCAxNiwgMTUsIDE2LCAxNywgMTcsIDE3LCAxNywgMTcsIDEzLCAxNiwgMTUsIDE3LCAxNywgMTcsIDE2LCAxNSwgMTcsIDE3LCAxNywgMTYsIDE1LCAxNywgMTcsIDE0LCAxNiwgMTcsIDE3LCAxNiwgMTcsIDE3LCAxNiwgMTUsIDE3LCAxNiwgMTQsIDE3LCAxNiwgMTUsIDE3LCAxNiwgMTcsIDE3LCAxNiwgMTcsIDE1LCAxNiwgMTcsIDE0LCAxNywgMTYsIDE1LCAxNywgMTYsIDE3LCAxMywgMTcsIDE2LCAxNywgMTcsIDE2LCAxNywgMTQsIDE3LCAxNiwgMTcsIDE2LCAxNywgMTYsIDE3LCA5XTtcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKHJlY3QpIHtcblx0XHR2YXIgeCA9IHRoaXMuYmx1clh8MCwgeSA9IHRoaXMuYmx1cll8IDA7XG5cdFx0aWYgKHggPD0gMCAmJiB5IDw9IDApIHsgcmV0dXJuIHJlY3Q7IH1cblx0XHR2YXIgcSA9IE1hdGgucG93KHRoaXMucXVhbGl0eSwgMC4yKTtcblx0XHRyZXR1cm4gKHJlY3QgfHwgbmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSgpKS5wYWQoeCpxKzEseSpxKzEseCpxKzEseSpxKzEpO1xuXHR9O1xuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEJsdXJGaWx0ZXIodGhpcy5ibHVyWCwgdGhpcy5ibHVyWSwgdGhpcy5xdWFsaXR5KTtcblx0fTtcblxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0JsdXJGaWx0ZXJdXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuX2FwcGx5RmlsdGVyID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuXG5cdFx0dmFyIHJhZGl1c1ggPSB0aGlzLmJsdXJYID4+IDE7XG5cdFx0aWYgKGlzTmFOKHJhZGl1c1gpIHx8IHJhZGl1c1ggPCAwKSByZXR1cm4gZmFsc2U7XG5cdFx0dmFyIHJhZGl1c1kgPSB0aGlzLmJsdXJZID4+IDE7XG5cdFx0aWYgKGlzTmFOKHJhZGl1c1kpIHx8IHJhZGl1c1kgPCAwKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYgKHJhZGl1c1ggPT0gMCAmJiByYWRpdXNZID09IDApIHJldHVybiBmYWxzZTtcblxuXHRcdHZhciBpdGVyYXRpb25zID0gdGhpcy5xdWFsaXR5O1xuXHRcdGlmIChpc05hTihpdGVyYXRpb25zKSB8fCBpdGVyYXRpb25zIDwgMSkgaXRlcmF0aW9ucyA9IDE7XG5cdFx0aXRlcmF0aW9ucyB8PSAwO1xuXHRcdGlmIChpdGVyYXRpb25zID4gMykgaXRlcmF0aW9ucyA9IDM7XG5cdFx0aWYgKGl0ZXJhdGlvbnMgPCAxKSBpdGVyYXRpb25zID0gMTtcblxuXHRcdHZhciBweCA9IGltYWdlRGF0YS5kYXRhO1xuXHRcdHZhciB4PTAsIHk9MCwgaT0wLCBwPTAsIHlwPTAsIHlpPTAsIHl3PTAsIHI9MCwgZz0wLCBiPTAsIGE9MCwgcHI9MCwgcGc9MCwgcGI9MCwgcGE9MDtcblxuXHRcdHZhciBkaXZ4ID0gKHJhZGl1c1ggKyByYWRpdXNYICsgMSkgfCAwO1xuXHRcdHZhciBkaXZ5ID0gKHJhZGl1c1kgKyByYWRpdXNZICsgMSkgfCAwO1xuXHRcdHZhciB3ID0gaW1hZ2VEYXRhLndpZHRoIHwgMDtcblx0XHR2YXIgaCA9IGltYWdlRGF0YS5oZWlnaHQgfCAwO1xuXG5cdFx0dmFyIHcxID0gKHcgLSAxKSB8IDA7XG5cdFx0dmFyIGgxID0gKGggLSAxKSB8IDA7XG5cdFx0dmFyIHJ4cDEgPSAocmFkaXVzWCArIDEpIHwgMDtcblx0XHR2YXIgcnlwMSA9IChyYWRpdXNZICsgMSkgfCAwO1xuXG5cdFx0dmFyIHNzeCA9IHtyOjAsYjowLGc6MCxhOjB9O1xuXHRcdHZhciBzeCA9IHNzeDtcblx0XHRmb3IgKCBpID0gMTsgaSA8IGRpdng7IGkrKyApXG5cdFx0e1xuXHRcdFx0c3ggPSBzeC5uID0ge3I6MCxiOjAsZzowLGE6MH07XG5cdFx0fVxuXHRcdHN4Lm4gPSBzc3g7XG5cblx0XHR2YXIgc3N5ID0ge3I6MCxiOjAsZzowLGE6MH07XG5cdFx0dmFyIHN5ID0gc3N5O1xuXHRcdGZvciAoIGkgPSAxOyBpIDwgZGl2eTsgaSsrIClcblx0XHR7XG5cdFx0XHRzeSA9IHN5Lm4gPSB7cjowLGI6MCxnOjAsYTowfTtcblx0XHR9XG5cdFx0c3kubiA9IHNzeTtcblxuXHRcdHZhciBzaSA9IG51bGw7XG5cblxuXHRcdHZhciBtdHggPSBCbHVyRmlsdGVyLk1VTF9UQUJMRVtyYWRpdXNYXSB8IDA7XG5cdFx0dmFyIHN0eCA9IEJsdXJGaWx0ZXIuU0hHX1RBQkxFW3JhZGl1c1hdIHwgMDtcblx0XHR2YXIgbXR5ID0gQmx1ckZpbHRlci5NVUxfVEFCTEVbcmFkaXVzWV0gfCAwO1xuXHRcdHZhciBzdHkgPSBCbHVyRmlsdGVyLlNIR19UQUJMRVtyYWRpdXNZXSB8IDA7XG5cblx0XHR3aGlsZSAoaXRlcmF0aW9ucy0tID4gMCkge1xuXG5cdFx0XHR5dyA9IHlpID0gMDtcblx0XHRcdHZhciBtcyA9IG10eDtcblx0XHRcdHZhciBzcyA9IHN0eDtcblx0XHRcdGZvciAoeSA9IGg7IC0teSA+IC0xOykge1xuXHRcdFx0XHRyID0gcnhwMSAqIChwciA9IHB4Wyh5aSkgfCAwXSk7XG5cdFx0XHRcdGcgPSByeHAxICogKHBnID0gcHhbKHlpICsgMSkgfCAwXSk7XG5cdFx0XHRcdGIgPSByeHAxICogKHBiID0gcHhbKHlpICsgMikgfCAwXSk7XG5cdFx0XHRcdGEgPSByeHAxICogKHBhID0gcHhbKHlpICsgMykgfCAwXSk7XG5cblx0XHRcdFx0c3ggPSBzc3g7XG5cblx0XHRcdFx0Zm9yKCBpID0gcnhwMTsgLS1pID4gLTE7IClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHN4LnIgPSBwcjtcblx0XHRcdFx0XHRzeC5nID0gcGc7XG5cdFx0XHRcdFx0c3guYiA9IHBiO1xuXHRcdFx0XHRcdHN4LmEgPSBwYTtcblx0XHRcdFx0XHRzeCA9IHN4Lm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IoIGkgPSAxOyBpIDwgcnhwMTsgaSsrIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHAgPSAoeWkgKyAoKHcxIDwgaSA/IHcxIDogaSkgPDwgMikpIHwgMDtcblx0XHRcdFx0XHRyICs9ICggc3guciA9IHB4W3BdKTtcblx0XHRcdFx0XHRnICs9ICggc3guZyA9IHB4W3ArMV0pO1xuXHRcdFx0XHRcdGIgKz0gKCBzeC5iID0gcHhbcCsyXSk7XG5cdFx0XHRcdFx0YSArPSAoIHN4LmEgPSBweFtwKzNdKTtcblxuXHRcdFx0XHRcdHN4ID0gc3gubjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNpID0gc3N4O1xuXHRcdFx0XHRmb3IgKCB4ID0gMDsgeCA8IHc7IHgrKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRweFt5aSsrXSA9IChyICogbXMpID4+PiBzcztcblx0XHRcdFx0XHRweFt5aSsrXSA9IChnICogbXMpID4+PiBzcztcblx0XHRcdFx0XHRweFt5aSsrXSA9IChiICogbXMpID4+PiBzcztcblx0XHRcdFx0XHRweFt5aSsrXSA9IChhICogbXMpID4+PiBzcztcblxuXHRcdFx0XHRcdHAgPSAoKHl3ICsgKChwID0geCArIHJhZGl1c1ggKyAxKSA8IHcxID8gcCA6IHcxKSkgPDwgMik7XG5cblx0XHRcdFx0XHRyIC09IHNpLnIgLSAoIHNpLnIgPSBweFtwXSk7XG5cdFx0XHRcdFx0ZyAtPSBzaS5nIC0gKCBzaS5nID0gcHhbcCsxXSk7XG5cdFx0XHRcdFx0YiAtPSBzaS5iIC0gKCBzaS5iID0gcHhbcCsyXSk7XG5cdFx0XHRcdFx0YSAtPSBzaS5hIC0gKCBzaS5hID0gcHhbcCszXSk7XG5cblx0XHRcdFx0XHRzaSA9IHNpLm47XG5cblx0XHRcdFx0fVxuXHRcdFx0XHR5dyArPSB3O1xuXHRcdFx0fVxuXG5cdFx0XHRtcyA9IG10eTtcblx0XHRcdHNzID0gc3R5O1xuXHRcdFx0Zm9yICh4ID0gMDsgeCA8IHc7IHgrKykge1xuXHRcdFx0XHR5aSA9ICh4IDw8IDIpIHwgMDtcblxuXHRcdFx0XHRyID0gKHJ5cDEgKiAocHIgPSBweFt5aV0pKSB8IDA7XG5cdFx0XHRcdGcgPSAocnlwMSAqIChwZyA9IHB4Wyh5aSArIDEpIHwgMF0pKSB8IDA7XG5cdFx0XHRcdGIgPSAocnlwMSAqIChwYiA9IHB4Wyh5aSArIDIpIHwgMF0pKSB8IDA7XG5cdFx0XHRcdGEgPSAocnlwMSAqIChwYSA9IHB4Wyh5aSArIDMpIHwgMF0pKSB8IDA7XG5cblx0XHRcdFx0c3kgPSBzc3k7XG5cdFx0XHRcdGZvciggaSA9IDA7IGkgPCByeXAxOyBpKysgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c3kuciA9IHByO1xuXHRcdFx0XHRcdHN5LmcgPSBwZztcblx0XHRcdFx0XHRzeS5iID0gcGI7XG5cdFx0XHRcdFx0c3kuYSA9IHBhO1xuXHRcdFx0XHRcdHN5ID0gc3kubjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHlwID0gdztcblxuXHRcdFx0XHRmb3IoIGkgPSAxOyBpIDw9IHJhZGl1c1k7IGkrKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR5aSA9ICggeXAgKyB4ICkgPDwgMjtcblxuXHRcdFx0XHRcdHIgKz0gKCBzeS5yID0gcHhbeWldKTtcblx0XHRcdFx0XHRnICs9ICggc3kuZyA9IHB4W3lpKzFdKTtcblx0XHRcdFx0XHRiICs9ICggc3kuYiA9IHB4W3lpKzJdKTtcblx0XHRcdFx0XHRhICs9ICggc3kuYSA9IHB4W3lpKzNdKTtcblxuXHRcdFx0XHRcdHN5ID0gc3kubjtcblxuXHRcdFx0XHRcdGlmKCBpIDwgaDEgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHlwICs9IHc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0eWkgPSB4O1xuXHRcdFx0XHRzaSA9IHNzeTtcblx0XHRcdFx0aWYgKCBpdGVyYXRpb25zID4gMCApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmb3IgKCB5ID0gMDsgeSA8IGg7IHkrKyApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cCA9IHlpIDw8IDI7XG5cdFx0XHRcdFx0XHRweFtwKzNdID0gcGEgPShhICogbXMpID4+PiBzcztcblx0XHRcdFx0XHRcdGlmICggcGEgPiAwIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cHhbcF0gICA9ICgociAqIG1zKSA+Pj4gc3MgKTtcblx0XHRcdFx0XHRcdFx0cHhbcCsxXSA9ICgoZyAqIG1zKSA+Pj4gc3MgKTtcblx0XHRcdFx0XHRcdFx0cHhbcCsyXSA9ICgoYiAqIG1zKSA+Pj4gc3MgKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHB4W3BdID0gcHhbcCsxXSA9IHB4W3ArMl0gPSAwXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHAgPSAoIHggKyAoKCAoIHAgPSB5ICsgcnlwMSkgPCBoMSA/IHAgOiBoMSApICogdyApKSA8PCAyO1xuXG5cdFx0XHRcdFx0XHRyIC09IHNpLnIgLSAoIHNpLnIgPSBweFtwXSk7XG5cdFx0XHRcdFx0XHRnIC09IHNpLmcgLSAoIHNpLmcgPSBweFtwKzFdKTtcblx0XHRcdFx0XHRcdGIgLT0gc2kuYiAtICggc2kuYiA9IHB4W3ArMl0pO1xuXHRcdFx0XHRcdFx0YSAtPSBzaS5hIC0gKCBzaS5hID0gcHhbcCszXSk7XG5cblx0XHRcdFx0XHRcdHNpID0gc2kubjtcblxuXHRcdFx0XHRcdFx0eWkgKz0gdztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Zm9yICggeSA9IDA7IHkgPCBoOyB5KysgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHAgPSB5aSA8PCAyO1xuXHRcdFx0XHRcdFx0cHhbcCszXSA9IHBhID0oYSAqIG1zKSA+Pj4gc3M7XG5cdFx0XHRcdFx0XHRpZiAoIHBhID4gMCApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHBhID0gMjU1IC8gcGE7XG5cdFx0XHRcdFx0XHRcdHB4W3BdICAgPSAoKHIgKiBtcykgPj4+IHNzICkgKiBwYTtcblx0XHRcdFx0XHRcdFx0cHhbcCsxXSA9ICgoZyAqIG1zKSA+Pj4gc3MgKSAqIHBhO1xuXHRcdFx0XHRcdFx0XHRweFtwKzJdID0gKChiICogbXMpID4+PiBzcyApICogcGE7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRweFtwXSA9IHB4W3ArMV0gPSBweFtwKzJdID0gMFxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRwID0gKCB4ICsgKCggKCBwID0geSArIHJ5cDEpIDwgaDEgPyBwIDogaDEgKSAqIHcgKSkgPDwgMjtcblxuXHRcdFx0XHRcdFx0ciAtPSBzaS5yIC0gKCBzaS5yID0gcHhbcF0pO1xuXHRcdFx0XHRcdFx0ZyAtPSBzaS5nIC0gKCBzaS5nID0gcHhbcCsxXSk7XG5cdFx0XHRcdFx0XHRiIC09IHNpLmIgLSAoIHNpLmIgPSBweFtwKzJdKTtcblx0XHRcdFx0XHRcdGEgLT0gc2kuYSAtICggc2kuYSA9IHB4W3ArM10pO1xuXG5cdFx0XHRcdFx0XHRzaSA9IHNpLm47XG5cblx0XHRcdFx0XHRcdHlpICs9IHc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0Y3JlYXRlanMuQmx1ckZpbHRlciA9IGNyZWF0ZWpzLnByb21vdGUoQmx1ckZpbHRlciwgXCJGaWx0ZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQWxwaGFNYXBGaWx0ZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdFxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBBcHBsaWVzIGEgZ3JleXNjYWxlIGFscGhhIG1hcCBpbWFnZSAob3IgY2FudmFzKSB0byB0aGUgdGFyZ2V0LCBzdWNoIHRoYXQgdGhlIGFscGhhIGNoYW5uZWwgb2YgdGhlIHJlc3VsdCB3aWxsXG5cdCAqIGJlIGNvcGllZCBmcm9tIHRoZSByZWQgY2hhbm5lbCBvZiB0aGUgbWFwLCBhbmQgdGhlIFJHQiBjaGFubmVscyB3aWxsIGJlIGNvcGllZCBmcm9tIHRoZSB0YXJnZXQuXG5cdCAqXG5cdCAqIEdlbmVyYWxseSwgaXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3UgdXNlIHt7I2Nyb3NzTGluayBcIkFscGhhTWFza0ZpbHRlclwifX17ey9jcm9zc0xpbmt9fSwgYmVjYXVzZSBpdCBoYXMgbXVjaFxuXHQgKiBiZXR0ZXIgcGVyZm9ybWFuY2UuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogVGhpcyBleGFtcGxlIGRyYXdzIGEgcmVkLT5ibHVlIGJveCwgY2FjaGVzIGl0LCBhbmQgdGhlbiB1c2VzIHRoZSBjYWNoZSBjYW52YXMgYXMgYW4gYWxwaGEgbWFwIG9uIGEgMTAweDEwMCBpbWFnZS5cblx0ICpcblx0ICogICAgICAgdmFyIGJveCA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuXHQgKiAgICAgICBib3guZ3JhcGhpY3MuYmVnaW5MaW5lYXJHcmFkaWVudEZpbGwoW1wiI2ZmMDAwMFwiLCBcIiMwMDAwZmZcIl0sIFswLCAxXSwgMCwgMCwgMCwgMTAwKVxuXHQgKiAgICAgICBib3guZ3JhcGhpY3MuZHJhd1JlY3QoMCwgMCwgMTAwLCAxMDApO1xuXHQgKiAgICAgICBib3guY2FjaGUoMCwgMCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiAgICAgICB2YXIgYm1wID0gbmV3IGNyZWF0ZWpzLkJpdG1hcChcInBhdGgvdG8vaW1hZ2UuanBnXCIpO1xuXHQgKiAgICAgICBibXAuZmlsdGVycyA9IFtcblx0ICogICAgICAgICAgIG5ldyBjcmVhdGVqcy5BbHBoYU1hcEZpbHRlcihib3guY2FjaGVDYW52YXMpXG5cdCAqICAgICAgIF07XG5cdCAqICAgICAgIGJtcC5jYWNoZSgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqICAgICAgIHN0YWdlLmFkZENoaWxkKGJtcCk7XG5cdCAqXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gYXBwbHlpbmcgZmlsdGVycy5cblx0ICogQGNsYXNzIEFscGhhTWFwRmlsdGVyXG5cdCAqIEBleHRlbmRzIEZpbHRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBhbHBoYU1hcCBUaGUgZ3JleXNjYWxlIGltYWdlIChvciBjYW52YXMpIHRvIHVzZSBhcyB0aGUgYWxwaGEgdmFsdWUgZm9yIHRoZVxuXHQgKiByZXN1bHQuIFRoaXMgc2hvdWxkIGJlIGV4YWN0bHkgdGhlIHNhbWUgZGltZW5zaW9ucyBhcyB0aGUgdGFyZ2V0LlxuXHQgKiovXG5cdGZ1bmN0aW9uIEFscGhhTWFwRmlsdGVyKGFscGhhTWFwKSB7XG5cdFxuXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIGdyZXlzY2FsZSBpbWFnZSAob3IgY2FudmFzKSB0byB1c2UgYXMgdGhlIGFscGhhIHZhbHVlIGZvciB0aGUgcmVzdWx0LiBUaGlzIHNob3VsZCBiZSBleGFjdGx5IHRoZSBzYW1lXG5cdFx0ICogZGltZW5zaW9ucyBhcyB0aGUgdGFyZ2V0LlxuXHRcdCAqIEBwcm9wZXJ0eSBhbHBoYU1hcFxuXHRcdCAqIEB0eXBlIEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnRcblx0XHQgKiovXG5cdFx0dGhpcy5hbHBoYU1hcCA9IGFscGhhTWFwO1xuXHRcdFxuXHRcdFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9hbHBoYU1hcFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2FscGhhTWFwID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX21hcERhdGFcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgVWludDhDbGFtcGVkQXJyYXlcblx0XHQgKiovXG5cdFx0dGhpcy5fbWFwRGF0YSA9IG51bGw7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQWxwaGFNYXBGaWx0ZXIsIGNyZWF0ZWpzLkZpbHRlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG8gPSBuZXcgQWxwaGFNYXBGaWx0ZXIodGhpcy5hbHBoYU1hcCk7XG5cdFx0by5fYWxwaGFNYXAgPSB0aGlzLl9hbHBoYU1hcDtcblx0XHRvLl9tYXBEYXRhID0gdGhpcy5fbWFwRGF0YTtcblx0XHRyZXR1cm4gbztcblx0fTtcblxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltBbHBoYU1hcEZpbHRlcl1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuX2FwcGx5RmlsdGVyID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuXHRcdGlmICghdGhpcy5hbHBoYU1hcCkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGlmICghdGhpcy5fcHJlcEFscGhhTWFwKCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XG5cdFx0Ly8gVE9ETzogdXBkYXRlIHRvIHN1cHBvcnQgc2NlbmFyaW9zIHdoZXJlIHRoZSB0YXJnZXQgaGFzIGRpZmZlcmVudCBkaW1lbnNpb25zLlxuXHRcdHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcERhdGE7XG5cdFx0Zm9yKHZhciBpPTAsIGw9ZGF0YS5sZW5ndGg7IGk8bDsgaSArPSA0KSB7IGRhdGFbaSArIDNdID0gbWFwW2ldIHx8IDA7IH1cblx0XHRcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfcHJlcEFscGhhTWFwXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9wcmVwQWxwaGFNYXAgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLmFscGhhTWFwKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0aGlzLmFscGhhTWFwID09IHRoaXMuX2FscGhhTWFwICYmIHRoaXMuX21hcERhdGEpIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdHRoaXMuX21hcERhdGEgPSBudWxsO1xuXHRcdHZhciBtYXAgPSB0aGlzLl9hbHBoYU1hcCA9IHRoaXMuYWxwaGFNYXA7XG5cdFx0dmFyIGNhbnZhcyA9IG1hcDtcblx0XHR2YXIgY3R4O1xuXHRcdGlmIChtYXAgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuXHRcdFx0Y3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FudmFzID0gY3JlYXRlanMuY3JlYXRlQ2FudmFzID8gY3JlYXRlanMuY3JlYXRlQ2FudmFzKCkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXHRcdFx0Y2FudmFzLndpZHRoID0gbWFwLndpZHRoO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IG1hcC5oZWlnaHQ7XG5cdFx0XHRjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdFx0Y3R4LmRyYXdJbWFnZShtYXAsIDAsIDApO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgaW1nRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgbWFwLndpZHRoLCBtYXAuaGVpZ2h0KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHQvL2lmICghdGhpcy5zdXBwcmVzc0Nyb3NzRG9tYWluRXJyb3JzKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmFibGUgdG8gYWNjZXNzIGxvY2FsIGltYWdlIGRhdGE6IFwiICsgZSk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdFxuXHRcdHRoaXMuX21hcERhdGEgPSBpbWdEYXRhLmRhdGE7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5BbHBoYU1hcEZpbHRlciA9IGNyZWF0ZWpzLnByb21vdGUoQWxwaGFNYXBGaWx0ZXIsIFwiRmlsdGVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEFscGhhTWFza0ZpbHRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQXBwbGllcyB0aGUgYWxwaGEgZnJvbSB0aGUgbWFzayBpbWFnZSAob3IgY2FudmFzKSB0byB0aGUgdGFyZ2V0LCBzdWNoIHRoYXQgdGhlIGFscGhhIGNoYW5uZWwgb2YgdGhlIHJlc3VsdCB3aWxsXG5cdCAqIGJlIGRlcml2ZWQgZnJvbSB0aGUgbWFzaywgYW5kIHRoZSBSR0IgY2hhbm5lbHMgd2lsbCBiZSBjb3BpZWQgZnJvbSB0aGUgdGFyZ2V0LiBUaGlzIGNhbiBiZSB1c2VkLCBmb3IgZXhhbXBsZSwgdG9cblx0ICogYXBwbHkgYW4gYWxwaGEgbWFzayB0byBhIGRpc3BsYXkgb2JqZWN0LiBUaGlzIGNhbiBhbHNvIGJlIHVzZWQgdG8gY29tYmluZSBhIEpQRyBjb21wcmVzc2VkIFJHQiBpbWFnZSB3aXRoIGEgUE5HMzJcblx0ICogYWxwaGEgbWFzaywgd2hpY2ggY2FuIHJlc3VsdCBpbiBhIG11Y2ggc21hbGxlciBmaWxlIHNpemUgdGhhbiBhIHNpbmdsZSBQTkczMiBjb250YWluaW5nIEFSR0IuXG5cdCAqXG5cdCAqIDxiPklNUE9SVEFOVCBOT1RFOiBUaGlzIGZpbHRlciBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCB0aGUgdGFyZ2V0Q3R4LCBvciB0YXJnZXRYL1kgcGFyYW1ldGVycyBjb3JyZWN0bHkuPC9iPlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIFRoaXMgZXhhbXBsZSBkcmF3cyBhIGdyYWRpZW50IGJveCwgdGhlbiBjYWNoZXMgaXQgYW5kIHVzZXMgdGhlIFwiY2FjaGVDYW52YXNcIiBhcyB0aGUgYWxwaGEgbWFzayBvbiBhIDEwMHgxMDAgaW1hZ2UuXG5cdCAqXG5cdCAqICAgICAgdmFyIGJveCA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuXHQgKiAgICAgIGJveC5ncmFwaGljcy5iZWdpbkxpbmVhckdyYWRpZW50RmlsbChbXCIjMDAwMDAwXCIsIFwicmdiYSgwLCAwLCAwLCAwKVwiXSwgWzAsIDFdLCAwLCAwLCAxMDAsIDEwMClcblx0ICogICAgICBib3guZ3JhcGhpY3MuZHJhd1JlY3QoMCwgMCwgMTAwLCAxMDApO1xuXHQgKiAgICAgIGJveC5jYWNoZSgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqXG5cdCAqICAgICAgdmFyIGJtcCA9IG5ldyBjcmVhdGVqcy5CaXRtYXAoXCJwYXRoL3RvL2ltYWdlLmpwZ1wiKTtcblx0ICogICAgICBibXAuZmlsdGVycyA9IFtcblx0ICogICAgICAgICAgbmV3IGNyZWF0ZWpzLkFscGhhTWFza0ZpbHRlcihib3guY2FjaGVDYW52YXMpXG5cdCAqICAgICAgXTtcblx0ICogICAgICBibXAuY2FjaGUoMCwgMCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGFwcGx5aW5nIGZpbHRlcnMuXG5cdCAqIEBjbGFzcyBBbHBoYU1hc2tGaWx0ZXJcblx0ICogQGV4dGVuZHMgRmlsdGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IG1hc2tcblx0ICoqL1xuXHRmdW5jdGlvbiBBbHBoYU1hc2tGaWx0ZXIobWFzaykge1xuXHRcblx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSBpbWFnZSAob3IgY2FudmFzKSB0byB1c2UgYXMgdGhlIG1hc2suXG5cdFx0ICogQHByb3BlcnR5IG1hc2tcblx0XHQgKiBAdHlwZSBIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50XG5cdFx0ICoqL1xuXHRcdHRoaXMubWFzayA9IG1hc2s7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQWxwaGFNYXNrRmlsdGVyLCBjcmVhdGVqcy5GaWx0ZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXHRcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBBcHBsaWVzIHRoZSBmaWx0ZXIgdG8gdGhlIHNwZWNpZmllZCBjb250ZXh0LlxuXHQgKlxuXHQgKiA8c3Ryb25nPklNUE9SVEFOVCBOT1RFOiBUaGlzIGZpbHRlciBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCB0aGUgdGFyZ2V0Q3R4LCBvciB0YXJnZXRYL1kgcGFyYW1ldGVyc1xuXHQgKiBjb3JyZWN0bHkuPC9zdHJvbmc+XG5cdCAqIEBtZXRob2QgYXBwbHlGaWx0ZXJcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgMkQgY29udGV4dCB0byB1c2UgYXMgdGhlIHNvdXJjZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uIHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBbdGFyZ2V0Q3R4XSBOT1QgU1VQUE9SVEVEIElOIFRISVMgRklMVEVSLiBUaGUgMkQgY29udGV4dCB0byBkcmF3IHRoZSByZXN1bHQgdG8uIERlZmF1bHRzIHRvIHRoZSBjb250ZXh0IHBhc3NlZCB0byBjdHguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGFyZ2V0WF0gTk9UIFNVUFBPUlRFRCBJTiBUSElTIEZJTFRFUi4gVGhlIHggcG9zaXRpb24gdG8gZHJhdyB0aGUgcmVzdWx0IHRvLiBEZWZhdWx0cyB0byB0aGUgdmFsdWUgcGFzc2VkIHRvIHguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGFyZ2V0WV0gTk9UIFNVUFBPUlRFRCBJTiBUSElTIEZJTFRFUi4gVGhlIHkgcG9zaXRpb24gdG8gZHJhdyB0aGUgcmVzdWx0IHRvLiBEZWZhdWx0cyB0byB0aGUgdmFsdWUgcGFzc2VkIHRvIHkuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBmaWx0ZXIgd2FzIGFwcGxpZWQgc3VjY2Vzc2Z1bGx5LlxuXHQgKiovXG5cdHAuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0YXJnZXRDdHgsIHRhcmdldFgsIHRhcmdldFkpIHtcblx0XHRpZiAoIXRoaXMubWFzaykgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdHRhcmdldEN0eCA9IHRhcmdldEN0eCB8fCBjdHg7XG5cdFx0aWYgKHRhcmdldFggPT0gbnVsbCkgeyB0YXJnZXRYID0geDsgfVxuXHRcdGlmICh0YXJnZXRZID09IG51bGwpIHsgdGFyZ2V0WSA9IHk7IH1cblxuXHRcdHRhcmdldEN0eC5zYXZlKCk7XG5cdFx0aWYgKGN0eCAhPSB0YXJnZXRDdHgpIHtcblx0XHRcdC8vIFRPRE86IHN1cHBvcnQgdGFyZ2V0Q3R4IGFuZCB0YXJnZXRYL1lcblx0XHRcdC8vIGNsZWFyUmVjdCwgdGhlbiBkcmF3IHRoZSBjdHggaW4/XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dGFyZ2V0Q3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24taW5cIjtcblx0XHR0YXJnZXRDdHguZHJhd0ltYWdlKHRoaXMubWFzaywgdGFyZ2V0WCwgdGFyZ2V0WSk7XG5cdFx0dGFyZ2V0Q3R4LnJlc3RvcmUoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBuZXcgQWxwaGFNYXNrRmlsdGVyKHRoaXMubWFzayk7XG5cdH07XG5cblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbQWxwaGFNYXNrRmlsdGVyXVwiO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuQWxwaGFNYXNrRmlsdGVyID0gY3JlYXRlanMucHJvbW90ZShBbHBoYU1hc2tGaWx0ZXIsIFwiRmlsdGVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIENvbG9yRmlsdGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBBcHBsaWVzIGEgY29sb3IgdHJhbnNmb3JtIHRvIERpc3BsYXlPYmplY3RzLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIFRoaXMgZXhhbXBsZSBkcmF3cyBhIHJlZCBjaXJjbGUsIGFuZCB0aGVuIHRyYW5zZm9ybXMgaXQgdG8gQmx1ZS4gVGhpcyBpcyBhY2NvbXBsaXNoZWQgYnkgbXVsdGlwbHlpbmcgYWxsIHRoZSBjaGFubmVsc1xuXHQgKiB0byAwIChleGNlcHQgYWxwaGEsIHdoaWNoIGlzIHNldCB0byAxKSwgYW5kIHRoZW4gYWRkaW5nIDI1NSB0byB0aGUgYmx1ZSBjaGFubmVsLlxuXHQgKlxuXHQgKiAgICAgIHZhciBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpLnNldCh7eDoxMDAseToxMDB9KTtcblx0ICogICAgICBzaGFwZS5ncmFwaGljcy5iZWdpbkZpbGwoXCIjZmYwMDAwXCIpLmRyYXdDaXJjbGUoMCwwLDUwKTtcblx0ICpcblx0ICogICAgICBzaGFwZS5maWx0ZXJzID0gW1xuXHQgKiAgICAgICAgICBuZXcgY3JlYXRlanMuQ29sb3JGaWx0ZXIoMCwwLDAsMSwgMCwwLDI1NSwwKVxuXHQgKiAgICAgIF07XG5cdCAqICAgICAgc2hhcGUuY2FjaGUoLTUwLCAtNTAsIDEwMCwgMTAwKTtcblx0ICpcblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkZpbHRlclwifX17ey9jcm9zc0xpbmt9fSBmb3IgYW4gbW9yZSBpbmZvcm1hdGlvbiBvbiBhcHBseWluZyBmaWx0ZXJzLlxuXHQgKiBAY2xhc3MgQ29sb3JGaWx0ZXJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtyZWRNdWx0aXBsaWVyPTFdIFRoZSBhbW91bnQgdG8gbXVsdGlwbHkgYWdhaW5zdCB0aGUgcmVkIGNoYW5uZWwuIFRoaXMgaXMgYSByYW5nZSBiZXR3ZWVuIDAgYW5kIDEuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZ3JlZW5NdWx0aXBsaWVyPTFdIFRoZSBhbW91bnQgdG8gbXVsdGlwbHkgYWdhaW5zdCB0aGUgZ3JlZW4gY2hhbm5lbC4gVGhpcyBpcyBhIHJhbmdlIGJldHdlZW4gMCBhbmQgMS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtibHVlTXVsdGlwbGllcj0xXSBUaGUgYW1vdW50IHRvIG11bHRpcGx5IGFnYWluc3QgdGhlIGJsdWUgY2hhbm5lbC4gVGhpcyBpcyBhIHJhbmdlIGJldHdlZW4gMCBhbmQgMS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthbHBoYU11bHRpcGxpZXI9MV0gVGhlIGFtb3VudCB0byBtdWx0aXBseSBhZ2FpbnN0IHRoZSBhbHBoYSBjaGFubmVsLiBUaGlzIGlzIGEgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3JlZE9mZnNldD0wXSBUaGUgYW1vdW50IHRvIGFkZCB0byB0aGUgcmVkIGNoYW5uZWwgYWZ0ZXIgaXQgaGFzIGJlZW4gbXVsdGlwbGllZC4gVGhpcyBpcyBhIHJhbmdlXG5cdCAqIGJldHdlZW4gLTI1NSBhbmQgMjU1LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2dyZWVuT2Zmc2V0PTBdIFRoZSBhbW91bnQgdG8gYWRkIHRvIHRoZSBncmVlbiBjaGFubmVsIGFmdGVyIGl0IGhhcyBiZWVuIG11bHRpcGxpZWQuIFRoaXMgaXMgYSByYW5nZVxuXHQgICogYmV0d2VlbiAtMjU1IGFuZCAyNTUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYmx1ZU9mZnNldD0wXSBUaGUgYW1vdW50IHRvIGFkZCB0byB0aGUgYmx1ZSBjaGFubmVsIGFmdGVyIGl0IGhhcyBiZWVuIG11bHRpcGxpZWQuIFRoaXMgaXMgYSByYW5nZVxuXHQgICogYmV0d2VlbiAtMjU1IGFuZCAyNTUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYWxwaGFPZmZzZXQ9MF0gVGhlIGFtb3VudCB0byBhZGQgdG8gdGhlIGFscGhhIGNoYW5uZWwgYWZ0ZXIgaXQgaGFzIGJlZW4gbXVsdGlwbGllZC4gVGhpcyBpcyBhIHJhbmdlXG5cdCAgKiBiZXR3ZWVuIC0yNTUgYW5kIDI1NS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBleHRlbmRzIEZpbHRlclxuXHQgKiovXG5cdGZ1bmN0aW9uIENvbG9yRmlsdGVyKHJlZE11bHRpcGxpZXIsIGdyZWVuTXVsdGlwbGllciwgYmx1ZU11bHRpcGxpZXIsIGFscGhhTXVsdGlwbGllciwgcmVkT2Zmc2V0LCBncmVlbk9mZnNldCwgYmx1ZU9mZnNldCwgYWxwaGFPZmZzZXQpIHtcblx0XHRcblx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFJlZCBjaGFubmVsIG11bHRpcGxpZXIuXG5cdFx0ICogQHByb3BlcnR5IHJlZE11bHRpcGxpZXJcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5yZWRNdWx0aXBsaWVyID0gcmVkTXVsdGlwbGllciAhPSBudWxsID8gcmVkTXVsdGlwbGllciA6IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEdyZWVuIGNoYW5uZWwgbXVsdGlwbGllci5cblx0XHQgKiBAcHJvcGVydHkgZ3JlZW5NdWx0aXBsaWVyXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuZ3JlZW5NdWx0aXBsaWVyID0gZ3JlZW5NdWx0aXBsaWVyICE9IG51bGwgPyBncmVlbk11bHRpcGxpZXIgOiAxO1xuXHRcblx0XHQvKipcblx0XHQgKiBCbHVlIGNoYW5uZWwgbXVsdGlwbGllci5cblx0XHQgKiBAcHJvcGVydHkgYmx1ZU11bHRpcGxpZXJcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5ibHVlTXVsdGlwbGllciA9IGJsdWVNdWx0aXBsaWVyICE9IG51bGwgPyBibHVlTXVsdGlwbGllciA6IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFscGhhIGNoYW5uZWwgbXVsdGlwbGllci5cblx0XHQgKiBAcHJvcGVydHkgYWxwaGFNdWx0aXBsaWVyXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuYWxwaGFNdWx0aXBsaWVyID0gYWxwaGFNdWx0aXBsaWVyICE9IG51bGwgPyBhbHBoYU11bHRpcGxpZXIgOiAxO1xuXHRcblx0XHQvKipcblx0XHQgKiBSZWQgY2hhbm5lbCBvZmZzZXQgKGFkZGVkIHRvIHZhbHVlKS5cblx0XHQgKiBAcHJvcGVydHkgcmVkT2Zmc2V0XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMucmVkT2Zmc2V0ID0gcmVkT2Zmc2V0IHx8IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEdyZWVuIGNoYW5uZWwgb2Zmc2V0IChhZGRlZCB0byB2YWx1ZSkuXG5cdFx0ICogQHByb3BlcnR5IGdyZWVuT2Zmc2V0XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuZ3JlZW5PZmZzZXQgPSBncmVlbk9mZnNldCB8fCAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBCbHVlIGNoYW5uZWwgb2Zmc2V0IChhZGRlZCB0byB2YWx1ZSkuXG5cdFx0ICogQHByb3BlcnR5IGJsdWVPZmZzZXRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5ibHVlT2Zmc2V0ID0gYmx1ZU9mZnNldCB8fCAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBBbHBoYSBjaGFubmVsIG9mZnNldCAoYWRkZWQgdG8gdmFsdWUpLlxuXHRcdCAqIEBwcm9wZXJ0eSBhbHBoYU9mZnNldFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmFscGhhT2Zmc2V0ID0gYWxwaGFPZmZzZXQgfHwgMDtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChDb2xvckZpbHRlciwgY3JlYXRlanMuRmlsdGVyKTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltDb2xvckZpbHRlcl1cIjtcblx0fTtcblxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvckZpbHRlcih0aGlzLnJlZE11bHRpcGxpZXIsIHRoaXMuZ3JlZW5NdWx0aXBsaWVyLCB0aGlzLmJsdWVNdWx0aXBsaWVyLCB0aGlzLmFscGhhTXVsdGlwbGllciwgdGhpcy5yZWRPZmZzZXQsIHRoaXMuZ3JlZW5PZmZzZXQsIHRoaXMuYmx1ZU9mZnNldCwgdGhpcy5hbHBoYU9mZnNldCk7XG5cdH07XG5cdFxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuX2FwcGx5RmlsdGVyID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG5cdFx0dmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblx0XHR2YXIgbCA9IGRhdGEubGVuZ3RoO1xuXHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKz00KSB7XG5cdFx0XHRkYXRhW2ldID0gZGF0YVtpXSp0aGlzLnJlZE11bHRpcGxpZXIrdGhpcy5yZWRPZmZzZXQ7XG5cdFx0XHRkYXRhW2krMV0gPSBkYXRhW2krMV0qdGhpcy5ncmVlbk11bHRpcGxpZXIrdGhpcy5ncmVlbk9mZnNldDtcblx0XHRcdGRhdGFbaSsyXSA9IGRhdGFbaSsyXSp0aGlzLmJsdWVNdWx0aXBsaWVyK3RoaXMuYmx1ZU9mZnNldDtcblx0XHRcdGRhdGFbaSszXSA9IGRhdGFbaSszXSp0aGlzLmFscGhhTXVsdGlwbGllcit0aGlzLmFscGhhT2Zmc2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLkNvbG9yRmlsdGVyID0gY3JlYXRlanMucHJvbW90ZShDb2xvckZpbHRlciwgXCJGaWx0ZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQ29sb3JNYXRyaXguanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgZm9yIGFzc2VtYmxpbmcgYSBtYXRyaXggZm9yIHVzZSB3aXRoIHRoZSB7eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeEZpbHRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogTW9zdCBtZXRob2RzIHJldHVybiB0aGUgaW5zdGFuY2UgdG8gZmFjaWxpdGF0ZSBjaGFpbmVkIGNhbGxzLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgbXlDb2xvck1hdHJpeC5hZGp1c3RIdWUoMjApLmFkanVzdEJyaWdodG5lc3MoNTApO1xuXHQgKlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhbiBleGFtcGxlIG9mIGhvdyB0byBhcHBseSBmaWx0ZXJzLCBvciB7eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeEZpbHRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgYW4gZXhhbXBsZSBvZiBob3cgdG8gdXNlIENvbG9yTWF0cml4IHRvIGNoYW5nZSBhIERpc3BsYXlPYmplY3QncyBjb2xvci5cblx0ICogQGNsYXNzIENvbG9yTWF0cml4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBicmlnaHRuZXNzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb250cmFzdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gaHVlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIENvbG9yTWF0cml4KGJyaWdodG5lc3MsIGNvbnRyYXN0LCBzYXR1cmF0aW9uLCBodWUpIHtcblx0XHR0aGlzLnNldENvbG9yKGJyaWdodG5lc3MsIGNvbnRyYXN0LCBzYXR1cmF0aW9uLCBodWUpO1xuXHR9XG5cdHZhciBwID0gQ29sb3JNYXRyaXgucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBjb25zdGFudHM6XG5cdC8qKlxuXHQgKiBBcnJheSBvZiBkZWx0YSB2YWx1ZXMgZm9yIGNvbnRyYXN0IGNhbGN1bGF0aW9ucy5cblx0ICogQHByb3BlcnR5IERFTFRBX0lOREVYXG5cdCAqIEB0eXBlIEFycmF5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdENvbG9yTWF0cml4LkRFTFRBX0lOREVYID0gW1xuXHRcdDAsICAgIDAuMDEsIDAuMDIsIDAuMDQsIDAuMDUsIDAuMDYsIDAuMDcsIDAuMDgsIDAuMSwgIDAuMTEsXG5cdFx0MC4xMiwgMC4xNCwgMC4xNSwgMC4xNiwgMC4xNywgMC4xOCwgMC4yMCwgMC4yMSwgMC4yMiwgMC4yNCxcblx0XHQwLjI1LCAwLjI3LCAwLjI4LCAwLjMwLCAwLjMyLCAwLjM0LCAwLjM2LCAwLjM4LCAwLjQwLCAwLjQyLFxuXHRcdDAuNDQsIDAuNDYsIDAuNDgsIDAuNSwgIDAuNTMsIDAuNTYsIDAuNTksIDAuNjIsIDAuNjUsIDAuNjgsXG5cdFx0MC43MSwgMC43NCwgMC43NywgMC44MCwgMC44MywgMC44NiwgMC44OSwgMC45MiwgMC45NSwgMC45OCxcblx0XHQxLjAsICAxLjA2LCAxLjEyLCAxLjE4LCAxLjI0LCAxLjMwLCAxLjM2LCAxLjQyLCAxLjQ4LCAxLjU0LFxuXHRcdDEuNjAsIDEuNjYsIDEuNzIsIDEuNzgsIDEuODQsIDEuOTAsIDEuOTYsIDIuMCwgIDIuMTIsIDIuMjUsXG5cdFx0Mi4zNywgMi41MCwgMi42MiwgMi43NSwgMi44NywgMy4wLCAgMy4yLCAgMy40LCAgMy42LCAgMy44LFxuXHRcdDQuMCwgIDQuMywgIDQuNywgIDQuOSwgIDUuMCwgIDUuNSwgIDYuMCwgIDYuNSwgIDYuOCwgIDcuMCxcblx0XHQ3LjMsICA3LjUsICA3LjgsICA4LjAsICA4LjQsICA4LjcsICA5LjAsICA5LjQsICA5LjYsICA5LjgsXG5cdFx0MTAuMFxuXHRdO1xuXG5cdC8qKlxuXHQgKiBJZGVudGl0eSBtYXRyaXggdmFsdWVzLlxuXHQgKiBAcHJvcGVydHkgSURFTlRJVFlfTUFUUklYXG5cdCAqIEB0eXBlIEFycmF5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdENvbG9yTWF0cml4LklERU5USVRZX01BVFJJWCA9IFtcblx0XHQxLDAsMCwwLDAsXG5cdFx0MCwxLDAsMCwwLFxuXHRcdDAsMCwxLDAsMCxcblx0XHQwLDAsMCwxLDAsXG5cdFx0MCwwLDAsMCwxXG5cdF07XG5cblx0LyoqXG5cdCAqIFRoZSBjb25zdGFudCBsZW5ndGggb2YgYSBjb2xvciBtYXRyaXguXG5cdCAqIEBwcm9wZXJ0eSBMRU5HVEhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdENvbG9yTWF0cml4LkxFTkdUSCA9IENvbG9yTWF0cml4LklERU5USVRZX01BVFJJWC5sZW5ndGg7XG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXNldHMgdGhlIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZXMuXG5cdCAqIEBtZXRob2Qgc2V0Q29sb3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGJyaWdodG5lc3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvbnRyYXN0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzYXR1cmF0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBodWVcblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHAuc2V0Q29sb3IgPSBmdW5jdGlvbihicmlnaHRuZXNzLGNvbnRyYXN0LHNhdHVyYXRpb24saHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVzZXQoKS5hZGp1c3RDb2xvcihicmlnaHRuZXNzLGNvbnRyYXN0LHNhdHVyYXRpb24saHVlKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVzZXRzIHRoZSBtYXRyaXggdG8gaWRlbnRpdHkgdmFsdWVzLlxuXHQgKiBAbWV0aG9kIHJlc2V0XG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRwLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29weShDb2xvck1hdHJpeC5JREVOVElUWV9NQVRSSVgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCBtZXRob2QgdG8gYWRqdXN0IGJyaWdodG5lc3MsIGNvbnRyYXN0LCBzYXR1cmF0aW9uIGFuZCBodWUuXG5cdCAqIEVxdWl2YWxlbnQgdG8gY2FsbGluZyBhZGp1c3RIdWUoaHVlKSwgYWRqdXN0Q29udHJhc3QoY29udHJhc3QpLFxuXHQgKiBhZGp1c3RCcmlnaHRuZXNzKGJyaWdodG5lc3MpLCBhZGp1c3RTYXR1cmF0aW9uKHNhdHVyYXRpb24pLCBpbiB0aGF0IG9yZGVyLlxuXHQgKiBAbWV0aG9kIGFkanVzdENvbG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBicmlnaHRuZXNzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb250cmFzdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gaHVlXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hZGp1c3RDb2xvciA9IGZ1bmN0aW9uKGJyaWdodG5lc3MsY29udHJhc3Qsc2F0dXJhdGlvbixodWUpIHtcblx0XHR0aGlzLmFkanVzdEh1ZShodWUpO1xuXHRcdHRoaXMuYWRqdXN0Q29udHJhc3QoY29udHJhc3QpO1xuXHRcdHRoaXMuYWRqdXN0QnJpZ2h0bmVzcyhicmlnaHRuZXNzKTtcblx0XHRyZXR1cm4gdGhpcy5hZGp1c3RTYXR1cmF0aW9uKHNhdHVyYXRpb24pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGp1c3RzIHRoZSBicmlnaHRuZXNzIG9mIHBpeGVsIGNvbG9yIGJ5IGFkZGluZyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIHRoZSByZWQsIGdyZWVuIGFuZCBibHVlIGNoYW5uZWxzLlxuXHQgKiBQb3NpdGl2ZSB2YWx1ZXMgd2lsbCBtYWtlIHRoZSBpbWFnZSBicmlnaHRlciwgbmVnYXRpdmUgdmFsdWVzIHdpbGwgbWFrZSBpdCBkYXJrZXIuXG5cdCAqIEBtZXRob2QgYWRqdXN0QnJpZ2h0bmVzc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgQSB2YWx1ZSBiZXR3ZWVuIC0yNTUgJiAyNTUgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBSR0IgY2hhbm5lbHMuXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hZGp1c3RCcmlnaHRuZXNzID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT0gMCB8fCBpc05hTih2YWx1ZSkpIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR2YWx1ZSA9IHRoaXMuX2NsZWFuVmFsdWUodmFsdWUsMjU1KTtcblx0XHR0aGlzLl9tdWx0aXBseU1hdHJpeChbXG5cdFx0XHQxLDAsMCwwLHZhbHVlLFxuXHRcdFx0MCwxLDAsMCx2YWx1ZSxcblx0XHRcdDAsMCwxLDAsdmFsdWUsXG5cdFx0XHQwLDAsMCwxLDAsXG5cdFx0XHQwLDAsMCwwLDFcblx0XHRdKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQWRqdXN0cyB0aGUgY29udHJhc3Qgb2YgcGl4ZWwgY29sb3IuXG5cdCAqIFBvc2l0aXZlIHZhbHVlcyB3aWxsIGluY3JlYXNlIGNvbnRyYXN0LCBuZWdhdGl2ZSB2YWx1ZXMgd2lsbCBkZWNyZWFzZSBjb250cmFzdC5cblx0ICogQG1ldGhvZCBhZGp1c3RDb250cmFzdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgQSB2YWx1ZSBiZXR3ZWVuIC0xMDAgJiAxMDAuXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hZGp1c3RDb250cmFzdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09IDAgfHwgaXNOYU4odmFsdWUpKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dmFsdWUgPSB0aGlzLl9jbGVhblZhbHVlKHZhbHVlLDEwMCk7XG5cdFx0dmFyIHg7XG5cdFx0aWYgKHZhbHVlPDApIHtcblx0XHRcdHggPSAxMjcrdmFsdWUvMTAwKjEyNztcblx0XHR9IGVsc2Uge1xuXHRcdFx0eCA9IHZhbHVlJTE7XG5cdFx0XHRpZiAoeCA9PSAwKSB7XG5cdFx0XHRcdHggPSBDb2xvck1hdHJpeC5ERUxUQV9JTkRFWFt2YWx1ZV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR4ID0gQ29sb3JNYXRyaXguREVMVEFfSU5ERVhbKHZhbHVlPDwwKV0qKDEteCkrQ29sb3JNYXRyaXguREVMVEFfSU5ERVhbKHZhbHVlPDwwKSsxXSp4OyAvLyB1c2UgbGluZWFyIGludGVycG9sYXRpb24gZm9yIG1vcmUgZ3JhbnVsYXJpdHkuXG5cdFx0XHR9XG5cdFx0XHR4ID0geCoxMjcrMTI3O1xuXHRcdH1cblx0XHR0aGlzLl9tdWx0aXBseU1hdHJpeChbXG5cdFx0XHR4LzEyNywwLDAsMCwwLjUqKDEyNy14KSxcblx0XHRcdDAseC8xMjcsMCwwLDAuNSooMTI3LXgpLFxuXHRcdFx0MCwwLHgvMTI3LDAsMC41KigxMjcteCksXG5cdFx0XHQwLDAsMCwxLDAsXG5cdFx0XHQwLDAsMCwwLDFcblx0XHRdKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQWRqdXN0cyB0aGUgY29sb3Igc2F0dXJhdGlvbiBvZiB0aGUgcGl4ZWwuXG5cdCAqIFBvc2l0aXZlIHZhbHVlcyB3aWxsIGluY3JlYXNlIHNhdHVyYXRpb24sIG5lZ2F0aXZlIHZhbHVlcyB3aWxsIGRlY3JlYXNlIHNhdHVyYXRpb24gKHRyZW5kIHRvd2FyZHMgZ3JleXNjYWxlKS5cblx0ICogQG1ldGhvZCBhZGp1c3RTYXR1cmF0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBBIHZhbHVlIGJldHdlZW4gLTEwMCAmIDEwMC5cblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmFkanVzdFNhdHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PSAwIHx8IGlzTmFOKHZhbHVlKSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHZhbHVlID0gdGhpcy5fY2xlYW5WYWx1ZSh2YWx1ZSwxMDApO1xuXHRcdHZhciB4ID0gMSsoKHZhbHVlID4gMCkgPyAzKnZhbHVlLzEwMCA6IHZhbHVlLzEwMCk7XG5cdFx0dmFyIGx1bVIgPSAwLjMwODY7XG5cdFx0dmFyIGx1bUcgPSAwLjYwOTQ7XG5cdFx0dmFyIGx1bUIgPSAwLjA4MjA7XG5cdFx0dGhpcy5fbXVsdGlwbHlNYXRyaXgoW1xuXHRcdFx0bHVtUiooMS14KSt4LGx1bUcqKDEteCksbHVtQiooMS14KSwwLDAsXG5cdFx0XHRsdW1SKigxLXgpLGx1bUcqKDEteCkreCxsdW1CKigxLXgpLDAsMCxcblx0XHRcdGx1bVIqKDEteCksbHVtRyooMS14KSxsdW1CKigxLXgpK3gsMCwwLFxuXHRcdFx0MCwwLDAsMSwwLFxuXHRcdFx0MCwwLDAsMCwxXG5cdFx0XSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblxuXHQvKipcblx0ICogQWRqdXN0cyB0aGUgaHVlIG9mIHRoZSBwaXhlbCBjb2xvci5cblx0ICogQG1ldGhvZCBhZGp1c3RIdWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIEEgdmFsdWUgYmV0d2VlbiAtMTgwICYgMTgwLlxuXHQgKiBAcmV0dXJuIHtDb2xvck1hdHJpeH0gVGhlIENvbG9yTWF0cml4IGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYWRqdXN0SHVlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT0gMCB8fCBpc05hTih2YWx1ZSkpIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR2YWx1ZSA9IHRoaXMuX2NsZWFuVmFsdWUodmFsdWUsMTgwKS8xODAqTWF0aC5QSTtcblx0XHR2YXIgY29zVmFsID0gTWF0aC5jb3ModmFsdWUpO1xuXHRcdHZhciBzaW5WYWwgPSBNYXRoLnNpbih2YWx1ZSk7XG5cdFx0dmFyIGx1bVIgPSAwLjIxMztcblx0XHR2YXIgbHVtRyA9IDAuNzE1O1xuXHRcdHZhciBsdW1CID0gMC4wNzI7XG5cdFx0dGhpcy5fbXVsdGlwbHlNYXRyaXgoW1xuXHRcdFx0bHVtUitjb3NWYWwqKDEtbHVtUikrc2luVmFsKigtbHVtUiksbHVtRytjb3NWYWwqKC1sdW1HKStzaW5WYWwqKC1sdW1HKSxsdW1CK2Nvc1ZhbCooLWx1bUIpK3NpblZhbCooMS1sdW1CKSwwLDAsXG5cdFx0XHRsdW1SK2Nvc1ZhbCooLWx1bVIpK3NpblZhbCooMC4xNDMpLGx1bUcrY29zVmFsKigxLWx1bUcpK3NpblZhbCooMC4xNDApLGx1bUIrY29zVmFsKigtbHVtQikrc2luVmFsKigtMC4yODMpLDAsMCxcblx0XHRcdGx1bVIrY29zVmFsKigtbHVtUikrc2luVmFsKigtKDEtbHVtUikpLGx1bUcrY29zVmFsKigtbHVtRykrc2luVmFsKihsdW1HKSxsdW1CK2Nvc1ZhbCooMS1sdW1CKStzaW5WYWwqKGx1bUIpLDAsMCxcblx0XHRcdDAsMCwwLDEsMCxcblx0XHRcdDAsMCwwLDAsMVxuXHRcdF0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb25jYXRlbmF0ZXMgKG11bHRpcGxpZXMpIHRoZSBzcGVjaWZpZWQgbWF0cml4IHdpdGggdGhpcyBvbmUuXG5cdCAqIEBtZXRob2QgY29uY2F0XG5cdCAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeCBBbiBhcnJheSBvciBDb2xvck1hdHJpeCBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmNvbmNhdCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdG1hdHJpeCA9IHRoaXMuX2ZpeE1hdHJpeChtYXRyaXgpO1xuXHRcdGlmIChtYXRyaXgubGVuZ3RoICE9IENvbG9yTWF0cml4LkxFTkdUSCkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX211bHRpcGx5TWF0cml4KG1hdHJpeCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGlzIENvbG9yTWF0cml4LlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBBIGNsb25lIG9mIHRoaXMgQ29sb3JNYXRyaXguXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAobmV3IENvbG9yTWF0cml4KCkpLmNvcHkodGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybiBhIGxlbmd0aCAyNSAoNXg1KSBhcnJheSBpbnN0YW5jZSBjb250YWluaW5nIHRoaXMgbWF0cml4J3MgdmFsdWVzLlxuXHQgKiBAbWV0aG9kIHRvQXJyYXlcblx0ICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IGhvbGRpbmcgdGhpcyBtYXRyaXgncyB2YWx1ZXMuXG5cdCAqKi9cblx0cC50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyciA9IFtdO1xuXHRcdGZvciAodmFyIGk9IDAsIGw9Q29sb3JNYXRyaXguTEVOR1RIOyBpPGw7IGkrKykge1xuXHRcdFx0YXJyW2ldID0gdGhpc1tpXTtcblx0XHR9XG5cdFx0cmV0dXJuIGFycjtcblx0fTtcblxuXHQvKipcblx0ICogQ29weSB0aGUgc3BlY2lmaWVkIG1hdHJpeCdzIHZhbHVlcyB0byB0aGlzIG1hdHJpeC5cblx0ICogQG1ldGhvZCBjb3B5XG5cdCAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeCBBbiBhcnJheSBvciBDb2xvck1hdHJpeCBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmNvcHkgPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR2YXIgbCA9IENvbG9yTWF0cml4LkxFTkdUSDtcblx0XHRmb3IgKHZhciBpPTA7aTxsO2krKykge1xuXHRcdFx0dGhpc1tpXSA9IG1hdHJpeFtpXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0NvbG9yTWF0cml4XVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX211bHRpcGx5TWF0cml4XG5cdCAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fbXVsdGlwbHlNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR2YXIgaSwgaiwgaywgY29sID0gW107XG5cblx0XHRmb3IgKGk9MDtpPDU7aSsrKSB7XG5cdFx0XHRmb3IgKGo9MDtqPDU7aisrKSB7XG5cdFx0XHRcdGNvbFtqXSA9IHRoaXNbaitpKjVdO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChqPTA7ajw1O2orKykge1xuXHRcdFx0XHR2YXIgdmFsPTA7XG5cdFx0XHRcdGZvciAoaz0wO2s8NTtrKyspIHtcblx0XHRcdFx0XHR2YWwgKz0gbWF0cml4W2orayo1XSpjb2xba107XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpc1tqK2kqNV0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBNYWtlIHN1cmUgdmFsdWVzIGFyZSB3aXRoaW4gdGhlIHNwZWNpZmllZCByYW5nZSwgaHVlIGhhcyBhIGxpbWl0IG9mIDE4MCwgYnJpZ2h0bmVzcyBpcyAyNTUsIG90aGVycyBhcmUgMTAwLlxuXHQgKiBAbWV0aG9kIF9jbGVhblZhbHVlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgcmF3IG51bWJlclxuXHQgKiBAcGFyYW0ge051bWJlcn0gbGltaXQgVGhlIG1heGltdW0gdGhhdCB0aGUgbnVtYmVyIGNhbiBiZS4gVGhlIG1pbmltdW0gaXMgdGhlIGxpbWl0ICogLTEuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9jbGVhblZhbHVlID0gZnVuY3Rpb24odmFsdWUsIGxpbWl0KSB7XG5cdFx0cmV0dXJuIE1hdGgubWluKGxpbWl0LE1hdGgubWF4KC1saW1pdCx2YWx1ZSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBNYWtlcyBzdXJlIG1hdHJpeGVzIGFyZSA1eDUgKDI1IGxvbmcpLlxuXHQgKiBAbWV0aG9kIF9maXhNYXRyaXhcblx0ICogQHBhcmFtIHtBcnJheX0gbWF0cml4XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9maXhNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRpZiAobWF0cml4IGluc3RhbmNlb2YgQ29sb3JNYXRyaXgpIHsgbWF0cml4ID0gbWF0cml4LnRvQXJyYXkoKTsgfVxuXHRcdGlmIChtYXRyaXgubGVuZ3RoIDwgQ29sb3JNYXRyaXguTEVOR1RIKSB7XG5cdFx0XHRtYXRyaXggPSBtYXRyaXguc2xpY2UoMCxtYXRyaXgubGVuZ3RoKS5jb25jYXQoQ29sb3JNYXRyaXguSURFTlRJVFlfTUFUUklYLnNsaWNlKG1hdHJpeC5sZW5ndGgsQ29sb3JNYXRyaXguTEVOR1RIKSk7XG5cdFx0fSBlbHNlIGlmIChtYXRyaXgubGVuZ3RoID4gQ29sb3JNYXRyaXguTEVOR1RIKSB7XG5cdFx0XHRtYXRyaXggPSBtYXRyaXguc2xpY2UoMCxDb2xvck1hdHJpeC5MRU5HVEgpO1xuXHRcdH1cblx0XHRyZXR1cm4gbWF0cml4O1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuQ29sb3JNYXRyaXggPSBDb2xvck1hdHJpeDtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBDb2xvck1hdHJpeEZpbHRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQWxsb3dzIHlvdSB0byBjYXJyeSBvdXQgY29tcGxleCBjb2xvciBvcGVyYXRpb25zIHN1Y2ggYXMgbW9kaWZ5aW5nIHNhdHVyYXRpb24sIGJyaWdodG5lc3MsIG9yIGludmVydGluZy4gU2VlIHRoZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBjaGFuZ2luZyBjb2xvcnMuIEZvciBhbiBlYXNpZXIgY29sb3IgdHJhbnNmb3JtLFxuXHQgKiBjb25zaWRlciB0aGUge3sjY3Jvc3NMaW5rIFwiQ29sb3JGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogVGhpcyBleGFtcGxlIGNyZWF0ZXMgYSByZWQgY2lyY2xlLCBpbnZlcnRzIGl0cyBodWUsIGFuZCB0aGVuIHNhdHVyYXRlcyBpdCB0byBicmlnaHRlbiBpdCB1cC5cblx0ICpcblx0ICogICAgICB2YXIgc2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKS5zZXQoe3g6MTAwLHk6MTAwfSk7XG5cdCAqICAgICAgc2hhcGUuZ3JhcGhpY3MuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3Q2lyY2xlKDAsMCw1MCk7XG5cdCAqXG5cdCAqICAgICAgdmFyIG1hdHJpeCA9IG5ldyBjcmVhdGVqcy5Db2xvck1hdHJpeCgpLmFkanVzdEh1ZSgxODApLmFkanVzdFNhdHVyYXRpb24oMTAwKTtcblx0ICogICAgICBzaGFwZS5maWx0ZXJzID0gW1xuXHQgKiAgICAgICAgICBuZXcgY3JlYXRlanMuQ29sb3JNYXRyaXhGaWx0ZXIobWF0cml4KVxuXHQgKiAgICAgIF07XG5cdCAqXG5cdCAqICAgICAgc2hhcGUuY2FjaGUoLTUwLCAtNTAsIDEwMCwgMTAwKTtcblx0ICpcblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkZpbHRlclwifX17ey9jcm9zc0xpbmt9fSBmb3IgYW4gbW9yZSBpbmZvcm1hdGlvbiBvbiBhcHBseWluZyBmaWx0ZXJzLlxuXHQgKiBAY2xhc3MgQ29sb3JNYXRyaXhGaWx0ZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBleHRlbmRzIEZpbHRlclxuXHQgKiBAcGFyYW0ge0FycmF5IHwgQ29sb3JNYXRyaXh9IG1hdHJpeCBBIDR4NSBtYXRyaXggZGVzY3JpYmluZyB0aGUgY29sb3Igb3BlcmF0aW9uIHRvIHBlcmZvcm0uIFNlZSBhbHNvIHRoZSB7eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBjbGFzcy5cblx0ICoqL1xuXHRmdW5jdGlvbiBDb2xvck1hdHJpeEZpbHRlcihtYXRyaXgpIHtcblx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEEgNHg1IG1hdHJpeCBkZXNjcmliaW5nIHRoZSBjb2xvciBvcGVyYXRpb24gdG8gcGVyZm9ybS4gU2VlIGFsc28gdGhlIHt7I2Nyb3NzTGluayBcIkNvbG9yTWF0cml4XCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogQHByb3BlcnR5IG1hdHJpeFxuXHRcdCAqIEB0eXBlIEFycmF5IHwgQ29sb3JNYXRyaXhcblx0XHQgKiovXG5cdFx0dGhpcy5tYXRyaXggPSBtYXRyaXg7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQ29sb3JNYXRyaXhGaWx0ZXIsIGNyZWF0ZWpzLkZpbHRlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cdFxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltDb2xvck1hdHJpeEZpbHRlcl1cIjtcblx0fTtcblxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvck1hdHJpeEZpbHRlcih0aGlzLm1hdHJpeCk7XG5cdH07XG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5fYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbihpbWFnZURhdGEpIHsgXG5cdFx0dmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblx0XHR2YXIgbCA9IGRhdGEubGVuZ3RoO1xuXHRcdHZhciByLGcsYixhO1xuXHRcdHZhciBtdHggPSB0aGlzLm1hdHJpeDtcblx0XHR2YXIgbTAgPSAgbXR4WzBdLCAgbTEgPSAgbXR4WzFdLCAgbTIgPSAgbXR4WzJdLCAgbTMgPSAgbXR4WzNdLCAgbTQgPSAgbXR4WzRdO1xuXHRcdHZhciBtNSA9ICBtdHhbNV0sICBtNiA9ICBtdHhbNl0sICBtNyA9ICBtdHhbN10sICBtOCA9ICBtdHhbOF0sICBtOSA9ICBtdHhbOV07XG5cdFx0dmFyIG0xMCA9IG10eFsxMF0sIG0xMSA9IG10eFsxMV0sIG0xMiA9IG10eFsxMl0sIG0xMyA9IG10eFsxM10sIG0xNCA9IG10eFsxNF07XG5cdFx0dmFyIG0xNSA9IG10eFsxNV0sIG0xNiA9IG10eFsxNl0sIG0xNyA9IG10eFsxN10sIG0xOCA9IG10eFsxOF0sIG0xOSA9IG10eFsxOV07XG5cblx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSs9NCkge1xuXHRcdFx0ciA9IGRhdGFbaV07XG5cdFx0XHRnID0gZGF0YVtpKzFdO1xuXHRcdFx0YiA9IGRhdGFbaSsyXTtcblx0XHRcdGEgPSBkYXRhW2krM107XG5cdFx0XHRkYXRhW2ldID0gciptMCtnKm0xK2IqbTIrYSptMyttNDsgLy8gcmVkXG5cdFx0XHRkYXRhW2krMV0gPSByKm01K2cqbTYrYiptNythKm04K205OyAvLyBncmVlblxuXHRcdFx0ZGF0YVtpKzJdID0gciptMTArZyptMTErYiptMTIrYSptMTMrbTE0OyAvLyBibHVlXG5cdFx0XHRkYXRhW2krM10gPSByKm0xNStnKm0xNitiKm0xNythKm0xOCttMTk7IC8vIGFscGhhXG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuQ29sb3JNYXRyaXhGaWx0ZXIgPSBjcmVhdGVqcy5wcm9tb3RlKENvbG9yTWF0cml4RmlsdGVyLCBcIkZpbHRlclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUb3VjaC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcbiAqIEdsb2JhbCB1dGlsaXR5IGZvciB3b3JraW5nIHdpdGggbXVsdGktdG91Y2ggZW5hYmxlZCBkZXZpY2VzIGluIEVhc2VsSlMuIEN1cnJlbnRseSBzdXBwb3J0cyBXM0MgVG91Y2ggQVBJIChpT1MgYW5kXG4gKiBtb2Rlcm4gQW5kcm9pZCBicm93c2VyKSBhbmQgdGhlIFBvaW50ZXIgQVBJIChJRSksIGluY2x1ZGluZyBtcy1wcmVmaXhlZCBldmVudHMgaW4gSUUxMCwgYW5kIHVucHJlZml4ZWQgaW4gSUUxMS5cbiAqXG4gKiBFbnN1cmUgdGhhdCB5b3Uge3sjY3Jvc3NMaW5rIFwiVG91Y2gvZGlzYWJsZVwifX17ey9jcm9zc0xpbmt9fSB0b3VjaCB3aGVuIGNsZWFuaW5nIHVwIHlvdXIgYXBwbGljYXRpb24uIFlvdSBkbyBub3QgaGF2ZVxuICogdG8gY2hlY2sgaWYgdG91Y2ggaXMgc3VwcG9ydGVkIHRvIGVuYWJsZSBpdCwgYXMgaXQgd2lsbCBmYWlsIGdyYWNlZnVsbHkgaWYgaXQgaXMgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiA8aDQ+RXhhbXBsZTwvaDQ+XG4gKlxuICogICAgICB2YXIgc3RhZ2UgPSBuZXcgY3JlYXRlanMuU3RhZ2UoXCJjYW52YXNJZFwiKTtcbiAqICAgICAgY3JlYXRlanMuVG91Y2guZW5hYmxlKHN0YWdlKTtcbiAqXG4gKiA8c3Ryb25nPk5vdGU6PC9zdHJvbmc+IEl0IGlzIGltcG9ydGFudCB0byBkaXNhYmxlIFRvdWNoIG9uIGEgc3RhZ2UgdGhhdCB5b3UgYXJlIG5vIGxvbmdlciB1c2luZzpcbiAqXG4gKiAgICAgIGNyZWF0ZWpzLlRvdWNoLmRpc2FibGUoc3RhZ2UpO1xuICpcbiAqIEBjbGFzcyBUb3VjaFxuICogQHN0YXRpY1xuICoqL1xuXHRmdW5jdGlvbiBUb3VjaCgpIHtcblx0XHR0aHJvdyBcIlRvdWNoIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWRcIjtcblx0fVxuXG5cbi8vIHB1YmxpYyBzdGF0aWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRvdWNoIGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBicm93c2VyLlxuXHQgKiBAbWV0aG9kIGlzU3VwcG9ydGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEluZGljYXRlcyB3aGV0aGVyIHRvdWNoIGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBicm93c2VyLlxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm5cdCEhKCgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIC8vIGlPUyAmIEFuZHJvaWRcblx0XHRcdHx8ICh3aW5kb3cubmF2aWdhdG9yWydtc1BvaW50ZXJFbmFibGVkJ10gJiYgd2luZG93Lm5hdmlnYXRvclsnbXNNYXhUb3VjaFBvaW50cyddID4gMCkgLy8gSUUxMFxuXHRcdFx0fHwgKHdpbmRvdy5uYXZpZ2F0b3JbJ3BvaW50ZXJFbmFibGVkJ10gJiYgd2luZG93Lm5hdmlnYXRvclsnbWF4VG91Y2hQb2ludHMnXSA+IDApKTsgLy8gSUUxMStcblx0fTtcblxuXHQvKipcblx0ICogRW5hYmxlcyB0b3VjaCBpbnRlcmFjdGlvbiBmb3IgdGhlIHNwZWNpZmllZCBFYXNlbEpTIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319LiBDdXJyZW50bHkgc3VwcG9ydHMgaU9TXG5cdCAqIChhbmQgY29tcGF0aWJsZSBicm93c2Vycywgc3VjaCBhcyBtb2Rlcm4gQW5kcm9pZCBicm93c2VycyksIGFuZCBJRTEwLzExLiBTdXBwb3J0cyBib3RoIHNpbmdsZSB0b3VjaCBhbmRcblx0ICogbXVsdGktdG91Y2ggbW9kZXMuIEV4dGVuZHMgdGhlIEVhc2VsSlMge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBtb2RlbCwgYnV0IHdpdGhvdXQgc3VwcG9ydCBmb3Jcblx0ICogZG91YmxlIGNsaWNrIG9yIG92ZXIvb3V0IGV2ZW50cy4gU2VlIHRoZSBNb3VzZUV2ZW50IHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnQvcG9pbnRlcklkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIGVuYWJsZVxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZSBUaGUge3sjY3Jvc3NMaW5rIFwiU3RhZ2VcIn19e3svY3Jvc3NMaW5rfX0gdG8gZW5hYmxlIHRvdWNoIG9uLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaW5nbGVUb3VjaD1mYWxzZV0gSWYgYHRydWVgLCBvbmx5IGEgc2luZ2xlIHRvdWNoIHdpbGwgYmUgYWN0aXZlIGF0IGEgdGltZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbYWxsb3dEZWZhdWx0PWZhbHNlXSBJZiBgdHJ1ZWAsIHRoZW4gZGVmYXVsdCBnZXN0dXJlIGFjdGlvbnMgKGV4LiBzY3JvbGxpbmcsIHpvb21pbmcpIHdpbGwgYmVcblx0ICogYWxsb3dlZCB3aGVuIHRoZSB1c2VyIGlzIGludGVyYWN0aW5nIHdpdGggdGhlIHRhcmdldCBjYW52YXMuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRvdWNoIHdhcyBzdWNjZXNzZnVsbHkgZW5hYmxlZCBvbiB0aGUgdGFyZ2V0IHN0YWdlLlxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guZW5hYmxlID0gZnVuY3Rpb24oc3RhZ2UsIHNpbmdsZVRvdWNoLCBhbGxvd0RlZmF1bHQpIHtcblx0XHRpZiAoIXN0YWdlIHx8ICFzdGFnZS5jYW52YXMgfHwgIVRvdWNoLmlzU3VwcG9ydGVkKCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHN0YWdlLl9fdG91Y2gpIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdC8vIGluamVjdCByZXF1aXJlZCBwcm9wZXJ0aWVzIG9uIHN0YWdlOlxuXHRcdHN0YWdlLl9fdG91Y2ggPSB7cG9pbnRlcnM6e30sIG11bHRpdG91Y2g6IXNpbmdsZVRvdWNoLCBwcmV2ZW50RGVmYXVsdDohYWxsb3dEZWZhdWx0LCBjb3VudDowfTtcblxuXHRcdC8vIG5vdGUgdGhhdCBpbiB0aGUgZnV0dXJlIHdlIG1heSBuZWVkIHRvIGRpc2FibGUgdGhlIHN0YW5kYXJkIG1vdXNlIGV2ZW50IG1vZGVsIGJlZm9yZSBhZGRpbmdcblx0XHQvLyB0aGVzZSB0byBwcmV2ZW50IGR1cGxpY2F0ZSBjYWxscy4gSXQgZG9lc24ndCBzZWVtIHRvIGJlIGFuIGlzc3VlIHdpdGggaU9TIGRldmljZXMgdGhvdWdoLlxuXHRcdGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHsgVG91Y2guX0lPU19lbmFibGUoc3RhZ2UpOyB9XG5cdFx0ZWxzZSBpZiAod2luZG93Lm5hdmlnYXRvclsnbXNQb2ludGVyRW5hYmxlZCddIHx8IHdpbmRvdy5uYXZpZ2F0b3JbXCJwb2ludGVyRW5hYmxlZFwiXSkgeyBUb3VjaC5fSUVfZW5hYmxlKHN0YWdlKTsgfVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIHNldCB1cCB3aGVuIGNhbGxpbmcgYFRvdWNoLmVuYWJsZSgpYCBvbiBhIHN0YWdlLlxuXHQgKiBAbWV0aG9kIGRpc2FibGVcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2UgVGhlIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319IHRvIGRpc2FibGUgdG91Y2ggb24uXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5kaXNhYmxlID0gZnVuY3Rpb24oc3RhZ2UpIHtcblx0XHRpZiAoIXN0YWdlKSB7IHJldHVybjsgfVxuXHRcdGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHsgVG91Y2guX0lPU19kaXNhYmxlKHN0YWdlKTsgfVxuXHRcdGVsc2UgaWYgKHdpbmRvdy5uYXZpZ2F0b3JbJ21zUG9pbnRlckVuYWJsZWQnXSB8fCB3aW5kb3cubmF2aWdhdG9yW1wicG9pbnRlckVuYWJsZWRcIl0pIHsgVG91Y2guX0lFX2Rpc2FibGUoc3RhZ2UpOyB9XG5cdFx0XG5cdFx0ZGVsZXRlIHN0YWdlLl9fdG91Y2g7XG5cdH07XG5cblxuLy8gUHJpdmF0ZSBzdGF0aWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX0lPU19lbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guX0lPU19lbmFibGUgPSBmdW5jdGlvbihzdGFnZSkge1xuXHRcdHZhciBjYW52YXMgPSBzdGFnZS5jYW52YXM7XG5cdFx0dmFyIGYgPSBzdGFnZS5fX3RvdWNoLmYgPSBmdW5jdGlvbihlKSB7IFRvdWNoLl9JT1NfaGFuZGxlRXZlbnQoc3RhZ2UsZSk7IH07XG5cdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIGYsIGZhbHNlKTtcblx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBmLCBmYWxzZSk7XG5cdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBmLCBmYWxzZSk7XG5cdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCBmLCBmYWxzZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX0lPU19kaXNhYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2Vcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRvdWNoLl9JT1NfZGlzYWJsZSA9IGZ1bmN0aW9uKHN0YWdlKSB7XG5cdFx0dmFyIGNhbnZhcyA9IHN0YWdlLmNhbnZhcztcblx0XHRpZiAoIWNhbnZhcykgeyByZXR1cm47IH1cblx0XHR2YXIgZiA9IHN0YWdlLl9fdG91Y2guZjtcblx0XHRjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgZiwgZmFsc2UpO1xuXHRcdGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGYsIGZhbHNlKTtcblx0XHRjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGYsIGZhbHNlKTtcblx0XHRjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIGYsIGZhbHNlKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfSU9TX2hhbmRsZUV2ZW50XG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBldmVudCB0byBoYW5kbGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guX0lPU19oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKHN0YWdlLCBlKSB7XG5cdFx0aWYgKCFzdGFnZSkgeyByZXR1cm47IH1cblx0XHRpZiAoc3RhZ2UuX190b3VjaC5wcmV2ZW50RGVmYXVsdCkgeyBlLnByZXZlbnREZWZhdWx0JiZlLnByZXZlbnREZWZhdWx0KCk7IH1cblx0XHR2YXIgdG91Y2hlcyA9IGUuY2hhbmdlZFRvdWNoZXM7XG5cdFx0dmFyIHR5cGUgPSBlLnR5cGU7XG5cdFx0Zm9yICh2YXIgaT0gMCxsPXRvdWNoZXMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0dmFyIHRvdWNoID0gdG91Y2hlc1tpXTtcblx0XHRcdHZhciBpZCA9IHRvdWNoLmlkZW50aWZpZXI7XG5cdFx0XHRpZiAodG91Y2gudGFyZ2V0ICE9IHN0YWdlLmNhbnZhcykgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRpZiAodHlwZSA9PSBcInRvdWNoc3RhcnRcIikge1xuXHRcdFx0XHR0aGlzLl9oYW5kbGVTdGFydChzdGFnZSwgaWQsIGUsIHRvdWNoLnBhZ2VYLCB0b3VjaC5wYWdlWSk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT0gXCJ0b3VjaG1vdmVcIikge1xuXHRcdFx0XHR0aGlzLl9oYW5kbGVNb3ZlKHN0YWdlLCBpZCwgZSwgdG91Y2gucGFnZVgsIHRvdWNoLnBhZ2VZKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PSBcInRvdWNoZW5kXCIgfHwgdHlwZSA9PSBcInRvdWNoY2FuY2VsXCIpIHtcblx0XHRcdFx0dGhpcy5faGFuZGxlRW5kKHN0YWdlLCBpZCwgZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9JRV9lbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guX0lFX2VuYWJsZSA9IGZ1bmN0aW9uKHN0YWdlKSB7XG5cdFx0dmFyIGNhbnZhcyA9IHN0YWdlLmNhbnZhcztcblx0XHR2YXIgZiA9IHN0YWdlLl9fdG91Y2guZiA9IGZ1bmN0aW9uKGUpIHsgVG91Y2guX0lFX2hhbmRsZUV2ZW50KHN0YWdlLGUpOyB9O1xuXG5cdFx0aWYgKHdpbmRvdy5uYXZpZ2F0b3JbXCJwb2ludGVyRW5hYmxlZFwiXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlckRvd25cIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJNb3ZlXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyVXBcIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJDYW5jZWxcIiwgZiwgZmFsc2UpO1xuXHRcdFx0aWYgKHN0YWdlLl9fdG91Y2gucHJldmVudERlZmF1bHQpIHsgY2FudmFzLnN0eWxlLm1zVG91Y2hBY3Rpb24gPSBcIm5vbmVcIjsgfVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIGYsIGZhbHNlKTtcblx0XHRcdGlmIChzdGFnZS5fX3RvdWNoLnByZXZlbnREZWZhdWx0KSB7IGNhbnZhcy5zdHlsZS50b3VjaEFjdGlvbiA9IFwibm9uZVwiOyB9XG5cblx0XHR9XG5cdFx0c3RhZ2UuX190b3VjaC5hY3RpdmVJRHMgPSB7fTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfSUVfZGlzYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5fSUVfZGlzYWJsZSA9IGZ1bmN0aW9uKHN0YWdlKSB7XG5cdFx0dmFyIGYgPSBzdGFnZS5fX3RvdWNoLmY7XG5cblx0XHRpZiAod2luZG93Lm5hdmlnYXRvcltcInBvaW50ZXJFbmFibGVkXCJdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyTW92ZVwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlclVwXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyQ2FuY2VsXCIsIGYsIGZhbHNlKTtcblx0XHRcdGlmIChzdGFnZS5jYW52YXMpIHtcblx0XHRcdFx0c3RhZ2UuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJEb3duXCIsIGYsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIiwgZiwgZmFsc2UpO1xuXHRcdFx0aWYgKHN0YWdlLmNhbnZhcykge1xuXHRcdFx0XHRzdGFnZS5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGYsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX0lFX2hhbmRsZUV2ZW50XG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBldmVudCB0byBoYW5kbGUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRvdWNoLl9JRV9oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKHN0YWdlLCBlKSB7XG5cdFx0aWYgKCFzdGFnZSkgeyByZXR1cm47IH1cblx0XHRpZiAoc3RhZ2UuX190b3VjaC5wcmV2ZW50RGVmYXVsdCkgeyBlLnByZXZlbnREZWZhdWx0ICYmIGUucHJldmVudERlZmF1bHQoKTsgfVxuXHRcdHZhciB0eXBlID0gZS50eXBlO1xuXHRcdHZhciBpZCA9IGUucG9pbnRlcklkO1xuXHRcdHZhciBpZHMgPSBzdGFnZS5fX3RvdWNoLmFjdGl2ZUlEcztcblxuXHRcdGlmICh0eXBlID09IFwiTVNQb2ludGVyRG93blwiIHx8IHR5cGUgPT0gXCJwb2ludGVyZG93blwiKSB7XG5cdFx0XHRpZiAoZS5zcmNFbGVtZW50ICE9IHN0YWdlLmNhbnZhcykgeyByZXR1cm47IH1cblx0XHRcdGlkc1tpZF0gPSB0cnVlO1xuXHRcdFx0dGhpcy5faGFuZGxlU3RhcnQoc3RhZ2UsIGlkLCBlLCBlLnBhZ2VYLCBlLnBhZ2VZKTtcblx0XHR9IGVsc2UgaWYgKGlkc1tpZF0pIHsgLy8gaXQncyBhbiBpZCB3ZSdyZSB3YXRjaGluZ1xuXHRcdFx0aWYgKHR5cGUgPT0gXCJNU1BvaW50ZXJNb3ZlXCIgfHwgdHlwZSA9PSBcInBvaW50ZXJtb3ZlXCIpIHtcblx0XHRcdFx0dGhpcy5faGFuZGxlTW92ZShzdGFnZSwgaWQsIGUsIGUucGFnZVgsIGUucGFnZVkpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09IFwiTVNQb2ludGVyVXBcIiB8fCB0eXBlID09IFwiTVNQb2ludGVyQ2FuY2VsXCJcblx0XHRcdFx0XHR8fCB0eXBlID09IFwicG9pbnRlcnVwXCIgfHwgdHlwZSA9PSBcInBvaW50ZXJjYW5jZWxcIikge1xuXHRcdFx0XHRkZWxldGUoaWRzW2lkXSk7XG5cdFx0XHRcdHRoaXMuX2hhbmRsZUVuZChzdGFnZSwgaWQsIGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlU3RhcnRcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2Vcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VG91Y2guX2hhbmRsZVN0YXJ0ID0gZnVuY3Rpb24oc3RhZ2UsIGlkLCBlLCB4LCB5KSB7XG5cdFx0dmFyIHByb3BzID0gc3RhZ2UuX190b3VjaDtcblx0XHRpZiAoIXByb3BzLm11bHRpdG91Y2ggJiYgcHJvcHMuY291bnQpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIGlkcyA9IHByb3BzLnBvaW50ZXJzO1xuXHRcdGlmIChpZHNbaWRdKSB7IHJldHVybjsgfVxuXHRcdGlkc1tpZF0gPSB0cnVlO1xuXHRcdHByb3BzLmNvdW50Kys7XG5cdFx0c3RhZ2UuX2hhbmRsZVBvaW50ZXJEb3duKGlkLCBlLCB4LCB5KTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlTW92ZVxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGlkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUb3VjaC5faGFuZGxlTW92ZSA9IGZ1bmN0aW9uKHN0YWdlLCBpZCwgZSwgeCwgeSkge1xuXHRcdGlmICghc3RhZ2UuX190b3VjaC5wb2ludGVyc1tpZF0pIHsgcmV0dXJuOyB9XG5cdFx0c3RhZ2UuX2hhbmRsZVBvaW50ZXJNb3ZlKGlkLCBlLCB4LCB5KTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlRW5kXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gaWRcblx0ICogQHBhcmFtIHtPYmplY3R9IGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRvdWNoLl9oYW5kbGVFbmQgPSBmdW5jdGlvbihzdGFnZSwgaWQsIGUpIHtcblx0XHQvLyBUT0RPOiBjYW5jZWwgc2hvdWxkIGJlIGhhbmRsZWQgZGlmZmVyZW50bHkgZm9yIHByb3BlciBVSSAoZXguIGFuIHVwIHdvdWxkIHRyaWdnZXIgYSBjbGljaywgYSBjYW5jZWwgd291bGQgbW9yZSBjbG9zZWx5IHJlc2VtYmxlIGFuIG91dCkuXG5cdFx0dmFyIHByb3BzID0gc3RhZ2UuX190b3VjaDtcblx0XHR2YXIgaWRzID0gcHJvcHMucG9pbnRlcnM7XG5cdFx0aWYgKCFpZHNbaWRdKSB7IHJldHVybjsgfVxuXHRcdHByb3BzLmNvdW50LS07XG5cdFx0c3RhZ2UuX2hhbmRsZVBvaW50ZXJVcChpZCwgZSwgdHJ1ZSk7XG5cdFx0ZGVsZXRlKGlkc1tpZF0pO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuVG91Y2ggPSBUb3VjaDtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyB2ZXJzaW9uLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogU3RhdGljIGNsYXNzIGhvbGRpbmcgbGlicmFyeSBzcGVjaWZpYyBpbmZvcm1hdGlvbiBzdWNoIGFzIHRoZSB2ZXJzaW9uIGFuZCBidWlsZERhdGUgb2Zcblx0ICogdGhlIGxpYnJhcnkuXG5cdCAqIEBjbGFzcyBFYXNlbEpTXG5cdCAqKi9cblx0dmFyIHMgPSBjcmVhdGVqcy5FYXNlbEpTID0gY3JlYXRlanMuRWFzZWxKUyB8fCB7fTtcblxuXHQvKipcblx0ICogVGhlIHZlcnNpb24gc3RyaW5nIGZvciB0aGlzIHJlbGVhc2UuXG5cdCAqIEBwcm9wZXJ0eSB2ZXJzaW9uXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy52ZXJzaW9uID0gLyo9dmVyc2lvbiovXCIwLjguMVwiOyAvLyBpbmplY3RlZCBieSBidWlsZCBwcm9jZXNzXG5cblx0LyoqXG5cdCAqIFRoZSBidWlsZCBkYXRlIGZvciB0aGlzIHJlbGVhc2UgaW4gVVRDIGZvcm1hdC5cblx0ICogQHByb3BlcnR5IGJ1aWxkRGF0ZVxuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdHMuYnVpbGREYXRlID0gLyo9ZGF0ZSovXCJUaHUsIDIxIE1heSAyMDE1IDE2OjE3OjM5IEdNVFwiOyAvLyBpbmplY3RlZCBieSBidWlsZCBwcm9jZXNzXG5cbn0pKCk7XG4vKiFcbiogUHJlbG9hZEpTXG4qIFZpc2l0IGh0dHA6Ly9jcmVhdGVqcy5jb20vIGZvciBkb2N1bWVudGF0aW9uLCB1cGRhdGVzIGFuZCBleGFtcGxlcy5cbipcbiogQ29weXJpZ2h0IChjKSAyMDEwIGdza2lubmVyLmNvbSwgaW5jLlxuKlxuKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4qIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4qIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuKiBjb25kaXRpb25zOlxuKlxuKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbipcbiogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4qIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4qIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4qIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyB2ZXJzaW9uLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIFN0YXRpYyBjbGFzcyBob2xkaW5nIGxpYnJhcnkgc3BlY2lmaWMgaW5mb3JtYXRpb24gc3VjaCBhcyB0aGUgdmVyc2lvbiBhbmQgYnVpbGREYXRlIG9mIHRoZSBsaWJyYXJ5LlxuXHQgKiBAY2xhc3MgUHJlbG9hZEpTXG5cdCAqKi9cblx0dmFyIHMgPSBjcmVhdGVqcy5QcmVsb2FkSlMgPSBjcmVhdGVqcy5QcmVsb2FkSlMgfHwge307XG5cblx0LyoqXG5cdCAqIFRoZSB2ZXJzaW9uIHN0cmluZyBmb3IgdGhpcyByZWxlYXNlLlxuXHQgKiBAcHJvcGVydHkgdmVyc2lvblxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy52ZXJzaW9uID0gLyo9dmVyc2lvbiovXCIwLjYuMVwiOyAvLyBpbmplY3RlZCBieSBidWlsZCBwcm9jZXNzXG5cblx0LyoqXG5cdCAqIFRoZSBidWlsZCBkYXRlIGZvciB0aGlzIHJlbGVhc2UgaW4gVVRDIGZvcm1hdC5cblx0ICogQHByb3BlcnR5IGJ1aWxkRGF0ZVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy5idWlsZERhdGUgPSAvKj1kYXRlKi9cIlRodSwgMjEgTWF5IDIwMTUgMTY6MTc6MzcgR01UXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxufSkoKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIGV4dGVuZC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuXG4vKipcbiAqIFNldHMgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiBhbmQgY29uc3RydWN0b3IgcHJvcGVydHkgZm9yIGEgbmV3IGNsYXNzLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCByaWdodCBhZnRlciBjcmVhdGluZyB0aGUgY2xhc3MgY29uc3RydWN0b3IuXG4gKlxuICogXHRmdW5jdGlvbiBNeVN1YkNsYXNzKCkge31cbiAqIFx0Y3JlYXRlanMuZXh0ZW5kKE15U3ViQ2xhc3MsIE15U3VwZXJDbGFzcyk7XG4gKiBcdENsYXNzQi5wcm90b3R5cGUuZG9Tb21ldGhpbmcgPSBmdW5jdGlvbigpIHsgfVxuICpcbiAqIFx0dmFyIGZvbyA9IG5ldyBNeVN1YkNsYXNzKCk7XG4gKiBcdGNvbnNvbGUubG9nKGZvbyBpbnN0YW5jZW9mIE15U3VwZXJDbGFzcyk7IC8vIHRydWVcbiAqIFx0Y29uc29sZS5sb2coZm9vLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9PT0gTXlTdWJDbGFzcyk7IC8vIHRydWVcbiAqXG4gKiBAbWV0aG9kIGV4dGVuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ViY2xhc3MgVGhlIHN1YmNsYXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJjbGFzcyBUaGUgc3VwZXJjbGFzcyB0byBleHRlbmQuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgc3ViY2xhc3MncyBuZXcgcHJvdG90eXBlLlxuICovXG5jcmVhdGVqcy5leHRlbmQgPSBmdW5jdGlvbihzdWJjbGFzcywgc3VwZXJjbGFzcykge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRmdW5jdGlvbiBvKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gc3ViY2xhc3M7IH1cblx0by5wcm90b3R5cGUgPSBzdXBlcmNsYXNzLnByb3RvdHlwZTtcblx0cmV0dXJuIChzdWJjbGFzcy5wcm90b3R5cGUgPSBuZXcgbygpKTtcbn07XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBwcm9tb3RlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbi8qKlxuICogUHJvbW90ZXMgYW55IG1ldGhvZHMgb24gdGhlIHN1cGVyIGNsYXNzIHRoYXQgd2VyZSBvdmVycmlkZGVuLCBieSBjcmVhdGluZyBhbiBhbGlhcyBpbiB0aGUgZm9ybWF0IGBwcmVmaXhfbWV0aG9kTmFtZWAuXG4gKiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgdGhlIHN1cGVyIGNsYXNzJ3MgbmFtZSBhcyB0aGUgcHJlZml4LlxuICogQW4gYWxpYXMgdG8gdGhlIHN1cGVyIGNsYXNzJ3MgY29uc3RydWN0b3IgaXMgYWx3YXlzIGFkZGVkIGluIHRoZSBmb3JtYXQgYHByZWZpeF9jb25zdHJ1Y3RvcmAuXG4gKiBUaGlzIGFsbG93cyB0aGUgc3ViY2xhc3MgdG8gY2FsbCBzdXBlciBjbGFzcyBtZXRob2RzIHdpdGhvdXQgdXNpbmcgYGZ1bmN0aW9uLmNhbGxgLCBwcm92aWRpbmcgYmV0dGVyIHBlcmZvcm1hbmNlLlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiBgTXlTdWJDbGFzc2AgZXh0ZW5kcyBgTXlTdXBlckNsYXNzYCwgYW5kIGJvdGggZGVmaW5lIGEgYGRyYXdgIG1ldGhvZCwgdGhlbiBjYWxsaW5nIGBwcm9tb3RlKE15U3ViQ2xhc3MsIFwiTXlTdXBlckNsYXNzXCIpYFxuICogd291bGQgYWRkIGEgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAgbWV0aG9kIHRvIE15U3ViQ2xhc3MgYW5kIHByb21vdGUgdGhlIGBkcmF3YCBtZXRob2Qgb24gYE15U3VwZXJDbGFzc2AgdG8gdGhlXG4gKiBwcm90b3R5cGUgb2YgYE15U3ViQ2xhc3NgIGFzIGBNeVN1cGVyQ2xhc3NfZHJhd2AuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoZSBjbGFzcydzIHByb3RvdHlwZSBpcyBmdWxseSBkZWZpbmVkLlxuICpcbiAqIFx0ZnVuY3Rpb24gQ2xhc3NBKG5hbWUpIHtcbiAqIFx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuICogXHR9XG4gKiBcdENsYXNzQS5wcm90b3R5cGUuZ3JlZXQgPSBmdW5jdGlvbigpIHtcbiAqIFx0XHRyZXR1cm4gXCJIZWxsbyBcIit0aGlzLm5hbWU7XG4gKiBcdH1cbiAqXG4gKiBcdGZ1bmN0aW9uIENsYXNzQihuYW1lLCBwdW5jdHVhdGlvbikge1xuICogXHRcdHRoaXMuQ2xhc3NBX2NvbnN0cnVjdG9yKG5hbWUpO1xuICogXHRcdHRoaXMucHVuY3R1YXRpb24gPSBwdW5jdHVhdGlvbjtcbiAqIFx0fVxuICogXHRjcmVhdGVqcy5leHRlbmQoQ2xhc3NCLCBDbGFzc0EpO1xuICogXHRDbGFzc0IucHJvdG90eXBlLmdyZWV0ID0gZnVuY3Rpb24oKSB7XG4gKiBcdFx0cmV0dXJuIHRoaXMuQ2xhc3NBX2dyZWV0KCkrdGhpcy5wdW5jdHVhdGlvbjtcbiAqIFx0fVxuICogXHRjcmVhdGVqcy5wcm9tb3RlKENsYXNzQiwgXCJDbGFzc0FcIik7XG4gKlxuICogXHR2YXIgZm9vID0gbmV3IENsYXNzQihcIldvcmxkXCIsIFwiIT8hXCIpO1xuICogXHRjb25zb2xlLmxvZyhmb28uZ3JlZXQoKSk7IC8vIEhlbGxvIFdvcmxkIT8hXG4gKlxuICogQG1ldGhvZCBwcm9tb3RlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJjbGFzcyBUaGUgY2xhc3MgdG8gcHJvbW90ZSBzdXBlciBjbGFzcyBtZXRob2RzIG9uLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBUaGUgcHJlZml4IHRvIGFkZCB0byB0aGUgcHJvbW90ZWQgbWV0aG9kIG5hbWVzLiBVc3VhbGx5IHRoZSBuYW1lIG9mIHRoZSBzdXBlcmNsYXNzLlxuICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgdGhlIHN1YmNsYXNzLlxuICovXG5jcmVhdGVqcy5wcm9tb3RlID0gZnVuY3Rpb24oc3ViY2xhc3MsIHByZWZpeCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHR2YXIgc3ViUCA9IHN1YmNsYXNzLnByb3RvdHlwZSwgc3VwUCA9IChPYmplY3QuZ2V0UHJvdG90eXBlT2YmJk9iamVjdC5nZXRQcm90b3R5cGVPZihzdWJQKSl8fHN1YlAuX19wcm90b19fO1xuXHRpZiAoc3VwUCkge1xuXHRcdHN1YlBbKHByZWZpeCs9XCJfXCIpICsgXCJjb25zdHJ1Y3RvclwiXSA9IHN1cFAuY29uc3RydWN0b3I7IC8vIGNvbnN0cnVjdG9yIGlzIG5vdCBhbHdheXMgaW5udW1lcmFibGVcblx0XHRmb3IgKHZhciBuIGluIHN1cFApIHtcblx0XHRcdGlmIChzdWJQLmhhc093blByb3BlcnR5KG4pICYmICh0eXBlb2Ygc3VwUFtuXSA9PSBcImZ1bmN0aW9uXCIpKSB7IHN1YlBbcHJlZml4ICsgbl0gPSBzdXBQW25dOyB9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBzdWJjbGFzcztcbn07XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBpbmRleE9mLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBzcGVjaWZpZWQgdmFsdWUgc2VhcmNoRWxlbWVudCBpbiB0aGUgcGFzc2VkIGluIGFycmF5LCBhbmQgcmV0dXJucyB0aGUgaW5kZXggb2ZcbiAqIHRoYXQgdmFsdWUuICBSZXR1cm5zIC0xIGlmIHZhbHVlIGlzIG5vdCBmb3VuZC5cbiAqXG4gKiAgICAgIHZhciBpID0gY3JlYXRlanMuaW5kZXhPZihteUFycmF5LCBteUVsZW1lbnRUb0ZpbmQpO1xuICpcbiAqIEBtZXRob2QgaW5kZXhPZlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgQXJyYXkgdG8gc2VhcmNoIGZvciBzZWFyY2hFbGVtZW50XG4gKiBAcGFyYW0gc2VhcmNoRWxlbWVudCBFbGVtZW50IHRvIGZpbmQgaW4gYXJyYXkuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBmaXJzdCBpbmRleCBvZiBzZWFyY2hFbGVtZW50IGluIGFycmF5LlxuICovXG5jcmVhdGVqcy5pbmRleE9mID0gZnVuY3Rpb24gKGFycmF5LCBzZWFyY2hFbGVtZW50KXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Zm9yICh2YXIgaSA9IDAsbD1hcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRpZiAoc2VhcmNoRWxlbWVudCA9PT0gYXJyYXlbaV0pIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59O1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gcHJveHkuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuLyoqXG4gKiBWYXJpb3VzIHV0aWxpdGllcyB0aGF0IHRoZSBDcmVhdGVKUyBTdWl0ZSB1c2VzLiBVdGlsaXRpZXMgYXJlIGNyZWF0ZWQgYXMgc2VwYXJhdGUgZmlsZXMsIGFuZCB3aWxsIGJlIGF2YWlsYWJsZSBvbiB0aGVcbiAqIGNyZWF0ZWpzIG5hbWVzcGFjZSBkaXJlY3RseS5cbiAqXG4gKiA8aDQ+RXhhbXBsZTwvaDQ+XG4gKlxuICogICAgICBteU9iamVjdC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGNyZWF0ZWpzLnByb3h5KG15TWV0aG9kLCBzY29wZSkpO1xuICpcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqIEBtYWluIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIEEgZnVuY3Rpb24gcHJveHkgZm9yIG1ldGhvZHMuIEJ5IGRlZmF1bHQsIEphdmFTY3JpcHQgbWV0aG9kcyBkbyBub3QgbWFpbnRhaW4gc2NvcGUsIHNvIHBhc3NpbmcgYSBtZXRob2QgYXMgYVxuXHQgKiBjYWxsYmFjayB3aWxsIHJlc3VsdCBpbiB0aGUgbWV0aG9kIGdldHRpbmcgY2FsbGVkIGluIHRoZSBzY29wZSBvZiB0aGUgY2FsbGVyLiBVc2luZyBhIHByb3h5IGVuc3VyZXMgdGhhdCB0aGVcblx0ICogbWV0aG9kIGdldHMgY2FsbGVkIGluIHRoZSBjb3JyZWN0IHNjb3BlLlxuXHQgKlxuXHQgKiBBZGRpdGlvbmFsIGFyZ3VtZW50cyBjYW4gYmUgcGFzc2VkIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBmdW5jdGlvbiB3aGVuIGl0IGlzIGNhbGxlZC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIG15T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJldmVudFwiLCBjcmVhdGVqcy5wcm94eShteUhhbmRsZXIsIHRoaXMsIGFyZzEsIGFyZzIpKTtcblx0ICpcblx0ICogICAgICBmdW5jdGlvbiBteUhhbmRsZXIoYXJnMSwgYXJnMikge1xuXHQgKiAgICAgICAgICAgLy8gVGhpcyBnZXRzIGNhbGxlZCB3aGVuIG15T2JqZWN0Lm15Q2FsbGJhY2sgaXMgZXhlY3V0ZWQuXG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBAbWV0aG9kIHByb3h5XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBUaGUgZnVuY3Rpb24gdG8gY2FsbFxuXHQgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgVGhlIHNjb3BlIHRvIGNhbGwgdGhlIG1ldGhvZCBuYW1lIG9uXG5cdCAqIEBwYXJhbSB7bWl4ZWR9IFthcmddICogQXJndW1lbnRzIHRoYXQgYXJlIGFwcGVuZGVkIHRvIHRoZSBjYWxsYmFjayBmb3IgYWRkaXRpb25hbCBwYXJhbXMuXG5cdCAqIEBwdWJsaWNcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0Y3JlYXRlanMucHJveHkgPSBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSkge1xuXHRcdHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBtZXRob2QuYXBwbHkoc2NvcGUsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkuY29uY2F0KGFBcmdzKSk7XG5cdFx0fTtcblx0fVxuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQnJvd3NlckRldGVjdC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogQW4gb2JqZWN0IHRoYXQgZGV0ZXJtaW5lcyB0aGUgY3VycmVudCBicm93c2VyLCB2ZXJzaW9uLCBvcGVyYXRpbmcgc3lzdGVtLCBhbmQgb3RoZXIgZW52aXJvbm1lbnRcblx0ICogdmFyaWFibGVzIHZpYSB1c2VyIGFnZW50IHN0cmluZy5cblx0ICpcblx0ICogVXNlZCBmb3IgYXVkaW8gYmVjYXVzZSBmZWF0dXJlIGRldGVjdGlvbiBpcyB1bmFibGUgdG8gZGV0ZWN0IHRoZSBtYW55IGxpbWl0YXRpb25zIG9mIG1vYmlsZSBkZXZpY2VzLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgaWYgKGNyZWF0ZWpzLkJyb3dzZXJEZXRlY3QuaXNJT1MpIHsgLy8gZG8gc3R1ZmYgfVxuXHQgKlxuXHQgKiBAcHJvcGVydHkgQnJvd3NlckRldGVjdFxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRmlyZWZveCBUcnVlIGlmIG91ciBicm93c2VyIGlzIEZpcmVmb3guXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPcGVyYSBUcnVlIGlmIG91ciBicm93c2VyIGlzIG9wZXJhLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQ2hyb21lIFRydWUgaWYgb3VyIGJyb3dzZXIgaXMgQ2hyb21lLiAgTm90ZSB0aGF0IENocm9tZSBmb3IgQW5kcm9pZCByZXR1cm5zIHRydWUsIGJ1dCBpcyBhXG5cdCAqIGNvbXBsZXRlbHkgZGlmZmVyZW50IGJyb3dzZXIgd2l0aCBkaWZmZXJlbnQgYWJpbGl0aWVzLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzSU9TIFRydWUgaWYgb3VyIGJyb3dzZXIgaXMgc2FmYXJpIGZvciBpT1MgZGV2aWNlcyAoaVBhZCwgaVBob25lLCBhbmQgaVBvZCkuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNBbmRyb2lkIFRydWUgaWYgb3VyIGJyb3dzZXIgaXMgQW5kcm9pZC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0JsYWNrYmVycnkgVHJ1ZSBpZiBvdXIgYnJvd3NlciBpcyBCbGFja2JlcnJ5LlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0ZnVuY3Rpb24gQnJvd3NlckRldGVjdCgpIHtcblx0XHR0aHJvdyBcIkJyb3dzZXJEZXRlY3QgY2Fubm90IGJlIGluc3RhbnRpYXRlZFwiO1xuXHR9XG5cblx0dmFyIGFnZW50ID0gQnJvd3NlckRldGVjdC5hZ2VudCA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXHRCcm93c2VyRGV0ZWN0LmlzV2luZG93UGhvbmUgPSAoYWdlbnQuaW5kZXhPZihcIklFTW9iaWxlXCIpID4gLTEpIHx8IChhZ2VudC5pbmRleE9mKFwiV2luZG93cyBQaG9uZVwiKSA+IC0xKTtcblx0QnJvd3NlckRldGVjdC5pc0ZpcmVmb3ggPSAoYWdlbnQuaW5kZXhPZihcIkZpcmVmb3hcIikgPiAtMSk7XG5cdEJyb3dzZXJEZXRlY3QuaXNPcGVyYSA9ICh3aW5kb3cub3BlcmEgIT0gbnVsbCk7XG5cdEJyb3dzZXJEZXRlY3QuaXNDaHJvbWUgPSAoYWdlbnQuaW5kZXhPZihcIkNocm9tZVwiKSA+IC0xKTsgIC8vIE5PVEUgdGhhdCBDaHJvbWUgb24gQW5kcm9pZCByZXR1cm5zIHRydWUgYnV0IGlzIGEgY29tcGxldGVseSBkaWZmZXJlbnQgYnJvd3NlciB3aXRoIGRpZmZlcmVudCBhYmlsaXRpZXNcblx0QnJvd3NlckRldGVjdC5pc0lPUyA9IChhZ2VudC5pbmRleE9mKFwiaVBvZFwiKSA+IC0xIHx8IGFnZW50LmluZGV4T2YoXCJpUGhvbmVcIikgPiAtMSB8fCBhZ2VudC5pbmRleE9mKFwiaVBhZFwiKSA+IC0xKSAmJiAhQnJvd3NlckRldGVjdC5pc1dpbmRvd1Bob25lO1xuXHRCcm93c2VyRGV0ZWN0LmlzQW5kcm9pZCA9IChhZ2VudC5pbmRleE9mKFwiQW5kcm9pZFwiKSA+IC0xKSAmJiAhQnJvd3NlckRldGVjdC5pc1dpbmRvd1Bob25lO1xuXHRCcm93c2VyRGV0ZWN0LmlzQmxhY2tiZXJyeSA9IChhZ2VudC5pbmRleE9mKFwiQmxhY2tiZXJyeVwiKSA+IC0xKTtcblxuXHRjcmVhdGVqcy5Ccm93c2VyRGV0ZWN0ID0gQnJvd3NlckRldGVjdDtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEV2ZW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQ29udGFpbnMgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBzaGFyZWQgYnkgYWxsIGV2ZW50cyBmb3IgdXNlIHdpdGhcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBcblx0ICogTm90ZSB0aGF0IEV2ZW50IG9iamVjdHMgYXJlIG9mdGVuIHJldXNlZCwgc28geW91IHNob3VsZCBuZXZlclxuXHQgKiByZWx5IG9uIGFuIGV2ZW50IG9iamVjdCdzIHN0YXRlIG91dHNpZGUgb2YgdGhlIGNhbGwgc3RhY2sgaXQgd2FzIHJlY2VpdmVkIGluLlxuXHQgKiBAY2xhc3MgRXZlbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYnViYmxlcyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZXZlbnQgd2lsbCBidWJibGUgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNhbmNlbGFibGUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mIHRoaXMgZXZlbnQgY2FuIGJlIGNhbmNlbGxlZC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gRXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSkge1xuXHRcdFxuXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IHR5cGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiovXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIG9iamVjdCB0aGF0IGdlbmVyYXRlZCBhbiBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgdGFyZ2V0XG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy50YXJnZXQgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY3VycmVudCB0YXJnZXQgdGhhdCBhIGJ1YmJsaW5nIGV2ZW50IGlzIGJlaW5nIGRpc3BhdGNoZWQgZnJvbS4gRm9yIG5vbi1idWJibGluZyBldmVudHMsIHRoaXMgd2lsbFxuXHRcdCAqIGFsd2F5cyBiZSB0aGUgc2FtZSBhcyB0YXJnZXQuIEZvciBleGFtcGxlLCBpZiBjaGlsZE9iai5wYXJlbnQgPSBwYXJlbnRPYmosIGFuZCBhIGJ1YmJsaW5nIGV2ZW50XG5cdFx0ICogaXMgZ2VuZXJhdGVkIGZyb20gY2hpbGRPYmosIHRoZW4gYSBsaXN0ZW5lciBvbiBwYXJlbnRPYmogd291bGQgcmVjZWl2ZSB0aGUgZXZlbnQgd2l0aFxuXHRcdCAqIHRhcmdldD1jaGlsZE9iaiAodGhlIG9yaWdpbmFsIHRhcmdldCkgYW5kIGN1cnJlbnRUYXJnZXQ9cGFyZW50T2JqICh3aGVyZSB0aGUgbGlzdGVuZXIgd2FzIGFkZGVkKS5cblx0XHQgKiBAcHJvcGVydHkgY3VycmVudFRhcmdldFxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZvciBidWJibGluZyBldmVudHMsIHRoaXMgaW5kaWNhdGVzIHRoZSBjdXJyZW50IGV2ZW50IHBoYXNlOjxPTD5cblx0XHQgKiBcdDxMST4gY2FwdHVyZSBwaGFzZTogc3RhcnRpbmcgZnJvbSB0aGUgdG9wIHBhcmVudCB0byB0aGUgdGFyZ2V0PC9MST5cblx0XHQgKiBcdDxMST4gYXQgdGFyZ2V0IHBoYXNlOiBjdXJyZW50bHkgYmVpbmcgZGlzcGF0Y2hlZCBmcm9tIHRoZSB0YXJnZXQ8L0xJPlxuXHRcdCAqIFx0PExJPiBidWJibGluZyBwaGFzZTogZnJvbSB0aGUgdGFyZ2V0IHRvIHRoZSB0b3AgcGFyZW50PC9MST5cblx0XHQgKiA8L09MPlxuXHRcdCAqIEBwcm9wZXJ0eSBldmVudFBoYXNlXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5ldmVudFBoYXNlID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IHdpbGwgYnViYmxlIHRocm91Z2ggdGhlIGRpc3BsYXkgbGlzdC5cblx0XHQgKiBAcHJvcGVydHkgYnViYmxlc1xuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5idWJibGVzID0gISFidWJibGVzO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdGhpcyBldmVudCBjYW4gYmUgY2FuY2VsbGVkIHZpYVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50L3ByZXZlbnREZWZhdWx0XCJ9fXt7L2Nyb3NzTGlua319LiBUaGlzIGlzIHNldCB2aWEgdGhlIEV2ZW50IGNvbnN0cnVjdG9yLlxuXHRcdCAqIEBwcm9wZXJ0eSBjYW5jZWxhYmxlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmNhbmNlbGFibGUgPSAhIWNhbmNlbGFibGU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBlcG9jaCB0aW1lIGF0IHdoaWNoIHRoaXMgZXZlbnQgd2FzIGNyZWF0ZWQuXG5cdFx0ICogQHByb3BlcnR5IHRpbWVTdGFtcFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMudGltZVN0YW1wID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHt7I2Nyb3NzTGluayBcIkV2ZW50L3ByZXZlbnREZWZhdWx0XCJ9fXt7L2Nyb3NzTGlua319IGhhcyBiZWVuIGNhbGxlZFxuXHRcdCAqIG9uIHRoaXMgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IGRlZmF1bHRQcmV2ZW50ZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYge3sjY3Jvc3NMaW5rIFwiRXZlbnQvc3RvcFByb3BhZ2F0aW9uXCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXCJ9fXt7L2Nyb3NzTGlua319IGhhcyBiZWVuIGNhbGxlZCBvbiB0aGlzIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBwcm9wYWdhdGlvblN0b3BwZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkXG5cdFx0ICogb24gdGhpcyBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9yZW1vdmVcIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkIG9uIHRoaXMgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IHJlbW92ZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMucmVtb3ZlZCA9IGZhbHNlO1xuXHR9XG5cdHZhciBwID0gRXZlbnQucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblx0XG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogU2V0cyB7eyNjcm9zc0xpbmsgXCJFdmVudC9kZWZhdWx0UHJldmVudGVkXCJ9fXt7L2Nyb3NzTGlua319IHRvIHRydWUuXG5cdCAqIE1pcnJvcnMgdGhlIERPTSBldmVudCBzdGFuZGFyZC5cblx0ICogQG1ldGhvZCBwcmV2ZW50RGVmYXVsdFxuXHQgKiovXG5cdHAucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0aGlzLmNhbmNlbGFibGUmJnRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcHJvcGFnYXRpb25TdG9wcGVkXCJ9fXt7L2Nyb3NzTGlua319IHRvIHRydWUuXG5cdCAqIE1pcnJvcnMgdGhlIERPTSBldmVudCBzdGFuZGFyZC5cblx0ICogQG1ldGhvZCBzdG9wUHJvcGFnYXRpb25cblx0ICoqL1xuXHRwLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB7eyNjcm9zc0xpbmsgXCJFdmVudC9wcm9wYWdhdGlvblN0b3BwZWRcIn19e3svY3Jvc3NMaW5rfX0gYW5kXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50L2ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZFwifX17ey9jcm9zc0xpbmt9fSB0byB0cnVlLlxuXHQgKiBNaXJyb3JzIHRoZSBET00gZXZlbnQgc3RhbmRhcmQuXG5cdCAqIEBtZXRob2Qgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXG5cdCAqKi9cblx0cC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDYXVzZXMgdGhlIGFjdGl2ZSBsaXN0ZW5lciB0byBiZSByZW1vdmVkIHZpYSByZW1vdmVFdmVudExpc3RlbmVyKCk7XG5cdCAqIFxuXHQgKiBcdFx0bXlCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2dCkge1xuXHQgKiBcdFx0XHQvLyBkbyBzdHVmZi4uLlxuXHQgKiBcdFx0XHRldnQucmVtb3ZlKCk7IC8vIHJlbW92ZXMgdGhpcyBsaXN0ZW5lci5cblx0ICogXHRcdH0pO1xuXHQgKiBcblx0ICogQG1ldGhvZCByZW1vdmVcblx0ICoqL1xuXHRwLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVtb3ZlZCA9IHRydWU7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBFdmVudCBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtFdmVudH0gYSBjbG9uZSBvZiB0aGUgRXZlbnQgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgRXZlbnQodGhpcy50eXBlLCB0aGlzLmJ1YmJsZXMsIHRoaXMuY2FuY2VsYWJsZSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUHJvdmlkZXMgYSBjaGFpbmFibGUgc2hvcnRjdXQgbWV0aG9kIGZvciBzZXR0aW5nIGEgbnVtYmVyIG9mIHByb3BlcnRpZXMgb24gdGhlIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHNldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQSBnZW5lcmljIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gY29weSB0byB0aGUgaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4ge0V2ZW50fSBSZXR1cm5zIHRoZSBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5zZXQgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdGZvciAodmFyIG4gaW4gcHJvcHMpIHsgdGhpc1tuXSA9IHByb3BzW25dOyB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltFdmVudCAodHlwZT1cIit0aGlzLnR5cGUrXCIpXVwiO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkV2ZW50ID0gRXZlbnQ7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRXJyb3JFdmVudC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyYWwgZXJyb3Ige3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0sIHRoYXQgZGVzY3JpYmVzIGFuIGVycm9yIHRoYXQgb2NjdXJyZWQsIGFzIHdlbGwgYXMgYW55IGRldGFpbHMuXG5cdCAqIEBjbGFzcyBFcnJvckV2ZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbdGl0bGVdIFRoZSBlcnJvciB0aXRsZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIFRoZSBlcnJvciBkZXNjcmlwdGlvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIEFkZGl0aW9uYWwgZXJyb3IgZGF0YVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEVycm9yRXZlbnQodGl0bGUsIG1lc3NhZ2UsIGRhdGEpIHtcblx0XHR0aGlzLkV2ZW50X2NvbnN0cnVjdG9yKFwiZXJyb3JcIik7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgc2hvcnQgZXJyb3IgdGl0bGUsIHdoaWNoIGluZGljYXRlcyB0aGUgdHlwZSBvZiBlcnJvciB0aGF0IG9jY3VycmVkLlxuXHRcdCAqIEBwcm9wZXJ0eSB0aXRsZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdHRoaXMudGl0bGUgPSB0aXRsZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB2ZXJib3NlIGVycm9yIG1lc3NhZ2UsIGNvbnRhaW5pbmcgZGV0YWlscyBhYm91dCB0aGUgZXJyb3IuXG5cdFx0ICogQHByb3BlcnR5IG1lc3NhZ2Vcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXG5cdFx0LyoqXG5cdFx0ICogQWRkaXRpb25hbCBkYXRhIGF0dGFjaGVkIHRvIGFuIGVycm9yLlxuXHRcdCAqIEBwcm9wZXJ0eSBkYXRhXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLmRhdGEgPSBkYXRhO1xuXHR9XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoRXJyb3JFdmVudCwgY3JlYXRlanMuRXZlbnQpO1xuXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQodGhpcy50aXRsZSwgdGhpcy5tZXNzYWdlLCB0aGlzLmRhdGEpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkVycm9yRXZlbnQgPSBjcmVhdGVqcy5wcm9tb3RlKEVycm9yRXZlbnQsIFwiRXZlbnRcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBFdmVudERpc3BhdGNoZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG4vLyBjb25zdHJ1Y3RvcjpcclxuXHQvKipcclxuXHQgKiBFdmVudERpc3BhdGNoZXIgcHJvdmlkZXMgbWV0aG9kcyBmb3IgbWFuYWdpbmcgcXVldWVzIG9mIGV2ZW50IGxpc3RlbmVycyBhbmQgZGlzcGF0Y2hpbmcgZXZlbnRzLlxyXG5cdCAqXHJcblx0ICogWW91IGNhbiBlaXRoZXIgZXh0ZW5kIEV2ZW50RGlzcGF0Y2hlciBvciBtaXggaXRzIG1ldGhvZHMgaW50byBhbiBleGlzdGluZyBwcm90b3R5cGUgb3IgaW5zdGFuY2UgYnkgdXNpbmcgdGhlXHJcblx0ICogRXZlbnREaXNwYXRjaGVyIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9pbml0aWFsaXplXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cclxuXHQgKiBcclxuXHQgKiBUb2dldGhlciB3aXRoIHRoZSBDcmVhdGVKUyBFdmVudCBjbGFzcywgRXZlbnREaXNwYXRjaGVyIHByb3ZpZGVzIGFuIGV4dGVuZGVkIGV2ZW50IG1vZGVsIHRoYXQgaXMgYmFzZWQgb24gdGhlXHJcblx0ICogRE9NIExldmVsIDIgZXZlbnQgbW9kZWwsIGluY2x1ZGluZyBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyLCBhbmQgZGlzcGF0Y2hFdmVudC4gSXQgc3VwcG9ydHNcclxuXHQgKiBidWJibGluZyAvIGNhcHR1cmUsIHByZXZlbnREZWZhdWx0LCBzdG9wUHJvcGFnYXRpb24sIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiwgYW5kIGhhbmRsZUV2ZW50LlxyXG5cdCAqIFxyXG5cdCAqIEV2ZW50RGlzcGF0Y2hlciBhbHNvIGV4cG9zZXMgYSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvb25cIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLCB3aGljaCBtYWtlcyBpdCBlYXNpZXJcclxuXHQgKiB0byBjcmVhdGUgc2NvcGVkIGxpc3RlbmVycywgbGlzdGVuZXJzIHRoYXQgb25seSBydW4gb25jZSwgYW5kIGxpc3RlbmVycyB3aXRoIGFzc29jaWF0ZWQgYXJiaXRyYXJ5IGRhdGEuIFRoZSBcclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvb2ZmXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCBpcyBtZXJlbHkgYW4gYWxpYXMgdG9cclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvcmVtb3ZlRXZlbnRMaXN0ZW5lclwifX17ey9jcm9zc0xpbmt9fS5cclxuXHQgKiBcclxuXHQgKiBBbm90aGVyIGFkZGl0aW9uIHRvIHRoZSBET00gTGV2ZWwgMiBtb2RlbCBpcyB0aGUge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL3JlbW92ZUFsbEV2ZW50TGlzdGVuZXJzXCJ9fXt7L2Nyb3NzTGlua319XHJcblx0ICogbWV0aG9kLCB3aGljaCBjYW4gYmUgdXNlZCB0byBsaXN0ZW5lcnMgZm9yIGFsbCBldmVudHMsIG9yIGxpc3RlbmVycyBmb3IgYSBzcGVjaWZpYyBldmVudC4gVGhlIEV2ZW50IG9iamVjdCBhbHNvIFxyXG5cdCAqIGluY2x1ZGVzIGEge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcmVtb3ZlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCB3aGljaCByZW1vdmVzIHRoZSBhY3RpdmUgbGlzdGVuZXIuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICogQWRkIEV2ZW50RGlzcGF0Y2hlciBjYXBhYmlsaXRpZXMgdG8gdGhlIFwiTXlDbGFzc1wiIGNsYXNzLlxyXG5cdCAqXHJcblx0ICogICAgICBFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShNeUNsYXNzLnByb3RvdHlwZSk7XHJcblx0ICpcclxuXHQgKiBBZGQgYW4gZXZlbnQgKHNlZSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvYWRkRXZlbnRMaXN0ZW5lclwifX17ey9jcm9zc0xpbmt9fSkuXHJcblx0ICpcclxuXHQgKiAgICAgIGluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJldmVudE5hbWVcIiwgaGFuZGxlck1ldGhvZCk7XHJcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVyTWV0aG9kKGV2ZW50KSB7XHJcblx0ICogICAgICAgICAgY29uc29sZS5sb2coZXZlbnQudGFyZ2V0ICsgXCIgV2FzIENsaWNrZWRcIik7XHJcblx0ICogICAgICB9XHJcblx0ICpcclxuXHQgKiA8Yj5NYWludGFpbmluZyBwcm9wZXIgc2NvcGU8L2I+PGJyIC8+XHJcblx0ICogU2NvcGUgKGllLiBcInRoaXNcIikgY2FuIGJlIGJlIGEgY2hhbGxlbmdlIHdpdGggZXZlbnRzLiBVc2luZyB0aGUge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL29uXCJ9fXt7L2Nyb3NzTGlua319XHJcblx0ICogbWV0aG9kIHRvIHN1YnNjcmliZSB0byBldmVudHMgc2ltcGxpZmllcyB0aGlzLlxyXG5cdCAqXHJcblx0ICogICAgICBpbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuXHQgKiAgICAgICAgICBjb25zb2xlLmxvZyhpbnN0YW5jZSA9PSB0aGlzKTsgLy8gZmFsc2UsIHNjb3BlIGlzIGFtYmlndW91cy5cclxuXHQgKiAgICAgIH0pO1xyXG5cdCAqICAgICAgXHJcblx0ICogICAgICBpbnN0YW5jZS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0ICogICAgICAgICAgY29uc29sZS5sb2coaW5zdGFuY2UgPT0gdGhpcyk7IC8vIHRydWUsIFwib25cIiB1c2VzIGRpc3BhdGNoZXIgc2NvcGUgYnkgZGVmYXVsdC5cclxuXHQgKiAgICAgIH0pO1xyXG5cdCAqIFxyXG5cdCAqIElmIHlvdSB3YW50IHRvIHVzZSBhZGRFdmVudExpc3RlbmVyIGluc3RlYWQsIHlvdSBtYXkgd2FudCB0byB1c2UgZnVuY3Rpb24uYmluZCgpIG9yIGEgc2ltaWxhciBwcm94eSB0byBtYW5hZ2Ugc2NvcGUuXHJcblx0ICogICAgICBcclxuXHQgKlxyXG5cdCAqIEBjbGFzcyBFdmVudERpc3BhdGNoZXJcclxuXHQgKiBAY29uc3RydWN0b3JcclxuXHQgKiovXHJcblx0ZnVuY3Rpb24gRXZlbnREaXNwYXRjaGVyKCkge1xyXG5cdFxyXG5cdFxyXG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcclxuXHRcdC8qKlxyXG5cdFx0ICogQHByb3RlY3RlZFxyXG5cdFx0ICogQHByb3BlcnR5IF9saXN0ZW5lcnNcclxuXHRcdCAqIEB0eXBlIE9iamVjdFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5fbGlzdGVuZXJzID0gbnVsbDtcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAcHJvcGVydHkgX2NhcHR1cmVMaXN0ZW5lcnNcclxuXHRcdCAqIEB0eXBlIE9iamVjdFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5fY2FwdHVyZUxpc3RlbmVycyA9IG51bGw7XHJcblx0fVxyXG5cdHZhciBwID0gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZTtcclxuXHJcblx0LyoqXHJcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxyXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIGZvciBkZXRhaWxzLlxyXG5cdCAqXHJcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICogQGRlcHJlY2F0ZWRcclxuXHQgKi9cclxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cclxuXHJcblxyXG4vLyBzdGF0aWMgcHVibGljIG1ldGhvZHM6XHJcblx0LyoqXHJcblx0ICogU3RhdGljIGluaXRpYWxpemVyIHRvIG1peCBFdmVudERpc3BhdGNoZXIgbWV0aG9kcyBpbnRvIGEgdGFyZ2V0IG9iamVjdCBvciBwcm90b3R5cGUuXHJcblx0ICogXHJcblx0ICogXHRcdEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplKE15Q2xhc3MucHJvdG90eXBlKTsgLy8gYWRkIHRvIHRoZSBwcm90b3R5cGUgb2YgdGhlIGNsYXNzXHJcblx0ICogXHRcdEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplKG15T2JqZWN0KTsgLy8gYWRkIHRvIGEgc3BlY2lmaWMgaW5zdGFuY2VcclxuXHQgKiBcclxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcclxuXHQgKiBAc3RhdGljXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCB0byBpbmplY3QgRXZlbnREaXNwYXRjaGVyIG1ldGhvZHMgaW50by4gVGhpcyBjYW4gYmUgYW4gaW5zdGFuY2Ugb3IgYVxyXG5cdCAqIHByb3RvdHlwZS5cclxuXHQgKiovXHJcblx0RXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUgPSBmdW5jdGlvbih0YXJnZXQpIHtcclxuXHRcdHRhcmdldC5hZGRFdmVudExpc3RlbmVyID0gcC5hZGRFdmVudExpc3RlbmVyO1xyXG5cdFx0dGFyZ2V0Lm9uID0gcC5vbjtcclxuXHRcdHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyID0gdGFyZ2V0Lm9mZiA9ICBwLnJlbW92ZUV2ZW50TGlzdGVuZXI7XHJcblx0XHR0YXJnZXQucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMgPSBwLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzO1xyXG5cdFx0dGFyZ2V0Lmhhc0V2ZW50TGlzdGVuZXIgPSBwLmhhc0V2ZW50TGlzdGVuZXI7XHJcblx0XHR0YXJnZXQuZGlzcGF0Y2hFdmVudCA9IHAuZGlzcGF0Y2hFdmVudDtcclxuXHRcdHRhcmdldC5fZGlzcGF0Y2hFdmVudCA9IHAuX2Rpc3BhdGNoRXZlbnQ7XHJcblx0XHR0YXJnZXQud2lsbFRyaWdnZXIgPSBwLndpbGxUcmlnZ2VyO1xyXG5cdH07XHJcblx0XHJcblxyXG4vLyBwdWJsaWMgbWV0aG9kczpcclxuXHQvKipcclxuXHQgKiBBZGRzIHRoZSBzcGVjaWZpZWQgZXZlbnQgbGlzdGVuZXIuIE5vdGUgdGhhdCBhZGRpbmcgbXVsdGlwbGUgbGlzdGVuZXJzIHRvIHRoZSBzYW1lIGZ1bmN0aW9uIHdpbGwgcmVzdWx0IGluXHJcblx0ICogbXVsdGlwbGUgY2FsbGJhY2tzIGdldHRpbmcgZmlyZWQuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrKTtcclxuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XHJcblx0ICogICAgICAgICAvLyBDbGljayBoYXBwZW5lZC5cclxuXHQgKiAgICAgIH1cclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgYWRkRXZlbnRMaXN0ZW5lclxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbiB8IE9iamVjdH0gbGlzdGVuZXIgQW4gb2JqZWN0IHdpdGggYSBoYW5kbGVFdmVudCBtZXRob2QsIG9yIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuXHJcblx0ICogdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZV0gRm9yIGV2ZW50cyB0aGF0IGJ1YmJsZSwgaW5kaWNhdGVzIHdoZXRoZXIgdG8gbGlzdGVuIGZvciB0aGUgZXZlbnQgaW4gdGhlIGNhcHR1cmUgb3IgYnViYmxpbmcvdGFyZ2V0IHBoYXNlLlxyXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9uIHwgT2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0ZW5lciBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cclxuXHQgKiovXHJcblx0cC5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnM7XHJcblx0XHRpZiAodXNlQ2FwdHVyZSkge1xyXG5cdFx0XHRsaXN0ZW5lcnMgPSB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVyc3x8e307XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnN8fHt9O1xyXG5cdFx0fVxyXG5cdFx0dmFyIGFyciA9IGxpc3RlbmVyc1t0eXBlXTtcclxuXHRcdGlmIChhcnIpIHsgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTsgfVxyXG5cdFx0YXJyID0gbGlzdGVuZXJzW3R5cGVdOyAvLyByZW1vdmUgbWF5IGhhdmUgZGVsZXRlZCB0aGUgYXJyYXlcclxuXHRcdGlmICghYXJyKSB7IGxpc3RlbmVyc1t0eXBlXSA9IFtsaXN0ZW5lcl07ICB9XHJcblx0XHRlbHNlIHsgYXJyLnB1c2gobGlzdGVuZXIpOyB9XHJcblx0XHRyZXR1cm4gbGlzdGVuZXI7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBBIHNob3J0Y3V0IG1ldGhvZCBmb3IgdXNpbmcgYWRkRXZlbnRMaXN0ZW5lciB0aGF0IG1ha2VzIGl0IGVhc2llciB0byBzcGVjaWZ5IGFuIGV4ZWN1dGlvbiBzY29wZSwgaGF2ZSBhIGxpc3RlbmVyXHJcblx0ICogb25seSBydW4gb25jZSwgYXNzb2NpYXRlIGFyYml0cmFyeSBkYXRhIHdpdGggdGhlIGxpc3RlbmVyLCBhbmQgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHQgKiBcclxuXHQgKiBUaGlzIG1ldGhvZCB3b3JrcyBieSBjcmVhdGluZyBhbiBhbm9ueW1vdXMgd3JhcHBlciBmdW5jdGlvbiBhbmQgc3Vic2NyaWJpbmcgaXQgd2l0aCBhZGRFdmVudExpc3RlbmVyLlxyXG5cdCAqIFRoZSBjcmVhdGVkIGFub255bW91cyBmdW5jdGlvbiBpcyByZXR1cm5lZCBmb3IgdXNlIHdpdGggLnJlbW92ZUV2ZW50TGlzdGVuZXIgKG9yIC5vZmYpLlxyXG5cdCAqIFxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKiBcclxuXHQgKiBcdFx0dmFyIGxpc3RlbmVyID0gbXlCdG4ub24oXCJjbGlja1wiLCBoYW5kbGVDbGljaywgbnVsbCwgZmFsc2UsIHtjb3VudDozfSk7XHJcblx0ICogXHRcdGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2dCwgZGF0YSkge1xyXG5cdCAqIFx0XHRcdGRhdGEuY291bnQgLT0gMTtcclxuXHQgKiBcdFx0XHRjb25zb2xlLmxvZyh0aGlzID09IG15QnRuKTsgLy8gdHJ1ZSAtIHNjb3BlIGRlZmF1bHRzIHRvIHRoZSBkaXNwYXRjaGVyXHJcblx0ICogXHRcdFx0aWYgKGRhdGEuY291bnQgPT0gMCkge1xyXG5cdCAqIFx0XHRcdFx0YWxlcnQoXCJjbGlja2VkIDMgdGltZXMhXCIpO1xyXG5cdCAqIFx0XHRcdFx0bXlCdG4ub2ZmKFwiY2xpY2tcIiwgbGlzdGVuZXIpO1xyXG5cdCAqIFx0XHRcdFx0Ly8gYWx0ZXJuYXRlbHk6IGV2dC5yZW1vdmUoKTtcclxuXHQgKiBcdFx0XHR9XHJcblx0ICogXHRcdH1cclxuXHQgKiBcclxuXHQgKiBAbWV0aG9kIG9uXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBBbiBvYmplY3Qgd2l0aCBhIGhhbmRsZUV2ZW50IG1ldGhvZCwgb3IgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5cclxuXHQgKiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSBUaGUgc2NvcGUgdG8gZXhlY3V0ZSB0aGUgbGlzdGVuZXIgaW4uIERlZmF1bHRzIHRvIHRoZSBkaXNwYXRjaGVyL2N1cnJlbnRUYXJnZXQgZm9yIGZ1bmN0aW9uIGxpc3RlbmVycywgYW5kIHRvIHRoZSBsaXN0ZW5lciBpdHNlbGYgZm9yIG9iamVjdCBsaXN0ZW5lcnMgKGllLiB1c2luZyBoYW5kbGVFdmVudCkuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gSWYgdHJ1ZSwgdGhlIGxpc3RlbmVyIHdpbGwgcmVtb3ZlIGl0c2VsZiBhZnRlciB0aGUgZmlyc3QgdGltZSBpdCBpcyB0cmlnZ2VyZWQuXHJcblx0ICogQHBhcmFtIHsqfSBbZGF0YV0gQXJiaXRyYXJ5IGRhdGEgdGhhdCB3aWxsIGJlIGluY2x1ZGVkIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHdoZW4gdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlPWZhbHNlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXHJcblx0ICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgdGhlIGFub255bW91cyBmdW5jdGlvbiB0aGF0IHdhcyBjcmVhdGVkIGFuZCBhc3NpZ25lZCBhcyB0aGUgbGlzdGVuZXIuIFRoaXMgaXMgbmVlZGVkIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIgbGF0ZXIgdXNpbmcgLnJlbW92ZUV2ZW50TGlzdGVuZXIuXHJcblx0ICoqL1xyXG5cdHAub24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgc2NvcGUsIG9uY2UsIGRhdGEsIHVzZUNhcHR1cmUpIHtcclxuXHRcdGlmIChsaXN0ZW5lci5oYW5kbGVFdmVudCkge1xyXG5cdFx0XHRzY29wZSA9IHNjb3BlfHxsaXN0ZW5lcjtcclxuXHRcdFx0bGlzdGVuZXIgPSBsaXN0ZW5lci5oYW5kbGVFdmVudDtcclxuXHRcdH1cclxuXHRcdHNjb3BlID0gc2NvcGV8fHRoaXM7XHJcblx0XHRyZXR1cm4gdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmN0aW9uKGV2dCkge1xyXG5cdFx0XHRcdGxpc3RlbmVyLmNhbGwoc2NvcGUsIGV2dCwgZGF0YSk7XHJcblx0XHRcdFx0b25jZSYmZXZ0LnJlbW92ZSgpO1xyXG5cdFx0XHR9LCB1c2VDYXB0dXJlKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgZXZlbnQgbGlzdGVuZXIuXHJcblx0ICpcclxuXHQgKiA8Yj5JbXBvcnRhbnQgTm90ZTo8L2I+IHRoYXQgeW91IG11c3QgcGFzcyB0aGUgZXhhY3QgZnVuY3Rpb24gcmVmZXJlbmNlIHVzZWQgd2hlbiB0aGUgZXZlbnQgd2FzIGFkZGVkLiBJZiBhIHByb3h5XHJcblx0ICogZnVuY3Rpb24sIG9yIGZ1bmN0aW9uIGNsb3N1cmUgaXMgdXNlZCBhcyB0aGUgY2FsbGJhY2ssIHRoZSBwcm94eS9jbG9zdXJlIHJlZmVyZW5jZSBtdXN0IGJlIHVzZWQgLSBhIG5ldyBwcm94eSBvclxyXG5cdCAqIGNsb3N1cmUgd2lsbCBub3Qgd29yay5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gb3Igb2JqZWN0LlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdIEZvciBldmVudHMgdGhhdCBidWJibGUsIGluZGljYXRlcyB3aGV0aGVyIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50IGluIHRoZSBjYXB0dXJlIG9yIGJ1YmJsaW5nL3RhcmdldCBwaGFzZS5cclxuXHQgKiovXHJcblx0cC5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB1c2VDYXB0dXJlID8gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA6IHRoaXMuX2xpc3RlbmVycztcclxuXHRcdGlmICghbGlzdGVuZXJzKSB7IHJldHVybjsgfVxyXG5cdFx0dmFyIGFyciA9IGxpc3RlbmVyc1t0eXBlXTtcclxuXHRcdGlmICghYXJyKSB7IHJldHVybjsgfVxyXG5cdFx0Zm9yICh2YXIgaT0wLGw9YXJyLmxlbmd0aDsgaTxsOyBpKyspIHtcclxuXHRcdFx0aWYgKGFycltpXSA9PSBsaXN0ZW5lcikge1xyXG5cdFx0XHRcdGlmIChsPT0xKSB7IGRlbGV0ZShsaXN0ZW5lcnNbdHlwZV0pOyB9IC8vIGFsbG93cyBmb3IgZmFzdGVyIGNoZWNrcy5cclxuXHRcdFx0XHRlbHNlIHsgYXJyLnNwbGljZShpLDEpOyB9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEEgc2hvcnRjdXQgdG8gdGhlIHJlbW92ZUV2ZW50TGlzdGVuZXIgbWV0aG9kLCB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMgYW5kIHJldHVybiB2YWx1ZS4gVGhpcyBpcyBhIGNvbXBhbmlvbiB0byB0aGVcclxuXHQgKiAub24gbWV0aG9kLlxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBvZmZcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb24gfCBPYmplY3R9IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiBvciBvYmplY3QuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZV0gRm9yIGV2ZW50cyB0aGF0IGJ1YmJsZSwgaW5kaWNhdGVzIHdoZXRoZXIgdG8gbGlzdGVuIGZvciB0aGUgZXZlbnQgaW4gdGhlIGNhcHR1cmUgb3IgYnViYmxpbmcvdGFyZ2V0IHBoYXNlLlxyXG5cdCAqKi9cclxuXHRwLm9mZiA9IHAucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgc3BlY2lmaWVkIHR5cGUsIG9yIGFsbCBsaXN0ZW5lcnMgb2YgYWxsIHR5cGVzLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVyc1xyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5yZW1vdmVBbGxFdmVudExpc3RlbmVycygpO1xyXG5cdCAqXHJcblx0ICogICAgICAvLyBSZW1vdmUgYWxsIGNsaWNrIGxpc3RlbmVyc1xyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5yZW1vdmVBbGxFdmVudExpc3RlbmVycyhcImNsaWNrXCIpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCByZW1vdmVBbGxFdmVudExpc3RlbmVyc1xyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC4gSWYgb21pdHRlZCwgYWxsIGxpc3RlbmVycyBmb3IgYWxsIHR5cGVzIHdpbGwgYmUgcmVtb3ZlZC5cclxuXHQgKiovXHJcblx0cC5yZW1vdmVBbGxFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdGlmICghdHlwZSkgeyB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzID0gbnVsbDsgfVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGlmICh0aGlzLl9saXN0ZW5lcnMpIHsgZGVsZXRlKHRoaXMuX2xpc3RlbmVyc1t0eXBlXSk7IH1cclxuXHRcdFx0aWYgKHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMpIHsgZGVsZXRlKHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnNbdHlwZV0pOyB9XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogRGlzcGF0Y2hlcyB0aGUgc3BlY2lmaWVkIGV2ZW50IHRvIGFsbCBsaXN0ZW5lcnMuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIC8vIFVzZSBhIHN0cmluZyBldmVudFxyXG5cdCAqICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiY29tcGxldGVcIik7XHJcblx0ICpcclxuXHQgKiAgICAgIC8vIFVzZSBhbiBFdmVudCBpbnN0YW5jZVxyXG5cdCAqICAgICAgdmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwicHJvZ3Jlc3NcIik7XHJcblx0ICogICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBkaXNwYXRjaEV2ZW50XHJcblx0ICogQHBhcmFtIHtPYmplY3QgfCBTdHJpbmcgfCBFdmVudH0gZXZlbnRPYmogQW4gb2JqZWN0IHdpdGggYSBcInR5cGVcIiBwcm9wZXJ0eSwgb3IgYSBzdHJpbmcgdHlwZS5cclxuXHQgKiBXaGlsZSBhIGdlbmVyaWMgb2JqZWN0IHdpbGwgd29yaywgaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIGEgQ3JlYXRlSlMgRXZlbnQgaW5zdGFuY2UuIElmIGEgc3RyaW5nIGlzIHVzZWQsXHJcblx0ICogZGlzcGF0Y2hFdmVudCB3aWxsIGNvbnN0cnVjdCBhbiBFdmVudCBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgdHlwZS5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBldmVudE9iai5kZWZhdWx0UHJldmVudGVkLlxyXG5cdCAqKi9cclxuXHRwLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudE9iaikge1xyXG5cdFx0aWYgKHR5cGVvZiBldmVudE9iaiA9PSBcInN0cmluZ1wiKSB7XHJcblx0XHRcdC8vIHdvbid0IGJ1YmJsZSwgc28gc2tpcCBldmVyeXRoaW5nIGlmIHRoZXJlJ3Mgbm8gbGlzdGVuZXJzOlxyXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG5cdFx0XHRpZiAoIWxpc3RlbmVycyB8fCAhbGlzdGVuZXJzW2V2ZW50T2JqXSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0ZXZlbnRPYmogPSBuZXcgY3JlYXRlanMuRXZlbnQoZXZlbnRPYmopO1xyXG5cdFx0fSBlbHNlIGlmIChldmVudE9iai50YXJnZXQgJiYgZXZlbnRPYmouY2xvbmUpIHtcclxuXHRcdFx0Ly8gcmVkaXNwYXRjaGluZyBhbiBhY3RpdmUgZXZlbnQgb2JqZWN0LCBzbyBjbG9uZSBpdDpcclxuXHRcdFx0ZXZlbnRPYmogPSBldmVudE9iai5jbG9uZSgpO1xyXG5cdFx0fVxyXG5cdFx0dHJ5IHsgZXZlbnRPYmoudGFyZ2V0ID0gdGhpczsgfSBjYXRjaCAoZSkge30gLy8gdHJ5L2NhdGNoIGFsbG93cyByZWRpc3BhdGNoaW5nIG9mIG5hdGl2ZSBldmVudHNcclxuXHJcblx0XHRpZiAoIWV2ZW50T2JqLmJ1YmJsZXMgfHwgIXRoaXMucGFyZW50KSB7XHJcblx0XHRcdHRoaXMuX2Rpc3BhdGNoRXZlbnQoZXZlbnRPYmosIDIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHRvcD10aGlzLCBsaXN0PVt0b3BdO1xyXG5cdFx0XHR3aGlsZSAodG9wLnBhcmVudCkgeyBsaXN0LnB1c2godG9wID0gdG9wLnBhcmVudCk7IH1cclxuXHRcdFx0dmFyIGksIGw9bGlzdC5sZW5ndGg7XHJcblxyXG5cdFx0XHQvLyBjYXB0dXJlICYgYXRUYXJnZXRcclxuXHRcdFx0Zm9yIChpPWwtMTsgaT49MCAmJiAhZXZlbnRPYmoucHJvcGFnYXRpb25TdG9wcGVkOyBpLS0pIHtcclxuXHRcdFx0XHRsaXN0W2ldLl9kaXNwYXRjaEV2ZW50KGV2ZW50T2JqLCAxKyhpPT0wKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gYnViYmxpbmdcclxuXHRcdFx0Zm9yIChpPTE7IGk8bCAmJiAhZXZlbnRPYmoucHJvcGFnYXRpb25TdG9wcGVkOyBpKyspIHtcclxuXHRcdFx0XHRsaXN0W2ldLl9kaXNwYXRjaEV2ZW50KGV2ZW50T2JqLCAzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGV2ZW50T2JqLmRlZmF1bHRQcmV2ZW50ZWQ7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXHJcblx0ICogQG1ldGhvZCBoYXNFdmVudExpc3RlbmVyXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxyXG5cdCAqKi9cclxuXHRwLmhhc0V2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLCBjYXB0dXJlTGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVycztcclxuXHRcdHJldHVybiAhISgobGlzdGVuZXJzICYmIGxpc3RlbmVyc1t0eXBlXSkgfHwgKGNhcHR1cmVMaXN0ZW5lcnMgJiYgY2FwdHVyZUxpc3RlbmVyc1t0eXBlXSkpO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUgb24gdGhpcyBvYmplY3Qgb3IgYW55IG9mIGl0c1xyXG5cdCAqIGFuY2VzdG9ycyAocGFyZW50LCBwYXJlbnQncyBwYXJlbnQsIGV0YykuIEEgcmV0dXJuIHZhbHVlIG9mIHRydWUgaW5kaWNhdGVzIHRoYXQgaWYgYSBidWJibGluZyBldmVudCBvZiB0aGVcclxuXHQgKiBzcGVjaWZpZWQgdHlwZSBpcyBkaXNwYXRjaGVkIGZyb20gdGhpcyBvYmplY3QsIGl0IHdpbGwgdHJpZ2dlciBhdCBsZWFzdCBvbmUgbGlzdGVuZXIuXHJcblx0ICogXHJcblx0ICogVGhpcyBpcyBzaW1pbGFyIHRvIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9oYXNFdmVudExpc3RlbmVyXCJ9fXt7L2Nyb3NzTGlua319LCBidXQgaXQgc2VhcmNoZXMgdGhlIGVudGlyZVxyXG5cdCAqIGV2ZW50IGZsb3cgZm9yIGEgbGlzdGVuZXIsIG5vdCBqdXN0IHRoaXMgb2JqZWN0LlxyXG5cdCAqIEBtZXRob2Qgd2lsbFRyaWdnZXJcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cclxuXHQgKiovXHJcblx0cC53aWxsVHJpZ2dlciA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdHZhciBvID0gdGhpcztcclxuXHRcdHdoaWxlIChvKSB7XHJcblx0XHRcdGlmIChvLmhhc0V2ZW50TGlzdGVuZXIodHlwZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0byA9IG8ucGFyZW50O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cclxuXHQgKiovXHJcblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIFwiW0V2ZW50RGlzcGF0Y2hlcl1cIjtcclxuXHR9O1xyXG5cclxuXHJcbi8vIHByaXZhdGUgbWV0aG9kczpcclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIF9kaXNwYXRjaEV2ZW50XHJcblx0ICogQHBhcmFtIHtPYmplY3QgfCBTdHJpbmcgfCBFdmVudH0gZXZlbnRPYmpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRQaGFzZVxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiovXHJcblx0cC5fZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50T2JqLCBldmVudFBoYXNlKSB7XHJcblx0XHR2YXIgbCwgbGlzdGVuZXJzID0gKGV2ZW50UGhhc2U9PTEpID8gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA6IHRoaXMuX2xpc3RlbmVycztcclxuXHRcdGlmIChldmVudE9iaiAmJiBsaXN0ZW5lcnMpIHtcclxuXHRcdFx0dmFyIGFyciA9IGxpc3RlbmVyc1tldmVudE9iai50eXBlXTtcclxuXHRcdFx0aWYgKCFhcnJ8fCEobD1hcnIubGVuZ3RoKSkgeyByZXR1cm47IH1cclxuXHRcdFx0dHJ5IHsgZXZlbnRPYmouY3VycmVudFRhcmdldCA9IHRoaXM7IH0gY2F0Y2ggKGUpIHt9XHJcblx0XHRcdHRyeSB7IGV2ZW50T2JqLmV2ZW50UGhhc2UgPSBldmVudFBoYXNlOyB9IGNhdGNoIChlKSB7fVxyXG5cdFx0XHRldmVudE9iai5yZW1vdmVkID0gZmFsc2U7XHJcblx0XHRcdFxyXG5cdFx0XHRhcnIgPSBhcnIuc2xpY2UoKTsgLy8gdG8gYXZvaWQgaXNzdWVzIHdpdGggaXRlbXMgYmVpbmcgcmVtb3ZlZCBvciBhZGRlZCBkdXJpbmcgdGhlIGRpc3BhdGNoXHJcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsICYmICFldmVudE9iai5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ7IGkrKykge1xyXG5cdFx0XHRcdHZhciBvID0gYXJyW2ldO1xyXG5cdFx0XHRcdGlmIChvLmhhbmRsZUV2ZW50KSB7IG8uaGFuZGxlRXZlbnQoZXZlbnRPYmopOyB9XHJcblx0XHRcdFx0ZWxzZSB7IG8oZXZlbnRPYmopOyB9XHJcblx0XHRcdFx0aWYgKGV2ZW50T2JqLnJlbW92ZWQpIHtcclxuXHRcdFx0XHRcdHRoaXMub2ZmKGV2ZW50T2JqLnR5cGUsIG8sIGV2ZW50UGhhc2U9PTEpO1xyXG5cdFx0XHRcdFx0ZXZlbnRPYmoucmVtb3ZlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cclxuXHRjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIgPSBFdmVudERpc3BhdGNoZXI7XHJcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBQcm9ncmVzc0V2ZW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uIChzY29wZSkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBDcmVhdGVKUyB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGRpc3BhdGNoZWQgd2hlbiBwcm9ncmVzcyBjaGFuZ2VzLlxuXHQgKiBAY2xhc3MgUHJvZ3Jlc3NFdmVudFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbG9hZGVkIFRoZSBhbW91bnQgdGhhdCBoYXMgYmVlbiBsb2FkZWQuIFRoaXMgY2FuIGJlIGFueSBudW1iZXIgcmVsYXRpdmUgdG8gdGhlIHRvdGFsLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RvdGFsPTFdIFRoZSB0b3RhbCBhbW91bnQgdGhhdCB3aWxsIGxvYWQuIFRoaXMgd2lsbCBkZWZhdWx0IHRvIDEsIHNvIGlmIHRoZSBgbG9hZGVkYCB2YWx1ZSBpc1xuXHQgKiBhIHBlcmNlbnRhZ2UgKGJldHdlZW4gMCBhbmQgMSksIGl0IGNhbiBiZSBvbWl0dGVkLlxuXHQgKiBAdG9kbyBDb25zaWRlciBoYXZpbmcgdGhpcyBldmVudCBiZSBhIFwiZmlsZXByb2dyZXNzXCIgZXZlbnQgYXMgd2VsbFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFByb2dyZXNzRXZlbnQobG9hZGVkLCB0b3RhbCkge1xuXHRcdHRoaXMuRXZlbnRfY29uc3RydWN0b3IoXCJwcm9ncmVzc1wiKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBhbW91bnQgdGhhdCBoYXMgYmVlbiBsb2FkZWQgKG91dCBvZiBhIHRvdGFsIGFtb3VudClcblx0XHQgKiBAcHJvcGVydHkgbG9hZGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLmxvYWRlZCA9IGxvYWRlZDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0b3RhbCBcInNpemVcIiBvZiB0aGUgbG9hZC5cblx0XHQgKiBAcHJvcGVydHkgdG90YWxcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLnRvdGFsID0gKHRvdGFsID09IG51bGwpID8gMSA6IHRvdGFsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHBlcmNlbnRhZ2UgKG91dCBvZiAxKSB0aGF0IHRoZSBsb2FkIGhhcyBiZWVuIGNvbXBsZXRlZC4gVGhpcyBpcyBjYWxjdWxhdGVkIHVzaW5nIGBsb2FkZWQvdG90YWxgLlxuXHRcdCAqIEBwcm9wZXJ0eSBwcm9ncmVzc1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSAodG90YWwgPT0gMCkgPyAwIDogdGhpcy5sb2FkZWQgLyB0aGlzLnRvdGFsO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFByb2dyZXNzRXZlbnQsIGNyZWF0ZWpzLkV2ZW50KTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBQcm9ncmVzc0V2ZW50IGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge1Byb2dyZXNzRXZlbnR9IGEgY2xvbmUgb2YgdGhlIEV2ZW50IGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IGNyZWF0ZWpzLlByb2dyZXNzRXZlbnQodGhpcy5sb2FkZWQsIHRoaXMudG90YWwpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLlByb2dyZXNzRXZlbnQgPSBjcmVhdGVqcy5wcm9tb3RlKFByb2dyZXNzRXZlbnQsIFwiRXZlbnRcIik7XG5cbn0od2luZG93KSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBqc29uMy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuLyohIEpTT04gdjMuMy4yIHwgaHR0cDovL2Jlc3RpZWpzLmdpdGh1Yi5pby9qc29uMyB8IENvcHlyaWdodCAyMDEyLTIwMTQsIEtpdCBDYW1icmlkZ2UgfCBodHRwOi8va2l0Lm1pdC1saWNlbnNlLm9yZyAqL1xuOyhmdW5jdGlvbiAoKSB7XG4gIC8vIERldGVjdCB0aGUgYGRlZmluZWAgZnVuY3Rpb24gZXhwb3NlZCBieSBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuIFRoZVxuICAvLyBzdHJpY3QgYGRlZmluZWAgY2hlY2sgaXMgbmVjZXNzYXJ5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggYHIuanNgLlxuICB2YXIgaXNMb2FkZXIgPSB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZDtcblxuICAvLyBBIHNldCBvZiB0eXBlcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIG9iamVjdHMgZnJvbSBwcmltaXRpdmVzLlxuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgIFwib2JqZWN0XCI6IHRydWVcbiAgfTtcblxuICAvLyBEZXRlY3QgdGhlIGBleHBvcnRzYCBvYmplY3QgZXhwb3NlZCBieSBDb21tb25KUyBpbXBsZW1lbnRhdGlvbnMuXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLy8gVXNlIHRoZSBgZ2xvYmFsYCBvYmplY3QgZXhwb3NlZCBieSBOb2RlIChpbmNsdWRpbmcgQnJvd3NlcmlmeSB2aWFcbiAgLy8gYGluc2VydC1tb2R1bGUtZ2xvYmFsc2ApLCBOYXJ3aGFsLCBhbmQgUmluZ28gYXMgdGhlIGRlZmF1bHQgY29udGV4dCxcbiAgLy8gYW5kIHRoZSBgd2luZG93YCBvYmplY3QgaW4gYnJvd3NlcnMuIFJoaW5vIGV4cG9ydHMgYSBgZ2xvYmFsYCBmdW5jdGlvblxuICAvLyBpbnN0ZWFkLlxuICB2YXIgcm9vdCA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyB8fCB0aGlzLFxuICAgICAgZnJlZUdsb2JhbCA9IGZyZWVFeHBvcnRzICYmIG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIHR5cGVvZiBnbG9iYWwgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWw7XG5cbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWxbXCJnbG9iYWxcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcIndpbmRvd1wiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wic2VsZlwiXSA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8vIFB1YmxpYzogSW5pdGlhbGl6ZXMgSlNPTiAzIHVzaW5nIHRoZSBnaXZlbiBgY29udGV4dGAgb2JqZWN0LCBhdHRhY2hpbmcgdGhlXG4gIC8vIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGZ1bmN0aW9ucyB0byB0aGUgc3BlY2lmaWVkIGBleHBvcnRzYCBvYmplY3QuXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0LCBleHBvcnRzKSB7XG4gICAgY29udGV4dCB8fCAoY29udGV4dCA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG4gICAgZXhwb3J0cyB8fCAoZXhwb3J0cyA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG5cbiAgICAvLyBOYXRpdmUgY29uc3RydWN0b3IgYWxpYXNlcy5cbiAgICB2YXIgTnVtYmVyID0gY29udGV4dFtcIk51bWJlclwiXSB8fCByb290W1wiTnVtYmVyXCJdLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0W1wiU3RyaW5nXCJdIHx8IHJvb3RbXCJTdHJpbmdcIl0sXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHRbXCJPYmplY3RcIl0gfHwgcm9vdFtcIk9iamVjdFwiXSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHRbXCJEYXRlXCJdIHx8IHJvb3RbXCJEYXRlXCJdLFxuICAgICAgICBTeW50YXhFcnJvciA9IGNvbnRleHRbXCJTeW50YXhFcnJvclwiXSB8fCByb290W1wiU3ludGF4RXJyb3JcIl0sXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHRbXCJUeXBlRXJyb3JcIl0gfHwgcm9vdFtcIlR5cGVFcnJvclwiXSxcbiAgICAgICAgTWF0aCA9IGNvbnRleHRbXCJNYXRoXCJdIHx8IHJvb3RbXCJNYXRoXCJdLFxuICAgICAgICBuYXRpdmVKU09OID0gY29udGV4dFtcIkpTT05cIl0gfHwgcm9vdFtcIkpTT05cIl07XG5cbiAgICAvLyBEZWxlZ2F0ZSB0byB0aGUgbmF0aXZlIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGltcGxlbWVudGF0aW9ucy5cbiAgICBpZiAodHlwZW9mIG5hdGl2ZUpTT04gPT0gXCJvYmplY3RcIiAmJiBuYXRpdmVKU09OKSB7XG4gICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IG5hdGl2ZUpTT04uc3RyaW5naWZ5O1xuICAgICAgZXhwb3J0cy5wYXJzZSA9IG5hdGl2ZUpTT04ucGFyc2U7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgYWxpYXNlcy5cbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBnZXRDbGFzcyA9IG9iamVjdFByb3RvLnRvU3RyaW5nLFxuICAgICAgICBpc1Byb3BlcnR5LCBmb3JFYWNoLCB1bmRlZjtcblxuICAgIC8vIFRlc3QgdGhlIGBEYXRlI2dldFVUQypgIG1ldGhvZHMuIEJhc2VkIG9uIHdvcmsgYnkgQFlhZmZsZS5cbiAgICB2YXIgaXNFeHRlbmRlZCA9IG5ldyBEYXRlKC0zNTA5ODI3MzM0NTczMjkyKTtcbiAgICB0cnkge1xuICAgICAgLy8gVGhlIGBnZXRVVENGdWxsWWVhcmAsIGBNb250aGAsIGFuZCBgRGF0ZWAgbWV0aG9kcyByZXR1cm4gbm9uc2Vuc2ljYWxcbiAgICAgIC8vIHJlc3VsdHMgZm9yIGNlcnRhaW4gZGF0ZXMgaW4gT3BlcmEgPj0gMTAuNTMuXG4gICAgICBpc0V4dGVuZGVkID0gaXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpID09IC0xMDkyNTIgJiYgaXNFeHRlbmRlZC5nZXRVVENNb250aCgpID09PSAwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpID09PSAxICYmXG4gICAgICAgIC8vIFNhZmFyaSA8IDIuMC4yIHN0b3JlcyB0aGUgaW50ZXJuYWwgbWlsbGlzZWNvbmQgdGltZSB2YWx1ZSBjb3JyZWN0bHksXG4gICAgICAgIC8vIGJ1dCBjbGlwcyB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBkYXRlIG1ldGhvZHMgdG8gdGhlIHJhbmdlIG9mXG4gICAgICAgIC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cbiAgICAgICAgaXNFeHRlbmRlZC5nZXRVVENIb3VycygpID09IDEwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWludXRlcygpID09IDM3ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDU2Vjb25kcygpID09IDYgJiYgaXNFeHRlbmRlZC5nZXRVVENNaWxsaXNlY29uZHMoKSA9PSA3MDg7XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXG4gICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgd2hldGhlciB0aGUgbmF0aXZlIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBwYXJzZWBcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgYXJlIHNwZWMtY29tcGxpYW50LiBCYXNlZCBvbiB3b3JrIGJ5IEtlbiBTbnlkZXIuXG4gICAgZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICAgIGlmIChoYXNbbmFtZV0gIT09IHVuZGVmKSB7XG4gICAgICAgIC8vIFJldHVybiBjYWNoZWQgZmVhdHVyZSB0ZXN0IHJlc3VsdC5cbiAgICAgICAgcmV0dXJuIGhhc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1N1cHBvcnRlZDtcbiAgICAgIGlmIChuYW1lID09IFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpIHtcbiAgICAgICAgLy8gSUUgPD0gNyBkb2Vzbid0IHN1cHBvcnQgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIHVzaW5nIHNxdWFyZVxuICAgICAgICAvLyBicmFja2V0IG5vdGF0aW9uLiBJRSA4IG9ubHkgc3VwcG9ydHMgdGhpcyBmb3IgcHJpbWl0aXZlcy5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBcImFcIlswXSAhPSBcImFcIjtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImpzb25cIikge1xuICAgICAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciBib3RoIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBKU09OLnBhcnNlYCBhcmVcbiAgICAgICAgLy8gc3VwcG9ydGVkLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IGhhcyhcImpzb24tc3RyaW5naWZ5XCIpICYmIGhhcyhcImpzb24tcGFyc2VcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUsIHNlcmlhbGl6ZWQgPSAne1wiYVwiOlsxLHRydWUsZmFsc2UsbnVsbCxcIlxcXFx1MDAwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcIl19JztcbiAgICAgICAgLy8gVGVzdCBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tc3RyaW5naWZ5XCIpIHtcbiAgICAgICAgICB2YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnksIHN0cmluZ2lmeVN1cHBvcnRlZCA9IHR5cGVvZiBzdHJpbmdpZnkgPT0gXCJmdW5jdGlvblwiICYmIGlzRXh0ZW5kZWQ7XG4gICAgICAgICAgaWYgKHN0cmluZ2lmeVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgLy8gQSB0ZXN0IGZ1bmN0aW9uIG9iamVjdCB3aXRoIGEgY3VzdG9tIGB0b0pTT05gIG1ldGhvZC5cbiAgICAgICAgICAgICh2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9KS50b0pTT04gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCAzLjFiMSBhbmQgYjIgc2VyaWFsaXplIHN0cmluZywgbnVtYmVyLCBhbmQgYm9vbGVhblxuICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZXMgYXMgb2JqZWN0IGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgwKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIsIGFuZCBKU09OIDIgc2VyaWFsaXplIHdyYXBwZWQgcHJpbWl0aXZlcyBhcyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IE51bWJlcigpKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IFN0cmluZygpKSA9PSAnXCJcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3JcbiAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBkZWZpbmUgYSBjYW5vbmljYWwgSlNPTiByZXByZXNlbnRhdGlvbiAodGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGB0b0pTT05gIHByb3BlcnRpZXMgYXMgd2VsbCwgKnVubGVzcyogdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gd2l0aGluIGFuIG9iamVjdCBvciBhcnJheSkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KGdldENsYXNzKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBJRSA4IHNlcmlhbGl6ZXMgYHVuZGVmaW5lZGAgYXMgYFwidW5kZWZpbmVkXCJgLiBTYWZhcmkgPD0gNS4xLjcgYW5kXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjMgcGFzcyB0aGlzIHRlc3QuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHVuZGVmKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjcgYW5kIEZGIDMuMWIzIHRocm93IGBFcnJvcmBzIGFuZCBgVHlwZUVycm9yYHMsXG4gICAgICAgICAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LCBpZiB0aGUgdmFsdWUgaXMgb21pdHRlZCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgbnVtYmVyLFxuICAgICAgICAgICAgICAgIC8vIHN0cmluZywgYXJyYXksIG9iamVjdCwgQm9vbGVhbiwgb3IgYG51bGxgIGxpdGVyYWwuIFRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcyBhcyB3ZWxsLCB1bmxlc3MgdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIG9iamVjdCBvciBhcnJheSBsaXRlcmFscy4gWVVJIDMuMC4wYjEgaWdub3JlcyBjdXN0b20gYHRvSlNPTmBcbiAgICAgICAgICAgICAgICAvLyBtZXRob2RzIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt2YWx1ZV0pID09IFwiWzFdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgc2VyaWFsaXplcyBgW3VuZGVmaW5lZF1gIGFzIGBcIltdXCJgIGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAgICAvLyBgXCJbbnVsbF1cImAuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZl0pID09IFwiW251bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBZVUkgMy4wLjBiMSBmYWlscyB0byBzZXJpYWxpemUgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsKSA9PSBcIm51bGxcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIGhhbHRzIHNlcmlhbGl6YXRpb24gaWYgYW4gYXJyYXkgY29udGFpbnMgYSBmdW5jdGlvbjpcbiAgICAgICAgICAgICAgICAvLyBgWzEsIHRydWUsIGdldENsYXNzLCAxXWAgc2VyaWFsaXplcyBhcyBcIlsxLHRydWUsXSxcIi4gRkYgMy4xYjNcbiAgICAgICAgICAgICAgICAvLyBlbGlkZXMgbm9uLUpTT04gdmFsdWVzIGZyb20gb2JqZWN0cyBhbmQgYXJyYXlzLCB1bmxlc3MgdGhleVxuICAgICAgICAgICAgICAgIC8vIGRlZmluZSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmLCBnZXRDbGFzcywgbnVsbF0pID09IFwiW251bGwsbnVsbCxudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHNlcmlhbGl6YXRpb24gdGVzdC4gRkYgMy4xYjEgdXNlcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZXNcbiAgICAgICAgICAgICAgICAvLyB3aGVyZSBjaGFyYWN0ZXIgZXNjYXBlIGNvZGVzIGFyZSBleHBlY3RlZCAoZS5nLiwgYFxcYmAgPT4gYFxcdTAwMDhgKS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoeyBcImFcIjogW3ZhbHVlLCB0cnVlLCBmYWxzZSwgbnVsbCwgXCJcXHgwMFxcYlxcblxcZlxcclxcdFwiXSB9KSA9PSBzZXJpYWxpemVkICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEgYW5kIGIyIGlnbm9yZSB0aGUgYGZpbHRlcmAgYW5kIGB3aWR0aGAgYXJndW1lbnRzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsLCB2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFsxLCAyXSwgbnVsbCwgMSkgPT0gXCJbXFxuIDEsXFxuIDJcXG5dXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBKU09OIDIsIFByb3RvdHlwZSA8PSAxLjcsIGFuZCBvbGRlciBXZWJLaXQgYnVpbGRzIGluY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIGV4dGVuZGVkIHllYXJzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtOC42NGUxNSkpID09ICdcIi0yNzE4MjEtMDQtMjBUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFRoZSBtaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKDguNjRlMTUpKSA9PSAnXCIrMjc1NzYwLTA5LTEzVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDw9IDExLjAgaW5jb3JyZWN0bHkgc2VyaWFsaXplcyB5ZWFycyBwcmlvciB0byAwIGFzIG5lZ2F0aXZlXG4gICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCB5ZWFycyBpbnN0ZWFkIG9mIHNpeC1kaWdpdCB5ZWFycy4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTYyMTk4NzU1MmU1KSkgPT0gJ1wiLTAwMDAwMS0wMS0wMVQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS41IGFuZCBPcGVyYSA+PSAxMC41MyBpbmNvcnJlY3RseSBzZXJpYWxpemUgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgbGVzcyB0aGFuIDEwMDAuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC0xKSkgPT0gJ1wiMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaXCInO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHN0cmluZ2lmeVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXN0IGBKU09OLnBhcnNlYC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXBhcnNlXCIpIHtcbiAgICAgICAgICB2YXIgcGFyc2UgPSBleHBvcnRzLnBhcnNlO1xuICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2UgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYSBiYXJlIGxpdGVyYWwgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgIC8vIENvbmZvcm1pbmcgaW1wbGVtZW50YXRpb25zIHNob3VsZCBhbHNvIGNvZXJjZSB0aGUgaW5pdGlhbCBhcmd1bWVudCB0b1xuICAgICAgICAgICAgICAvLyBhIHN0cmluZyBwcmlvciB0byBwYXJzaW5nLlxuICAgICAgICAgICAgICBpZiAocGFyc2UoXCIwXCIpID09PSAwICYmICFwYXJzZShmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgcGFyc2luZyB0ZXN0LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlU3VwcG9ydGVkID0gdmFsdWVbXCJhXCJdLmxlbmd0aCA9PSA1ICYmIHZhbHVlW1wiYVwiXVswXSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuMiBhbmQgRkYgMy4xYjEgYWxsb3cgdW5lc2NhcGVkIHRhYnMgaW4gc3RyaW5ncy5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSAhcGFyc2UoJ1wiXFx0XCInKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCBhbmQgNC4wLjEgYWxsb3cgbGVhZGluZyBgK2Agc2lnbnMgYW5kIGxlYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNpbWFsIHBvaW50cy4gRkYgNC4wLCA0LjAuMSwgYW5kIElFIDktMTAgYWxzbyBhbGxvd1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjAxXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAsIDQuMC4xLCBhbmQgUmhpbm8gMS43UjMtUjQgYWxsb3cgdHJhaWxpbmcgZGVjaW1hbFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50cy4gVGhlc2UgZW52aXJvbm1lbnRzLCBhbG9uZyB3aXRoIEZGIDMuMWIxIGFuZCAyLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzIGluIEpTT04gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIxLlwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gcGFyc2VTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNbbmFtZV0gPSAhIWlzU3VwcG9ydGVkO1xuICAgIH1cblxuICAgIGlmICghaGFzKFwianNvblwiKSkge1xuICAgICAgLy8gQ29tbW9uIGBbW0NsYXNzXV1gIG5hbWUgYWxpYXNlcy5cbiAgICAgIHZhciBmdW5jdGlvbkNsYXNzID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLFxuICAgICAgICAgIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiLFxuICAgICAgICAgIG51bWJlckNsYXNzID0gXCJbb2JqZWN0IE51bWJlcl1cIixcbiAgICAgICAgICBzdHJpbmdDbGFzcyA9IFwiW29iamVjdCBTdHJpbmddXCIsXG4gICAgICAgICAgYXJyYXlDbGFzcyA9IFwiW29iamVjdCBBcnJheV1cIixcbiAgICAgICAgICBib29sZWFuQ2xhc3MgPSBcIltvYmplY3QgQm9vbGVhbl1cIjtcblxuICAgICAgLy8gRGV0ZWN0IGluY29tcGxldGUgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxuICAgICAgdmFyIGNoYXJJbmRleEJ1Z2d5ID0gaGFzKFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpO1xuXG4gICAgICAvLyBEZWZpbmUgYWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMgaWYgdGhlIGBEYXRlYCBtZXRob2RzIGFyZSBidWdneS5cbiAgICAgIGlmICghaXNFeHRlbmRlZCkge1xuICAgICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgICAgICAvLyBBIG1hcHBpbmcgYmV0d2VlbiB0aGUgbW9udGhzIG9mIHRoZSB5ZWFyIGFuZCB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlblxuICAgICAgICAvLyBKYW51YXJ5IDFzdCBhbmQgdGhlIGZpcnN0IG9mIHRoZSByZXNwZWN0aXZlIG1vbnRoLlxuICAgICAgICB2YXIgTW9udGhzID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcbiAgICAgICAgLy8gSW50ZXJuYWw6IENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdGhlIFVuaXggZXBvY2ggYW5kIHRoZVxuICAgICAgICAvLyBmaXJzdCBkYXkgb2YgdGhlIGdpdmVuIG1vbnRoLlxuICAgICAgICB2YXIgZ2V0RGF5ID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG4gICAgICAgICAgcmV0dXJuIE1vbnRoc1ttb250aF0gKyAzNjUgKiAoeWVhciAtIDE5NzApICsgZmxvb3IoKHllYXIgLSAxOTY5ICsgKG1vbnRoID0gKyhtb250aCA+IDEpKSkgLyA0KSAtIGZsb29yKCh5ZWFyIC0gMTkwMSArIG1vbnRoKSAvIDEwMCkgKyBmbG9vcigoeWVhciAtIDE2MDEgKyBtb250aCkgLyA0MDApO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyBpZiBhIHByb3BlcnR5IGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIHRoZSBnaXZlblxuICAgICAgLy8gb2JqZWN0LiBEZWxlZ2F0ZXMgdG8gdGhlIG5hdGl2ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBtZXRob2QuXG4gICAgICBpZiAoIShpc1Byb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHkpKSB7XG4gICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBjb25zdHJ1Y3RvcjtcbiAgICAgICAgICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XG4gICAgICAgICAgICAvLyBUaGUgKnByb3RvKiBwcm9wZXJ0eSBjYW5ub3QgYmUgc2V0IG11bHRpcGxlIHRpbWVzIGluIHJlY2VudFxuICAgICAgICAgICAgLy8gdmVyc2lvbnMgb2YgRmlyZWZveCBhbmQgU2VhTW9ua2V5LlxuICAgICAgICAgICAgXCJ0b1N0cmluZ1wiOiAxXG4gICAgICAgICAgfSwgbWVtYmVycykudG9TdHJpbmcgIT0gZ2V0Q2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuMyBkb2Vzbid0IGltcGxlbWVudCBgT2JqZWN0I2hhc093blByb3BlcnR5YCwgYnV0XG4gICAgICAgICAgICAvLyBzdXBwb3J0cyB0aGUgbXV0YWJsZSAqcHJvdG8qIHByb3BlcnR5LlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAvLyBDYXB0dXJlIGFuZCBicmVhayB0aGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIChzZWUgc2VjdGlvbiA4LjYuMlxuICAgICAgICAgICAgICAvLyBvZiB0aGUgRVMgNS4xIHNwZWMpLiBUaGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIHByZXZlbnRzIGFuXG4gICAgICAgICAgICAgIC8vIHVuc2FmZSB0cmFuc2Zvcm1hdGlvbiBieSB0aGUgQ2xvc3VyZSBDb21waWxlci5cbiAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcy5fX3Byb3RvX18sIHJlc3VsdCA9IHByb3BlcnR5IGluICh0aGlzLl9fcHJvdG9fXyA9IG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gb3JpZ2luYWw7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDYXB0dXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbGV2ZWwgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IG1lbWJlcnMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgdG8gc2ltdWxhdGUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW5cbiAgICAgICAgICAgIC8vIG90aGVyIGVudmlyb25tZW50cy5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9ICh0aGlzLmNvbnN0cnVjdG9yIHx8IGNvbnN0cnVjdG9yKS5wcm90b3R5cGU7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmICEocHJvcGVydHkgaW4gcGFyZW50ICYmIHRoaXNbcHJvcGVydHldID09PSBwYXJlbnRbcHJvcGVydHldKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lbWJlcnMgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBpc1Byb3BlcnR5LmNhbGwodGhpcywgcHJvcGVydHkpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogTm9ybWFsaXplcyB0aGUgYGZvci4uLmluYCBpdGVyYXRpb24gYWxnb3JpdGhtIGFjcm9zc1xuICAgICAgLy8gZW52aXJvbm1lbnRzLiBFYWNoIGVudW1lcmF0ZWQga2V5IGlzIHlpZWxkZWQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLlxuICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzaXplID0gMCwgUHJvcGVydGllcywgbWVtYmVycywgcHJvcGVydHk7XG5cbiAgICAgICAgLy8gVGVzdHMgZm9yIGJ1Z3MgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQncyBgZm9yLi4uaW5gIGFsZ29yaXRobS4gVGhlXG4gICAgICAgIC8vIGB2YWx1ZU9mYCBwcm9wZXJ0eSBpbmhlcml0cyB0aGUgbm9uLWVudW1lcmFibGUgZmxhZyBmcm9tXG4gICAgICAgIC8vIGBPYmplY3QucHJvdG90eXBlYCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgTmV0c2NhcGUsIGFuZCBNb3ppbGxhLlxuICAgICAgICAoUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlT2YgPSAwO1xuICAgICAgICB9KS5wcm90b3R5cGUudmFsdWVPZiA9IDA7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUHJvcGVydGllc2AgY2xhc3MuXG4gICAgICAgIG1lbWJlcnMgPSBuZXcgUHJvcGVydGllcygpO1xuICAgICAgICBmb3IgKHByb3BlcnR5IGluIG1lbWJlcnMpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgYWxsIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIGlmIChpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFByb3BlcnRpZXMgPSBtZW1iZXJzID0gbnVsbDtcblxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGl0ZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgIC8vIEEgbGlzdCBvZiBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBtZW1iZXJzID0gW1widmFsdWVPZlwiLCBcInRvU3RyaW5nXCIsIFwidG9Mb2NhbGVTdHJpbmdcIiwgXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLCBcImlzUHJvdG90eXBlT2ZcIiwgXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdO1xuICAgICAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxuICAgICAgICAgIC8vIHByb3BlcnRpZXMuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgbGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGhhc1Byb3BlcnR5ID0gIWlzRnVuY3Rpb24gJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciAhPSBcImZ1bmN0aW9uXCIgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eV0gJiYgb2JqZWN0Lmhhc093blByb3BlcnR5IHx8IGlzUHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBHZWNrbyA8PSAxLjAgZW51bWVyYXRlcyB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHVuZGVyXG4gICAgICAgICAgICAgIC8vIGNlcnRhaW4gY29uZGl0aW9uczsgSUUgZG9lcyBub3QuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gbWVtYmVycy5sZW5ndGg7IHByb3BlcnR5ID0gbWVtYmVyc1stLWxlbmd0aF07IGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgY2FsbGJhY2socHJvcGVydHkpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHNpemUgPT0gMikge1xuICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuNCBlbnVtZXJhdGVzIHNoYWRvd2VkIHByb3BlcnRpZXMgdHdpY2UuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzZXQgb2YgaXRlcmF0ZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBTdG9yZSBlYWNoIHByb3BlcnR5IG5hbWUgdG8gcHJldmVudCBkb3VibGUgZW51bWVyYXRpb24uIFRoZVxuICAgICAgICAgICAgICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxuICAgICAgICAgICAgICAvLyBlbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgIWlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkgJiYgKG1lbWJlcnNbcHJvcGVydHldID0gMSkgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGlzQ29uc3RydWN0b3I7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiAhKGlzQ29uc3RydWN0b3IgPSBwcm9wZXJ0eSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgZHVlIHRvXG4gICAgICAgICAgICAvLyBjcm9zcy1lbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciB8fCBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCAocHJvcGVydHkgPSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFB1YmxpYzogU2VyaWFsaXplcyBhIEphdmFTY3JpcHQgYHZhbHVlYCBhcyBhIEpTT04gc3RyaW5nLiBUaGUgb3B0aW9uYWxcbiAgICAgIC8vIGBmaWx0ZXJgIGFyZ3VtZW50IG1heSBzcGVjaWZ5IGVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgYWx0ZXJzIGhvdyBvYmplY3QgYW5kXG4gICAgICAvLyBhcnJheSBtZW1iZXJzIGFyZSBzZXJpYWxpemVkLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBudW1iZXJzIHRoYXRcbiAgICAgIC8vIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgb3B0aW9uYWwgYHdpZHRoYFxuICAgICAgLy8gYXJndW1lbnQgbWF5IGJlIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXG4gICAgICAvLyBsZXZlbCBvZiB0aGUgb3V0cHV0LlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSkge1xuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgRXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXFxcXFwiJyxcbiAgICAgICAgICA4OiBcIlxcXFxiXCIsXG4gICAgICAgICAgMTI6IFwiXFxcXGZcIixcbiAgICAgICAgICAxMDogXCJcXFxcblwiLFxuICAgICAgICAgIDEzOiBcIlxcXFxyXCIsXG4gICAgICAgICAgOTogXCJcXFxcdFwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IENvbnZlcnRzIGB2YWx1ZWAgaW50byBhIHplcm8tcGFkZGVkIHN0cmluZyBzdWNoIHRoYXQgaXRzXG4gICAgICAgIC8vIGxlbmd0aCBpcyBhdCBsZWFzdCBlcXVhbCB0byBgd2lkdGhgLiBUaGUgYHdpZHRoYCBtdXN0IGJlIDw9IDYuXG4gICAgICAgIHZhciBsZWFkaW5nWmVyb2VzID0gXCIwMDAwMDBcIjtcbiAgICAgICAgdmFyIHRvUGFkZGVkU3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoLCB2YWx1ZSkge1xuICAgICAgICAgIC8vIFRoZSBgfHwgMGAgZXhwcmVzc2lvbiBpcyBuZWNlc3NhcnkgdG8gd29yayBhcm91bmQgYSBidWcgaW5cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgd2hlcmUgYDAgPT0gLTBgLCBidXQgYFN0cmluZygtMCkgIT09IFwiMFwiYC5cbiAgICAgICAgICByZXR1cm4gKGxlYWRpbmdaZXJvZXMgKyAodmFsdWUgfHwgMCkpLnNsaWNlKC13aWR0aCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgKGNoYXJhY3RlcnMgd2l0aCBjb2RlIHVuaXQgdmFsdWVzIGJldHdlZW4gMCBhbmQgMzEpIHdpdGhcbiAgICAgICAgLy8gdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgdmFyIHVuaWNvZGVQcmVmaXggPSBcIlxcXFx1MDBcIjtcbiAgICAgICAgdmFyIHF1b3RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICdcIicsIGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCB1c2VDaGFySW5kZXggPSAhY2hhckluZGV4QnVnZ3kgfHwgbGVuZ3RoID4gMTA7XG4gICAgICAgICAgdmFyIHN5bWJvbHMgPSB1c2VDaGFySW5kZXggJiYgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuc3BsaXQoXCJcIikgOiB2YWx1ZSk7XG4gICAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBjb250cm9sIGNoYXJhY3RlciwgYXBwZW5kIGl0cyBVbmljb2RlIG9yXG4gICAgICAgICAgICAvLyBzaG9ydGhhbmQgZXNjYXBlIHNlcXVlbmNlOyBvdGhlcndpc2UsIGFwcGVuZCB0aGUgY2hhcmFjdGVyIGFzLWlzLlxuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDg6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMjogY2FzZSAxMzogY2FzZSAzNDogY2FzZSA5MjpcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gRXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1bmljb2RlUHJlZml4ICsgdG9QYWRkZWRTdHJpbmcoMiwgY2hhckNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdXNlQ2hhckluZGV4ID8gc3ltYm9sc1tpbmRleF0gOiB2YWx1ZS5jaGFyQXQoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ1wiJztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgc2VyaWFsaXplcyBhbiBvYmplY3QuIEltcGxlbWVudHMgdGhlXG4gICAgICAgIC8vIGBTdHIoa2V5LCBob2xkZXIpYCwgYEpPKHZhbHVlKWAsIGFuZCBgSkEodmFsdWUpYCBvcGVyYXRpb25zLlxuICAgICAgICB2YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKHByb3BlcnR5LCBvYmplY3QsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUsIGNsYXNzTmFtZSwgeWVhciwgbW9udGgsIGRhdGUsIHRpbWUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIHJlc3VsdHMsIGVsZW1lbnQsIGluZGV4LCBsZW5ndGgsIHByZWZpeCwgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBOZWNlc3NhcnkgZm9yIGhvc3Qgb2JqZWN0IHN1cHBvcnQuXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGRhdGVDbGFzcyAmJiAhaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCkge1xuICAgICAgICAgICAgICAgIC8vIERhdGVzIGFyZSBzZXJpYWxpemVkIGFjY29yZGluZyB0byB0aGUgYERhdGUjdG9KU09OYCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuOS41LjQ0LiBTZWUgc2VjdGlvbiAxNS45LjEuMTVcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0LlxuICAgICAgICAgICAgICAgIGlmIChnZXREYXkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGNvbXB1dGUgdGhlIHllYXIsIG1vbnRoLCBkYXRlLCBob3VycywgbWludXRlcyxcbiAgICAgICAgICAgICAgICAgIC8vIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgaWYgdGhlIGBnZXRVVEMqYCBtZXRob2RzIGFyZVxuICAgICAgICAgICAgICAgICAgLy8gYnVnZ3kuIEFkYXB0ZWQgZnJvbSBAWWFmZmxlJ3MgYGRhdGUtc2hpbWAgcHJvamVjdC5cbiAgICAgICAgICAgICAgICAgIGRhdGUgPSBmbG9vcih2YWx1ZSAvIDg2NGU1KTtcbiAgICAgICAgICAgICAgICAgIGZvciAoeWVhciA9IGZsb29yKGRhdGUgLyAzNjUuMjQyNSkgKyAxOTcwIC0gMTsgZ2V0RGF5KHllYXIgKyAxLCAwKSA8PSBkYXRlOyB5ZWFyKyspO1xuICAgICAgICAgICAgICAgICAgZm9yIChtb250aCA9IGZsb29yKChkYXRlIC0gZ2V0RGF5KHllYXIsIDApKSAvIDMwLjQyKTsgZ2V0RGF5KHllYXIsIG1vbnRoICsgMSkgPD0gZGF0ZTsgbW9udGgrKyk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gMSArIGRhdGUgLSBnZXREYXkoeWVhciwgbW9udGgpO1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGB0aW1lYCB2YWx1ZSBzcGVjaWZpZXMgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkgKHNlZSBFU1xuICAgICAgICAgICAgICAgICAgLy8gNS4xIHNlY3Rpb24gMTUuOS4xLjIpLiBUaGUgZm9ybXVsYSBgKEEgJSBCICsgQikgJSBCYCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgICAvLyB0byBjb21wdXRlIGBBIG1vZHVsbyBCYCwgYXMgdGhlIGAlYCBvcGVyYXRvciBkb2VzIG5vdFxuICAgICAgICAgICAgICAgICAgLy8gY29ycmVzcG9uZCB0byB0aGUgYG1vZHVsb2Agb3BlcmF0aW9uIGZvciBuZWdhdGl2ZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgdGltZSA9ICh2YWx1ZSAlIDg2NGU1ICsgODY0ZTUpICUgODY0ZTU7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgYXJlIG9idGFpbmVkIGJ5XG4gICAgICAgICAgICAgICAgICAvLyBkZWNvbXBvc2luZyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheS4gU2VlIHNlY3Rpb24gMTUuOS4xLjEwLlxuICAgICAgICAgICAgICAgICAgaG91cnMgPSBmbG9vcih0aW1lIC8gMzZlNSkgJSAyNDtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBmbG9vcih0aW1lIC8gNmU0KSAlIDYwO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IGZsb29yKHRpbWUgLyAxZTMpICUgNjA7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aW1lICUgMWUzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB5ZWFyID0gdmFsdWUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICAgIG1vbnRoID0gdmFsdWUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSB2YWx1ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgICAgICAgICAgICBob3VycyA9IHZhbHVlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gdmFsdWUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IHZhbHVlLmdldFVUQ1NlY29uZHMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gKHllYXIgPD0gMCB8fCB5ZWFyID49IDFlNCA/ICh5ZWFyIDwgMCA/IFwiLVwiIDogXCIrXCIpICsgdG9QYWRkZWRTdHJpbmcoNiwgeWVhciA8IDAgPyAteWVhciA6IHllYXIpIDogdG9QYWRkZWRTdHJpbmcoNCwgeWVhcikpICtcbiAgICAgICAgICAgICAgICAgIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbW9udGggKyAxKSArIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgZGF0ZSkgK1xuICAgICAgICAgICAgICAgICAgLy8gTW9udGhzLCBkYXRlcywgaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzIHNob3VsZCBoYXZlIHR3b1xuICAgICAgICAgICAgICAgICAgLy8gZGlnaXRzOyBtaWxsaXNlY29uZHMgc2hvdWxkIGhhdmUgdGhyZWUuXG4gICAgICAgICAgICAgICAgICBcIlRcIiArIHRvUGFkZGVkU3RyaW5nKDIsIGhvdXJzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbWludXRlcykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIHNlY29uZHMpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNS4wLCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgICAgXCIuXCIgKyB0b1BhZGRlZFN0cmluZygzLCBtaWxsaXNlY29uZHMpICsgXCJaXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT0gXCJmdW5jdGlvblwiICYmICgoY2xhc3NOYW1lICE9IG51bWJlckNsYXNzICYmIGNsYXNzTmFtZSAhPSBzdHJpbmdDbGFzcyAmJiBjbGFzc05hbWUgIT0gYXJyYXlDbGFzcykgfHwgaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkpIHtcbiAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIGFkZHMgbm9uLXN0YW5kYXJkIGB0b0pTT05gIG1ldGhvZHMgdG8gdGhlXG4gICAgICAgICAgICAgIC8vIGBOdW1iZXJgLCBgU3RyaW5nYCwgYERhdGVgLCBhbmQgYEFycmF5YCBwcm90b3R5cGVzLiBKU09OIDNcbiAgICAgICAgICAgICAgLy8gaWdub3JlcyBhbGwgYHRvSlNPTmAgbWV0aG9kcyBvbiB0aGVzZSBvYmplY3RzIHVubGVzcyB0aGV5IGFyZVxuICAgICAgICAgICAgICAvLyBkZWZpbmVkIGRpcmVjdGx5IG9uIGFuIGluc3RhbmNlLlxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gSWYgYSByZXBsYWNlbWVudCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIGNhbGwgaXQgdG8gb2J0YWluIHRoZSB2YWx1ZVxuICAgICAgICAgICAgLy8gZm9yIHNlcmlhbGl6YXRpb24uXG4gICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBib29sZWFuQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEJvb2xlYW5zIGFyZSByZXByZXNlbnRlZCBsaXRlcmFsbHkuXG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIGBJbmZpbml0eWAgYW5kIGBOYU5gIGFyZSBzZXJpYWxpemVkIGFzXG4gICAgICAgICAgICAvLyBgXCJudWxsXCJgLlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDAgPyBcIlwiICsgdmFsdWUgOiBcIm51bGxcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgLy8gU3RyaW5ncyBhcmUgZG91YmxlLXF1b3RlZCBhbmQgZXNjYXBlZC5cbiAgICAgICAgICAgIHJldHVybiBxdW90ZShcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGlzIGlzIGEgbGluZWFyIHNlYXJjaDsgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIC8vIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZiB1bmlxdWUgbmVzdGVkIG9iamVjdHMuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgIGlmIChzdGFja1tsZW5ndGhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIEN5Y2xpYyBzdHJ1Y3R1cmVzIGNhbm5vdCBiZSBzZXJpYWxpemVkIGJ5IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgaW5kZW50IG9uZSBhZGRpdGlvbmFsIGxldmVsLlxuICAgICAgICAgICAgcHJlZml4ID0gaW5kZW50YXRpb247XG4gICAgICAgICAgICBpbmRlbnRhdGlvbiArPSB3aGl0ZXNwYWNlO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBhcnJheSBlbGVtZW50cy5cbiAgICAgICAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gc2VyaWFsaXplKGluZGV4LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW1lbnQgPT09IHVuZGVmID8gXCJudWxsXCIgOiBlbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJbXFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIl1cIiA6IChcIltcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIl1cIikpIDogXCJbXVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdCBtZW1iZXJzLiBNZW1iZXJzIGFyZSBzZWxlY3RlZCBmcm9tXG4gICAgICAgICAgICAgIC8vIGVpdGhlciBhIHVzZXItc3BlY2lmaWVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMsIG9yIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgLy8gaXRzZWxmLlxuICAgICAgICAgICAgICBmb3JFYWNoKHByb3BlcnRpZXMgfHwgdmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2VyaWFsaXplKHByb3BlcnR5LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMzogXCJJZiBgZ2FwYCB7d2hpdGVzcGFjZX1cbiAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgYG1lbWJlcmAge3F1b3RlKHByb3BlcnR5KSArIFwiOlwifVxuICAgICAgICAgICAgICAgICAgLy8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgYG1lbWJlcmAgYW5kIHRoZSBgc3BhY2VgIGNoYXJhY3Rlci5cIlxuICAgICAgICAgICAgICAgICAgLy8gVGhlIFwiYHNwYWNlYCBjaGFyYWN0ZXJcIiByZWZlcnMgdG8gdGhlIGxpdGVyYWwgc3BhY2VcbiAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgbm90IHRoZSBgc3BhY2VgIHt3aWR0aH0gYXJndW1lbnQgcHJvdmlkZWQgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocXVvdGUocHJvcGVydHkpICsgXCI6XCIgKyAod2hpdGVzcGFjZSA/IFwiIFwiIDogXCJcIikgKyBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJ7XFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIn1cIiA6IChcIntcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIn1cIikpIDogXCJ7fVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgdHJhdmVyc2VkIG9iamVjdCBzdGFjay5cbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5zdHJpbmdpZnlgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoc291cmNlLCBmaWx0ZXIsIHdpZHRoKSB7XG4gICAgICAgICAgdmFyIHdoaXRlc3BhY2UsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCBjbGFzc05hbWU7XG4gICAgICAgICAgaWYgKG9iamVjdFR5cGVzW3R5cGVvZiBmaWx0ZXJdICYmIGZpbHRlcikge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKGZpbHRlcikpID09IGZ1bmN0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmaWx0ZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHByb3BlcnR5IG5hbWVzIGFycmF5IGludG8gYSBtYWtlc2hpZnQgc2V0LlxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKSksIGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpICYmIChwcm9wZXJ0aWVzW3ZhbHVlXSA9IDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwod2lkdGgpKSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBgd2lkdGhgIHRvIGFuIGludGVnZXIgYW5kIGNyZWF0ZSBhIHN0cmluZyBjb250YWluaW5nXG4gICAgICAgICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgIGlmICgod2lkdGggLT0gd2lkdGggJSAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHdoaXRlc3BhY2UgPSBcIlwiLCB3aWR0aCA+IDEwICYmICh3aWR0aCA9IDEwKTsgd2hpdGVzcGFjZS5sZW5ndGggPCB3aWR0aDsgd2hpdGVzcGFjZSArPSBcIiBcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAgIHdoaXRlc3BhY2UgPSB3aWR0aC5sZW5ndGggPD0gMTAgPyB3aWR0aCA6IHdpZHRoLnNsaWNlKDAsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIGRpc2NhcmRzIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGVtcHR5IHN0cmluZyBrZXlzXG4gICAgICAgICAgLy8gKGBcIlwiYCkgb25seSBpZiB0aGV5IGFyZSB1c2VkIGRpcmVjdGx5IHdpdGhpbiBhbiBvYmplY3QgbWVtYmVyIGxpc3RcbiAgICAgICAgICAvLyAoZS5nLiwgYCEoXCJcIiBpbiB7IFwiXCI6IDF9KWApLlxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoXCJcIiwgKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gc291cmNlLCB2YWx1ZSksIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBcIlwiLCBbXSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXBhcnNlXCIpKSB7XG4gICAgICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgdW5lc2NhcGVkXG4gICAgICAgIC8vIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgVW5lc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcIixcbiAgICAgICAgICAzNDogJ1wiJyxcbiAgICAgICAgICA0NzogXCIvXCIsXG4gICAgICAgICAgOTg6IFwiXFxiXCIsXG4gICAgICAgICAgMTE2OiBcIlxcdFwiLFxuICAgICAgICAgIDExMDogXCJcXG5cIixcbiAgICAgICAgICAxMDI6IFwiXFxmXCIsXG4gICAgICAgICAgMTE0OiBcIlxcclwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFN0b3JlcyB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICB2YXIgSW5kZXgsIFNvdXJjZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVzZXRzIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93cyBhIGBTeW50YXhFcnJvcmAuXG4gICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmV0dXJucyB0aGUgbmV4dCB0b2tlbiwgb3IgYFwiJFwiYCBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkXG4gICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzdHJpbmcuIEEgdG9rZW4gbWF5IGJlIGEgc3RyaW5nLCBudW1iZXIsIGBudWxsYFxuICAgICAgICAvLyBsaXRlcmFsLCBvciBCb29sZWFuIGxpdGVyYWwuXG4gICAgICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IFNvdXJjZSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aCwgdmFsdWUsIGJlZ2luLCBwb3NpdGlvbiwgaXNTaWduZWQsIGNoYXJDb2RlO1xuICAgICAgICAgIHdoaWxlIChJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UgdG9rZW5zLCBpbmNsdWRpbmcgdGFicywgY2FycmlhZ2UgcmV0dXJucywgbGluZVxuICAgICAgICAgICAgICAgIC8vIGZlZWRzLCBhbmQgc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDEyMzogY2FzZSAxMjU6IGNhc2UgOTE6IGNhc2UgOTM6IGNhc2UgNTg6IGNhc2UgNDQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIChge2AsIGB9YCwgYFtgLCBgXWAsIGA6YCwgb3IgYCxgKSBhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIHZhbHVlID0gY2hhckluZGV4QnVnZ3kgPyBzb3VyY2UuY2hhckF0KEluZGV4KSA6IHNvdXJjZVtJbmRleF07XG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgLy8gYFwiYCBkZWxpbWl0cyBhIEpTT04gc3RyaW5nOyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmRcbiAgICAgICAgICAgICAgICAvLyBiZWdpbiBwYXJzaW5nIHRoZSBzdHJpbmcuIFN0cmluZyB0b2tlbnMgYXJlIHByZWZpeGVkIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgLy8gc2VudGluZWwgYEBgIGNoYXJhY3RlciB0byBkaXN0aW5ndWlzaCB0aGVtIGZyb20gcHVuY3R1YXRvcnMgYW5kXG4gICAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmluZyB0b2tlbnMuXG4gICAgICAgICAgICAgICAgZm9yICh2YWx1ZSA9IFwiQFwiLCBJbmRleCsrOyBJbmRleCA8IGxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5lc2NhcGVkIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycyAodGhvc2Ugd2l0aCBhIGNvZGUgdW5pdFxuICAgICAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gdGhlIHNwYWNlIGNoYXJhY3RlcikgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09IDkyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgcmV2ZXJzZSBzb2xpZHVzIChgXFxgKSBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGFuIGVzY2FwZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udHJvbCBjaGFyYWN0ZXIgKGluY2x1ZGluZyBgXCJgLCBgXFxgLCBhbmQgYC9gKSBvciBVbmljb2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTI6IGNhc2UgMzQ6IGNhc2UgNDc6IGNhc2UgOTg6IGNhc2UgMTE2OiBjYXNlIDExMDogY2FzZSAxMDI6IGNhc2UgMTE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gVW5lc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBcXHVgIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgdmFsaWRhdGUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IGNvZGUgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXggKyA0OyBJbmRleCA8IHBvc2l0aW9uOyBJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHZhbGlkIHNlcXVlbmNlIGNvbXByaXNlcyBmb3VyIGhleGRpZ2l0cyAoY2FzZS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZW5zaXRpdmUpIHRoYXQgZm9ybSBhIHNpbmdsZSBoZXhhZGVjaW1hbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyIHx8IGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZShcIjB4XCIgKyBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBbiB1bmVzY2FwZWQgZG91YmxlLXF1b3RlIGNoYXJhY3RlciBtYXJrcyB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSBhIHN0cmluZyBpcyB2YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJDb2RlID49IDMyICYmIGNoYXJDb2RlICE9IDkyICYmIGNoYXJDb2RlICE9IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHN0cmluZyBhcy1pcy5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZCByZXR1cm4gdGhlIHJldml2ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW50ZXJtaW5hdGVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIG51bWJlcnMgYW5kIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBwYXN0IHRoZSBuZWdhdGl2ZSBzaWduLCBpZiBvbmUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYW4gaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVyb2VzIGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0OCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXggKyAxKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIG9jdGFsIGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGludGVnZXIgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgZm9yICg7IEluZGV4IDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IEluZGV4KyspO1xuICAgICAgICAgICAgICAgICAgLy8gRmxvYXRzIGNhbm5vdCBjb250YWluIGEgbGVhZGluZyBkZWNpbWFsIHBvaW50OyBob3dldmVyLCB0aGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSA0Nikge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBkZWNpbWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIHRyYWlsaW5nIGRlY2ltYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgZXhwb25lbnRzLiBUaGUgYGVgIGRlbm90aW5nIHRoZSBleHBvbmVudCBpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDEwMSB8fCBjaGFyQ29kZSA9PSA2OSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHBhc3QgdGhlIHNpZ24gZm9sbG93aW5nIHRoZSBleHBvbmVudCwgaWYgb25lIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQzIHx8IGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZXhwb25lbnRpYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIGVtcHR5IGV4cG9uZW50LlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgcGFyc2VkIHZhbHVlIHRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gK3NvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIG5lZ2F0aXZlIHNpZ24gbWF5IG9ubHkgcHJlY2VkZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgIGlmIChpc1NpZ25lZCkge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYHRydWVgLCBgZmFsc2VgLCBhbmQgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA1KSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5yZWNvZ25pemVkIHRva2VuLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJldHVybiB0aGUgc2VudGluZWwgYCRgIGNoYXJhY3RlciBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgICAvLyBvZiB0aGUgc291cmNlIHN0cmluZy5cbiAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFBhcnNlcyBhIEpTT04gYHZhbHVlYCB0b2tlbi5cbiAgICAgICAgdmFyIGdldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHRzLCBoYXNNZW1iZXJzO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIiRcIikge1xuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICgoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgPT0gXCJAXCIpIHtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxuICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiW1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxuICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3Npbmcgc3F1YXJlIGJyYWNrZXQgbWFya3MgdGhlIGVuZCBvZiB0aGUgYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYXJyYXkgbGl0ZXJhbCBjb250YWlucyBlbGVtZW50cywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0aW5nIHRoZSBwcmV2aW91cyBlbGVtZW50IGZyb20gdGhlXG4gICAgICAgICAgICAgICAgLy8gbmV4dC5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIGFycmF5IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVsaXNpb25zIGFuZCBsZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChnZXQodmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBvYmplY3QsIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IG9iamVjdC5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIGN1cmx5IGJyYWNlIG1hcmtzIHRoZSBlbmQgb2YgdGhlIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZCwgb2JqZWN0IHByb3BlcnR5IG5hbWVzIG11c3QgYmVcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIGFuZCBhIGA6YCBtdXN0IHNlcGFyYXRlIGVhY2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgICAvLyBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIgfHwgdHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIgfHwgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pICE9IFwiQFwiIHx8IGxleCgpICE9IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzW3ZhbHVlLnNsaWNlKDEpXSA9IGdldChsZXgoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBVcGRhdGVzIGEgdHJhdmVyc2VkIG9iamVjdCBtZW1iZXIuXG4gICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHdhbGsoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZikge1xuICAgICAgICAgICAgZGVsZXRlIHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0gPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgdHJhdmVyc2VzIGEgcGFyc2VkIEpTT04gb2JqZWN0LCBpbnZva2luZyB0aGVcbiAgICAgICAgLy8gYGNhbGxiYWNrYCBmdW5jdGlvbiBmb3IgZWFjaCB2YWx1ZS4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFdhbGsoaG9sZGVyLCBuYW1lKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldLCBsZW5ndGg7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0cyBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGBmYWxzZWBcbiAgICAgICAgICAgIC8vIGZvciBhcnJheSBpbmRpY2VzIChlLmcuLCBgIVsxLCAyLCAzXS5oYXNPd25Qcm9wZXJ0eShcIjBcIilgKS5cbiAgICAgICAgICAgIGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIGZvciAobGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIGxlbmd0aCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzb3VyY2UsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5wYXJzZWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcbiAgICAgICAgICBJbmRleCA9IDA7XG4gICAgICAgICAgU291cmNlID0gXCJcIiArIHNvdXJjZTtcbiAgICAgICAgICByZXN1bHQgPSBnZXQobGV4KCkpO1xuICAgICAgICAgIC8vIElmIGEgSlNPTiBzdHJpbmcgY29udGFpbnMgbXVsdGlwbGUgdG9rZW5zLCBpdCBpcyBpbnZhbGlkLlxuICAgICAgICAgIGlmIChsZXgoKSAhPSBcIiRcIikge1xuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGdldENsYXNzLmNhbGwoY2FsbGJhY2spID09IGZ1bmN0aW9uQ2xhc3MgPyB3YWxrKCh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHJlc3VsdCwgdmFsdWUpLCBcIlwiLCBjYWxsYmFjaykgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0c1tcInJ1bkluQ29udGV4dFwiXSA9IHJ1bkluQ29udGV4dDtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfVxuXG4gIGlmIChmcmVlRXhwb3J0cyAmJiAhaXNMb2FkZXIpIHtcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIGVudmlyb25tZW50cy5cbiAgICBydW5JbkNvbnRleHQocm9vdCwgZnJlZUV4cG9ydHMpO1xuICB9IGVsc2Uge1xuICAgIC8vIEV4cG9ydCBmb3Igd2ViIGJyb3dzZXJzIGFuZCBKYXZhU2NyaXB0IGVuZ2luZXMuXG4gICAgdmFyIG5hdGl2ZUpTT04gPSByb290LkpTT04sXG4gICAgICAgIHByZXZpb3VzSlNPTiA9IHJvb3RbXCJKU09OM1wiXSxcbiAgICAgICAgaXNSZXN0b3JlZCA9IGZhbHNlO1xuXG4gICAgdmFyIEpTT04zID0gcnVuSW5Db250ZXh0KHJvb3QsIChyb290W1wiSlNPTjNcIl0gPSB7XG4gICAgICAvLyBQdWJsaWM6IFJlc3RvcmVzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgZ2xvYmFsIGBKU09OYCBvYmplY3QgYW5kXG4gICAgICAvLyByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgSlNPTjNgIG9iamVjdC5cbiAgICAgIFwibm9Db25mbGljdFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNSZXN0b3JlZCkge1xuICAgICAgICAgIGlzUmVzdG9yZWQgPSB0cnVlO1xuICAgICAgICAgIHJvb3QuSlNPTiA9IG5hdGl2ZUpTT047XG4gICAgICAgICAgcm9vdFtcIkpTT04zXCJdID0gcHJldmlvdXNKU09OO1xuICAgICAgICAgIG5hdGl2ZUpTT04gPSBwcmV2aW91c0pTT04gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OMztcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICByb290LkpTT04gPSB7XG4gICAgICBcInBhcnNlXCI6IEpTT04zLnBhcnNlLFxuICAgICAgXCJzdHJpbmdpZnlcIjogSlNPTjMuc3RyaW5naWZ5XG4gICAgfTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBmb3IgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLlxuICBpZiAoaXNMb2FkZXIpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEpTT04zO1xuICAgIH0pO1xuICB9XG59KS5jYWxsKHRoaXMpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRG9tVXRpbHMuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cblx0LyoqXG5cdCAqIEEgZmV3IHV0aWxpdGllcyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgZG9tLlxuXHQgKiBAY2xhc3MgRG9tVXRpbHNcblx0ICovXG5cdHZhciBzID0ge307XG5cblx0cy5hcHBlbmRUb0hlYWQgPSBmdW5jdGlvbiAoZWwpIHtcblx0XHRzLmdldEhlYWQoKS5hcHBlbmRDaGlsZChlbClcblx0fVxuXG5cdHMuZ2V0SGVhZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG5cdH1cblxuXHRzLmdldEJvZHkgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdO1xuXHR9XG5cblx0Y3JlYXRlanMuRG9tVXRpbHMgPSBzO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRGF0YVV0aWxzLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXG5cdC8qKlxuXHQgKiBBIGZldyBkYXRhIHV0aWxpdGllcyBmb3IgZm9ybWF0dGluZyBkaWZmZXJlbnQgZGF0YSB0eXBlcy5cblx0ICogQGNsYXNzIERhdGFVdGlsc1xuXHQgKi9cblx0dmFyIHMgPSB7fTtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogUGFyc2UgWE1MIHVzaW5nIHRoZSBET00uIFRoaXMgaXMgcmVxdWlyZWQgd2hlbiBwcmVsb2FkaW5nIFhNTCBvciBTVkcuXG5cdCAqIEBtZXRob2QgcGFyc2VYTUxcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHJhdyB0ZXh0IG9yIFhNTCB0aGF0IGlzIGxvYWRlZCBieSBYSFIuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBtaW1lIHR5cGUgb2YgdGhlIFhNTC4gVXNlIFwidGV4dC94bWxcIiBmb3IgWE1MLCBhbmQgIFwiaW1hZ2Uvc3ZnK3htbFwiIGZvciBTVkcgcGFyc2luZy5cblx0ICogQHJldHVybiB7WE1MfSBBbiBYTUwgZG9jdW1lbnRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5wYXJzZVhNTCA9IGZ1bmN0aW9uICh0ZXh0LCB0eXBlKSB7XG5cdFx0dmFyIHhtbCA9IG51bGw7XG5cdFx0Ly8gQ29jb29uSlMgZG9lcyBub3Qgc3VwcG9ydCBYTUwgcGFyc2luZyB3aXRoIGVpdGhlciBtZXRob2QuXG5cblx0XHQvLyBNb3N0IGJyb3dzZXJzIHdpbGwgdXNlIERPTVBhcnNlclxuXHRcdC8vIElFIGZhaWxzIG9uIGNlcnRhaW4gU1ZHIGZpbGVzLCBzbyB3ZSBoYXZlIGEgZmFsbGJhY2sgYmVsb3cuXG5cdFx0dHJ5IHtcblx0XHRcdGlmICh3aW5kb3cuRE9NUGFyc2VyKSB7XG5cdFx0XHRcdHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG5cdFx0XHRcdHhtbCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodGV4dCwgdHlwZSk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIGZvciBJRSBzdXBwb3J0LlxuXHRcdGlmICgheG1sKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR4bWwgPSBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxET01cIik7XG5cdFx0XHRcdHhtbC5hc3luYyA9IGZhbHNlO1xuXHRcdFx0XHR4bWwubG9hZFhNTCh0ZXh0KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0eG1sID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4geG1sO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXJzZSBhIHN0cmluZyBpbnRvIGFuIE9iamVjdC5cblx0ICogQG1ldGhvZCBwYXJzZUpTT05cblx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSBsb2FkZWQgSlNPTiBzdHJpbmdcblx0ICogQHJldHVybnMge09iamVjdH0gQSBKYXZhU2NyaXB0IG9iamVjdC5cblx0ICovXG5cdHMucGFyc2VKU09OID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Ly8gVE9ETzsgSGFuZGxlIHRoaXMgd2l0aCBhIGN1c3RvbSBlcnJvcj9cblx0XHRcdHRocm93IGU7XG5cdFx0fVxuXHR9O1xuXG5cdGNyZWF0ZWpzLkRhdGFVdGlscyA9IHM7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBMb2FkSXRlbS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBBbGwgbG9hZGVycyBhY2NlcHQgYW4gaXRlbSBjb250YWluaW5nIHRoZSBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhpcyBjbGFzcy4gSWYgYSByYXcgb2JqZWN0IGlzIHBhc3NlZCBpbnN0ZWFkLFxuXHQgKiBpdCB3aWxsIG5vdCBiZSBhZmZlY3RlZCwgYnV0IGl0IG11c3QgY29udGFpbiBhdCBsZWFzdCBhIHt7I2Nyb3NzTGluayBcInNyYzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eS4gQVxuXHQgKiBzdHJpbmcgcGF0aCBvciBIVE1MIHRhZyBpcyBhbHNvIGFjY2VwdGFibGUsIGJ1dCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGEgTG9hZEl0ZW0gdXNpbmcgdGhlXG5cdCAqIHt7I2Nyb3NzTGluayBcImNyZWF0ZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgYnkge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogQGNsYXNzIExvYWRJdGVtXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdGZ1bmN0aW9uIExvYWRJdGVtKCkge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBzb3VyY2Ugb2YgdGhlIGZpbGUgdGhhdCBpcyBiZWluZyBsb2FkZWQuIFRoaXMgcHJvcGVydHkgaXMgPGI+cmVxdWlyZWQ8L2I+LiBUaGUgc291cmNlIGNhbiBlaXRoZXIgYmUgYVxuXHRcdCAqIHN0cmluZyAocmVjb21tZW5kZWQpLCBvciBhbiBIVE1MIHRhZy5cblx0XHQgKiBUaGlzIGNhbiBhbHNvIGJlIGFuIG9iamVjdCwgYnV0IGluIHRoYXQgY2FzZSBpdCBoYXMgdG8gaW5jbHVkZSBhIHR5cGUgYW5kIGJlIGhhbmRsZWQgYnkgYSBwbHVnaW4uXG5cdFx0ICogQHByb3BlcnR5IHNyY1xuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuc3JjID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIGZpbGUgdGhhdCBpcyBiZWluZyBsb2FkZWQuIFRoZSB0eXBlIG9mIHRoZSBmaWxlIGlzIHVzdWFsbHkgaW5mZXJyZWQgYnkgdGhlIGV4dGVuc2lvbiwgYnV0IGNhbiBhbHNvXG5cdFx0ICogYmUgc2V0IG1hbnVhbGx5LiBUaGlzIGlzIGhlbHBmdWwgaW4gY2FzZXMgd2hlcmUgYSBmaWxlIGRvZXMgbm90IGhhdmUgYW4gZXh0ZW5zaW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSB0eXBlXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy50eXBlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIGlkZW50aWZpZXIgd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmVmZXJlbmNlIHRoZSBsb2FkZWQgb2JqZWN0LiBJZiBub25lIGlzIHByb3ZpZGVkLCB0aGlzIHdpbGwgYmVcblx0XHQgKiBhdXRvbWF0aWNhbGx5IHNldCB0byB0aGUge3sjY3Jvc3NMaW5rIFwic3JjOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBpZFxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuaWQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lcyBpZiBhIG1hbmlmZXN0IHdpbGwgbWFpbnRhaW4gdGhlIG9yZGVyIG9mIHRoaXMgaXRlbSwgaW4gcmVsYXRpb24gdG8gb3RoZXIgaXRlbXMgaW4gdGhlIG1hbmlmZXN0XG5cdFx0ICogdGhhdCBoYXZlIGFsc28gc2V0IHRoZSBgbWFpbnRhaW5PcmRlcmAgcHJvcGVydHkgdG8gYHRydWVgLiBUaGlzIG9ubHkgYXBwbGllcyB3aGVuIHRoZSBtYXggY29ubmVjdGlvbnMgaGFzXG5cdFx0ICogYmVlbiBzZXQgYWJvdmUgMSAodXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldE1heENvbm5lY3Rpb25zXCJ9fXt7L2Nyb3NzTGlua319KS4gRXZlcnl0aGluZyB3aXRoIHRoaXNcblx0XHQgKiBwcm9wZXJ0eSBzZXQgdG8gYGZhbHNlYCB3aWxsIGZpbmlzaCBhcyBpdCBpcyBsb2FkZWQuIE9yZGVyZWQgaXRlbXMgYXJlIGNvbWJpbmVkIHdpdGggc2NyaXB0IHRhZ3MgbG9hZGluZyBpblxuXHRcdCAqIG9yZGVyIHdoZW4ge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL21haW50YWluU2NyaXB0T3JkZXI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaXMgc2V0IHRvIGB0cnVlYC5cblx0XHQgKiBAcHJvcGVydHkgbWFpbnRhaW5PcmRlclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5tYWludGFpbk9yZGVyID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBBIGNhbGxiYWNrIHVzZWQgYnkgSlNPTlAgcmVxdWVzdHMgdGhhdCBkZWZpbmVzIHdoYXQgZ2xvYmFsIG1ldGhvZCB0byBjYWxsIHdoZW4gdGhlIEpTT05QIGNvbnRlbnQgaXMgbG9hZGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBjYWxsYmFja1xuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gYXJiaXRyYXJ5IGRhdGEgb2JqZWN0LCB3aGljaCBpcyBpbmNsdWRlZCB3aXRoIHRoZSBsb2FkZWQgb2JqZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBkYXRhXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5kYXRhID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByZXF1ZXN0IG1ldGhvZCB1c2VkIGZvciBIVFRQIGNhbGxzLiBCb3RoIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0dFVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBvclxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1BPU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcmVxdWVzdCB0eXBlcyBhcmUgc3VwcG9ydGVkLCBhbmQgYXJlIGRlZmluZWQgYXNcblx0XHQgKiBjb25zdGFudHMgb24ge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IG1ldGhvZFxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgZ2V0XG5cdFx0ICovXG5cdFx0dGhpcy5tZXRob2QgPSBjcmVhdGVqcy5Mb2FkSXRlbS5HRVQ7XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiBuYW1lL3ZhbHVlIHBhaXJzIHRvIHNlbmQgdG8gdGhlIHNlcnZlci5cblx0XHQgKiBAcHJvcGVydHkgdmFsdWVzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy52YWx1ZXMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IGhhc2ggb2YgaGVhZGVycyB0byBhdHRhY2ggdG8gYW4gWEhSIHJlcXVlc3QuIFByZWxvYWRKUyB3aWxsIGF1dG9tYXRpY2FsbHkgYXR0YWNoIHNvbWUgZGVmYXVsdFxuXHRcdCAqIGhlYWRlcnMgd2hlbiByZXF1aXJlZCwgaW5jbHVkaW5nIFwiT3JpZ2luXCIsIFwiQ29udGVudC1UeXBlXCIsIGFuZCBcIlgtUmVxdWVzdGVkLVdpdGhcIi4gWW91IG1heSBvdmVycmlkZSB0aGVcblx0XHQgKiBkZWZhdWx0IGhlYWRlcnMgYnkgaW5jbHVkaW5nIHRoZW0gaW4geW91ciBoZWFkZXJzIG9iamVjdC5cblx0XHQgKiBAcHJvcGVydHkgaGVhZGVyc1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuaGVhZGVycyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBFbmFibGUgY3JlZGVudGlhbHMgZm9yIFhIUiByZXF1ZXN0cy5cblx0XHQgKiBAcHJvcGVydHkgd2l0aENyZWRlbnRpYWxzXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBtaW1lIHR5cGUgb2YgWEhSLWJhc2VkIHJlcXVlc3RzLiBUaGlzIGlzIGF1dG9tYXRpY2FsbHkgc2V0IHRvIFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiIGZvciB0ZXh0XG5cdFx0ICogYmFzZWQgZmlsZXMgKGpzb24sIHhtbCwgdGV4dCwgY3NzLCBqcykuXG5cdFx0ICogQHByb3BlcnR5IG1pbWVUeXBlXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5taW1lVHlwZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBTZXRzIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgZm9yIENPUlMtZW5hYmxlZCBpbWFnZXMgbG9hZGluZyBjcm9zcy1kb21haW4uXG5cdFx0ICogQHByb3BlcnR5IGNyb3NzT3JpZ2luXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgQW5vbnltb3VzXG5cdFx0ICovXG5cdFx0dGhpcy5jcm9zc09yaWdpbiA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIGEgcmVxdWVzdCB0aW1lcyBvdXQuIFRoaXMgb25seSBhcHBsaWVzIHRvIHRhZy1iYXNlZCBhbmQgYW5kIFhIUlxuXHRcdCAqIChsZXZlbCBvbmUpIGxvYWRpbmcsIGFzIFhIUiAobGV2ZWwgMikgcHJvdmlkZXMgaXRzIG93biB0aW1lb3V0IGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBsb2FkVGltZW91dFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgODAwMCAoOCBzZWNvbmRzKVxuXHRcdCAqL1xuXHRcdHRoaXMubG9hZFRpbWVvdXQgPSBzLkxPQURfVElNRU9VVF9ERUZBVUxUO1xuXHR9O1xuXG5cdHZhciBwID0gTG9hZEl0ZW0ucHJvdG90eXBlID0ge307XG5cdHZhciBzID0gTG9hZEl0ZW07XG5cblx0LyoqXG5cdCAqIERlZmF1bHQgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIGEgcmVxdWVzdCB0aW1lcyBvdXQuIFRoaXMgb25seSBhcHBsaWVzIHRvIHRhZy1iYXNlZCBhbmQgYW5kIFhIUlxuXHQgKiAobGV2ZWwgb25lKSBsb2FkaW5nLCBhcyBYSFIgKGxldmVsIDIpIHByb3ZpZGVzIGl0cyBvd24gdGltZW91dCBldmVudC5cblx0ICogQHByb3BlcnR5IExPQURfVElNRU9VVF9ERUZBVUxUXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuTE9BRF9USU1FT1VUX0RFRkFVTFQgPSA4MDAwO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBMb2FkSXRlbS5cblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPlN0cmluZy1iYXNlZCBpdGVtcyBhcmUgY29udmVydGVkIHRvIGEgTG9hZEl0ZW0gd2l0aCBhIHBvcHVsYXRlZCB7eyNjcm9zc0xpbmsgXCJzcmM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uPC9saT5cblx0ICogICAgIDxsaT5Mb2FkSXRlbSBpbnN0YW5jZXMgYXJlIHJldHVybmVkIGFzLWlzPC9saT5cblx0ICogICAgIDxsaT5PYmplY3RzIGFyZSByZXR1cm5lZCB3aXRoIGFueSBuZWVkZWQgcHJvcGVydGllcyBhZGRlZDwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIEBtZXRob2QgY3JlYXRlXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18U3RyaW5nfE9iamVjdH0gdmFsdWUgVGhlIGxvYWQgaXRlbSB2YWx1ZVxuXHQgKiBAcmV0dXJucyB7TG9hZEl0ZW18T2JqZWN0fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFyIGl0ZW0gPSBuZXcgTG9hZEl0ZW0oKTtcblx0XHRcdGl0ZW0uc3JjID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gaXRlbTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2Ygcykge1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QgJiYgdmFsdWUuc3JjKSB7XG5cdFx0XHRpZiAodmFsdWUubG9hZFRpbWVvdXQgPT0gbnVsbCkge1xuXHRcdFx0XHR2YWx1ZS5sb2FkVGltZW91dCA9IHMuTE9BRF9USU1FT1VUX0RFRkFVTFQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlR5cGUgbm90IHJlY29nbml6ZWQuXCIpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUHJvdmlkZXMgYSBjaGFpbmFibGUgc2hvcnRjdXQgbWV0aG9kIGZvciBzZXR0aW5nIGEgbnVtYmVyIG9mIHByb3BlcnRpZXMgb24gdGhlIGluc3RhbmNlLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIGxvYWRJdGVtID0gbmV3IGNyZWF0ZWpzLkxvYWRJdGVtKCkuc2V0KHtzcmM6XCJpbWFnZS5wbmdcIiwgbWFpbnRhaW5PcmRlcjp0cnVlfSk7XG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBBIGdlbmVyaWMgb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBjb3B5IHRvIHRoZSBMb2FkSXRlbSBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7TG9hZEl0ZW19IFJldHVybnMgdGhlIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0Ki9cblx0cC5zZXQgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdGZvciAodmFyIG4gaW4gcHJvcHMpIHsgdGhpc1tuXSA9IHByb3BzW25dOyB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0Y3JlYXRlanMuTG9hZEl0ZW0gPSBzO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gUmVxdWVzdFV0aWxzLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXG5cdC8qKlxuXHQgKiBVdGlsaXRpZXMgdGhhdCBhc3Npc3Qgd2l0aCBwYXJzaW5nIGxvYWQgaXRlbXMsIGFuZCBkZXRlcm1pbmluZyBmaWxlIHR5cGVzLCBldGMuXG5cdCAqIEBjbGFzcyBSZXF1ZXN0VXRpbHNcblx0ICovXG5cdHZhciBzID0ge307XG5cblx0LyoqXG5cdCAqIFRoZSBSZWd1bGFyIEV4cHJlc3Npb24gdXNlZCB0byB0ZXN0IGZpbGUgVVJMUyBmb3IgYW4gYWJzb2x1dGUgcGF0aC5cblx0ICogQHByb3BlcnR5IEFCU09MVVRFX1BBVEhcblx0ICogQHR5cGUge1JlZ0V4cH1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5BQlNPTFVURV9QQVRUID0gL14oPzpcXHcrOik/XFwvezJ9L2k7XG5cblx0LyoqXG5cdCAqIFRoZSBSZWd1bGFyIEV4cHJlc3Npb24gdXNlZCB0byB0ZXN0IGZpbGUgVVJMUyBmb3IgYSByZWxhdGl2ZSBwYXRoLlxuXHQgKiBAcHJvcGVydHkgUkVMQVRJVkVfUEFUSFxuXHQgKiBAdHlwZSB7UmVnRXhwfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLlJFTEFUSVZFX1BBVFQgPSAoL15bLi9dKj9cXC8vaSk7XG5cblx0LyoqXG5cdCAqIFRoZSBSZWd1bGFyIEV4cHJlc3Npb24gdXNlZCB0byB0ZXN0IGZpbGUgVVJMUyBmb3IgYW4gZXh0ZW5zaW9uLiBOb3RlIHRoYXQgVVJJcyBtdXN0IGFscmVhZHkgaGF2ZSB0aGUgcXVlcnkgc3RyaW5nXG5cdCAqIHJlbW92ZWQuXG5cdCAqIEBwcm9wZXJ0eSBFWFRFTlNJT05fUEFUVFxuXHQgKiBAdHlwZSB7UmVnRXhwfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLkVYVEVOU0lPTl9QQVRUID0gL1xcLz9bXi9dK1xcLihcXHd7MSw1fSkkL2k7XG5cblx0LyoqXG5cdCAqIFBhcnNlIGEgZmlsZSBwYXRoIHRvIGRldGVybWluZSB0aGUgaW5mb3JtYXRpb24gd2UgbmVlZCB0byB3b3JrIHdpdGggaXQuIEN1cnJlbnRseSwgUHJlbG9hZEpTIG5lZWRzIHRvIGtub3c6XG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5JZiB0aGUgcGF0aCBpcyBhYnNvbHV0ZS4gQWJzb2x1dGUgcGF0aHMgc3RhcnQgd2l0aCBhIHByb3RvY29sIChzdWNoIGFzIGBodHRwOi8vYCwgYGZpbGU6Ly9gLCBvclxuXHQgKiAgICAgYC8vbmV0d29ya1BhdGhgKTwvbGk+XG5cdCAqICAgICA8bGk+SWYgdGhlIHBhdGggaXMgcmVsYXRpdmUuIFJlbGF0aXZlIHBhdGhzIHN0YXJ0IHdpdGggYC4uL2Agb3IgYC9wYXRoYCAob3Igc2ltaWxhcik8L2xpPlxuXHQgKiAgICAgPGxpPlRoZSBmaWxlIGV4dGVuc2lvbi4gVGhpcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBmaWxlbmFtZSB3aXRoIGFuIGV4dGVuc2lvbi4gUXVlcnkgc3RyaW5ncyBhcmUgZHJvcHBlZCwgYW5kXG5cdCAqICAgICB0aGUgZmlsZSBwYXRoIGlzIGV4cGVjdGVkIHRvIGZvbGxvdyB0aGUgZm9ybWF0IGBuYW1lLmV4dGAuPC9saT5cblx0ICogPC91bD5cblx0ICogQG1ldGhvZCBwYXJzZVVSSVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBPYmplY3Qgd2l0aCBhbiBgYWJzb2x1dGVgIGFuZCBgcmVsYXRpdmVgIEJvb2xlYW4gdmFsdWVzLCBhcyB3ZWxsIGFzIGFuIG9wdGlvbmFsICdleHRlbnNpb25gXG5cdCAqIHByb3BlcnR5LCB3aGljaCBpcyB0aGUgbG93ZXJjYXNlIGV4dGVuc2lvbi5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5wYXJzZVVSSSA9IGZ1bmN0aW9uIChwYXRoKSB7XG5cdFx0dmFyIGluZm8gPSB7YWJzb2x1dGU6IGZhbHNlLCByZWxhdGl2ZTogZmFsc2V9O1xuXHRcdGlmIChwYXRoID09IG51bGwpIHsgcmV0dXJuIGluZm87IH1cblxuXHRcdC8vIERyb3AgdGhlIHF1ZXJ5IHN0cmluZ1xuXHRcdHZhciBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKFwiP1wiKTtcblx0XHRpZiAocXVlcnlJbmRleCA+IC0xKSB7XG5cdFx0XHRwYXRoID0gcGF0aC5zdWJzdHIoMCwgcXVlcnlJbmRleCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJzb2x1dGVcblx0XHR2YXIgbWF0Y2g7XG5cdFx0aWYgKHMuQUJTT0xVVEVfUEFUVC50ZXN0KHBhdGgpKSB7XG5cdFx0XHRpbmZvLmFic29sdXRlID0gdHJ1ZTtcblxuXHRcdFx0Ly8gUmVsYXRpdmVcblx0XHR9IGVsc2UgaWYgKHMuUkVMQVRJVkVfUEFUVC50ZXN0KHBhdGgpKSB7XG5cdFx0XHRpbmZvLnJlbGF0aXZlID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBFeHRlbnNpb25cblx0XHRpZiAobWF0Y2ggPSBwYXRoLm1hdGNoKHMuRVhURU5TSU9OX1BBVFQpKSB7XG5cdFx0XHRpbmZvLmV4dGVuc2lvbiA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBpbmZvO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBGb3JtYXRzIGFuIG9iamVjdCBpbnRvIGEgcXVlcnkgc3RyaW5nIGZvciBlaXRoZXIgYSBQT1NUIG9yIEdFVCByZXF1ZXN0LlxuXHQgKiBAbWV0aG9kIGZvcm1hdFF1ZXJ5U3RyaW5nXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIHRvIGNvbnZlcnQgdG8gYSBxdWVyeSBzdHJpbmcuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtxdWVyeV0gRXhpc3RpbmcgbmFtZS92YWx1ZSBwYWlycyB0byBhcHBlbmQgb24gdG8gdGhpcyBxdWVyeS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5mb3JtYXRRdWVyeVN0cmluZyA9IGZ1bmN0aW9uIChkYXRhLCBxdWVyeSkge1xuXHRcdGlmIChkYXRhID09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBkYXRhLicpO1xuXHRcdH1cblx0XHR2YXIgcGFyYW1zID0gW107XG5cdFx0Zm9yICh2YXIgbiBpbiBkYXRhKSB7XG5cdFx0XHRwYXJhbXMucHVzaChuICsgJz0nICsgZXNjYXBlKGRhdGFbbl0pKTtcblx0XHR9XG5cdFx0aWYgKHF1ZXJ5KSB7XG5cdFx0XHRwYXJhbXMgPSBwYXJhbXMuY29uY2F0KHF1ZXJ5KTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcmFtcy5qb2luKCcmJyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEEgdXRpbGl0eSBtZXRob2QgdGhhdCBidWlsZHMgYSBmaWxlIHBhdGggdXNpbmcgYSBzb3VyY2UgYW5kIGEgZGF0YSBvYmplY3QsIGFuZCBmb3JtYXRzIGl0IGludG8gYSBuZXcgcGF0aC5cblx0ICogQG1ldGhvZCBidWlsZFBhdGhcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIHBhdGggdG8gYWRkIHZhbHVlcyB0by5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXSBPYmplY3QgdXNlZCB0byBhcHBlbmQgdmFsdWVzIHRvIHRoaXMgcmVxdWVzdCBhcyBhIHF1ZXJ5IHN0cmluZy4gRXhpc3RpbmcgcGFyYW1ldGVycyBvbiB0aGVcblx0ICogcGF0aCB3aWxsIGJlIHByZXNlcnZlZC5cblx0ICogQHJldHVybnMge3N0cmluZ30gQSBmb3JtYXR0ZWQgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIHBhdGggYW5kIHRoZSBzdXBwbGllZCBwYXJhbWV0ZXJzLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChzcmMsIGRhdGEpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gc3JjO1xuXHRcdH1cblxuXHRcdHZhciBxdWVyeSA9IFtdO1xuXHRcdHZhciBpZHggPSBzcmMuaW5kZXhPZignPycpO1xuXG5cdFx0aWYgKGlkeCAhPSAtMSkge1xuXHRcdFx0dmFyIHEgPSBzcmMuc2xpY2UoaWR4ICsgMSk7XG5cdFx0XHRxdWVyeSA9IHF1ZXJ5LmNvbmNhdChxLnNwbGl0KCcmJykpO1xuXHRcdH1cblxuXHRcdGlmIChpZHggIT0gLTEpIHtcblx0XHRcdHJldHVybiBzcmMuc2xpY2UoMCwgaWR4KSArICc/JyArIHRoaXMuX2Zvcm1hdFF1ZXJ5U3RyaW5nKGRhdGEsIHF1ZXJ5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHNyYyArICc/JyArIHRoaXMuX2Zvcm1hdFF1ZXJ5U3RyaW5nKGRhdGEsIHF1ZXJ5KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgaXNDcm9zc0RvbWFpblxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBBIGxvYWQgaXRlbSB3aXRoIGEgYHNyY2AgcHJvcGVydHkuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBsb2FkIGl0ZW0gaXMgbG9hZGluZyBmcm9tIGEgZGlmZmVyZW50IGRvbWFpbiB0aGFuIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzQ3Jvc3NEb21haW4gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHZhciB0YXJnZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcblx0XHR0YXJnZXQuaHJlZiA9IGl0ZW0uc3JjO1xuXG5cdFx0dmFyIGhvc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcblx0XHRob3N0LmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG5cdFx0dmFyIGNyb3NzZG9tYWluID0gKHRhcmdldC5ob3N0bmFtZSAhPSBcIlwiKSAmJlxuXHRcdFx0XHRcdFx0ICAodGFyZ2V0LnBvcnQgIT0gaG9zdC5wb3J0IHx8XG5cdFx0XHRcdFx0XHQgICB0YXJnZXQucHJvdG9jb2wgIT0gaG9zdC5wcm90b2NvbCB8fFxuXHRcdFx0XHRcdFx0ICAgdGFyZ2V0Lmhvc3RuYW1lICE9IGhvc3QuaG9zdG5hbWUpO1xuXHRcdHJldHVybiBjcm9zc2RvbWFpbjtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBpc0xvY2FsXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIEEgbG9hZCBpdGVtIHdpdGggYSBgc3JjYCBwcm9wZXJ0eVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgbG9hZCBpdGVtIGlzIGxvYWRpbmcgZnJvbSB0aGUgXCJmaWxlOlwiIHByb3RvY29sLiBBc3N1bWUgdGhhdCB0aGUgaG9zdCBtdXN0IGJlIGxvY2FsIGFzXG5cdCAqIHdlbGwuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNMb2NhbCA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0dmFyIHRhcmdldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXHRcdHRhcmdldC5ocmVmID0gaXRlbS5zcmM7XG5cdFx0cmV0dXJuIHRhcmdldC5ob3N0bmFtZSA9PSBcIlwiICYmIHRhcmdldC5wcm90b2NvbCA9PSBcImZpbGU6XCI7XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSBpZiBhIHNwZWNpZmljIHR5cGUgc2hvdWxkIGJlIGxvYWRlZCBhcyBhIGJpbmFyeSBmaWxlLiBDdXJyZW50bHksIG9ubHkgaW1hZ2VzIGFuZCBpdGVtcyBtYXJrZWRcblx0ICogc3BlY2lmaWNhbGx5IGFzIFwiYmluYXJ5XCIgYXJlIGxvYWRlZCBhcyBiaW5hcnkuIE5vdGUgdGhhdCBhdWRpbyBpcyA8Yj5ub3Q8L2I+IGEgYmluYXJ5IHR5cGUsIGFzIHdlIGNhbiBub3QgcGxheVxuXHQgKiBiYWNrIHVzaW5nIGFuIGF1ZGlvIHRhZyBpZiBpdCBpcyBsb2FkZWQgYXMgYmluYXJ5LiBQbHVnaW5zIGNhbiBjaGFuZ2UgdGhlIGl0ZW0gdHlwZSB0byBiaW5hcnkgdG8gZW5zdXJlIHRoZXkgZ2V0XG5cdCAqIGEgYmluYXJ5IHJlc3VsdCB0byB3b3JrIHdpdGguIEJpbmFyeSBmaWxlcyBhcmUgbG9hZGVkIHVzaW5nIFhIUjIuIFR5cGVzIGFyZSBkZWZpbmVkIGFzIHN0YXRpYyBjb25zdGFudHMgb25cblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgaXNCaW5hcnlcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGl0ZW0gdHlwZS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIHNwZWNpZmllZCB0eXBlIGlzIGJpbmFyeS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pc0JpbmFyeSA9IGZ1bmN0aW9uICh0eXBlKSB7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLklNQUdFOlxuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5CSU5BUlk6XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgaXRlbSBpcyBhIHZhbGlkIEhUTUxJbWFnZUVsZW1lbnRcblx0ICogQG1ldGhvZCBpc0ltYWdlVGFnXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzSW1hZ2VUYWcgPSBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0gaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBpdGVtIGlzIGEgdmFsaWQgSFRNTEF1ZGlvRWxlbWVudFxuXHQgKiBAbWV0aG9kIGlzQXVkaW9UYWdcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cblx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNBdWRpb1RhZyA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRpZiAod2luZG93LkhUTUxBdWRpb0VsZW1lbnQpIHtcblx0XHRcdHJldHVybiBpdGVtIGluc3RhbmNlb2YgSFRNTEF1ZGlvRWxlbWVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgaXRlbSBpcyBhIHZhbGlkIEhUTUxWaWRlb0VsZW1lbnRcblx0ICogQG1ldGhvZCBpc1ZpZGVvVGFnXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzVmlkZW9UYWcgPSBmdW5jdGlvbihpdGVtKSB7XG5cdFx0aWYgKHdpbmRvdy5IVE1MVmlkZW9FbGVtZW50KSB7XG5cdFx0XHRyZXR1cm4gaXRlbSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSBpZiBhIHNwZWNpZmljIHR5cGUgaXMgYSB0ZXh0LWJhc2VkIGFzc2V0LCBhbmQgc2hvdWxkIGJlIGxvYWRlZCBhcyBVVEYtOC5cblx0ICogQG1ldGhvZCBpc1RleHRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGl0ZW0gdHlwZS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIHNwZWNpZmllZCB0eXBlIGlzIHRleHQuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNUZXh0ID0gZnVuY3Rpb24gKHR5cGUpIHtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVEVYVDpcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTjpcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuTUFOSUZFU1Q6XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlhNTDpcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuQ1NTOlxuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TVkc6XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpBVkFTQ1JJUFQ6XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNQUklURVNIRUVUOlxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSB0aGUgdHlwZSBvZiB0aGUgb2JqZWN0IHVzaW5nIGNvbW1vbiBleHRlbnNpb25zLiBOb3RlIHRoYXQgdGhlIHR5cGUgY2FuIGJlIHBhc3NlZCBpbiB3aXRoIHRoZSBsb2FkIGl0ZW1cblx0ICogaWYgaXQgaXMgYW4gdW51c3VhbCBleHRlbnNpb24uXG5cdCAqIEBtZXRob2QgZ2V0VHlwZUJ5RXh0ZW5zaW9uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBleHRlbnNpb24gVGhlIGZpbGUgZXh0ZW5zaW9uIHRvIHVzZSB0byBkZXRlcm1pbmUgdGhlIGxvYWQgdHlwZS5cblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgZGV0ZXJtaW5lZCBsb2FkIHR5cGUgKGZvciBleGFtcGxlLCA8Y29kZT5BYnN0cmFjdExvYWRlci5JTUFHRTwvY29kZT4pLiBXaWxsIHJldHVybiBgbnVsbGAgaWZcblx0ICogdGhlIHR5cGUgY2FuIG5vdCBiZSBkZXRlcm1pbmVkIGJ5IHRoZSBleHRlbnNpb24uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuZ2V0VHlwZUJ5RXh0ZW5zaW9uID0gZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuXHRcdGlmIChleHRlbnNpb24gPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlRFWFQ7XG5cdFx0fVxuXG5cdFx0c3dpdGNoIChleHRlbnNpb24udG9Mb3dlckNhc2UoKSkge1xuXHRcdFx0Y2FzZSBcImpwZWdcIjpcblx0XHRcdGNhc2UgXCJqcGdcIjpcblx0XHRcdGNhc2UgXCJnaWZcIjpcblx0XHRcdGNhc2UgXCJwbmdcIjpcblx0XHRcdGNhc2UgXCJ3ZWJwXCI6XG5cdFx0XHRjYXNlIFwiYm1wXCI6XG5cdFx0XHRcdHJldHVybiBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5JTUFHRTtcblx0XHRcdGNhc2UgXCJvZ2dcIjpcblx0XHRcdGNhc2UgXCJtcDNcIjpcblx0XHRcdGNhc2UgXCJ3ZWJtXCI6XG5cdFx0XHRcdHJldHVybiBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TT1VORDtcblx0XHRcdGNhc2UgXCJtcDRcIjpcblx0XHRcdGNhc2UgXCJ3ZWJtXCI6XG5cdFx0XHRjYXNlIFwidHNcIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlZJREVPO1xuXHRcdFx0Y2FzZSBcImpzb25cIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpTT047XG5cdFx0XHRjYXNlIFwieG1sXCI6XG5cdFx0XHRcdHJldHVybiBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5YTUw7XG5cdFx0XHRjYXNlIFwiY3NzXCI6XG5cdFx0XHRcdHJldHVybiBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5DU1M7XG5cdFx0XHRjYXNlIFwianNcIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpBVkFTQ1JJUFQ7XG5cdFx0XHRjYXNlICdzdmcnOlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU1ZHO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlRFWFQ7XG5cdFx0fVxuXHR9O1xuXG5cdGNyZWF0ZWpzLlJlcXVlc3RVdGlscyA9IHM7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBBYnN0cmFjdExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG4vLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogVGhlIGJhc2UgbG9hZGVyLCB3aGljaCBkZWZpbmVzIGFsbCB0aGUgZ2VuZXJpYyBtZXRob2RzLCBwcm9wZXJ0aWVzLCBhbmQgZXZlbnRzLiBBbGwgbG9hZGVycyBleHRlbmQgdGhpcyBjbGFzcyxcblx0ICogaW5jbHVkaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBjbGFzcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfG9iamVjdHxzdHJpbmd9IGxvYWRJdGVtIFRoZSBpdGVtIHRvIGJlIGxvYWRlZC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcHJlZmVyWEhSXSBEZXRlcm1pbmVzIGlmIHRoZSBMb2FkSXRlbSBzaG91bGQgPGVtPnRyeTwvZW0+IGFuZCBsb2FkIHVzaW5nIFhIUiwgb3IgdGFrZSBhXG5cdCAqIHRhZy1iYXNlZCBhcHByb2FjaCwgd2hpY2ggY2FuIGJlIGJldHRlciBpbiBjcm9zcy1kb21haW4gc2l0dWF0aW9ucy4gTm90IGFsbCBsb2FkZXJzIGNhbiBsb2FkIHVzaW5nIG9uZSBvciB0aGVcblx0ICogb3RoZXIsIHNvIHRoaXMgaXMgYSBzdWdnZXN0ZWQgZGlyZWN0aXZlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIFRoZSB0eXBlIG9mIGxvYWRlci4gTG9hZGVyIHR5cGVzIGFyZSBkZWZpbmVkIGFzIGNvbnN0YW50cyBvbiB0aGUgQWJzdHJhY3RMb2FkZXIgY2xhc3MsXG5cdCAqIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiSU1BR0U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIkNTUzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSwgZXRjLlxuXHQgKiBAZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJcblx0ICovXG5cdGZ1bmN0aW9uIEFic3RyYWN0TG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIsIHR5cGUpIHtcblx0XHR0aGlzLkV2ZW50RGlzcGF0Y2hlcl9jb25zdHJ1Y3RvcigpO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBJZiB0aGUgbG9hZGVyIGhhcyBjb21wbGV0ZWQgbG9hZGluZy4gVGhpcyBwcm92aWRlcyBhIHF1aWNrIGNoZWNrLCBidXQgYWxzbyBlbnN1cmVzIHRoYXQgdGhlIGRpZmZlcmVudCBhcHByb2FjaGVzXG5cdFx0ICogdXNlZCBmb3IgbG9hZGluZyBkbyBub3QgcGlsZSB1cCByZXN1bHRpbmcgaW4gbW9yZSB0aGFuIG9uZSBgY29tcGxldGVgIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBsb2FkZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMubG9hZGVkID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBEZXRlcm1pbmUgaWYgdGhlIGxvYWRlciB3YXMgY2FuY2VsZWQuIENhbmNlbGVkIGxvYWRzIHdpbGwgbm90IGZpcmUgY29tcGxldGUgZXZlbnRzLiBOb3RlIHRoYXQgdGhpcyBwcm9wZXJ0eVxuXHRcdCAqIGlzIHJlYWRvbmx5LCBzbyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gcXVldWVzIHNob3VsZCBiZSBjbG9zZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2Nsb3NlXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogaW5zdGVhZC5cblx0XHQgKiBAcHJvcGVydHkgY2FuY2VsZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMuY2FuY2VsZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IGxvYWQgcHJvZ3Jlc3MgKHBlcmNlbnRhZ2UpIGZvciB0aGlzIGl0ZW0uIFRoaXMgd2lsbCBiZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXG5cdFx0ICpcblx0XHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdFx0ICpcblx0XHQgKiAgICAgdmFyIHF1ZXVlID0gbmV3IGNyZWF0ZWpzLkxvYWRRdWV1ZSgpO1xuXHRcdCAqICAgICBxdWV1ZS5sb2FkRmlsZShcImxhcmdlSW1hZ2UucG5nXCIpO1xuXHRcdCAqICAgICBxdWV1ZS5vbihcInByb2dyZXNzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgICAgY29uc29sZS5sb2coXCJQcm9ncmVzczpcIiwgcXVldWUucHJvZ3Jlc3MsIGV2ZW50LnByb2dyZXNzKTtcblx0XHQgKiAgICAgfSk7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgcHJvZ3Jlc3Ncblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLnByb2dyZXNzID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIGl0ZW0gdGhpcyBsb2FkZXIgd2lsbCBsb2FkLiBTZWUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGEgZnVsbCBsaXN0IG9mXG5cdFx0ICogc3VwcG9ydGVkIHR5cGVzLlxuXHRcdCAqIEBwcm9wZXJ0eSB0eXBlXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBmb3JtYXR0ZXIgZnVuY3Rpb24gdGhhdCBjb252ZXJ0cyB0aGUgbG9hZGVkIHJhdyByZXN1bHQgaW50byB0aGUgZmluYWwgcmVzdWx0LiBGb3IgZXhhbXBsZSwgdGhlIEpTT05Mb2FkZXJcblx0XHQgKiBjb252ZXJ0cyBhIHN0cmluZyBvZiB0ZXh0IGludG8gYSBKYXZhU2NyaXB0IG9iamVjdC4gTm90IGFsbCBsb2FkZXJzIGhhdmUgYSByZXN1bHRGb3JtYXR0ZXIsIGFuZCB0aGlzIHByb3BlcnR5XG5cdFx0ICogY2FuIGJlIG92ZXJyaWRkZW4gdG8gcHJvdmlkZSBjdXN0b20gZm9ybWF0dGluZy5cblx0XHQgKlxuXHRcdCAqIE9wdGlvbmFsbHksIGEgcmVzdWx0Rm9ybWF0dGVyIGNhbiByZXR1cm4gYSBjYWxsYmFjayBmdW5jdGlvbiBpbiBjYXNlcyB3aGVyZSB0aGUgZm9ybWF0dGluZyBuZWVkcyB0byBiZVxuXHRcdCAqIGFzeW5jaHJvbm91cywgc3VjaCBhcyBjcmVhdGluZyBhIG5ldyBpbWFnZS5cblx0XHQgKiBAcHJvcGVydHkgcmVzdWx0Rm9ybWF0dGVyXG5cdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IG51bGw7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSB0aGlzIGxvYWRlciByZXByZXNlbnRzLiBOb3RlIHRoYXQgdGhpcyBpcyBudWxsIGluIGEge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319LFxuXHRcdCAqIGJ1dCB3aWxsIGJlIGF2YWlsYWJsZSBvbiBsb2FkZXJzIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiWE1MTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJJbWFnZUxvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgX2l0ZW1cblx0XHQgKiBAdHlwZSB7TG9hZEl0ZW18T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0aWYgKGxvYWRJdGVtKSB7XG5cdFx0XHR0aGlzLl9pdGVtID0gY3JlYXRlanMuTG9hZEl0ZW0uY3JlYXRlKGxvYWRJdGVtKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5faXRlbSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0aGUgbG9hZGVyIHdpbGwgdHJ5IGFuZCBsb2FkIGNvbnRlbnQgdXNpbmcgWEhSICh0cnVlKSBvciBIVE1MIHRhZ3MgKGZhbHNlKS5cblx0XHQgKiBAcHJvcGVydHkgX3ByZWZlclhIUlxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcHJlZmVyWEhSID0gcHJlZmVyWEhSO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxvYWRlZCByZXN1bHQgYWZ0ZXIgaXQgaXMgZm9ybWF0dGVkIGJ5IGFuIG9wdGlvbmFsIHt7I2Nyb3NzTGluayBcInJlc3VsdEZvcm1hdHRlclwifX17ey9jcm9zc0xpbmt9fS4gRm9yXG5cdFx0ICogaXRlbXMgdGhhdCBhcmUgbm90IGZvcm1hdHRlZCwgdGhpcyB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSB7eyNjcm9zc0xpbmsgXCJfcmF3UmVzdWx0OnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIFRoZSByZXN1bHQgaXMgYWNjZXNzZWQgdXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcImdldFJlc3VsdFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cdFx0ICogQHByb3BlcnR5IF9yZXN1bHRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fFN0cmluZ31cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3Jlc3VsdCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbG9hZGVkIHJlc3VsdCBiZWZvcmUgaXQgaXMgZm9ybWF0dGVkLiBUaGUgcmF3UmVzdWx0IGlzIGFjY2Vzc2VkIHVzaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJnZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBtZXRob2QsIGFuZCBwYXNzaW5nIGB0cnVlYC5cblx0XHQgKiBAcHJvcGVydHkgX3Jhd1Jlc3VsdFxuXHRcdCAqIEB0eXBlIHtPYmplY3R8U3RyaW5nfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcmF3UmVzdWx0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEEgbGlzdCBvZiBpdGVtcyB0aGF0IGxvYWRlcnMgbG9hZCBiZWhpbmQgdGhlIHNjZW5lcy4gVGhpcyBkb2VzIG5vdCBpbmNsdWRlIHRoZSBtYWluIGl0ZW0gdGhlIGxvYWRlciBpc1xuXHRcdCAqIHJlc3BvbnNpYmxlIGZvciBsb2FkaW5nLiBFeGFtcGxlcyBvZiBsb2FkZXJzIHRoYXQgaGF2ZSBzdWItaXRlbXMgaW5jbHVkZSB0aGUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gYW5kXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkSXRlbXNcblx0XHQgKiBAdHlwZSB7bnVsbH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZGVkSXRlbXMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGF0dHJpYnV0ZSB0aGUgaXRlbXMgbG9hZGVkIHVzaW5nIHRhZ3MgdXNlIGZvciB0aGUgc291cmNlLlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fdGFnU3JjQXR0cmlidXRlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIEhUTUwgdGFnIChvciBzaW1pbGFyKSB0aGF0IGEgbG9hZGVyIG1heSB1c2UgdG8gbG9hZCBIVE1MIGNvbnRlbnQsIHN1Y2ggYXMgaW1hZ2VzLCBzY3JpcHRzLCBldGMuXG5cdFx0ICogQHByb3BlcnR5IF90YWdcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fdGFnID0gbnVsbDtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChBYnN0cmFjdExvYWRlciwgY3JlYXRlanMuRXZlbnREaXNwYXRjaGVyKTtcblx0dmFyIHMgPSBBYnN0cmFjdExvYWRlcjtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG5cdC8qKlxuXHQgKiBEZWZpbmVzIGEgUE9TVCByZXF1ZXN0LCB1c2UgZm9yIGEgbWV0aG9kIHZhbHVlIHdoZW4gbG9hZGluZyBkYXRhLlxuXHQgKiBAcHJvcGVydHkgUE9TVFxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBwb3N0XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuUE9TVCA9IFwiUE9TVFwiO1xuXG5cdC8qKlxuXHQgKiBEZWZpbmVzIGEgR0VUIHJlcXVlc3QsIHVzZSBmb3IgYSBtZXRob2QgdmFsdWUgd2hlbiBsb2FkaW5nIGRhdGEuXG5cdCAqIEBwcm9wZXJ0eSBHRVRcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICogQGRlZmF1bHQgZ2V0XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuR0VUID0gXCJHRVRcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgZ2VuZXJpYyBiaW5hcnkgdHlwZXMuIE5vdGUgdGhhdCBpbWFnZXMgYXJlIGxvYWRlZCBhcyBiaW5hcnkgZmlsZXMgd2hlbiB1c2luZyBYSFIuXG5cdCAqIEBwcm9wZXJ0eSBCSU5BUllcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgYmluYXJ5XG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLkJJTkFSWSA9IFwiYmluYXJ5XCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGNzcyBmaWxlcy4gQ1NTIGZpbGVzIGFyZSBsb2FkZWQgdXNpbmcgYSAmbHQ7bGluayZndDsgd2hlbiBsb2FkZWQgd2l0aCBYSFIsIG9yIGFcblx0ICogJmx0O3N0eWxlJmd0OyB0YWcgd2hlbiBsb2FkZWQgd2l0aCB0YWdzLlxuXHQgKiBAcHJvcGVydHkgQ1NTXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGNzc1xuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5DU1MgPSBcImNzc1wiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBpbWFnZSBmaWxlcywgdXN1YWxseSBwbmcsIGdpZiwgb3IganBnL2pwZWcuIEltYWdlcyBhcmUgbG9hZGVkIGludG8gYW4gJmx0O2ltYWdlJmd0OyB0YWcuXG5cdCAqIEBwcm9wZXJ0eSBJTUFHRVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBpbWFnZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5JTUFHRSA9IFwiaW1hZ2VcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgamF2YXNjcmlwdCBmaWxlcywgdXN1YWxseSB3aXRoIHRoZSBcImpzXCIgZmlsZSBleHRlbnNpb24uIEphdmFTY3JpcHQgZmlsZXMgYXJlIGxvYWRlZCBpbnRvIGFcblx0ICogJmx0O3NjcmlwdCZndDsgdGFnLlxuXHQgKlxuXHQgKiBTaW5jZSB2ZXJzaW9uIDAuNC4xKywgZHVlIHRvIGhvdyB0YWctbG9hZGVkIHNjcmlwdHMgd29yaywgYWxsIEphdmFTY3JpcHQgZmlsZXMgYXJlIGF1dG9tYXRpY2FsbHkgaW5qZWN0ZWQgaW50b1xuXHQgKiB0aGUgYm9keSBvZiB0aGUgZG9jdW1lbnQgdG8gbWFpbnRhaW4gcGFyaXR5IGJldHdlZW4gWEhSIGFuZCB0YWctbG9hZGVkIHNjcmlwdHMuIEluIHZlcnNpb24gMC40LjAgYW5kIGVhcmxpZXIsXG5cdCAqIG9ubHkgdGFnLWxvYWRlZCBzY3JpcHRzIGFyZSBpbmplY3RlZC5cblx0ICogQHByb3BlcnR5IEpBVkFTQ1JJUFRcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgamF2YXNjcmlwdFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5KQVZBU0NSSVBUID0gXCJqYXZhc2NyaXB0XCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGpzb24gZmlsZXMsIHVzdWFsbHkgd2l0aCB0aGUgXCJqc29uXCIgZmlsZSBleHRlbnNpb24uIEpTT04gZGF0YSBpcyBsb2FkZWQgYW5kIHBhcnNlZCBpbnRvIGFcblx0ICogSmF2YVNjcmlwdCBvYmplY3QuIE5vdGUgdGhhdCBpZiBhIGBjYWxsYmFja2AgaXMgcHJlc2VudCBvbiB0aGUgbG9hZCBpdGVtLCB0aGUgZmlsZSB3aWxsIGJlIGxvYWRlZCB3aXRoIEpTT05QLFxuXHQgKiBubyBtYXR0ZXIgd2hhdCB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3ByZWZlclhIUjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpcyBzZXQgdG8sIGFuZCB0aGUgSlNPTlxuXHQgKiBtdXN0IGNvbnRhaW4gYSBtYXRjaGluZyB3cmFwcGVyIGZ1bmN0aW9uLlxuXHQgKiBAcHJvcGVydHkgSlNPTlxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBqc29uXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLkpTT04gPSBcImpzb25cIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IganNvbnAgZmlsZXMsIHVzdWFsbHkgd2l0aCB0aGUgXCJqc29uXCIgZmlsZSBleHRlbnNpb24uIEpTT04gZGF0YSBpcyBsb2FkZWQgYW5kIHBhcnNlZCBpbnRvIGFcblx0ICogSmF2YVNjcmlwdCBvYmplY3QuIFlvdSBhcmUgcmVxdWlyZWQgdG8gcGFzcyBhIGNhbGxiYWNrIHBhcmFtZXRlciB0aGF0IG1hdGNoZXMgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgaW4gdGhlIEpTT04uXG5cdCAqIE5vdGUgdGhhdCBKU09OUCB3aWxsIGFsd2F5cyBiZSB1c2VkIGlmIHRoZXJlIGlzIGEgY2FsbGJhY2sgcHJlc2VudCwgbm8gbWF0dGVyIHdoYXQgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9wcmVmZXJYSFI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogcHJvcGVydHkgaXMgc2V0IHRvLlxuXHQgKiBAcHJvcGVydHkgSlNPTlBcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQganNvbnBcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuSlNPTlAgPSBcImpzb25wXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGpzb24tYmFzZWQgbWFuaWZlc3QgZmlsZXMsIHVzdWFsbHkgd2l0aCB0aGUgXCJqc29uXCIgZmlsZSBleHRlbnNpb24uIFRoZSBKU09OIGRhdGEgaXMgbG9hZGVkXG5cdCAqIGFuZCBwYXJzZWQgaW50byBhIEphdmFTY3JpcHQgb2JqZWN0LiBQcmVsb2FkSlMgd2lsbCB0aGVuIGxvb2sgZm9yIGEgXCJtYW5pZmVzdFwiIHByb3BlcnR5IGluIHRoZSBKU09OLCB3aGljaCBpcyBhblxuXHQgKiBBcnJheSBvZiBmaWxlcyB0byBsb2FkLCBmb2xsb3dpbmcgdGhlIHNhbWUgZm9ybWF0IGFzIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC4gSWYgYSBcImNhbGxiYWNrXCIgaXMgc3BlY2lmaWVkIG9uIHRoZSBtYW5pZmVzdCBvYmplY3QsIHRoZW4gaXQgd2lsbCBiZSBsb2FkZWQgdXNpbmcgSlNPTlAgaW5zdGVhZCxcblx0ICogcmVnYXJkbGVzcyBvZiB3aGF0IHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvcHJlZmVyWEhSOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGlzIHNldCB0by5cblx0ICogQHByb3BlcnR5IE1BTklGRVNUXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IG1hbmlmZXN0XG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLk1BTklGRVNUID0gXCJtYW5pZmVzdFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBzb3VuZCBmaWxlcywgdXN1YWxseSBtcDMsIG9nZywgb3Igd2F2LiBXaGVuIGxvYWRpbmcgdmlhIHRhZ3MsIGF1ZGlvIGlzIGxvYWRlZCBpbnRvIGFuXG5cdCAqICZsdDthdWRpbyZndDsgdGFnLlxuXHQgKiBAcHJvcGVydHkgU09VTkRcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgc291bmRcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuU09VTkQgPSBcInNvdW5kXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIHZpZGVvIGZpbGVzLCB1c3VhbGx5IG1wNCwgdHMsIG9yIG9nZy4gV2hlbiBsb2FkaW5nIHZpYSB0YWdzLCB2aWRlbyBpcyBsb2FkZWQgaW50byBhblxuXHQgKiAmbHQ7dmlkZW8mZ3Q7IHRhZy5cblx0ICogQHByb3BlcnR5IFZJREVPXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHZpZGVvXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLlZJREVPID0gXCJ2aWRlb1wiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBTcHJpdGVTaGVldCBmaWxlcy4gU3ByaXRlU2hlZXQgZmlsZXMgYXJlIEpTT04gZmlsZXMgdGhhdCBjb250YWluIHN0cmluZyBpbWFnZSBwYXRocy5cblx0ICogQHByb3BlcnR5IFNQUklURVNIRUVUXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHNwcml0ZXNoZWV0XG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLlNQUklURVNIRUVUID0gXCJzcHJpdGVzaGVldFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBTVkcgZmlsZXMuXG5cdCAqIEBwcm9wZXJ0eSBTVkdcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgc3ZnXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLlNWRyA9IFwic3ZnXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIHRleHQgZmlsZXMsIHdoaWNoIGlzIGFsc28gdGhlIGRlZmF1bHQgZmlsZSB0eXBlIGlmIHRoZSB0eXBlIGNhbiBub3QgYmUgZGV0ZXJtaW5lZC4gVGV4dCBpc1xuXHQgKiBsb2FkZWQgYXMgcmF3IHRleHQuXG5cdCAqIEBwcm9wZXJ0eSBURVhUXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHRleHRcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuVEVYVCA9IFwidGV4dFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciB4bWwgZmlsZXMuIFhNTCBpcyBsb2FkZWQgaW50byBhbiBYTUwgZG9jdW1lbnQuXG5cdCAqIEBwcm9wZXJ0eSBYTUxcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgeG1sXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLlhNTCA9IFwieG1sXCI7XG5cbi8vIEV2ZW50c1xuXHQvKipcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIlByb2dyZXNzRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIHRoZSBvdmVyYWxsIHByb2dyZXNzIGNoYW5nZXMuIFByaW9yIHRvXG5cdCAqIHZlcnNpb24gMC42LjAsIHRoaXMgd2FzIGp1c3QgYSByZWd1bGFyIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAZXZlbnQgcHJvZ3Jlc3Ncblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGUge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIGEgbG9hZCBzdGFydHMuXG5cdCAqIEBldmVudCBsb2Fkc3RhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAc2luY2UgMC4zLjFcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIHdoZW4gdGhlIGVudGlyZSBxdWV1ZSBoYXMgYmVlbiBsb2FkZWQuXG5cdCAqIEBldmVudCBjb21wbGV0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBzaW5jZSAwLjMuMFxuXHQgKi9cblxuXHQvKipcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIkVycm9yRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIHRoZSBsb2FkZXIgZW5jb3VudGVycyBhbiBlcnJvci4gSWYgdGhlIGVycm9yIHdhc1xuXHQgKiBlbmNvdW50ZXJlZCBieSBhIGZpbGUsIHRoZSBldmVudCB3aWxsIGNvbnRhaW4gdGhlIGl0ZW0gdGhhdCBjYXVzZWQgdGhlIGVycm9yLiBQcmlvciB0byB2ZXJzaW9uIDAuNi4wLCB0aGlzIHdhc1xuXHQgKiBqdXN0IGEgcmVndWxhciB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQGV2ZW50IGVycm9yXG5cdCAqIEBzaW5jZSAwLjMuMFxuXHQgKi9cblxuXHQvKipcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgd2hlbiB0aGUgbG9hZGVyIGVuY291bnRlcnMgYW4gaW50ZXJuYWwgZmlsZSBsb2FkIGVycm9yLlxuXHQgKiBUaGlzIGVuYWJsZXMgbG9hZGVycyB0byBtYWludGFpbiBpbnRlcm5hbCBxdWV1ZXMsIGFuZCBzdXJmYWNlIGZpbGUgbG9hZCBlcnJvcnMuXG5cdCAqIEBldmVudCBmaWxlZXJyb3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVuIHR5cGUgKFwiZmlsZWVycm9yXCIpXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18b2JqZWN0fSBUaGUgaXRlbSB0aGF0IGVuY291bnRlcmVkIHRoZSBlcnJvclxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIHdoZW4gYSBsb2FkZXIgaW50ZXJuYWxseSBsb2FkcyBhIGZpbGUuIFRoaXMgZW5hYmxlc1xuXHQgKiBsb2FkZXJzIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gdG8gbWFpbnRhaW4gaW50ZXJuYWwge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319c1xuXHQgKiBhbmQgbm90aWZ5IHdoZW4gdGhleSBoYXZlIGxvYWRlZCBhIGZpbGUuIFRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZGlzcGF0Y2hlcyBhXG5cdCAqIHNsaWdodGx5IGRpZmZlcmVudCB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZWxvYWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQuXG5cdCAqIEBldmVudCBmaWxlbG9hZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUgKFwiZmlsZWxvYWRcIilcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIGZpbGUgaXRlbSB3aGljaCB3YXMgc3BlY2lmaWVkIGluIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogb3Ige3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fSBjYWxsLiBJZiBvbmx5IGEgc3RyaW5nIHBhdGggb3IgdGFnIHdhcyBzcGVjaWZpZWQsIHRoZVxuXHQgKiBvYmplY3Qgd2lsbCBjb250YWluIHRoYXQgdmFsdWUgYXMgYSBgc3JjYCBwcm9wZXJ0eS5cblx0ICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCBUaGUgSFRNTCB0YWcgb3IgcGFyc2VkIHJlc3VsdCBvZiB0aGUgbG9hZGVkIGl0ZW0uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByYXdSZXN1bHQgVGhlIHVucHJvY2Vzc2VkIHJlc3VsdCwgdXN1YWxseSB0aGUgcmF3IHRleHQgb3IgYmluYXJ5IGRhdGEgYmVmb3JlIGl0IGlzIGNvbnZlcnRlZFxuXHQgKiB0byBhIHVzYWJsZSBvYmplY3QuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgYWZ0ZXIgdGhlIGludGVybmFsIHJlcXVlc3QgaXMgY3JlYXRlZCwgYnV0IGJlZm9yZSBhIGxvYWQuXG5cdCAqIFRoaXMgYWxsb3dzIHVwZGF0ZXMgdG8gdGhlIGxvYWRlciBmb3Igc3BlY2lmaWMgbG9hZGluZyBuZWVkcywgc3VjaCBhcyBiaW5hcnkgb3IgWEhSIGltYWdlIGxvYWRpbmcuXG5cdCAqIEBldmVudCBpbml0aWFsaXplXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZSAoXCJpbml0aWFsaXplXCIpXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlciBUaGUgbG9hZGVyIHRoYXQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG5cdCAqL1xuXG5cblx0LyoqXG5cdCAqIEdldCBhIHJlZmVyZW5jZSB0byB0aGUgbWFuaWZlc3QgaXRlbSB0aGF0IGlzIGxvYWRlZCBieSB0aGlzIGxvYWRlci4gSW4gc29tZSBjYXNlcyB0aGlzIHdpbGwgYmUgdGhlIHZhbHVlIHRoYXQgd2FzXG5cdCAqIHBhc3NlZCBpbnRvIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fS4gSG93ZXZlciBpZiBvbmx5IGEgU3RyaW5nIHBhdGggd2FzIHBhc3NlZCBpbiwgdGhlbiBpdCB3aWxsXG5cdCAqIGJlIGEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgZ2V0SXRlbVxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBtYW5pZmVzdCBpdGVtIHRoYXQgdGhpcyBsb2FkZXIgaXMgcmVzcG9uc2libGUgZm9yIGxvYWRpbmcuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5nZXRJdGVtID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9pdGVtO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIGNvbnRlbnQgdGhhdCB3YXMgbG9hZGVkIGJ5IHRoZSBsb2FkZXIgKG9ubHkgYXZhaWxhYmxlIGFmdGVyIHRoZSB7eyNjcm9zc0xpbmsgXCJjb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBpcyBkaXNwYXRjaGVkLlxuXHQgKiBAbWV0aG9kIGdldFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyYXc9ZmFsc2VdIERldGVybWluZXMgaWYgdGhlIHJldHVybmVkIHJlc3VsdCB3aWxsIGJlIHRoZSBmb3JtYXR0ZWQgY29udGVudCwgb3IgdGhlIHJhdyBsb2FkZWRcblx0ICogZGF0YSAoaWYgaXQgZXhpc3RzKS5cblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuZ2V0UmVzdWx0ID0gZnVuY3Rpb24gKHJhdykge1xuXHRcdHJldHVybiByYXcgPyB0aGlzLl9yYXdSZXN1bHQgOiB0aGlzLl9yZXN1bHQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgYHRhZ2AgdGhpcyBvYmplY3QgY3JlYXRlcyBvciB1c2VzIGZvciBsb2FkaW5nLlxuXHQgKiBAbWV0aG9kIGdldFRhZ1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB0YWcgaW5zdGFuY2Vcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmdldFRhZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdGFnO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGB0YWdgIHRoaXMgaXRlbSB1c2VzIGZvciBsb2FkaW5nLlxuXHQgKiBAbWV0aG9kIHNldFRhZ1xuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFnIFRoZSB0YWcgaW5zdGFuY2Vcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLnNldFRhZyA9IGZ1bmN0aW9uKHRhZykge1xuXHQgIHRoaXMuX3RhZyA9IHRhZztcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW4gbG9hZGluZyB0aGUgaXRlbS4gVGhpcyBtZXRob2QgaXMgcmVxdWlyZWQgd2hlbiB1c2luZyBhIGxvYWRlciBieSBpdHNlbGYuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG5cdCAqICAgICAgcXVldWUub24oXCJjb21wbGV0ZVwiLCBoYW5kbGVDb21wbGV0ZSk7XG5cdCAqICAgICAgcXVldWUubG9hZE1hbmlmZXN0KGZpbGVBcnJheSwgZmFsc2UpOyAvLyBOb3RlIHRoZSAybmQgYXJndW1lbnQgdGhhdCB0ZWxscyB0aGUgcXVldWUgbm90IHRvIHN0YXJ0IGxvYWRpbmcgeWV0XG5cdCAqICAgICAgcXVldWUubG9hZCgpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIGxvYWRcblx0ICovXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jcmVhdGVSZXF1ZXN0KCk7XG5cblx0XHR0aGlzLl9yZXF1ZXN0Lm9uKFwiY29tcGxldGVcIiwgdGhpcywgdGhpcyk7XG5cdFx0dGhpcy5fcmVxdWVzdC5vbihcInByb2dyZXNzXCIsIHRoaXMsIHRoaXMpO1xuXHRcdHRoaXMuX3JlcXVlc3Qub24oXCJsb2FkU3RhcnRcIiwgdGhpcywgdGhpcyk7XG5cdFx0dGhpcy5fcmVxdWVzdC5vbihcImFib3J0XCIsIHRoaXMsIHRoaXMpO1xuXHRcdHRoaXMuX3JlcXVlc3Qub24oXCJ0aW1lb3V0XCIsIHRoaXMsIHRoaXMpO1xuXHRcdHRoaXMuX3JlcXVlc3Qub24oXCJlcnJvclwiLCB0aGlzLCB0aGlzKTtcblxuXHRcdHZhciBldnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJpbml0aWFsaXplXCIpO1xuXHRcdGV2dC5sb2FkZXIgPSB0aGlzLl9yZXF1ZXN0O1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuXG5cdFx0dGhpcy5fcmVxdWVzdC5sb2FkKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENsb3NlIHRoZSB0aGUgaXRlbS4gVGhpcyB3aWxsIHN0b3AgYW55IG9wZW4gcmVxdWVzdHMgKGFsdGhvdWdoIGRvd25sb2FkcyB1c2luZyBIVE1MIHRhZ3MgbWF5IHN0aWxsIGNvbnRpbnVlIGluXG5cdCAqIHRoZSBiYWNrZ3JvdW5kKSwgYnV0IGV2ZW50cyB3aWxsIG5vdCBsb25nZXIgYmUgZGlzcGF0Y2hlZC5cblx0ICogQG1ldGhvZCBjYW5jZWxcblx0ICovXG5cdHAuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY2FuY2VsZWQgPSB0cnVlO1xuXHRcdHRoaXMuZGVzdHJveSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cCB0aGUgbG9hZGVyLlxuXHQgKiBAbWV0aG9kIGRlc3Ryb3lcblx0ICovXG5cdHAuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9yZXF1ZXN0KSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LmRlc3Ryb3koKTtcblx0XHR9XG5cblx0XHR0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcblxuXHRcdHRoaXMuX2l0ZW0gPSBudWxsO1xuXHRcdHRoaXMuX3Jhd1Jlc3VsdCA9IG51bGw7XG5cdFx0dGhpcy5fcmVzdWx0ID0gbnVsbDtcblxuXHRcdHRoaXMuX2xvYWRJdGVtcyA9IG51bGw7XG5cblx0XHR0aGlzLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCBhbnkgaXRlbXMgbG9hZGVkIGludGVybmFsbHkgYnkgdGhlIGxvYWRlci4gVGhlIGVuYWJsZXMgbG9hZGVycyBzdWNoIGFzIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHRvIGV4cG9zZSBpdGVtcyBpdCBsb2FkcyBpbnRlcm5hbGx5LlxuXHQgKiBAbWV0aG9kIGdldExvYWRlZEl0ZW1zXG5cdCAqIEByZXR1cm4ge0FycmF5fSBBIGxpc3Qgb2YgdGhlIGl0ZW1zIGxvYWRlZCBieSB0aGUgbG9hZGVyLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuZ2V0TG9hZGVkSXRlbXMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRlZEl0ZW1zO1xuXHR9O1xuXG5cblx0Ly8gUHJpdmF0ZSBtZXRob2RzXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW4gaW50ZXJuYWwgcmVxdWVzdCB1c2VkIGZvciBsb2FkaW5nLiBCeSBkZWZhdWx0LCBhbiB7eyNjcm9zc0xpbmsgXCJYSFJSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdCAqIHt7I2Nyb3NzTGluayBcIlRhZ1JlcXVlc3RcIn19e3svY3Jvc3NMaW5rfX0gaXMgY3JlYXRlZCwgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiB7eyNjcm9zc0xpbmsgXCJwcmVmZXJYSFI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIE90aGVyIGxvYWRlcnMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gdXNlIGRpZmZlcmVudCByZXF1ZXN0IHR5cGVzLCBzdWNoIGFzIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiB3aGljaCB1c2VzIHt7I2Nyb3NzTGluayBcIkpTT05Mb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gb3Ige3sjY3Jvc3NMaW5rIFwiSlNPTlBMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gdW5kZXIgdGhlIGhvb2QuXG5cdCAqIEBtZXRob2QgX2NyZWF0ZVJlcXVlc3Rcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fcHJlZmVyWEhSKSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLlRhZ1JlcXVlc3QodGhpcy5faXRlbSwgdGhpcy5fdGFnIHx8IHRoaXMuX2NyZWF0ZVRhZygpLCB0aGlzLl90YWdTcmNBdHRyaWJ1dGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLlhIUlJlcXVlc3QodGhpcy5faXRlbSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgdGhlIEhUTUwgdGFnIHVzZWQgZm9yIGxvYWRpbmcuIFRoaXMgbWV0aG9kIGRvZXMgbm90aGluZyBieSBkZWZhdWx0LCBhbmQgbmVlZHMgdG8gYmUgaW1wbGVtZW50ZWRcblx0ICogYnkgbG9hZGVycyB0aGF0IHJlcXVpcmUgdGFnIGxvYWRpbmcuXG5cdCAqIEBtZXRob2QgX2NyZWF0ZVRhZ1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSB0YWcgc291cmNlXG5cdCAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBUaGUgdGFnIHRoYXQgd2FzIGNyZWF0ZWRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fY3JlYXRlVGFnID0gZnVuY3Rpb24oc3JjKSB7IHJldHVybiBudWxsOyB9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhIGxvYWRzdGFydCB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvbG9hZHN0YXJ0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IGZvciBkZXRhaWxzIG9uIHRoZSBldmVudCBwYXlsb2FkLlxuXHQgKiBAbWV0aG9kIF9zZW5kTG9hZFN0YXJ0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3NlbmRMb2FkU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2lzQ2FuY2VsZWQoKSkgeyByZXR1cm47IH1cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJsb2Fkc3RhcnRcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoIGEge3sjY3Jvc3NMaW5rIFwiUHJvZ3Jlc3NFdmVudFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBfc2VuZFByb2dyZXNzXG5cdCAqIEBwYXJhbSB7TnVtYmVyIHwgT2JqZWN0fSB2YWx1ZSBUaGUgcHJvZ3Jlc3Mgb2YgdGhlIGxvYWRlZCBpdGVtLCBvciBhbiBvYmplY3QgY29udGFpbmluZyA8Y29kZT5sb2FkZWQ8L2NvZGU+XG5cdCAqIGFuZCA8Y29kZT50b3RhbDwvY29kZT4gcHJvcGVydGllcy5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2VuZFByb2dyZXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMuX2lzQ2FuY2VsZWQoKSkgeyByZXR1cm47IH1cblx0XHR2YXIgZXZlbnQgPSBudWxsO1xuXHRcdGlmICh0eXBlb2YodmFsdWUpID09IFwibnVtYmVyXCIpIHtcblx0XHRcdHRoaXMucHJvZ3Jlc3MgPSB2YWx1ZTtcblx0XHRcdGV2ZW50ID0gbmV3IGNyZWF0ZWpzLlByb2dyZXNzRXZlbnQodGhpcy5wcm9ncmVzcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV2ZW50ID0gdmFsdWU7XG5cdFx0XHR0aGlzLnByb2dyZXNzID0gdmFsdWUubG9hZGVkIC8gdmFsdWUudG90YWw7XG5cdFx0XHRldmVudC5wcm9ncmVzcyA9IHRoaXMucHJvZ3Jlc3M7XG5cdFx0XHRpZiAoaXNOYU4odGhpcy5wcm9ncmVzcykgfHwgdGhpcy5wcm9ncmVzcyA9PSBJbmZpbml0eSkgeyB0aGlzLnByb2dyZXNzID0gMDsgfVxuXHRcdH1cblx0XHR0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiKSAmJiB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhIGNvbXBsZXRlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9jb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudFxuXHQgKiBAbWV0aG9kIF9zZW5kQ29tcGxldGVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2VuZENvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9pc0NhbmNlbGVkKCkpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLmxvYWRlZCA9IHRydWU7XG5cblx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJjb21wbGV0ZVwiKTtcblx0XHRldmVudC5yYXdSZXN1bHQgPSB0aGlzLl9yYXdSZXN1bHQ7XG5cblx0XHRpZiAodGhpcy5fcmVzdWx0ICE9IG51bGwpIHtcblx0XHRcdGV2ZW50LnJlc3VsdCA9IHRoaXMuX3Jlc3VsdDtcblx0XHR9XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhbiBlcnJvciB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvZXJyb3I6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgZm9yIGRldGFpbHMgb24gdGhlIGV2ZW50IHBheWxvYWQuXG5cdCAqIEBtZXRob2QgX3NlbmRFcnJvclxuXHQgKiBAcGFyYW0ge0Vycm9yRXZlbnR9IGV2ZW50IFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBzcGVjaWZpYyBlcnJvciBwcm9wZXJ0aWVzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZW5kRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRpZiAodGhpcy5faXNDYW5jZWxlZCgpIHx8ICF0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJlcnJvclwiKSkgeyByZXR1cm47IH1cblx0XHRpZiAoZXZlbnQgPT0gbnVsbCkge1xuXHRcdFx0ZXZlbnQgPSBuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlBSRUxPQURfRVJST1JfRU1QVFlcIik7IC8vIFRPRE86IFBvcHVsYXRlIGVycm9yXG5cdFx0fVxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSBpZiB0aGUgbG9hZCBoYXMgYmVlbiBjYW5jZWxlZC4gVGhpcyBpcyBpbXBvcnRhbnQgdG8gZW5zdXJlIHRoYXQgbWV0aG9kIGNhbGxzIG9yIGFzeW5jaHJvbm91cyBldmVudHNcblx0ICogZG8gbm90IGNhdXNlIGlzc3VlcyBhZnRlciB0aGUgcXVldWUgaGFzIGJlZW4gY2xlYW5lZCB1cC5cblx0ICogQG1ldGhvZCBfaXNDYW5jZWxlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgbG9hZGVyIGhhcyBiZWVuIGNhbmNlbGVkLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9pc0NhbmNlbGVkID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh3aW5kb3cuY3JlYXRlanMgPT0gbnVsbCB8fCB0aGlzLmNhbmNlbGVkKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBIGN1c3RvbSByZXN1bHQgZm9ybWF0dGVyIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWQganVzdCBiZWZvcmUgYSByZXF1ZXN0IGRpc3BhdGNoZXMgaXRzIGNvbXBsZXRlIGV2ZW50LiBNb3N0XG5cdCAqIGxvYWRlciB0eXBlcyBhbHJlYWR5IGhhdmUgYW4gaW50ZXJuYWwgZm9ybWF0dGVyLCBidXQgdGhpcyBjYW4gYmUgdXNlci1vdmVycmlkZGVuIGZvciBjdXN0b20gZm9ybWF0dGluZy4gVGhlXG5cdCAqIGZvcm1hdHRlZCByZXN1bHQgd2lsbCBiZSBhdmFpbGFibGUgb24gTG9hZGVycyB1c2luZyB7eyNjcm9zc0xpbmsgXCJnZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCBwYXNzaW5nIGB0cnVlYC5cblx0ICogQHByb3BlcnR5IHJlc3VsdEZvcm1hdHRlclxuXHQgKiBAdHlwZSBGdW5jdGlvblxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBmb3JtYXR0ZWQgcmVzdWx0XG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5yZXN1bHRGb3JtYXR0ZXIgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBIYW5kbGUgZXZlbnRzIGZyb20gaW50ZXJuYWwgcmVxdWVzdHMuIEJ5IGRlZmF1bHQsIGxvYWRlcnMgd2lsbCBoYW5kbGUsIGFuZCByZWRpc3BhdGNoIHRoZSBuZWNlc3NhcnkgZXZlbnRzLCBidXRcblx0ICogdGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gZm9yIGN1c3RvbSBiZWhhdmlvdXJzLlxuXHQgKiBAbWV0aG9kIGhhbmRsZUV2ZW50XG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0aGF0IHRoZSBpbnRlcm5hbCByZXF1ZXN0IGRpc3BhdGNoZXMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0c3dpdGNoIChldmVudC50eXBlKSB7XG5cdFx0XHRjYXNlIFwiY29tcGxldGVcIjpcblx0XHRcdFx0dGhpcy5fcmF3UmVzdWx0ID0gZXZlbnQudGFyZ2V0Ll9yZXNwb25zZTtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0Rm9ybWF0dGVyICYmIHRoaXMucmVzdWx0Rm9ybWF0dGVyKHRoaXMpO1xuXHRcdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdFx0XHRpZiAocmVzdWx0IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdFx0XHRyZXN1bHQoZnVuY3Rpb24ocmVzdWx0KSB7XG5cdFx0XHRcdFx0XHRfdGhpcy5fcmVzdWx0ID0gcmVzdWx0O1xuXHRcdFx0XHRcdFx0X3RoaXMuX3NlbmRDb21wbGV0ZSgpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3Jlc3VsdCA9ICByZXN1bHQgfHwgdGhpcy5fcmF3UmVzdWx0O1xuXHRcdFx0XHRcdHRoaXMuX3NlbmRDb21wbGV0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInByb2dyZXNzXCI6XG5cdFx0XHRcdHRoaXMuX3NlbmRQcm9ncmVzcyhldmVudCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImVycm9yXCI6XG5cdFx0XHRcdHRoaXMuX3NlbmRFcnJvcihldmVudCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImxvYWRzdGFydFwiOlxuXHRcdFx0XHR0aGlzLl9zZW5kTG9hZFN0YXJ0KCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImFib3J0XCI6XG5cdFx0XHRjYXNlIFwidGltZW91dFwiOlxuXHRcdFx0XHRpZiAoIXRoaXMuX2lzQ2FuY2VsZWQoKSkge1xuXHRcdFx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldmVudC50eXBlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgYnVpbGRQYXRoXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJSZXF1ZXN0VXRpbHNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIHt7I2Nyb3NzTGluayBcIlJlcXVlc3RVdGlscy9idWlsZFBhdGhcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaW5zdGVhZC5cblx0ICovXG5cdHAuYnVpbGRQYXRoID0gZnVuY3Rpb24gKHNyYywgZGF0YSkge1xuXHRcdHJldHVybiBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuYnVpbGRQYXRoKHNyYywgZGF0YSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltQcmVsb2FkSlMgQWJzdHJhY3RMb2FkZXJdXCI7XG5cdH07XG5cblx0Y3JlYXRlanMuQWJzdHJhY3RMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEFic3RyYWN0TG9hZGVyLCBcIkV2ZW50RGlzcGF0Y2hlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEFic3RyYWN0TWVkaWFMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogVGhlIEFic3RyYWN0TWVkaWFMb2FkZXIgaXMgYSBiYXNlIGNsYXNzIHRoYXQgaGFuZGxlcyBzb21lIG9mIHRoZSBzaGFyZWQgbWV0aG9kcyBhbmQgcHJvcGVydGllcyBvZiBsb2FkZXJzIHRoYXRcblx0ICogaGFuZGxlIEhUTUwgbWVkaWEgZWxlbWVudHMsIHN1Y2ggYXMgVmlkZW8gYW5kIEF1ZGlvLlxuXHQgKiBAY2xhc3MgQWJzdHJhY3RNZWRpYUxvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgbWVkaWEgdG8gbG9hZC4gVXN1YWxseSBcInZpZGVvXCIgb3IgXCJhdWRpb1wiLlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEFic3RyYWN0TWVkaWFMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUiwgdHlwZSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgdHlwZSk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBcInNyY1wiO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEFic3RyYWN0TWVkaWFMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblxuXHQvLyBzdGF0aWMgcHJvcGVydGllc1xuXHQvLyBwdWJsaWMgbWV0aG9kc1xuXHRwLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVGFnUmVxdWVzdCB3aWxsIGhhbmRsZSBtb3N0IG9mIHRoaXMsIGJ1dCBTb3VuZCAvIFZpZGVvIG5lZWQgYSBmZXcgY3VzdG9tIHByb3BlcnRpZXMsIHNvIGp1c3QgaGFuZGxlIHRoZW0gaGVyZS5cblx0XHRpZiAoIXRoaXMuX3RhZykge1xuXHRcdFx0dGhpcy5fdGFnID0gdGhpcy5fY3JlYXRlVGFnKHRoaXMuX2l0ZW0uc3JjKTtcblx0XHR9XG5cblx0XHR0aGlzLl90YWcucHJlbG9hZCA9IFwiYXV0b1wiO1xuXHRcdHRoaXMuX3RhZy5sb2FkKCk7XG5cblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2xvYWQoKTtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyB0YWcgZm9yIGxvYWRpbmcgaWYgaXQgZG9lc24ndCBleGlzdCB5ZXQuXG5cdCAqIEBtZXRob2QgX2NyZWF0ZVRhZ1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY3JlYXRlVGFnID0gZnVuY3Rpb24gKCkge307XG5cblxuXHRwLl9jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9wcmVmZXJYSFIpIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuTWVkaWFUYWdSZXF1ZXN0KHRoaXMuX2l0ZW0sIHRoaXMuX3RhZyB8fCB0aGlzLl9jcmVhdGVUYWcoKSwgdGhpcy5fdGFnU3JjQXR0cmlidXRlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5YSFJSZXF1ZXN0KHRoaXMuX2l0ZW0pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIG1lZGlhIGZpbGVzLlxuXHQgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEByZXR1cm5zIHtIVE1MVmlkZW9FbGVtZW50fEhUTUxBdWRpb0VsZW1lbnR9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9mb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0dGhpcy5fdGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIgJiYgdGhpcy5fdGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5dGhyb3VnaFwiLCB0aGlzLl9sb2FkZWRIYW5kbGVyKTtcblx0XHR0aGlzLl90YWcub25zdGFsbGVkID0gbnVsbDtcblx0XHRpZiAodGhpcy5fcHJlZmVyWEhSKSB7XG5cdFx0XHRsb2FkZXIuZ2V0VGFnKCkuc3JjID0gbG9hZGVyLmdldFJlc3VsdCh0cnVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIGxvYWRlci5nZXRUYWcoKTtcblx0fTtcblxuXHRjcmVhdGVqcy5BYnN0cmFjdE1lZGlhTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShBYnN0cmFjdE1lZGlhTG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQWJzdHJhY3RSZXF1ZXN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIEEgYmFzZSBjbGFzcyBmb3IgYWN0dWFsIGRhdGEgcmVxdWVzdHMsIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiWEhSUmVxdWVzdFwifX17ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiVGFnUmVxdWVzdFwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogYW5kIHt7I2Nyb3NzTGluayBcIk1lZGlhUmVxdWVzdFwifX17ey9jcm9zc0xpbmt9fS4gUHJlbG9hZEpTIGxvYWRlcnMgd2lsbCB0eXBpY2FsbHkgdXNlIGEgZGF0YSBsb2FkZXIgdW5kZXIgdGhlXG5cdCAqIGhvb2QgdG8gZ2V0IGRhdGEuXG5cdCAqIEBjbGFzcyBBYnN0cmFjdFJlcXVlc3Rcblx0ICogQHBhcmFtIHtMb2FkSXRlbX0gaXRlbVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdHZhciBBYnN0cmFjdFJlcXVlc3QgPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHRoaXMuX2l0ZW0gPSBpdGVtO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEFic3RyYWN0UmVxdWVzdCwgY3JlYXRlanMuRXZlbnREaXNwYXRjaGVyKTtcblxuXHQvLyBwdWJsaWMgbWV0aG9kc1xuXHQvKipcblx0ICogQmVnaW4gYSBsb2FkLlxuXHQgKiBAbWV0aG9kIGxvYWRcblx0ICovXG5cdHAubG9hZCA9ICBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cCBhIHJlcXVlc3QuXG5cdCAqIEBtZXRob2QgZGVzdHJveVxuXHQgKi9cblx0cC5kZXN0cm95ID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKipcblx0ICogQ2FuY2VsIGFuIGluLXByb2dyZXNzIHJlcXVlc3QuXG5cdCAqIEBtZXRob2QgY2FuY2VsXG5cdCAqL1xuXHRwLmNhbmNlbCA9IGZ1bmN0aW9uKCkge307XG5cblx0Y3JlYXRlanMuQWJzdHJhY3RSZXF1ZXN0ID0gY3JlYXRlanMucHJvbW90ZShBYnN0cmFjdFJlcXVlc3QsIFwiRXZlbnREaXNwYXRjaGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVGFnUmVxdWVzdC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBbiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFJlcXVlc3RcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBsb2FkcyBIVE1MIHRhZ3MsIHN1Y2ggYXMgaW1hZ2VzIGFuZCBzY3JpcHRzLlxuXHQgKiBAY2xhc3MgVGFnUmVxdWVzdFxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YWdcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyY0F0dHJpYnV0ZSBUaGUgdGFnIGF0dHJpYnV0ZSB0aGF0IHNwZWNpZmllcyB0aGUgc291cmNlLCBzdWNoIGFzIFwic3JjXCIsIFwiaHJlZlwiLCBldGMuXG5cdCAqL1xuXHRmdW5jdGlvbiBUYWdSZXF1ZXN0KGxvYWRJdGVtLCB0YWcsIHNyY0F0dHJpYnV0ZSkge1xuXHRcdHRoaXMuQWJzdHJhY3RSZXF1ZXN0X2NvbnN0cnVjdG9yKGxvYWRJdGVtKTtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogVGhlIEhUTUwgdGFnIGluc3RhbmNlIHRoYXQgaXMgdXNlZCB0byBsb2FkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfdGFnXG5cdFx0ICogQHR5cGUge0hUTUxFbGVtZW50fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl90YWcgPSB0YWc7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdGFnIGF0dHJpYnV0ZSB0aGF0IHNwZWNpZmllcyB0aGUgc291cmNlLCBzdWNoIGFzIFwic3JjXCIsIFwiaHJlZlwiLCBldGMuXG5cdFx0ICogQHByb3BlcnR5IF90YWdTcmNBdHRyaWJ1dGVcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBzcmNBdHRyaWJ1dGU7XG5cblx0XHQvKipcblx0XHQgKiBBIG1ldGhvZCBjbG9zdXJlIHVzZWQgZm9yIGhhbmRsaW5nIHRoZSB0YWcgbG9hZCBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRlZEhhbmRsZXJcblx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkZWRIYW5kbGVyID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlVGFnQ29tcGxldGUsIHRoaXMpO1xuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgZWxlbWVudCB3YXMgYWRkZWQgdG8gdGhlIERPTSBhdXRvbWF0aWNhbGx5IGJ5IFByZWxvYWRKUywgc28gaXQgY2FuIGJlIGNsZWFuZWQgdXAgYWZ0ZXIuXG5cdFx0ICogQHByb3BlcnR5IF9hZGRlZFRvRE9NXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9hZGRlZFRvRE9NID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBEZXRlcm1pbmVzIHdoYXQgdGhlIHRhZ3MgaW5pdGlhbCBzdHlsZS52aXNpYmlsaXR5IHdhcywgc28gd2UgY2FuIHNldCBpdCBjb3JyZWN0bHkgYWZ0ZXIgYSBsb2FkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bGx9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9zdGFydFRhZ1Zpc2liaWxpdHkgPSBudWxsO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFRhZ1JlcXVlc3QsIGNyZWF0ZWpzLkFic3RyYWN0UmVxdWVzdCk7XG5cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3RhZy5vbmxvYWQgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUYWdDb21wbGV0ZSwgdGhpcyk7XG5cdFx0dGhpcy5fdGFnLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2UsIHRoaXMpO1xuXHRcdHRoaXMuX3RhZy5vbmVycm9yID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlRXJyb3IsIHRoaXMpO1xuXG5cdFx0dmFyIGV2dCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImluaXRpYWxpemVcIik7XG5cdFx0ZXZ0LmxvYWRlciA9IHRoaXMuX3RhZztcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuXG5cdFx0dGhpcy5faGlkZVRhZygpO1xuXG5cdFx0dGhpcy5fbG9hZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRpbWVvdXQsIHRoaXMpLCB0aGlzLl9pdGVtLmxvYWRUaW1lb3V0KTtcblxuXHRcdHRoaXMuX3RhZ1t0aGlzLl90YWdTcmNBdHRyaWJ1dGVdID0gdGhpcy5faXRlbS5zcmM7XG5cblx0XHQvLyB3ZGc6OiBBcHBlbmQgdGhlIHRhZyBBRlRFUiBzZXR0aW5nIHRoZSBzcmMsIG9yIFNWRyBsb2FkaW5nIG9uIGlPUyB3aWxsIGZhaWwuXG5cdFx0aWYgKHRoaXMuX3RhZy5wYXJlbnROb2RlID09IG51bGwpIHtcblx0XHRcdHdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX3RhZyk7XG5cdFx0XHR0aGlzLl9hZGRlZFRvRE9NID0gdHJ1ZTtcblx0XHR9XG5cdH07XG5cblx0cC5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fY2xlYW4oKTtcblx0XHR0aGlzLl90YWcgPSBudWxsO1xuXG5cdFx0dGhpcy5BYnN0cmFjdFJlcXVlc3RfZGVzdHJveSgpO1xuXHR9O1xuXG5cdC8vIHByaXZhdGUgbWV0aG9kc1xuXHQvKipcblx0ICogSGFuZGxlIHRoZSByZWFkeVN0YXRlQ2hhbmdlIGV2ZW50IGZyb20gYSB0YWcuIFdlIG5lZWQgdGhpcyBpbiBwbGFjZSBvZiB0aGUgYG9ubG9hZGAgY2FsbGJhY2sgKG1haW5seSBTQ1JJUFRcblx0ICogYW5kIExJTksgdGFncyksIGJ1dCBvdGhlciBjYXNlcyBtYXkgZXhpc3QuXG5cdCAqIEBtZXRob2QgX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2Vcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2xvYWRUaW1lb3V0KTtcblx0XHQvLyBUaGlzIGlzIHN0cmljdGx5IGZvciB0YWdzIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgb25sb2FkLlxuXHRcdHZhciB0YWcgPSB0aGlzLl90YWc7XG5cblx0XHQvLyBDb21wbGV0ZSBpcyBmb3Igb2xkIElFIHN1cHBvcnQuXG5cdFx0aWYgKHRhZy5yZWFkeVN0YXRlID09IFwibG9hZGVkXCIgfHwgdGFnLnJlYWR5U3RhdGUgPT0gXCJjb21wbGV0ZVwiKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVUYWdDb21wbGV0ZSgpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlIGFueSBlcnJvciBldmVudHMgZnJvbSB0aGUgdGFnLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVFcnJvclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9oYW5kbGVFcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2NsZWFuKCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiZXJyb3JcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZSB0aGUgdGFnJ3Mgb25sb2FkIGNhbGxiYWNrLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVUYWdDb21wbGV0ZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlVGFnQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmF3UmVzdWx0ID0gdGhpcy5fdGFnO1xuXHRcdHRoaXMuX3Jlc3VsdCA9IHRoaXMucmVzdWx0Rm9ybWF0dGVyICYmIHRoaXMucmVzdWx0Rm9ybWF0dGVyKHRoaXMpIHx8IHRoaXMuX3Jhd1Jlc3VsdDtcblxuXHRcdHRoaXMuX2NsZWFuKCk7XG5cdFx0dGhpcy5fc2hvd1RhZygpO1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiY29tcGxldGVcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSB0YWcgcmVxdWVzdCBoYXMgbm90IGxvYWRlZCB3aXRoaW4gdGhlIHRpbWUgc3BlY2lmaWVkIGluIGxvYWRUaW1lb3V0LlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVFcnJvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiBlcnJvciBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY2xlYW4oKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3IGNyZWF0ZWpzLkV2ZW50KFwidGltZW91dFwiKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMsIGJ1dCBkb24ndCBkZXN0cm95IHRoZSByZXF1ZXN0IG9iamVjdFxuXHQgKiBAbWV0aG9kIF9jbGVhblxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY2xlYW4gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl90YWcub25sb2FkID0gbnVsbDtcblx0XHR0aGlzLl90YWcub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblx0XHR0aGlzLl90YWcub25lcnJvciA9IG51bGw7XG5cdFx0aWYgKHRoaXMuX2FkZGVkVG9ET00gJiYgdGhpcy5fdGFnLnBhcmVudE5vZGUgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fdGFnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fdGFnKTtcblx0XHR9XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2xvYWRUaW1lb3V0KTtcblx0fTtcblxuXHRwLl9oaWRlVGFnID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc3RhcnRUYWdWaXNpYmlsaXR5ID0gdGhpcy5fdGFnLnN0eWxlLnZpc2liaWxpdHk7XG5cdFx0dGhpcy5fdGFnLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuXHR9O1xuXG5cdHAuX3Nob3dUYWcgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl90YWcuc3R5bGUudmlzaWJpbGl0eSA9IHRoaXMuX3N0YXJ0VGFnVmlzaWJpbGl0eTtcblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlIGEgc3RhbGxlZCBhdWRpbyBldmVudC4gVGhlIG1haW4gcGxhY2UgdGhpcyBoYXBwZW5zIGlzIHdpdGggSFRNTEF1ZGlvIGluIENocm9tZSB3aGVuIHBsYXlpbmcgYmFjayBhdWRpb1xuXHQgKiB0aGF0IGlzIGFscmVhZHkgaW4gYSBsb2FkLCBidXQgbm90IGNvbXBsZXRlLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVTdGFsbGVkXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVTdGFsbGVkID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vSWdub3JlLCBsZXQgdGhlIHRpbWVvdXQgdGFrZSBjYXJlIG9mIGl0LiBTb21ldGltZXMgaXRzIG5vdCByZWFsbHkgc3RvcHBlZC5cblx0fTtcblxuXHRjcmVhdGVqcy5UYWdSZXF1ZXN0ID0gY3JlYXRlanMucHJvbW90ZShUYWdSZXF1ZXN0LCBcIkFic3RyYWN0UmVxdWVzdFwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIE1lZGlhVGFnUmVxdWVzdC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBbiB7eyNjcm9zc0xpbmsgXCJUYWdSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgbG9hZHMgSFRNTCB0YWdzIGZvciB2aWRlbyBhbmQgYXVkaW8uXG5cdCAqIEBjbGFzcyBNZWRpYVRhZ1JlcXVlc3Rcblx0ICogQHBhcmFtIHtMb2FkSXRlbX0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtIVE1MQXVkaW9FbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IHRhZ1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjQXR0cmlidXRlIFRoZSB0YWcgYXR0cmlidXRlIHRoYXQgc3BlY2lmaWVzIHRoZSBzb3VyY2UsIHN1Y2ggYXMgXCJzcmNcIiwgXCJocmVmXCIsIGV0Yy5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBNZWRpYVRhZ1JlcXVlc3QobG9hZEl0ZW0sIHRhZywgc3JjQXR0cmlidXRlKSB7XG5cdFx0dGhpcy5BYnN0cmFjdFJlcXVlc3RfY29uc3RydWN0b3IobG9hZEl0ZW0pO1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHR0aGlzLl90YWcgPSB0YWc7XG5cdFx0dGhpcy5fdGFnU3JjQXR0cmlidXRlID0gc3JjQXR0cmlidXRlO1xuXHRcdHRoaXMuX2xvYWRlZEhhbmRsZXIgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUYWdDb21wbGV0ZSwgdGhpcyk7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoTWVkaWFUYWdSZXF1ZXN0LCBjcmVhdGVqcy5UYWdSZXF1ZXN0KTtcblx0dmFyIHMgPSBNZWRpYVRhZ1JlcXVlc3Q7XG5cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzYyA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVN0YWxsZWQsIHRoaXMpO1xuXHRcdHRoaXMuX3N0YWxsZWRDYWxsYmFjayA9IHNjO1xuXG5cdFx0dmFyIHBjID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlUHJvZ3Jlc3MsIHRoaXMpO1xuXHRcdHRoaXMuX2hhbmRsZVByb2dyZXNzID0gcGM7XG5cblx0XHR0aGlzLl90YWcuYWRkRXZlbnRMaXN0ZW5lcihcInN0YWxsZWRcIiwgc2MpO1xuXHRcdHRoaXMuX3RhZy5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgcGMpO1xuXG5cdFx0Ly8gVGhpcyB3aWxsIHRlbGwgdXMgd2hlbiBhdWRpbyBpcyBidWZmZXJlZCBlbm91Z2ggdG8gcGxheSB0aHJvdWdoLCBidXQgbm90IHdoZW4gaXRzIGxvYWRlZC5cblx0XHQvLyBUaGUgdGFnIGRvZXNuJ3Qga2VlcCBsb2FkaW5nIGluIENocm9tZSBvbmNlIGVub3VnaCBoYXMgYnVmZmVyZWQsIGFuZCB3ZSBoYXZlIGRlY2lkZWQgdGhhdCBiZWhhdmlvdXIgaXMgc3VmZmljaWVudC5cblx0XHR0aGlzLl90YWcuYWRkRXZlbnRMaXN0ZW5lciAmJiB0aGlzLl90YWcuYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsIHRoaXMuX2xvYWRlZEhhbmRsZXIsIGZhbHNlKTsgLy8gY2FucGxheXRocm91Z2ggY2FsbGJhY2sgZG9lc24ndCB3b3JrIGluIENocm9tZSwgc28gd2UgdXNlIGFuIGV2ZW50LlxuXG5cdFx0dGhpcy5UYWdSZXF1ZXN0X2xvYWQoKTtcblx0fTtcblxuXHQvLyBwcml2YXRlIG1ldGhvZHNcblx0cC5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fbG9hZFRpbWVvdXQpO1xuXHRcdC8vIFRoaXMgaXMgc3RyaWN0bHkgZm9yIHRhZ3MgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBvbmxvYWQuXG5cdFx0dmFyIHRhZyA9IHRoaXMuX3RhZztcblxuXHRcdC8vIENvbXBsZXRlIGlzIGZvciBvbGQgSUUgc3VwcG9ydC5cblx0XHRpZiAodGFnLnJlYWR5U3RhdGUgPT0gXCJsb2FkZWRcIiB8fCB0YWcucmVhZHlTdGF0ZSA9PSBcImNvbXBsZXRlXCIpIHtcblx0XHRcdHRoaXMuX2hhbmRsZVRhZ0NvbXBsZXRlKCk7XG5cdFx0fVxuXHR9O1xuXG5cdHAuX2hhbmRsZVN0YWxsZWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly9JZ25vcmUsIGxldCB0aGUgdGltZW91dCB0YWtlIGNhcmUgb2YgaXQuIFNvbWV0aW1lcyBpdHMgbm90IHJlYWxseSBzdG9wcGVkLlxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbiBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgcHJvZ3Jlc3MuXG5cdCAqIEBtZXRob2QgX2hhbmRsZVByb2dyZXNzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIHByb2dyZXNzIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRpZiAoIWV2ZW50IHx8IGV2ZW50LmxvYWRlZCA+IDAgJiYgZXZlbnQudG90YWwgPT0gMCkge1xuXHRcdFx0cmV0dXJuOyAvLyBTb21ldGltZXMgd2UgZ2V0IG5vIFwidG90YWxcIiwgc28ganVzdCBpZ25vcmUgdGhlIHByb2dyZXNzIGV2ZW50LlxuXHRcdH1cblxuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5Qcm9ncmVzc0V2ZW50KGV2ZW50LmxvYWRlZCwgZXZlbnQudG90YWwpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0cC5fY2xlYW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIgJiYgdGhpcy5fdGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5dGhyb3VnaFwiLCB0aGlzLl9sb2FkZWRIYW5kbGVyKTtcblx0XHR0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN0YWxsZWRcIiwgdGhpcy5fc3RhbGxlZENhbGxiYWNrKTtcblx0XHR0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIHRoaXMuX3Byb2dyZXNzQ2FsbGJhY2spO1xuXG5cdFx0dGhpcy5UYWdSZXF1ZXN0X19jbGVhbigpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLk1lZGlhVGFnUmVxdWVzdCA9IGNyZWF0ZWpzLnByb21vdGUoTWVkaWFUYWdSZXF1ZXN0LCBcIlRhZ1JlcXVlc3RcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBYSFJSZXF1ZXN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIHByZWxvYWRlciB0aGF0IGxvYWRzIGl0ZW1zIHVzaW5nIFhIUiByZXF1ZXN0cywgdXN1YWxseSBYTUxIdHRwUmVxdWVzdC4gSG93ZXZlciBYRG9tYWluUmVxdWVzdHMgd2lsbCBiZSB1c2VkXG5cdCAqIGZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMgaWYgcG9zc2libGUsIGFuZCBvbGRlciB2ZXJzaW9ucyBvZiBJRSBmYWxsIGJhY2sgb24gdG8gQWN0aXZlWCBvYmplY3RzIHdoZW4gbmVjZXNzYXJ5LlxuXHQgKiBYSFIgcmVxdWVzdHMgbG9hZCB0aGUgY29udGVudCBhcyB0ZXh0IG9yIGJpbmFyeSBkYXRhLCBwcm92aWRlIHByb2dyZXNzIGFuZCBjb25zaXN0ZW50IGNvbXBsZXRpb24gZXZlbnRzLCBhbmRcblx0ICogY2FuIGJlIGNhbmNlbGVkIGR1cmluZyBsb2FkLiBOb3RlIHRoYXQgWEhSIGlzIG5vdCBzdXBwb3J0ZWQgaW4gSUUgNiBvciBlYXJsaWVyLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvclxuXHQgKiBjcm9zcy1kb21haW4gbG9hZGluZy5cblx0ICogQGNsYXNzIFhIUlJlcXVlc3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSBvYmplY3QgdGhhdCBkZWZpbmVzIHRoZSBmaWxlIHRvIGxvYWQuIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgYW4gb3ZlcnZpZXcgb2Ygc3VwcG9ydGVkIGZpbGUgcHJvcGVydGllcy5cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICovXG5cdGZ1bmN0aW9uIFhIUlJlcXVlc3QgKGl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0UmVxdWVzdF9jb25zdHJ1Y3RvcihpdGVtKTtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogQSByZWZlcmVuY2UgdG8gdGhlIFhIUiByZXF1ZXN0IHVzZWQgdG8gbG9hZCB0aGUgY29udGVudC5cblx0XHQgKiBAcHJvcGVydHkgX3JlcXVlc3Rcblx0XHQgKiBAdHlwZSB7WE1MSHR0cFJlcXVlc3QgfCBYRG9tYWluUmVxdWVzdCB8IEFjdGl2ZVguWE1MSFRUUH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBtYW51YWwgbG9hZCB0aW1lb3V0IHRoYXQgaXMgdXNlZCBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCB0aGUgb25UaW1lb3V0IGV2ZW50IG9uIFhIUiAoWEhSIGxldmVsIDEsXG5cdFx0ICogdHlwaWNhbGx5IElFOSkuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkVGltZW91dFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkVGltZW91dCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYnJvd3NlcidzIFhIUiAoWE1MSFRUUFJlcXVlc3QpIHZlcnNpb24uIFN1cHBvcnRlZCB2ZXJzaW9ucyBhcmUgMSBhbmQgMi4gVGhlcmUgaXMgbm8gb2ZmaWNpYWwgd2F5IHRvIGRldGVjdFxuXHRcdCAqIHRoZSB2ZXJzaW9uLCBzbyB3ZSB1c2UgY2FwYWJpbGl0aWVzIHRvIG1ha2UgYSBiZXN0IGd1ZXNzLlxuXHRcdCAqIEBwcm9wZXJ0eSBfeGhyTGV2ZWxcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3hockxldmVsID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByZXNwb25zZSBvZiBhIGxvYWRlZCBmaWxlLiBUaGlzIGlzIHNldCBiZWNhdXNlIGl0IGlzIGV4cGVuc2l2ZSB0byBsb29rIHVwIGNvbnN0YW50bHkuIFRoaXMgcHJvcGVydHkgd2lsbCBiZVxuXHRcdCAqIG51bGwgdW50aWwgdGhlIGZpbGUgaXMgbG9hZGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmVzcG9uc2Vcblx0XHQgKiBAdHlwZSB7bWl4ZWR9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9yZXNwb25zZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcmVzcG9uc2Ugb2YgdGhlIGxvYWRlZCBmaWxlIGJlZm9yZSBpdCBpcyBtb2RpZmllZC4gSW4gbW9zdCBjYXNlcywgY29udGVudCBpcyBjb252ZXJ0ZWQgZnJvbSByYXcgdGV4dCB0b1xuXHRcdCAqIGFuIEhUTUwgdGFnIG9yIGEgZm9ybWF0dGVkIG9iamVjdCB3aGljaCBpcyBzZXQgdG8gdGhlIDxjb2RlPnJlc3VsdDwvY29kZT4gcHJvcGVydHksIGJ1dCB0aGUgZGV2ZWxvcGVyIG1heSBzdGlsbFxuXHRcdCAqIHdhbnQgdG8gYWNjZXNzIHRoZSByYXcgY29udGVudCBhcyBpdCB3YXMgbG9hZGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmF3UmVzcG9uc2Vcblx0XHQgKiBAdHlwZSB7U3RyaW5nfE9iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3Jhd1Jlc3BvbnNlID0gbnVsbDtcblxuXHRcdHRoaXMuX2NhbmNlbGVkID0gZmFsc2U7XG5cblx0XHQvLyBTZXR1cCBvdXIgZXZlbnQgaGFuZGxlcnMgbm93LlxuXHRcdHRoaXMuX2hhbmRsZUxvYWRTdGFydFByb3h5ID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlTG9hZFN0YXJ0LCB0aGlzKTtcblx0XHR0aGlzLl9oYW5kbGVQcm9ncmVzc1Byb3h5ID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlUHJvZ3Jlc3MsIHRoaXMpO1xuXHRcdHRoaXMuX2hhbmRsZUFib3J0UHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVBYm9ydCwgdGhpcyk7XG5cdFx0dGhpcy5faGFuZGxlRXJyb3JQcm94eSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUVycm9yLCB0aGlzKTtcblx0XHR0aGlzLl9oYW5kbGVUaW1lb3V0UHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUaW1lb3V0LCB0aGlzKTtcblx0XHR0aGlzLl9oYW5kbGVMb2FkUHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVMb2FkLCB0aGlzKTtcblx0XHR0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlUHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlLCB0aGlzKTtcblxuXHRcdGlmICghdGhpcy5fY3JlYXRlWEhSKGl0ZW0pKSB7XG5cdFx0XHQvL1RPRE86IFRocm93IGVycm9yP1xuXHRcdH1cblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChYSFJSZXF1ZXN0LCBjcmVhdGVqcy5BYnN0cmFjdFJlcXVlc3QpO1xuXG4vLyBzdGF0aWMgcHJvcGVydGllc1xuXHQvKipcblx0ICogQSBsaXN0IG9mIFhNTEhUVFAgb2JqZWN0IElEcyB0byB0cnkgd2hlbiBidWlsZGluZyBhbiBBY3RpdmVYIG9iamVjdCBmb3IgWEhSIHJlcXVlc3RzIGluIGVhcmxpZXIgdmVyc2lvbnMgb2YgSUUuXG5cdCAqIEBwcm9wZXJ0eSBBQ1RJVkVYX1ZFUlNJT05TXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHNpbmNlIDAuNC4yXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRYSFJSZXF1ZXN0LkFDVElWRVhfVkVSU0lPTlMgPSBbXG5cdFx0XCJNc3htbDIuWE1MSFRUUC42LjBcIixcblx0XHRcIk1zeG1sMi5YTUxIVFRQLjUuMFwiLFxuXHRcdFwiTXN4bWwyLlhNTEhUVFAuNC4wXCIsXG5cdFx0XCJNU1hNTDIuWE1MSFRUUC4zLjBcIixcblx0XHRcIk1TWE1MMi5YTUxIVFRQXCIsXG5cdFx0XCJNaWNyb3NvZnQuWE1MSFRUUFwiXG5cdF07XG5cbi8vIFB1YmxpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBMb29rIHVwIHRoZSBsb2FkZWQgcmVzdWx0LlxuXHQgKiBAbWV0aG9kIGdldFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyYXc9ZmFsc2VdIFJldHVybiBhIHJhdyByZXN1bHQgaW5zdGVhZCBvZiBhIGZvcm1hdHRlZCByZXN1bHQuIFRoaXMgYXBwbGllcyB0byBjb250ZW50XG5cdCAqIGxvYWRlZCB2aWEgWEhSIHN1Y2ggYXMgc2NyaXB0cywgWE1MLCBDU1MsIGFuZCBJbWFnZXMuIElmIHRoZXJlIGlzIG5vIHJhdyByZXN1bHQsIHRoZSBmb3JtYXR0ZWQgcmVzdWx0IHdpbGwgYmVcblx0ICogcmV0dXJuZWQgaW5zdGVhZC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBIHJlc3VsdCBvYmplY3QgY29udGFpbmluZyB0aGUgY29udGVudCB0aGF0IHdhcyBsb2FkZWQsIHN1Y2ggYXM6XG5cdCAqIDx1bD5cblx0ICogICAgICA8bGk+QW4gaW1hZ2UgdGFnICgmbHQ7aW1hZ2UgLyZndDspIGZvciBpbWFnZXM8L2xpPlxuXHQgKiAgICAgIDxsaT5BIHNjcmlwdCB0YWcgZm9yIEphdmFTY3JpcHQgKCZsdDtzY3JpcHQgLyZndDspLiBOb3RlIHRoYXQgc2NyaXB0cyBsb2FkZWQgd2l0aCB0YWdzIG1heSBiZSBhZGRlZCB0byB0aGVcblx0ICogICAgICBIVE1MIGhlYWQuPC9saT5cblx0ICogICAgICA8bGk+QSBzdHlsZSB0YWcgZm9yIENTUyAoJmx0O3N0eWxlIC8mZ3Q7KTwvbGk+XG5cdCAqICAgICAgPGxpPlJhdyB0ZXh0IGZvciBURVhUPC9saT5cblx0ICogICAgICA8bGk+QSBmb3JtYXR0ZWQgSmF2YVNjcmlwdCBvYmplY3QgZGVmaW5lZCBieSBKU09OPC9saT5cblx0ICogICAgICA8bGk+QW4gWE1MIGRvY3VtZW50PC9saT5cblx0ICogICAgICA8bGk+QW4gYmluYXJ5IGFycmF5YnVmZmVyIGxvYWRlZCBieSBYSFI8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBOb3RlIHRoYXQgaWYgYSByYXcgcmVzdWx0IGlzIHJlcXVlc3RlZCwgYnV0IG5vdCBmb3VuZCwgdGhlIHJlc3VsdCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQuXG5cdCAqL1xuXHRwLmdldFJlc3VsdCA9IGZ1bmN0aW9uIChyYXcpIHtcblx0XHRpZiAocmF3ICYmIHRoaXMuX3Jhd1Jlc3BvbnNlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmF3UmVzcG9uc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9yZXNwb25zZTtcblx0fTtcblxuXHQvLyBPdmVycmlkZXMgYWJzdHJhY3QgbWV0aG9kIGluIEFic3RyYWN0UmVxdWVzdFxuXHRwLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmNhbmNlbGVkID0gdHJ1ZTtcblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuX3JlcXVlc3QuYWJvcnQoKTtcblx0fTtcblxuXHQvLyBPdmVycmlkZXMgYWJzdHJhY3QgbWV0aG9kIGluIEFic3RyYWN0TG9hZGVyXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVxdWVzdCA9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVFcnJvcigpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vRXZlbnRzXG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2Fkc3RhcnRcIiwgdGhpcy5faGFuZGxlTG9hZFN0YXJ0UHJveHksIGZhbHNlKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIHRoaXMuX2hhbmRsZVByb2dyZXNzUHJveHksIGZhbHNlKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHRoaXMuX2hhbmRsZUFib3J0UHJveHksIGZhbHNlKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMuX2hhbmRsZUVycm9yUHJveHksIGZhbHNlKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcInRpbWVvdXRcIiwgdGhpcy5faGFuZGxlVGltZW91dFByb3h5LCBmYWxzZSk7XG5cblx0XHRcdC8vIE5vdGU6IFdlIGRvbid0IGdldCBvbmxvYWQgaW4gYWxsIGJyb3dzZXJzIChlYXJsaWVyIEZGIGFuZCBJRSkuIG9uUmVhZHlTdGF0ZUNoYW5nZSBoYW5kbGVzIHRoZXNlLlxuXHRcdFx0dGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCB0aGlzLl9oYW5kbGVMb2FkUHJveHksIGZhbHNlKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIiwgdGhpcy5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZVByb3h5LCBmYWxzZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIElFOSBzdXBwb3J0XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9ubG9hZHN0YXJ0ID0gdGhpcy5faGFuZGxlTG9hZFN0YXJ0UHJveHk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSB0aGlzLl9oYW5kbGVQcm9ncmVzc1Byb3h5O1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbmFib3J0ID0gdGhpcy5faGFuZGxlQWJvcnRQcm94eTtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25lcnJvciA9IHRoaXMuX2hhbmRsZUVycm9yUHJveHk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9udGltZW91dCA9IHRoaXMuX2hhbmRsZVRpbWVvdXRQcm94eTtcblxuXHRcdFx0Ly8gTm90ZTogV2UgZG9uJ3QgZ2V0IG9ubG9hZCBpbiBhbGwgYnJvd3NlcnMgKGVhcmxpZXIgRkYgYW5kIElFKS4gb25SZWFkeVN0YXRlQ2hhbmdlIGhhbmRsZXMgdGhlc2UuXG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9ubG9hZCA9IHRoaXMuX2hhbmRsZUxvYWRQcm94eTtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZVByb3h5O1xuXHRcdH1cblxuXHRcdC8vIFNldCB1cCBhIHRpbWVvdXQgaWYgd2UgZG9uJ3QgaGF2ZSBYSFIyXG5cdFx0aWYgKHRoaXMuX3hockxldmVsID09IDEpIHtcblx0XHRcdHRoaXMuX2xvYWRUaW1lb3V0ID0gc2V0VGltZW91dChjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUaW1lb3V0LCB0aGlzKSwgdGhpcy5faXRlbS5sb2FkVGltZW91dCk7XG5cdFx0fVxuXG5cdFx0Ly8gU29tZXRpbWVzIHdlIGdldCBiYWNrIDQwNHMgaW1tZWRpYXRlbHksIHBhcnRpY3VsYXJseSB3aGVuIHRoZXJlIGlzIGEgY3Jvc3Mgb3JpZ2luIHJlcXVlc3QuICAvLyBub3RlIHRoaXMgZG9lcyBub3QgY2F0Y2ggaW4gQ2hyb21lXG5cdFx0dHJ5IHtcblx0XHRcdGlmICghdGhpcy5faXRlbS52YWx1ZXMgfHwgdGhpcy5faXRlbS5tZXRob2QgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuR0VUKSB7XG5cdFx0XHRcdHRoaXMuX3JlcXVlc3Quc2VuZCgpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9pdGVtLm1ldGhvZCA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5QT1NUKSB7XG5cdFx0XHRcdHRoaXMuX3JlcXVlc3Quc2VuZChjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuZm9ybWF0UXVlcnlTdHJpbmcodGhpcy5faXRlbS52YWx1ZXMpKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiWEhSX1NFTkRcIiwgbnVsbCwgZXJyb3IpKTtcblx0XHR9XG5cdH07XG5cblx0cC5zZXRSZXNwb25zZVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuXHRcdC8vIFNvbWUgb2xkIGJyb3dzZXJzIGRvZXNuJ3Qgc3VwcG9ydCBibG9iLCBzbyB3ZSBjb252ZXJ0IGFycmF5YnVmZmVyIHRvIGJsb2IgYWZ0ZXIgcmVzcG9uc2UgaXMgZG93bmxvYWRlZFxuXHRcdGlmICh0eXBlID09PSAnYmxvYicpIHtcblx0XHRcdHR5cGUgPSB3aW5kb3cuVVJMID8gJ2Jsb2InIDogJ2FycmF5YnVmZmVyJztcblx0XHRcdHRoaXMuX3Jlc3BvbnNlVHlwZSA9IHR5cGU7XG5cdFx0fVxuXHRcdHRoaXMuX3JlcXVlc3QucmVzcG9uc2VUeXBlID0gdHlwZTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IGFsbCB0aGUgcmVzcG9uc2UgaGVhZGVycyBmcm9tIHRoZSBYbWxIdHRwUmVxdWVzdC5cblx0ICpcblx0ICogPHN0cm9uZz5Gcm9tIHRoZSBkb2NzOjwvc3Ryb25nPiBSZXR1cm4gYWxsIHRoZSBIVFRQIGhlYWRlcnMsIGV4Y2x1ZGluZyBoZWFkZXJzIHRoYXQgYXJlIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaFxuXHQgKiBmb3IgU2V0LUNvb2tpZSBvciBTZXQtQ29va2llMiwgYXMgYSBzaW5nbGUgc3RyaW5nLCB3aXRoIGVhY2ggaGVhZGVyIGxpbmUgc2VwYXJhdGVkIGJ5IGEgVSswMDBEIENSIFUrMDAwQSBMRiBwYWlyLFxuXHQgKiBleGNsdWRpbmcgdGhlIHN0YXR1cyBsaW5lLCBhbmQgd2l0aCBlYWNoIGhlYWRlciBuYW1lIGFuZCBoZWFkZXIgdmFsdWUgc2VwYXJhdGVkIGJ5IGEgVSswMDNBIENPTE9OIFUrMDAyMCBTUEFDRVxuXHQgKiBwYWlyLlxuXHQgKiBAbWV0aG9kIGdldEFsbFJlc3BvbnNlSGVhZGVyc1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblx0cC5nZXRBbGxSZXNwb25zZUhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCBhIHNwZWNpZmljIHJlc3BvbnNlIGhlYWRlciBmcm9tIHRoZSBYbWxIdHRwUmVxdWVzdC5cblx0ICpcblx0ICogPHN0cm9uZz5Gcm9tIHRoZSBkb2NzOjwvc3Ryb25nPiBSZXR1cm5zIHRoZSBoZWFkZXIgZmllbGQgdmFsdWUgZnJvbSB0aGUgcmVzcG9uc2Ugb2Ygd2hpY2ggdGhlIGZpZWxkIG5hbWUgbWF0Y2hlc1xuXHQgKiBoZWFkZXIsIHVubGVzcyB0aGUgZmllbGQgbmFtZSBpcyBTZXQtQ29va2llIG9yIFNldC1Db29raWUyLlxuXHQgKiBAbWV0aG9kIGdldFJlc3BvbnNlSGVhZGVyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGhlYWRlciBuYW1lIHRvIHJldHJpZXZlLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblx0cC5nZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXIpIHtcblx0XHRpZiAodGhpcy5fcmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlciBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH07XG5cbi8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBUaGUgWEhSIHJlcXVlc3QgaGFzIHJlcG9ydGVkIHByb2dyZXNzLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVQcm9ncmVzc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiBwcm9ncmVzcyBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVByb2dyZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKCFldmVudCB8fCBldmVudC5sb2FkZWQgPiAwICYmIGV2ZW50LnRvdGFsID09IDApIHtcblx0XHRcdHJldHVybjsgLy8gU29tZXRpbWVzIHdlIGdldCBubyBcInRvdGFsXCIsIHNvIGp1c3QgaWdub3JlIHRoZSBwcm9ncmVzcyBldmVudC5cblx0XHR9XG5cblx0XHR2YXIgbmV3RXZlbnQgPSBuZXcgY3JlYXRlanMuUHJvZ3Jlc3NFdmVudChldmVudC5sb2FkZWQsIGV2ZW50LnRvdGFsKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgWEhSIHJlcXVlc3QgaGFzIHJlcG9ydGVkIGEgbG9hZCBzdGFydC5cblx0ICogQG1ldGhvZCBfaGFuZGxlTG9hZFN0YXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGxvYWRTdGFydCBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZUxvYWRTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9sb2FkVGltZW91dCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwibG9hZHN0YXJ0XCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgWEhSIHJlcXVlc3QgaGFzIHJlcG9ydGVkIGFuIGFib3J0IGV2ZW50LlxuXHQgKiBAbWV0aG9kIGhhbmRsZUFib3J0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGFib3J0IGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlQWJvcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlhIUl9BQk9SVEVEXCIsIG51bGwsIGV2ZW50KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgYW4gZXJyb3IgZXZlbnQuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUVycm9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGVycm9yIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChldmVudC5tZXNzYWdlKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgYSByZWFkeVN0YXRlIGNoYW5nZS4gTm90ZSB0aGF0IG9sZGVyIGJyb3dzZXJzIChJRSA3ICYgOCkgZG8gbm90IHByb3ZpZGUgYW4gb25sb2FkXG5cdCAqIGV2ZW50LCBzbyB3ZSBtdXN0IG1vbml0b3IgdGhlIHJlYWR5U3RhdGVDaGFuZ2UgdG8gZGV0ZXJtaW5lIGlmIHRoZSBmaWxlIGlzIGxvYWRlZC5cblx0ICogQG1ldGhvZCBfaGFuZGxlUmVhZHlTdGF0ZUNoYW5nZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiByZWFkeVN0YXRlQ2hhbmdlIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGlmICh0aGlzLl9yZXF1ZXN0LnJlYWR5U3RhdGUgPT0gNCkge1xuXHRcdFx0dGhpcy5faGFuZGxlTG9hZCgpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVGhlIFhIUiByZXF1ZXN0IGhhcyBjb21wbGV0ZWQuIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBYSFIgcmVxdWVzdCBkaXJlY3RseSwgb3IgYnkgYSByZWFkeVN0YXRlQ2hhbmdlIHRoYXQgaGFzXG5cdCAqIDxjb2RlPnJlcXVlc3QucmVhZHlTdGF0ZSA9PSA0PC9jb2RlPi4gT25seSB0aGUgZmlyc3QgY2FsbCB0byB0aGlzIG1ldGhvZCB3aWxsIGJlIHByb2Nlc3NlZC5cblx0ICogQG1ldGhvZCBfaGFuZGxlTG9hZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiBsb2FkIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGlmICh0aGlzLmxvYWRlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLmxvYWRlZCA9IHRydWU7XG5cblx0XHR2YXIgZXJyb3IgPSB0aGlzLl9jaGVja0Vycm9yKCk7XG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVFcnJvcihlcnJvcik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fcmVzcG9uc2UgPSB0aGlzLl9nZXRSZXNwb25zZSgpO1xuXHRcdC8vIENvbnZlcnQgYXJyYXlidWZmZXIgYmFjayB0byBibG9iXG5cdFx0aWYgKHRoaXMuX3Jlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhpcy5fcmVzcG9uc2UgPSBuZXcgQmxvYihbdGhpcy5fcmVzcG9uc2VdKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gdXNlIEJsb2JCdWlsZGVyIGlmIEJsb2IgY29uc3RydWN0b3IgaXMgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHQvLyBUZXN0ZWQgb24gQW5kcm9pZCAyLjMgfiA0LjIgYW5kIGlPUzUgc2FmYXJpXG5cdFx0XHRcdHdpbmRvdy5CbG9iQnVpbGRlciA9IHdpbmRvdy5CbG9iQnVpbGRlciB8fCB3aW5kb3cuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1vekJsb2JCdWlsZGVyIHx8IHdpbmRvdy5NU0Jsb2JCdWlsZGVyO1xuXHRcdFx0XHRpZiAoZS5uYW1lID09PSAnVHlwZUVycm9yJyAmJiB3aW5kb3cuQmxvYkJ1aWxkZXIpIHtcblx0XHRcdFx0XHR2YXIgYnVpbGRlciA9IG5ldyBCbG9iQnVpbGRlcigpO1xuXHRcdFx0XHRcdGJ1aWxkZXIuYXBwZW5kKHRoaXMuX3Jlc3BvbnNlKTtcblx0XHRcdFx0XHR0aGlzLl9yZXNwb25zZSA9IGJ1aWxkZXIuZ2V0QmxvYigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2NsZWFuKCk7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3IGNyZWF0ZWpzLkV2ZW50KFwiY29tcGxldGVcIikpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgWEhSIHJlcXVlc3QgaGFzIHRpbWVkIG91dC4gVGhpcyBpcyBjYWxsZWQgYnkgdGhlIFhIUiByZXF1ZXN0IGRpcmVjdGx5LCBvciB2aWEgYSA8Y29kZT5zZXRUaW1lb3V0PC9jb2RlPlxuXHQgKiBjYWxsYmFjay5cblx0ICogQG1ldGhvZCBfaGFuZGxlVGltZW91dFxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2V2ZW50XSBUaGUgWEhSIHRpbWVvdXQgZXZlbnQuIFRoaXMgaXMgb2NjYXNpb25hbGx5IG51bGwgd2hlbiBjYWxsZWQgYnkgdGhlIGJhY2t1cCBzZXRUaW1lb3V0LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlVGltZW91dCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuX2NsZWFuKCk7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJQUkVMT0FEX1RJTUVPVVRcIiwgbnVsbCwgZXZlbnQpKTtcblx0fTtcblxuLy8gUHJvdGVjdGVkXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgdGhlcmUgaXMgYW4gZXJyb3IgaW4gdGhlIGN1cnJlbnQgbG9hZC4gVGhpcyBjaGVja3MgdGhlIHN0YXR1cyBvZiB0aGUgcmVxdWVzdCBmb3IgcHJvYmxlbSBjb2Rlcy4gTm90ZVxuXHQgKiB0aGF0IHRoaXMgZG9lcyBub3QgY2hlY2sgZm9yIGFuIGFjdHVhbCByZXNwb25zZS4gQ3VycmVudGx5LCBpdCBvbmx5IGNoZWNrcyBmb3IgNDA0IG9yIDAgZXJyb3IgY29kZS5cblx0ICogQG1ldGhvZCBfY2hlY2tFcnJvclxuXHQgKiBAcmV0dXJuIHtpbnR9IElmIHRoZSByZXF1ZXN0IHN0YXR1cyByZXR1cm5zIGFuIGVycm9yIGNvZGUuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jaGVja0Vycm9yID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vTE06IFByb2JhYmx5IG5lZWQgYWRkaXRpb25hbCBoYW5kbGVycyBoZXJlLCBtYXliZSA1MDFcblx0XHR2YXIgc3RhdHVzID0gcGFyc2VJbnQodGhpcy5fcmVxdWVzdC5zdGF0dXMpO1xuXG5cdFx0c3dpdGNoIChzdGF0dXMpIHtcblx0XHRcdGNhc2UgNDA0OiAgIC8vIE5vdCBGb3VuZFxuXHRcdFx0Y2FzZSAwOiAgICAgLy8gTm90IExvYWRlZFxuXHRcdFx0XHRyZXR1cm4gbmV3IEVycm9yKHN0YXR1cyk7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBWYWxpZGF0ZSB0aGUgcmVzcG9uc2UuIERpZmZlcmVudCBicm93c2VycyBoYXZlIGRpZmZlcmVudCBhcHByb2FjaGVzLCBzb21lIG9mIHdoaWNoIHRocm93IGVycm9ycyB3aGVuIGFjY2Vzc2VkXG5cdCAqIGluIG90aGVyIGJyb3dzZXJzLiBJZiB0aGVyZSBpcyBubyByZXNwb25zZSwgdGhlIDxjb2RlPl9yZXNwb25zZTwvY29kZT4gcHJvcGVydHkgd2lsbCByZW1haW4gbnVsbC5cblx0ICogQG1ldGhvZCBfZ2V0UmVzcG9uc2Vcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2dldFJlc3BvbnNlID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZXNwb25zZSAhPSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QucmVzcG9uc2UgIT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JlcXVlc3QucmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQW5kcm9pZCAyLjIgdXNlcyAucmVzcG9uc2VUZXh0XG5cdFx0dHJ5IHtcblx0XHRcdGlmICh0aGlzLl9yZXF1ZXN0LnJlc3BvbnNlVGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXF1ZXN0LnJlc3BvbnNlVGV4dDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiBsb2FkaW5nIFhNTCwgSUU5IGRvZXMgbm90IHJldHVybiAucmVzcG9uc2UsIGluc3RlYWQgaXQgcmV0dXJucyByZXNwb25zZVhNTC54bWxcblx0XHR0cnkge1xuXHRcdFx0aWYgKHRoaXMuX3JlcXVlc3QucmVzcG9uc2VYTUwgIT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVxdWVzdC5yZXNwb25zZVhNTDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhbiBYSFIgcmVxdWVzdC4gRGVwZW5kaW5nIG9uIGEgbnVtYmVyIG9mIGZhY3RvcnMsIHdlIGdldCB0b3RhbGx5IGRpZmZlcmVudCByZXN1bHRzLlxuXHQgKiA8b2w+PGxpPlNvbWUgYnJvd3NlcnMgZ2V0IGFuIDxjb2RlPlhEb21haW5SZXF1ZXN0PC9jb2RlPiB3aGVuIGxvYWRpbmcgY3Jvc3MtZG9tYWluLjwvbGk+XG5cdCAqICAgICAgPGxpPlhNTEh0dHBSZXF1ZXN0IGFyZSBjcmVhdGVkIHdoZW4gYXZhaWxhYmxlLjwvbGk+XG5cdCAqICAgICAgPGxpPkFjdGl2ZVguWE1MSFRUUCBvYmplY3RzIGFyZSB1c2VkIGluIG9sZGVyIElFIGJyb3dzZXJzLjwvbGk+XG5cdCAqICAgICAgPGxpPlRleHQgcmVxdWVzdHMgb3ZlcnJpZGUgdGhlIG1pbWUgdHlwZSBpZiBwb3NzaWJsZTwvbGk+XG5cdCAqICAgICAgPGxpPk9yaWdpbiBoZWFkZXJzIGFyZSBzZW50IGZvciBjcm9zc2RvbWFpbiByZXF1ZXN0cyBpbiBzb21lIGJyb3dzZXJzLjwvbGk+XG5cdCAqICAgICAgPGxpPkJpbmFyeSBsb2FkcyBzZXQgdGhlIHJlc3BvbnNlIHR5cGUgdG8gXCJhcnJheWJ1ZmZlclwiPC9saT48L29sPlxuXHQgKiBAbWV0aG9kIF9jcmVhdGVYSFJcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIHJlcXVlc3RlZCBpdGVtIHRoYXQgaXMgYmVpbmcgbG9hZGVkLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiBhbiBYSFIgcmVxdWVzdCBvciBlcXVpdmFsZW50IHdhcyBzdWNjZXNzZnVsbHkgY3JlYXRlZC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NyZWF0ZVhIUiA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0Ly8gQ2hlY2sgZm9yIGNyb3NzLWRvbWFpbiBsb2Fkcy4gV2UgY2FuJ3QgZnVsbHkgc3VwcG9ydCB0aGVtLCBidXQgd2UgY2FuIHRyeS5cblx0XHR2YXIgY3Jvc3Nkb21haW4gPSBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNDcm9zc0RvbWFpbihpdGVtKTtcblx0XHR2YXIgaGVhZGVycyA9IHt9O1xuXG5cdFx0Ly8gQ3JlYXRlIHRoZSByZXF1ZXN0LiBGYWxsYmFjayB0byB3aGF0ZXZlciBzdXBwb3J0IHdlIGhhdmUuXG5cdFx0dmFyIHJlcSA9IG51bGw7XG5cdFx0aWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuXHRcdFx0cmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0XHQvLyBUaGlzIGlzIDggb3IgOSwgc28gdXNlIFhEb21haW5SZXF1ZXN0IGluc3RlYWQuXG5cdFx0XHRpZiAoY3Jvc3Nkb21haW4gJiYgcmVxLndpdGhDcmVkZW50aWFscyA9PT0gdW5kZWZpbmVkICYmIHdpbmRvdy5YRG9tYWluUmVxdWVzdCkge1xuXHRcdFx0XHRyZXEgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgeyAvLyBPbGQgSUUgdmVyc2lvbnMgdXNlIGEgZGlmZmVyZW50IGFwcHJvYWNoXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHMuQUNUSVZFWF9WRVJTSU9OUy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGF4VmVyc2lvbiA9IHMuQUNUSVZFWF9WRVJTSU9OU1tpXTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXEgPSBuZXcgQWN0aXZlWE9iamVjdChheFZlcnNpb24pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChyZXEgPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRGVmYXVsdCB0byB1dGYtOCBmb3IgVGV4dCByZXF1ZXN0cy5cblx0XHRpZiAoaXRlbS5taW1lVHlwZSA9PSBudWxsICYmIGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc1RleHQoaXRlbS50eXBlKSkge1xuXHRcdFx0aXRlbS5taW1lVHlwZSA9IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiO1xuXHRcdH1cblxuXHRcdC8vIElFOSBkb2Vzbid0IHN1cHBvcnQgb3ZlcnJpZGVNaW1lVHlwZSgpLCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGZvciBpdC5cblx0XHRpZiAoaXRlbS5taW1lVHlwZSAmJiByZXEub3ZlcnJpZGVNaW1lVHlwZSkge1xuXHRcdFx0cmVxLm92ZXJyaWRlTWltZVR5cGUoaXRlbS5taW1lVHlwZSk7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIHRoZSBYSFIgbGV2ZWxcblx0XHR0aGlzLl94aHJMZXZlbCA9ICh0eXBlb2YgcmVxLnJlc3BvbnNlVHlwZSA9PT0gXCJzdHJpbmdcIikgPyAyIDogMTtcblxuXHRcdHZhciBzcmMgPSBudWxsO1xuXHRcdGlmIChpdGVtLm1ldGhvZCA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5HRVQpIHtcblx0XHRcdHNyYyA9IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5idWlsZFBhdGgoaXRlbS5zcmMsIGl0ZW0udmFsdWVzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3JjID0gaXRlbS5zcmM7XG5cdFx0fVxuXG5cdFx0Ly8gT3BlbiB0aGUgcmVxdWVzdC4gIFNldCBjcm9zcy1kb21haW4gZmxhZ3MgaWYgaXQgaXMgc3VwcG9ydGVkIChYSFIgbGV2ZWwgMSBvbmx5KVxuXHRcdHJlcS5vcGVuKGl0ZW0ubWV0aG9kIHx8IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkdFVCwgc3JjLCB0cnVlKTtcblxuXHRcdGlmIChjcm9zc2RvbWFpbiAmJiByZXEgaW5zdGFuY2VvZiBYTUxIdHRwUmVxdWVzdCAmJiB0aGlzLl94aHJMZXZlbCA9PSAxKSB7XG5cdFx0XHRoZWFkZXJzW1wiT3JpZ2luXCJdID0gbG9jYXRpb24ub3JpZ2luO1xuXHRcdH1cblxuXHRcdC8vIFRvIHNlbmQgZGF0YSB3ZSBuZWVkIHRvIHNldCB0aGUgQ29udGVudC10eXBlIGhlYWRlcilcblx0XHRpZiAoaXRlbS52YWx1ZXMgJiYgaXRlbS5tZXRob2QgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuUE9TVCkge1xuXHRcdFx0aGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XG5cdFx0fVxuXG5cdFx0aWYgKCFjcm9zc2RvbWFpbiAmJiAhaGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl0pIHtcblx0XHRcdGhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdH1cblxuXHRcdGlmIChpdGVtLmhlYWRlcnMpIHtcblx0XHRcdGZvciAodmFyIG4gaW4gaXRlbS5oZWFkZXJzKSB7XG5cdFx0XHRcdGhlYWRlcnNbbl0gPSBpdGVtLmhlYWRlcnNbbl07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChuIGluIGhlYWRlcnMpIHtcblx0XHRcdHJlcS5zZXRSZXF1ZXN0SGVhZGVyKG4sIGhlYWRlcnNbbl0pXG5cdFx0fVxuXG5cdFx0aWYgKHJlcSBpbnN0YW5jZW9mIFhNTEh0dHBSZXF1ZXN0ICYmIGl0ZW0ud2l0aENyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJlcS53aXRoQ3JlZGVudGlhbHMgPSBpdGVtLndpdGhDcmVkZW50aWFscztcblx0XHR9XG5cblx0XHR0aGlzLl9yZXF1ZXN0ID0gcmVxO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEEgcmVxdWVzdCBoYXMgY29tcGxldGVkIChvciBmYWlsZWQgb3IgY2FuY2VsZWQpLCBhbmQgbmVlZHMgdG8gYmUgZGlzcG9zZWQuXG5cdCAqIEBtZXRob2QgX2NsZWFuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jbGVhbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fbG9hZFRpbWVvdXQpO1xuXG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lciAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2Fkc3RhcnRcIiwgdGhpcy5faGFuZGxlTG9hZFN0YXJ0UHJveHkpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgdGhpcy5faGFuZGxlUHJvZ3Jlc3NQcm94eSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCB0aGlzLl9oYW5kbGVBYm9ydFByb3h5KTtcblx0XHRcdHRoaXMuX3JlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMuX2hhbmRsZUVycm9yUHJveHkpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwidGltZW91dFwiLCB0aGlzLl9oYW5kbGVUaW1lb3V0UHJveHkpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCB0aGlzLl9oYW5kbGVMb2FkUHJveHkpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLCB0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlUHJveHkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9ubG9hZHN0YXJ0ID0gbnVsbDtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25wcm9ncmVzcyA9IG51bGw7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9uYWJvcnQgPSBudWxsO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbmVycm9yID0gbnVsbDtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub250aW1lb3V0ID0gbnVsbDtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25sb2FkID0gbnVsbDtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbUHJlbG9hZEpTIFhIUlJlcXVlc3RdXCI7XG5cdH07XG5cblx0Y3JlYXRlanMuWEhSUmVxdWVzdCA9IGNyZWF0ZWpzLnByb21vdGUoWEhSUmVxdWVzdCwgXCJBYnN0cmFjdFJlcXVlc3RcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBMb2FkUXVldWUuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4vKlxuIFRPRE86IFdJTkRPV1MgSVNTVUVTXG4gKiBObyBlcnJvciBmb3IgSFRNTCBhdWRpbyBpbiBJRSA2NzhcbiAqIFNWRyBubyBmYWlsdXJlIGVycm9yIGluIElFIDY3IChtYXliZSA4KSBUQUdTIEFORCBYSFJcbiAqIE5vIHNjcmlwdCBjb21wbGV0ZSBoYW5kbGVyIGluIElFIDY3IFRBR1MgKFhIUiBpcyBmaW5lKVxuICogTm8gWE1ML0pTT04gaW4gSUU2IFRBR1NcbiAqIE5lZWQgdG8gaGlkZSBsb2FkaW5nIFNWRyBpbiBPcGVyYSBUQUdTXG4gKiBObyBDU1Mgb25sb2FkL3JlYWR5c3RhdGVjaGFuZ2UgaW4gU2FmYXJpIG9yIEFuZHJvaWQgVEFHUyAocmVxdWlyZXMgcnVsZSBjaGVja2luZylcbiAqIFNWRyBubyBsb2FkIG9yIGZhaWx1cmUgaW4gT3BlcmEgWEhSXG4gKiBSZXBvcnRlZCBpc3N1ZXMgd2l0aCBJRTcvOFxuICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG4vLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogVGhlIExvYWRRdWV1ZSBjbGFzcyBpcyB0aGUgbWFpbiBBUEkgZm9yIHByZWxvYWRpbmcgY29udGVudC4gTG9hZFF1ZXVlIGlzIGEgbG9hZCBtYW5hZ2VyLCB3aGljaCBjYW4gcHJlbG9hZCBlaXRoZXJcblx0ICogYSBzaW5nbGUgZmlsZSwgb3IgcXVldWUgb2YgZmlsZXMuXG5cdCAqXG5cdCAqIDxiPkNyZWF0aW5nIGEgUXVldWU8L2I+PGJyIC8+XG5cdCAqIFRvIHVzZSBMb2FkUXVldWUsIGNyZWF0ZSBhIExvYWRRdWV1ZSBpbnN0YW5jZS4gSWYgeW91IHdhbnQgdG8gZm9yY2UgdGFnIGxvYWRpbmcgd2hlcmUgcG9zc2libGUsIHNldCB0aGUgcHJlZmVyWEhSXG5cdCAqIGFyZ3VtZW50IHRvIGZhbHNlLlxuXHQgKlxuXHQgKiAgICAgIHZhciBxdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUodHJ1ZSk7XG5cdCAqXG5cdCAqIDxiPkxpc3RlbmluZyBmb3IgRXZlbnRzPC9iPjxiciAvPlxuXHQgKiBBZGQgYW55IGxpc3RlbmVycyB5b3Ugd2FudCB0byB0aGUgcXVldWUuIFNpbmNlIFByZWxvYWRKUyAwLjMuMCwgdGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBsZXRzIHlvdSBhZGQgYXMgbWFueSBsaXN0ZW5lcnMgYXMgeW91IHdhbnQgZm9yIGV2ZW50cy4gWW91IGNhbiBzdWJzY3JpYmUgdG8gdGhlIGZvbGxvd2luZyBldmVudHM6PHVsPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2NvbXBsZXRlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319OiBmaXJlZCB3aGVuIGEgcXVldWUgY29tcGxldGVzIGxvYWRpbmcgYWxsXG5cdCAqICAgICBmaWxlczwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvZXJyb3I6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX06IGZpcmVkIHdoZW4gdGhlIHF1ZXVlIGVuY291bnRlcnMgYW4gZXJyb3Igd2l0aFxuXHQgKiAgICAgYW55IGZpbGUuPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9wcm9ncmVzczpldmVudFwifX17ey9jcm9zc0xpbmt9fTogUHJvZ3Jlc3MgZm9yIHRoZSBlbnRpcmUgcXVldWUgaGFzXG5cdCAqICAgICBjaGFuZ2VkLjwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319OiBBIHNpbmdsZSBmaWxlIGhhcyBjb21wbGV0ZWQgbG9hZGluZy48L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlcHJvZ3Jlc3M6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX06IFByb2dyZXNzIGZvciBhIHNpbmdsZSBmaWxlIGhhcyBjaGFuZ2VzLiBOb3RlXG5cdCAqICAgICB0aGF0IG9ubHkgZmlsZXMgbG9hZGVkIHdpdGggWEhSIChvciBwb3NzaWJseSBieSBwbHVnaW5zKSB3aWxsIGZpcmUgcHJvZ3Jlc3MgZXZlbnRzIG90aGVyIHRoYW4gMCBvciAxMDAlLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqICAgICAgcXVldWUub24oXCJmaWxlbG9hZFwiLCBoYW5kbGVGaWxlTG9hZCwgdGhpcyk7XG5cdCAqICAgICAgcXVldWUub24oXCJjb21wbGV0ZVwiLCBoYW5kbGVDb21wbGV0ZSwgdGhpcyk7XG5cdCAqXG5cdCAqIDxiPkFkZGluZyBmaWxlcyBhbmQgbWFuaWZlc3RzPC9iPjxiciAvPlxuXHQgKiBBZGQgZmlsZXMgeW91IHdhbnQgdG8gbG9hZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX0gb3IgYWRkIG11bHRpcGxlIGZpbGVzIGF0IGFcblx0ICogdGltZSB1c2luZyBhIGxpc3Qgb3IgYSBtYW5pZmVzdCBkZWZpbml0aW9uIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX0uIEZpbGVzIGFyZVxuXHQgKiBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBhY3RpdmUgcXVldWUsIHNvIHlvdSBjYW4gdXNlIHRoZXNlIG1ldGhvZHMgYXMgbWFueSB0aW1lcyBhcyB5b3UgbGlrZSwgd2hlbmV2ZXIgeW91XG5cdCAqIGxpa2UuXG5cdCAqXG5cdCAqICAgICAgcXVldWUubG9hZEZpbGUoXCJmaWxlUGF0aC9maWxlLmpwZ1wiKTtcblx0ICogICAgICBxdWV1ZS5sb2FkRmlsZSh7aWQ6XCJpbWFnZVwiLCBzcmM6XCJmaWxlUGF0aC9maWxlLmpwZ1wifSk7XG5cdCAqICAgICAgcXVldWUubG9hZE1hbmlmZXN0KFtcImZpbGVQYXRoL2ZpbGUuanBnXCIsIHtpZDpcImltYWdlXCIsIHNyYzpcImZpbGVQYXRoL2ZpbGUuanBnXCJ9XSk7XG5cdCAqXG5cdCAqICAgICAgLy8gVXNlIGFuIGV4dGVybmFsIG1hbmlmZXN0XG5cdCAqICAgICAgcXVldWUubG9hZE1hbmlmZXN0KFwicGF0aC90by9tYW5pZmVzdC5qc29uXCIpO1xuXHQgKiAgICAgIHF1ZXVlLmxvYWRNYW5pZmVzdCh7c3JjOlwibWFuaWZlc3QuanNvblwiLCB0eXBlOlwibWFuaWZlc3RcIn0pO1xuXHQgKlxuXHQgKiBJZiB5b3UgcGFzcyBgZmFsc2VgIGFzIHRoZSBgbG9hZE5vd2AgcGFyYW1ldGVyLCB0aGUgcXVldWUgd2lsbCBub3Qga2ljayBvZiB0aGUgbG9hZCBvZiB0aGUgZmlsZXMsIGJ1dCBpdCB3aWxsIG5vdFxuXHQgKiBzdG9wIGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZC4gQ2FsbCB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvbG9hZFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgdG8gYmVnaW5cblx0ICogYSBwYXVzZWQgcXVldWUuIE5vdGUgdGhhdCBhIHBhdXNlZCBxdWV1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgcmVzdW1lIHdoZW4gbmV3IGZpbGVzIGFyZSBhZGRlZCB0byBpdCB3aXRoIGFcblx0ICogYGxvYWROb3dgIGFyZ3VtZW50IG9mIGB0cnVlYC5cblx0ICpcblx0ICogICAgICBxdWV1ZS5sb2FkKCk7XG5cdCAqXG5cdCAqIDxiPkZpbGUgVHlwZXM8L2I+PGJyIC8+XG5cdCAqIFRoZSBmaWxlIHR5cGUgb2YgYSBtYW5pZmVzdCBpdGVtIGlzIGF1dG8tZGV0ZXJtaW5lZCBieSB0aGUgZmlsZSBleHRlbnNpb24uIFRoZSBwYXR0ZXJuIG1hdGNoaW5nIGluIFByZWxvYWRKU1xuXHQgKiBzaG91bGQgaGFuZGxlIHRoZSBtYWpvcml0eSBvZiBzdGFuZGFyZCBmaWxlIGFuZCB1cmwgZm9ybWF0cywgYW5kIHdvcmtzIHdpdGggY29tbW9uIGZpbGUgZXh0ZW5zaW9ucy4gSWYgeW91IGhhdmVcblx0ICogZWl0aGVyIGEgbm9uLXN0YW5kYXJkIGZpbGUgZXh0ZW5zaW9uLCBvciBhcmUgc2VydmluZyB0aGUgZmlsZSB1c2luZyBhIHByb3h5IHNjcmlwdCwgdGhlbiB5b3UgY2FuIHBhc3MgaW4gYVxuXHQgKiA8Y29kZT50eXBlPC9jb2RlPiBwcm9wZXJ0eSB3aXRoIGFueSBtYW5pZmVzdCBpdGVtLlxuXHQgKlxuXHQgKiAgICAgIHF1ZXVlLmxvYWRGaWxlKHtzcmM6XCJwYXRoL3RvL215RmlsZS5tcDN4XCIsIHR5cGU6Y3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU09VTkR9KTtcblx0ICpcblx0ICogICAgICAvLyBOb3RlIHRoYXQgUHJlbG9hZEpTIHdpbGwgbm90IHJlYWQgYSBmaWxlIGV4dGVuc2lvbiBmcm9tIHRoZSBxdWVyeSBzdHJpbmdcblx0ICogICAgICBxdWV1ZS5sb2FkRmlsZSh7c3JjOlwiaHR0cDovL3NlcnZlci5jb20vcHJveHk/ZmlsZT1pbWFnZS5qcGdcIiwgdHlwZTpjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5JTUFHRX0pO1xuXHQgKlxuXHQgKiBTdXBwb3J0ZWQgdHlwZXMgYXJlIGRlZmluZWQgb24gdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzLCBhbmQgaW5jbHVkZTpcblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0JJTkFSWTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogUmF3IGJpbmFyeSBkYXRhIHZpYSBYSFI8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0NTUzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogQ1NTIGZpbGVzPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9JTUFHRTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogQ29tbW9uIGltYWdlIGZvcm1hdHM8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pBVkFTQ1JJUFQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IEphdmFTY3JpcHQgZmlsZXM8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pTT046cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IEpTT04gZGF0YTwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSlNPTlA6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IEpTT04gZmlsZXMgY3Jvc3MtZG9tYWluPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9NQU5JRkVTVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogQSBsaXN0IG9mIGZpbGVzIHRvIGxvYWQgaW4gSlNPTiBmb3JtYXQsIHNlZVxuXHQgKiAgICAge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319PC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TT1VORDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogQXVkaW8gZmlsZSBmb3JtYXRzPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TUFJJVEVTSEVFVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogSlNPTiBTcHJpdGVTaGVldCBkZWZpbml0ZWlvbnMuIFRoaXNcblx0ICogICAgIHdpbGwgYWxzbyBsb2FkIHN1Yi1pbWFnZXMsIGFuZCBwcm92aWRlIGEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UuPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TVkc6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IFNWRyBmaWxlczwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvVEVYVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogVGV4dCBmaWxlcyAtIFhIUiBvbmx5PC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9YTUw6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IFhNTCBkYXRhPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogPGVtPk5vdGU6IExvYWRlciB0eXBlcyB1c2VkIHRvIGJlIGRlZmluZWQgb24gTG9hZFF1ZXVlLCBidXQgaGF2ZSBiZWVuIG1vdmVkIHRvIEFic3RyYWN0TG9hZGVyIGZvciBiZXR0ZXJcblx0ICogcG9ydGFiaWxpdHkgb2YgbG9hZGVyIGNsYXNzZXMsIHdoaWNoIGNhbiBiZSB1c2VkIGluZGl2aWR1YWxseSBub3cuIFRoZSBwcm9wZXJ0aWVzIG9uIExvYWRRdWV1ZSBzdGlsbCBleGlzdCwgYnV0XG5cdCAqIGFyZSBkZXByZWNhdGVkLjwvZW0+XG5cdCAqXG5cdCAqIDxiPkhhbmRsaW5nIFJlc3VsdHM8L2I+PGJyIC8+XG5cdCAqIFdoZW4gYSBmaWxlIGlzIGZpbmlzaGVkIGRvd25sb2FkaW5nLCBhIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBpc1xuXHQgKiBkaXNwYXRjaGVkLiBJbiBhbiBleGFtcGxlIGFib3ZlLCB0aGVyZSBpcyBhbiBldmVudCBsaXN0ZW5lciBzbmlwcGV0IGZvciBmaWxlbG9hZC4gTG9hZGVkIGZpbGVzIGFyZSB1c3VhbGx5IGFcblx0ICogZm9ybWF0dGVkIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGltbWVkaWF0ZWx5LCBpbmNsdWRpbmc6XG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5CaW5hcnk6IFRoZSBiaW5hcnkgbG9hZGVkIHJlc3VsdDwvbGk+XG5cdCAqICAgICA8bGk+Q1NTOiBBICZsdDtsaW5rIC8mZ3Q7IHRhZzwvbGk+XG5cdCAqICAgICA8bGk+SW1hZ2U6IEFuICZsdDtpbWcgLyZndDsgdGFnPC9saT5cblx0ICogICAgIDxsaT5KYXZhU2NyaXB0OiBBICZsdDtzY3JpcHQgLyZndDsgdGFnPC9saT5cblx0ICogICAgIDxsaT5KU09OL0pTT05QOiBBIGZvcm1hdHRlZCBKYXZhU2NyaXB0IE9iamVjdDwvbGk+XG5cdCAqICAgICA8bGk+TWFuaWZlc3Q6IEEgSmF2YVNjcmlwdCBvYmplY3QuXG5cdCAqICAgICA8bGk+U291bmQ6IEFuICZsdDthdWRpbyAvJmd0OyB0YWc8L2E+XG5cdCAqICAgICA8bGk+U3ByaXRlU2hlZXQ6IEEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UsIGNvbnRhaW5pbmcgbG9hZGVkIGltYWdlcy5cblx0ICogICAgIDxsaT5TVkc6IEFuICZsdDtvYmplY3QgLyZndDsgdGFnPC9saT5cblx0ICogICAgIDxsaT5UZXh0OiBSYXcgdGV4dDwvbGk+XG5cdCAqICAgICA8bGk+WE1MOiBBbiBYTUwgRE9NIG5vZGU8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZUZpbGVMb2FkKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIHZhciBpdGVtID0gZXZlbnQuaXRlbTsgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGl0ZW0gdGhhdCB3YXMgcGFzc2VkIGluIHRvIHRoZSBMb2FkUXVldWVcblx0ICogICAgICAgICAgdmFyIHR5cGUgPSBpdGVtLnR5cGU7XG5cdCAqXG5cdCAqICAgICAgICAgIC8vIEFkZCBhbnkgaW1hZ2VzIHRvIHRoZSBwYWdlIGJvZHkuXG5cdCAqICAgICAgICAgIGlmICh0eXBlID09IGNyZWF0ZWpzLkxvYWRRdWV1ZS5JTUFHRSkge1xuXHQgKiAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChldmVudC5yZXN1bHQpO1xuXHQgKiAgICAgICAgICB9XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBBdCBhbnkgdGltZSBhZnRlciB0aGUgZmlsZSBoYXMgYmVlbiBsb2FkZWQgKHVzdWFsbHkgYWZ0ZXIgdGhlIHF1ZXVlIGhhcyBjb21wbGV0ZWQpLCBhbnkgcmVzdWx0IGNhbiBiZSBsb29rZWQgdXBcblx0ICogdmlhIGl0cyBcImlkXCIgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2dldFJlc3VsdFwifX17ey9jcm9zc0xpbmt9fS4gSWYgbm8gaWQgd2FzIHByb3ZpZGVkLCB0aGVuIHRoZVxuXHQgKiBcInNyY1wiIG9yIGZpbGUgcGF0aCBjYW4gYmUgdXNlZCBpbnN0ZWFkLCBpbmNsdWRpbmcgdGhlIGBwYXRoYCBkZWZpbmVkIGJ5IGEgbWFuaWZlc3QsIGJ1dCA8c3Ryb25nPm5vdCBpbmNsdWRpbmc8L3N0cm9uZz5cblx0ICogYSBiYXNlIHBhdGggZGVmaW5lZCBvbiB0aGUgTG9hZFF1ZXVlLiBJdCBpcyByZWNvbW1lbmRlZCB0byBhbHdheXMgcGFzcyBhbiBpZCBpZiB5b3Ugd2FudCB0byBsb29rIHVwIGNvbnRlbnQuXG5cdCAqXG5cdCAqICAgICAgdmFyIGltYWdlID0gcXVldWUuZ2V0UmVzdWx0KFwiaW1hZ2VcIik7XG5cdCAqICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbWFnZSk7XG5cdCAqXG5cdCAqIFJhdyBsb2FkZWQgY29udGVudCBjYW4gYmUgYWNjZXNzZWQgdXNpbmcgdGhlIDxjb2RlPnJhd1Jlc3VsdDwvY29kZT4gcHJvcGVydHkgb2YgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCwgb3IgY2FuIGJlIGxvb2tlZCB1cCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZ2V0UmVzdWx0XCJ9fXt7L2Nyb3NzTGlua319LCBwYXNzaW5nIGB0cnVlYCBhcyB0aGUgMm5kXG5cdCAqIGFyZ3VtZW50LiBUaGlzIGlzIG9ubHkgYXBwbGljYWJsZSBmb3IgY29udGVudCB0aGF0IGhhcyBiZWVuIHBhcnNlZCBmb3IgdGhlIGJyb3dzZXIsIHNwZWNpZmljYWxseTogSmF2YVNjcmlwdCxcblx0ICogQ1NTLCBYTUwsIFNWRywgYW5kIEpTT04gb2JqZWN0cywgb3IgYW55dGhpbmcgbG9hZGVkIHdpdGggWEhSLlxuXHQgKlxuXHQgKiAgICAgIHZhciBpbWFnZSA9IHF1ZXVlLmdldFJlc3VsdChcImltYWdlXCIsIHRydWUpOyAvLyBsb2FkIHRoZSBiaW5hcnkgaW1hZ2UgZGF0YSBsb2FkZWQgd2l0aCBYSFIuXG5cdCAqXG5cdCAqIDxiPlBsdWdpbnM8L2I+PGJyIC8+XG5cdCAqIExvYWRRdWV1ZSBoYXMgYSBzaW1wbGUgcGx1Z2luIGFyY2hpdGVjdHVyZSB0byBoZWxwIHByb2Nlc3MgYW5kIHByZWxvYWQgY29udGVudC4gRm9yIGV4YW1wbGUsIHRvIHByZWxvYWQgYXVkaW8sXG5cdCAqIG1ha2Ugc3VyZSB0byBpbnN0YWxsIHRoZSA8YSBocmVmPVwiaHR0cDovL3NvdW5kanMuY29tXCI+U291bmRKUzwvYT4gU291bmQgY2xhc3MsIHdoaWNoIHdpbGwgaGVscCBsb2FkIEhUTUwgYXVkaW8sXG5cdCAqIEZsYXNoIGF1ZGlvLCBhbmQgV2ViQXVkaW8gZmlsZXMuIFRoaXMgc2hvdWxkIGJlIGluc3RhbGxlZCA8c3Ryb25nPmJlZm9yZTwvc3Ryb25nPiBsb2FkaW5nIGFueSBhdWRpbyBmaWxlcy5cblx0ICpcblx0ICogICAgICBxdWV1ZS5pbnN0YWxsUGx1Z2luKGNyZWF0ZWpzLlNvdW5kKTtcblx0ICpcblx0ICogPGg0Pktub3duIEJyb3dzZXIgSXNzdWVzPC9oND5cblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPkJyb3dzZXJzIHdpdGhvdXQgYXVkaW8gc3VwcG9ydCBjYW4gbm90IGxvYWQgYXVkaW8gZmlsZXMuPC9saT5cblx0ICogICAgIDxsaT5TYWZhcmkgb24gTWFjIE9TIFggY2FuIG9ubHkgcGxheSBIVE1MIGF1ZGlvIGlmIFF1aWNrVGltZSBpcyBpbnN0YWxsZWQ8L2xpPlxuXHQgKiAgICAgPGxpPkhUTUwgQXVkaW8gdGFncyB3aWxsIG9ubHkgZG93bmxvYWQgdW50aWwgdGhlaXIgPGNvZGU+Y2FuUGxheVRocm91Z2g8L2NvZGU+IGV2ZW50IGlzIGZpcmVkLiBCcm93c2VycyBvdGhlclxuXHQgKiAgICAgdGhhbiBDaHJvbWUgd2lsbCBjb250aW51ZSB0byBkb3dubG9hZCBpbiB0aGUgYmFja2dyb3VuZC48L2xpPlxuXHQgKiAgICAgPGxpPldoZW4gbG9hZGluZyBzY3JpcHRzIHVzaW5nIHRhZ3MsIHRoZXkgYXJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gdGhlIGRvY3VtZW50LjwvbGk+XG5cdCAqICAgICA8bGk+U2NyaXB0cyBsb2FkZWQgdmlhIFhIUiBtYXkgbm90IGJlIHByb3Blcmx5IGluc3BlY3RhYmxlIHdpdGggYnJvd3NlciB0b29scy48L2xpPlxuXHQgKiAgICAgPGxpPklFNiBhbmQgSUU3IChhbmQgc29tZSBvdGhlciBicm93c2VycykgbWF5IG5vdCBiZSBhYmxlIHRvIGxvYWQgWE1MLCBUZXh0LCBvciBKU09OLCBzaW5jZSB0aGV5IHJlcXVpcmVcblx0ICogICAgIFhIUiB0byB3b3JrLjwvbGk+XG5cdCAqICAgICA8bGk+Q29udGVudCBsb2FkZWQgdmlhIHRhZ3Mgd2lsbCBub3Qgc2hvdyBwcm9ncmVzcywgYW5kIHdpbGwgY29udGludWUgdG8gZG93bmxvYWQgaW4gdGhlIGJhY2tncm91bmQgd2hlblxuXHQgKiAgICAgY2FuY2VsZWQsIGFsdGhvdWdoIG5vIGV2ZW50cyB3aWxsIGJlIGRpc3BhdGNoZWQuPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogQGNsYXNzIExvYWRRdWV1ZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmVmZXJYSFI9dHJ1ZV0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwcmVsb2FkIGluc3RhbmNlIHdpbGwgZmF2b3IgbG9hZGluZyB3aXRoIFhIUiAoWE1MIEhUVFBcblx0ICogUmVxdWVzdHMpLCBvciBIVE1MIHRhZ3MuIFdoZW4gdGhpcyBpcyBgZmFsc2VgLCB0aGUgcXVldWUgd2lsbCB1c2UgdGFnIGxvYWRpbmcgd2hlbiBwb3NzaWJsZSwgYW5kIGZhbGwgYmFjayBvbiBYSFJcblx0ICogd2hlbiBuZWNlc3NhcnkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbYmFzZVBhdGg9XCJcIl0gQSBwYXRoIHRoYXQgd2lsbCBiZSBwcmVwZW5kZWQgb24gdG8gdGhlIHNvdXJjZSBwYXJhbWV0ZXIgb2YgYWxsIGl0ZW1zIGluIHRoZSBxdWV1ZVxuXHQgKiBiZWZvcmUgdGhleSBhcmUgbG9hZGVkLiAgU291cmNlcyBiZWdpbm5pbmcgd2l0aCBhIHByb3RvY29sIHN1Y2ggYXMgYGh0dHA6Ly9gIG9yIGEgcmVsYXRpdmUgcGF0aCBzdWNoIGFzIGAuLi9gXG5cdCAqIHdpbGwgbm90IHJlY2VpdmUgYSBiYXNlIHBhdGguXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEJvb2xlYW59IFtjcm9zc09yaWdpbj1cIlwiXSBBbiBvcHRpb25hbCBmbGFnIHRvIHN1cHBvcnQgaW1hZ2VzIGxvYWRlZCBmcm9tIGEgQ09SUy1lbmFibGVkIHNlcnZlci4gVG9cblx0ICogdXNlIGl0LCBzZXQgdGhpcyB2YWx1ZSB0byBgdHJ1ZWAsIHdoaWNoIHdpbGwgZGVmYXVsdCB0aGUgY3Jvc3NPcmlnaW4gcHJvcGVydHkgb24gaW1hZ2VzIHRvIFwiQW5vbnltb3VzXCIuIEFueVxuXHQgKiBzdHJpbmcgdmFsdWUgd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCwgYnV0IG9ubHkgXCJcIiBhbmQgXCJBbm9ueW1vdXNcIiBhcmUgcmVjb21tZW5kZWQuIDxzdHJvbmc+Tm90ZTogVGhlIGNyb3NzT3JpZ2luXG5cdCAqIHBhcmFtZXRlciBpcyBkZXByZWNhdGVkLiBVc2UgTG9hZEl0ZW0uY3Jvc3NPcmlnaW4gaW5zdGVhZDwvc3Ryb25nPlxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICovXG5cdGZ1bmN0aW9uIExvYWRRdWV1ZSAocHJlZmVyWEhSLCBiYXNlUGF0aCwgY3Jvc3NPcmlnaW4pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKCk7XG5cblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBvZiB0aGUgcGx1Z2lucyByZWdpc3RlcmVkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9pbnN0YWxsUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBfcGx1Z2luc1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBzaW5jZSAwLjYuMVxuXHRcdCAqL1xuXHRcdHRoaXMuX3BsdWdpbnMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBoYXNoIG9mIGNhbGxiYWNrcyB0aGF0IGFyZSBmaXJlZCBmb3IgZWFjaCBmaWxlIHR5cGUgYmVmb3JlIHRoZSBmaWxlIGlzIGxvYWRlZCwgZ2l2aW5nIHBsdWdpbnMgdGhlXG5cdFx0ICogYWJpbGl0eSB0byBvdmVycmlkZSBwcm9wZXJ0aWVzIG9mIHRoZSBsb2FkLiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvaW5zdGFsbFBsdWdpblwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIG1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgX3R5cGVDYWxsYmFja3Ncblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fdHlwZUNhbGxiYWNrcyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IGhhc2ggb2YgY2FsbGJhY2tzIHRoYXQgYXJlIGZpcmVkIGZvciBlYWNoIGZpbGUgZXh0ZW5zaW9uIGJlZm9yZSB0aGUgZmlsZSBpcyBsb2FkZWQsIGdpdmluZyBwbHVnaW5zIHRoZVxuXHRcdCAqIGFiaWxpdHkgdG8gb3ZlcnJpZGUgcHJvcGVydGllcyBvZiB0aGUgbG9hZC4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2luc3RhbGxQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBtZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdFx0ICogQHByb3BlcnR5IF9leHRlbnNpb25DYWxsYmFja3Ncblx0XHQgKiBAdHlwZSB7bnVsbH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2V4dGVuc2lvbkNhbGxiYWNrcyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG5leHQgcHJlbG9hZCBxdWV1ZSB0byBwcm9jZXNzIHdoZW4gdGhpcyBvbmUgaXMgY29tcGxldGUuIElmIGFuIGVycm9yIGlzIHRocm93biBpbiB0aGUgY3VycmVudCBxdWV1ZSwgYW5kXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3N0b3BPbkVycm9yOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlzIGB0cnVlYCwgdGhlIG5leHQgcXVldWUgd2lsbCBub3QgYmUgcHJvY2Vzc2VkLlxuXHRcdCAqIEBwcm9wZXJ0eSBuZXh0XG5cdFx0ICogQHR5cGUge0xvYWRRdWV1ZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5uZXh0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEVuc3VyZSBsb2FkZWQgc2NyaXB0cyBcImNvbXBsZXRlXCIgaW4gdGhlIG9yZGVyIHRoZXkgYXJlIHNwZWNpZmllZC4gTG9hZGVkIHNjcmlwdHMgYXJlIGFkZGVkIHRvIHRoZSBkb2N1bWVudCBoZWFkXG5cdFx0ICogb25jZSB0aGV5IGFyZSBsb2FkZWQuIFNjcmlwdHMgbG9hZGVkIHZpYSB0YWdzIHdpbGwgbG9hZCBvbmUtYXQtYS10aW1lIHdoZW4gdGhpcyBwcm9wZXJ0eSBpcyBgdHJ1ZWAsIHdoZXJlYXNcblx0XHQgKiBzY3JpcHRzIGxvYWRlZCB1c2luZyBYSFIgY2FuIGxvYWQgaW4gYW55IG9yZGVyLCBidXQgd2lsbCBcImZpbmlzaFwiIGFuZCBiZSBhZGRlZCB0byB0aGUgZG9jdW1lbnQgaW4gdGhlIG9yZGVyXG5cdFx0ICogc3BlY2lmaWVkLlxuXHRcdCAqXG5cdFx0ICogQW55IGl0ZW1zIGNhbiBiZSBzZXQgdG8gbG9hZCBpbiBvcmRlciBieSBzZXR0aW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJtYWludGFpbk9yZGVyOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogcHJvcGVydHkgb24gdGhlIGxvYWQgaXRlbSwgb3IgYnkgZW5zdXJpbmcgdGhhdCBvbmx5IG9uZSBjb25uZWN0aW9uIGNhbiBiZSBvcGVuIGF0IGEgdGltZSB1c2luZ1xuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRNYXhDb25uZWN0aW9uc1wifX17ey9jcm9zc0xpbmt9fS4gTm90ZSB0aGF0IHdoZW4gdGhlIGBtYWludGFpblNjcmlwdE9yZGVyYCBwcm9wZXJ0eVxuXHRcdCAqIGlzIHNldCB0byBgdHJ1ZWAsIHNjcmlwdHMgaXRlbXMgYXJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIGBtYWludGFpbk9yZGVyPXRydWVgLCBhbmQgY2hhbmdpbmcgdGhlXG5cdFx0ICogYG1haW50YWluU2NyaXB0T3JkZXJgIHRvIGBmYWxzZWAgZHVyaW5nIGEgbG9hZCB3aWxsIG5vdCBjaGFuZ2UgaXRlbXMgYWxyZWFkeSBpbiBhIHF1ZXVlLlxuXHRcdCAqXG5cdFx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHRcdCAqXG5cdFx0ICogICAgICB2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG5cdFx0ICogICAgICBxdWV1ZS5zZXRNYXhDb25uZWN0aW9ucygzKTsgLy8gU2V0IGEgaGlnaGVyIG51bWJlciB0byBsb2FkIG11bHRpcGxlIGl0ZW1zIGF0IG9uY2Vcblx0XHQgKiAgICAgIHF1ZXVlLm1haW50YWluU2NyaXB0T3JkZXIgPSB0cnVlOyAvLyBFbnN1cmUgc2NyaXB0cyBhcmUgbG9hZGVkIGluIG9yZGVyXG5cdFx0ICogICAgICBxdWV1ZS5sb2FkTWFuaWZlc3QoW1xuXHRcdCAqICAgICAgICAgIFwic2NyaXB0MS5qc1wiLFxuXHRcdCAqICAgICAgICAgIFwic2NyaXB0Mi5qc1wiLFxuXHRcdCAqICAgICAgICAgIFwiaW1hZ2UucG5nXCIsIC8vIExvYWQgYW55IHRpbWVcblx0XHQgKiAgICAgICAgICB7c3JjOiBcImltYWdlMi5wbmdcIiwgbWFpbnRhaW5PcmRlcjogdHJ1ZX0gLy8gV2lsbCB3YWl0IGZvciBzY3JpcHQyLmpzXG5cdFx0ICogICAgICAgICAgXCJpbWFnZTMucG5nXCIsXG5cdFx0ICogICAgICAgICAgXCJzY3JpcHQzLmpzXCIgLy8gV2lsbCB3YWl0IGZvciBpbWFnZTIucG5nIGJlZm9yZSBsb2FkaW5nIChvciBjb21wbGV0aW5nIHdoZW4gbG9hZGluZyB3aXRoIFhIUilcblx0XHQgKiAgICAgIF0pO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IG1haW50YWluU2NyaXB0T3JkZXJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5tYWludGFpblNjcmlwdE9yZGVyID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgaWYgdGhlIExvYWRRdWV1ZSB3aWxsIHN0b3AgcHJvY2Vzc2luZyB0aGUgY3VycmVudCBxdWV1ZSB3aGVuIGFuIGVycm9yIGlzIGVuY291bnRlcmVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBzdG9wT25FcnJvclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5zdG9wT25FcnJvciA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBtYXhpbXVtIG9wZW4gY29ubmVjdGlvbnMgdGhhdCBhIGxvYWRRdWV1ZSB0cmllcyB0byBtYWludGFpbi4gUGxlYXNlIHNlZVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRNYXhDb25uZWN0aW9uc1wifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgX21heENvbm5lY3Rpb25zXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9tYXhDb25uZWN0aW9ucyA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBBbiBpbnRlcm5hbCBsaXN0IG9mIGFsbCB0aGUgZGVmYXVsdCBMb2FkZXJzIHRoYXQgYXJlIGluY2x1ZGVkIHdpdGggUHJlbG9hZEpTLiBCZWZvcmUgYW4gaXRlbSBpcyBsb2FkZWQsIHRoZVxuXHRcdCAqIGF2YWlsYWJsZSBsb2FkZXIgbGlzdCBpcyBpdGVyYXRlZCwgaW4gdGhlIG9yZGVyIHRoZXkgYXJlIGluY2x1ZGVkLCBhbmQgYXMgc29vbiBhcyBhIGxvYWRlciBpbmRpY2F0ZXMgaXQgY2FuXG5cdFx0ICogaGFuZGxlIHRoZSBjb250ZW50LCBpdCB3aWxsIGJlIHNlbGVjdGVkLiBUaGUgZGVmYXVsdCBsb2FkZXIsICh7eyNjcm9zc0xpbmsgXCJUZXh0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGlzXG5cdFx0ICogbGFzdCBpbiB0aGUgbGlzdCwgc28gaXQgd2lsbCBiZSB1c2VkIGlmIG5vIG90aGVyIG1hdGNoIGlzIGZvdW5kLiBUeXBpY2FsbHksIGxvYWRlcnMgd2lsbCBtYXRjaCBiYXNlZCBvbiB0aGVcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS90eXBlXCJ9fXt7L2Nyb3NzTGlua319LCB3aGljaCBpcyBhdXRvbWF0aWNhbGx5IGRldGVybWluZWQgdXNpbmcgdGhlIGZpbGUgZXh0ZW5zaW9uIG9mXG5cdFx0ICogdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL3NyYzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKlxuXHRcdCAqIExvYWRlcnMgY2FuIGJlIHJlbW92ZWQgZnJvbSBQcmVsb2FkSlMgYnkgc2ltcGx5IG5vdCBpbmNsdWRpbmcgdGhlbS5cblx0XHQgKlxuXHRcdCAqIEN1c3RvbSBsb2FkZXJzIGluc3RhbGxlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJyZWdpc3RlckxvYWRlclwifX17ey9jcm9zc0xpbmt9fSB3aWxsIGJlIHByZXBlbmRlZCB0byB0aGlzIGxpc3Rcblx0XHQgKiBzbyB0aGF0IHRoZXkgYXJlIGNoZWNrZWQgZmlyc3QuXG5cdFx0ICogQHByb3BlcnR5IF9hdmFpbGFibGVMb2FkZXJzXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHNpbmNlIDAuNi4wXG5cdFx0ICovXG5cdFx0dGhpcy5fYXZhaWxhYmxlTG9hZGVycyA9IFtcblx0XHRcdGNyZWF0ZWpzLkltYWdlTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuSmF2YVNjcmlwdExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLkNTU0xvYWRlcixcblx0XHRcdGNyZWF0ZWpzLkpTT05Mb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5KU09OUExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlNvdW5kTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuTWFuaWZlc3RMb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5TcHJpdGVTaGVldExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlhNTExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlNWR0xvYWRlcixcblx0XHRcdGNyZWF0ZWpzLkJpbmFyeUxvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlZpZGVvTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuVGV4dExvYWRlcixcblx0XHRdO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBidWlsdCBpbiBsb2FkZXJzLCBzbyB0aGV5IGNhbid0IGJlIHJlbW92ZWQgYnkge3sjY3Jvc3NMaW5rIFwidW5yZWdpc3RlckxvYWRlclwifX17ey9jcm9zc0xpbmt9LlxuXHRcdFx0XHQgKiBAcHJvcGVydHkgX2RlZmF1bHRMb2FkZXJMZW5ndGhcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHNpbmNlIDAuNi4wXG5cdFx0ICovXG5cdFx0dGhpcy5fZGVmYXVsdExvYWRlckxlbmd0aCA9IHRoaXMuX2F2YWlsYWJsZUxvYWRlcnMubGVuZ3RoO1xuXG5cdFx0dGhpcy5pbml0KHByZWZlclhIUiwgYmFzZVBhdGgsIGNyb3NzT3JpZ2luKTtcblx0fVxuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKExvYWRRdWV1ZSwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IExvYWRRdWV1ZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblx0LyoqXG5cdCAqIEFuIGludGVybmFsIGluaXRpYWxpemF0aW9uIG1ldGhvZCwgd2hpY2ggaXMgdXNlZCBmb3IgaW5pdGlhbCBzZXQgdXAsIGJ1dCBhbHNvIHRvIHJlc2V0IHRoZSBMb2FkUXVldWUuXG5cdCAqIEBtZXRob2QgaW5pdFxuXHQgKiBAcGFyYW0gcHJlZmVyWEhSXG5cdCAqIEBwYXJhbSBiYXNlUGF0aFxuXHQgKiBAcGFyYW0gY3Jvc3NPcmlnaW5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuaW5pdCA9IGZ1bmN0aW9uIChwcmVmZXJYSFIsIGJhc2VQYXRoLCBjcm9zc09yaWdpbikge1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgdXNlWEhSXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqIEBkZXByZWNhdGVkIFVzZSBwcmVmZXJYSFIgaW5zdGVhZC5cblx0XHQgKi9cblx0XHR0aGlzLnVzZVhIUiA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBUcnkgYW5kIHVzZSBYTUxIdHRwUmVxdWVzdCAoWEhSKSB3aGVuIHBvc3NpYmxlLiBOb3RlIHRoYXQgTG9hZFF1ZXVlIHdpbGwgZGVmYXVsdCB0byB0YWcgbG9hZGluZyBvciBYSFJcblx0XHQgKiBsb2FkaW5nIGRlcGVuZGluZyBvbiB0aGUgcmVxdWlyZW1lbnRzIGZvciBhIG1lZGlhIHR5cGUuIEZvciBleGFtcGxlLCBIVE1MIGF1ZGlvIGNhbiBub3QgYmUgbG9hZGVkIHdpdGggWEhSLFxuXHRcdCAqIGFuZCBwbGFpbiB0ZXh0IGNhbiBub3QgYmUgbG9hZGVkIHdpdGggdGFncywgc28gaXQgd2lsbCBkZWZhdWx0IHRoZSB0aGUgY29ycmVjdCB0eXBlIGluc3RlYWQgb2YgdXNpbmcgdGhlXG5cdFx0ICogdXNlci1kZWZpbmVkIHR5cGUuXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqIEBzaW5jZSAwLjYuMFxuXHRcdCAqL1xuXHRcdHRoaXMucHJlZmVyWEhSID0gdHJ1ZTsgLy9UT0RPOiBHZXQvU2V0XG5cdFx0dGhpcy5fcHJlZmVyWEhSID0gdHJ1ZTtcblx0XHR0aGlzLnNldFByZWZlclhIUihwcmVmZXJYSFIpO1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRoZSBxdWV1ZSBpcyBjdXJyZW50bHkgcGF1c2VkIG9yIG5vdC5cblx0XHQgKiBAcHJvcGVydHkgX3BhdXNlZFxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBBIHBhdGggdGhhdCB3aWxsIGJlIHByZXBlbmRlZCBvbiB0byB0aGUgaXRlbSdzIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL3NyYzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS4gVGhlXG5cdFx0ICogYF9iYXNlUGF0aGAgcHJvcGVydHkgd2lsbCBvbmx5IGJlIHVzZWQgaWYgYW4gaXRlbSdzIHNvdXJjZSBpcyByZWxhdGl2ZSwgYW5kIGRvZXMgbm90IGluY2x1ZGUgYSBwcm90b2NvbCBzdWNoXG5cdFx0ICogYXMgYGh0dHA6Ly9gLCBvciBhIHJlbGF0aXZlIHBhdGggc3VjaCBhcyBgLi4vYC5cblx0XHQgKiBAcHJvcGVydHkgX2Jhc2VQYXRoXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBzaW5jZSAwLjMuMVxuXHRcdCAqL1xuXHRcdHRoaXMuX2Jhc2VQYXRoID0gYmFzZVBhdGg7XG5cblx0XHQvKipcblx0XHQgKiBBbiBvcHRpb25hbCBmbGFnIHRvIHNldCBvbiBpbWFnZXMgdGhhdCBhcmUgbG9hZGVkIHVzaW5nIFByZWxvYWRKUywgd2hpY2ggZW5hYmxlcyBDT1JTIHN1cHBvcnQuIEltYWdlcyBsb2FkZWRcblx0XHQgKiBjcm9zcy1kb21haW4gYnkgc2VydmVycyB0aGF0IHN1cHBvcnQgQ09SUyByZXF1aXJlIHRoZSBjcm9zc09yaWdpbiBmbGFnIHRvIGJlIGxvYWRlZCBhbmQgaW50ZXJhY3RlZCB3aXRoIGJ5XG5cdFx0ICogYSBjYW52YXMuIFdoZW4gbG9hZGluZyBsb2NhbGx5LCBvciB3aXRoIGEgc2VydmVyIHdpdGggbm8gQ09SUyBzdXBwb3J0LCB0aGlzIGZsYWcgY2FuIGNhdXNlIG90aGVyIHNlY3VyaXR5IGlzc3Vlcyxcblx0XHQgKiBzbyBpdCBpcyByZWNvbW1lbmRlZCB0byBvbmx5IHNldCBpdCBpZiB5b3UgYXJlIHN1cmUgdGhlIHNlcnZlciBzdXBwb3J0cyBpdC4gQ3VycmVudGx5LCBzdXBwb3J0ZWQgdmFsdWVzIGFyZSBcIlwiXG5cdFx0ICogYW5kIFwiQW5vbnltb3VzXCIuXG5cdFx0ICogQHByb3BlcnR5IF9jcm9zc09yaWdpblxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgXCJcIlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHNpbmNlIDAuNC4xXG5cdFx0ICovXG5cdFx0dGhpcy5fY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRTdGFydCBldmVudCB3YXMgZGlzcGF0Y2hlZCBhbHJlYWR5LiBUaGlzIGV2ZW50IGlzIG9ubHkgZmlyZWQgb25lIHRpbWUsIHdoZW4gdGhlIGZpcnN0XG5cdFx0ICogZmlsZSBpcyByZXF1ZXN0ZWQuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkU3RhcnRXYXNEaXNwYXRjaGVkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRTdGFydFdhc0Rpc3BhdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgaWYgdGhlcmUgaXMgY3VycmVudGx5IGEgc2NyaXB0IGxvYWRpbmcuIFRoaXMgaGVscHMgZW5zdXJlIHRoYXQgb25seSBhIHNpbmdsZSBzY3JpcHQgbG9hZHMgYXQgb25jZSB3aGVuXG5cdFx0ICogdXNpbmcgYSBzY3JpcHQgdGFnIHRvIGRvIHByZWxvYWRpbmcuXG5cdFx0ICogQHByb3BlcnR5IF9jdXJyZW50bHlMb2FkaW5nU2NyaXB0XG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9jdXJyZW50bHlMb2FkaW5nU2NyaXB0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGN1cnJlbnRseSBkb3dubG9hZGluZyBmaWxlcy5cblx0XHQgKiBAcHJvcGVydHkgX2N1cnJlbnRMb2Fkc1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2N1cnJlbnRMb2FkcyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgY29udGFpbmluZyB0aGUgcXVldWVkIGl0ZW1zIHRoYXQgaGF2ZSBub3QgeWV0IHN0YXJ0ZWQgZG93bmxvYWRpbmcuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkUXVldWVcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkUXVldWUgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IGNvbnRhaW5pbmcgZG93bmxvYWRzIHRoYXQgaGF2ZSBub3QgY29tcGxldGVkLCBzbyB0aGF0IHRoZSBMb2FkUXVldWUgY2FuIGJlIHByb3Blcmx5IHJlc2V0LlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZFF1ZXVlQmFja3VwXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZFF1ZXVlQmFja3VwID0gW107XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiBpdGVtcyB0aGF0IGhhdmUgZmluaXNoZWQgZG93bmxvYWRpbmcsIGluZGV4ZWQgYnkgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogaWQuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkSXRlbXNCeUlkXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRJdGVtc0J5SWQgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBoYXNoIG9mIGl0ZW1zIHRoYXQgaGF2ZSBmaW5pc2hlZCBkb3dubG9hZGluZywgaW5kZXhlZCBieSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIHNvdXJjZS5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRJdGVtc0J5U3JjXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRJdGVtc0J5U3JjID0ge307XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiBsb2FkZWQgaXRlbXMsIGluZGV4ZWQgYnkgdGhlIElEIG9mIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRlZFJlc3VsdHNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZGVkUmVzdWx0cyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IGhhc2ggb2YgdW4tcGFyc2VkIGxvYWRlZCBpdGVtcywgaW5kZXhlZCBieSB0aGUgSUQgb2YgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZGVkUmF3UmVzdWx0c1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkZWRSYXdSZXN1bHRzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRoYXQgaGF2ZSBiZWVuIHJlcXVlc3RlZC4gVGhpcyBoZWxwcyBtYW5hZ2UgYW4gb3ZlcmFsbCBwcm9ncmVzcyB3aXRob3V0IGtub3dpbmcgaG93IGxhcmdlXG5cdFx0ICogdGhlIGZpbGVzIGFyZSBiZWZvcmUgdGhleSBhcmUgZG93bmxvYWRlZC4gVGhpcyBkb2VzIG5vdCBpbmNsdWRlIGl0ZW1zIGluc2lkZSBvZiBsb2FkZXJzIHN1Y2ggYXMgdGhlXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IF9udW1JdGVtc1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbnVtSXRlbXMgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBpdGVtcyB0aGF0IGhhdmUgY29tcGxldGVkIGxvYWRlZC4gVGhpcyBoZWxwcyBtYW5hZ2UgYW4gb3ZlcmFsbCBwcm9ncmVzcyB3aXRob3V0IGtub3dpbmcgaG93IGxhcmdlXG5cdFx0ICogdGhlIGZpbGVzIGFyZSBiZWZvcmUgdGhleSBhcmUgZG93bmxvYWRlZC5cblx0XHQgKiBAcHJvcGVydHkgX251bUl0ZW1zTG9hZGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9udW1JdGVtc0xvYWRlZCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBBIGxpc3Qgb2Ygc2NyaXB0cyBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIHJlcXVlc3RlZC4gVGhpcyBoZWxwcyBlbnN1cmUgdGhhdCBzY3JpcHRzIGFyZSBcImNvbXBsZXRlZFwiIGluIHRoZSByaWdodFxuXHRcdCAqIG9yZGVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBfc2NyaXB0T3JkZXJcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9zY3JpcHRPcmRlciA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBsaXN0IG9mIHNjcmlwdHMgdGhhdCBoYXZlIGJlZW4gbG9hZGVkLiBJdGVtcyBhcmUgYWRkZWQgdG8gdGhpcyBsaXN0IGFzIDxjb2RlPm51bGw8L2NvZGU+IHdoZW4gdGhleSBhcmVcblx0XHQgKiByZXF1ZXN0ZWQsIGNvbnRhaW4gdGhlIGxvYWRlZCBpdGVtIGlmIGl0IGhhcyBjb21wbGV0ZWQsIGJ1dCBub3QgYmVlbiBkaXNwYXRjaGVkIHRvIHRoZSB1c2VyLCBhbmQgPGNvZGU+dHJ1ZTwvdHJ1ZT5cblx0XHQgKiBvbmNlIHRoZXkgYXJlIGNvbXBsZXRlIGFuZCBoYXZlIGJlZW4gZGlzcGF0Y2hlZC5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRlZFNjcmlwdHNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkZWRTY3JpcHRzID0gW107XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGFzdCBwcm9ncmVzcyBhbW91bnQuIFRoaXMgaXMgdXNlZCB0byBzdXBwcmVzcyBkdXBsaWNhdGUgcHJvZ3Jlc3MgZXZlbnRzLlxuXHRcdCAqIEBwcm9wZXJ0eSBfbGFzdFByb2dyZXNzXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBzaW5jZSAwLjYuMFxuXHRcdCAqL1xuXHRcdHRoaXMuX2xhc3RQcm9ncmVzcyA9IE5hTjtcblxuXHR9O1xuXG4vLyBzdGF0aWMgcHJvcGVydGllc1xuXHQvKipcblx0ICogVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIGFzc3VtZSBhIGxvYWQgaGFzIGZhaWxlZC4gQW4ge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvZXJyb3I6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgaXMgZGlzcGF0Y2hlZCBpZiB0aGUgdGltZW91dCBpcyByZWFjaGVkIGJlZm9yZSBhbnkgZGF0YSBpcyByZWNlaXZlZC5cblx0ICogQHByb3BlcnR5IGxvYWRUaW1lb3V0XG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDgwMDBcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC40LjFcblx0ICogQGRlcHJlY2F0ZWQgSW4gZmF2b3VyIG9mIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL0xPQURfVElNRU9VVF9ERUZBVUxUOnByb3BlcnR5fX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eS5cblx0ICovXG5cdHMubG9hZFRpbWVvdXQgPSA4MDAwO1xuXG5cdC8qKlxuXHQgKiBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gYXNzdW1lIGEgbG9hZCBoYXMgZmFpbGVkLlxuXHQgKiBAcHJvcGVydHkgTE9BRF9USU1FT1VUXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDBcblx0ICogQGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkVGltZW91dDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eS5cblx0ICovXG5cdHMuTE9BRF9USU1FT1VUID0gMDtcblxuLy8gUHJlbG9hZCBUeXBlc1xuXHQvKipcblx0ICogQHByb3BlcnR5IEJJTkFSWVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBiaW5hcnlcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0JJTkFSWTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5CSU5BUlkgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5CSU5BUlk7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBDU1Ncblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgY3NzXG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9DU1M6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuQ1NTID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuQ1NTO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgSU1BR0Vcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgaW1hZ2Vcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0NTUzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5JTUFHRSA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLklNQUdFO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgSkFWQVNDUklQVFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBqYXZhc2NyaXB0XG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KQVZBU0NSSVBUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLkpBVkFTQ1JJUFQgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KQVZBU0NSSVBUO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgSlNPTlxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBqc29uXG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KU09OOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLkpTT04gPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KU09OO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgSlNPTlBcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQganNvbnBcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pTT05QOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLkpTT05QID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTlA7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBNQU5JRkVTVFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBtYW5pZmVzdFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL01BTklGRVNUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLk1BTklGRVNUID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuTUFOSUZFU1Q7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBTT1VORFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBzb3VuZFxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSkFWQVNDUklQVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5TT1VORCA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNPVU5EO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgVklERU9cblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgdmlkZW9cblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pBVkFTQ1JJUFQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuVklERU8gPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5WSURFTztcblxuXHQvKipcblx0ICogQHByb3BlcnR5IFNWR1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBzdmdcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1NWRzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5TVkcgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TVkc7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBURVhUXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHRleHRcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1RFWFQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuVEVYVCA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlRFWFQ7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBYTUxcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgeG1sXG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9YTUw6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuWE1MID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuWE1MO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgUE9TVFxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1BPU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuUE9TVCA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlBPU1Q7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBHRVRcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9HRVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuR0VUID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuR0VUO1xuXG4vLyBldmVudHNcblx0LyoqXG5cdCAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhbiBpbmRpdmlkdWFsIGZpbGUgaGFzIGxvYWRlZCwgYW5kIGJlZW4gcHJvY2Vzc2VkLlxuXHQgKiBAZXZlbnQgZmlsZWxvYWRcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBUaGUgZmlsZSBpdGVtIHdoaWNoIHdhcyBzcGVjaWZpZWQgaW4gdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvciB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319IGNhbGwuIElmIG9ubHkgYSBzdHJpbmcgcGF0aCBvciB0YWcgd2FzIHNwZWNpZmllZCwgdGhlXG5cdCAqIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhhdCB2YWx1ZSBhcyBhIGBzcmNgIHByb3BlcnR5LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0IFRoZSBIVE1MIHRhZyBvciBwYXJzZWQgcmVzdWx0IG9mIHRoZSBsb2FkZWQgaXRlbS5cblx0ICogQHBhcmFtIHtPYmplY3R9IHJhd1Jlc3VsdCBUaGUgdW5wcm9jZXNzZWQgcmVzdWx0LCB1c3VhbGx5IHRoZSByYXcgdGV4dCBvciBiaW5hcnkgZGF0YSBiZWZvcmUgaXQgaXMgY29udmVydGVkXG5cdCAqIHRvIGEgdXNhYmxlIG9iamVjdC5cblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGlzIHt7I2Nyb3NzTGluayBcIlByb2dyZXNzRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIGFuIGFuIGluZGl2aWR1YWwgZmlsZSdzIHByb2dyZXNzIGNoYW5nZXMuXG5cdCAqIEBldmVudCBmaWxlcHJvZ3Jlc3Ncblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gYW4gaW5kaXZpZHVhbCBmaWxlIHN0YXJ0cyB0byBsb2FkLlxuXHQgKiBAZXZlbnQgZmlsZXN0YXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBUaGUgZmlsZSBpdGVtIHdoaWNoIHdhcyBzcGVjaWZpZWQgaW4gdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvciB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319IGNhbGwuIElmIG9ubHkgYSBzdHJpbmcgcGF0aCBvciB0YWcgd2FzIHNwZWNpZmllZCwgdGhlXG5cdCAqIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhhdCB2YWx1ZSBhcyBhIHByb3BlcnR5LlxuXHQgKi9cblxuLy8gcHVibGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIFJlZ2lzdGVyIGEgY3VzdG9tIGxvYWRlcnMgY2xhc3MuIE5ldyBsb2FkZXJzIGFyZSBnaXZlbiBwcmVjZWRlbmNlIG92ZXIgbG9hZGVycyBhZGRlZCBlYXJsaWVyIGFuZCBkZWZhdWx0IGxvYWRlcnMuXG5cdCAqIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgbG9hZGVycyBleHRlbmQge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uIExvYWRlcnMgY2FuIG9ubHkgYmUgYWRkZWRcblx0ICogb25jZSwgYW5kIHdpbGwgYmUgcHJlcGVuZGVkIHRvIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSBsb2FkZXJzLlxuXHQgKiBAbWV0aG9kIHJlZ2lzdGVyTG9hZGVyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb258QWJzdHJhY3RMb2FkZXJ9IGxvYWRlciBUaGUgQWJzdHJhY3RMb2FkZXIgY2xhc3MgdG8gYWRkLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAucmVnaXN0ZXJMb2FkZXIgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0aWYgKCFsb2FkZXIgfHwgIWxvYWRlci5jYW5Mb2FkSXRlbSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibG9hZGVyIGlzIG9mIGFuIGluY29ycmVjdCB0eXBlLlwiKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuX2F2YWlsYWJsZUxvYWRlcnMuaW5kZXhPZihsb2FkZXIpICE9IC0xKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJsb2FkZXIgYWxyZWFkeSBleGlzdHMuXCIpOyAvL0xNOiBNYXliZSBqdXN0IHNpbGVudGx5IGZhaWwgaGVyZVxuXHRcdH1cblxuXHRcdHRoaXMuX2F2YWlsYWJsZUxvYWRlcnMudW5zaGlmdChsb2FkZXIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYSBjdXN0b20gbG9hZGVyIGFkZGVkIHVzaWcge3sjY3Jvc3NMaW5rIFwicmVnaXN0ZXJMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uIE9ubHkgY3VzdG9tIGxvYWRlcnMgY2FuIGJlXG5cdCAqIHVucmVnaXN0ZXJlZCwgdGhlIGRlZmF1bHQgbG9hZGVycyB3aWxsIGFsd2F5cyBiZSBhdmFpbGFibGUuXG5cdCAqIEBtZXRob2QgdW5yZWdpc3RlckxvYWRlclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufEFic3RyYWN0TG9hZGVyfSBsb2FkZXIgVGhlIEFic3RyYWN0TG9hZGVyIGNsYXNzIHRvIHJlbW92ZVxuXHQgKi9cblx0cC51bnJlZ2lzdGVyTG9hZGVyID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdHZhciBpZHggPSB0aGlzLl9hdmFpbGFibGVMb2FkZXJzLmluZGV4T2YobG9hZGVyKTtcblx0XHRpZiAoaWR4ICE9IC0xICYmIGlkeCA8IHRoaXMuX2RlZmF1bHRMb2FkZXJMZW5ndGggLSAxKSB7XG5cdFx0XHR0aGlzLl9hdmFpbGFibGVMb2FkZXJzLnNwbGljZShpZHgsIDEpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBzZXRVc2VYSFJcblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBUaGUgbmV3IHVzZVhIUiB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBuZXcgdXNlWEhSIHZhbHVlLiBJZiBYSFIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYnJvd3NlciwgdGhpcyB3aWxsIHJldHVybiBmYWxzZSwgZXZlbiBpZlxuXHQgKiB0aGUgcHJvdmlkZWQgdmFsdWUgYXJndW1lbnQgd2FzIHRydWUuXG5cdCAqIEBzaW5jZSAwLjMuMFxuXHQgKiBAZGVwcmVjYXRlZCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcInByZWZlclhIUjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSwgb3IgdGhlIHt7I2Nyb3NzTGluayBcInNldFVzZVhIUlwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QgaW5zdGVhZC5cblx0ICovXG5cdHAuc2V0VXNlWEhSID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0UHJlZmVyWEhSKHZhbHVlKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2hhbmdlIHRoZSB7eyNjcm9zc0xpbmsgXCJwcmVmZXJYSFI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gdmFsdWUuIE5vdGUgdGhhdCBpZiB0aGlzIGlzIHNldCB0byBgdHJ1ZWAsIGl0IG1heVxuXHQgKiBmYWlsLCBvciBiZSBpZ25vcmVkIGRlcGVuZGluZyBvbiB0aGUgYnJvd3NlcidzIGNhcGFiaWxpdGllcyBhbmQgdGhlIGxvYWQgdHlwZS5cblx0ICogQG1ldGhvZCBzZXRQcmVmZXJYSFJcblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVGhlIHZhbHVlIG9mIHt7I2Nyb3NzTGluayBcInByZWZlclhIUlwifX17ey9jcm9zc0xpbmt9fSB0aGF0IHdhcyBzdWNjZXNzZnVsbHkgc2V0LlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuc2V0UHJlZmVyWEhSID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHdlIGNhbiB1c2UgWEhSLiBYSFIgZGVmYXVsdHMgdG8gVFJVRSwgYnV0IHRoZSBicm93c2VyIG1heSBub3Qgc3VwcG9ydCBpdC5cblx0XHQvL1RPRE86IFNob3VsZCB3ZSBiZSBjaGVja2luZyBmb3IgdGhlIG90aGVyIFhIUiB0eXBlcz8gTWlnaHQgaGF2ZSB0byBkbyBhIHRyeS9jYXRjaCBvbiB0aGUgZGlmZmVyZW50IHR5cGVzIHNpbWlsYXIgdG8gY3JlYXRlWEhSLlxuXHRcdHRoaXMucHJlZmVyWEhSID0gKHZhbHVlICE9IGZhbHNlICYmIHdpbmRvdy5YTUxIdHRwUmVxdWVzdCAhPSBudWxsKTtcblx0XHRyZXR1cm4gdGhpcy5wcmVmZXJYSFI7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3BzIGFsbCBxdWV1ZWQgYW5kIGxvYWRpbmcgaXRlbXMsIGFuZCBjbGVhcnMgdGhlIHF1ZXVlLiBUaGlzIGFsc28gcmVtb3ZlcyBhbGwgaW50ZXJuYWwgcmVmZXJlbmNlcyB0byBsb2FkZWRcblx0ICogY29udGVudCwgYW5kIGFsbG93cyB0aGUgcXVldWUgdG8gYmUgdXNlZCBhZ2Fpbi5cblx0ICogQG1ldGhvZCByZW1vdmVBbGxcblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXHRwLnJlbW92ZUFsbCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnJlbW92ZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9wcyBhbiBpdGVtIGZyb20gYmVpbmcgbG9hZGVkLCBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBxdWV1ZS4gSWYgbm90aGluZyBpcyBwYXNzZWQsIGFsbCBpdGVtcyBhcmUgcmVtb3ZlZC5cblx0ICogVGhpcyBhbHNvIHJlbW92ZXMgaW50ZXJuYWwgcmVmZXJlbmNlcyB0byBsb2FkZWQgaXRlbShzKS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHF1ZXVlLmxvYWRNYW5pZmVzdChbXG5cdCAqICAgICAgICAgIHtzcmM6XCJ0ZXN0LnBuZ1wiLCBpZDpcInBuZ1wifSxcblx0ICogICAgICAgICAge3NyYzpcInRlc3QuanBnXCIsIGlkOlwianBnXCJ9LFxuXHQgKiAgICAgICAgICB7c3JjOlwidGVzdC5tcDNcIiwgaWQ6XCJtcDNcIn1cblx0ICogICAgICBdKTtcblx0ICogICAgICBxdWV1ZS5yZW1vdmUoXCJwbmdcIik7IC8vIFNpbmdsZSBpdGVtIGJ5IElEXG5cdCAqICAgICAgcXVldWUucmVtb3ZlKFwicG5nXCIsIFwidGVzdC5qcGdcIik7IC8vIEl0ZW1zIGFzIGFyZ3VtZW50cy4gTWl4ZWQgaWQgYW5kIHNyYy5cblx0ICogICAgICBxdWV1ZS5yZW1vdmUoW1widGVzdC5wbmdcIiwgXCJqcGdcIl0pOyAvLyBJdGVtcyBpbiBhbiBBcnJheS4gTWl4ZWQgaWQgYW5kIHNyYy5cblx0ICpcblx0ICogQG1ldGhvZCByZW1vdmVcblx0ICogQHBhcmFtIHtTdHJpbmcgfCBBcnJheX0gaWRzT3JVcmxzKiBUaGUgaWQgb3IgaWRzIHRvIHJlbW92ZSBmcm9tIHRoaXMgcXVldWUuIFlvdSBjYW4gcGFzcyBhbiBpdGVtLCBhbiBhcnJheSBvZlxuXHQgKiBpdGVtcywgb3IgbXVsdGlwbGUgaXRlbXMgYXMgYXJndW1lbnRzLlxuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cdHAucmVtb3ZlID0gZnVuY3Rpb24gKGlkc09yVXJscykge1xuXHRcdHZhciBhcmdzID0gbnVsbDtcblxuXHRcdGlmIChpZHNPclVybHMgJiYgIShpZHNPclVybHMgaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0XHRcdGFyZ3MgPSBbaWRzT3JVcmxzXTtcblx0XHR9IGVsc2UgaWYgKGlkc09yVXJscykge1xuXHRcdFx0YXJncyA9IGlkc09yVXJscztcblx0XHR9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGl0ZW1zV2VyZVJlbW92ZWQgPSBmYWxzZTtcblxuXHRcdC8vIERlc3Ryb3kgZXZlcnl0aGluZ1xuXHRcdGlmICghYXJncykge1xuXHRcdFx0dGhpcy5jbG9zZSgpO1xuXHRcdFx0Zm9yICh2YXIgbiBpbiB0aGlzLl9sb2FkSXRlbXNCeUlkKSB7XG5cdFx0XHRcdHRoaXMuX2Rpc3Bvc2VJdGVtKHRoaXMuX2xvYWRJdGVtc0J5SWRbbl0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5pbml0KHRoaXMucHJlZmVyWEhSLCB0aGlzLl9iYXNlUGF0aCk7XG5cblx0XHRcdC8vIFJlbW92ZSBzcGVjaWZpYyBpdGVtc1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aGlsZSAoYXJncy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSBhcmdzLnBvcCgpO1xuXHRcdFx0XHR2YXIgciA9IHRoaXMuZ2V0UmVzdWx0KGl0ZW0pO1xuXG5cdFx0XHRcdC8vUmVtb3ZlIGZyb20gdGhlIG1haW4gbG9hZCBRdWV1ZVxuXHRcdFx0XHRmb3IgKGkgPSB0aGlzLl9sb2FkUXVldWUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRsb2FkSXRlbSA9IHRoaXMuX2xvYWRRdWV1ZVtpXS5nZXRJdGVtKCk7XG5cdFx0XHRcdFx0aWYgKGxvYWRJdGVtLmlkID09IGl0ZW0gfHwgbG9hZEl0ZW0uc3JjID09IGl0ZW0pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2xvYWRRdWV1ZS5zcGxpY2UoaSwgMSlbMF0uY2FuY2VsKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL1JlbW92ZSBmcm9tIHRoZSBiYWNrdXAgcXVldWVcblx0XHRcdFx0Zm9yIChpID0gdGhpcy5fbG9hZFF1ZXVlQmFja3VwLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0bG9hZEl0ZW0gPSB0aGlzLl9sb2FkUXVldWVCYWNrdXBbaV0uZ2V0SXRlbSgpO1xuXHRcdFx0XHRcdGlmIChsb2FkSXRlbS5pZCA9PSBpdGVtIHx8IGxvYWRJdGVtLnNyYyA9PSBpdGVtKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9sb2FkUXVldWVCYWNrdXAuc3BsaWNlKGksIDEpWzBdLmNhbmNlbCgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHIpIHtcblx0XHRcdFx0XHR0aGlzLl9kaXNwb3NlSXRlbSh0aGlzLmdldEl0ZW0oaXRlbSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSB0aGlzLl9jdXJyZW50TG9hZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRcdHZhciBsb2FkSXRlbSA9IHRoaXMuX2N1cnJlbnRMb2Fkc1tpXS5nZXRJdGVtKCk7XG5cdFx0XHRcdFx0XHRpZiAobG9hZEl0ZW0uaWQgPT0gaXRlbSB8fCBsb2FkSXRlbS5zcmMgPT0gaXRlbSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9jdXJyZW50TG9hZHMuc3BsaWNlKGksIDEpWzBdLmNhbmNlbCgpO1xuXHRcdFx0XHRcdFx0XHRpdGVtc1dlcmVSZW1vdmVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGNhbGxlZCBkdXJpbmcgYSBsb2FkLCB0cnkgdG8gbG9hZCB0aGUgbmV4dCBpdGVtLlxuXHRcdFx0aWYgKGl0ZW1zV2VyZVJlbW92ZWQpIHtcblx0XHRcdFx0dGhpcy5fbG9hZE5leHQoKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3BzIGFsbCBvcGVuIGxvYWRzLCBkZXN0cm95cyBhbnkgbG9hZGVkIGl0ZW1zLCBhbmQgcmVzZXRzIHRoZSBxdWV1ZSwgc28gYWxsIGl0ZW1zIGNhblxuXHQgKiBiZSByZWxvYWRlZCBhZ2FpbiBieSBjYWxsaW5nIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2xvYWRcIn19e3svY3Jvc3NMaW5rfX0uIEl0ZW1zIGFyZSBub3QgcmVtb3ZlZCBmcm9tIHRoZVxuXHQgKiBxdWV1ZS4gVG8gcmVtb3ZlIGl0ZW1zIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3JlbW92ZVwifX17ey9jcm9zc0xpbmt9fSBvclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvcmVtb3ZlQWxsXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblx0ICogQG1ldGhvZCByZXNldFxuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cdHAucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5jbG9zZSgpO1xuXHRcdGZvciAodmFyIG4gaW4gdGhpcy5fbG9hZEl0ZW1zQnlJZCkge1xuXHRcdFx0dGhpcy5fZGlzcG9zZUl0ZW0odGhpcy5fbG9hZEl0ZW1zQnlJZFtuXSk7XG5cdFx0fVxuXG5cdFx0Ly9SZXNldCB0aGUgcXVldWUgdG8gaXRzIHN0YXJ0IHN0YXRlXG5cdFx0dmFyIGEgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2xvYWRRdWV1ZUJhY2t1cC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGEucHVzaCh0aGlzLl9sb2FkUXVldWVCYWNrdXBbaV0uZ2V0SXRlbSgpKTtcblx0XHR9XG5cblx0XHR0aGlzLmxvYWRNYW5pZmVzdChhLCBmYWxzZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVyIGEgcGx1Z2luLiBQbHVnaW5zIGNhbiBtYXAgdG8gbG9hZCB0eXBlcyAoc291bmQsIGltYWdlLCBldGMpLCBvciBzcGVjaWZpYyBleHRlbnNpb25zIChwbmcsIG1wMywgZXRjKS5cblx0ICogQ3VycmVudGx5LCBvbmx5IG9uZSBwbHVnaW4gY2FuIGV4aXN0IHBlciB0eXBlL2V4dGVuc2lvbi5cblx0ICpcblx0ICogV2hlbiBhIHBsdWdpbiBpcyBpbnN0YWxsZWQsIGEgPGNvZGU+Z2V0UHJlbG9hZEhhbmRsZXJzKCk8L2NvZGU+IG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBvbiBpdC4gRm9yIG1vcmUgaW5mb3JtYXRpb25cblx0ICogb24gdGhpcyBtZXRob2QsIGNoZWNrIG91dCB0aGUge3sjY3Jvc3NMaW5rIFwiU2FtcGxlUGx1Z2luL2dldFByZWxvYWRIYW5kbGVyc1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgaW4gdGhlXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNhbXBsZVBsdWdpblwifX17ey9jcm9zc0xpbmt9fSBjbGFzcy5cblx0ICpcblx0ICogQmVmb3JlIGEgZmlsZSBpcyBsb2FkZWQsIGEgbWF0Y2hpbmcgcGx1Z2luIGhhcyBhbiBvcHBvcnR1bml0eSB0byBtb2RpZnkgdGhlIGxvYWQuIElmIGEgYGNhbGxiYWNrYCBpcyByZXR1cm5lZFxuXHQgKiBmcm9tIHRoZSB7eyNjcm9zc0xpbmsgXCJTYW1wbGVQbHVnaW4vZ2V0UHJlbG9hZEhhbmRsZXJzXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCwgaXQgd2lsbCBiZSBpbnZva2VkIGZpcnN0LCBhbmQgaXRzXG5cdCAqIHJlc3VsdCBtYXkgY2FuY2VsIG9yIG1vZGlmeSB0aGUgaXRlbS4gVGhlIGNhbGxiYWNrIG1ldGhvZCBjYW4gYWxzbyByZXR1cm4gYSBgY29tcGxldGVIYW5kbGVyYCB0byBiZSBmaXJlZCB3aGVuXG5cdCAqIHRoZSBmaWxlIGlzIGxvYWRlZCwgb3IgYSBgdGFnYCBvYmplY3QsIHdoaWNoIHdpbGwgbWFuYWdlIHRoZSBhY3R1YWwgZG93bmxvYWQuIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlXG5cdCAqIG1ldGhvZHMsIGNoZWNrIG91dCB0aGUge3sjY3Jvc3NMaW5rIFwiU2FtcGxlUGx1Z2luL3ByZWxvYWRIYW5kbGVyXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJTYW1wbGVQbHVnaW4vZmlsZUxvYWRIYW5kbGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZHMgb24gdGhlIHt7I2Nyb3NzTGluayBcIlNhbXBsZVBsdWdpblwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogQG1ldGhvZCBpbnN0YWxsUGx1Z2luXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHBsdWdpbiBUaGUgcGx1Z2luIGNsYXNzIHRvIGluc3RhbGwuXG5cdCAqL1xuXHRwLmluc3RhbGxQbHVnaW4gPSBmdW5jdGlvbiAocGx1Z2luKSB7XG5cdFx0aWYgKHBsdWdpbiA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHBsdWdpbi5nZXRQcmVsb2FkSGFuZGxlcnMgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fcGx1Z2lucy5wdXNoKHBsdWdpbik7XG5cdFx0XHR2YXIgbWFwID0gcGx1Z2luLmdldFByZWxvYWRIYW5kbGVycygpO1xuXHRcdFx0bWFwLnNjb3BlID0gcGx1Z2luO1xuXG5cdFx0XHRpZiAobWFwLnR5cGVzICE9IG51bGwpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBtYXAudHlwZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5fdHlwZUNhbGxiYWNrc1ttYXAudHlwZXNbaV1dID0gbWFwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXAuZXh0ZW5zaW9ucyAhPSBudWxsKSB7XG5cdFx0XHRcdGZvciAoaSA9IDAsIGwgPSBtYXAuZXh0ZW5zaW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR0aGlzLl9leHRlbnNpb25DYWxsYmFja3NbbWFwLmV4dGVuc2lvbnNbaV1dID0gbWFwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbmN1cnJlbnQgY29ubmVjdGlvbnMuIE5vdGUgdGhhdCBicm93c2VycyBhbmQgc2VydmVycyBtYXkgaGF2ZSBhIGJ1aWx0LWluIG1heGltdW1cblx0ICogbnVtYmVyIG9mIG9wZW4gY29ubmVjdGlvbnMsIHNvIGFueSBhZGRpdGlvbmFsIGNvbm5lY3Rpb25zIG1heSByZW1haW4gaW4gYSBwZW5kaW5nIHN0YXRlIHVudGlsIHRoZSBicm93c2VyXG5cdCAqIG9wZW5zIHRoZSBjb25uZWN0aW9uLiBXaGVuIGxvYWRpbmcgc2NyaXB0cyB1c2luZyB0YWdzLCBhbmQgd2hlbiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbWFpbnRhaW5TY3JpcHRPcmRlcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpcyBgdHJ1ZWAsIG9ubHkgb25lIHNjcmlwdCBpcyBsb2FkZWQgYXQgYSB0aW1lIGR1ZSB0byBicm93c2VyIGxpbWl0YXRpb25zLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIHF1ZXVlID0gbmV3IGNyZWF0ZWpzLkxvYWRRdWV1ZSgpO1xuXHQgKiAgICAgIHF1ZXVlLnNldE1heENvbm5lY3Rpb25zKDEwKTsgLy8gQWxsb3cgMTAgY29uY3VycmVudCBsb2Fkc1xuXHQgKlxuXHQgKiBAbWV0aG9kIHNldE1heENvbm5lY3Rpb25zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgbG9hZHMgdG8gYWxsb3cuIEJ5IGRlZmF1bHQsIG9ubHkgYSBzaW5nbGUgY29ubmVjdGlvbiBwZXIgTG9hZFF1ZXVlXG5cdCAqIGlzIG9wZW4gYXQgYW55IHRpbWUuXG5cdCAqL1xuXHRwLnNldE1heENvbm5lY3Rpb25zID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dGhpcy5fbWF4Q29ubmVjdGlvbnMgPSB2YWx1ZTtcblx0XHRpZiAoIXRoaXMuX3BhdXNlZCAmJiB0aGlzLl9sb2FkUXVldWUubGVuZ3RoID4gMCkge1xuXHRcdFx0dGhpcy5fbG9hZE5leHQoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIExvYWQgYSBzaW5nbGUgZmlsZS4gVG8gYWRkIG11bHRpcGxlIGZpbGVzIGF0IG9uY2UsIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuXG5cdCAqXG5cdCAqIEZpbGVzIGFyZSBhbHdheXMgYXBwZW5kZWQgdG8gdGhlIGN1cnJlbnQgcXVldWUsIHNvIHRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIG11bHRpcGxlIHRpbWVzIHRvIGFkZCBmaWxlcy5cblx0ICogVG8gY2xlYXIgdGhlIHF1ZXVlIGZpcnN0LCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2Nsb3NlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblx0ICogQG1ldGhvZCBsb2FkRmlsZVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdHxTdHJpbmd9IGZpbGUgVGhlIGZpbGUgb2JqZWN0IG9yIHBhdGggdG8gbG9hZC4gQSBmaWxlIGNhbiBiZSBlaXRoZXJcblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPkEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2U8L2xpPlxuXHQgKiAgICAgPGxpPkFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgZGVmaW5lZCBieSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fTwvbGk+XG5cdCAqICAgICA8bGk+T1IgQSBzdHJpbmcgcGF0aCB0byBhIHJlc291cmNlLiBOb3RlIHRoYXQgdGhpcyBraW5kIG9mIGxvYWQgaXRlbSB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqICAgICBpbiB0aGUgYmFja2dyb3VuZC48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtsb2FkTm93PXRydWVdIEtpY2sgb2ZmIGFuIGltbWVkaWF0ZSBsb2FkICh0cnVlKSBvciB3YWl0IGZvciBhIGxvYWQgY2FsbCAoZmFsc2UpLiBUaGUgZGVmYXVsdFxuXHQgKiB2YWx1ZSBpcyB0cnVlLiBJZiB0aGUgcXVldWUgaXMgcGF1c2VkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRQYXVzZWRcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCB0aGUgdmFsdWUgaXNcblx0ICogYHRydWVgLCB0aGUgcXVldWUgd2lsbCByZXN1bWUgYXV0b21hdGljYWxseS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtiYXNlUGF0aF0gQSBiYXNlIHBhdGggdGhhdCB3aWxsIGJlIHByZXBlbmRlZCB0byBlYWNoIGZpbGUuIFRoZSBiYXNlUGF0aCBhcmd1bWVudCBvdmVycmlkZXMgdGhlXG5cdCAqIHBhdGggc3BlY2lmaWVkIGluIHRoZSBjb25zdHJ1Y3Rvci4gTm90ZSB0aGF0IGlmIHlvdSBsb2FkIGEgbWFuaWZlc3QgdXNpbmcgYSBmaWxlIG9mIHR5cGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvTUFOSUZFU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIGl0cyBmaWxlcyB3aWxsIDxzdHJvbmc+Tk9UPC9zdHJvbmc+IHVzZSB0aGUgYmFzZVBhdGggcGFyYW1ldGVyLiA8c3Ryb25nPlRoZSBiYXNlUGF0aCBwYXJhbWV0ZXIgaXMgZGVwcmVjYXRlZC48L3N0cm9uZz5cblx0ICogVGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uIFBsZWFzZSBlaXRoZXIgdXNlIHRoZSBgYmFzZVBhdGhgIHBhcmFtZXRlciBpbiB0aGUgTG9hZFF1ZXVlXG5cdCAqIGNvbnN0cnVjdG9yLCBvciBhIGBwYXRoYCBwcm9wZXJ0eSBpbiBhIG1hbmlmZXN0IGRlZmluaXRpb24uXG5cdCAqL1xuXHRwLmxvYWRGaWxlID0gZnVuY3Rpb24gKGZpbGUsIGxvYWROb3csIGJhc2VQYXRoKSB7XG5cdFx0aWYgKGZpbGUgPT0gbnVsbCkge1xuXHRcdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJQUkVMT0FEX05PX0ZJTEVcIik7XG5cdFx0XHR0aGlzLl9zZW5kRXJyb3IoZXZlbnQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9hZGRJdGVtKGZpbGUsIG51bGwsIGJhc2VQYXRoKTtcblxuXHRcdGlmIChsb2FkTm93ICE9PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5zZXRQYXVzZWQoZmFsc2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNldFBhdXNlZCh0cnVlKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIExvYWQgYW4gYXJyYXkgb2YgZmlsZXMuIFRvIGxvYWQgYSBzaW5nbGUgZmlsZSwgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXHQgKiBUaGUgZmlsZXMgaW4gdGhlIG1hbmlmZXN0IGFyZSByZXF1ZXN0ZWQgaW4gdGhlIHNhbWUgb3JkZXIsIGJ1dCBtYXkgY29tcGxldGUgaW4gYSBkaWZmZXJlbnQgb3JkZXIgaWYgdGhlIG1heFxuXHQgKiBjb25uZWN0aW9ucyBhcmUgc2V0IGFib3ZlIDEgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldE1heENvbm5lY3Rpb25zXCJ9fXt7L2Nyb3NzTGlua319LiBTY3JpcHRzIHdpbGwgbG9hZFxuXHQgKiBpbiB0aGUgcmlnaHQgb3JkZXIgYXMgbG9uZyBhcyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbWFpbnRhaW5TY3JpcHRPcmRlclwifX17ey9jcm9zc0xpbmt9fSBpcyB0cnVlICh3aGljaCBpc1xuXHQgKiBkZWZhdWx0KS5cblx0ICpcblx0ICogRmlsZXMgYXJlIGFsd2F5cyBhcHBlbmRlZCB0byB0aGUgY3VycmVudCBxdWV1ZSwgc28gdGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgbXVsdGlwbGUgdGltZXMgdG8gYWRkIGZpbGVzLlxuXHQgKiBUbyBjbGVhciB0aGUgcXVldWUgZmlyc3QsIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvY2xvc2VcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXHQgKiBAbWV0aG9kIGxvYWRNYW5pZmVzdFxuXHQgKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xPYmplY3R9IG1hbmlmZXN0IEFuIGxpc3Qgb2YgZmlsZXMgdG8gbG9hZC4gVGhlIGxvYWRNYW5pZmVzdCBjYWxsIHN1cHBvcnRzIGZvdXIgdHlwZXMgb2Zcblx0ICogbWFuaWZlc3RzOlxuXHQgKiA8b2w+XG5cdCAqICAgICA8bGk+QSBzdHJpbmcgcGF0aCwgd2hpY2ggcG9pbnRzIHRvIGEgbWFuaWZlc3QgZmlsZSwgd2hpY2ggaXMgYSBKU09OIGZpbGUgdGhhdCBjb250YWlucyBhIFwibWFuaWZlc3RcIiBwcm9wZXJ0eSxcblx0ICogICAgIHdoaWNoIGRlZmluZXMgdGhlIGxpc3Qgb2YgZmlsZXMgdG8gbG9hZCwgYW5kIGNhbiBvcHRpb25hbGx5IGNvbnRhaW4gYSBcInBhdGhcIiBwcm9wZXJ0eSwgd2hpY2ggd2lsbCBiZVxuXHQgKiAgICAgcHJlcGVuZGVkIHRvIGVhY2ggZmlsZSBpbiB0aGUgbGlzdC48L2xpPlxuXHQgKiAgICAgPGxpPkFuIG9iamVjdCB3aGljaCBkZWZpbmVzIGEgXCJzcmNcIiwgd2hpY2ggaXMgYSBKU09OIG9yIEpTT05QIGZpbGUuIEEgXCJjYWxsYmFja1wiIGNhbiBiZSBkZWZpbmVkIGZvciBKU09OUFxuXHQgKiAgICAgZmlsZS4gVGhlIEpTT04vSlNPTlAgZmlsZSBzaG91bGQgY29udGFpbiBhIFwibWFuaWZlc3RcIiBwcm9wZXJ0eSwgd2hpY2ggZGVmaW5lcyB0aGUgbGlzdCBvZiBmaWxlcyB0byBsb2FkLFxuXHQgKiAgICAgYW5kIGNhbiBvcHRpb25hbGx5IGNvbnRhaW4gYSBcInBhdGhcIiBwcm9wZXJ0eSwgd2hpY2ggd2lsbCBiZSBwcmVwZW5kZWQgdG8gZWFjaCBmaWxlIGluIHRoZSBsaXN0LjwvbGk+XG5cdCAqICAgICA8bGk+QW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIGEgXCJtYW5pZmVzdFwiIHByb3BlcnR5LCB3aGljaCBkZWZpbmVzIHRoZSBsaXN0IG9mIGZpbGVzIHRvIGxvYWQsIGFuZCBjYW5cblx0ICogICAgIG9wdGlvbmFsbHkgY29udGFpbiBhIFwicGF0aFwiIHByb3BlcnR5LCB3aGljaCB3aWxsIGJlIHByZXBlbmRlZCB0byBlYWNoIGZpbGUgaW4gdGhlIGxpc3QuPC9saT5cblx0ICogICAgIDxsaT5BbiBBcnJheSBvZiBmaWxlcyB0byBsb2FkLjwvbGk+XG5cdCAqIDwvb2w+XG5cdCAqXG5cdCAqIEVhY2ggXCJmaWxlXCIgaW4gYSBtYW5pZmVzdCBjYW4gYmUgZWl0aGVyOlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+QSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZTwvbGk+XG5cdCAqICAgICA8bGk+QW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBkZWZpbmVkIGJ5IHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319PC9saT5cblx0ICogICAgIDxsaT5PUiBBIHN0cmluZyBwYXRoIHRvIGEgcmVzb3VyY2UuIE5vdGUgdGhhdCB0aGlzIGtpbmQgb2YgbG9hZCBpdGVtIHdpbGwgYmUgY29udmVydGVkIHRvIGEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX1cblx0ICogICAgIGluIHRoZSBiYWNrZ3JvdW5kLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2xvYWROb3c9dHJ1ZV0gS2ljayBvZmYgYW4gaW1tZWRpYXRlIGxvYWQgKHRydWUpIG9yIHdhaXQgZm9yIGEgbG9hZCBjYWxsIChmYWxzZSkuIFRoZSBkZWZhdWx0XG5cdCAqIHZhbHVlIGlzIHRydWUuIElmIHRoZSBxdWV1ZSBpcyBwYXVzZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldFBhdXNlZFwifX17ey9jcm9zc0xpbmt9fSBhbmQgdGhpcyB2YWx1ZSBpc1xuXHQgKiBgdHJ1ZWAsIHRoZSBxdWV1ZSB3aWxsIHJlc3VtZSBhdXRvbWF0aWNhbGx5LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2Jhc2VQYXRoXSBBIGJhc2UgcGF0aCB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIHRvIGVhY2ggZmlsZS4gVGhlIGJhc2VQYXRoIGFyZ3VtZW50IG92ZXJyaWRlcyB0aGVcblx0ICogcGF0aCBzcGVjaWZpZWQgaW4gdGhlIGNvbnN0cnVjdG9yLiBOb3RlIHRoYXQgaWYgeW91IGxvYWQgYSBtYW5pZmVzdCB1c2luZyBhIGZpbGUgb2YgdHlwZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvTUFOSUZFU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIGl0cyBmaWxlcyB3aWxsIDxzdHJvbmc+Tk9UPC9zdHJvbmc+IHVzZSB0aGUgYmFzZVBhdGggcGFyYW1ldGVyLiA8c3Ryb25nPlRoZSBiYXNlUGF0aCBwYXJhbWV0ZXIgaXMgZGVwcmVjYXRlZC48L3N0cm9uZz5cblx0ICogVGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uIFBsZWFzZSBlaXRoZXIgdXNlIHRoZSBgYmFzZVBhdGhgIHBhcmFtZXRlciBpbiB0aGUgTG9hZFF1ZXVlXG5cdCAqIGNvbnN0cnVjdG9yLCBvciBhIGBwYXRoYCBwcm9wZXJ0eSBpbiBhIG1hbmlmZXN0IGRlZmluaXRpb24uXG5cdCAqL1xuXHRwLmxvYWRNYW5pZmVzdCA9IGZ1bmN0aW9uIChtYW5pZmVzdCwgbG9hZE5vdywgYmFzZVBhdGgpIHtcblx0XHR2YXIgZmlsZUxpc3QgPSBudWxsO1xuXHRcdHZhciBwYXRoID0gbnVsbDtcblxuXHRcdC8vIEFycmF5LWJhc2VkIGxpc3Qgb2YgaXRlbXNcblx0XHRpZiAobWFuaWZlc3QgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0aWYgKG1hbmlmZXN0Lmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9NQU5JRkVTVF9FTVBUWVwiKTtcblx0XHRcdFx0dGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0ZmlsZUxpc3QgPSBtYW5pZmVzdDtcblxuXHRcdFx0Ly8gU3RyaW5nLWJhc2VkLiBPbmx5IGZpbGUgbWFuaWZlc3RzIGNhbiBiZSBzcGVjaWZpZWQgdGhpcyB3YXkuIEFueSBvdGhlciB0eXBlcyB3aWxsIGNhdXNlIGFuIGVycm9yIHdoZW4gbG9hZGVkLlxuXHRcdH0gZWxzZSBpZiAodHlwZW9mKG1hbmlmZXN0KSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0ZmlsZUxpc3QgPSBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzcmM6IG1hbmlmZXN0LFxuXHRcdFx0XHRcdHR5cGU6IHMuTUFOSUZFU1Rcblx0XHRcdFx0fVxuXHRcdFx0XTtcblxuXHRcdH0gZWxzZSBpZiAodHlwZW9mKG1hbmlmZXN0KSA9PSBcIm9iamVjdFwiKSB7XG5cblx0XHRcdC8vIEFuIG9iamVjdCB0aGF0IGRlZmluZXMgYSBtYW5pZmVzdCBwYXRoXG5cdFx0XHRpZiAobWFuaWZlc3Quc3JjICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKG1hbmlmZXN0LnR5cGUgPT0gbnVsbCkge1xuXHRcdFx0XHRcdG1hbmlmZXN0LnR5cGUgPSBzLk1BTklGRVNUO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG1hbmlmZXN0LnR5cGUgIT0gcy5NQU5JRkVTVCkge1xuXHRcdFx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9NQU5JRkVTVF9UWVBFXCIpO1xuXHRcdFx0XHRcdHRoaXMuX3NlbmRFcnJvcihldmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZmlsZUxpc3QgPSBbbWFuaWZlc3RdO1xuXG5cdFx0XHRcdC8vIEFuIG9iamVjdCB0aGF0IGRlZmluZXMgYSBtYW5pZmVzdFxuXHRcdFx0fSBlbHNlIGlmIChtYW5pZmVzdC5tYW5pZmVzdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGZpbGVMaXN0ID0gbWFuaWZlc3QubWFuaWZlc3Q7XG5cdFx0XHRcdHBhdGggPSBtYW5pZmVzdC5wYXRoO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVbnN1cHBvcnRlZC4gVGhpcyB3aWxsIHRocm93IGFuIGVycm9yLlxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlBSRUxPQURfTUFOSUZFU1RfTlVMTFwiKTtcblx0XHRcdHRoaXMuX3NlbmRFcnJvcihldmVudCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBmaWxlTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHRoaXMuX2FkZEl0ZW0oZmlsZUxpc3RbaV0sIHBhdGgsIGJhc2VQYXRoKTtcblx0XHR9XG5cblx0XHRpZiAobG9hZE5vdyAhPT0gZmFsc2UpIHtcblx0XHRcdHRoaXMuc2V0UGF1c2VkKGZhbHNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRQYXVzZWQodHJ1ZSk7XG5cdFx0fVxuXG5cdH07XG5cblx0LyoqXG5cdCAqIFN0YXJ0IGEgTG9hZFF1ZXVlIHRoYXQgd2FzIGNyZWF0ZWQsIGJ1dCBub3QgYXV0b21hdGljYWxseSBzdGFydGVkLlxuXHQgKiBAbWV0aG9kIGxvYWRcblx0ICovXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnNldFBhdXNlZChmYWxzZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIExvb2sgdXAgYSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSB1c2luZyBlaXRoZXIgdGhlIFwiaWRcIiBvciBcInNyY1wiIHRoYXQgd2FzIHNwZWNpZmllZCB3aGVuIGxvYWRpbmcgaXQuIE5vdGUgdGhhdCBpZiBubyBcImlkXCIgd2FzXG5cdCAqIHN1cHBsaWVkIHdpdGggdGhlIGxvYWQgaXRlbSwgdGhlIElEIHdpbGwgYmUgdGhlIFwic3JjXCIsIGluY2x1ZGluZyBhIGBwYXRoYCBwcm9wZXJ0eSBkZWZpbmVkIGJ5IGEgbWFuaWZlc3QuIFRoZVxuXHQgKiBgYmFzZVBhdGhgIHdpbGwgbm90IGJlIHBhcnQgb2YgdGhlIElELlxuXHQgKiBAbWV0aG9kIGdldEl0ZW1cblx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSA8Y29kZT5pZDwvY29kZT4gb3IgPGNvZGU+c3JjPC9jb2RlPiBvZiB0aGUgbG9hZCBpdGVtLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBsb2FkIGl0ZW0gdGhhdCB3YXMgaW5pdGlhbGx5IHJlcXVlc3RlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogb3Ige3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fS4gVGhpcyBvYmplY3QgaXMgYWxzbyByZXR1cm5lZCB2aWEgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBhcyB0aGUgYGl0ZW1gIHBhcmFtZXRlci5cblx0ICovXG5cdHAuZ2V0SXRlbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHJldHVybiB0aGlzLl9sb2FkSXRlbXNCeUlkW3ZhbHVlXSB8fCB0aGlzLl9sb2FkSXRlbXNCeVNyY1t2YWx1ZV07XG5cdH07XG5cblx0LyoqXG5cdCAqIExvb2sgdXAgYSBsb2FkZWQgcmVzdWx0IHVzaW5nIGVpdGhlciB0aGUgXCJpZFwiIG9yIFwic3JjXCIgdGhhdCB3YXMgc3BlY2lmaWVkIHdoZW4gbG9hZGluZyBpdC4gTm90ZSB0aGF0IGlmIG5vIFwiaWRcIlxuXHQgKiB3YXMgc3VwcGxpZWQgd2l0aCB0aGUgbG9hZCBpdGVtLCB0aGUgSUQgd2lsbCBiZSB0aGUgXCJzcmNcIiwgaW5jbHVkaW5nIGEgYHBhdGhgIHByb3BlcnR5IGRlZmluZWQgYnkgYSBtYW5pZmVzdC4gVGhlXG5cdCAqIGBiYXNlUGF0aGAgd2lsbCBub3QgYmUgcGFydCBvZiB0aGUgSUQuXG5cdCAqIEBtZXRob2QgZ2V0UmVzdWx0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgPGNvZGU+aWQ8L2NvZGU+IG9yIDxjb2RlPnNyYzwvY29kZT4gb2YgdGhlIGxvYWQgaXRlbS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcmF3UmVzdWx0PWZhbHNlXSBSZXR1cm4gYSByYXcgcmVzdWx0IGluc3RlYWQgb2YgYSBmb3JtYXR0ZWQgcmVzdWx0LiBUaGlzIGFwcGxpZXMgdG8gY29udGVudFxuXHQgKiBsb2FkZWQgdmlhIFhIUiBzdWNoIGFzIHNjcmlwdHMsIFhNTCwgQ1NTLCBhbmQgSW1hZ2VzLiBJZiB0aGVyZSBpcyBubyByYXcgcmVzdWx0LCB0aGUgZm9ybWF0dGVkIHJlc3VsdCB3aWxsIGJlXG5cdCAqIHJldHVybmVkIGluc3RlYWQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQSByZXN1bHQgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvbnRlbnQgdGhhdCB3YXMgbG9hZGVkLCBzdWNoIGFzOlxuXHQgKiA8dWw+XG5cdCAqICAgICAgPGxpPkFuIGltYWdlIHRhZyAoJmx0O2ltYWdlIC8mZ3Q7KSBmb3IgaW1hZ2VzPC9saT5cblx0ICogICAgICA8bGk+QSBzY3JpcHQgdGFnIGZvciBKYXZhU2NyaXB0ICgmbHQ7c2NyaXB0IC8mZ3Q7KS4gTm90ZSB0aGF0IHNjcmlwdHMgYXJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gdGhlIEhUTUxcblx0ICogICAgICBET00uPC9saT5cblx0ICogICAgICA8bGk+QSBzdHlsZSB0YWcgZm9yIENTUyAoJmx0O3N0eWxlIC8mZ3Q7IG9yICZsdDtsaW5rICZndDspPC9saT5cblx0ICogICAgICA8bGk+UmF3IHRleHQgZm9yIFRFWFQ8L2xpPlxuXHQgKiAgICAgIDxsaT5BIGZvcm1hdHRlZCBKYXZhU2NyaXB0IG9iamVjdCBkZWZpbmVkIGJ5IEpTT048L2xpPlxuXHQgKiAgICAgIDxsaT5BbiBYTUwgZG9jdW1lbnQ8L2xpPlxuXHQgKiAgICAgIDxsaT5BIGJpbmFyeSBhcnJheWJ1ZmZlciBsb2FkZWQgYnkgWEhSPC9saT5cblx0ICogICAgICA8bGk+QW4gYXVkaW8gdGFnICgmbHQ7YXVkaW8gJmd0OykgZm9yIEhUTUwgYXVkaW8uIE5vdGUgdGhhdCBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgU291bmRKUyBBUElzIHRvIHBsYXlcblx0ICogICAgICBsb2FkZWQgYXVkaW8uIFNwZWNpZmljYWxseSwgYXVkaW8gbG9hZGVkIGJ5IEZsYXNoIGFuZCBXZWJBdWRpbyB3aWxsIHJldHVybiBhIGxvYWRlciBvYmplY3QgdXNpbmcgdGhpcyBtZXRob2Rcblx0ICogICAgICB3aGljaCBjYW4gbm90IGJlIHVzZWQgdG8gcGxheSBhdWRpbyBiYWNrLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIFRoaXMgb2JqZWN0IGlzIGFsc28gcmV0dXJuZWQgdmlhIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZWxvYWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgYXMgdGhlICdpdGVtYFxuXHQgKiBwYXJhbWV0ZXIuIE5vdGUgdGhhdCBpZiBhIHJhdyByZXN1bHQgaXMgcmVxdWVzdGVkLCBidXQgbm90IGZvdW5kLCB0aGUgcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZC5cblx0ICovXG5cdHAuZ2V0UmVzdWx0ID0gZnVuY3Rpb24gKHZhbHVlLCByYXdSZXN1bHQpIHtcblx0XHR2YXIgaXRlbSA9IHRoaXMuX2xvYWRJdGVtc0J5SWRbdmFsdWVdIHx8IHRoaXMuX2xvYWRJdGVtc0J5U3JjW3ZhbHVlXTtcblx0XHRpZiAoaXRlbSA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0dmFyIGlkID0gaXRlbS5pZDtcblx0XHRpZiAocmF3UmVzdWx0ICYmIHRoaXMuX2xvYWRlZFJhd1Jlc3VsdHNbaWRdKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbG9hZGVkUmF3UmVzdWx0c1tpZF07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9sb2FkZWRSZXN1bHRzW2lkXTtcblx0fTtcblxuXHQvKipcblx0ICogR2VuZXJhdGUgYW4gbGlzdCBvZiBpdGVtcyBsb2FkZWQgYnkgdGhpcyBxdWV1ZS5cblx0ICogQG1ldGhvZCBnZXRJdGVtc1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGxvYWRlZCBEZXRlcm1pbmVzIGlmIG9ubHkgaXRlbXMgdGhhdCBoYXZlIGJlZW4gbG9hZGVkIHNob3VsZCBiZSByZXR1cm5lZC4gSWYgZmFsc2UsIGluLXByb2dyZXNzXG5cdCAqIGFuZCBmYWlsZWQgbG9hZCBpdGVtcyB3aWxsIGFsc28gYmUgaW5jbHVkZWQuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBsaXN0IG9mIG9iamVjdHMgdGhhdCBoYXZlIGJlZW4gbG9hZGVkLiBFYWNoIGl0ZW0gaW5jbHVkZXMgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiByZXN1bHQsIGFuZCByYXdSZXN1bHQuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5nZXRJdGVtcyA9IGZ1bmN0aW9uIChsb2FkZWQpIHtcblx0XHR2YXIgYXJyID0gW107XG5cdFx0Zm9yICh2YXIgbiBpbiB0aGlzLl9sb2FkSXRlbXNCeUlkKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHRoaXMuX2xvYWRJdGVtc0J5SWRbbl07XG5cdFx0XHR2YXIgcmVzdWx0ID0gdGhpcy5nZXRSZXN1bHQobik7XG5cdFx0XHRpZiAobG9hZGVkID09PSB0cnVlICYmIHJlc3VsdCA9PSBudWxsKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0YXJyLnB1c2goe1xuXHRcdFx0XHRpdGVtOiBpdGVtLFxuXHRcdFx0XHRyZXN1bHQ6IHJlc3VsdCxcblx0XHRcdFx0cmF3UmVzdWx0OiB0aGlzLmdldFJlc3VsdChuLCB0cnVlKVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBhcnI7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhdXNlIG9yIHJlc3VtZSB0aGUgY3VycmVudCBsb2FkLiBBY3RpdmUgbG9hZHMgd2lsbCBub3QgYmUgY2FuY2VsbGVkLCBidXQgdGhlIG5leHQgaXRlbXMgaW4gdGhlIHF1ZXVlIHdpbGwgbm90XG5cdCAqIGJlIHByb2Nlc3NlZCB3aGVuIGFjdGl2ZSBsb2FkcyBjb21wbGV0ZS4gTG9hZFF1ZXVlcyBhcmUgbm90IHBhdXNlZCBieSBkZWZhdWx0LlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgaWYgbmV3IGl0ZW1zIGFyZSBhZGRlZCB0byB0aGUgcXVldWUgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX0sIGEgcGF1c2VkIHF1ZXVlIHdpbGwgYmUgcmVzdW1lZCwgdW5sZXNzIHRoZSBgbG9hZE5vd2Bcblx0ICogYXJndW1lbnQgaXMgYGZhbHNlYC5cblx0ICogQG1ldGhvZCBzZXRQYXVzZWRcblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBXaGV0aGVyIHRoZSBxdWV1ZSBzaG91bGQgYmUgcGF1c2VkIG9yIG5vdC5cblx0ICovXG5cdHAuc2V0UGF1c2VkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dGhpcy5fcGF1c2VkID0gdmFsdWU7XG5cdFx0aWYgKCF0aGlzLl9wYXVzZWQpIHtcblx0XHRcdHRoaXMuX2xvYWROZXh0KCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbG9zZSB0aGUgYWN0aXZlIHF1ZXVlLiBDbG9zaW5nIGEgcXVldWUgY29tcGxldGVseSBlbXB0aWVzIHRoZSBxdWV1ZSwgYW5kIHByZXZlbnRzIGFueSByZW1haW5pbmcgaXRlbXMgZnJvbVxuXHQgKiBzdGFydGluZyB0byBkb3dubG9hZC4gTm90ZSB0aGF0IGN1cnJlbnRseSBhbnkgYWN0aXZlIGxvYWRzIHdpbGwgcmVtYWluIG9wZW4sIGFuZCBldmVudHMgbWF5IGJlIHByb2Nlc3NlZC5cblx0ICpcblx0ICogVG8gc3RvcCBhbmQgcmVzdGFydCBhIHF1ZXVlLCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRQYXVzZWRcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGluc3RlYWQuXG5cdCAqIEBtZXRob2QgY2xvc2Vcblx0ICovXG5cdHAuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0d2hpbGUgKHRoaXMuX2N1cnJlbnRMb2Fkcy5sZW5ndGgpIHtcblx0XHRcdHRoaXMuX2N1cnJlbnRMb2Fkcy5wb3AoKS5jYW5jZWwoKTtcblx0XHR9XG5cdFx0dGhpcy5fc2NyaXB0T3JkZXIubGVuZ3RoID0gMDtcblx0XHR0aGlzLl9sb2FkZWRTY3JpcHRzLmxlbmd0aCA9IDA7XG5cdFx0dGhpcy5sb2FkU3RhcnRXYXNEaXNwYXRjaGVkID0gZmFsc2U7XG5cdFx0dGhpcy5faXRlbUNvdW50ID0gMDtcblx0XHR0aGlzLl9sYXN0UHJvZ3Jlc3MgPSBOYU47XG5cdH07XG5cbi8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBBZGQgYW4gaXRlbSB0byB0aGUgcXVldWUuIEl0ZW1zIGFyZSBmb3JtYXR0ZWQgaW50byBhIHVzYWJsZSBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHByb3BlcnRpZXMgbmVjZXNzYXJ5IHRvXG5cdCAqIGxvYWQgdGhlIGNvbnRlbnQuIFRoZSBsb2FkIHF1ZXVlIGlzIHBvcHVsYXRlZCB3aXRoIHRoZSBsb2FkZXIgaW5zdGFuY2UgdGhhdCBoYW5kbGVzIHByZWxvYWRpbmcsIGFuZCBub3QgdGhlIGxvYWRcblx0ICogaXRlbSB0aGF0IHdhcyBwYXNzZWQgaW4gYnkgdGhlIHVzZXIuIFRvIGxvb2sgdXAgdGhlIGxvYWQgaXRlbSBieSBpZCBvciBzcmMsIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlLmdldEl0ZW1cIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLlxuXHQgKiBAbWV0aG9kIF9hZGRJdGVtXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdmFsdWUgVGhlIGl0ZW0gdG8gYWRkIHRvIHRoZSBxdWV1ZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXSBBbiBvcHRpb25hbCBwYXRoIHByZXBlbmRlZCB0byB0aGUgYHNyY2AuIFRoZSBwYXRoIHdpbGwgb25seSBiZSBwcmVwZW5kZWQgaWYgdGhlIHNyYyBpc1xuXHQgKiByZWxhdGl2ZSwgYW5kIGRvZXMgbm90IHN0YXJ0IHdpdGggYSBwcm90b2NvbCBzdWNoIGFzIGBodHRwOi8vYCwgb3IgYSBwYXRoIGxpa2UgYC4uL2AuIElmIHRoZSBMb2FkUXVldWUgd2FzXG5cdCAqIHByb3ZpZGVkIGEge3sjY3Jvc3NMaW5rIFwiX2Jhc2VQYXRoXCJ9fXt7L2Nyb3NzTGlua319LCB0aGVuIGl0IHdpbGwgb3B0aW9uYWxseSBiZSBwcmVwZW5kZWQgYWZ0ZXIuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbYmFzZVBhdGhdIDxzdHJvbmc+RGVwcmVjYXRlZDwvc3Ryb25nPkFuIG9wdGlvbmFsIGJhc2VQYXRoIHBhc3NlZCBpbnRvIGEge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvciB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX0gY2FsbC4gVGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHRhZ2dlZFxuXHQgKiB2ZXJzaW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fYWRkSXRlbSA9IGZ1bmN0aW9uICh2YWx1ZSwgcGF0aCwgYmFzZVBhdGgpIHtcblx0XHR2YXIgaXRlbSA9IHRoaXMuX2NyZWF0ZUxvYWRJdGVtKHZhbHVlLCBwYXRoLCBiYXNlUGF0aCk7IC8vIGJhc2VQYXRoIGFuZCBtYW5pZmVzdCBwYXRoIGFyZSBhZGRlZCB0byB0aGUgc3JjLlxuXHRcdGlmIChpdGVtID09IG51bGwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vIFNvbWV0aW1lcyBwbHVnaW5zIG9yIHR5cGVzIHNob3VsZCBiZSBza2lwcGVkLlxuXHRcdHZhciBsb2FkZXIgPSB0aGlzLl9jcmVhdGVMb2FkZXIoaXRlbSk7XG5cdFx0aWYgKGxvYWRlciAhPSBudWxsKSB7XG5cdFx0XHRpZiAoXCJwbHVnaW5zXCIgaW4gbG9hZGVyKSB7XG5cdFx0XHRcdGxvYWRlci5wbHVnaW5zID0gdGhpcy5fcGx1Z2lucztcblx0XHRcdH1cblx0XHRcdGl0ZW0uX2xvYWRlciA9IGxvYWRlcjtcblx0XHRcdHRoaXMuX2xvYWRRdWV1ZS5wdXNoKGxvYWRlcik7XG5cdFx0XHR0aGlzLl9sb2FkUXVldWVCYWNrdXAucHVzaChsb2FkZXIpO1xuXG5cdFx0XHR0aGlzLl9udW1JdGVtcysrO1xuXHRcdFx0dGhpcy5fdXBkYXRlUHJvZ3Jlc3MoKTtcblxuXHRcdFx0Ly8gT25seSB3b3JyeSBhYm91dCBzY3JpcHQgb3JkZXIgd2hlbiB1c2luZyBYSFIgdG8gbG9hZCBzY3JpcHRzLiBUYWdzIGFyZSBvbmx5IGxvYWRpbmcgb25lIGF0IGEgdGltZS5cblx0XHRcdGlmICgodGhpcy5tYWludGFpblNjcmlwdE9yZGVyXG5cdFx0XHRcdFx0JiYgaXRlbS50eXBlID09IGNyZWF0ZWpzLkxvYWRRdWV1ZS5KQVZBU0NSSVBUXG5cdFx0XHRcdFx0XHQvLyYmIGxvYWRlciBpbnN0YW5jZW9mIGNyZWF0ZWpzLlhIUkxvYWRlciAvL05PVEU6IEhhdmUgdG8gdHJhY2sgYWxsIEpTIGZpbGVzIHRoaXMgd2F5XG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdHx8IGl0ZW0ubWFpbnRhaW5PcmRlciA9PT0gdHJ1ZSkge1xuXHRcdFx0XHR0aGlzLl9zY3JpcHRPcmRlci5wdXNoKGl0ZW0pO1xuXHRcdFx0XHR0aGlzLl9sb2FkZWRTY3JpcHRzLnB1c2gobnVsbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSByZWZpbmVkIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319LCB3aGljaCBjb250YWlucyBhbGwgdGhlIHJlcXVpcmVkIHByb3BlcnRpZXMuIFRoZSB0eXBlIG9mXG5cdCAqIGl0ZW0gaXMgZGV0ZXJtaW5lZCBieSBicm93c2VyIHN1cHBvcnQsIHJlcXVpcmVtZW50cyBiYXNlZCBvbiB0aGUgZmlsZSB0eXBlLCBhbmQgZGV2ZWxvcGVyIHNldHRpbmdzLiBGb3IgZXhhbXBsZSxcblx0ICogWEhSIGlzIG9ubHkgdXNlZCBmb3IgZmlsZSB0eXBlcyB0aGF0IHN1cHBvcnQgaXQgaW4gbmV3IGJyb3dzZXJzLlxuXHQgKlxuXHQgKiBCZWZvcmUgdGhlIGl0ZW0gaXMgcmV0dXJuZWQsIGFueSBwbHVnaW5zIHJlZ2lzdGVyZWQgdG8gaGFuZGxlIHRoZSB0eXBlIG9yIGV4dGVuc2lvbiB3aWxsIGJlIGZpcmVkLCB3aGljaCBtYXlcblx0ICogYWx0ZXIgdGhlIGxvYWQgaXRlbS5cblx0ICogQG1ldGhvZCBfY3JlYXRlTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtTdHJpbmcgfCBPYmplY3QgfCBIVE1MQXVkaW9FbGVtZW50IHwgSFRNTEltYWdlRWxlbWVudH0gdmFsdWUgVGhlIGl0ZW0gdGhhdCBuZWVkcyB0byBiZSBwcmVsb2FkZWQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF0gQSBwYXRoIHRvIHByZXBlbmQgdG8gdGhlIGl0ZW0ncyBzb3VyY2UuIFNvdXJjZXMgYmVnaW5uaW5nIHdpdGggaHR0cDovLyBvciBzaW1pbGFyIHdpbGxcblx0ICogbm90IHJlY2VpdmUgYSBwYXRoLiBTaW5jZSBQcmVsb2FkSlMgMC40LjEsIHRoZSBzcmMgd2lsbCBiZSBtb2RpZmllZCB0byBpbmNsdWRlIHRoZSBgcGF0aGAgYW5kIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9fYmFzZVBhdGg6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2hlbiBpdCBpcyBhZGRlZC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtiYXNlUGF0aF0gPHN0cm9uZz5EZXByZWN0YXRlZDwvc3Ryb25nPiBBIGJhc2UgcGF0aCB0byBwcmVwZW5kIHRvIHRoZSBpdGVtcyBzb3VyY2UgaW4gYWRkaXRpb24gdG9cblx0ICogdGhlIHBhdGggYXJndW1lbnQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGxvYWRlciBpbnN0YW5jZSB0aGF0IHdpbGwgYmUgdXNlZC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NyZWF0ZUxvYWRJdGVtID0gZnVuY3Rpb24gKHZhbHVlLCBwYXRoLCBiYXNlUGF0aCkge1xuXHRcdHZhciBpdGVtID0gY3JlYXRlanMuTG9hZEl0ZW0uY3JlYXRlKHZhbHVlKTtcblx0XHRpZiAoaXRlbSA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR2YXIgYnAgPSBcIlwiOyAvLyBTdG9yZSB0aGUgZ2VuZXJhdGVkIGJhc2VQYXRoXG5cdFx0dmFyIHVzZUJhc2VQYXRoID0gYmFzZVBhdGggfHwgdGhpcy5fYmFzZVBhdGg7XG5cblx0XHRpZiAoaXRlbS5zcmMgaW5zdGFuY2VvZiBPYmplY3QpIHtcblx0XHRcdGlmICghaXRlbS50eXBlKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSAvLyB0aGUgdGhlIHNyYyBpcyBhbiBvYmplY3QsIHR5cGUgaXMgcmVxdWlyZWQgdG8gcGFzcyBvZmYgdG8gcGx1Z2luXG5cdFx0XHRpZiAocGF0aCkge1xuXHRcdFx0XHRicCA9IHBhdGg7XG5cdFx0XHRcdHZhciBwYXRoTWF0Y2ggPSBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMucGFyc2VVUkkocGF0aCk7XG5cdFx0XHRcdC8vIEFsc28gYXBwZW5kIGJhc2VQYXRoXG5cdFx0XHRcdGlmICh1c2VCYXNlUGF0aCAhPSBudWxsICYmICFwYXRoTWF0Y2guYWJzb2x1dGUgJiYgIXBhdGhNYXRjaC5yZWxhdGl2ZSkge1xuXHRcdFx0XHRcdGJwID0gdXNlQmFzZVBhdGggKyBicDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh1c2VCYXNlUGF0aCAhPSBudWxsKSB7XG5cdFx0XHRcdGJwID0gdXNlQmFzZVBhdGg7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIERldGVybWluZSBFeHRlbnNpb24sIGV0Yy5cblx0XHRcdHZhciBtYXRjaCA9IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5wYXJzZVVSSShpdGVtLnNyYyk7XG5cdFx0XHRpZiAobWF0Y2guZXh0ZW5zaW9uKSB7XG5cdFx0XHRcdGl0ZW0uZXh0ID0gbWF0Y2guZXh0ZW5zaW9uO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGl0ZW0udHlwZSA9PSBudWxsKSB7XG5cdFx0XHRcdGl0ZW0udHlwZSA9IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5nZXRUeXBlQnlFeHRlbnNpb24oaXRlbS5leHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmplY3QgcGF0aCAmIGJhc2VQYXRoXG5cdFx0XHR2YXIgYXV0b0lkID0gaXRlbS5zcmM7XG5cdFx0XHRpZiAoIW1hdGNoLmFic29sdXRlICYmICFtYXRjaC5yZWxhdGl2ZSkge1xuXHRcdFx0XHRpZiAocGF0aCkge1xuXHRcdFx0XHRcdGJwID0gcGF0aDtcblx0XHRcdFx0XHR2YXIgcGF0aE1hdGNoID0gY3JlYXRlanMuUmVxdWVzdFV0aWxzLnBhcnNlVVJJKHBhdGgpO1xuXHRcdFx0XHRcdGF1dG9JZCA9IHBhdGggKyBhdXRvSWQ7XG5cdFx0XHRcdFx0Ly8gQWxzbyBhcHBlbmQgYmFzZVBhdGhcblx0XHRcdFx0XHRpZiAodXNlQmFzZVBhdGggIT0gbnVsbCAmJiAhcGF0aE1hdGNoLmFic29sdXRlICYmICFwYXRoTWF0Y2gucmVsYXRpdmUpIHtcblx0XHRcdFx0XHRcdGJwID0gdXNlQmFzZVBhdGggKyBicDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAodXNlQmFzZVBhdGggIT0gbnVsbCkge1xuXHRcdFx0XHRcdGJwID0gdXNlQmFzZVBhdGg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGl0ZW0uc3JjID0gYnAgKyBpdGVtLnNyYztcblx0XHR9XG5cdFx0aXRlbS5wYXRoID0gYnA7XG5cblx0XHQvLyBJZiB0aGVyZSdzIG5vIGlkLCBzZXQgb25lIG5vdy5cblx0XHRpZiAoaXRlbS5pZCA9PT0gdW5kZWZpbmVkIHx8IGl0ZW0uaWQgPT09IG51bGwgfHwgaXRlbS5pZCA9PT0gXCJcIikge1xuXHRcdFx0aXRlbS5pZCA9IGF1dG9JZDtcblx0XHR9XG5cblx0XHQvLyBHaXZlIHBsdWdpbnMgYSBjaGFuY2UgdG8gbW9kaWZ5IHRoZSBsb2FkSXRlbTpcblx0XHR2YXIgY3VzdG9tSGFuZGxlciA9IHRoaXMuX3R5cGVDYWxsYmFja3NbaXRlbS50eXBlXSB8fCB0aGlzLl9leHRlbnNpb25DYWxsYmFja3NbaXRlbS5leHRdO1xuXHRcdGlmIChjdXN0b21IYW5kbGVyKSB7XG5cdFx0XHQvLyBQbHVnaW5zIGFyZSBub3cgcGFzc2VkIGJvdGggdGhlIGZ1bGwgc291cmNlLCBhcyB3ZWxsIGFzIGEgY29tYmluZWQgcGF0aCtiYXNlUGF0aCAoYXBwcm9wcmlhdGVseSlcblx0XHRcdHZhciByZXN1bHQgPSBjdXN0b21IYW5kbGVyLmNhbGxiYWNrLmNhbGwoY3VzdG9tSGFuZGxlci5zY29wZSwgaXRlbSwgdGhpcyk7XG5cblx0XHRcdC8vIFRoZSBwbHVnaW4gd2lsbCBoYW5kbGUgdGhlIGxvYWQsIG9yIGhhcyBjYW5jZWxlZCBpdC4gSWdub3JlIGl0LlxuXHRcdFx0aWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdFx0Ly8gTG9hZCBhcyBub3JtYWw6XG5cdFx0XHR9IGVsc2UgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHQvLyBEbyBOb3RoaW5nXG5cblx0XHRcdFx0Ly8gUmVzdWx0IGlzIGEgbG9hZGVyIGNsYXNzOlxuXHRcdFx0fSBlbHNlIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuXHRcdFx0XHRpdGVtLl9sb2FkZXIgPSByZXN1bHQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSB0aGUgZXh0ZW5zaW9uIGluIGNhc2UgdGhlIHR5cGUgY2hhbmdlZDpcblx0XHRcdG1hdGNoID0gY3JlYXRlanMuUmVxdWVzdFV0aWxzLnBhcnNlVVJJKGl0ZW0uc3JjKTtcblx0XHRcdGlmIChtYXRjaC5leHRlbnNpb24gIT0gbnVsbCkge1xuXHRcdFx0XHRpdGVtLmV4dCA9IG1hdGNoLmV4dGVuc2lvbjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdG9yZSB0aGUgaXRlbSBmb3IgbG9va3VwLiBUaGlzIGFsc28gaGVscHMgY2xlYW4tdXAgbGF0ZXIuXG5cdFx0dGhpcy5fbG9hZEl0ZW1zQnlJZFtpdGVtLmlkXSA9IGl0ZW07XG5cdFx0dGhpcy5fbG9hZEl0ZW1zQnlTcmNbaXRlbS5zcmNdID0gaXRlbTtcblxuXHRcdGlmIChpdGVtLmNyb3NzT3JpZ2luID09IG51bGwpIHtcblx0XHRcdGl0ZW0uY3Jvc3NPcmlnaW4gPSB0aGlzLl9jcm9zc09yaWdpbjtcblx0XHR9XG5cblx0XHRyZXR1cm4gaXRlbTtcblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgbG9hZGVyIGZvciBhIGxvYWQgaXRlbS5cblx0ICogQG1ldGhvZCBfY3JlYXRlTG9hZGVyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIEEgZm9ybWF0dGVkIGxvYWQgaXRlbSB0aGF0IGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIGEgbG9hZGVyLlxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdExvYWRlcn0gQSBsb2FkZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBsb2FkIGNvbnRlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jcmVhdGVMb2FkZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdGlmIChpdGVtLl9sb2FkZXIgIT0gbnVsbCkgeyAvLyBBIHBsdWdpbiBhbHJlYWR5IHNwZWNpZmllZCBhIGxvYWRlclxuXHRcdFx0cmV0dXJuIGl0ZW0uX2xvYWRlcjtcblx0XHR9XG5cblx0XHQvLyBJbml0aWFsbHksIHRyeSBhbmQgdXNlIHRoZSBwcm92aWRlZC9zdXBwb3J0ZWQgWEhSIG1vZGU6XG5cdFx0dmFyIHByZWZlclhIUiA9IHRoaXMucHJlZmVyWEhSO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9hdmFpbGFibGVMb2FkZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgbG9hZGVyID0gdGhpcy5fYXZhaWxhYmxlTG9hZGVyc1tpXTtcblx0XHRcdGlmIChsb2FkZXIgJiYgbG9hZGVyLmNhbkxvYWRJdGVtKGl0ZW0pKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgbG9hZGVyKGl0ZW0sIHByZWZlclhIUik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gVE9ETzogTG9nIGVycm9yIChyZXF1aXJlcyBjcmVhdGVqcy5sb2cpXG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIExvYWQgdGhlIG5leHQgaXRlbSBpbiB0aGUgcXVldWUuIElmIHRoZSBxdWV1ZSBpcyBlbXB0eSAoYWxsIGl0ZW1zIGhhdmUgYmVlbiBsb2FkZWQpLCB0aGVuIHRoZSBjb21wbGV0ZSBldmVudFxuXHQgKiBpcyBwcm9jZXNzZWQuIFRoZSBxdWV1ZSB3aWxsIFwiZmlsbCB1cFwiIGFueSBlbXB0eSBzbG90cywgdXAgdG8gdGhlIG1heCBjb25uZWN0aW9uIHNwZWNpZmllZCB1c2luZ1xuXHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUuc2V0TWF4Q29ubmVjdGlvbnNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLiBUaGUgb25seSBleGNlcHRpb24gaXMgc2NyaXB0cyB0aGF0IGFyZSBsb2FkZWRcblx0ICogdXNpbmcgdGFncywgd2hpY2ggaGF2ZSB0byBiZSBsb2FkZWQgb25lIGF0IGEgdGltZSB0byBtYWludGFpbiBsb2FkIG9yZGVyLlxuXHQgKiBAbWV0aG9kIF9sb2FkTmV4dFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fbG9hZE5leHQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3BhdXNlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9ubHkgZGlzcGF0Y2ggbG9hZHN0YXJ0IGV2ZW50IHdoZW4gdGhlIGZpcnN0IGZpbGUgaXMgbG9hZGVkLlxuXHRcdGlmICghdGhpcy5fbG9hZFN0YXJ0V2FzRGlzcGF0Y2hlZCkge1xuXHRcdFx0dGhpcy5fc2VuZExvYWRTdGFydCgpO1xuXHRcdFx0dGhpcy5fbG9hZFN0YXJ0V2FzRGlzcGF0Y2hlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHF1ZXVlIGhhcyBjb21wbGV0ZWQuXG5cdFx0aWYgKHRoaXMuX251bUl0ZW1zID09IHRoaXMuX251bUl0ZW1zTG9hZGVkKSB7XG5cdFx0XHR0aGlzLmxvYWRlZCA9IHRydWU7XG5cdFx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblxuXHRcdFx0Ly8gTG9hZCB0aGUgbmV4dCBxdWV1ZSwgaWYgaXQgaGFzIGJlZW4gZGVmaW5lZC5cblx0XHRcdGlmICh0aGlzLm5leHQgJiYgdGhpcy5uZXh0LmxvYWQpIHtcblx0XHRcdFx0dGhpcy5uZXh0LmxvYWQoKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5sb2FkZWQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBNdXN0IGl0ZXJhdGUgZm9yd2FyZHMgdG8gbG9hZCBpbiB0aGUgcmlnaHQgb3JkZXIuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sb2FkUXVldWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLl9jdXJyZW50TG9hZHMubGVuZ3RoID49IHRoaXMuX21heENvbm5lY3Rpb25zKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGxvYWRlciA9IHRoaXMuX2xvYWRRdWV1ZVtpXTtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBiZSBvbmx5IGxvYWRpbmcgb25lIHRhZy1zY3JpcHQgYXQgYSB0aW1lOlxuXHRcdFx0Ly8gTm90ZTogbWFpbnRhaW5PcmRlciBpdGVtcyBkb24ndCBkbyBhbnl0aGluZyBoZXJlIGJlY2F1c2Ugd2UgY2FuIGhvbGQgb250byB0aGVpciBsb2FkZWQgdmFsdWVcblx0XHRcdGlmICghdGhpcy5fY2FuU3RhcnRMb2FkKGxvYWRlcikpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9sb2FkUXVldWUuc3BsaWNlKGksIDEpO1xuXHRcdFx0aS0tO1xuXHRcdFx0dGhpcy5fbG9hZEl0ZW0obG9hZGVyKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2luIGxvYWRpbmcgYW4gaXRlbS4gRXZlbnQgbGlzdGVuZXJzIGFyZSBub3QgYWRkZWQgdG8gdGhlIGxvYWRlcnMgdW50aWwgdGhlIGxvYWQgc3RhcnRzLlxuXHQgKiBAbWV0aG9kIF9sb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXIgVGhlIGxvYWRlciBpbnN0YW5jZSB0byBzdGFydC4gQ3VycmVudGx5LCB0aGlzIHdpbGwgYmUgYW4gWEhSTG9hZGVyIG9yIFRhZ0xvYWRlci5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2xvYWRJdGVtID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdGxvYWRlci5vbihcImZpbGVsb2FkXCIsIHRoaXMuX2hhbmRsZUZpbGVMb2FkLCB0aGlzKTtcblx0XHRsb2FkZXIub24oXCJwcm9ncmVzc1wiLCB0aGlzLl9oYW5kbGVQcm9ncmVzcywgdGhpcyk7XG5cdFx0bG9hZGVyLm9uKFwiY29tcGxldGVcIiwgdGhpcy5faGFuZGxlRmlsZUNvbXBsZXRlLCB0aGlzKTtcblx0XHRsb2FkZXIub24oXCJlcnJvclwiLCB0aGlzLl9oYW5kbGVFcnJvciwgdGhpcyk7XG5cdFx0bG9hZGVyLm9uKFwiZmlsZWVycm9yXCIsIHRoaXMuX2hhbmRsZUZpbGVFcnJvciwgdGhpcyk7XG5cdFx0dGhpcy5fY3VycmVudExvYWRzLnB1c2gobG9hZGVyKTtcblx0XHR0aGlzLl9zZW5kRmlsZVN0YXJ0KGxvYWRlci5nZXRJdGVtKCkpO1xuXHRcdGxvYWRlci5sb2FkKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBjYWxsYmFjayB0aGF0IGlzIGZpcmVkIHdoZW4gYSBsb2FkZXIgbG9hZHMgYSBmaWxlLiBUaGlzIGVuYWJsZXMgbG9hZGVycyBsaWtlIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHRvIG1haW50YWluIGludGVybmFsIHF1ZXVlcywgYnV0IGZvciB0aGlzIHF1ZXVlIHRvIGRpc3BhdGNoIHRoZSB7eyNjcm9zc0xpbmsgXCJmaWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudHMuXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBmcm9tIHRoZSBsb2FkZXIuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5faGFuZGxlRmlsZUxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC50YXJnZXQgPSBudWxsO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBjYWxsYmFjayB0aGF0IGlzIGZpcmVkIHdoZW4gYSBsb2FkZXIgZW5jb3VudGVycyBhbiBlcnJvciBmcm9tIGFuIGludGVybmFsIGZpbGUgbG9hZCBvcGVyYXRpb24uIFRoaXMgZW5hYmxlc1xuXHQgKiBsb2FkZXJzIGxpa2UgTVxuXHQgKiBAcGFyYW0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZUZpbGVFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiRklMRV9MT0FEX0VSUk9SXCIsIG51bGwsIGV2ZW50Lml0ZW0pO1xuXHRcdHRoaXMuX3NlbmRFcnJvcihuZXdFdmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBjYWxsYmFjayB0aGF0IGlzIGZpcmVkIHdoZW4gYSBsb2FkZXIgZW5jb3VudGVycyBhbiBlcnJvci4gVGhlIHF1ZXVlIHdpbGwgY29udGludWUgbG9hZGluZyB1bmxlc3Mge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3N0b3BPbkVycm9yOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGlzIHNldCB0byBgdHJ1ZWAuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUVycm9yXG5cdCAqIEBwYXJhbSB7RXJyb3JFdmVudH0gZXZlbnQgVGhlIGVycm9yIGV2ZW50LCBjb250YWluaW5nIHJlbGV2YW50IGVycm9yIGluZm9ybWF0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgbG9hZGVyID0gZXZlbnQudGFyZ2V0O1xuXHRcdHRoaXMuX251bUl0ZW1zTG9hZGVkKys7XG5cblx0XHR0aGlzLl9maW5pc2hPcmRlcmVkSXRlbShsb2FkZXIsIHRydWUpO1xuXHRcdHRoaXMuX3VwZGF0ZVByb2dyZXNzKCk7XG5cblx0XHR2YXIgbmV3RXZlbnQgPSBuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIkZJTEVfTE9BRF9FUlJPUlwiLCBudWxsLCBsb2FkZXIuZ2V0SXRlbSgpKTtcblx0XHQvLyBUT0RPOiBQcm9wYWdhdGUgYWN0dWFsIGVycm9yIG1lc3NhZ2UuXG5cblx0XHR0aGlzLl9zZW5kRXJyb3IobmV3RXZlbnQpO1xuXG5cdFx0aWYgKCF0aGlzLnN0b3BPbkVycm9yKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVMb2FkSXRlbShsb2FkZXIpO1xuXHRcdFx0dGhpcy5fY2xlYW5Mb2FkSXRlbShsb2FkZXIpO1xuXHRcdFx0dGhpcy5fbG9hZE5leHQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRQYXVzZWQodHJ1ZSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbiBpdGVtIGhhcyBmaW5pc2hlZCBsb2FkaW5nLiBXZSBjYW4gYXNzdW1lIHRoYXQgaXQgaXMgdG90YWxseSBsb2FkZWQsIGhhcyBiZWVuIHBhcnNlZCBmb3IgaW1tZWRpYXRlIHVzZSwgYW5kXG5cdCAqIGlzIGF2YWlsYWJsZSBhcyB0aGUgXCJyZXN1bHRcIiBwcm9wZXJ0eSBvbiB0aGUgbG9hZCBpdGVtLiBUaGUgcmF3IHRleHQgcmVzdWx0IGZvciBhIHBhcnNlZCBpdGVtIChzdWNoIGFzIEpTT04sIFhNTCxcblx0ICogQ1NTLCBKYXZhU2NyaXB0LCBldGMpIGlzIGF2YWlsYWJsZSBhcyB0aGUgXCJyYXdSZXN1bHRcIiBwcm9wZXJ0eSwgYW5kIGNhbiBhbHNvIGJlIGxvb2tlZCB1cCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZ2V0UmVzdWx0XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVGaWxlQ29tcGxldGVcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IG9iamVjdCBmcm9tIHRoZSBsb2FkZXIuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVGaWxlQ29tcGxldGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgbG9hZGVyID0gZXZlbnQudGFyZ2V0O1xuXHRcdHZhciBpdGVtID0gbG9hZGVyLmdldEl0ZW0oKTtcblxuXHRcdHZhciByZXN1bHQgPSBsb2FkZXIuZ2V0UmVzdWx0KCk7XG5cdFx0dGhpcy5fbG9hZGVkUmVzdWx0c1tpdGVtLmlkXSA9IHJlc3VsdDtcblx0XHR2YXIgcmF3UmVzdWx0ID0gbG9hZGVyLmdldFJlc3VsdCh0cnVlKTtcblx0XHRpZiAocmF3UmVzdWx0ICE9IG51bGwgJiYgcmF3UmVzdWx0ICE9PSByZXN1bHQpIHtcblx0XHRcdHRoaXMuX2xvYWRlZFJhd1Jlc3VsdHNbaXRlbS5pZF0gPSByYXdSZXN1bHQ7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2F2ZUxvYWRlZEl0ZW1zKGxvYWRlcik7XG5cblx0XHQvLyBSZW1vdmUgdGhlIGxvYWQgaXRlbVxuXHRcdHRoaXMuX3JlbW92ZUxvYWRJdGVtKGxvYWRlcik7XG5cblx0XHRpZiAoIXRoaXMuX2ZpbmlzaE9yZGVyZWRJdGVtKGxvYWRlcikpIHtcblx0XHRcdC8vIFRoZSBpdGVtIHdhcyBOT1QgbWFuYWdlZCwgc28gcHJvY2VzcyBpdCBub3dcblx0XHRcdHRoaXMuX3Byb2Nlc3NGaW5pc2hlZExvYWQoaXRlbSwgbG9hZGVyKTtcblx0XHR9XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgbG9hZCBpdGVtXG5cdFx0dGhpcy5fY2xlYW5Mb2FkSXRlbShsb2FkZXIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTb21lIGxvYWRlcnMgbWlnaHQgbG9hZCBhZGRpdGlvbmFsIGNvbnRlbnQsIG90aGVyIHRoYW4gdGhlIGl0ZW0gdGhleSB3ZXJlIHBhc3NlZCAoc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fSkuXG5cdCAqIEFueSBpdGVtcyBleHBvc2VkIGJ5IHRoZSBsb2FkZXIgdXNpbmcge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvZ2V0TG9hZEl0ZW1zXCJ9fXt7L2Nyb3NzTGlua319IGFyZSBhZGRlZCB0byB0aGVcblx0ICogTG9hZFF1ZXVlJ3MgbG9vay11cHMsIGluY2x1ZGluZyB7eyNjcm9zc0xpbmsgXCJnZXRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJnZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kcy5cblx0ICogQG1ldGhvZCBfc2F2ZUxvYWRlZEl0ZW1zXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5fc2F2ZUxvYWRlZEl0ZW1zID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdC8vIFRPRE86IE5vdCBzdXJlIGhvdyB0byBoYW5kbGUgdGhpcy4gV291bGQgYmUgbmljZSB0byBleHBvc2UgdGhlIGl0ZW1zLlxuXHRcdC8vIExvYWRlcnMgbWF5IGxvYWQgc3ViLWl0ZW1zLiBUaGlzIGFkZHMgdGhlbSB0byB0aGlzIHF1ZXVlXG5cdFx0dmFyIGxpc3QgPSBsb2FkZXIuZ2V0TG9hZGVkSXRlbXMoKTtcblx0XHRpZiAobGlzdCA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBsaXN0W2ldLml0ZW07XG5cblx0XHRcdC8vIFN0b3JlIGl0ZW0gbG9va3Vwc1xuXHRcdFx0dGhpcy5fbG9hZEl0ZW1zQnlTcmNbaXRlbS5zcmNdID0gaXRlbTtcblx0XHRcdHRoaXMuX2xvYWRJdGVtc0J5SWRbaXRlbS5pZF0gPSBpdGVtO1xuXG5cdFx0XHQvLyBTdG9yZSBsb2FkZWQgY29udGVudFxuXHRcdFx0dGhpcy5fbG9hZGVkUmVzdWx0c1tpdGVtLmlkXSA9IGxpc3RbaV0ucmVzdWx0O1xuXHRcdFx0dGhpcy5fbG9hZGVkUmF3UmVzdWx0c1tpdGVtLmlkXSA9IGxpc3RbaV0ucmF3UmVzdWx0O1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRmxhZyBhbiBpdGVtIGFzIGZpbmlzaGVkLiBJZiB0aGUgaXRlbSdzIG9yZGVyIGlzIGJlaW5nIG1hbmFnZWQsIHRoZW4gZW5zdXJlIHRoYXQgaXQgaXMgYWxsb3dlZCB0byBmaW5pc2gsIGFuZCBpZlxuXHQgKiBzbywgdHJpZ2dlciBwcmlvciBpdGVtcyB0byB0cmlnZ2VyIGFzIHdlbGwuXG5cdCAqIEBtZXRob2QgX2ZpbmlzaE9yZGVyZWRJdGVtXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGxvYWRGYWlsZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIGl0ZW0ncyBvcmRlciBpcyBiZWluZyBtYW5hZ2VkLiBUaGlzIGFsbG93cyB0aGUgY2FsbGVyIHRvIHRha2UgYW4gYWx0ZXJuYXRlXG5cdCAqIGJlaGF2aW91ciBpZiBpdCBpcy5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2ZpbmlzaE9yZGVyZWRJdGVtID0gZnVuY3Rpb24gKGxvYWRlciwgbG9hZEZhaWxlZCkge1xuXHRcdHZhciBpdGVtID0gbG9hZGVyLmdldEl0ZW0oKTtcblxuXHRcdGlmICgodGhpcy5tYWludGFpblNjcmlwdE9yZGVyICYmIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5Mb2FkUXVldWUuSkFWQVNDUklQVClcblx0XHRcdFx0fHwgaXRlbS5tYWludGFpbk9yZGVyKSB7XG5cblx0XHRcdC8vVE9ETzogRXZhbHVhdGUgcmVtb3ZhbCBvZiB0aGUgX2N1cnJlbnRseUxvYWRpbmdTY3JpcHRcblx0XHRcdGlmIChsb2FkZXIgaW5zdGFuY2VvZiBjcmVhdGVqcy5KYXZhU2NyaXB0TG9hZGVyKSB7XG5cdFx0XHRcdHRoaXMuX2N1cnJlbnRseUxvYWRpbmdTY3JpcHQgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGluZGV4ID0gY3JlYXRlanMuaW5kZXhPZih0aGlzLl9zY3JpcHRPcmRlciwgaXRlbSk7XG5cdFx0XHRpZiAoaW5kZXggPT0gLTEpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSAvLyBUaGlzIGxvYWRlciBubyBsb25nZXIgZXhpc3RzXG5cdFx0XHR0aGlzLl9sb2FkZWRTY3JpcHRzW2luZGV4XSA9IChsb2FkRmFpbGVkID09PSB0cnVlKSA/IHRydWUgOiBpdGVtO1xuXG5cdFx0XHR0aGlzLl9jaGVja1NjcmlwdExvYWRPcmRlcigpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbnN1cmUgdGhlIHNjcmlwdHMgbG9hZCBhbmQgZGlzcGF0Y2ggaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIFdoZW4gdXNpbmcgWEhSLCBzY3JpcHRzIGFyZSBzdG9yZWQgaW4gYW4gYXJyYXkgaW4gdGhlXG5cdCAqIG9yZGVyIHRoZXkgd2VyZSBhZGRlZCwgYnV0IHdpdGggYSBcIm51bGxcIiB2YWx1ZS4gV2hlbiB0aGV5IGFyZSBjb21wbGV0ZWQsIHRoZSB2YWx1ZSBpcyBzZXQgdG8gdGhlIGxvYWQgaXRlbSxcblx0ICogYW5kIHRoZW4gd2hlbiB0aGV5IGFyZSBwcm9jZXNzZWQgYW5kIGRpc3BhdGNoZWQsIHRoZSB2YWx1ZSBpcyBzZXQgdG8gYHRydWVgLiBUaGlzIG1ldGhvZCBzaW1wbHlcblx0ICogaXRlcmF0ZXMgdGhlIGFycmF5LCBhbmQgZW5zdXJlcyB0aGF0IGFueSBsb2FkZWQgaXRlbXMgdGhhdCBhcmUgbm90IHByZWNlZGVkIGJ5IGEgYG51bGxgIHZhbHVlIGFyZVxuXHQgKiBkaXNwYXRjaGVkLlxuXHQgKiBAbWV0aG9kIF9jaGVja1NjcmlwdExvYWRPcmRlclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY2hlY2tTY3JpcHRMb2FkT3JkZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGwgPSB0aGlzLl9sb2FkZWRTY3JpcHRzLmxlbmd0aDtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHRoaXMuX2xvYWRlZFNjcmlwdHNbaV07XG5cdFx0XHRpZiAoaXRlbSA9PT0gbnVsbCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH0gLy8gVGhpcyBpcyBzdGlsbCBsb2FkaW5nLiBEbyBub3QgcHJvY2VzcyBmdXJ0aGVyLlxuXHRcdFx0aWYgKGl0ZW0gPT09IHRydWUpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9IC8vIFRoaXMgaGFzIGNvbXBsZXRlZCwgYW5kIGJlZW4gcHJvY2Vzc2VkLiBNb3ZlIG9uLlxuXG5cdFx0XHR2YXIgbG9hZEl0ZW0gPSB0aGlzLl9sb2FkZWRSZXN1bHRzW2l0ZW0uaWRdO1xuXHRcdFx0aWYgKGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5Mb2FkUXVldWUuSkFWQVNDUklQVCkge1xuXHRcdFx0XHQvLyBBcHBlbmQgc2NyaXB0IHRhZ3MgdG8gdGhlIGhlYWQgYXV0b21hdGljYWxseS5cblx0XHRcdFx0Y3JlYXRlanMuRG9tVXRpbHMuYXBwZW5kVG9IZWFkKGxvYWRJdGVtKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGxvYWRlciA9IGl0ZW0uX2xvYWRlcjtcblx0XHRcdHRoaXMuX3Byb2Nlc3NGaW5pc2hlZExvYWQoaXRlbSwgbG9hZGVyKTtcblx0XHRcdHRoaXMuX2xvYWRlZFNjcmlwdHNbaV0gPSB0cnVlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQSBmaWxlIGhhcyBjb21wbGV0ZWQgbG9hZGluZywgYW5kIHRoZSBMb2FkUXVldWUgY2FuIG1vdmUgb24uIFRoaXMgdHJpZ2dlcnMgdGhlIGNvbXBsZXRlIGV2ZW50LCBhbmQga2ljay1zdGFydHNcblx0ICogdGhlIG5leHQgaXRlbS5cblx0ICogQG1ldGhvZCBfcHJvY2Vzc0ZpbmlzaGVkTG9hZFxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbVxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fcHJvY2Vzc0ZpbmlzaGVkTG9hZCA9IGZ1bmN0aW9uIChpdGVtLCBsb2FkZXIpIHtcblx0XHR0aGlzLl9udW1JdGVtc0xvYWRlZCsrO1xuXG5cdFx0Ly8gU2luY2UgTG9hZFF1ZXVlIG5lZWRzIG1haW50YWluIG9yZGVyLCB3ZSBjYW4ndCBhcHBlbmQgc2NyaXB0cyBpbiB0aGUgbG9hZGVyLlxuXHRcdC8vIFNvIHdlIGRvIGl0IGhlcmUgaW5zdGVhZC4gT3IgaW4gX2NoZWNrU2NyaXB0TG9hZE9yZGVyKCk7XG5cdFx0aWYgKCF0aGlzLm1haW50YWluU2NyaXB0T3JkZXIgJiYgaXRlbS50eXBlID09IGNyZWF0ZWpzLkxvYWRRdWV1ZS5KQVZBU0NSSVBUKSB7XG5cdFx0XHRjcmVhdGVqcy5Eb21VdGlscy5hcHBlbmRUb0hlYWQoaXRlbS5yZXN1bHQpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZVByb2dyZXNzKCk7XG5cdFx0dGhpcy5fc2VuZEZpbGVDb21wbGV0ZShpdGVtLCBsb2FkZXIpO1xuXHRcdHRoaXMuX2xvYWROZXh0KCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuc3VyZSBpdGVtcyB3aXRoIGBtYWludGFpbk9yZGVyPXRydWVgIHRoYXQgYXJlIGJlZm9yZSB0aGUgc3BlY2lmaWVkIGl0ZW0gaGF2ZSBsb2FkZWQuIFRoaXMgb25seSBhcHBsaWVzIHRvXG5cdCAqIEphdmFTY3JpcHQgaXRlbXMgdGhhdCBhcmUgYmVpbmcgbG9hZGVkIHdpdGggYSBUYWdMb2FkZXIsIHNpbmNlIHRoZXkgaGF2ZSB0byBiZSBsb2FkZWQgYW5kIGNvbXBsZXRlZCA8c3Ryb25nPmJlZm9yZTwvc3Ryb25nPlxuXHQgKiB0aGUgc2NyaXB0IGNhbiBldmVuIGJlIHN0YXJ0ZWQsIHNpbmNlIGl0IGV4aXN0IGluIHRoZSBET00gd2hpbGUgbG9hZGluZy5cblx0ICogQG1ldGhvZCBfY2FuU3RhcnRMb2FkXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlciBUaGUgbG9hZGVyIGZvciB0aGUgaXRlbVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBpdGVtIGNhbiBzdGFydCBhIGxvYWQgb3Igbm90LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY2FuU3RhcnRMb2FkID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdGlmICghdGhpcy5tYWludGFpblNjcmlwdE9yZGVyIHx8IGxvYWRlci5wcmVmZXJYSFIpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHR2YXIgaXRlbSA9IGxvYWRlci5nZXRJdGVtKCk7XG5cdFx0aWYgKGl0ZW0udHlwZSAhPSBjcmVhdGVqcy5Mb2FkUXVldWUuSkFWQVNDUklQVCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9jdXJyZW50bHlMb2FkaW5nU2NyaXB0KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIGluZGV4ID0gdGhpcy5fc2NyaXB0T3JkZXIuaW5kZXhPZihpdGVtKTtcblx0XHR2YXIgaSA9IDA7XG5cdFx0d2hpbGUgKGkgPCBpbmRleCkge1xuXHRcdFx0dmFyIGNoZWNrSXRlbSA9IHRoaXMuX2xvYWRlZFNjcmlwdHNbaV07XG5cdFx0XHRpZiAoY2hlY2tJdGVtID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aSsrO1xuXHRcdH1cblx0XHR0aGlzLl9jdXJyZW50bHlMb2FkaW5nU2NyaXB0ID0gdHJ1ZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQSBsb2FkIGl0ZW0gaXMgY29tcGxldGVkIG9yIHdhcyBjYW5jZWxlZCwgYW5kIG5lZWRzIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgTG9hZFF1ZXVlLlxuXHQgKiBAbWV0aG9kIF9yZW1vdmVMb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXIgQSBsb2FkZXIgaW5zdGFuY2UgdG8gcmVtb3ZlLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fcmVtb3ZlTG9hZEl0ZW0gPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0dmFyIGwgPSB0aGlzLl9jdXJyZW50TG9hZHMubGVuZ3RoO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAodGhpcy5fY3VycmVudExvYWRzW2ldID09IGxvYWRlcikge1xuXHRcdFx0XHR0aGlzLl9jdXJyZW50TG9hZHMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSB1bm5lZWRlZCByZWZlcmVuY2VzIGZyb20gYSBsb2FkZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSBsb2FkZXJcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NsZWFuTG9hZEl0ZW0gPSBmdW5jdGlvbihsb2FkZXIpIHtcblx0XHR2YXIgaXRlbSA9IGxvYWRlci5nZXRJdGVtKCk7XG5cdFx0aWYgKGl0ZW0pIHtcblx0XHRcdGRlbGV0ZSBpdGVtLl9sb2FkZXI7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEFuIGl0ZW0gaGFzIGRpc3BhdGNoZWQgcHJvZ3Jlc3MuIFByb3BhZ2F0ZSB0aGF0IHByb2dyZXNzLCBhbmQgdXBkYXRlIHRoZSBMb2FkUXVldWUncyBvdmVyYWxsIHByb2dyZXNzLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVQcm9ncmVzc1xuXHQgKiBAcGFyYW0ge1Byb2dyZXNzRXZlbnR9IGV2ZW50IFRoZSBwcm9ncmVzcyBldmVudCBmcm9tIHRoZSBpdGVtLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgbG9hZGVyID0gZXZlbnQudGFyZ2V0O1xuXHRcdHRoaXMuX3NlbmRGaWxlUHJvZ3Jlc3MobG9hZGVyLmdldEl0ZW0oKSwgbG9hZGVyLnByb2dyZXNzKTtcblx0XHR0aGlzLl91cGRhdGVQcm9ncmVzcygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBPdmVyYWxsIHByb2dyZXNzIGhhcyBjaGFuZ2VkLCBzbyBkZXRlcm1pbmUgdGhlIG5ldyBwcm9ncmVzcyBhbW91bnQgYW5kIGRpc3BhdGNoIGl0LiBUaGlzIGNoYW5nZXMgYW55IHRpbWUgYW5cblx0ICogaXRlbSBkaXNwYXRjaGVzIHByb2dyZXNzIG9yIGNvbXBsZXRlcy4gTm90ZSB0aGF0IHNpbmNlIHdlIGRvbid0IGFsd2F5cyBrbm93IHRoZSBhY3R1YWwgZmlsZXNpemUgb2YgaXRlbXMgYmVmb3JlXG5cdCAqIHRoZXkgYXJlIGxvYWRlZC4gSW4gdGhpcyBjYXNlLCB3ZSBkZWZpbmUgYSBcInNsb3RcIiBmb3IgZWFjaCBpdGVtICgxIGl0ZW0gaW4gMTAgd291bGQgZ2V0IDEwJSksIGFuZCB0aGVuIGFwcGVuZFxuXHQgKiBsb2FkZWQgcHJvZ3Jlc3Mgb24gdG9wIG9mIHRoZSBhbHJlYWR5LWxvYWRlZCBpdGVtcy5cblx0ICpcblx0ICogRm9yIGV4YW1wbGUsIGlmIDUvMTAgaXRlbXMgaGF2ZSBsb2FkZWQsIGFuZCBpdGVtIDYgaXMgMjAlIGxvYWRlZCwgdGhlIHRvdGFsIHByb2dyZXNzIHdvdWxkIGJlOlxuXHQgKiA8dWw+XG5cdCAqICAgICAgPGxpPjUvMTAgb2YgdGhlIGl0ZW1zIGluIHRoZSBxdWV1ZSAoNTAlKTwvbGk+XG5cdCAqICAgICAgPGxpPnBsdXMgMjAlIG9mIGl0ZW0gNidzIHNsb3QgKDIlKTwvbGk+XG5cdCAqICAgICAgPGxpPmVxdWFscyA1MiU8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBAbWV0aG9kIF91cGRhdGVQcm9ncmVzc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fdXBkYXRlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGxvYWRlZCA9IHRoaXMuX251bUl0ZW1zTG9hZGVkIC8gdGhpcy5fbnVtSXRlbXM7IC8vIEZ1bGx5IExvYWRlZCBQcm9ncmVzc1xuXHRcdHZhciByZW1haW5pbmcgPSB0aGlzLl9udW1JdGVtcyAtIHRoaXMuX251bUl0ZW1zTG9hZGVkO1xuXHRcdGlmIChyZW1haW5pbmcgPiAwKSB7XG5cdFx0XHR2YXIgY2h1bmsgPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jdXJyZW50TG9hZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNodW5rICs9IHRoaXMuX2N1cnJlbnRMb2Fkc1tpXS5wcm9ncmVzcztcblx0XHRcdH1cblx0XHRcdGxvYWRlZCArPSAoY2h1bmsgLyByZW1haW5pbmcpICogKHJlbWFpbmluZyAvIHRoaXMuX251bUl0ZW1zKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbGFzdFByb2dyZXNzICE9IGxvYWRlZCkge1xuXHRcdFx0dGhpcy5fc2VuZFByb2dyZXNzKGxvYWRlZCk7XG5cdFx0XHR0aGlzLl9sYXN0UHJvZ3Jlc3MgPSBsb2FkZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiBvdXQgaXRlbSByZXN1bHRzLCB0byBmcmVlIHRoZW0gZnJvbSBtZW1vcnkuIE1haW5seSwgdGhlIGxvYWRlZCBpdGVtIGFuZCByZXN1bHRzIGFyZSBjbGVhcmVkIGZyb20gaW50ZXJuYWxcblx0ICogaGFzaGVzLlxuXHQgKiBAbWV0aG9kIF9kaXNwb3NlSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgaXRlbSB0aGF0IHdhcyBwYXNzZWQgaW4gZm9yIHByZWxvYWRpbmcuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9kaXNwb3NlSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0ZGVsZXRlIHRoaXMuX2xvYWRlZFJlc3VsdHNbaXRlbS5pZF07XG5cdFx0ZGVsZXRlIHRoaXMuX2xvYWRlZFJhd1Jlc3VsdHNbaXRlbS5pZF07XG5cdFx0ZGVsZXRlIHRoaXMuX2xvYWRJdGVtc0J5SWRbaXRlbS5pZF07XG5cdFx0ZGVsZXRlIHRoaXMuX2xvYWRJdGVtc0J5U3JjW2l0ZW0uc3JjXTtcblx0fTtcblxuXHQvKipcblx0ICogRGlzcGF0Y2ggYSBcImZpbGVwcm9ncmVzc1wiIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LiBQbGVhc2Ugc2VlIHRoZSBMb2FkUXVldWUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVwcm9ncmVzczpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBmb3IgZGV0YWlscyBvbiB0aGUgZXZlbnQgcGF5bG9hZC5cblx0ICogQG1ldGhvZCBfc2VuZEZpbGVQcm9ncmVzc1xuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgaXRlbSB0aGF0IGlzIGJlaW5nIGxvYWRlZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHByb2dyZXNzIFRoZSBhbW91bnQgdGhlIGl0ZW0gaGFzIGJlZW4gbG9hZGVkIChiZXR3ZWVuIDAgYW5kIDEpLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZW5kRmlsZVByb2dyZXNzID0gZnVuY3Rpb24gKGl0ZW0sIHByb2dyZXNzKSB7XG5cdFx0aWYgKHRoaXMuX2lzQ2FuY2VsZWQoKSB8fCB0aGlzLl9wYXVzZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCF0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJmaWxlcHJvZ3Jlc3NcIikpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvL0xNOiBSZXdvcmsgUHJvZ3Jlc3NFdmVudCB0byBzdXBwb3J0IHRoaXM/XG5cdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiZmlsZXByb2dyZXNzXCIpO1xuXHRcdGV2ZW50LnByb2dyZXNzID0gcHJvZ3Jlc3M7XG5cdFx0ZXZlbnQubG9hZGVkID0gcHJvZ3Jlc3M7XG5cdFx0ZXZlbnQudG90YWwgPSAxO1xuXHRcdGV2ZW50Lml0ZW0gPSBpdGVtO1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRGlzcGF0Y2ggYSBmaWxlbG9hZCB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGZvclxuXHQgKiBkZXRhaWxzIG9uIHRoZSBldmVudCBwYXlsb2FkLlxuXHQgKiBAbWV0aG9kIF9zZW5kRmlsZUNvbXBsZXRlXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW1PYmplY3R9IGl0ZW0gVGhlIGl0ZW0gdGhhdCBpcyBiZWluZyBsb2FkZWQuXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZW5kRmlsZUNvbXBsZXRlID0gZnVuY3Rpb24gKGl0ZW0sIGxvYWRlcikge1xuXHRcdGlmICh0aGlzLl9pc0NhbmNlbGVkKCkgfHwgdGhpcy5fcGF1c2VkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiZmlsZWxvYWRcIik7XG5cdFx0ZXZlbnQubG9hZGVyID0gbG9hZGVyO1xuXHRcdGV2ZW50Lml0ZW0gPSBpdGVtO1xuXHRcdGV2ZW50LnJlc3VsdCA9IHRoaXMuX2xvYWRlZFJlc3VsdHNbaXRlbS5pZF07XG5cdFx0ZXZlbnQucmF3UmVzdWx0ID0gdGhpcy5fbG9hZGVkUmF3UmVzdWx0c1tpdGVtLmlkXTtcblxuXHRcdC8vIFRoaXMgY2FsbHMgYSBoYW5kbGVyIHNwZWNpZmllZCBvbiB0aGUgYWN0dWFsIGxvYWQgaXRlbS4gQ3VycmVudGx5LCB0aGUgU291bmRKUyBwbHVnaW4gdXNlcyB0aGlzLlxuXHRcdGlmIChpdGVtLmNvbXBsZXRlSGFuZGxlcikge1xuXHRcdFx0aXRlbS5jb21wbGV0ZUhhbmRsZXIoZXZlbnQpO1xuXHRcdH1cblxuXHRcdHRoaXMuaGFzRXZlbnRMaXN0ZW5lcihcImZpbGVsb2FkXCIpICYmIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoIGEgZmlsZXN0YXJ0IHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGltbWVkaWF0ZWx5IGJlZm9yZSBhIGZpbGUgc3RhcnRzIHRvIGxvYWQuIFBsZWFzZSBzZWVcblx0ICogdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlc3RhcnQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgZm9yIGRldGFpbHMgb24gdGhlIGV2ZW50IHBheWxvYWQuXG5cdCAqIEBtZXRob2QgX3NlbmRGaWxlU3RhcnRcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIGl0ZW0gdGhhdCBpcyBiZWluZyBsb2FkZWQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3NlbmRGaWxlU3RhcnQgPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVzdGFydFwiKTtcblx0XHRldmVudC5pdGVtID0gaXRlbTtcblx0XHR0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJmaWxlc3RhcnRcIikgJiYgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltQcmVsb2FkSlMgTG9hZFF1ZXVlXVwiO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkxvYWRRdWV1ZSA9IGNyZWF0ZWpzLnByb21vdGUoTG9hZFF1ZXVlLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFRleHRMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIFRleHQgZmlsZXMuXG5cdCAqIEBjbGFzcyBUZXh0TG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFRleHRMb2FkZXIobG9hZEl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCB0cnVlLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5URVhUKTtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChUZXh0TG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gVGV4dExvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgbG9hZHMgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9URVhUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBidXQgaXMgYWxzbyB0aGUgZGVmYXVsdCBsb2FkZXIgaWYgYSBmaWxlIHR5cGUgY2FuIG5vdCBiZSBkZXRlcm1pbmVkLlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlRFWFQ7XG5cdH07XG5cblx0Y3JlYXRlanMuVGV4dExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoVGV4dExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEJpbmFyeUxvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgYmluYXJ5IGZpbGVzLiBUaGlzIGlzIHVzZWZ1bCBmb3IgbG9hZGluZyB3ZWIgYXVkaW8sIG9yIGNvbnRlbnQgdGhhdCByZXF1aXJlcyBhbiBBcnJheUJ1ZmZlci5cblx0ICogQGNsYXNzIEJpbmFyeUxvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBCaW5hcnlMb2FkZXIobG9hZEl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCB0cnVlLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5CSU5BUlkpO1xuXHRcdHRoaXMub24oXCJpbml0aWFsaXplXCIsIHRoaXMuX3VwZGF0ZVhIUiwgdGhpcyk7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQmluYXJ5TG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gQmluYXJ5TG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvQklOQVJZOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuQklOQVJZO1xuXHR9O1xuXG5cdC8vIHByaXZhdGUgbWV0aG9kc1xuXHQvKipcblx0ICogQmVmb3JlIHRoZSBpdGVtIGxvYWRzLCBzZXQgdGhlIHJlc3BvbnNlIHR5cGUgdG8gXCJhcnJheWJ1ZmZlclwiXG5cdCAqIEBwcm9wZXJ0eSBfdXBkYXRlWEhSXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl91cGRhdGVYSFIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC5sb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XG5cdH07XG5cblx0Y3JlYXRlanMuQmluYXJ5TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShCaW5hcnlMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBDU1NMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIENTUyBmaWxlcy5cblx0ICogQGNsYXNzIENTU0xvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBDU1NMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuQ1NTKTtcblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5yZXN1bHRGb3JtYXR0ZXIgPSB0aGlzLl9mb3JtYXRSZXN1bHQ7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSA9IFwiaHJlZlwiO1xuXG5cdFx0aWYgKHByZWZlclhIUikge1xuXHRcdFx0dGhpcy5fdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl90YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblx0XHR9XG5cblx0XHR0aGlzLl90YWcucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cdFx0dGhpcy5fdGFnLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQ1NTTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gQ1NTTG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvQ1NTOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkNTUztcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIENTUyBmaWxlcy5cblx0ICogQG1ldGhvZCBfZm9ybWF0UmVzdWx0XG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcmV0dXJucyB7SFRNTExpbmtFbGVtZW50fEhUTUxTdHlsZUVsZW1lbnR9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9mb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0aWYgKHRoaXMuX3ByZWZlclhIUikge1xuXHRcdFx0dmFyIHRhZyA9IGxvYWRlci5nZXRUYWcoKTtcblxuXHRcdFx0aWYgKHRhZy5zdHlsZVNoZWV0KSB7IC8vIElFXG5cdFx0XHRcdHRhZy5zdHlsZVNoZWV0LmNzc1RleHQgPSBsb2FkZXIuZ2V0UmVzdWx0KHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobG9hZGVyLmdldFJlc3VsdCh0cnVlKSk7XG5cdFx0XHRcdHRhZy5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhZyA9IHRoaXMuX3RhZztcblx0XHR9XG5cblx0XHRjcmVhdGVqcy5Eb21VdGlscy5hcHBlbmRUb0hlYWQodGFnKTtcblxuXHRcdHJldHVybiB0YWc7XG5cdH07XG5cblx0Y3JlYXRlanMuQ1NTTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShDU1NMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBJbWFnZUxvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgaW1hZ2UgZmlsZXMuXG5cdCAqIEBjbGFzcyBJbWFnZUxvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBJbWFnZUxvYWRlciAobG9hZEl0ZW0sIHByZWZlclhIUikge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSU1BR0UpO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IHRoaXMuX2Zvcm1hdFJlc3VsdDtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5fdGFnU3JjQXR0cmlidXRlID0gXCJzcmNcIjtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBwcmVsb2FkIGl0ZW0gaXMgYWxyZWFkeSBhIHRhZy5cblx0XHRpZiAoY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzSW1hZ2VUYWcobG9hZEl0ZW0pKSB7XG5cdFx0XHR0aGlzLl90YWcgPSBsb2FkSXRlbTtcblx0XHR9IGVsc2UgaWYgKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0ltYWdlVGFnKGxvYWRJdGVtLnNyYykpIHtcblx0XHRcdHRoaXMuX3RhZyA9IGxvYWRJdGVtLnNyYztcblx0XHR9IGVsc2UgaWYgKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0ltYWdlVGFnKGxvYWRJdGVtLnRhZykpIHtcblx0XHRcdHRoaXMuX3RhZyA9IGxvYWRJdGVtLnRhZztcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fdGFnICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3ByZWZlclhIUiA9IGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl90YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuXHRcdH1cblxuXHRcdHRoaXMub24oXCJpbml0aWFsaXplXCIsIHRoaXMuX3VwZGF0ZVhIUiwgdGhpcyk7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoSW1hZ2VMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBJbWFnZUxvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0lNQUdFOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLklNQUdFO1xuXHR9O1xuXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdGFnLnNyYyAhPSBcIlwiICYmIHRoaXMuX3RhZy5jb21wbGV0ZSkge1xuXHRcdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGNyb3NzT3JpZ2luID0gdGhpcy5faXRlbS5jcm9zc09yaWdpbjtcblx0XHRpZiAoY3Jvc3NPcmlnaW4gPT0gdHJ1ZSkgeyBjcm9zc09yaWdpbiA9IFwiQW5vbnltb3VzXCI7IH1cblx0XHRpZiAoY3Jvc3NPcmlnaW4gIT0gbnVsbCAmJiAhY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzTG9jYWwodGhpcy5faXRlbS5zcmMpKSB7XG5cdFx0XHR0aGlzLl90YWcuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblx0XHR9XG5cblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2xvYWQoKTtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogQmVmb3JlIHRoZSBpdGVtIGxvYWRzLCBzZXQgaXRzIG1pbWVUeXBlIGFuZCByZXNwb25zZVR5cGUuXG5cdCAqIEBwcm9wZXJ0eSBfdXBkYXRlWEhSXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl91cGRhdGVYSFIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC5sb2FkZXIubWltZVR5cGUgPSAndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZC1iaW5hcnknO1xuXG5cdFx0Ly8gT25seSBleGlzdHMgZm9yIFhIUlxuXHRcdGlmIChldmVudC5sb2FkZXIuc2V0UmVzcG9uc2VUeXBlKSB7XG5cdFx0XHRldmVudC5sb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYmxvYlwiKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBJbWFnZSBmaWxlcy5cblx0ICogQG1ldGhvZCBfZm9ybWF0UmVzdWx0XG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcmV0dXJucyB7SFRNTEltYWdlRWxlbWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHJldHVybiBmdW5jdGlvbiAoZG9uZSkge1xuXHRcdFx0dmFyIHRhZyA9IF90aGlzLl90YWc7XG5cdFx0XHR2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuXG5cdFx0XHRpZiAoIV90aGlzLl9wcmVmZXJYSFIpIHtcblx0XHRcdFx0Ly9kb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRhZyk7XG5cdFx0XHR9IGVsc2UgaWYgKFVSTCkge1xuXHRcdFx0XHR2YXIgb2JqVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChsb2FkZXIuZ2V0UmVzdWx0KHRydWUpKTtcblx0XHRcdFx0dGFnLnNyYyA9IG9ialVSTDtcblx0XHRcdFx0dGFnLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKF90aGlzLnNyYyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhZy5zcmMgPSBsb2FkZXIuZ2V0SXRlbSgpLnNyYztcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRhZy5jb21wbGV0ZSkge1xuXHRcdFx0XHRkb25lKHRhZyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGRvbmUodGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkltYWdlTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShJbWFnZUxvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEphdmFTY3JpcHRMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIEphdmFTY3JpcHQgZmlsZXMuXG5cdCAqIEBjbGFzcyBKYXZhU2NyaXB0TG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZlclhIUlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEphdmFTY3JpcHRMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSkFWQVNDUklQVCk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBcInNyY1wiO1xuXHRcdHRoaXMuc2V0VGFnKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEphdmFTY3JpcHRMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBKYXZhU2NyaXB0TG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSkFWQVNDUklQVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpBVkFTQ1JJUFQ7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBKYXZhU2NyaXB0IGZpbGVzLlxuXHQgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEByZXR1cm5zIHtIVE1MTGlua0VsZW1lbnR8SFRNTFN0eWxlRWxlbWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHR2YXIgdGFnID0gbG9hZGVyLmdldFRhZygpO1xuXHRcdGlmICh0aGlzLl9wcmVmZXJYSFIpIHtcblx0XHRcdHRhZy50ZXh0ID0gbG9hZGVyLmdldFJlc3VsdCh0cnVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRhZztcblx0fTtcblxuXHRjcmVhdGVqcy5KYXZhU2NyaXB0TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShKYXZhU2NyaXB0TG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gSlNPTkxvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgSlNPTiBmaWxlcy4gVG8gbG9hZCBKU09OIGNyb3NzLWRvbWFpbiwgdXNlIEpTT05QIGFuZCB0aGUge3sjY3Jvc3NMaW5rIFwiSlNPTlBMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaW5zdGVhZC4gVG8gbG9hZCBKU09OLWZvcm1hdHRlZCBtYW5pZmVzdHMsIHVzZSB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHRvXG5cdCAqIGxvYWQgRWFzZWxKUyBTcHJpdGVTaGVldHMsIHVzZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldExvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQGNsYXNzIEpTT05Mb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gSlNPTkxvYWRlcihsb2FkSXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHRydWUsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpTT04pO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IHRoaXMuX2Zvcm1hdFJlc3VsdDtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChKU09OTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gSlNPTkxvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pTT046cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTiAmJiAhaXRlbS5fbG9hZEFzSlNPTlA7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBKU09OIGZpbGVzLlxuXHQgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEByZXR1cm5zIHtIVE1MTGlua0VsZW1lbnR8SFRNTFN0eWxlRWxlbWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHR2YXIganNvbiA9IG51bGw7XG5cdFx0dHJ5IHtcblx0XHRcdGpzb24gPSBjcmVhdGVqcy5EYXRhVXRpbHMucGFyc2VKU09OKGxvYWRlci5nZXRSZXN1bHQodHJ1ZSkpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiSlNPTl9GT1JNQVRcIiwgbnVsbCwgZSk7XG5cdFx0XHR0aGlzLl9zZW5kRXJyb3IoZXZlbnQpO1xuXHRcdFx0cmV0dXJuIGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpzb247XG5cdH07XG5cblx0Y3JlYXRlanMuSlNPTkxvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoSlNPTkxvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEpTT05QTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBKU09OUCBmaWxlcywgd2hpY2ggYXJlIEpTT04tZm9ybWF0dGVkIHRleHQgZmlsZXMsIHdyYXBwZWQgaW4gYSBjYWxsYmFjay4gVG8gbG9hZCByZWd1bGFyIEpTT05cblx0ICogd2l0aG91dCBhIGNhbGxiYWNrIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiSlNPTkxvYWRlclwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLiBUbyBsb2FkIEpTT04tZm9ybWF0dGVkIG1hbmlmZXN0cyxcblx0ICogdXNlIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgdG8gbG9hZCBFYXNlbEpTIFNwcml0ZVNoZWV0cywgdXNlXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgSlNPTlAgZmlsZXMgbG9hZGVkIGNvbmN1cnJlbnRseSByZXF1aXJlIGEgPGVtPnVuaXF1ZTwvZW0+IGNhbGxiYWNrLiBUbyBlbnN1cmUgSlNPTlAgZmlsZXMgYXJlIGxvYWRlZFxuXHQgKiBpbiBvcmRlciwgZWl0aGVyIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldE1heENvbm5lY3Rpb25zXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCAoc2V0IHRvIDEpLFxuXHQgKiBvciBzZXQge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vbWFpbnRhaW5PcmRlcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBvbiBpdGVtcyB3aXRoIHRoZSBzYW1lIGNhbGxiYWNrLlxuXHQgKiBAY2xhc3MgSlNPTlBMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gSlNPTlBMb2FkZXIobG9hZEl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBmYWxzZSwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTlApO1xuXHRcdHRoaXMuc2V0VGFnKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpO1xuXHRcdHRoaXMuZ2V0VGFnKCkudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoSlNPTlBMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBKU09OUExvYWRlcjtcblxuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSlNPTlA6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTlAgfHwgaXRlbS5fbG9hZEFzSlNPTlA7XG5cdH07XG5cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0cC5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jYW5jZWwoKTtcblx0XHR0aGlzLl9kaXNwb3NlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIExvYWRzIHRoZSBKU09OcCBmaWxlLiAgQmVjYXVzZSBvZiB0aGUgdW5pcXVlIGxvYWRpbmcgbmVlZHMgb2YganNvblBcblx0ICogd2UgZG9uJ3QgdXNlIHRoZSBBYnN0cmFjdExvYWRlci5sb2FkKCkgbWV0aG9kLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGxvYWRcblx0ICpcblx0ICovXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5faXRlbS5jYWxsYmFjayA9PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIGlzIHJlcXVpcmVkIGZvciBsb2FkaW5nIEpTT05QIHJlcXVlc3RzLicpO1xuXHRcdH1cblxuXHRcdC8vIFRPRE86IExvb2sgaW50byBjcmVhdGluZyBvdXIgb3duIGlGcmFtZSB0byBoYW5kbGUgdGhlIGxvYWRcblx0XHQvLyBJbiB0aGUgZmlyc3QgYXR0ZW1wdCwgRkYgZGlkIG5vdCBnZXQgdGhlIHJlc3VsdFxuXHRcdC8vICAgcmVzdWx0IGluc3RhbmNlb2YgT2JqZWN0IGRpZCBub3Qgd29yayBlaXRoZXJcblx0XHQvLyAgIHNvIHdlIHdvdWxkIG5lZWQgdG8gY2xvbmUgdGhlIHJlc3VsdC5cblx0XHRpZiAod2luZG93W3RoaXMuX2l0ZW0uY2FsbGJhY2tdICE9IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XCJKU09OUCBjYWxsYmFjayAnXCIgK1xuXHRcdFx0XHR0aGlzLl9pdGVtLmNhbGxiYWNrICtcblx0XHRcdFx0XCInIGFscmVhZHkgZXhpc3RzIG9uIHdpbmRvdy4gWW91IG5lZWQgdG8gc3BlY2lmeSBhIGRpZmZlcmVudCBjYWxsYmFjayBvciByZS1uYW1lIHRoZSBjdXJyZW50IG9uZS5cIik7XG5cdFx0fVxuXG5cdFx0d2luZG93W3RoaXMuX2l0ZW0uY2FsbGJhY2tdID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlTG9hZCwgdGhpcyk7XG5cdFx0d2luZG93LmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fdGFnKTtcblxuXHRcdHRoaXMuX2xvYWRUaW1lb3V0ID0gc2V0VGltZW91dChjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUaW1lb3V0LCB0aGlzKSwgdGhpcy5faXRlbS5sb2FkVGltZW91dCk7XG5cblx0XHQvLyBMb2FkIHRoZSB0YWdcblx0XHR0aGlzLl90YWcuc3JjID0gdGhpcy5faXRlbS5zcmM7XG5cdH07XG5cblx0Ly8gcHJpdmF0ZSBtZXRob2RzXG5cdC8qKlxuXHQgKiBIYW5kbGUgdGhlIEpTT05QIGNhbGxiYWNrLCB3aGljaCBpcyBhIHB1YmxpYyBtZXRob2QgZGVmaW5lZCBvbiBgd2luZG93YC5cblx0ICogQG1ldGhvZCBfaGFuZGxlTG9hZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZm9ybWF0dGVkIEpTT04gZGF0YS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZUxvYWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdHRoaXMuX3Jlc3VsdCA9IHRoaXMuX3Jhd1Jlc3VsdCA9IGRhdGE7XG5cdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cblx0XHR0aGlzLl9kaXNwb3NlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSB0YWcgcmVxdWVzdCBoYXMgbm90IGxvYWRlZCB3aXRoaW4gdGhlIHRpbWUgc3BlY2ZpZWQgaW4gbG9hZFRpbWVvdXQuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUVycm9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGVycm9yIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9kaXNwb3NlKCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwidGltZW91dFwiKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENsZWFuIHVwIHRoZSBKU09OUCBsb2FkLiBUaGlzIGNsZWFycyBvdXQgdGhlIGNhbGxiYWNrIGFuZCBzY3JpcHQgdGFnIHRoYXQgdGhpcyBsb2FkZXIgY3JlYXRlcy5cblx0ICogQG1ldGhvZCBfZGlzcG9zZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR3aW5kb3cuZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLl90YWcpO1xuXHRcdGRlbGV0ZSB3aW5kb3dbdGhpcy5faXRlbS5jYWxsYmFja107XG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5fbG9hZFRpbWVvdXQpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkpTT05QTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShKU09OUExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIE1hbmlmZXN0TG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBKU09OIG1hbmlmZXN0cy4gSXRlbXMgaW5zaWRlIHRoZSBtYW5pZmVzdCBhcmUgbG9hZGVkIGJlZm9yZSB0aGUgbG9hZGVyIGNvbXBsZXRlcy4gVG8gbG9hZCBtYW5pZmVzdHNcblx0ICogdXNpbmcgSlNPTlAsIHNwZWNpZnkgYSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS9jYWxsYmFjazpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBhcyBwYXJ0IG9mIHRoZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogVGhlIGxpc3Qgb2YgZmlsZXMgaW4gdGhlIG1hbmlmZXN0IG11c3QgYmUgZGVmaW5lZCBvbiB0aGUgdG9wLWxldmVsIEpTT04gb2JqZWN0IGluIGEgYG1hbmlmZXN0YCBwcm9wZXJ0eS4gVGhpc1xuXHQgKiBleGFtcGxlIHNob3dzIGEgc2FtcGxlIG1hbmlmZXN0IGRlZmluaXRpb24sIGFzIHdlbGwgYXMgaG93IHRvIHRvIGluY2x1ZGUgYSBzdWItbWFuaWZlc3QuXG5cdCAqXG5cdCAqIFx0XHR7XG5cdCAqIFx0XHRcdFwicGF0aFwiOiBcImFzc2V0cy9cIixcblx0ICpcdCBcdCAgICBcIm1hbmlmZXN0XCI6IFtcblx0ICpcdFx0XHRcdFwiaW1hZ2UucG5nXCIsXG5cdCAqXHRcdFx0XHR7XCJzcmNcIjogXCJpbWFnZTIucG5nXCIsIFwiaWRcIjpcImltYWdlMlwifSxcblx0ICpcdFx0XHRcdHtcInNyY1wiOiBcInN1Yi1tYW5pZmVzdC5qc29uXCIsIFwidHlwZVwiOlwibWFuaWZlc3RcIiwgXCJjYWxsYmFja1wiOlwianNvbkNhbGxiYWNrXCJ9XG5cdCAqXHQgXHQgICAgXVxuXHQgKlx0IFx0fVxuXHQgKlxuXHQgKiBXaGVuIGEgTWFuaWZlc3RMb2FkZXIgaGFzIGNvbXBsZXRlZCBsb2FkaW5nLCB0aGUgcGFyZW50IGxvYWRlciAodXN1YWxseSBhIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogYnV0IGNvdWxkIGFsc28gYmUgYW5vdGhlciBNYW5pZmVzdExvYWRlcikgd2lsbCBpbmhlcml0IGFsbCB0aGUgbG9hZGVkIGl0ZW1zLCBzbyB5b3UgY2FuIGFjY2VzcyB0aGVtIGRpcmVjdGx5LlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIHt7I2Nyb3NzTGluayBcIkpTT05Mb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkpTT05QTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGFyZVxuXHQgKiBoaWdoZXIgcHJpb3JpdHkgbG9hZGVycywgc28gbWFuaWZlc3RzIDxzdHJvbmc+bXVzdDwvc3Ryb25nPiBzZXQgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL3R5cGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgdG8ge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvTUFOSUZFU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBjbGFzcyBNYW5pZmVzdExvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBNYW5pZmVzdExvYWRlcihsb2FkSXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIG51bGwsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLk1BTklGRVNUKTtcblxuXHQvLyBQdWJsaWMgUHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IG9mIHRoZSBwbHVnaW5zIHJlZ2lzdGVyZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2luc3RhbGxQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0sXG5cdFx0ICogdXNlZCB0byBwYXNzIHBsdWdpbnMgdG8gbmV3IExvYWRRdWV1ZXMgdGhhdCBtYXkgYmUgY3JlYXRlZC5cblx0XHQgKiBAcHJvcGVydHkgX3BsdWdpbnNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAc2luY2UgMC42LjFcblx0XHQgKi9cblx0XHR0aGlzLnBsdWdpbnMgPSBudWxsO1xuXG5cblx0Ly8gUHJvdGVjdGVkIFByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBBbiBpbnRlcm5hbCB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBsb2FkcyB0aGUgY29udGVudHMgb2YgdGhlIG1hbmlmZXN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBfbWFuaWZlc3RRdWV1ZVxuXHRcdCAqIEB0eXBlIHtMb2FkUXVldWV9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9tYW5pZmVzdFF1ZXVlID0gbnVsbDtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChNYW5pZmVzdExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IE1hbmlmZXN0TG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBwcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBUaGUgYW1vdW50IG9mIHByb2dyZXNzIHRoYXQgdGhlIG1hbmlmZXN0IGl0c2VsZiB0YWtlcyB1cC5cblx0ICogQHByb3BlcnR5IE1BTklGRVNUX1BST0dSRVNTXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDAuMjUgKDI1JSlcblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5NQU5JRkVTVF9QUk9HUkVTUyA9IDAuMjU7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9NQU5JRkVTVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLk1BTklGRVNUO1xuXHR9O1xuXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2xvYWQoKTtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHRwLl9jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gdGhpcy5faXRlbS5jYWxsYmFjaztcblx0XHRpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5KU09OUExvYWRlcih0aGlzLl9pdGVtKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5KU09OTG9hZGVyKHRoaXMuX2l0ZW0pO1xuXHRcdH1cblx0fTtcblxuXHRwLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0c3dpdGNoIChldmVudC50eXBlKSB7XG5cdFx0XHRjYXNlIFwiY29tcGxldGVcIjpcblx0XHRcdFx0dGhpcy5fcmF3UmVzdWx0ID0gZXZlbnQudGFyZ2V0LmdldFJlc3VsdCh0cnVlKTtcblx0XHRcdFx0dGhpcy5fcmVzdWx0ID0gZXZlbnQudGFyZ2V0LmdldFJlc3VsdCgpO1xuXHRcdFx0XHR0aGlzLl9zZW5kUHJvZ3Jlc3Mocy5NQU5JRkVTVF9QUk9HUkVTUyk7XG5cdFx0XHRcdHRoaXMuX2xvYWRNYW5pZmVzdCh0aGlzLl9yZXN1bHQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRjYXNlIFwicHJvZ3Jlc3NcIjpcblx0XHRcdFx0ZXZlbnQubG9hZGVkICo9IHMuTUFOSUZFU1RfUFJPR1JFU1M7XG5cdFx0XHRcdHRoaXMucHJvZ3Jlc3MgPSBldmVudC5sb2FkZWQgLyBldmVudC50b3RhbDtcblx0XHRcdFx0aWYgKGlzTmFOKHRoaXMucHJvZ3Jlc3MpIHx8IHRoaXMucHJvZ3Jlc3MgPT0gSW5maW5pdHkpIHsgdGhpcy5wcm9ncmVzcyA9IDA7IH1cblx0XHRcdFx0dGhpcy5fc2VuZFByb2dyZXNzKGV2ZW50KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2hhbmRsZUV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHRwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2Rlc3Ryb3koKTtcblx0XHR0aGlzLl9tYW5pZmVzdFF1ZXVlLmNsb3NlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhbmQgbG9hZCB0aGUgbWFuaWZlc3QgaXRlbXMgb25jZSB0aGUgYWN0dWFsIG1hbmlmZXN0IGhhcyBiZWVuIGxvYWRlZC5cblx0ICogQG1ldGhvZCBfbG9hZE1hbmlmZXN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBqc29uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9sb2FkTWFuaWZlc3QgPSBmdW5jdGlvbiAoanNvbikge1xuXHRcdGlmIChqc29uICYmIGpzb24ubWFuaWZlc3QpIHtcblx0XHRcdHZhciBxdWV1ZSA9IHRoaXMuX21hbmlmZXN0UXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG5cdFx0XHRxdWV1ZS5vbihcImZpbGVsb2FkXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0RmlsZUxvYWQsIHRoaXMpO1xuXHRcdFx0cXVldWUub24oXCJwcm9ncmVzc1wiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdFByb2dyZXNzLCB0aGlzKTtcblx0XHRcdHF1ZXVlLm9uKFwiY29tcGxldGVcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RDb21wbGV0ZSwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRxdWV1ZS5vbihcImVycm9yXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0RXJyb3IsIHRoaXMsIHRydWUpO1xuXHRcdFx0Zm9yKHZhciBpID0gMCwgbCA9IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcdC8vIGNvbnNlcnZlIG9yZGVyIG9mIHBsdWdpbnNcblx0XHRcdFx0cXVldWUuaW5zdGFsbFBsdWdpbih0aGlzLnBsdWdpbnNbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cXVldWUubG9hZE1hbmlmZXN0KGpzb24pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEFuIGl0ZW0gZnJvbSB0aGUge3sjY3Jvc3NMaW5rIFwiX21hbmlmZXN0UXVldWU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaGFzIGNvbXBsZXRlZC5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RGaWxlTG9hZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RGaWxlTG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LnRhcmdldCA9IG51bGw7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG1hbmlmZXN0IGhhcyBjb21wbGV0ZWQgbG9hZGluZy4gVGhpcyB0cmlnZ2VycyB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvY29tcGxldGU6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZnJvbSB0aGUgTWFuaWZlc3RMb2FkZXIuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0Q29tcGxldGVcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZU1hbmlmZXN0Q29tcGxldGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9sb2FkZWRJdGVtcyA9IHRoaXMuX21hbmlmZXN0UXVldWUuZ2V0SXRlbXModHJ1ZSk7XG5cdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBtYW5pZmVzdCBoYXMgcmVwb3J0ZWQgcHJvZ3Jlc3MuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0UHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtQcm9ncmVzc0V2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RQcm9ncmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSBldmVudC5wcm9ncmVzcyAqICgxIC0gcy5NQU5JRkVTVF9QUk9HUkVTUykgKyBzLk1BTklGRVNUX1BST0dSRVNTO1xuXHRcdHRoaXMuX3NlbmRQcm9ncmVzcyh0aGlzLnByb2dyZXNzKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG1hbmlmZXN0IGhhcyByZXBvcnRlZCBhbiBlcnJvciB3aXRoIG9uZSBvZiB0aGUgZmlsZXMuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0RXJyb3Jcblx0ICogQHBhcmFtIHtFcnJvckV2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVlcnJvclwiKTtcblx0XHRuZXdFdmVudC5pdGVtID0gZXZlbnQuZGF0YTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLk1hbmlmZXN0TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShNYW5pZmVzdExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNvdW5kTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBIVE1MIGF1ZGlvIGZpbGVzLiBQcmVsb2FkSlMgY2FuIG5vdCBsb2FkIFdlYkF1ZGlvIGZpbGVzLCBhcyBhIFdlYkF1ZGlvIGNvbnRleHQgaXMgcmVxdWlyZWQsIHdoaWNoXG5cdCAqIHNob3VsZCBiZSBjcmVhdGVkIGJ5IGVpdGhlciBhIGxpYnJhcnkgcGxheWluZyB0aGUgc291bmQgKHN1Y2ggYXMgPGEgaHJlZj1cImh0dHA6Ly9zb3VuZGpzLmNvbVwiPlNvdW5kSlM8L2E+LCBvciBhblxuXHQgKiBleHRlcm5hbCBmcmFtZXdvcmsgdGhhdCBoYW5kbGVzIGF1ZGlvIHBsYXliYWNrLiBUbyBsb2FkIGNvbnRlbnQgdGhhdCBjYW4gYmUgcGxheWVkIGJ5IFdlYkF1ZGlvLCB1c2UgdGhlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkJpbmFyeUxvYWRlclwifX17ey9jcm9zc0xpbmt9fSwgYW5kIGhhbmRsZSB0aGUgYXVkaW8gY29udGV4dCBkZWNvZGluZyBtYW51YWxseS5cblx0ICogQGNsYXNzIFNvdW5kTG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZlclhIUlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdE1lZGlhTG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gU291bmRMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuXHRcdHRoaXMuQWJzdHJhY3RNZWRpYUxvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgcHJlZmVyWEhSLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TT1VORCk7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdGlmIChjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNBdWRpb1RhZyhsb2FkSXRlbSkpIHtcblx0XHRcdHRoaXMuX3RhZyA9IGxvYWRJdGVtO1xuXHRcdH0gZWxzZSBpZiAoY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzQXVkaW9UYWcobG9hZEl0ZW0uc3JjKSkge1xuXHRcdFx0dGhpcy5fdGFnID0gbG9hZEl0ZW07XG5cdFx0fSBlbHNlIGlmIChjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNBdWRpb1RhZyhsb2FkSXRlbS50YWcpKSB7XG5cdFx0XHR0aGlzLl90YWcgPSBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNBdWRpb1RhZyhsb2FkSXRlbSkgPyBsb2FkSXRlbSA6IGxvYWRJdGVtLnNyYztcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fdGFnICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3ByZWZlclhIUiA9IGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTb3VuZExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RNZWRpYUxvYWRlcik7XG5cdHZhciBzID0gU291bmRMb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TT1VORDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TT1VORDtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHRwLl9jcmVhdGVUYWcgPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0dmFyIHRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhdWRpb1wiKTtcblx0XHR0YWcuYXV0b3BsYXkgPSBmYWxzZTtcblx0XHR0YWcucHJlbG9hZCA9IFwibm9uZVwiO1xuXG5cdFx0Ly9MTTogRmlyZWZveCBmYWlscyB3aGVuIHRoaXMgdGhlIHByZWxvYWQ9XCJub25lXCIgZm9yIG90aGVyIHRhZ3MsIGJ1dCBpdCBuZWVkcyB0byBiZSBcIm5vbmVcIiB0byBlbnN1cmUgUHJlbG9hZEpTIHdvcmtzLlxuXHRcdHRhZy5zcmMgPSBzcmM7XG5cdFx0cmV0dXJuIHRhZztcblx0fTtcblxuXHRjcmVhdGVqcy5Tb3VuZExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoU291bmRMb2FkZXIsIFwiQWJzdHJhY3RNZWRpYUxvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFZpZGVvTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciB2aWRlbyBmaWxlcy5cblx0ICogQGNsYXNzIFZpZGVvTG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZlclhIUlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdE1lZGlhTG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gVmlkZW9Mb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuXHRcdHRoaXMuQWJzdHJhY3RNZWRpYUxvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgcHJlZmVyWEhSLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5WSURFTyk7XG5cblx0XHRpZiAoY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzVmlkZW9UYWcobG9hZEl0ZW0pIHx8IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc1ZpZGVvVGFnKGxvYWRJdGVtLnNyYykpIHtcblx0XHRcdHRoaXMuc2V0VGFnKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc1ZpZGVvVGFnKGxvYWRJdGVtKT9sb2FkSXRlbTpsb2FkSXRlbS5zcmMpO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCB1c2UgWEhSIGZvciBhIHRhZyB0aGF0J3MgcGFzc2VkIGluLlxuXHRcdFx0dGhpcy5fcHJlZmVyWEhSID0gZmFsc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2V0VGFnKHRoaXMuX2NyZWF0ZVRhZygpKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoVmlkZW9Mb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TWVkaWFMb2FkZXIpO1xuXHR2YXIgcyA9IFZpZGVvTG9hZGVyO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBuZXcgdmlkZW8gdGFnXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NyZWF0ZVRhZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xuXHR9O1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvVklERU86cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVklERU87XG5cdH07XG5cblx0Y3JlYXRlanMuVmlkZW9Mb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKFZpZGVvTG9hZGVyLCBcIkFic3RyYWN0TWVkaWFMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTcHJpdGVTaGVldExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgRWFzZWxKUyBTcHJpdGVTaGVldHMuIEltYWdlcyBpbnNpZGUgdGhlIHNwcml0ZXNoZWV0IGRlZmluaXRpb24gYXJlIGxvYWRlZCBiZWZvcmUgdGhlIGxvYWRlclxuXHQgKiBjb21wbGV0ZXMuIFRvIGxvYWQgU3ByaXRlU2hlZXRzIHVzaW5nIEpTT05QLCBzcGVjaWZ5IGEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vY2FsbGJhY2s6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogYXMgcGFydCBvZiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0uIE5vdGUgdGhhdCB0aGUge3sjY3Jvc3NMaW5rIFwiSlNPTkxvYWRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBhbmQge3sjY3Jvc3NMaW5rIFwiSlNPTlBMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gYXJlIGhpZ2hlciBwcmlvcml0eSBsb2FkZXJzLCBzbyBTcHJpdGVTaGVldHMgPHN0cm9uZz5tdXN0PC9zdHJvbmc+XG5cdCAqIHNldCB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0ge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vdHlwZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eVxuXHQgKiB0byB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TUFJJVEVTSEVFVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQGNsYXNzIFNwcml0ZVNoZWV0TG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFNwcml0ZVNoZWV0TG9hZGVyKGxvYWRJdGVtKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgbnVsbCwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU1BSSVRFU0hFRVQpO1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBBbiBpbnRlcm5hbCBxdWV1ZSB3aGljaCBsb2FkcyB0aGUgU3ByaXRlU2hlZXQncyBpbWFnZXMuXG5cdFx0ICogQG1ldGhvZCBfbWFuaWZlc3RRdWV1ZVxuXHRcdCAqIEB0eXBlIHtMb2FkUXVldWV9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9tYW5pZmVzdFF1ZXVlID0gbnVsbDtcblx0fVxuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFNwcml0ZVNoZWV0TG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gU3ByaXRlU2hlZXRMb2FkZXI7XG5cblx0Ly8gc3RhdGljIHByb3BlcnRpZXNcblx0LyoqXG5cdCAqIFRoZSBhbW91bnQgb2YgcHJvZ3Jlc3MgdGhhdCB0aGUgbWFuaWZlc3QgaXRzZWxmIHRha2VzIHVwLlxuXHQgKiBAcHJvcGVydHkgU1BSSVRFU0hFRVRfUFJPR1JFU1Ncblx0ICogQHR5cGUge251bWJlcn1cblx0ICogQGRlZmF1bHQgMC4yNSAoMjUlKVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLlNQUklURVNIRUVUX1BST0dSRVNTID0gMC4yNTtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1NQUklURVNIRUVUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU1BSSVRFU0hFRVQ7XG5cdH07XG5cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0cC5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9kZXN0cm95O1xuXHRcdHRoaXMuX21hbmlmZXN0UXVldWUuY2xvc2UoKTtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHRwLl9jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gdGhpcy5faXRlbS5jYWxsYmFjaztcblx0XHRpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiBjYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLkpTT05QTG9hZGVyKHRoaXMuX2l0ZW0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLkpTT05Mb2FkZXIodGhpcy5faXRlbSk7XG5cdFx0fVxuXHR9O1xuXG5cdHAuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcblx0XHRcdGNhc2UgXCJjb21wbGV0ZVwiOlxuXHRcdFx0XHR0aGlzLl9yYXdSZXN1bHQgPSBldmVudC50YXJnZXQuZ2V0UmVzdWx0KHRydWUpO1xuXHRcdFx0XHR0aGlzLl9yZXN1bHQgPSBldmVudC50YXJnZXQuZ2V0UmVzdWx0KCk7XG5cdFx0XHRcdHRoaXMuX3NlbmRQcm9ncmVzcyhzLlNQUklURVNIRUVUX1BST0dSRVNTKTtcblx0XHRcdFx0dGhpcy5fbG9hZE1hbmlmZXN0KHRoaXMuX3Jlc3VsdCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdGNhc2UgXCJwcm9ncmVzc1wiOlxuXHRcdFx0XHRldmVudC5sb2FkZWQgKj0gcy5TUFJJVEVTSEVFVF9QUk9HUkVTUztcblx0XHRcdFx0dGhpcy5wcm9ncmVzcyA9IGV2ZW50LmxvYWRlZCAvIGV2ZW50LnRvdGFsO1xuXHRcdFx0XHRpZiAoaXNOYU4odGhpcy5wcm9ncmVzcykgfHwgdGhpcy5wcm9ncmVzcyA9PSBJbmZpbml0eSkgeyB0aGlzLnByb2dyZXNzID0gMDsgfVxuXHRcdFx0XHR0aGlzLl9zZW5kUHJvZ3Jlc3MoZXZlbnQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfaGFuZGxlRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW5kIGxvYWQgdGhlIGltYWdlcyBvbmNlIHRoZSBTcHJpdGVTaGVldCBKU09OIGhhcyBiZWVuIGxvYWRlZC5cblx0ICogQG1ldGhvZCBfbG9hZE1hbmlmZXN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBqc29uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9sb2FkTWFuaWZlc3QgPSBmdW5jdGlvbiAoanNvbikge1xuXHRcdGlmIChqc29uICYmIGpzb24uaW1hZ2VzKSB7XG5cdFx0XHR2YXIgcXVldWUgPSB0aGlzLl9tYW5pZmVzdFF1ZXVlID0gbmV3IGNyZWF0ZWpzLkxvYWRRdWV1ZSgpO1xuXHRcdFx0cXVldWUub24oXCJjb21wbGV0ZVwiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdENvbXBsZXRlLCB0aGlzLCB0cnVlKTtcblx0XHRcdHF1ZXVlLm9uKFwiZmlsZWxvYWRcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RGaWxlTG9hZCwgdGhpcyk7XG5cdFx0XHRxdWV1ZS5vbihcInByb2dyZXNzXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0UHJvZ3Jlc3MsIHRoaXMpO1xuXHRcdFx0cXVldWUub24oXCJlcnJvclwiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdEVycm9yLCB0aGlzLCB0cnVlKTtcblx0XHRcdHF1ZXVlLmxvYWRNYW5pZmVzdChqc29uLmltYWdlcyk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbiBpdGVtIGZyb20gdGhlIHt7I2Nyb3NzTGluayBcIl9tYW5pZmVzdFF1ZXVlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGhhcyBjb21wbGV0ZWQuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0RmlsZUxvYWRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZU1hbmlmZXN0RmlsZUxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgaW1hZ2UgPSBldmVudC5yZXN1bHQ7XG5cdFx0aWYgKGltYWdlICE9IG51bGwpIHtcblx0XHRcdHZhciBpbWFnZXMgPSB0aGlzLmdldFJlc3VsdCgpLmltYWdlcztcblx0XHRcdHZhciBwb3MgPSBpbWFnZXMuaW5kZXhPZihldmVudC5pdGVtLnNyYyk7XG5cdFx0XHRpbWFnZXNbcG9zXSA9IGltYWdlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVGhlIGltYWdlcyBoYXZlIGNvbXBsZXRlZCBsb2FkaW5nLiBUaGlzIHRyaWdnZXJzIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9jb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSBmcm9tIHRoZSBTcHJpdGVTaGVldExvYWRlci5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RDb21wbGV0ZVxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RDb21wbGV0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuX3Jlc3VsdCA9IG5ldyBjcmVhdGVqcy5TcHJpdGVTaGVldCh0aGlzLl9yZXN1bHQpO1xuXHRcdHRoaXMuX2xvYWRlZEl0ZW1zID0gdGhpcy5fbWFuaWZlc3RRdWV1ZS5nZXRJdGVtcyh0cnVlKTtcblx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIGltYWdlcyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gaGFzIHJlcG9ydGVkIHByb2dyZXNzLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNYW5pZmVzdFByb2dyZXNzXG5cdCAqIEBwYXJhbSB7UHJvZ3Jlc3NFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZU1hbmlmZXN0UHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLnByb2dyZXNzID0gZXZlbnQucHJvZ3Jlc3MgKiAoMSAtIHMuU1BSSVRFU0hFRVRfUFJPR1JFU1MpICsgcy5TUFJJVEVTSEVFVF9QUk9HUkVTUztcblx0XHR0aGlzLl9zZW5kUHJvZ3Jlc3ModGhpcy5wcm9ncmVzcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFuIGltYWdlIGhhcyByZXBvcnRlZCBhbiBlcnJvci5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RFcnJvclxuXHQgKiBAcGFyYW0ge0Vycm9yRXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVNYW5pZmVzdEVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIG5ld0V2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiZmlsZWVycm9yXCIpO1xuXHRcdG5ld0V2ZW50Lml0ZW0gPSBldmVudC5kYXRhO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG5cdH07XG5cblx0Y3JlYXRlanMuU3ByaXRlU2hlZXRMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKFNwcml0ZVNoZWV0TG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU1ZHTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBTVkcgZmlsZXMuXG5cdCAqIEBjbGFzcyBTVkdMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gU1ZHTG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNWRyk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBcImRhdGFcIjtcblxuXHRcdGlmIChwcmVmZXJYSFIpIHtcblx0XHRcdHRoaXMuc2V0VGFnKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIikpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNldFRhZyhkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib2JqZWN0XCIpKTtcblx0XHRcdHRoaXMuZ2V0VGFnKCkudHlwZSA9IFwiaW1hZ2Uvc3ZnK3htbFwiO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTVkdMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBTVkdMb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TVkc6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TVkc7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBTVkcgZmlsZXMuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHJldHVybnMge09iamVjdH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHQvLyBtaW1lIHNob3VsZCBiZSBpbWFnZS9zdmcreG1sLCBidXQgT3BlcmEgcmVxdWlyZXMgdGV4dC94bWxcblx0XHR2YXIgeG1sID0gY3JlYXRlanMuRGF0YVV0aWxzLnBhcnNlWE1MKGxvYWRlci5nZXRSZXN1bHQodHJ1ZSksIFwidGV4dC94bWxcIik7XG5cdFx0dmFyIHRhZyA9IGxvYWRlci5nZXRUYWcoKTtcblxuXHRcdGlmICghdGhpcy5fcHJlZmVyWEhSICYmIGRvY3VtZW50LmJvZHkuY29udGFpbnModGFnKSkge1xuXHRcdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0YWcpO1xuXHRcdH1cblxuXHRcdGlmICh4bWwuZG9jdW1lbnRFbGVtZW50ICE9IG51bGwpIHtcblx0XHRcdHRhZy5hcHBlbmRDaGlsZCh4bWwuZG9jdW1lbnRFbGVtZW50KTtcblx0XHRcdHRhZy5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG5cdFx0XHRyZXR1cm4gdGFnO1xuXHRcdH0gZWxzZSB7IC8vIEZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgU1ZHLCBqdXN0IGdpdmUgdGhlbSB0aGUgWE1MLiAoSUUgOS04KVxuXHRcdFx0cmV0dXJuIHhtbDtcblx0XHR9XG5cdH07XG5cblx0Y3JlYXRlanMuU1ZHTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShTVkdMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBYTUxMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIENTUyBmaWxlcy5cblx0ICogQGNsYXNzIFhNTExvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBYTUxMb2FkZXIobG9hZEl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCB0cnVlLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5YTUwpO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IHRoaXMuX2Zvcm1hdFJlc3VsdDtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChYTUxMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBYTUxMb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9YTUw6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuWE1MO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBUaGUgcmVzdWx0IGZvcm1hdHRlciBmb3IgWE1MIGZpbGVzLlxuXHQgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEByZXR1cm5zIHtYTUxEb2N1bWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHRyZXR1cm4gY3JlYXRlanMuRGF0YVV0aWxzLnBhcnNlWE1MKGxvYWRlci5nZXRSZXN1bHQodHJ1ZSksIFwidGV4dC94bWxcIik7XG5cdH07XG5cblx0Y3JlYXRlanMuWE1MTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShYTUxMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG4vKiFcbiogVHdlZW5KU1xuKiBWaXNpdCBodHRwOi8vY3JlYXRlanMuY29tLyBmb3IgZG9jdW1lbnRhdGlvbiwgdXBkYXRlcyBhbmQgZXhhbXBsZXMuXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMCBnc2tpbm5lci5jb20sIGluYy5cbipcbiogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4qIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiogY29uZGl0aW9uczpcbipcbiogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4qXG4qIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4qIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4qIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cblxuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gZXh0ZW5kLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbi8qKlxuICogU2V0cyB1cCB0aGUgcHJvdG90eXBlIGNoYWluIGFuZCBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBmb3IgYSBuZXcgY2xhc3MuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIHJpZ2h0IGFmdGVyIGNyZWF0aW5nIHRoZSBjbGFzcyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBcdGZ1bmN0aW9uIE15U3ViQ2xhc3MoKSB7fVxuICogXHRjcmVhdGVqcy5leHRlbmQoTXlTdWJDbGFzcywgTXlTdXBlckNsYXNzKTtcbiAqIFx0Q2xhc3NCLnByb3RvdHlwZS5kb1NvbWV0aGluZyA9IGZ1bmN0aW9uKCkgeyB9XG4gKlxuICogXHR2YXIgZm9vID0gbmV3IE15U3ViQ2xhc3MoKTtcbiAqIFx0Y29uc29sZS5sb2coZm9vIGluc3RhbmNlb2YgTXlTdXBlckNsYXNzKTsgLy8gdHJ1ZVxuICogXHRjb25zb2xlLmxvZyhmb28ucHJvdG90eXBlLmNvbnN0cnVjdG9yID09PSBNeVN1YkNsYXNzKTsgLy8gdHJ1ZVxuICpcbiAqIEBtZXRob2QgZXh0ZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJjbGFzcyBUaGUgc3ViY2xhc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdXBlcmNsYXNzIFRoZSBzdXBlcmNsYXNzIHRvIGV4dGVuZC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBzdWJjbGFzcydzIG5ldyBwcm90b3R5cGUuXG4gKi9cbmNyZWF0ZWpzLmV4dGVuZCA9IGZ1bmN0aW9uKHN1YmNsYXNzLCBzdXBlcmNsYXNzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGZ1bmN0aW9uIG8oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBzdWJjbGFzczsgfVxuXHRvLnByb3RvdHlwZSA9IHN1cGVyY2xhc3MucHJvdG90eXBlO1xuXHRyZXR1cm4gKHN1YmNsYXNzLnByb3RvdHlwZSA9IG5ldyBvKCkpO1xufTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIHByb21vdGUuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuLyoqXG4gKiBAY2xhc3MgVXRpbGl0eSBNZXRob2RzXG4gKi9cblxuLyoqXG4gKiBQcm9tb3RlcyBhbnkgbWV0aG9kcyBvbiB0aGUgc3VwZXIgY2xhc3MgdGhhdCB3ZXJlIG92ZXJyaWRkZW4sIGJ5IGNyZWF0aW5nIGFuIGFsaWFzIGluIHRoZSBmb3JtYXQgYHByZWZpeF9tZXRob2ROYW1lYC5cbiAqIEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGUgc3VwZXIgY2xhc3MncyBuYW1lIGFzIHRoZSBwcmVmaXguXG4gKiBBbiBhbGlhcyB0byB0aGUgc3VwZXIgY2xhc3MncyBjb25zdHJ1Y3RvciBpcyBhbHdheXMgYWRkZWQgaW4gdGhlIGZvcm1hdCBgcHJlZml4X2NvbnN0cnVjdG9yYC5cbiAqIFRoaXMgYWxsb3dzIHRoZSBzdWJjbGFzcyB0byBjYWxsIHN1cGVyIGNsYXNzIG1ldGhvZHMgd2l0aG91dCB1c2luZyBgZnVuY3Rpb24uY2FsbGAsIHByb3ZpZGluZyBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIGBNeVN1YkNsYXNzYCBleHRlbmRzIGBNeVN1cGVyQ2xhc3NgLCBhbmQgYm90aCBkZWZpbmUgYSBgZHJhd2AgbWV0aG9kLCB0aGVuIGNhbGxpbmcgYHByb21vdGUoTXlTdWJDbGFzcywgXCJNeVN1cGVyQ2xhc3NcIilgXG4gKiB3b3VsZCBhZGQgYSBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYCBtZXRob2QgdG8gTXlTdWJDbGFzcyBhbmQgcHJvbW90ZSB0aGUgYGRyYXdgIG1ldGhvZCBvbiBgTXlTdXBlckNsYXNzYCB0byB0aGVcbiAqIHByb3RvdHlwZSBvZiBgTXlTdWJDbGFzc2AgYXMgYE15U3VwZXJDbGFzc19kcmF3YC5cbiAqXG4gKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGNsYXNzJ3MgcHJvdG90eXBlIGlzIGZ1bGx5IGRlZmluZWQuXG4gKlxuICogXHRmdW5jdGlvbiBDbGFzc0EobmFtZSkge1xuICogXHRcdHRoaXMubmFtZSA9IG5hbWU7XG4gKiBcdH1cbiAqIFx0Q2xhc3NBLnByb3RvdHlwZS5ncmVldCA9IGZ1bmN0aW9uKCkge1xuICogXHRcdHJldHVybiBcIkhlbGxvIFwiK3RoaXMubmFtZTtcbiAqIFx0fVxuICpcbiAqIFx0ZnVuY3Rpb24gQ2xhc3NCKG5hbWUsIHB1bmN0dWF0aW9uKSB7XG4gKiBcdFx0dGhpcy5DbGFzc0FfY29uc3RydWN0b3IobmFtZSk7XG4gKiBcdFx0dGhpcy5wdW5jdHVhdGlvbiA9IHB1bmN0dWF0aW9uO1xuICogXHR9XG4gKiBcdGNyZWF0ZWpzLmV4dGVuZChDbGFzc0IsIENsYXNzQSk7XG4gKiBcdENsYXNzQi5wcm90b3R5cGUuZ3JlZXQgPSBmdW5jdGlvbigpIHtcbiAqIFx0XHRyZXR1cm4gdGhpcy5DbGFzc0FfZ3JlZXQoKSt0aGlzLnB1bmN0dWF0aW9uO1xuICogXHR9XG4gKiBcdGNyZWF0ZWpzLnByb21vdGUoQ2xhc3NCLCBcIkNsYXNzQVwiKTtcbiAqXG4gKiBcdHZhciBmb28gPSBuZXcgQ2xhc3NCKFwiV29ybGRcIiwgXCIhPyFcIik7XG4gKiBcdGNvbnNvbGUubG9nKGZvby5ncmVldCgpKTsgLy8gSGVsbG8gV29ybGQhPyFcbiAqXG4gKiBAbWV0aG9kIHByb21vdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YmNsYXNzIFRoZSBjbGFzcyB0byBwcm9tb3RlIHN1cGVyIGNsYXNzIG1ldGhvZHMgb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IFRoZSBwcmVmaXggdG8gYWRkIHRvIHRoZSBwcm9tb3RlZCBtZXRob2QgbmFtZXMuIFVzdWFsbHkgdGhlIG5hbWUgb2YgdGhlIHN1cGVyY2xhc3MuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgc3ViY2xhc3MuXG4gKi9cbmNyZWF0ZWpzLnByb21vdGUgPSBmdW5jdGlvbihzdWJjbGFzcywgcHJlZml4KSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciBzdWJQID0gc3ViY2xhc3MucHJvdG90eXBlLCBzdXBQID0gKE9iamVjdC5nZXRQcm90b3R5cGVPZiYmT2JqZWN0LmdldFByb3RvdHlwZU9mKHN1YlApKXx8c3ViUC5fX3Byb3RvX187XG5cdGlmIChzdXBQKSB7XG5cdFx0c3ViUFsocHJlZml4Kz1cIl9cIikgKyBcImNvbnN0cnVjdG9yXCJdID0gc3VwUC5jb25zdHJ1Y3RvcjsgLy8gY29uc3RydWN0b3IgaXMgbm90IGFsd2F5cyBpbm51bWVyYWJsZVxuXHRcdGZvciAodmFyIG4gaW4gc3VwUCkge1xuXHRcdFx0aWYgKHN1YlAuaGFzT3duUHJvcGVydHkobikgJiYgKHR5cGVvZiBzdXBQW25dID09IFwiZnVuY3Rpb25cIikpIHsgc3ViUFtwcmVmaXggKyBuXSA9IHN1cFBbbl07IH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHN1YmNsYXNzO1xufTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEV2ZW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQ29udGFpbnMgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBzaGFyZWQgYnkgYWxsIGV2ZW50cyBmb3IgdXNlIHdpdGhcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBcblx0ICogTm90ZSB0aGF0IEV2ZW50IG9iamVjdHMgYXJlIG9mdGVuIHJldXNlZCwgc28geW91IHNob3VsZCBuZXZlclxuXHQgKiByZWx5IG9uIGFuIGV2ZW50IG9iamVjdCdzIHN0YXRlIG91dHNpZGUgb2YgdGhlIGNhbGwgc3RhY2sgaXQgd2FzIHJlY2VpdmVkIGluLlxuXHQgKiBAY2xhc3MgRXZlbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYnViYmxlcyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZXZlbnQgd2lsbCBidWJibGUgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNhbmNlbGFibGUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mIHRoaXMgZXZlbnQgY2FuIGJlIGNhbmNlbGxlZC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gRXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSkge1xuXHRcdFxuXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IHR5cGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiovXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIG9iamVjdCB0aGF0IGdlbmVyYXRlZCBhbiBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgdGFyZ2V0XG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy50YXJnZXQgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY3VycmVudCB0YXJnZXQgdGhhdCBhIGJ1YmJsaW5nIGV2ZW50IGlzIGJlaW5nIGRpc3BhdGNoZWQgZnJvbS4gRm9yIG5vbi1idWJibGluZyBldmVudHMsIHRoaXMgd2lsbFxuXHRcdCAqIGFsd2F5cyBiZSB0aGUgc2FtZSBhcyB0YXJnZXQuIEZvciBleGFtcGxlLCBpZiBjaGlsZE9iai5wYXJlbnQgPSBwYXJlbnRPYmosIGFuZCBhIGJ1YmJsaW5nIGV2ZW50XG5cdFx0ICogaXMgZ2VuZXJhdGVkIGZyb20gY2hpbGRPYmosIHRoZW4gYSBsaXN0ZW5lciBvbiBwYXJlbnRPYmogd291bGQgcmVjZWl2ZSB0aGUgZXZlbnQgd2l0aFxuXHRcdCAqIHRhcmdldD1jaGlsZE9iaiAodGhlIG9yaWdpbmFsIHRhcmdldCkgYW5kIGN1cnJlbnRUYXJnZXQ9cGFyZW50T2JqICh3aGVyZSB0aGUgbGlzdGVuZXIgd2FzIGFkZGVkKS5cblx0XHQgKiBAcHJvcGVydHkgY3VycmVudFRhcmdldFxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZvciBidWJibGluZyBldmVudHMsIHRoaXMgaW5kaWNhdGVzIHRoZSBjdXJyZW50IGV2ZW50IHBoYXNlOjxPTD5cblx0XHQgKiBcdDxMST4gY2FwdHVyZSBwaGFzZTogc3RhcnRpbmcgZnJvbSB0aGUgdG9wIHBhcmVudCB0byB0aGUgdGFyZ2V0PC9MST5cblx0XHQgKiBcdDxMST4gYXQgdGFyZ2V0IHBoYXNlOiBjdXJyZW50bHkgYmVpbmcgZGlzcGF0Y2hlZCBmcm9tIHRoZSB0YXJnZXQ8L0xJPlxuXHRcdCAqIFx0PExJPiBidWJibGluZyBwaGFzZTogZnJvbSB0aGUgdGFyZ2V0IHRvIHRoZSB0b3AgcGFyZW50PC9MST5cblx0XHQgKiA8L09MPlxuXHRcdCAqIEBwcm9wZXJ0eSBldmVudFBoYXNlXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5ldmVudFBoYXNlID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IHdpbGwgYnViYmxlIHRocm91Z2ggdGhlIGRpc3BsYXkgbGlzdC5cblx0XHQgKiBAcHJvcGVydHkgYnViYmxlc1xuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5idWJibGVzID0gISFidWJibGVzO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdGhpcyBldmVudCBjYW4gYmUgY2FuY2VsbGVkIHZpYVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50L3ByZXZlbnREZWZhdWx0XCJ9fXt7L2Nyb3NzTGlua319LiBUaGlzIGlzIHNldCB2aWEgdGhlIEV2ZW50IGNvbnN0cnVjdG9yLlxuXHRcdCAqIEBwcm9wZXJ0eSBjYW5jZWxhYmxlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmNhbmNlbGFibGUgPSAhIWNhbmNlbGFibGU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBlcG9jaCB0aW1lIGF0IHdoaWNoIHRoaXMgZXZlbnQgd2FzIGNyZWF0ZWQuXG5cdFx0ICogQHByb3BlcnR5IHRpbWVTdGFtcFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMudGltZVN0YW1wID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHt7I2Nyb3NzTGluayBcIkV2ZW50L3ByZXZlbnREZWZhdWx0XCJ9fXt7L2Nyb3NzTGlua319IGhhcyBiZWVuIGNhbGxlZFxuXHRcdCAqIG9uIHRoaXMgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IGRlZmF1bHRQcmV2ZW50ZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYge3sjY3Jvc3NMaW5rIFwiRXZlbnQvc3RvcFByb3BhZ2F0aW9uXCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXCJ9fXt7L2Nyb3NzTGlua319IGhhcyBiZWVuIGNhbGxlZCBvbiB0aGlzIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBwcm9wYWdhdGlvblN0b3BwZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkXG5cdFx0ICogb24gdGhpcyBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9yZW1vdmVcIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkIG9uIHRoaXMgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IHJlbW92ZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMucmVtb3ZlZCA9IGZhbHNlO1xuXHR9XG5cdHZhciBwID0gRXZlbnQucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblx0XG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogU2V0cyB7eyNjcm9zc0xpbmsgXCJFdmVudC9kZWZhdWx0UHJldmVudGVkXCJ9fXt7L2Nyb3NzTGlua319IHRvIHRydWUuXG5cdCAqIE1pcnJvcnMgdGhlIERPTSBldmVudCBzdGFuZGFyZC5cblx0ICogQG1ldGhvZCBwcmV2ZW50RGVmYXVsdFxuXHQgKiovXG5cdHAucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0aGlzLmNhbmNlbGFibGUmJnRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcHJvcGFnYXRpb25TdG9wcGVkXCJ9fXt7L2Nyb3NzTGlua319IHRvIHRydWUuXG5cdCAqIE1pcnJvcnMgdGhlIERPTSBldmVudCBzdGFuZGFyZC5cblx0ICogQG1ldGhvZCBzdG9wUHJvcGFnYXRpb25cblx0ICoqL1xuXHRwLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB7eyNjcm9zc0xpbmsgXCJFdmVudC9wcm9wYWdhdGlvblN0b3BwZWRcIn19e3svY3Jvc3NMaW5rfX0gYW5kXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50L2ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZFwifX17ey9jcm9zc0xpbmt9fSB0byB0cnVlLlxuXHQgKiBNaXJyb3JzIHRoZSBET00gZXZlbnQgc3RhbmRhcmQuXG5cdCAqIEBtZXRob2Qgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXG5cdCAqKi9cblx0cC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDYXVzZXMgdGhlIGFjdGl2ZSBsaXN0ZW5lciB0byBiZSByZW1vdmVkIHZpYSByZW1vdmVFdmVudExpc3RlbmVyKCk7XG5cdCAqIFxuXHQgKiBcdFx0bXlCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2dCkge1xuXHQgKiBcdFx0XHQvLyBkbyBzdHVmZi4uLlxuXHQgKiBcdFx0XHRldnQucmVtb3ZlKCk7IC8vIHJlbW92ZXMgdGhpcyBsaXN0ZW5lci5cblx0ICogXHRcdH0pO1xuXHQgKiBcblx0ICogQG1ldGhvZCByZW1vdmVcblx0ICoqL1xuXHRwLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVtb3ZlZCA9IHRydWU7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBFdmVudCBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtFdmVudH0gYSBjbG9uZSBvZiB0aGUgRXZlbnQgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgRXZlbnQodGhpcy50eXBlLCB0aGlzLmJ1YmJsZXMsIHRoaXMuY2FuY2VsYWJsZSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUHJvdmlkZXMgYSBjaGFpbmFibGUgc2hvcnRjdXQgbWV0aG9kIGZvciBzZXR0aW5nIGEgbnVtYmVyIG9mIHByb3BlcnRpZXMgb24gdGhlIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHNldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQSBnZW5lcmljIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gY29weSB0byB0aGUgaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4ge0V2ZW50fSBSZXR1cm5zIHRoZSBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5zZXQgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdGZvciAodmFyIG4gaW4gcHJvcHMpIHsgdGhpc1tuXSA9IHByb3BzW25dOyB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltFdmVudCAodHlwZT1cIit0aGlzLnR5cGUrXCIpXVwiO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkV2ZW50ID0gRXZlbnQ7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRXZlbnREaXNwYXRjaGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuLy8gY29uc3RydWN0b3I6XHJcblx0LyoqXHJcblx0ICogRXZlbnREaXNwYXRjaGVyIHByb3ZpZGVzIG1ldGhvZHMgZm9yIG1hbmFnaW5nIHF1ZXVlcyBvZiBldmVudCBsaXN0ZW5lcnMgYW5kIGRpc3BhdGNoaW5nIGV2ZW50cy5cclxuXHQgKlxyXG5cdCAqIFlvdSBjYW4gZWl0aGVyIGV4dGVuZCBFdmVudERpc3BhdGNoZXIgb3IgbWl4IGl0cyBtZXRob2RzIGludG8gYW4gZXhpc3RpbmcgcHJvdG90eXBlIG9yIGluc3RhbmNlIGJ5IHVzaW5nIHRoZVxyXG5cdCAqIEV2ZW50RGlzcGF0Y2hlciB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvaW5pdGlhbGl6ZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXHJcblx0ICogXHJcblx0ICogVG9nZXRoZXIgd2l0aCB0aGUgQ3JlYXRlSlMgRXZlbnQgY2xhc3MsIEV2ZW50RGlzcGF0Y2hlciBwcm92aWRlcyBhbiBleHRlbmRlZCBldmVudCBtb2RlbCB0aGF0IGlzIGJhc2VkIG9uIHRoZVxyXG5cdCAqIERPTSBMZXZlbCAyIGV2ZW50IG1vZGVsLCBpbmNsdWRpbmcgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciwgYW5kIGRpc3BhdGNoRXZlbnQuIEl0IHN1cHBvcnRzXHJcblx0ICogYnViYmxpbmcgLyBjYXB0dXJlLCBwcmV2ZW50RGVmYXVsdCwgc3RvcFByb3BhZ2F0aW9uLCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24sIGFuZCBoYW5kbGVFdmVudC5cclxuXHQgKiBcclxuXHQgKiBFdmVudERpc3BhdGNoZXIgYWxzbyBleHBvc2VzIGEge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL29uXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCwgd2hpY2ggbWFrZXMgaXQgZWFzaWVyXHJcblx0ICogdG8gY3JlYXRlIHNjb3BlZCBsaXN0ZW5lcnMsIGxpc3RlbmVycyB0aGF0IG9ubHkgcnVuIG9uY2UsIGFuZCBsaXN0ZW5lcnMgd2l0aCBhc3NvY2lhdGVkIGFyYml0cmFyeSBkYXRhLiBUaGUgXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL29mZlwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgaXMgbWVyZWx5IGFuIGFsaWFzIHRvXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL3JlbW92ZUV2ZW50TGlzdGVuZXJcIn19e3svY3Jvc3NMaW5rfX0uXHJcblx0ICogXHJcblx0ICogQW5vdGhlciBhZGRpdGlvbiB0byB0aGUgRE9NIExldmVsIDIgbW9kZWwgaXMgdGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9yZW1vdmVBbGxFdmVudExpc3RlbmVyc1wifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIG1ldGhvZCwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbGlzdGVuZXJzIGZvciBhbGwgZXZlbnRzLCBvciBsaXN0ZW5lcnMgZm9yIGEgc3BlY2lmaWMgZXZlbnQuIFRoZSBFdmVudCBvYmplY3QgYWxzbyBcclxuXHQgKiBpbmNsdWRlcyBhIHt7I2Nyb3NzTGluayBcIkV2ZW50L3JlbW92ZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2Qgd2hpY2ggcmVtb3ZlcyB0aGUgYWN0aXZlIGxpc3RlbmVyLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqIEFkZCBFdmVudERpc3BhdGNoZXIgY2FwYWJpbGl0aWVzIHRvIHRoZSBcIk15Q2xhc3NcIiBjbGFzcy5cclxuXHQgKlxyXG5cdCAqICAgICAgRXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUoTXlDbGFzcy5wcm90b3R5cGUpO1xyXG5cdCAqXHJcblx0ICogQWRkIGFuIGV2ZW50IChzZWUge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL2FkZEV2ZW50TGlzdGVuZXJcIn19e3svY3Jvc3NMaW5rfX0pLlxyXG5cdCAqXHJcblx0ICogICAgICBpbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKFwiZXZlbnROYW1lXCIsIGhhbmRsZXJNZXRob2QpO1xyXG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlck1ldGhvZChldmVudCkge1xyXG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LnRhcmdldCArIFwiIFdhcyBDbGlja2VkXCIpO1xyXG5cdCAqICAgICAgfVxyXG5cdCAqXHJcblx0ICogPGI+TWFpbnRhaW5pbmcgcHJvcGVyIHNjb3BlPC9iPjxiciAvPlxyXG5cdCAqIFNjb3BlIChpZS4gXCJ0aGlzXCIpIGNhbiBiZSBiZSBhIGNoYWxsZW5nZSB3aXRoIGV2ZW50cy4gVXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9vblwifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIG1ldGhvZCB0byBzdWJzY3JpYmUgdG8gZXZlbnRzIHNpbXBsaWZpZXMgdGhpcy5cclxuXHQgKlxyXG5cdCAqICAgICAgaW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0ICogICAgICAgICAgY29uc29sZS5sb2coaW5zdGFuY2UgPT0gdGhpcyk7IC8vIGZhbHNlLCBzY29wZSBpcyBhbWJpZ3VvdXMuXHJcblx0ICogICAgICB9KTtcclxuXHQgKiAgICAgIFxyXG5cdCAqICAgICAgaW5zdGFuY2Uub24oXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCkge1xyXG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKGluc3RhbmNlID09IHRoaXMpOyAvLyB0cnVlLCBcIm9uXCIgdXNlcyBkaXNwYXRjaGVyIHNjb3BlIGJ5IGRlZmF1bHQuXHJcblx0ICogICAgICB9KTtcclxuXHQgKiBcclxuXHQgKiBJZiB5b3Ugd2FudCB0byB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpbnN0ZWFkLCB5b3UgbWF5IHdhbnQgdG8gdXNlIGZ1bmN0aW9uLmJpbmQoKSBvciBhIHNpbWlsYXIgcHJveHkgdG8gbWFuYWdlIHNjb3BlLlxyXG5cdCAqICAgICAgXHJcblx0ICpcclxuXHQgKiBAY2xhc3MgRXZlbnREaXNwYXRjaGVyXHJcblx0ICogQGNvbnN0cnVjdG9yXHJcblx0ICoqL1xyXG5cdGZ1bmN0aW9uIEV2ZW50RGlzcGF0Y2hlcigpIHtcclxuXHRcclxuXHRcclxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XHJcblx0XHQvKipcclxuXHRcdCAqIEBwcm90ZWN0ZWRcclxuXHRcdCAqIEBwcm9wZXJ0eSBfbGlzdGVuZXJzXHJcblx0XHQgKiBAdHlwZSBPYmplY3RcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuX2xpc3RlbmVycyA9IG51bGw7XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogQHByb3RlY3RlZFxyXG5cdFx0ICogQHByb3BlcnR5IF9jYXB0dXJlTGlzdGVuZXJzXHJcblx0XHQgKiBAdHlwZSBPYmplY3RcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgPSBudWxsO1xyXG5cdH1cclxuXHR2YXIgcCA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGU7XHJcblxyXG5cdC8qKlxyXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cclxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cclxuXHQgKiBmb3IgZGV0YWlscy5cclxuXHQgKlxyXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqIEBkZXByZWNhdGVkXHJcblx0ICovXHJcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXHJcblxyXG5cclxuLy8gc3RhdGljIHB1YmxpYyBtZXRob2RzOlxyXG5cdC8qKlxyXG5cdCAqIFN0YXRpYyBpbml0aWFsaXplciB0byBtaXggRXZlbnREaXNwYXRjaGVyIG1ldGhvZHMgaW50byBhIHRhcmdldCBvYmplY3Qgb3IgcHJvdG90eXBlLlxyXG5cdCAqIFxyXG5cdCAqIFx0XHRFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShNeUNsYXNzLnByb3RvdHlwZSk7IC8vIGFkZCB0byB0aGUgcHJvdG90eXBlIG9mIHRoZSBjbGFzc1xyXG5cdCAqIFx0XHRFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShteU9iamVjdCk7IC8vIGFkZCB0byBhIHNwZWNpZmljIGluc3RhbmNlXHJcblx0ICogXHJcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXHJcblx0ICogQHN0YXRpY1xyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdG8gaW5qZWN0IEV2ZW50RGlzcGF0Y2hlciBtZXRob2RzIGludG8uIFRoaXMgY2FuIGJlIGFuIGluc3RhbmNlIG9yIGFcclxuXHQgKiBwcm90b3R5cGUuXHJcblx0ICoqL1xyXG5cdEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplID0gZnVuY3Rpb24odGFyZ2V0KSB7XHJcblx0XHR0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lciA9IHAuYWRkRXZlbnRMaXN0ZW5lcjtcclxuXHRcdHRhcmdldC5vbiA9IHAub247XHJcblx0XHR0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHRhcmdldC5vZmYgPSAgcC5yZW1vdmVFdmVudExpc3RlbmVyO1xyXG5cdFx0dGFyZ2V0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gcC5yZW1vdmVBbGxFdmVudExpc3RlbmVycztcclxuXHRcdHRhcmdldC5oYXNFdmVudExpc3RlbmVyID0gcC5oYXNFdmVudExpc3RlbmVyO1xyXG5cdFx0dGFyZ2V0LmRpc3BhdGNoRXZlbnQgPSBwLmRpc3BhdGNoRXZlbnQ7XHJcblx0XHR0YXJnZXQuX2Rpc3BhdGNoRXZlbnQgPSBwLl9kaXNwYXRjaEV2ZW50O1xyXG5cdFx0dGFyZ2V0LndpbGxUcmlnZ2VyID0gcC53aWxsVHJpZ2dlcjtcclxuXHR9O1xyXG5cdFxyXG5cclxuLy8gcHVibGljIG1ldGhvZHM6XHJcblx0LyoqXHJcblx0ICogQWRkcyB0aGUgc3BlY2lmaWVkIGV2ZW50IGxpc3RlbmVyLiBOb3RlIHRoYXQgYWRkaW5nIG11bHRpcGxlIGxpc3RlbmVycyB0byB0aGUgc2FtZSBmdW5jdGlvbiB3aWxsIHJlc3VsdCBpblxyXG5cdCAqIG11bHRpcGxlIGNhbGxiYWNrcyBnZXR0aW5nIGZpcmVkLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljayk7XHJcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xyXG5cdCAqICAgICAgICAgLy8gQ2xpY2sgaGFwcGVuZWQuXHJcblx0ICogICAgICB9XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXJcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb24gfCBPYmplY3R9IGxpc3RlbmVyIEFuIG9iamVjdCB3aXRoIGEgaGFuZGxlRXZlbnQgbWV0aG9kLCBvciBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlblxyXG5cdCAqIHRoZSBldmVudCBpcyBkaXNwYXRjaGVkLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdIEZvciBldmVudHMgdGhhdCBidWJibGUsIGluZGljYXRlcyB3aGV0aGVyIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50IGluIHRoZSBjYXB0dXJlIG9yIGJ1YmJsaW5nL3RhcmdldCBwaGFzZS5cclxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbiB8IE9iamVjdH0gUmV0dXJucyB0aGUgbGlzdGVuZXIgZm9yIGNoYWluaW5nIG9yIGFzc2lnbm1lbnQuXHJcblx0ICoqL1xyXG5cdHAuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzO1xyXG5cdFx0aWYgKHVzZUNhcHR1cmUpIHtcclxuXHRcdFx0bGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnN8fHt9O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzfHx7fTtcclxuXHRcdH1cclxuXHRcdHZhciBhcnIgPSBsaXN0ZW5lcnNbdHlwZV07XHJcblx0XHRpZiAoYXJyKSB7IHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7IH1cclxuXHRcdGFyciA9IGxpc3RlbmVyc1t0eXBlXTsgLy8gcmVtb3ZlIG1heSBoYXZlIGRlbGV0ZWQgdGhlIGFycmF5XHJcblx0XHRpZiAoIWFycikgeyBsaXN0ZW5lcnNbdHlwZV0gPSBbbGlzdGVuZXJdOyAgfVxyXG5cdFx0ZWxzZSB7IGFyci5wdXNoKGxpc3RlbmVyKTsgfVxyXG5cdFx0cmV0dXJuIGxpc3RlbmVyO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogQSBzaG9ydGN1dCBtZXRob2QgZm9yIHVzaW5nIGFkZEV2ZW50TGlzdGVuZXIgdGhhdCBtYWtlcyBpdCBlYXNpZXIgdG8gc3BlY2lmeSBhbiBleGVjdXRpb24gc2NvcGUsIGhhdmUgYSBsaXN0ZW5lclxyXG5cdCAqIG9ubHkgcnVuIG9uY2UsIGFzc29jaWF0ZSBhcmJpdHJhcnkgZGF0YSB3aXRoIHRoZSBsaXN0ZW5lciwgYW5kIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblx0ICogXHJcblx0ICogVGhpcyBtZXRob2Qgd29ya3MgYnkgY3JlYXRpbmcgYW4gYW5vbnltb3VzIHdyYXBwZXIgZnVuY3Rpb24gYW5kIHN1YnNjcmliaW5nIGl0IHdpdGggYWRkRXZlbnRMaXN0ZW5lci5cclxuXHQgKiBUaGUgY3JlYXRlZCBhbm9ueW1vdXMgZnVuY3Rpb24gaXMgcmV0dXJuZWQgZm9yIHVzZSB3aXRoIC5yZW1vdmVFdmVudExpc3RlbmVyIChvciAub2ZmKS5cclxuXHQgKiBcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICogXHJcblx0ICogXHRcdHZhciBsaXN0ZW5lciA9IG15QnRuLm9uKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2ssIG51bGwsIGZhbHNlLCB7Y291bnQ6M30pO1xyXG5cdCAqIFx0XHRmdW5jdGlvbiBoYW5kbGVDbGljayhldnQsIGRhdGEpIHtcclxuXHQgKiBcdFx0XHRkYXRhLmNvdW50IC09IDE7XHJcblx0ICogXHRcdFx0Y29uc29sZS5sb2codGhpcyA9PSBteUJ0bik7IC8vIHRydWUgLSBzY29wZSBkZWZhdWx0cyB0byB0aGUgZGlzcGF0Y2hlclxyXG5cdCAqIFx0XHRcdGlmIChkYXRhLmNvdW50ID09IDApIHtcclxuXHQgKiBcdFx0XHRcdGFsZXJ0KFwiY2xpY2tlZCAzIHRpbWVzIVwiKTtcclxuXHQgKiBcdFx0XHRcdG15QnRuLm9mZihcImNsaWNrXCIsIGxpc3RlbmVyKTtcclxuXHQgKiBcdFx0XHRcdC8vIGFsdGVybmF0ZWx5OiBldnQucmVtb3ZlKCk7XHJcblx0ICogXHRcdFx0fVxyXG5cdCAqIFx0XHR9XHJcblx0ICogXHJcblx0ICogQG1ldGhvZCBvblxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbiB8IE9iamVjdH0gbGlzdGVuZXIgQW4gb2JqZWN0IHdpdGggYSBoYW5kbGVFdmVudCBtZXRob2QsIG9yIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuXHJcblx0ICogdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gVGhlIHNjb3BlIHRvIGV4ZWN1dGUgdGhlIGxpc3RlbmVyIGluLiBEZWZhdWx0cyB0byB0aGUgZGlzcGF0Y2hlci9jdXJyZW50VGFyZ2V0IGZvciBmdW5jdGlvbiBsaXN0ZW5lcnMsIGFuZCB0byB0aGUgbGlzdGVuZXIgaXRzZWxmIGZvciBvYmplY3QgbGlzdGVuZXJzIChpZS4gdXNpbmcgaGFuZGxlRXZlbnQpLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIElmIHRydWUsIHRoZSBsaXN0ZW5lciB3aWxsIHJlbW92ZSBpdHNlbGYgYWZ0ZXIgdGhlIGZpcnN0IHRpbWUgaXQgaXMgdHJpZ2dlcmVkLlxyXG5cdCAqIEBwYXJhbSB7Kn0gW2RhdGFdIEFyYml0cmFyeSBkYXRhIHRoYXQgd2lsbCBiZSBpbmNsdWRlZCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciB3aGVuIHRoZSBsaXN0ZW5lciBpcyBjYWxsZWQuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZT1mYWxzZV0gRm9yIGV2ZW50cyB0aGF0IGJ1YmJsZSwgaW5kaWNhdGVzIHdoZXRoZXIgdG8gbGlzdGVuIGZvciB0aGUgZXZlbnQgaW4gdGhlIGNhcHR1cmUgb3IgYnViYmxpbmcvdGFyZ2V0IHBoYXNlLlxyXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBhbm9ueW1vdXMgZnVuY3Rpb24gdGhhdCB3YXMgY3JlYXRlZCBhbmQgYXNzaWduZWQgYXMgdGhlIGxpc3RlbmVyLiBUaGlzIGlzIG5lZWRlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGxhdGVyIHVzaW5nIC5yZW1vdmVFdmVudExpc3RlbmVyLlxyXG5cdCAqKi9cclxuXHRwLm9uID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIHNjb3BlLCBvbmNlLCBkYXRhLCB1c2VDYXB0dXJlKSB7XHJcblx0XHRpZiAobGlzdGVuZXIuaGFuZGxlRXZlbnQpIHtcclxuXHRcdFx0c2NvcGUgPSBzY29wZXx8bGlzdGVuZXI7XHJcblx0XHRcdGxpc3RlbmVyID0gbGlzdGVuZXIuaGFuZGxlRXZlbnQ7XHJcblx0XHR9XHJcblx0XHRzY29wZSA9IHNjb3BlfHx0aGlzO1xyXG5cdFx0cmV0dXJuIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jdGlvbihldnQpIHtcclxuXHRcdFx0XHRsaXN0ZW5lci5jYWxsKHNjb3BlLCBldnQsIGRhdGEpO1xyXG5cdFx0XHRcdG9uY2UmJmV2dC5yZW1vdmUoKTtcclxuXHRcdFx0fSwgdXNlQ2FwdHVyZSk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGV2ZW50IGxpc3RlbmVyLlxyXG5cdCAqXHJcblx0ICogPGI+SW1wb3J0YW50IE5vdGU6PC9iPiB0aGF0IHlvdSBtdXN0IHBhc3MgdGhlIGV4YWN0IGZ1bmN0aW9uIHJlZmVyZW5jZSB1c2VkIHdoZW4gdGhlIGV2ZW50IHdhcyBhZGRlZC4gSWYgYSBwcm94eVxyXG5cdCAqIGZ1bmN0aW9uLCBvciBmdW5jdGlvbiBjbG9zdXJlIGlzIHVzZWQgYXMgdGhlIGNhbGxiYWNrLCB0aGUgcHJveHkvY2xvc3VyZSByZWZlcmVuY2UgbXVzdCBiZSB1c2VkIC0gYSBuZXcgcHJveHkgb3JcclxuXHQgKiBjbG9zdXJlIHdpbGwgbm90IHdvcmsuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrKTtcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lclxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbiB8IE9iamVjdH0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIG9yIG9iamVjdC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXHJcblx0ICoqL1xyXG5cdHAucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdXNlQ2FwdHVyZSA/IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgOiB0aGlzLl9saXN0ZW5lcnM7XHJcblx0XHRpZiAoIWxpc3RlbmVycykgeyByZXR1cm47IH1cclxuXHRcdHZhciBhcnIgPSBsaXN0ZW5lcnNbdHlwZV07XHJcblx0XHRpZiAoIWFycikgeyByZXR1cm47IH1cclxuXHRcdGZvciAodmFyIGk9MCxsPWFyci5sZW5ndGg7IGk8bDsgaSsrKSB7XHJcblx0XHRcdGlmIChhcnJbaV0gPT0gbGlzdGVuZXIpIHtcclxuXHRcdFx0XHRpZiAobD09MSkgeyBkZWxldGUobGlzdGVuZXJzW3R5cGVdKTsgfSAvLyBhbGxvd3MgZm9yIGZhc3RlciBjaGVja3MuXHJcblx0XHRcdFx0ZWxzZSB7IGFyci5zcGxpY2UoaSwxKTsgfVxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBBIHNob3J0Y3V0IHRvIHRoZSByZW1vdmVFdmVudExpc3RlbmVyIG1ldGhvZCwgd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFuZCByZXR1cm4gdmFsdWUuIFRoaXMgaXMgYSBjb21wYW5pb24gdG8gdGhlXHJcblx0ICogLm9uIG1ldGhvZC5cclxuXHQgKlxyXG5cdCAqIEBtZXRob2Qgb2ZmXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gb3Igb2JqZWN0LlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdIEZvciBldmVudHMgdGhhdCBidWJibGUsIGluZGljYXRlcyB3aGV0aGVyIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50IGluIHRoZSBjYXB0dXJlIG9yIGJ1YmJsaW5nL3RhcmdldCBwaGFzZS5cclxuXHQgKiovXHJcblx0cC5vZmYgPSBwLnJlbW92ZUV2ZW50TGlzdGVuZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBmb3IgdGhlIHNwZWNpZmllZCB0eXBlLCBvciBhbGwgbGlzdGVuZXJzIG9mIGFsbCB0eXBlcy5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnNcclxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoKTtcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gUmVtb3ZlIGFsbCBjbGljayBsaXN0ZW5lcnNcclxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoXCJjbGlja1wiKTtcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnNcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuIElmIG9taXR0ZWQsIGFsbCBsaXN0ZW5lcnMgZm9yIGFsbCB0eXBlcyB3aWxsIGJlIHJlbW92ZWQuXHJcblx0ICoqL1xyXG5cdHAucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XHJcblx0XHRpZiAoIXR5cGUpIHsgdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA9IG51bGw7IH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRpZiAodGhpcy5fbGlzdGVuZXJzKSB7IGRlbGV0ZSh0aGlzLl9saXN0ZW5lcnNbdHlwZV0pOyB9XHJcblx0XHRcdGlmICh0aGlzLl9jYXB0dXJlTGlzdGVuZXJzKSB7IGRlbGV0ZSh0aGlzLl9jYXB0dXJlTGlzdGVuZXJzW3R5cGVdKTsgfVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIERpc3BhdGNoZXMgdGhlIHNwZWNpZmllZCBldmVudCB0byBhbGwgbGlzdGVuZXJzLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICAvLyBVc2UgYSBzdHJpbmcgZXZlbnRcclxuXHQgKiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpO1xyXG5cdCAqXHJcblx0ICogICAgICAvLyBVc2UgYW4gRXZlbnQgaW5zdGFuY2VcclxuXHQgKiAgICAgIHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcInByb2dyZXNzXCIpO1xyXG5cdCAqICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgZGlzcGF0Y2hFdmVudFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0IHwgU3RyaW5nIHwgRXZlbnR9IGV2ZW50T2JqIEFuIG9iamVjdCB3aXRoIGEgXCJ0eXBlXCIgcHJvcGVydHksIG9yIGEgc3RyaW5nIHR5cGUuXHJcblx0ICogV2hpbGUgYSBnZW5lcmljIG9iamVjdCB3aWxsIHdvcmssIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBhIENyZWF0ZUpTIEV2ZW50IGluc3RhbmNlLiBJZiBhIHN0cmluZyBpcyB1c2VkLFxyXG5cdCAqIGRpc3BhdGNoRXZlbnQgd2lsbCBjb25zdHJ1Y3QgYW4gRXZlbnQgaW5zdGFuY2Ugd2l0aCB0aGUgc3BlY2lmaWVkIHR5cGUuXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0aGUgdmFsdWUgb2YgZXZlbnRPYmouZGVmYXVsdFByZXZlbnRlZC5cclxuXHQgKiovXHJcblx0cC5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnRPYmopIHtcclxuXHRcdGlmICh0eXBlb2YgZXZlbnRPYmogPT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHQvLyB3b24ndCBidWJibGUsIHNvIHNraXAgZXZlcnl0aGluZyBpZiB0aGVyZSdzIG5vIGxpc3RlbmVyczpcclxuXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuXHRcdFx0aWYgKCFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVyc1tldmVudE9ial0pIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdGV2ZW50T2JqID0gbmV3IGNyZWF0ZWpzLkV2ZW50KGV2ZW50T2JqKTtcclxuXHRcdH0gZWxzZSBpZiAoZXZlbnRPYmoudGFyZ2V0ICYmIGV2ZW50T2JqLmNsb25lKSB7XHJcblx0XHRcdC8vIHJlZGlzcGF0Y2hpbmcgYW4gYWN0aXZlIGV2ZW50IG9iamVjdCwgc28gY2xvbmUgaXQ6XHJcblx0XHRcdGV2ZW50T2JqID0gZXZlbnRPYmouY2xvbmUoKTtcclxuXHRcdH1cclxuXHRcdHRyeSB7IGV2ZW50T2JqLnRhcmdldCA9IHRoaXM7IH0gY2F0Y2ggKGUpIHt9IC8vIHRyeS9jYXRjaCBhbGxvd3MgcmVkaXNwYXRjaGluZyBvZiBuYXRpdmUgZXZlbnRzXHJcblxyXG5cdFx0aWYgKCFldmVudE9iai5idWJibGVzIHx8ICF0aGlzLnBhcmVudCkge1xyXG5cdFx0XHR0aGlzLl9kaXNwYXRjaEV2ZW50KGV2ZW50T2JqLCAyKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciB0b3A9dGhpcywgbGlzdD1bdG9wXTtcclxuXHRcdFx0d2hpbGUgKHRvcC5wYXJlbnQpIHsgbGlzdC5wdXNoKHRvcCA9IHRvcC5wYXJlbnQpOyB9XHJcblx0XHRcdHZhciBpLCBsPWxpc3QubGVuZ3RoO1xyXG5cclxuXHRcdFx0Ly8gY2FwdHVyZSAmIGF0VGFyZ2V0XHJcblx0XHRcdGZvciAoaT1sLTE7IGk+PTAgJiYgIWV2ZW50T2JqLnByb3BhZ2F0aW9uU3RvcHBlZDsgaS0tKSB7XHJcblx0XHRcdFx0bGlzdFtpXS5fZGlzcGF0Y2hFdmVudChldmVudE9iaiwgMSsoaT09MCkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGJ1YmJsaW5nXHJcblx0XHRcdGZvciAoaT0xOyBpPGwgJiYgIWV2ZW50T2JqLnByb3BhZ2F0aW9uU3RvcHBlZDsgaSsrKSB7XHJcblx0XHRcdFx0bGlzdFtpXS5fZGlzcGF0Y2hFdmVudChldmVudE9iaiwgMyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBldmVudE9iai5kZWZhdWx0UHJldmVudGVkO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudCB0eXBlLlxyXG5cdCAqIEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lclxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cclxuXHQgKiovXHJcblx0cC5oYXNFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycywgY2FwdHVyZUxpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnM7XHJcblx0XHRyZXR1cm4gISEoKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnNbdHlwZV0pIHx8IChjYXB0dXJlTGlzdGVuZXJzICYmIGNhcHR1cmVMaXN0ZW5lcnNbdHlwZV0pKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudCB0eXBlIG9uIHRoaXMgb2JqZWN0IG9yIGFueSBvZiBpdHNcclxuXHQgKiBhbmNlc3RvcnMgKHBhcmVudCwgcGFyZW50J3MgcGFyZW50LCBldGMpLiBBIHJldHVybiB2YWx1ZSBvZiB0cnVlIGluZGljYXRlcyB0aGF0IGlmIGEgYnViYmxpbmcgZXZlbnQgb2YgdGhlXHJcblx0ICogc3BlY2lmaWVkIHR5cGUgaXMgZGlzcGF0Y2hlZCBmcm9tIHRoaXMgb2JqZWN0LCBpdCB3aWxsIHRyaWdnZXIgYXQgbGVhc3Qgb25lIGxpc3RlbmVyLlxyXG5cdCAqIFxyXG5cdCAqIFRoaXMgaXMgc2ltaWxhciB0byB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvaGFzRXZlbnRMaXN0ZW5lclwifX17ey9jcm9zc0xpbmt9fSwgYnV0IGl0IHNlYXJjaGVzIHRoZSBlbnRpcmVcclxuXHQgKiBldmVudCBmbG93IGZvciBhIGxpc3RlbmVyLCBub3QganVzdCB0aGlzIG9iamVjdC5cclxuXHQgKiBAbWV0aG9kIHdpbGxUcmlnZ2VyXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXHJcblx0ICoqL1xyXG5cdHAud2lsbFRyaWdnZXIgPSBmdW5jdGlvbih0eXBlKSB7XHJcblx0XHR2YXIgbyA9IHRoaXM7XHJcblx0XHR3aGlsZSAobykge1xyXG5cdFx0XHRpZiAoby5oYXNFdmVudExpc3RlbmVyKHR5cGUpKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcdG8gPSBvLnBhcmVudDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXHJcblx0ICoqL1xyXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBcIltFdmVudERpc3BhdGNoZXJdXCI7XHJcblx0fTtcclxuXHJcblxyXG4vLyBwcml2YXRlIG1ldGhvZHM6XHJcblx0LyoqXHJcblx0ICogQG1ldGhvZCBfZGlzcGF0Y2hFdmVudFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0IHwgU3RyaW5nIHwgRXZlbnR9IGV2ZW50T2JqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50UGhhc2VcclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICoqL1xyXG5cdHAuX2Rpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudE9iaiwgZXZlbnRQaGFzZSkge1xyXG5cdFx0dmFyIGwsIGxpc3RlbmVycyA9IChldmVudFBoYXNlPT0xKSA/IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgOiB0aGlzLl9saXN0ZW5lcnM7XHJcblx0XHRpZiAoZXZlbnRPYmogJiYgbGlzdGVuZXJzKSB7XHJcblx0XHRcdHZhciBhcnIgPSBsaXN0ZW5lcnNbZXZlbnRPYmoudHlwZV07XHJcblx0XHRcdGlmICghYXJyfHwhKGw9YXJyLmxlbmd0aCkpIHsgcmV0dXJuOyB9XHJcblx0XHRcdHRyeSB7IGV2ZW50T2JqLmN1cnJlbnRUYXJnZXQgPSB0aGlzOyB9IGNhdGNoIChlKSB7fVxyXG5cdFx0XHR0cnkgeyBldmVudE9iai5ldmVudFBoYXNlID0gZXZlbnRQaGFzZTsgfSBjYXRjaCAoZSkge31cclxuXHRcdFx0ZXZlbnRPYmoucmVtb3ZlZCA9IGZhbHNlO1xyXG5cdFx0XHRcclxuXHRcdFx0YXJyID0gYXJyLnNsaWNlKCk7IC8vIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGl0ZW1zIGJlaW5nIHJlbW92ZWQgb3IgYWRkZWQgZHVyaW5nIHRoZSBkaXNwYXRjaFxyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bCAmJiAhZXZlbnRPYmouaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgbyA9IGFycltpXTtcclxuXHRcdFx0XHRpZiAoby5oYW5kbGVFdmVudCkgeyBvLmhhbmRsZUV2ZW50KGV2ZW50T2JqKTsgfVxyXG5cdFx0XHRcdGVsc2UgeyBvKGV2ZW50T2JqKTsgfVxyXG5cdFx0XHRcdGlmIChldmVudE9iai5yZW1vdmVkKSB7XHJcblx0XHRcdFx0XHR0aGlzLm9mZihldmVudE9iai50eXBlLCBvLCBldmVudFBoYXNlPT0xKTtcclxuXHRcdFx0XHRcdGV2ZW50T2JqLnJlbW92ZWQgPSBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHJcblx0Y3JlYXRlanMuRXZlbnREaXNwYXRjaGVyID0gRXZlbnREaXNwYXRjaGVyO1xyXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVGlja2VyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBUaGUgVGlja2VyIHByb3ZpZGVzIGEgY2VudHJhbGl6ZWQgdGljayBvciBoZWFydGJlYXQgYnJvYWRjYXN0IGF0IGEgc2V0IGludGVydmFsLiBMaXN0ZW5lcnMgY2FuIHN1YnNjcmliZSB0byB0aGUgdGlja1xuXHQgKiBldmVudCB0byBiZSBub3RpZmllZCB3aGVuIGEgc2V0IHRpbWUgaW50ZXJ2YWwgaGFzIGVsYXBzZWQuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgaW50ZXJ2YWwgdGhhdCB0aGUgdGljayBldmVudCBpcyBjYWxsZWQgaXMgYSB0YXJnZXQgaW50ZXJ2YWwsIGFuZCBtYXkgYmUgYnJvYWRjYXN0IGF0IGEgc2xvd2VyIGludGVydmFsXG5cdCAqIHdoZW4gdW5kZXIgaGlnaCBDUFUgbG9hZC4gVGhlIFRpY2tlciBjbGFzcyB1c2VzIGEgc3RhdGljIGludGVyZmFjZSAoZXguIGBUaWNrZXIuZnJhbWVyYXRlID0gMzA7YCkgYW5kXG5cdCAqIGNhbiBub3QgYmUgaW5zdGFudGlhdGVkLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIGhhbmRsZVRpY2spO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZVRpY2soZXZlbnQpIHtcblx0ICogICAgICAgICAgLy8gQWN0aW9ucyBjYXJyaWVkIG91dCBlYWNoIHRpY2sgKGFrYSBmcmFtZSlcblx0ICogICAgICAgICAgaWYgKCFldmVudC5wYXVzZWQpIHtcblx0ICogICAgICAgICAgICAgIC8vIEFjdGlvbnMgY2FycmllZCBvdXQgd2hlbiB0aGUgVGlja2VyIGlzIG5vdCBwYXVzZWQuXG5cdCAqICAgICAgICAgIH1cblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBjbGFzcyBUaWNrZXJcblx0ICogQHVzZXMgRXZlbnREaXNwYXRjaGVyXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRmdW5jdGlvbiBUaWNrZXIoKSB7XG5cdFx0dGhyb3cgXCJUaWNrZXIgY2Fubm90IGJlIGluc3RhbnRpYXRlZC5cIjtcblx0fVxuXG5cbi8vIGNvbnN0YW50czpcblx0LyoqXG5cdCAqIEluIHRoaXMgbW9kZSwgVGlja2VyIHVzZXMgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBBUEksIGJ1dCBhdHRlbXB0cyB0byBzeW5jaCB0aGUgdGlja3MgdG8gdGFyZ2V0IGZyYW1lcmF0ZS4gSXRcblx0ICogdXNlcyBhIHNpbXBsZSBoZXVyaXN0aWMgdGhhdCBjb21wYXJlcyB0aGUgdGltZSBvZiB0aGUgUkFGIHJldHVybiB0byB0aGUgdGFyZ2V0IHRpbWUgZm9yIHRoZSBjdXJyZW50IGZyYW1lIGFuZFxuXHQgKiBkaXNwYXRjaGVzIHRoZSB0aWNrIHdoZW4gdGhlIHRpbWUgaXMgd2l0aGluIGEgY2VydGFpbiB0aHJlc2hvbGQuXG5cdCAqXG5cdCAqIFRoaXMgbW9kZSBoYXMgYSBoaWdoZXIgdmFyaWFuY2UgZm9yIHRpbWUgYmV0d2VlbiBmcmFtZXMgdGhhbiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvVElNRU9VVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogYnV0IGRvZXMgbm90IHJlcXVpcmUgdGhhdCBjb250ZW50IGJlIHRpbWUgYmFzZWQgYXMgd2l0aCB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvUkFGOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHdoaWxlXG5cdCAqIGdhaW5pbmcgdGhlIGJlbmVmaXRzIG9mIHRoYXQgQVBJIChzY3JlZW4gc3luY2gsIGJhY2tncm91bmQgdGhyb3R0bGluZykuXG5cdCAqXG5cdCAqIFZhcmlhbmNlIGlzIHVzdWFsbHkgbG93ZXN0IGZvciBmcmFtZXJhdGVzIHRoYXQgYXJlIGEgZGl2aXNvciBvZiB0aGUgUkFGIGZyZXF1ZW5jeS4gVGhpcyBpcyB1c3VhbGx5IDYwLCBzb1xuXHQgKiBmcmFtZXJhdGVzIG9mIDEwLCAxMiwgMTUsIDIwLCBhbmQgMzAgd29yayB3ZWxsLlxuXHQgKlxuXHQgKiBGYWxscyBiYWNrIHRvIHt7I2Nyb3NzTGluayBcIlRpY2tlci9USU1FT1VUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlmIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgQVBJIGlzIG5vdFxuXHQgKiBzdXBwb3J0ZWQuXG5cdCAqIEBwcm9wZXJ0eSBSQUZfU1lOQ0hFRFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IFwic3luY2hlZFwiXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdFRpY2tlci5SQUZfU1lOQ0hFRCA9IFwic3luY2hlZFwiO1xuXG5cdC8qKlxuXHQgKiBJbiB0aGlzIG1vZGUsIFRpY2tlciBwYXNzZXMgdGhyb3VnaCB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGhlYXJ0YmVhdCwgaWdub3JpbmcgdGhlIHRhcmdldCBmcmFtZXJhdGUgY29tcGxldGVseS5cblx0ICogQmVjYXVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZnJlcXVlbmN5IGlzIG5vdCBkZXRlcm1pbmlzdGljLCBhbnkgY29udGVudCB1c2luZyB0aGlzIG1vZGUgc2hvdWxkIGJlIHRpbWUgYmFzZWQuXG5cdCAqIFlvdSBjYW4gbGV2ZXJhZ2Uge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2dldFRpbWVcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBvYmplY3QncyBcImRlbHRhXCIgcHJvcGVydGllcyB0byBtYWtlIHRoaXMgZWFzaWVyLlxuXHQgKlxuXHQgKiBGYWxscyBiYWNrIG9uIHt7I2Nyb3NzTGluayBcIlRpY2tlci9USU1FT1VUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlmIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgQVBJIGlzIG5vdFxuXHQgKiBzdXBwb3J0ZWQuXG5cdCAqIEBwcm9wZXJ0eSBSQUZcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBcInJhZlwiXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdFRpY2tlci5SQUYgPSBcInJhZlwiO1xuXG5cdC8qKlxuXHQgKiBJbiB0aGlzIG1vZGUsIFRpY2tlciB1c2VzIHRoZSBzZXRUaW1lb3V0IEFQSS4gVGhpcyBwcm92aWRlcyBwcmVkaWN0YWJsZSwgYWRhcHRpdmUgZnJhbWUgdGltaW5nLCBidXQgZG9lcyBub3Rcblx0ICogcHJvdmlkZSB0aGUgYmVuZWZpdHMgb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIChzY3JlZW4gc3luY2gsIGJhY2tncm91bmQgdGhyb3R0bGluZykuXG5cdCAqIEBwcm9wZXJ0eSBUSU1FT1VUXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgXCJ0aW1lb3V0XCJcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0VGlja2VyLlRJTUVPVVQgPSBcInRpbWVvdXRcIjtcblxuXG4vLyBzdGF0aWMgZXZlbnRzOlxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCBlYWNoIHRpY2suIFRoZSBldmVudCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gZWFjaCBsaXN0ZW5lciBldmVuIHdoZW4gdGhlIFRpY2tlciBoYXMgYmVlbiBwYXVzZWQgdXNpbmdcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3NldFBhdXNlZFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLlRpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBoYW5kbGVUaWNrKTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVUaWNrKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKFwiUGF1c2VkOlwiLCBldmVudC5wYXVzZWQsIGV2ZW50LmRlbHRhKTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBldmVudCB0aWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBwYXVzZWQgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRpY2tlciBpcyBjdXJyZW50bHkgcGF1c2VkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgVGhlIHRpbWUgZWxhcHNlZCBpbiBtcyBzaW5jZSB0aGUgbGFzdCB0aWNrLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgdG90YWwgdGltZSBpbiBtcyBzaW5jZSBUaWNrZXIgd2FzIGluaXRpYWxpemVkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcnVuVGltZSBUaGUgdG90YWwgdGltZSBpbiBtcyB0aGF0IFRpY2tlciB3YXMgbm90IHBhdXNlZCBzaW5jZSBpdCB3YXMgaW5pdGlhbGl6ZWQuIEZvciBleGFtcGxlLFxuXHQgKiBcdHlvdSBjb3VsZCBkZXRlcm1pbmUgdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgdGhlIFRpY2tlciBoYXMgYmVlbiBwYXVzZWQgc2luY2UgaW5pdGlhbGl6YXRpb24gd2l0aCBgdGltZS1ydW5UaW1lYC5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cbi8vIHB1YmxpYyBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIERlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aW1pbmdNb2RlXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uIElmIHRydWUsIHRpbWluZ01vZGUgd2lsbFxuXHQgKiB1c2Uge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1JBRl9TWU5DSEVEXCJ9fXt7L2Nyb3NzTGlua319IGJ5IGRlZmF1bHQuXG5cdCAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aW1pbmdNb2RlXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAcHJvcGVydHkgdXNlUkFGXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqKi9cblx0VGlja2VyLnVzZVJBRiA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpZXMgdGhlIHRpbWluZyBhcGkgKHNldFRpbWVvdXQgb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSBhbmQgbW9kZSB0byB1c2UuIFNlZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvVElNRU9VVFwifX17ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1JBRlwifX17ey9jcm9zc0xpbmt9fSwgYW5kXG5cdCAqIHt7I2Nyb3NzTGluayBcIlRpY2tlci9SQUZfU1lOQ0hFRFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9kZSBkZXRhaWxzLlxuXHQgKiBAcHJvcGVydHkgdGltaW5nTW9kZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IFRpY2tlci5USU1FT1VUXG5cdCAqKi9cblx0VGlja2VyLnRpbWluZ01vZGUgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpZXMgYSBtYXhpbXVtIHZhbHVlIGZvciB0aGUgZGVsdGEgcHJvcGVydHkgaW4gdGhlIHRpY2sgZXZlbnQgb2JqZWN0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGJ1aWxkaW5nIHRpbWVcblx0ICogYmFzZWQgYW5pbWF0aW9ucyBhbmQgc3lzdGVtcyB0byBwcmV2ZW50IGlzc3VlcyBjYXVzZWQgYnkgbGFyZ2UgdGltZSBnYXBzIGNhdXNlZCBieSBiYWNrZ3JvdW5kIHRhYnMsIHN5c3RlbSBzbGVlcCxcblx0ICogYWxlcnQgZGlhbG9ncywgb3Igb3RoZXIgYmxvY2tpbmcgcm91dGluZXMuIERvdWJsZSB0aGUgZXhwZWN0ZWQgZnJhbWUgZHVyYXRpb24gaXMgb2Z0ZW4gYW4gZWZmZWN0aXZlIHZhbHVlXG5cdCAqIChleC4gbWF4RGVsdGE9NTAgd2hlbiBydW5uaW5nIGF0IDQwZnBzKS5cblx0ICogXG5cdCAqIFRoaXMgZG9lcyBub3QgaW1wYWN0IGFueSBvdGhlciB2YWx1ZXMgKGV4LiB0aW1lLCBydW5UaW1lLCBldGMpLCBzbyB5b3UgbWF5IGV4cGVyaWVuY2UgaXNzdWVzIGlmIHlvdSBlbmFibGUgbWF4RGVsdGFcblx0ICogd2hlbiB1c2luZyBib3RoIGRlbHRhIGFuZCBvdGhlciB2YWx1ZXMuXG5cdCAqIFxuXHQgKiBJZiAwLCB0aGVyZSBpcyBubyBtYXhpbXVtLlxuXHQgKiBAcHJvcGVydHkgbWF4RGVsdGFcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAwXG5cdCAqL1xuXHRUaWNrZXIubWF4RGVsdGEgPSAwO1xuXHRcblx0LyoqXG5cdCAqIFdoZW4gdGhlIHRpY2tlciBpcyBwYXVzZWQsIGFsbCBsaXN0ZW5lcnMgd2lsbCBzdGlsbCByZWNlaXZlIGEgdGljayBldmVudCwgYnV0IHRoZSA8Y29kZT5wYXVzZWQ8L2NvZGU+IHByb3BlcnR5XG5cdCAqIG9mIHRoZSBldmVudCB3aWxsIGJlIGB0cnVlYC4gQWxzbywgd2hpbGUgcGF1c2VkIHRoZSBgcnVuVGltZWAgd2lsbCBub3QgaW5jcmVhc2UuIFNlZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fSxcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2dldFRpbWVcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvZ2V0RXZlbnRUaW1lXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlXG5cdCAqIGluZm8uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgaGFuZGxlVGljayk7XG5cdCAqICAgICAgY3JlYXRlanMuVGlja2VyLnBhdXNlZCA9IHRydWU7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlVGljayhldmVudCkge1xuXHQgKiAgICAgICAgICBjb25zb2xlLmxvZyhldmVudC5wYXVzZWQsXG5cdCAqICAgICAgICAgIFx0Y3JlYXRlanMuVGlja2VyLmdldFRpbWUoZmFsc2UpLFxuXHQgKiAgICAgICAgICBcdGNyZWF0ZWpzLlRpY2tlci5nZXRUaW1lKHRydWUpKTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBwYXVzZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICoqL1xuXHRUaWNrZXIucGF1c2VkID0gZmFsc2U7XG5cblxuLy8gbWl4LWluczpcblx0Ly8gRXZlbnREaXNwYXRjaGVyIG1ldGhvZHM6XG5cdFRpY2tlci5yZW1vdmVFdmVudExpc3RlbmVyID0gbnVsbDtcblx0VGlja2VyLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gbnVsbDtcblx0VGlja2VyLmRpc3BhdGNoRXZlbnQgPSBudWxsO1xuXHRUaWNrZXIuaGFzRXZlbnRMaXN0ZW5lciA9IG51bGw7XG5cdFRpY2tlci5fbGlzdGVuZXJzID0gbnVsbDtcblx0Y3JlYXRlanMuRXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUoVGlja2VyKTsgLy8gaW5qZWN0IEV2ZW50RGlzcGF0Y2hlciBtZXRob2RzLlxuXHRUaWNrZXIuX2FkZEV2ZW50TGlzdGVuZXIgPSBUaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcjtcblx0VGlja2VyLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcblx0XHQhVGlja2VyLl9pbml0ZWQmJlRpY2tlci5pbml0KCk7XG5cdFx0cmV0dXJuIFRpY2tlci5fYWRkRXZlbnRMaXN0ZW5lci5hcHBseShUaWNrZXIsIGFyZ3VtZW50cyk7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfaW5pdGVkXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX2luaXRlZCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3N0YXJ0VGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3N0YXJ0VGltZSA9IDA7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfcGF1c2VkVGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3BhdXNlZFRpbWU9MDtcblxuXHQvKipcblx0ICogVGhlIG51bWJlciBvZiB0aWNrcyB0aGF0IGhhdmUgcGFzc2VkXG5cdCAqIEBwcm9wZXJ0eSBfdGlja3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aWNrcyA9IDA7XG5cblx0LyoqXG5cdCAqIFRoZSBudW1iZXIgb2YgdGlja3MgdGhhdCBoYXZlIHBhc3NlZCB3aGlsZSBUaWNrZXIgaGFzIGJlZW4gcGF1c2VkXG5cdCAqIEBwcm9wZXJ0eSBfcGF1c2VkVGlja3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9wYXVzZWRUaWNrcyA9IDA7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfaW50ZXJ2YWxcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9pbnRlcnZhbCA9IDUwO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX2xhc3RUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fbGFzdFRpbWUgPSAwO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3RpbWVzXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aW1lcyA9IG51bGw7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfdGlja1RpbWVzXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aWNrVGltZXMgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBTdG9yZXMgdGhlIHRpbWVvdXQgb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGlkLlxuXHQgKiBAcHJvcGVydHkgX3RpbWVySWRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aW1lcklkID0gbnVsbDtcblx0XG5cdC8qKlxuXHQgKiBUcnVlIGlmIGN1cnJlbnRseSB1c2luZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGZhbHNlIGlmIHVzaW5nIHNldFRpbWVvdXQuIFRoaXMgbWF5IGJlIGRpZmZlcmVudCB0aGFuIHRpbWluZ01vZGVcblx0ICogaWYgdGhhdCBwcm9wZXJ0eSBjaGFuZ2VkIGFuZCBhIHRpY2sgaGFzbid0IGZpcmVkLlxuXHQgKiBAcHJvcGVydHkgX3JhZlxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9yYWYgPSB0cnVlO1xuXHRcblxuLy8gc3RhdGljIGdldHRlciAvIHNldHRlcnM6XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9pbnRlcnZhbDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIHNldEludGVydmFsXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGludGVydmFsXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLnNldEludGVydmFsID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcblx0XHRUaWNrZXIuX2ludGVydmFsID0gaW50ZXJ2YWw7XG5cdFx0aWYgKCFUaWNrZXIuX2luaXRlZCkgeyByZXR1cm47IH1cblx0XHRUaWNrZXIuX3NldHVwVGljaygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9mcmFtZXJhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXRJbnRlcnZhbFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuZ2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gVGlja2VyLl9pbnRlcnZhbDtcblx0fTtcblxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvZnJhbWVyYXRlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2Qgc2V0RlBTXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLnNldEZQUyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0VGlja2VyLnNldEludGVydmFsKDEwMDAvdmFsdWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9pbnRlcnZhbDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldEZQU1xuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuZ2V0RlBTID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIDEwMDAvVGlja2VyLl9pbnRlcnZhbDtcblx0fTtcblxuXHQvKipcblx0ICogSW5kaWNhdGVzIHRoZSB0YXJnZXQgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSBiZXR3ZWVuIHRpY2tzLiBEZWZhdWx0IGlzIDUwICgyMCBGUFMpLlxuXHQgKiBOb3RlIHRoYXQgYWN0dWFsIHRpbWUgYmV0d2VlbiB0aWNrcyBtYXkgYmUgbW9yZSB0aGFuIHNwZWNpZmllZCBkZXBlbmRpbmcgb24gQ1BVIGxvYWQuXG5cdCAqIFRoaXMgcHJvcGVydHkgaXMgaWdub3JlZCBpZiB0aGUgdGlja2VyIGlzIHVzaW5nIHRoZSBgUkFGYCB0aW1pbmcgbW9kZS5cblx0ICogQHByb3BlcnR5IGludGVydmFsXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICoqL1xuXHQgXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgdGhlIHRhcmdldCBmcmFtZSByYXRlIGluIGZyYW1lcyBwZXIgc2Vjb25kIChGUFMpLiBFZmZlY3RpdmVseSBqdXN0IGEgc2hvcnRjdXQgdG8gYGludGVydmFsYCwgd2hlcmVcblx0ICogYGZyYW1lcmF0ZSA9PSAxMDAwL2ludGVydmFsYC5cblx0ICogQHByb3BlcnR5IGZyYW1lcmF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqKi9cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhUaWNrZXIsIHtcblx0XHRcdGludGVydmFsOiB7IGdldDogVGlja2VyLmdldEludGVydmFsLCBzZXQ6IFRpY2tlci5zZXRJbnRlcnZhbCB9LFxuXHRcdFx0ZnJhbWVyYXRlOiB7IGdldDogVGlja2VyLmdldEZQUywgc2V0OiBUaWNrZXIuc2V0RlBTIH1cblx0XHR9KTtcblx0fSBjYXRjaCAoZSkgeyBjb25zb2xlLmxvZyhlKTsgfVxuXG5cbi8vIHB1YmxpYyBzdGF0aWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFN0YXJ0cyB0aGUgdGljay4gVGhpcyBpcyBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBmaXJzdCBsaXN0ZW5lciBpcyBhZGRlZC5cblx0ICogQG1ldGhvZCBpbml0XG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUaWNrZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChUaWNrZXIuX2luaXRlZCkgeyByZXR1cm47IH1cblx0XHRUaWNrZXIuX2luaXRlZCA9IHRydWU7XG5cdFx0VGlja2VyLl90aW1lcyA9IFtdO1xuXHRcdFRpY2tlci5fdGlja1RpbWVzID0gW107XG5cdFx0VGlja2VyLl9zdGFydFRpbWUgPSBUaWNrZXIuX2dldFRpbWUoKTtcblx0XHRUaWNrZXIuX3RpbWVzLnB1c2goVGlja2VyLl9sYXN0VGltZSA9IDApO1xuXHRcdFRpY2tlci5pbnRlcnZhbCA9IFRpY2tlci5faW50ZXJ2YWw7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU3RvcHMgdGhlIFRpY2tlciBhbmQgcmVtb3ZlcyBhbGwgbGlzdGVuZXJzLiBVc2UgaW5pdCgpIHRvIHJlc3RhcnQgdGhlIFRpY2tlci5cblx0ICogQG1ldGhvZCByZXNldFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VGlja2VyLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKFRpY2tlci5fcmFmKSB7XG5cdFx0XHR2YXIgZiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5vQ2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cdFx0XHRmJiZmKFRpY2tlci5fdGltZXJJZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNsZWFyVGltZW91dChUaWNrZXIuX3RpbWVySWQpO1xuXHRcdH1cblx0XHRUaWNrZXIucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoXCJ0aWNrXCIpO1xuXHRcdFRpY2tlci5fdGltZXJJZCA9IFRpY2tlci5fdGltZXMgPSBUaWNrZXIuX3RpY2tUaW1lcyA9IG51bGw7XG5cdFx0VGlja2VyLl9zdGFydFRpbWUgPSBUaWNrZXIuX2xhc3RUaW1lID0gVGlja2VyLl90aWNrcyA9IDA7XG5cdFx0VGlja2VyLl9pbml0ZWQgPSBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYXZlcmFnZSB0aW1lIHNwZW50IHdpdGhpbiBhIHRpY2suIFRoaXMgY2FuIHZhcnkgc2lnbmlmaWNhbnRseSBmcm9tIHRoZSB2YWx1ZSBwcm92aWRlZCBieSBnZXRNZWFzdXJlZEZQU1xuXHQgKiBiZWNhdXNlIGl0IG9ubHkgbWVhc3VyZXMgdGhlIHRpbWUgc3BlbnQgd2l0aGluIHRoZSB0aWNrIGV4ZWN1dGlvbiBzdGFjay4gXG5cdCAqIFxuXHQgKiBFeGFtcGxlIDE6IFdpdGggYSB0YXJnZXQgRlBTIG9mIDIwLCBnZXRNZWFzdXJlZEZQUygpIHJldHVybnMgMjBmcHMsIHdoaWNoIGluZGljYXRlcyBhbiBhdmVyYWdlIG9mIDUwbXMgYmV0d2VlbiBcblx0ICogdGhlIGVuZCBvZiBvbmUgdGljayBhbmQgdGhlIGVuZCBvZiB0aGUgbmV4dC4gSG93ZXZlciwgZ2V0TWVhc3VyZWRUaWNrVGltZSgpIHJldHVybnMgMTVtcy4gVGhpcyBpbmRpY2F0ZXMgdGhhdCBcblx0ICogdGhlcmUgbWF5IGJlIHVwIHRvIDM1bXMgb2YgXCJpZGxlXCIgdGltZSBiZXR3ZWVuIHRoZSBlbmQgb2Ygb25lIHRpY2sgYW5kIHRoZSBzdGFydCBvZiB0aGUgbmV4dC5cblx0ICpcblx0ICogRXhhbXBsZSAyOiBXaXRoIGEgdGFyZ2V0IEZQUyBvZiAzMCwgZ2V0RlBTKCkgcmV0dXJucyAxMGZwcywgd2hpY2ggaW5kaWNhdGVzIGFuIGF2ZXJhZ2Ugb2YgMTAwbXMgYmV0d2VlbiB0aGUgZW5kIG9mXG5cdCAqIG9uZSB0aWNrIGFuZCB0aGUgZW5kIG9mIHRoZSBuZXh0LiBIb3dldmVyLCBnZXRNZWFzdXJlZFRpY2tUaW1lKCkgcmV0dXJucyAyMG1zLiBUaGlzIHdvdWxkIGluZGljYXRlIHRoYXQgc29tZXRoaW5nXG5cdCAqIG90aGVyIHRoYW4gdGhlIHRpY2sgaXMgdXNpbmcgfjgwbXMgKGFub3RoZXIgc2NyaXB0LCBET00gcmVuZGVyaW5nLCBldGMpLlxuXHQgKiBAbWV0aG9kIGdldE1lYXN1cmVkVGlja1RpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RpY2tzXSBUaGUgbnVtYmVyIG9mIHByZXZpb3VzIHRpY2tzIG92ZXIgd2hpY2ggdG8gbWVhc3VyZSB0aGUgYXZlcmFnZSB0aW1lIHNwZW50IGluIGEgdGljay5cblx0ICogRGVmYXVsdHMgdG8gdGhlIG51bWJlciBvZiB0aWNrcyBwZXIgc2Vjb25kLiBUbyBnZXQgb25seSB0aGUgbGFzdCB0aWNrJ3MgdGltZSwgcGFzcyBpbiAxLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBhdmVyYWdlIHRpbWUgc3BlbnQgaW4gYSB0aWNrIGluIG1pbGxpc2Vjb25kcy5cblx0ICoqL1xuXHRUaWNrZXIuZ2V0TWVhc3VyZWRUaWNrVGltZSA9IGZ1bmN0aW9uKHRpY2tzKSB7XG5cdFx0dmFyIHR0bD0wLCB0aW1lcz1UaWNrZXIuX3RpY2tUaW1lcztcblx0XHRpZiAoIXRpbWVzIHx8IHRpbWVzLmxlbmd0aCA8IDEpIHsgcmV0dXJuIC0xOyB9XG5cblx0XHQvLyBieSBkZWZhdWx0LCBjYWxjdWxhdGUgYXZlcmFnZSBmb3IgdGhlIHBhc3QgfjEgc2Vjb25kOlxuXHRcdHRpY2tzID0gTWF0aC5taW4odGltZXMubGVuZ3RoLCB0aWNrc3x8KFRpY2tlci5nZXRGUFMoKXwwKSk7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPHRpY2tzOyBpKyspIHsgdHRsICs9IHRpbWVzW2ldOyB9XG5cdFx0cmV0dXJuIHR0bC90aWNrcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYWN0dWFsIGZyYW1lcyAvIHRpY2tzIHBlciBzZWNvbmQuXG5cdCAqIEBtZXRob2QgZ2V0TWVhc3VyZWRGUFNcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RpY2tzXSBUaGUgbnVtYmVyIG9mIHByZXZpb3VzIHRpY2tzIG92ZXIgd2hpY2ggdG8gbWVhc3VyZSB0aGUgYWN0dWFsIGZyYW1lcyAvIHRpY2tzIHBlciBzZWNvbmQuXG5cdCAqIERlZmF1bHRzIHRvIHRoZSBudW1iZXIgb2YgdGlja3MgcGVyIHNlY29uZC5cblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgYWN0dWFsIGZyYW1lcyAvIHRpY2tzIHBlciBzZWNvbmQuIERlcGVuZGluZyBvbiBwZXJmb3JtYW5jZSwgdGhpcyBtYXkgZGlmZmVyXG5cdCAqIGZyb20gdGhlIHRhcmdldCBmcmFtZXMgcGVyIHNlY29uZC5cblx0ICoqL1xuXHRUaWNrZXIuZ2V0TWVhc3VyZWRGUFMgPSBmdW5jdGlvbih0aWNrcykge1xuXHRcdHZhciB0aW1lcyA9IFRpY2tlci5fdGltZXM7XG5cdFx0aWYgKCF0aW1lcyB8fCB0aW1lcy5sZW5ndGggPCAyKSB7IHJldHVybiAtMTsgfVxuXG5cdFx0Ly8gYnkgZGVmYXVsdCwgY2FsY3VsYXRlIGZwcyBmb3IgdGhlIHBhc3QgfjEgc2Vjb25kOlxuXHRcdHRpY2tzID0gTWF0aC5taW4odGltZXMubGVuZ3RoLTEsIHRpY2tzfHwoVGlja2VyLmdldEZQUygpfDApKTtcblx0XHRyZXR1cm4gMTAwMC8oKHRpbWVzWzBdLXRpbWVzW3RpY2tzXSkvdGlja3MpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9wYXVzZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBzZXRQYXVzZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLnNldFBhdXNlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0Ly8gVE9ETzogZGVwcmVjYXRlZC5cblx0XHRUaWNrZXIucGF1c2VkID0gdmFsdWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3BhdXNlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldFBhdXNlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLmdldFBhdXNlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFRPRE86IGRlcHJlY2F0ZWQuXG5cdFx0cmV0dXJuIFRpY2tlci5wYXVzZWQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2UgVGlja2VyIHdhcyBpbml0aWFsaXplZCB2aWEge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2luaXRcIn19LlxuXHQgKiBSZXR1cm5zIC0xIGlmIFRpY2tlciBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQuIEZvciBleGFtcGxlLCB5b3UgY291bGQgdXNlXG5cdCAqIHRoaXMgaW4gYSB0aW1lIHN5bmNocm9uaXplZCBhbmltYXRpb24gdG8gZGV0ZXJtaW5lIHRoZSBleGFjdCBhbW91bnQgb2YgdGltZSB0aGF0IGhhcyBlbGFwc2VkLlxuXHQgKiBAbWV0aG9kIGdldFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtydW5UaW1lPWZhbHNlXSBJZiB0cnVlIG9ubHkgdGltZSBlbGFwc2VkIHdoaWxlIFRpY2tlciB3YXMgbm90IHBhdXNlZCB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBJZiBmYWxzZSwgdGhlIHZhbHVlIHJldHVybmVkIHdpbGwgYmUgdG90YWwgdGltZSBlbGFwc2VkIHNpbmNlIHRoZSBmaXJzdCB0aWNrIGV2ZW50IGxpc3RlbmVyIHdhcyBhZGRlZC5cblx0ICogQHJldHVybiB7TnVtYmVyfSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlIFRpY2tlciB3YXMgaW5pdGlhbGl6ZWQgb3IgLTEuXG5cdCAqKi9cblx0VGlja2VyLmdldFRpbWUgPSBmdW5jdGlvbihydW5UaW1lKSB7XG5cdFx0cmV0dXJuIFRpY2tlci5fc3RhcnRUaW1lID8gVGlja2VyLl9nZXRUaW1lKCkgLSAocnVuVGltZSA/IFRpY2tlci5fcGF1c2VkVGltZSA6IDApIDogLTE7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNpbWlsYXIgdG8gZ2V0VGltZSgpLCBidXQgcmV0dXJucyB0aGUgdGltZSBvbiB0aGUgbW9zdCByZWNlbnQgdGljayBldmVudCBvYmplY3QuXG5cdCAqIEBtZXRob2QgZ2V0RXZlbnRUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHJ1blRpbWUge0Jvb2xlYW59IFtydW5UaW1lPWZhbHNlXSBJZiB0cnVlLCB0aGUgcnVuVGltZSBwcm9wZXJ0eSB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2YgdGltZS5cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHRpbWUgb3IgcnVuVGltZSBwcm9wZXJ0eSBmcm9tIHRoZSBtb3N0IHJlY2VudCB0aWNrIGV2ZW50IG9yIC0xLlxuXHQgKi9cblx0VGlja2VyLmdldEV2ZW50VGltZSA9IGZ1bmN0aW9uKHJ1blRpbWUpIHtcblx0XHRyZXR1cm4gVGlja2VyLl9zdGFydFRpbWUgPyAoVGlja2VyLl9sYXN0VGltZSB8fCBUaWNrZXIuX3N0YXJ0VGltZSkgLSAocnVuVGltZSA/IFRpY2tlci5fcGF1c2VkVGltZSA6IDApIDogLTE7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRpY2tzIHRoYXQgaGF2ZSBiZWVuIGJyb2FkY2FzdCBieSBUaWNrZXIuXG5cdCAqIEBtZXRob2QgZ2V0VGlja3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHBhdXNlYWJsZSBJbmRpY2F0ZXMgd2hldGhlciB0byBpbmNsdWRlIHRpY2tzIHRoYXQgd291bGQgaGF2ZSBiZWVuIGJyb2FkY2FzdFxuXHQgKiB3aGlsZSBUaWNrZXIgd2FzIHBhdXNlZC4gSWYgdHJ1ZSBvbmx5IHRpY2sgZXZlbnRzIGJyb2FkY2FzdCB3aGlsZSBUaWNrZXIgaXMgbm90IHBhdXNlZCB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBJZiBmYWxzZSwgdGljayBldmVudHMgdGhhdCB3b3VsZCBoYXZlIGJlZW4gYnJvYWRjYXN0IHdoaWxlIFRpY2tlciB3YXMgcGF1c2VkIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHJldHVyblxuXHQgKiB2YWx1ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgZmFsc2UuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gb2YgdGlja3MgdGhhdCBoYXZlIGJlZW4gYnJvYWRjYXN0LlxuXHQgKiovXG5cdFRpY2tlci5nZXRUaWNrcyA9IGZ1bmN0aW9uKHBhdXNlYWJsZSkge1xuXHRcdHJldHVybiAgVGlja2VyLl90aWNrcyAtIChwYXVzZWFibGUgPyBUaWNrZXIuX3BhdXNlZFRpY2tzIDogMCk7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBzdGF0aWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVN5bmNoXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5faGFuZGxlU3luY2ggPSBmdW5jdGlvbigpIHtcblx0XHRUaWNrZXIuX3RpbWVySWQgPSBudWxsO1xuXHRcdFRpY2tlci5fc2V0dXBUaWNrKCk7XG5cblx0XHQvLyBydW4gaWYgZW5vdWdoIHRpbWUgaGFzIGVsYXBzZWQsIHdpdGggYSBsaXR0bGUgYml0IG9mIGZsZXhpYmlsaXR5IHRvIGJlIGVhcmx5OlxuXHRcdGlmIChUaWNrZXIuX2dldFRpbWUoKSAtIFRpY2tlci5fbGFzdFRpbWUgPj0gKFRpY2tlci5faW50ZXJ2YWwtMSkqMC45Nykge1xuXHRcdFx0VGlja2VyLl90aWNrKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVSQUZcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9oYW5kbGVSQUYgPSBmdW5jdGlvbigpIHtcblx0XHRUaWNrZXIuX3RpbWVySWQgPSBudWxsO1xuXHRcdFRpY2tlci5fc2V0dXBUaWNrKCk7XG5cdFx0VGlja2VyLl90aWNrKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVRpbWVvdXRcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9oYW5kbGVUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0VGlja2VyLl90aW1lcklkID0gbnVsbDtcblx0XHRUaWNrZXIuX3NldHVwVGljaygpO1xuXHRcdFRpY2tlci5fdGljaygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9zZXR1cFRpY2tcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9zZXR1cFRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoVGlja2VyLl90aW1lcklkICE9IG51bGwpIHsgcmV0dXJuOyB9IC8vIGF2b2lkIGR1cGxpY2F0ZXNcblxuXHRcdHZhciBtb2RlID0gVGlja2VyLnRpbWluZ01vZGV8fChUaWNrZXIudXNlUkFGJiZUaWNrZXIuUkFGX1NZTkNIRUQpO1xuXHRcdGlmIChtb2RlID09IFRpY2tlci5SQUZfU1lOQ0hFRCB8fCBtb2RlID09IFRpY2tlci5SQUYpIHtcblx0XHRcdHZhciBmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXHRcdFx0aWYgKGYpIHtcblx0XHRcdFx0VGlja2VyLl90aW1lcklkID0gZihtb2RlID09IFRpY2tlci5SQUYgPyBUaWNrZXIuX2hhbmRsZVJBRiA6IFRpY2tlci5faGFuZGxlU3luY2gpO1xuXHRcdFx0XHRUaWNrZXIuX3JhZiA9IHRydWU7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFx0VGlja2VyLl9yYWYgPSBmYWxzZTtcblx0XHRUaWNrZXIuX3RpbWVySWQgPSBzZXRUaW1lb3V0KFRpY2tlci5faGFuZGxlVGltZW91dCwgVGlja2VyLl9pbnRlcnZhbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3RpY2tcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhdXNlZCA9IFRpY2tlci5wYXVzZWQ7XG5cdFx0dmFyIHRpbWUgPSBUaWNrZXIuX2dldFRpbWUoKTtcblx0XHR2YXIgZWxhcHNlZFRpbWUgPSB0aW1lLVRpY2tlci5fbGFzdFRpbWU7XG5cdFx0VGlja2VyLl9sYXN0VGltZSA9IHRpbWU7XG5cdFx0VGlja2VyLl90aWNrcysrO1xuXHRcdFxuXHRcdGlmIChwYXVzZWQpIHtcblx0XHRcdFRpY2tlci5fcGF1c2VkVGlja3MrKztcblx0XHRcdFRpY2tlci5fcGF1c2VkVGltZSArPSBlbGFwc2VkVGltZTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKFRpY2tlci5oYXNFdmVudExpc3RlbmVyKFwidGlja1wiKSkge1xuXHRcdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwidGlja1wiKTtcblx0XHRcdHZhciBtYXhEZWx0YSA9IFRpY2tlci5tYXhEZWx0YTtcblx0XHRcdGV2ZW50LmRlbHRhID0gKG1heERlbHRhICYmIGVsYXBzZWRUaW1lID4gbWF4RGVsdGEpID8gbWF4RGVsdGEgOiBlbGFwc2VkVGltZTtcblx0XHRcdGV2ZW50LnBhdXNlZCA9IHBhdXNlZDtcblx0XHRcdGV2ZW50LnRpbWUgPSB0aW1lO1xuXHRcdFx0ZXZlbnQucnVuVGltZSA9IHRpbWUtVGlja2VyLl9wYXVzZWRUaW1lO1xuXHRcdFx0VGlja2VyLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdH1cblx0XHRcblx0XHRUaWNrZXIuX3RpY2tUaW1lcy51bnNoaWZ0KFRpY2tlci5fZ2V0VGltZSgpLXRpbWUpO1xuXHRcdHdoaWxlIChUaWNrZXIuX3RpY2tUaW1lcy5sZW5ndGggPiAxMDApIHsgVGlja2VyLl90aWNrVGltZXMucG9wKCk7IH1cblxuXHRcdFRpY2tlci5fdGltZXMudW5zaGlmdCh0aW1lKTtcblx0XHR3aGlsZSAoVGlja2VyLl90aW1lcy5sZW5ndGggPiAxMDApIHsgVGlja2VyLl90aW1lcy5wb3AoKTsgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHZhciBub3cgPSB3aW5kb3cucGVyZm9ybWFuY2UgJiYgKHBlcmZvcm1hbmNlLm5vdyB8fCBwZXJmb3JtYW5jZS5tb3pOb3cgfHwgcGVyZm9ybWFuY2UubXNOb3cgfHwgcGVyZm9ybWFuY2Uub05vdyB8fCBwZXJmb3JtYW5jZS53ZWJraXROb3cpO1xuXHRUaWNrZXIuX2dldFRpbWUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKChub3cmJm5vdy5jYWxsKHBlcmZvcm1hbmNlKSl8fChuZXcgRGF0ZSgpLmdldFRpbWUoKSkpIC0gVGlja2VyLl9zdGFydFRpbWU7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5UaWNrZXIgPSBUaWNrZXI7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVHdlZW4uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbi8vIFRPRE86IHBvc3NpYmx5IGFkZCBhIEVORCBhY3Rpb25zTW9kZSAob25seSBydW5zIGFjdGlvbnMgdGhhdCA9PSBwb3NpdGlvbik/XG4vLyBUT0RPOiBldmFsdWF0ZSBhIHdheSB0byBkZWNvdXBsZSBwYXVzZWQgZnJvbSB0aWNrIHJlZ2lzdHJhdGlvbi5cblxuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgVHdlZW4gaW5zdGFuY2UgdHdlZW5zIHByb3BlcnRpZXMgZm9yIGEgc2luZ2xlIHRhcmdldC4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmUgY2hhaW5lZCBmb3IgZWFzeSBjb25zdHJ1Y3Rpb24gYW5kIHNlcXVlbmNpbmc6XG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB0YXJnZXQuYWxwaGEgPSAxO1xuXHQgKlx0ICAgIGNyZWF0ZWpzLlR3ZWVuLmdldCh0YXJnZXQpXG5cdCAqXHQgICAgICAgICAud2FpdCg1MDApXG5cdCAqXHQgICAgICAgICAudG8oe2FscGhhOjAsIHZpc2libGU6ZmFsc2V9LCAxMDAwKVxuXHQgKlx0ICAgICAgICAgLmNhbGwoaGFuZGxlQ29tcGxldGUpO1xuXHQgKlx0ICAgIGZ1bmN0aW9uIGhhbmRsZUNvbXBsZXRlKCkge1xuXHQgKlx0ICAgIFx0Ly9Ud2VlbiBjb21wbGV0ZVxuXHQgKlx0ICAgIH1cblx0ICpcblx0ICogTXVsdGlwbGUgdHdlZW5zIGNhbiBwb2ludCB0byB0aGUgc2FtZSBpbnN0YW5jZSwgaG93ZXZlciBpZiB0aGV5IGFmZmVjdCB0aGUgc2FtZSBwcm9wZXJ0aWVzIHRoZXJlIGNvdWxkIGJlIHVuZXhwZWN0ZWRcblx0ICogYmVoYXZpb3VyLiBUbyBzdG9wIGFsbCB0d2VlbnMgb24gYW4gb2JqZWN0LCB1c2Uge3sjY3Jvc3NMaW5rIFwiVHdlZW4vcmVtb3ZlVHdlZW5zXCJ9fXt7L2Nyb3NzTGlua319IG9yIHBhc3MgYG92ZXJyaWRlOnRydWVgXG5cdCAqIGluIHRoZSBwcm9wcyBhcmd1bWVudC5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0LCB7b3ZlcnJpZGU6dHJ1ZX0pLnRvKHt4OjEwMH0pO1xuXHQgKlxuXHQgKiBTdWJzY3JpYmUgdG8gdGhlIHt7I2Nyb3NzTGluayBcIlR3ZWVuL2NoYW5nZTpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCB0byBnZXQgbm90aWZpZWQgd2hlbiBhIHByb3BlcnR5IG9mIHRoZVxuXHQgKiB0YXJnZXQgaXMgY2hhbmdlZC5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0LCB7b3ZlcnJpZGU6dHJ1ZX0pLnRvKHt4OjEwMH0pLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlQ2hhbmdlKTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UoZXZlbnQpIHtcblx0ICogICAgICAgICAgLy8gVGhlIHR3ZWVuIGNoYW5nZWQuXG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBTZWUgdGhlIFR3ZWVuIHt7I2Nyb3NzTGluayBcIlR3ZWVuL2dldFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgZm9yIGFkZGl0aW9uYWwgcGFyYW0gZG9jdW1lbnRhdGlvbi5cblx0ICogQGNsYXNzIFR3ZWVuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdGhhdCB3aWxsIGhhdmUgaXRzIHByb3BlcnRpZXMgdHdlZW5lZC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gVGhlIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyB0byBhcHBseSB0byB0aGlzIHR3ZWVuIGluc3RhbmNlIChleC4gYHtsb29wOnRydWUsIHBhdXNlZDp0cnVlfWAuXG5cdCAqIEFsbCBwcm9wZXJ0aWVzIGRlZmF1bHQgdG8gZmFsc2UuIFN1cHBvcnRlZCBwcm9wcyBhcmU6PFVMPlxuXHQgKiAgICA8TEk+IGxvb3A6IHNldHMgdGhlIGxvb3AgcHJvcGVydHkgb24gdGhpcyB0d2Vlbi48L0xJPlxuXHQgKiAgICA8TEk+IHVzZVRpY2tzOiB1c2VzIHRpY2tzIGZvciBhbGwgZHVyYXRpb25zIGluc3RlYWQgb2YgbWlsbGlzZWNvbmRzLjwvTEk+XG5cdCAqICAgIDxMST4gaWdub3JlR2xvYmFsUGF1c2U6IHNldHMgdGhlIHt7I2Nyb3NzTGluayBcIlR3ZWVuL2lnbm9yZUdsb2JhbFBhdXNlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IG9uIHRoaXMgdHdlZW4uPC9MST5cblx0ICogICAgPExJPiBvdmVycmlkZTogaWYgdHJ1ZSwgYFR3ZWVuLnJlbW92ZVR3ZWVucyh0YXJnZXQpYCB3aWxsIGJlIGNhbGxlZCB0byByZW1vdmUgYW55IG90aGVyIHR3ZWVucyB3aXRoIHRoZSBzYW1lIHRhcmdldC5cblx0ICogICAgPExJPiBwYXVzZWQ6IGluZGljYXRlcyB3aGV0aGVyIHRvIHN0YXJ0IHRoZSB0d2VlbiBwYXVzZWQuPC9MST5cblx0ICogICAgPExJPiBwb3NpdGlvbjogaW5kaWNhdGVzIHRoZSBpbml0aWFsIHBvc2l0aW9uIGZvciB0aGlzIHR3ZWVuLjwvTEk+XG5cdCAqICAgIDxMST4gb25DaGFuZ2U6IHNwZWNpZmllcyBhIGxpc3RlbmVyIGZvciB0aGUgXCJjaGFuZ2VcIiBldmVudC48L0xJPlxuXHQgKiA8L1VMPlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3BsdWdpbkRhdGFdIEFuIG9iamVjdCBjb250YWluaW5nIGRhdGEgZm9yIHVzZSBieSBpbnN0YWxsZWQgcGx1Z2lucy4gU2VlIGluZGl2aWR1YWxcblx0ICogcGx1Z2lucycgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy5cblx0ICogQGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gVHdlZW4odGFyZ2V0LCBwcm9wcywgcGx1Z2luRGF0YSkge1xuXG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIENhdXNlcyB0aGlzIHR3ZWVuIHRvIGNvbnRpbnVlIHBsYXlpbmcgd2hlbiBhIGdsb2JhbCBwYXVzZSBpcyBhY3RpdmUuIEZvciBleGFtcGxlLCBpZiBUd2VlbkpTIGlzIHVzaW5nIHt7I2Nyb3NzTGluayBcIlRpY2tlclwifX17ey9jcm9zc0xpbmt9fSxcblx0XHQgKiB0aGVuIHNldHRpbmcgdGhpcyB0byB0cnVlICh0aGUgZGVmYXVsdCkgd2lsbCBjYXVzZSB0aGlzIHR3ZWVuIHRvIGJlIHBhdXNlZCB3aGVuIDxjb2RlPlRpY2tlci5zZXRQYXVzZWQodHJ1ZSk8L2NvZGU+XG5cdFx0ICogaXMgY2FsbGVkLiBTZWUgdGhlIFR3ZWVuIHt7I2Nyb3NzTGluayBcIlR3ZWVuL3RpY2tcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGZvciBtb3JlIGluZm8uIENhbiBiZSBzZXQgdmlhIHRoZSBwcm9wc1xuXHRcdCAqIHBhcmFtZXRlci5cblx0XHQgKiBAcHJvcGVydHkgaWdub3JlR2xvYmFsUGF1c2Vcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmlnbm9yZUdsb2JhbFBhdXNlID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIHRydWUsIHRoZSB0d2VlbiB3aWxsIGxvb3Agd2hlbiBpdCByZWFjaGVzIHRoZSBlbmQuIENhbiBiZSBzZXQgdmlhIHRoZSBwcm9wcyBwYXJhbS5cblx0XHQgKiBAcHJvcGVydHkgbG9vcFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5sb29wID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNwZWNpZmllcyB0aGUgdG90YWwgZHVyYXRpb24gb2YgdGhpcyB0d2VlbiBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIHVzZVRpY2tzIGlzIHRydWUpLlxuXHRcdCAqIFRoaXMgdmFsdWUgaXMgYXV0b21hdGljYWxseSB1cGRhdGVkIGFzIHlvdSBtb2RpZnkgdGhlIHR3ZWVuLiBDaGFuZ2luZyBpdCBkaXJlY3RseSBjb3VsZCByZXN1bHQgaW4gdW5leHBlY3RlZFxuXHRcdCAqIGJlaGF2aW91ci5cblx0XHQgKiBAcHJvcGVydHkgZHVyYXRpb25cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLmR1cmF0aW9uID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQWxsb3dzIHlvdSB0byBzcGVjaWZ5IGRhdGEgdGhhdCB3aWxsIGJlIHVzZWQgYnkgaW5zdGFsbGVkIHBsdWdpbnMuIEVhY2ggcGx1Z2luIHVzZXMgdGhpcyBkaWZmZXJlbnRseSwgYnV0IGluIGdlbmVyYWxcblx0XHQgKiB5b3Ugc3BlY2lmeSBkYXRhIGJ5IHNldHRpbmcgaXQgdG8gYSBwcm9wZXJ0eSBvZiBwbHVnaW5EYXRhIHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgcGx1Z2luIGNsYXNzLlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICpcdG15VHdlZW4ucGx1Z2luRGF0YS5QbHVnaW5DbGFzc05hbWUgPSBkYXRhO1xuXHRcdCAqIDxici8+XG5cdFx0ICogQWxzbywgbW9zdCBwbHVnaW5zIHN1cHBvcnQgYSBwcm9wZXJ0eSB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGVtLiBUaGlzIGlzIHR5cGljYWxseSB0aGUgcGx1Z2luIGNsYXNzIG5hbWUgZm9sbG93ZWQgYnkgXCJfZW5hYmxlZFwiLjxici8+XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKlx0bXlUd2Vlbi5wbHVnaW5EYXRhLlBsdWdpbkNsYXNzTmFtZV9lbmFibGVkID0gZmFsc2U7PGJyLz5cblx0XHQgKiA8YnIvPlxuXHRcdCAqIFNvbWUgcGx1Z2lucyBhbHNvIHN0b3JlIGluc3RhbmNlIGRhdGEgaW4gdGhpcyBvYmplY3QsIHVzdWFsbHkgaW4gYSBwcm9wZXJ0eSBuYW1lZCBfUGx1Z2luQ2xhc3NOYW1lLlxuXHRcdCAqIFNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgaW5kaXZpZHVhbCBwbHVnaW5zIGZvciBtb3JlIGRldGFpbHMuXG5cdFx0ICogQHByb3BlcnR5IHBsdWdpbkRhdGFcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMucGx1Z2luRGF0YSA9IHBsdWdpbkRhdGEgfHwge307XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0YXJnZXQgb2YgdGhpcyB0d2Vlbi4gVGhpcyBpcyB0aGUgb2JqZWN0IG9uIHdoaWNoIHRoZSB0d2VlbmVkIHByb3BlcnRpZXMgd2lsbCBiZSBjaGFuZ2VkLiBDaGFuZ2luZ1xuXHRcdCAqIHRoaXMgcHJvcGVydHkgYWZ0ZXIgdGhlIHR3ZWVuIGlzIGNyZWF0ZWQgd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSB0YXJnZXRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY3VycmVudCBub3JtYWxpemVkIHBvc2l0aW9uIG9mIHRoZSB0d2Vlbi4gVGhpcyB3aWxsIGFsd2F5cyBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgZHVyYXRpb24uXG5cdFx0ICogQ2hhbmdpbmcgdGhpcyBwcm9wZXJ0eSBkaXJlY3RseSB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBwb3NpdGlvblxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5wb3NpdGlvbiA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGUgdHdlZW4ncyBjdXJyZW50IHBvc2l0aW9uIGlzIHdpdGhpbiBhIHBhc3NpdmUgd2FpdC5cblx0XHQgKiBAcHJvcGVydHkgcGFzc2l2ZVxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMucGFzc2l2ZSA9IGZhbHNlO1xuXHRcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9wYXVzZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9jdXJRdWV1ZVByb3BzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fY3VyUXVldWVQcm9wcyA9IHt9O1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2luaXRRdWV1ZVByb3BzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5faW5pdFF1ZXVlUHJvcHMgPSB7fTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9zdGVwc1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fc3RlcHMgPSBbXTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9hY3Rpb25zXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9hY3Rpb25zID0gW107XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJhdyBwb3NpdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgX3ByZXZQb3NpdGlvblxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9wcmV2UG9zaXRpb24gPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgcG9zaXRpb24gd2l0aGluIHRoZSBjdXJyZW50IHN0ZXAuXG5cdFx0ICogQHByb3BlcnR5IF9zdGVwUG9zaXRpb25cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fc3RlcFBvc2l0aW9uID0gMDsgLy8gdGhpcyBpcyBuZWVkZWQgYnkgTW92aWVDbGlwLlxuXHRcblx0XHQvKipcblx0XHQgKiBOb3JtYWxpemVkIHBvc2l0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcHJldlBvc1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgLTFcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fcHJldlBvcyA9IC0xO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3RhcmdldFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3RhcmdldCA9IHRhcmdldDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF91c2VUaWNrc1xuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3VzZVRpY2tzID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfaW5pdGVkXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5faW5pdGVkID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHR3ZWVuIGlzIGN1cnJlbnRseSByZWdpc3RlcmVkIHdpdGggVHdlZW4uXG5cdFx0ICogQHByb3BlcnR5IF9yZWdpc3RlcmVkXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fcmVnaXN0ZXJlZCA9IGZhbHNlO1xuXG5cblx0XHRpZiAocHJvcHMpIHtcblx0XHRcdHRoaXMuX3VzZVRpY2tzID0gcHJvcHMudXNlVGlja3M7XG5cdFx0XHR0aGlzLmlnbm9yZUdsb2JhbFBhdXNlID0gcHJvcHMuaWdub3JlR2xvYmFsUGF1c2U7XG5cdFx0XHR0aGlzLmxvb3AgPSBwcm9wcy5sb29wO1xuXHRcdFx0cHJvcHMub25DaGFuZ2UgJiYgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHByb3BzLm9uQ2hhbmdlKTtcblx0XHRcdGlmIChwcm9wcy5vdmVycmlkZSkgeyBUd2Vlbi5yZW1vdmVUd2VlbnModGFyZ2V0KTsgfVxuXHRcdH1cblx0XHRpZiAocHJvcHMmJnByb3BzLnBhdXNlZCkgeyB0aGlzLl9wYXVzZWQ9dHJ1ZTsgfVxuXHRcdGVsc2UgeyBjcmVhdGVqcy5Ud2Vlbi5fcmVnaXN0ZXIodGhpcyx0cnVlKTsgfVxuXHRcdGlmIChwcm9wcyYmcHJvcHMucG9zaXRpb24hPW51bGwpIHsgdGhpcy5zZXRQb3NpdGlvbihwcm9wcy5wb3NpdGlvbiwgVHdlZW4uTk9ORSk7IH1cblxuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFR3ZWVuLCBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXHRcblxuLy8gc3RhdGljIHByb3BlcnRpZXNcblx0LyoqXG5cdCAqIENvbnN0YW50IGRlZmluaW5nIHRoZSBub25lIGFjdGlvbnNNb2RlIGZvciB1c2Ugd2l0aCBzZXRQb3NpdGlvbi5cblx0ICogQHByb3BlcnR5IE5PTkVcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqIEBkZWZhdWx0IDBcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VHdlZW4uTk9ORSA9IDA7XG5cblx0LyoqXG5cdCAqIENvbnN0YW50IGRlZmluaW5nIHRoZSBsb29wIGFjdGlvbnNNb2RlIGZvciB1c2Ugd2l0aCBzZXRQb3NpdGlvbi5cblx0ICogQHByb3BlcnR5IExPT1Bcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqIEBkZWZhdWx0IDFcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VHdlZW4uTE9PUCA9IDE7XG5cblx0LyoqXG5cdCAqIENvbnN0YW50IGRlZmluaW5nIHRoZSByZXZlcnNlIGFjdGlvbnNNb2RlIGZvciB1c2Ugd2l0aCBzZXRQb3NpdGlvbi5cblx0ICogQHByb3BlcnR5IFJFVkVSU0Vcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqIEBkZWZhdWx0IDJcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VHdlZW4uUkVWRVJTRSA9IDI7XG5cblx0LyoqXG5cdCAqIENvbnN0YW50IHJldHVybmVkIGJ5IHBsdWdpbnMgdG8gdGVsbCB0aGUgdHdlZW4gbm90IHRvIHVzZSBkZWZhdWx0IGFzc2lnbm1lbnQuXG5cdCAqIEBwcm9wZXJ0eSBJR05PUkVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFR3ZWVuLklHTk9SRSA9IHt9O1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX2xpc3RlbmVyc1xuXHQgKiBAdHlwZSBBcnJheVtUd2Vlbl1cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRUd2Vlbi5fdHdlZW5zID0gW107XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfcGx1Z2luc1xuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRUd2Vlbi5fcGx1Z2lucyA9IHt9O1xuXG5cbi8vIHN0YXRpYyBtZXRob2RzXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBuZXcgdHdlZW4gaW5zdGFuY2UuIFRoaXMgaXMgZnVuY3Rpb25hbGx5IGlkZW50aWNhbCB0byB1c2luZyBcIm5ldyBUd2VlbiguLi4pXCIsIGJ1dCBsb29rcyBjbGVhbmVyXG5cdCAqIHdpdGggdGhlIGNoYWluZWQgc3ludGF4IG9mIFR3ZWVuSlMuXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICpcdFx0dmFyIHR3ZWVuID0gY3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldCk7XG5cdCAqXG5cdCAqIEBtZXRob2QgZ2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdGhhdCB3aWxsIGhhdmUgaXRzIHByb3BlcnRpZXMgdHdlZW5lZC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gVGhlIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyB0byBhcHBseSB0byB0aGlzIHR3ZWVuIGluc3RhbmNlIChleC4gYHtsb29wOnRydWUsIHBhdXNlZDp0cnVlfWApLlxuXHQgKiBBbGwgcHJvcGVydGllcyBkZWZhdWx0IHRvIGBmYWxzZWAuIFN1cHBvcnRlZCBwcm9wcyBhcmU6XG5cdCAqIDxVTD5cblx0ICogICAgPExJPiBsb29wOiBzZXRzIHRoZSBsb29wIHByb3BlcnR5IG9uIHRoaXMgdHdlZW4uPC9MST5cblx0ICogICAgPExJPiB1c2VUaWNrczogdXNlcyB0aWNrcyBmb3IgYWxsIGR1cmF0aW9ucyBpbnN0ZWFkIG9mIG1pbGxpc2Vjb25kcy48L0xJPlxuXHQgKiAgICA8TEk+IGlnbm9yZUdsb2JhbFBhdXNlOiBzZXRzIHRoZSB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9pZ25vcmVHbG9iYWxQYXVzZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBvblxuXHQgKiAgICB0aGlzIHR3ZWVuLjwvTEk+XG5cdCAqICAgIDxMST4gb3ZlcnJpZGU6IGlmIHRydWUsIGBjcmVhdGVqcy5Ud2Vlbi5yZW1vdmVUd2VlbnModGFyZ2V0KWAgd2lsbCBiZSBjYWxsZWQgdG8gcmVtb3ZlIGFueSBvdGhlciB0d2VlbnMgd2l0aFxuXHQgKiAgICB0aGUgc2FtZSB0YXJnZXQuXG5cdCAqICAgIDxMST4gcGF1c2VkOiBpbmRpY2F0ZXMgd2hldGhlciB0byBzdGFydCB0aGUgdHdlZW4gcGF1c2VkLjwvTEk+XG5cdCAqICAgIDxMST4gcG9zaXRpb246IGluZGljYXRlcyB0aGUgaW5pdGlhbCBwb3NpdGlvbiBmb3IgdGhpcyB0d2Vlbi48L0xJPlxuXHQgKiAgICA8TEk+IG9uQ2hhbmdlOiBzcGVjaWZpZXMgYSBsaXN0ZW5lciBmb3IgdGhlIHt7I2Nyb3NzTGluayBcIlR3ZWVuL2NoYW5nZTpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudC48L0xJPlxuXHQgKiA8L1VMPlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3BsdWdpbkRhdGFdIEFuIG9iamVjdCBjb250YWluaW5nIGRhdGEgZm9yIHVzZSBieSBpbnN0YWxsZWQgcGx1Z2lucy4gU2VlIGluZGl2aWR1YWwgcGx1Z2lucydcblx0ICogZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3ZlcnJpZGU9ZmFsc2VdIElmIHRydWUsIGFueSBwcmV2aW91cyB0d2VlbnMgb24gdGhlIHNhbWUgdGFyZ2V0IHdpbGwgYmUgcmVtb3ZlZC4gVGhpcyBpcyB0aGVcblx0ICogc2FtZSBhcyBjYWxsaW5nIGBUd2Vlbi5yZW1vdmVUd2VlbnModGFyZ2V0KWAuXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBBIHJlZmVyZW5jZSB0byB0aGUgY3JlYXRlZCB0d2Vlbi4gQWRkaXRpb25hbCBjaGFpbmVkIHR3ZWVucywgbWV0aG9kIGNhbGxzLCBvciBjYWxsYmFja3MgY2FuIGJlXG5cdCAqIGFwcGxpZWQgdG8gdGhlIHJldHVybmVkIHR3ZWVuIGluc3RhbmNlLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUd2Vlbi5nZXQgPSBmdW5jdGlvbih0YXJnZXQsIHByb3BzLCBwbHVnaW5EYXRhLCBvdmVycmlkZSkge1xuXHRcdGlmIChvdmVycmlkZSkgeyBUd2Vlbi5yZW1vdmVUd2VlbnModGFyZ2V0KTsgfVxuXHRcdHJldHVybiBuZXcgVHdlZW4odGFyZ2V0LCBwcm9wcywgcGx1Z2luRGF0YSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkdmFuY2VzIGFsbCB0d2VlbnMuIFRoaXMgdHlwaWNhbGx5IHVzZXMgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlclwifX17ey9jcm9zc0xpbmt9fSBjbGFzcywgYnV0IHlvdSBjYW4gY2FsbCBpdFxuXHQgKiBtYW51YWxseSBpZiB5b3UgcHJlZmVyIHRvIHVzZSB5b3VyIG93biBcImhlYXJ0YmVhdFwiIGltcGxlbWVudGF0aW9uLlxuXHQgKiBAbWV0aG9kIHRpY2tcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhIFRoZSBjaGFuZ2UgaW4gdGltZSBpbiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdGljay4gUmVxdWlyZWQgdW5sZXNzIGFsbCB0d2VlbnMgaGF2ZVxuXHQgKiBgdXNlVGlja3NgIHNldCB0byB0cnVlLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHBhdXNlZCBJbmRpY2F0ZXMgd2hldGhlciBhIGdsb2JhbCBwYXVzZSBpcyBpbiBlZmZlY3QuIFR3ZWVucyB3aXRoIHt7I2Nyb3NzTGluayBcIlR3ZWVuL2lnbm9yZUdsb2JhbFBhdXNlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdpbGwgaWdub3JlIHRoaXMsIGJ1dCBhbGwgb3RoZXJzIHdpbGwgcGF1c2UgaWYgdGhpcyBpcyBgdHJ1ZWAuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFR3ZWVuLnRpY2sgPSBmdW5jdGlvbihkZWx0YSwgcGF1c2VkKSB7XG5cdFx0dmFyIHR3ZWVucyA9IFR3ZWVuLl90d2VlbnMuc2xpY2UoKTsgLy8gdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zLlxuXHRcdGZvciAodmFyIGk9dHdlZW5zLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcblx0XHRcdHZhciB0d2VlbiA9IHR3ZWVuc1tpXTtcblx0XHRcdGlmICgocGF1c2VkICYmICF0d2Vlbi5pZ25vcmVHbG9iYWxQYXVzZSkgfHwgdHdlZW4uX3BhdXNlZCkgeyBjb250aW51ZTsgfVxuXHRcdFx0dHdlZW4udGljayh0d2Vlbi5fdXNlVGlja3M/MTpkZWx0YSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGUgZXZlbnRzIHRoYXQgcmVzdWx0IGZyb20gVHdlZW4gYmVpbmcgdXNlZCBhcyBhbiBldmVudCBoYW5kbGVyLiBUaGlzIGlzIGluY2x1ZGVkIHRvIGFsbG93IFR3ZWVuIHRvIGhhbmRsZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudHMgZnJvbSB0aGUgY3JlYXRlanMge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBObyBvdGhlciBldmVudHMgYXJlIGhhbmRsZWQgaW4gVHdlZW4uXG5cdCAqIEBtZXRob2QgaGFuZGxlRXZlbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IEFuIGV2ZW50IG9iamVjdCBwYXNzZWQgaW4gYnkgdGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlclwifX17ey9jcm9zc0xpbmt9fS4gV2lsbFxuXHQgKiB1c3VhbGx5IGJlIG9mIHR5cGUgXCJ0aWNrXCIuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNC4yXG5cdCAqL1xuXHRUd2Vlbi5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0aWYgKGV2ZW50LnR5cGUgPT0gXCJ0aWNrXCIpIHtcblx0XHRcdHRoaXMudGljayhldmVudC5kZWx0YSwgZXZlbnQucGF1c2VkKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIGV4aXN0aW5nIHR3ZWVucyBmb3IgYSB0YXJnZXQuIFRoaXMgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgbmV3IHR3ZWVucyBpZiB0aGUgYG92ZXJyaWRlYFxuXHQgKiBwcm9wZXJ0eSBpcyBgdHJ1ZWAuXG5cdCAqIEBtZXRob2QgcmVtb3ZlVHdlZW5zXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdG8gcmVtb3ZlIGV4aXN0aW5nIHR3ZWVucyBmcm9tLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUd2Vlbi5yZW1vdmVUd2VlbnMgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRpZiAoIXRhcmdldC50d2VlbmpzX2NvdW50KSB7IHJldHVybjsgfVxuXHRcdHZhciB0d2VlbnMgPSBUd2Vlbi5fdHdlZW5zO1xuXHRcdGZvciAodmFyIGk9dHdlZW5zLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcblx0XHRcdHZhciB0d2VlbiA9IHR3ZWVuc1tpXTtcblx0XHRcdGlmICh0d2Vlbi5fdGFyZ2V0ID09IHRhcmdldCkge1xuXHRcdFx0XHR0d2Vlbi5fcGF1c2VkID0gdHJ1ZTtcblx0XHRcdFx0dHdlZW5zLnNwbGljZShpLCAxKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGFyZ2V0LnR3ZWVuanNfY291bnQgPSAwO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9wIGFuZCByZW1vdmUgYWxsIGV4aXN0aW5nIHR3ZWVucy5cblx0ICogQG1ldGhvZCByZW1vdmVBbGxUd2VlbnNcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC40LjFcblx0ICovXG5cdFR3ZWVuLnJlbW92ZUFsbFR3ZWVucyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0d2VlbnMgPSBUd2Vlbi5fdHdlZW5zO1xuXHRcdGZvciAodmFyIGk9IDAsIGw9dHdlZW5zLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdHZhciB0d2VlbiA9IHR3ZWVuc1tpXTtcblx0XHRcdHR3ZWVuLl9wYXVzZWQgPSB0cnVlO1xuXHRcdFx0dHdlZW4udGFyZ2V0JiYodHdlZW4udGFyZ2V0LnR3ZWVuanNfY291bnQgPSAwKTtcblx0XHR9XG5cdFx0dHdlZW5zLmxlbmd0aCA9IDA7XG5cdH07XG5cblx0LyoqXG5cdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgYWN0aXZlIHR3ZWVucyAoYW5kIGhvdyBtYW55KSBvbiB0aGUgdGFyZ2V0IG9iamVjdCAoaWYgc3BlY2lmaWVkKSBvciBpbiBnZW5lcmFsLlxuXHQgKiBAbWV0aG9kIGhhc0FjdGl2ZVR3ZWVuc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gW3RhcmdldF0gVGhlIHRhcmdldCB0byBjaGVjayBmb3IgYWN0aXZlIHR3ZWVucy4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGluZGljYXRlXG5cdCAqIGlmIHRoZXJlIGFyZSBhbnkgYWN0aXZlIHR3ZWVucyBvbiBhbnkgdGFyZ2V0LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGVyZSBhcmUgYWN0aXZlIHR3ZWVucy5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VHdlZW4uaGFzQWN0aXZlVHdlZW5zID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0aWYgKHRhcmdldCkgeyByZXR1cm4gdGFyZ2V0LnR3ZWVuanNfY291bnQgIT0gbnVsbCAmJiAhIXRhcmdldC50d2VlbmpzX2NvdW50OyB9XG5cdFx0cmV0dXJuIFR3ZWVuLl90d2VlbnMgJiYgISFUd2Vlbi5fdHdlZW5zLmxlbmd0aDtcblx0fTtcblxuXHQvKipcblx0ICogSW5zdGFsbHMgYSBwbHVnaW4sIHdoaWNoIGNhbiBtb2RpZnkgaG93IGNlcnRhaW4gcHJvcGVydGllcyBhcmUgaGFuZGxlZCB3aGVuIHR3ZWVuZWQuIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQ1NTUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBhbiBleGFtcGxlIG9mIGhvdyB0byB3cml0ZSBUd2VlbkpTIHBsdWdpbnMuXG5cdCAqIEBtZXRob2QgaW5zdGFsbFBsdWdpblxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gVGhlIHBsdWdpbiBjbGFzcyB0byBpbnN0YWxsXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHByb3BlcnRpZXMgQW4gYXJyYXkgb2YgcHJvcGVydGllcyB0aGF0IHRoZSBwbHVnaW4gd2lsbCBoYW5kbGUuXG5cdCAqL1xuXHRUd2Vlbi5pbnN0YWxsUGx1Z2luID0gZnVuY3Rpb24ocGx1Z2luLCBwcm9wZXJ0aWVzKSB7XG5cdFx0dmFyIHByaW9yaXR5ID0gcGx1Z2luLnByaW9yaXR5O1xuXHRcdGlmIChwcmlvcml0eSA9PSBudWxsKSB7IHBsdWdpbi5wcmlvcml0eSA9IHByaW9yaXR5ID0gMDsgfVxuXHRcdGZvciAodmFyIGk9MCxsPXByb3BlcnRpZXMubGVuZ3RoLHA9VHdlZW4uX3BsdWdpbnM7aTxsO2krKykge1xuXHRcdFx0dmFyIG4gPSBwcm9wZXJ0aWVzW2ldO1xuXHRcdFx0aWYgKCFwW25dKSB7IHBbbl0gPSBbcGx1Z2luXTsgfVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHZhciBhcnIgPSBwW25dO1xuXHRcdFx0XHRmb3IgKHZhciBqPTAsamw9YXJyLmxlbmd0aDtqPGpsO2orKykge1xuXHRcdFx0XHRcdGlmIChwcmlvcml0eSA8IGFycltqXS5wcmlvcml0eSkgeyBicmVhazsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdHBbbl0uc3BsaWNlKGosMCxwbHVnaW4pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIG9yIHVucmVnaXN0ZXJzIGEgdHdlZW4gd2l0aCB0aGUgdGlja2luZyBzeXN0ZW0uXG5cdCAqIEBtZXRob2QgX3JlZ2lzdGVyXG5cdCAqIEBwYXJhbSB7VHdlZW59IHR3ZWVuIFRoZSB0d2VlbiBpbnN0YW5jZSB0byByZWdpc3RlciBvciB1bnJlZ2lzdGVyLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIElmIGB0cnVlYCwgdGhlIHR3ZWVuIGlzIHJlZ2lzdGVyZWQuIElmIGBmYWxzZWAgdGhlIHR3ZWVuIGlzIHVucmVnaXN0ZXJlZC5cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRUd2Vlbi5fcmVnaXN0ZXIgPSBmdW5jdGlvbih0d2VlbiwgdmFsdWUpIHtcblx0XHR2YXIgdGFyZ2V0ID0gdHdlZW4uX3RhcmdldDtcblx0XHR2YXIgdHdlZW5zID0gVHdlZW4uX3R3ZWVucztcblx0XHRpZiAodmFsdWUgJiYgIXR3ZWVuLl9yZWdpc3RlcmVkKSB7XG5cdFx0XHQvLyBUT0RPOiB0aGlzIGFwcHJvYWNoIG1pZ2h0IGZhaWwgaWYgYSBkZXYgaXMgdXNpbmcgc2VhbGVkIG9iamVjdHMgaW4gRVM1XG5cdFx0XHRpZiAodGFyZ2V0KSB7IHRhcmdldC50d2VlbmpzX2NvdW50ID0gdGFyZ2V0LnR3ZWVuanNfY291bnQgPyB0YXJnZXQudHdlZW5qc19jb3VudCsxIDogMTsgfVxuXHRcdFx0dHdlZW5zLnB1c2godHdlZW4pO1xuXHRcdFx0aWYgKCFUd2Vlbi5faW5pdGVkICYmIGNyZWF0ZWpzLlRpY2tlcikgeyBjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgVHdlZW4pOyBUd2Vlbi5faW5pdGVkID0gdHJ1ZTsgfVxuXHRcdH0gZWxzZSBpZiAoIXZhbHVlICYmIHR3ZWVuLl9yZWdpc3RlcmVkKSB7XG5cdFx0XHRpZiAodGFyZ2V0KSB7IHRhcmdldC50d2VlbmpzX2NvdW50LS07IH1cblx0XHRcdHZhciBpID0gdHdlZW5zLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0aWYgKHR3ZWVuc1tpXSA9PSB0d2Vlbikge1xuXHRcdFx0XHRcdHR3ZWVucy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dHdlZW4uX3JlZ2lzdGVyZWQgPSB2YWx1ZTtcblx0fTtcblxuXG4vLyBldmVudHM6XG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIHR3ZWVuJ3MgcG9zaXRpb24gY2hhbmdlcy5cblx0ICogQGV2ZW50IGNoYW5nZVxuXHQgKiBAc2luY2UgMC40LjBcblx0ICoqL1xuXHRcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBRdWV1ZXMgYSB3YWl0IChlc3NlbnRpYWxseSBhbiBlbXB0eSB0d2VlbikuXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICpcdFx0Ly9UaGlzIHR3ZWVuIHdpbGwgd2FpdCAxcyBiZWZvcmUgYWxwaGEgaXMgZmFkZWQgdG8gMC5cblx0ICpcdFx0Y3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldCkud2FpdCgxMDAwKS50byh7YWxwaGE6MH0sIDEwMDApO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHdhaXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIFRoZSBkdXJhdGlvbiBvZiB0aGUgd2FpdCBpbiBtaWxsaXNlY29uZHMgKG9yIGluIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgdHJ1ZSkuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Bhc3NpdmVdIFR3ZWVuIHByb3BlcnRpZXMgd2lsbCBub3QgYmUgdXBkYXRlZCBkdXJpbmcgYSBwYXNzaXZlIHdhaXQuIFRoaXNcblx0ICogaXMgbW9zdGx5IHVzZWZ1bCBmb3IgdXNlIHdpdGgge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmVcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2VzIHRoYXQgY29udGFpbiBtdWx0aXBsZSB0d2VlbnNcblx0ICogYWZmZWN0aW5nIHRoZSBzYW1lIHRhcmdldCBhdCBkaWZmZXJlbnQgdGltZXMuXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBUaGlzIHR3ZWVuIGluc3RhbmNlIChmb3IgY2hhaW5pbmcgY2FsbHMpLlxuXHQgKiovXG5cdHAud2FpdCA9IGZ1bmN0aW9uKGR1cmF0aW9uLCBwYXNzaXZlKSB7XG5cdFx0aWYgKGR1cmF0aW9uID09IG51bGwgfHwgZHVyYXRpb24gPD0gMCkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHZhciBvID0gdGhpcy5fY2xvbmVQcm9wcyh0aGlzLl9jdXJRdWV1ZVByb3BzKTtcblx0XHRyZXR1cm4gdGhpcy5fYWRkU3RlcCh7ZDpkdXJhdGlvbiwgcDA6bywgZTp0aGlzLl9saW5lYXJFYXNlLCBwMTpvLCB2OnBhc3NpdmV9KTtcblx0fTtcblxuXHQvKipcblx0ICogUXVldWVzIGEgdHdlZW4gZnJvbSB0aGUgY3VycmVudCB2YWx1ZXMgdG8gdGhlIHRhcmdldCBwcm9wZXJ0aWVzLiBTZXQgZHVyYXRpb24gdG8gMCB0byBqdW1wIHRvIHRoZXNlIHZhbHVlLlxuXHQgKiBOdW1lcmljIHByb3BlcnRpZXMgd2lsbCBiZSB0d2VlbmVkIGZyb20gdGhlaXIgY3VycmVudCB2YWx1ZSBpbiB0aGUgdHdlZW4gdG8gdGhlIHRhcmdldCB2YWx1ZS4gTm9uLW51bWVyaWNcblx0ICogcHJvcGVydGllcyB3aWxsIGJlIHNldCBhdCB0aGUgZW5kIG9mIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24uXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICpcdFx0Y3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldCkudG8oe2FscGhhOjB9LCAxMDAwKTtcblx0ICpcblx0ICogQG1ldGhvZCB0b1xuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQW4gb2JqZWN0IHNwZWNpZnlpbmcgcHJvcGVydHkgdGFyZ2V0IHZhbHVlcyBmb3IgdGhpcyB0d2VlbiAoRXguIGB7eDozMDB9YCB3b3VsZCB0d2VlbiB0aGUgeFxuXHQgKiBwcm9wZXJ0eSBvZiB0aGUgdGFyZ2V0IHRvIDMwMCkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZHVyYXRpb249MF0gVGhlIGR1cmF0aW9uIG9mIHRoZSB3YWl0IGluIG1pbGxpc2Vjb25kcyAob3IgaW4gdGlja3MgaWYgYHVzZVRpY2tzYCBpcyB0cnVlKS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vhc2U9XCJsaW5lYXJcIl0gVGhlIGVhc2luZyBmdW5jdGlvbiB0byB1c2UgZm9yIHRoaXMgdHdlZW4uIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiRWFzZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBjbGFzcyBmb3IgYSBsaXN0IG9mIGJ1aWx0LWluIGVhc2UgZnVuY3Rpb25zLlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhpcyB0d2VlbiBpbnN0YW5jZSAoZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICovXG5cdHAudG8gPSBmdW5jdGlvbihwcm9wcywgZHVyYXRpb24sIGVhc2UpIHtcblx0XHRpZiAoaXNOYU4oZHVyYXRpb24pIHx8IGR1cmF0aW9uIDwgMCkgeyBkdXJhdGlvbiA9IDA7IH1cblx0XHRyZXR1cm4gdGhpcy5fYWRkU3RlcCh7ZDpkdXJhdGlvbnx8MCwgcDA6dGhpcy5fY2xvbmVQcm9wcyh0aGlzLl9jdXJRdWV1ZVByb3BzKSwgZTplYXNlLCBwMTp0aGlzLl9jbG9uZVByb3BzKHRoaXMuX2FwcGVuZFF1ZXVlUHJvcHMocHJvcHMpKX0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBRdWV1ZXMgYW4gYWN0aW9uIHRvIGNhbGwgdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgIFx0Ly93b3VsZCBjYWxsIG15RnVuY3Rpb24oKSBhZnRlciAxIHNlY29uZC5cblx0ICogICBcdG15VHdlZW4ud2FpdCgxMDAwKS5jYWxsKG15RnVuY3Rpb24pO1xuXHQgKlxuXHQgKiBAbWV0aG9kIGNhbGxcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtwYXJhbXNdLiBUaGUgcGFyYW1ldGVycyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLiBJZiB0aGlzIGlzIG9taXR0ZWQsIHRoZW4gdGhlIGZ1bmN0aW9uXG5cdCAqICAgICAgd2lsbCBiZSBjYWxsZWQgd2l0aCBhIHNpbmdsZSBwYXJhbSBwb2ludGluZyB0byB0aGlzIHR3ZWVuLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXS4gVGhlIHNjb3BlIHRvIGNhbGwgdGhlIGZ1bmN0aW9uIGluLiBJZiBvbWl0dGVkLCBpdCB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgdGFyZ2V0J3Ncblx0ICogICAgICBzY29wZS5cblx0ICogQHJldHVybiB7VHdlZW59IFRoaXMgdHdlZW4gaW5zdGFuY2UgKGZvciBjaGFpbmluZyBjYWxscykuXG5cdCAqL1xuXHRwLmNhbGwgPSBmdW5jdGlvbihjYWxsYmFjaywgcGFyYW1zLCBzY29wZSkge1xuXHRcdHJldHVybiB0aGlzLl9hZGRBY3Rpb24oe2Y6Y2FsbGJhY2ssIHA6cGFyYW1zID8gcGFyYW1zIDogW3RoaXNdLCBvOnNjb3BlID8gc2NvcGUgOiB0aGlzLl90YXJnZXR9KTtcblx0fTtcblxuXHQvLyBUT0RPOiBhZGQgY2xhcmlmaWNhdGlvbiBiZXR3ZWVuIHRoaXMgYW5kIGEgMCBkdXJhdGlvbiAudG86XG5cdC8qKlxuXHQgKiBRdWV1ZXMgYW4gYWN0aW9uIHRvIHNldCB0aGUgc3BlY2lmaWVkIHByb3BzIG9uIHRoZSBzcGVjaWZpZWQgdGFyZ2V0LiBJZiB0YXJnZXQgaXMgbnVsbCwgaXQgd2lsbCB1c2UgdGhpcyB0d2VlbidzXG5cdCAqIHRhcmdldC5cblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKlx0XHRteVR3ZWVuLndhaXQoMTAwMCkuc2V0KHt2aXNpYmxlOmZhbHNlfSxmb28pO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHNldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgVGhlIHByb3BlcnRpZXMgdG8gc2V0IChleC4gYHt2aXNpYmxlOmZhbHNlfWApLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3RhcmdldF0gVGhlIHRhcmdldCB0byBzZXQgdGhlIHByb3BlcnRpZXMgb24uIElmIG9taXR0ZWQsIHRoZXkgd2lsbCBiZSBzZXQgb24gdGhlIHR3ZWVuJ3MgdGFyZ2V0LlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhpcyB0d2VlbiBpbnN0YW5jZSAoZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICovXG5cdHAuc2V0ID0gZnVuY3Rpb24ocHJvcHMsIHRhcmdldCkge1xuXHRcdHJldHVybiB0aGlzLl9hZGRBY3Rpb24oe2Y6dGhpcy5fc2V0LCBvOnRoaXMsIHA6W3Byb3BzLCB0YXJnZXQgPyB0YXJnZXQgOiB0aGlzLl90YXJnZXRdfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFF1ZXVlcyBhbiBhY3Rpb24gdG8gcGxheSAodW5wYXVzZSkgdGhlIHNwZWNpZmllZCB0d2Vlbi4gVGhpcyBlbmFibGVzIHlvdSB0byBzZXF1ZW5jZSBtdWx0aXBsZSB0d2VlbnMuXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICpcdFx0bXlUd2Vlbi50byh7eDoxMDB9LDUwMCkucGxheShvdGhlclR3ZWVuKTtcblx0ICpcblx0ICogQG1ldGhvZCBwbGF5XG5cdCAqIEBwYXJhbSB7VHdlZW59IHR3ZWVuIFRoZSB0d2VlbiB0byBwbGF5LlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhpcyB0d2VlbiBpbnN0YW5jZSAoZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICovXG5cdHAucGxheSA9IGZ1bmN0aW9uKHR3ZWVuKSB7XG5cdFx0aWYgKCF0d2VlbikgeyB0d2VlbiA9IHRoaXM7IH1cblx0XHRyZXR1cm4gdGhpcy5jYWxsKHR3ZWVuLnNldFBhdXNlZCwgW2ZhbHNlXSwgdHdlZW4pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBRdWV1ZXMgYW4gYWN0aW9uIHRvIHBhdXNlIHRoZSBzcGVjaWZpZWQgdHdlZW4uXG5cdCAqIEBtZXRob2QgcGF1c2Vcblx0ICogQHBhcmFtIHtUd2Vlbn0gdHdlZW4gVGhlIHR3ZWVuIHRvIHBhdXNlLiBJZiBudWxsLCBpdCBwYXVzZXMgdGhpcyB0d2Vlbi5cblx0ICogQHJldHVybiB7VHdlZW59IFRoaXMgdHdlZW4gaW5zdGFuY2UgKGZvciBjaGFpbmluZyBjYWxscylcblx0ICovXG5cdHAucGF1c2UgPSBmdW5jdGlvbih0d2Vlbikge1xuXHRcdGlmICghdHdlZW4pIHsgdHdlZW4gPSB0aGlzOyB9XG5cdFx0cmV0dXJuIHRoaXMuY2FsbCh0d2Vlbi5zZXRQYXVzZWQsIFt0cnVlXSwgdHdlZW4pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZHZhbmNlcyB0aGUgdHdlZW4gdG8gYSBzcGVjaWZpZWQgcG9zaXRpb24uXG5cdCAqIEBtZXRob2Qgc2V0UG9zaXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSBwb3NpdGlvbiB0byBzZWVrIHRvIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgdXNlVGlja3MgaXMgdHJ1ZSkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYWN0aW9uc01vZGU9MV0gU3BlY2lmaWVzIGhvdyBhY3Rpb25zIGFyZSBoYW5kbGVkIChpZS4gY2FsbCwgc2V0LCBwbGF5LCBwYXVzZSk6XG5cdCAqIDx1bD5cblx0ICogICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiVHdlZW4vTk9ORTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSAoMCkgLSBydW4gbm8gYWN0aW9ucy48L2xpPlxuXHQgKiAgICAgIDxsaT57eyNjcm9zc0xpbmsgXCJUd2Vlbi9MT09QOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319ICgxKSAtIGlmIG5ldyBwb3NpdGlvbiBpcyBsZXNzIHRoYW4gb2xkLCB0aGVuIHJ1biBhbGxcblx0ICogICAgICBhY3Rpb25zIGJldHdlZW4gb2xkIGFuZCBkdXJhdGlvbiwgdGhlbiBhbGwgYWN0aW9ucyBiZXR3ZWVuIDAgYW5kIG5ldy48L2xpPlxuXHQgKiAgICAgIDxsaT57eyNjcm9zc0xpbmsgXCJUd2Vlbi9SRVZFUlNFOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319ICgyKSAtIGlmIG5ldyBwb3NpdGlvbiBpcyBsZXNzIHRoYW4gb2xkLCBydW4gYWxsXG5cdCAqICAgICAgYWN0aW9ucyBiZXR3ZWVuIHRoZW0gaW4gcmV2ZXJzZS48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdHdlZW4gaXMgY29tcGxldGUgKGllLiB0aGUgZnVsbCB0d2VlbiBoYXMgcnVuICYge3sjY3Jvc3NMaW5rIFwiVHdlZW4vbG9vcDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpcyBgZmFsc2VgKS5cblx0ICovXG5cdHAuc2V0UG9zaXRpb24gPSBmdW5jdGlvbih2YWx1ZSwgYWN0aW9uc01vZGUpIHtcblx0XHRpZiAodmFsdWUgPCAwKSB7IHZhbHVlID0gMDsgfVxuXHRcdGlmIChhY3Rpb25zTW9kZSA9PSBudWxsKSB7IGFjdGlvbnNNb2RlID0gMTsgfVxuXG5cdFx0Ly8gbm9ybWFsaXplIHBvc2l0aW9uOlxuXHRcdHZhciB0ID0gdmFsdWU7XG5cdFx0dmFyIGVuZCA9IGZhbHNlO1xuXHRcdGlmICh0ID49IHRoaXMuZHVyYXRpb24pIHtcblx0XHRcdGlmICh0aGlzLmxvb3ApIHsgdCA9IHQldGhpcy5kdXJhdGlvbjsgfVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHQgPSB0aGlzLmR1cmF0aW9uO1xuXHRcdFx0XHRlbmQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodCA9PSB0aGlzLl9wcmV2UG9zKSB7IHJldHVybiBlbmQ7IH1cblxuXG5cdFx0dmFyIHByZXZQb3MgPSB0aGlzLl9wcmV2UG9zO1xuXHRcdHRoaXMucG9zaXRpb24gPSB0aGlzLl9wcmV2UG9zID0gdDsgLy8gc2V0IHRoaXMgaW4gYWR2YW5jZSBpbiBjYXNlIGFuIGFjdGlvbiBtb2RpZmllcyBwb3NpdGlvbi5cblx0XHR0aGlzLl9wcmV2UG9zaXRpb24gPSB2YWx1ZTtcblxuXHRcdC8vIGhhbmRsZSB0d2VlbnM6XG5cdFx0aWYgKHRoaXMuX3RhcmdldCkge1xuXHRcdFx0aWYgKGVuZCkge1xuXHRcdFx0XHQvLyBhZGRyZXNzZXMgcHJvYmxlbXMgd2l0aCBhbiBlbmRpbmcgemVybyBsZW5ndGggc3RlcC5cblx0XHRcdFx0dGhpcy5fdXBkYXRlVGFyZ2V0UHJvcHMobnVsbCwxKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fc3RlcHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHQvLyBmaW5kIG91ciBuZXcgdHdlZW4gaW5kZXg6XG5cdFx0XHRcdGZvciAodmFyIGk9MCwgbD10aGlzLl9zdGVwcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3N0ZXBzW2ldLnQgPiB0KSB7IGJyZWFrOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHN0ZXAgPSB0aGlzLl9zdGVwc1tpLTFdO1xuXHRcdFx0XHR0aGlzLl91cGRhdGVUYXJnZXRQcm9wcyhzdGVwLCh0aGlzLl9zdGVwUG9zaXRpb24gPSB0LXN0ZXAudCkvc3RlcC5kKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBydW4gYWN0aW9uczpcblx0XHRpZiAoYWN0aW9uc01vZGUgIT0gMCAmJiB0aGlzLl9hY3Rpb25zLmxlbmd0aCA+IDApIHtcblx0XHRcdGlmICh0aGlzLl91c2VUaWNrcykge1xuXHRcdFx0XHQvLyBvbmx5IHJ1biB0aGUgYWN0aW9ucyB3ZSBsYW5kZWQgb24uXG5cdFx0XHRcdHRoaXMuX3J1bkFjdGlvbnModCx0KTtcblx0XHRcdH0gZWxzZSBpZiAoYWN0aW9uc01vZGUgPT0gMSAmJiB0PHByZXZQb3MpIHtcblx0XHRcdFx0aWYgKHByZXZQb3MgIT0gdGhpcy5kdXJhdGlvbikgeyB0aGlzLl9ydW5BY3Rpb25zKHByZXZQb3MsIHRoaXMuZHVyYXRpb24pOyB9XG5cdFx0XHRcdHRoaXMuX3J1bkFjdGlvbnMoMCwgdCwgdHJ1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9ydW5BY3Rpb25zKHByZXZQb3MsIHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChlbmQpIHsgdGhpcy5zZXRQYXVzZWQodHJ1ZSk7IH1cblxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjaGFuZ2VcIik7XG5cdFx0cmV0dXJuIGVuZDtcblx0fTtcblxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhpcyB0d2VlbiBieSB0aGUgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWZgdXNlVGlja3NgIGlzIGB0cnVlYCkuXG5cdCAqIFRoaXMgaXMgbm9ybWFsbHkgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIFR3ZWVuIGVuZ2luZSAodmlhIHt7I2Nyb3NzTGluayBcIlR3ZWVuL3RpY2tcIn19e3svY3Jvc3NMaW5rfX0pLCBidXQgaXNcblx0ICogZXhwb3NlZCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCB0aWNrXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YSBUaGUgdGltZSB0byBhZHZhbmNlIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzYCBpcyBgdHJ1ZWApLlxuXHQgKi9cblx0cC50aWNrID0gZnVuY3Rpb24oZGVsdGEpIHtcblx0XHRpZiAodGhpcy5fcGF1c2VkKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuc2V0UG9zaXRpb24odGhpcy5fcHJldlBvc2l0aW9uK2RlbHRhKTtcblx0fTtcblxuXHQvKipcblx0ICogUGF1c2VzIG9yIHBsYXlzIHRoaXMgdHdlZW4uXG5cdCAqIEBtZXRob2Qgc2V0UGF1c2VkXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ZhbHVlPXRydWVdIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0d2VlbiBzaG91bGQgYmUgcGF1c2VkIChgdHJ1ZWApIG9yIHBsYXllZCAoYGZhbHNlYCkuXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBUaGlzIHR3ZWVuIGluc3RhbmNlIChmb3IgY2hhaW5pbmcgY2FsbHMpXG5cdCAqL1xuXHRwLnNldFBhdXNlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMuX3BhdXNlZCA9PT0gISF2YWx1ZSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX3BhdXNlZCA9ICEhdmFsdWU7XG5cdFx0VHdlZW4uX3JlZ2lzdGVyKHRoaXMsICF2YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0Ly8gdGlueSBhcGkgKHByaW1hcmlseSBmb3IgdG9vbCBvdXRwdXQpOlxuXHRwLncgPSBwLndhaXQ7XG5cdHAudCA9IHAudG87XG5cdHAuYyA9IHAuY2FsbDtcblx0cC5zID0gcC5zZXQ7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1R3ZWVuXVwiO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyhcIlR3ZWVuIGNhbiBub3QgYmUgY2xvbmVkLlwiKVxuXHR9O1xuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF91cGRhdGVUYXJnZXRQcm9wc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gc3RlcFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmF0aW9cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fdXBkYXRlVGFyZ2V0UHJvcHMgPSBmdW5jdGlvbihzdGVwLCByYXRpbykge1xuXHRcdHZhciBwMCxwMSx2LHYwLHYxLGFycjtcblx0XHRpZiAoIXN0ZXAgJiYgcmF0aW8gPT0gMSkge1xuXHRcdFx0Ly8gR0RTOiB3aGVuIGRvZXMgdGhpcyBydW4/IEp1c3QgYXQgdGhlIHZlcnkgZW5kPyBTaG91bGRuJ3QuXG5cdFx0XHR0aGlzLnBhc3NpdmUgPSBmYWxzZTtcblx0XHRcdHAwID0gcDEgPSB0aGlzLl9jdXJRdWV1ZVByb3BzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBhc3NpdmUgPSAhIXN0ZXAudjtcblx0XHRcdGlmICh0aGlzLnBhc3NpdmUpIHsgcmV0dXJuOyB9IC8vIGRvbid0IHVwZGF0ZSBwcm9wcy5cblx0XHRcdC8vIGFwcGx5IGVhc2UgdG8gcmF0aW8uXG5cdFx0XHRpZiAoc3RlcC5lKSB7IHJhdGlvID0gc3RlcC5lKHJhdGlvLDAsMSwxKTsgfVxuXHRcdFx0cDAgPSBzdGVwLnAwO1xuXHRcdFx0cDEgPSBzdGVwLnAxO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIG4gaW4gdGhpcy5faW5pdFF1ZXVlUHJvcHMpIHtcblx0XHRcdGlmICgodjAgPSBwMFtuXSkgPT0gbnVsbCkgeyBwMFtuXSA9IHYwID0gdGhpcy5faW5pdFF1ZXVlUHJvcHNbbl07IH1cblx0XHRcdGlmICgodjEgPSBwMVtuXSkgPT0gbnVsbCkgeyBwMVtuXSA9IHYxID0gdjA7IH1cblx0XHRcdGlmICh2MCA9PSB2MSB8fCByYXRpbyA9PSAwIHx8IHJhdGlvID09IDEgfHwgKHR5cGVvZih2MCkgIT0gXCJudW1iZXJcIikpIHtcblx0XHRcdFx0Ly8gbm8gaW50ZXJwb2xhdGlvbiAtIGVpdGhlciBhdCBzdGFydCwgZW5kLCB2YWx1ZXMgZG9uJ3QgY2hhbmdlLCBvciB0aGUgdmFsdWUgaXMgbm9uLW51bWVyaWMuXG5cdFx0XHRcdHYgPSByYXRpbyA9PSAxID8gdjEgOiB2MDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHYgPSB2MCsodjEtdjApKnJhdGlvO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaWdub3JlID0gZmFsc2U7XG5cdFx0XHRpZiAoYXJyID0gVHdlZW4uX3BsdWdpbnNbbl0pIHtcblx0XHRcdFx0Zm9yICh2YXIgaT0wLGw9YXJyLmxlbmd0aDtpPGw7aSsrKSB7XG5cdFx0XHRcdFx0dmFyIHYyID0gYXJyW2ldLnR3ZWVuKHRoaXMsIG4sIHYsIHAwLCBwMSwgcmF0aW8sICEhc3RlcCYmcDA9PXAxLCAhc3RlcCk7XG5cdFx0XHRcdFx0aWYgKHYyID09IFR3ZWVuLklHTk9SRSkgeyBpZ25vcmUgPSB0cnVlOyB9XG5cdFx0XHRcdFx0ZWxzZSB7IHYgPSB2MjsgfVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWlnbm9yZSkgeyB0aGlzLl90YXJnZXRbbl0gPSB2OyB9XG5cdFx0fVxuXG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3J1bkFjdGlvbnNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0UG9zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBlbmRQb3Ncblx0ICogQHBhcmFtIHtCb29sZWFufSBpbmNsdWRlU3RhcnRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fcnVuQWN0aW9ucyA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBlbmRQb3MsIGluY2x1ZGVTdGFydCkge1xuXHRcdHZhciBzUG9zID0gc3RhcnRQb3M7XG5cdFx0dmFyIGVQb3MgPSBlbmRQb3M7XG5cdFx0dmFyIGkgPSAtMTtcblx0XHR2YXIgaiA9IHRoaXMuX2FjdGlvbnMubGVuZ3RoO1xuXHRcdHZhciBrID0gMTtcblx0XHRpZiAoc3RhcnRQb3MgPiBlbmRQb3MpIHtcblx0XHRcdC8vIHJ1bm5pbmcgYmFja3dhcmRzLCBmbGlwIGV2ZXJ5dGhpbmc6XG5cdFx0XHRzUG9zID0gZW5kUG9zO1xuXHRcdFx0ZVBvcyA9IHN0YXJ0UG9zO1xuXHRcdFx0aSA9IGo7XG5cdFx0XHRqID0gayA9IC0xO1xuXHRcdH1cblx0XHR3aGlsZSAoKGkrPWspICE9IGopIHtcblx0XHRcdHZhciBhY3Rpb24gPSB0aGlzLl9hY3Rpb25zW2ldO1xuXHRcdFx0dmFyIHBvcyA9IGFjdGlvbi50O1xuXHRcdFx0aWYgKHBvcyA9PSBlUG9zIHx8IChwb3MgPiBzUG9zICYmIHBvcyA8IGVQb3MpIHx8IChpbmNsdWRlU3RhcnQgJiYgcG9zID09IHN0YXJ0UG9zKSApIHtcblx0XHRcdFx0YWN0aW9uLmYuYXBwbHkoYWN0aW9uLm8sIGFjdGlvbi5wKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2FwcGVuZFF1ZXVlUHJvcHNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fYXBwZW5kUXVldWVQcm9wcyA9IGZ1bmN0aW9uKG8pIHtcblx0XHR2YXIgYXJyLG9sZFZhbHVlLGksIGwsIGluamVjdFByb3BzO1xuXHRcdGZvciAodmFyIG4gaW4gbykge1xuXHRcdFx0aWYgKHRoaXMuX2luaXRRdWV1ZVByb3BzW25dID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0b2xkVmFsdWUgPSB0aGlzLl90YXJnZXRbbl07XG5cblx0XHRcdFx0Ly8gaW5pdCBwbHVnaW5zOlxuXHRcdFx0XHRpZiAoYXJyID0gVHdlZW4uX3BsdWdpbnNbbl0pIHtcblx0XHRcdFx0XHRmb3IgKGk9MCxsPWFyci5sZW5ndGg7aTxsO2krKykge1xuXHRcdFx0XHRcdFx0b2xkVmFsdWUgPSBhcnJbaV0uaW5pdCh0aGlzLCBuLCBvbGRWYWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2luaXRRdWV1ZVByb3BzW25dID0gdGhpcy5fY3VyUXVldWVQcm9wc1tuXSA9IChvbGRWYWx1ZT09PXVuZGVmaW5lZCkgPyBudWxsIDogb2xkVmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbGRWYWx1ZSA9IHRoaXMuX2N1clF1ZXVlUHJvcHNbbl07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgbiBpbiBvKSB7XG5cdFx0XHRvbGRWYWx1ZSA9IHRoaXMuX2N1clF1ZXVlUHJvcHNbbl07XG5cdFx0XHRpZiAoYXJyID0gVHdlZW4uX3BsdWdpbnNbbl0pIHtcblx0XHRcdFx0aW5qZWN0UHJvcHMgPSBpbmplY3RQcm9wc3x8e307XG5cdFx0XHRcdGZvciAoaT0wLCBsPWFyci5sZW5ndGg7aTxsO2krKykge1xuXHRcdFx0XHRcdC8vIFRPRE86IHJlbW92ZSB0aGUgY2hlY2sgZm9yIC5zdGVwIGluIHRoZSBuZXh0IHZlcnNpb24uIEl0J3MgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cdFx0XHRcdFx0aWYgKGFycltpXS5zdGVwKSB7IGFycltpXS5zdGVwKHRoaXMsIG4sIG9sZFZhbHVlLCBvW25dLCBpbmplY3RQcm9wcyk7IH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY3VyUXVldWVQcm9wc1tuXSA9IG9bbl07XG5cdFx0fVxuXHRcdGlmIChpbmplY3RQcm9wcykgeyB0aGlzLl9hcHBlbmRRdWV1ZVByb3BzKGluamVjdFByb3BzKTsgfVxuXHRcdHJldHVybiB0aGlzLl9jdXJRdWV1ZVByb3BzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9jbG9uZVByb3BzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9jbG9uZVByb3BzID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHR2YXIgbyA9IHt9O1xuXHRcdGZvciAodmFyIG4gaW4gcHJvcHMpIHtcblx0XHRcdG9bbl0gPSBwcm9wc1tuXTtcblx0XHR9XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2FkZFN0ZXBcblx0ICogQHBhcmFtIHtPYmplY3R9IG9cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fYWRkU3RlcCA9IGZ1bmN0aW9uKG8pIHtcblx0XHRpZiAoby5kID4gMCkge1xuXHRcdFx0dGhpcy5fc3RlcHMucHVzaChvKTtcblx0XHRcdG8udCA9IHRoaXMuZHVyYXRpb247XG5cdFx0XHR0aGlzLmR1cmF0aW9uICs9IG8uZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2FkZEFjdGlvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gb1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9hZGRBY3Rpb24gPSBmdW5jdGlvbihvKSB7XG5cdFx0by50ID0gdGhpcy5kdXJhdGlvbjtcblx0XHR0aGlzLl9hY3Rpb25zLnB1c2gobyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3NldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2V0ID0gZnVuY3Rpb24ocHJvcHMsIG8pIHtcblx0XHRmb3IgKHZhciBuIGluIHByb3BzKSB7XG5cdFx0XHRvW25dID0gcHJvcHNbbl07XG5cdFx0fVxuXHR9O1xuXG5cdGNyZWF0ZWpzLlR3ZWVuID0gY3JlYXRlanMucHJvbW90ZShUd2VlbiwgXCJFdmVudERpc3BhdGNoZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUaW1lbGluZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFxuXG4vLyBjb25zdHJ1Y3Rvclx0XG5cdC8qKlxuXHQgKiBUaGUgVGltZWxpbmUgY2xhc3Mgc3luY2hyb25pemVzIG11bHRpcGxlIHR3ZWVucyBhbmQgYWxsb3dzIHRoZW0gdG8gYmUgY29udHJvbGxlZCBhcyBhIGdyb3VwLiBQbGVhc2Ugbm90ZSB0aGF0IGlmIGFcblx0ICogdGltZWxpbmUgaXMgbG9vcGluZywgdGhlIHR3ZWVucyBvbiBpdCBtYXkgYXBwZWFyIHRvIGxvb3AgZXZlbiBpZiB0aGUgXCJsb29wXCIgcHJvcGVydHkgb2YgdGhlIHR3ZWVuIGlzIGZhbHNlLlxuXHQgKiBAY2xhc3MgVGltZWxpbmVcblx0ICogQHBhcmFtIHtBcnJheX0gdHdlZW5zIEFuIGFycmF5IG9mIFR3ZWVucyB0byBhZGQgdG8gdGhpcyB0aW1lbGluZS4gU2VlIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2FkZFR3ZWVuXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBtb3JlIGluZm8uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBsYWJlbHMgQW4gb2JqZWN0IGRlZmluaW5nIGxhYmVscyBmb3IgdXNpbmcge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX0ve3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvZ290b0FuZFN0b3BcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9zZXRMYWJlbHNcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBUaGUgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIHRvIGFwcGx5IHRvIHRoaXMgdHdlZW4gaW5zdGFuY2UgKGV4LiBge2xvb3A6dHJ1ZX1gKS4gQWxsIHByb3BlcnRpZXNcblx0ICogZGVmYXVsdCB0byBmYWxzZS4gU3VwcG9ydGVkIHByb3BzIGFyZTo8VUw+XG5cdCAqICAgIDxMST4gbG9vcDogc2V0cyB0aGUgbG9vcCBwcm9wZXJ0eSBvbiB0aGlzIHR3ZWVuLjwvTEk+XG5cdCAqICAgIDxMST4gdXNlVGlja3M6IHVzZXMgdGlja3MgZm9yIGFsbCBkdXJhdGlvbnMgaW5zdGVhZCBvZiBtaWxsaXNlY29uZHMuPC9MST5cblx0ICogICAgPExJPiBpZ25vcmVHbG9iYWxQYXVzZTogc2V0cyB0aGUgaWdub3JlR2xvYmFsUGF1c2UgcHJvcGVydHkgb24gdGhpcyB0d2Vlbi48L0xJPlxuXHQgKiAgICA8TEk+IHBhdXNlZDogaW5kaWNhdGVzIHdoZXRoZXIgdG8gc3RhcnQgdGhlIHR3ZWVuIHBhdXNlZC48L0xJPlxuXHQgKiAgICA8TEk+IHBvc2l0aW9uOiBpbmRpY2F0ZXMgdGhlIGluaXRpYWwgcG9zaXRpb24gZm9yIHRoaXMgdGltZWxpbmUuPC9MST5cblx0ICogICAgPExJPiBvbkNoYW5nZTogc3BlY2lmaWVzIGEgbGlzdGVuZXIgdG8gYWRkIGZvciB0aGUge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvY2hhbmdlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50LjwvTEk+XG5cdCAqIDwvVUw+XG5cdCAqIEBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBUaW1lbGluZSh0d2VlbnMsIGxhYmVscywgcHJvcHMpIHtcblx0XHR0aGlzLkV2ZW50RGlzcGF0Y2hlcl9jb25zdHJ1Y3RvcigpO1xuXG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIENhdXNlcyB0aGlzIHRpbWVsaW5lIHRvIGNvbnRpbnVlIHBsYXlpbmcgd2hlbiBhIGdsb2JhbCBwYXVzZSBpcyBhY3RpdmUuXG5cdFx0ICogQHByb3BlcnR5IGlnbm9yZUdsb2JhbFBhdXNlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqKi9cblx0XHR0aGlzLmlnbm9yZUdsb2JhbFBhdXNlID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdG90YWwgZHVyYXRpb24gb2YgdGhpcyB0aW1lbGluZSBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrcyBgaXMgYHRydWVgKS4gVGhpcyB2YWx1ZSBpcyB1c3VhbGx5XG5cdFx0ICogYXV0b21hdGljYWxseSB1cGRhdGVkIGFzIHlvdSBtb2RpZnkgdGhlIHRpbWVsaW5lLiBTZWUge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvdXBkYXRlRHVyYXRpb25cIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgZHVyYXRpb25cblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMuZHVyYXRpb24gPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogSWYgdHJ1ZSwgdGhlIHRpbWVsaW5lIHdpbGwgbG9vcCB3aGVuIGl0IHJlYWNoZXMgdGhlIGVuZC4gQ2FuIGJlIHNldCB2aWEgdGhlIHByb3BzIHBhcmFtLlxuXHRcdCAqIEBwcm9wZXJ0eSBsb29wXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqKi9cblx0XHR0aGlzLmxvb3AgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IG5vcm1hbGl6ZWQgcG9zaXRpb24gb2YgdGhlIHRpbWVsaW5lLiBUaGlzIHdpbGwgYWx3YXlzIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZFxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2R1cmF0aW9uOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIENoYW5naW5nIHRoaXMgcHJvcGVydHkgZGlyZWN0bHkgd2lsbCBoYXZlIG5vIGVmZmVjdC5cblx0XHQgKiBAcHJvcGVydHkgcG9zaXRpb25cblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5wb3NpdGlvbiA9IG51bGw7XG5cblx0XHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9wYXVzZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfdHdlZW5zXG5cdFx0ICogQHR5cGUgQXJyYXlbVHdlZW5dXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl90d2VlbnMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbGFiZWxzXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9sYWJlbHMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9sYWJlbExpc3Rcblx0XHQgKiBAdHlwZSBBcnJheVtPYmplY3RdXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9sYWJlbExpc3QgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9wcmV2UG9zaXRpb25cblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9wcmV2UG9zaXRpb24gPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9wcmV2UG9zXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgLTFcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3ByZXZQb3MgPSAtMTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfdXNlVGlja3Ncblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3VzZVRpY2tzID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRpbWVsaW5lIGlzIGN1cnJlbnRseSByZWdpc3RlcmVkIHdpdGggVHdlZW4uXG5cdFx0ICogQHByb3BlcnR5IF9yZWdpc3RlcmVkXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fcmVnaXN0ZXJlZCA9IGZhbHNlO1xuXG5cblx0XHRpZiAocHJvcHMpIHtcblx0XHRcdHRoaXMuX3VzZVRpY2tzID0gcHJvcHMudXNlVGlja3M7XG5cdFx0XHR0aGlzLmxvb3AgPSBwcm9wcy5sb29wO1xuXHRcdFx0dGhpcy5pZ25vcmVHbG9iYWxQYXVzZSA9IHByb3BzLmlnbm9yZUdsb2JhbFBhdXNlO1xuXHRcdFx0cHJvcHMub25DaGFuZ2UmJnRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBwcm9wcy5vbkNoYW5nZSk7XG5cdFx0fVxuXHRcdGlmICh0d2VlbnMpIHsgdGhpcy5hZGRUd2Vlbi5hcHBseSh0aGlzLCB0d2VlbnMpOyB9XG5cdFx0dGhpcy5zZXRMYWJlbHMobGFiZWxzKTtcblx0XHRpZiAocHJvcHMmJnByb3BzLnBhdXNlZCkgeyB0aGlzLl9wYXVzZWQ9dHJ1ZTsgfVxuXHRcdGVsc2UgeyBjcmVhdGVqcy5Ud2Vlbi5fcmVnaXN0ZXIodGhpcyx0cnVlKTsgfVxuXHRcdGlmIChwcm9wcyYmcHJvcHMucG9zaXRpb24hPW51bGwpIHsgdGhpcy5zZXRQb3NpdGlvbihwcm9wcy5wb3NpdGlvbiwgY3JlYXRlanMuVHdlZW4uTk9ORSk7IH1cblx0XHRcblx0fTtcblx0XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFRpbWVsaW5lLCBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cdFxuLy8gZXZlbnRzOlxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW5ldmVyIHRoZSB0aW1lbGluZSdzIHBvc2l0aW9uIGNoYW5nZXMuXG5cdCAqIEBldmVudCBjaGFuZ2Vcblx0ICogQHNpbmNlIDAuNS4wXG5cdCAqKi9cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEFkZHMgb25lIG9yIG1vcmUgdHdlZW5zIChvciB0aW1lbGluZXMpIHRvIHRoaXMgdGltZWxpbmUuIFRoZSB0d2VlbnMgd2lsbCBiZSBwYXVzZWQgKHRvIHJlbW92ZSB0aGVtIGZyb20gdGhlXG5cdCAqIG5vcm1hbCB0aWNraW5nIHN5c3RlbSkgYW5kIG1hbmFnZWQgYnkgdGhpcyB0aW1lbGluZS4gQWRkaW5nIGEgdHdlZW4gdG8gbXVsdGlwbGUgdGltZWxpbmVzIHdpbGwgcmVzdWx0IGluXG5cdCAqIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLlxuXHQgKiBAbWV0aG9kIGFkZFR3ZWVuXG5cdCAqIEBwYXJhbSB7VHdlZW59IC4uLnR3ZWVuIFRoZSB0d2VlbihzKSB0byBhZGQuIEFjY2VwdHMgbXVsdGlwbGUgYXJndW1lbnRzLlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhlIGZpcnN0IHR3ZWVuIHRoYXQgd2FzIHBhc3NlZCBpbi5cblx0ICoqL1xuXHRwLmFkZFR3ZWVuID0gZnVuY3Rpb24odHdlZW4pIHtcblx0XHR2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0aWYgKGwgPiAxKSB7XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7IHRoaXMuYWRkVHdlZW4oYXJndW1lbnRzW2ldKTsgfVxuXHRcdFx0cmV0dXJuIGFyZ3VtZW50c1swXTtcblx0XHR9IGVsc2UgaWYgKGwgPT0gMCkgeyByZXR1cm4gbnVsbDsgfVxuXHRcdHRoaXMucmVtb3ZlVHdlZW4odHdlZW4pO1xuXHRcdHRoaXMuX3R3ZWVucy5wdXNoKHR3ZWVuKTtcblx0XHR0d2Vlbi5zZXRQYXVzZWQodHJ1ZSk7XG5cdFx0dHdlZW4uX3BhdXNlZCA9IGZhbHNlO1xuXHRcdHR3ZWVuLl91c2VUaWNrcyA9IHRoaXMuX3VzZVRpY2tzO1xuXHRcdGlmICh0d2Vlbi5kdXJhdGlvbiA+IHRoaXMuZHVyYXRpb24pIHsgdGhpcy5kdXJhdGlvbiA9IHR3ZWVuLmR1cmF0aW9uOyB9XG5cdFx0aWYgKHRoaXMuX3ByZXZQb3MgPj0gMCkgeyB0d2Vlbi5zZXRQb3NpdGlvbih0aGlzLl9wcmV2UG9zLCBjcmVhdGVqcy5Ud2Vlbi5OT05FKTsgfVxuXHRcdHJldHVybiB0d2Vlbjtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBvbmUgb3IgbW9yZSB0d2VlbnMgZnJvbSB0aGlzIHRpbWVsaW5lLlxuXHQgKiBAbWV0aG9kIHJlbW92ZVR3ZWVuXG5cdCAqIEBwYXJhbSB7VHdlZW59IC4uLnR3ZWVuIFRoZSB0d2VlbihzKSB0byByZW1vdmUuIEFjY2VwdHMgbXVsdGlwbGUgYXJndW1lbnRzLlxuXHQgKiBAcmV0dXJuIEJvb2xlYW4gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIG9mIHRoZSB0d2VlbnMgd2VyZSBzdWNjZXNzZnVsbHkgcmVtb3ZlZC5cblx0ICoqL1xuXHRwLnJlbW92ZVR3ZWVuID0gZnVuY3Rpb24odHdlZW4pIHtcblx0XHR2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0aWYgKGwgPiAxKSB7XG5cdFx0XHR2YXIgZ29vZCA9IHRydWU7XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7IGdvb2QgPSBnb29kICYmIHRoaXMucmVtb3ZlVHdlZW4oYXJndW1lbnRzW2ldKTsgfVxuXHRcdFx0cmV0dXJuIGdvb2Q7XG5cdFx0fSBlbHNlIGlmIChsID09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHR2YXIgdHdlZW5zID0gdGhpcy5fdHdlZW5zO1xuXHRcdHZhciBpID0gdHdlZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRpZiAodHdlZW5zW2ldID09IHR3ZWVuKSB7XG5cdFx0XHRcdHR3ZWVucy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdGlmICh0d2Vlbi5kdXJhdGlvbiA+PSB0aGlzLmR1cmF0aW9uKSB7IHRoaXMudXBkYXRlRHVyYXRpb24oKTsgfVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGRzIGEgbGFiZWwgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319L3t7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGFkZExhYmVsXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBUaGUgbGFiZWwgbmFtZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0aGlzIGxhYmVsIHJlcHJlc2VudHMuXG5cdCAqKi9cblx0cC5hZGRMYWJlbCA9IGZ1bmN0aW9uKGxhYmVsLCBwb3NpdGlvbikge1xuXHRcdHRoaXMuX2xhYmVsc1tsYWJlbF0gPSBwb3NpdGlvbjtcblx0XHR2YXIgbGlzdCA9IHRoaXMuX2xhYmVsTGlzdDtcblx0XHRpZiAobGlzdCkge1xuXHRcdFx0Zm9yICh2YXIgaT0gMCxsPWxpc3QubGVuZ3RoOyBpPGw7IGkrKykgeyBpZiAocG9zaXRpb24gPCBsaXN0W2ldLnBvc2l0aW9uKSB7IGJyZWFrOyB9IH1cblx0XHRcdGxpc3Quc3BsaWNlKGksIDAsIHtsYWJlbDpsYWJlbCwgcG9zaXRpb246cG9zaXRpb259KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIERlZmluZXMgbGFiZWxzIGZvciB1c2Ugd2l0aCBnb3RvQW5kUGxheS9TdG9wLiBPdmVyd3JpdGVzIGFueSBwcmV2aW91c2x5IHNldCBsYWJlbHMuXG5cdCAqIEBtZXRob2Qgc2V0TGFiZWxzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvIEFuIG9iamVjdCBkZWZpbmluZyBsYWJlbHMgZm9yIHVzaW5nIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319L3t7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGluIHRoZSBmb3JtIGB7bGFiZWxOYW1lOnRpbWV9YCB3aGVyZSB0aW1lIGlzIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzYCBpcyBgdHJ1ZWApLlxuXHQgKiovXG5cdHAuc2V0TGFiZWxzID0gZnVuY3Rpb24obykge1xuXHRcdHRoaXMuX2xhYmVscyA9IG8gPyAgbyA6IHt9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGxhYmVscyBkZWZpbmVkIG9uIHRoaXMgdGltZWxpbmUuXG5cdCAqIEBtZXRob2QgZ2V0TGFiZWxzXG5cdCAqIEByZXR1cm4ge0FycmF5W09iamVjdF19IEEgc29ydGVkIGFycmF5IG9mIG9iamVjdHMgd2l0aCBsYWJlbCBhbmQgcG9zaXRpb24gcHJvcGVydGllcy5cblx0ICoqL1xuXHRwLmdldExhYmVscyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsaXN0ID0gdGhpcy5fbGFiZWxMaXN0O1xuXHRcdGlmICghbGlzdCkge1xuXHRcdFx0bGlzdCA9IHRoaXMuX2xhYmVsTGlzdCA9IFtdO1xuXHRcdFx0dmFyIGxhYmVscyA9IHRoaXMuX2xhYmVscztcblx0XHRcdGZvciAodmFyIG4gaW4gbGFiZWxzKSB7XG5cdFx0XHRcdGxpc3QucHVzaCh7bGFiZWw6biwgcG9zaXRpb246bGFiZWxzW25dfSk7XG5cdFx0XHR9XG5cdFx0XHRsaXN0LnNvcnQoZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYS5wb3NpdGlvbi0gYi5wb3NpdGlvbjsgfSk7XG5cdFx0fVxuXHRcdHJldHVybiBsaXN0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBsYWJlbCBvbiBvciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGN1cnJlbnQgcG9zaXRpb24uIEZvciBleGFtcGxlLCBnaXZlbiBhIHRpbWVsaW5lIHdpdGhcblx0ICogdHdvIGxhYmVscywgXCJmaXJzdFwiIG9uIGZyYW1lIGluZGV4IDQsIGFuZCBcInNlY29uZFwiIG9uIGZyYW1lIDgsIGdldEN1cnJlbnRMYWJlbCB3b3VsZCByZXR1cm46XG5cdCAqIDxVTD5cblx0ICogXHRcdDxMST5udWxsIGlmIHRoZSBjdXJyZW50IHBvc2l0aW9uIGlzIDIuPC9MST5cblx0ICogXHRcdDxMST5cImZpcnN0XCIgaWYgdGhlIGN1cnJlbnQgcG9zaXRpb24gaXMgNC48L0xJPlxuXHQgKiBcdFx0PExJPlwiZmlyc3RcIiBpZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpcyA3LjwvTEk+XG5cdCAqIFx0XHQ8TEk+XCJzZWNvbmRcIiBpZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpcyAxNS48L0xJPlxuXHQgKiA8L1VMPlxuXHQgKiBAbWV0aG9kIGdldEN1cnJlbnRMYWJlbFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGxhYmVsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gbGFiZWxcblx0ICoqL1xuXHRwLmdldEN1cnJlbnRMYWJlbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuXHRcdHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uO1xuXHRcdHZhciBsID0gbGFiZWxzLmxlbmd0aDtcblx0XHRpZiAobCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGk8bDsgaSsrKSB7IGlmIChwb3MgPCBsYWJlbHNbaV0ucG9zaXRpb24pIHsgYnJlYWs7IH0gfVxuXHRcdFx0cmV0dXJuIChpPT0wKSA/IG51bGwgOiBsYWJlbHNbaS0xXS5sYWJlbDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVucGF1c2VzIHRoaXMgdGltZWxpbmUgYW5kIGp1bXBzIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gb3IgbGFiZWwuXG5cdCAqIEBtZXRob2QgZ290b0FuZFBsYXlcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBwb3NpdGlvbk9yTGFiZWwgVGhlIHBvc2l0aW9uIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzYCBpcyBgdHJ1ZWApXG5cdCAqIG9yIGxhYmVsIHRvIGp1bXAgdG8uXG5cdCAqKi9cblx0cC5nb3RvQW5kUGxheSA9IGZ1bmN0aW9uKHBvc2l0aW9uT3JMYWJlbCkge1xuXHRcdHRoaXMuc2V0UGF1c2VkKGZhbHNlKTtcblx0XHR0aGlzLl9nb3RvKHBvc2l0aW9uT3JMYWJlbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhdXNlcyB0aGlzIHRpbWVsaW5lIGFuZCBqdW1wcyB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIG9yIGxhYmVsLlxuXHQgKiBAbWV0aG9kIGdvdG9BbmRTdG9wXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gcG9zaXRpb25PckxhYmVsIFRoZSBwb3NpdGlvbiBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgYHRydWVgKSBvciBsYWJlbFxuXHQgKiB0byBqdW1wIHRvLlxuXHQgKiovXG5cdHAuZ290b0FuZFN0b3AgPSBmdW5jdGlvbihwb3NpdGlvbk9yTGFiZWwpIHtcblx0XHR0aGlzLnNldFBhdXNlZCh0cnVlKTtcblx0XHR0aGlzLl9nb3RvKHBvc2l0aW9uT3JMYWJlbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoZSB0aW1lbGluZSB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuXHQgKiBAbWV0aG9kIHNldFBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgcG9zaXRpb24gdG8gc2VlayB0byBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgYHRydWVgKS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthY3Rpb25zTW9kZV0gcGFyYW1ldGVyIHNwZWNpZnlpbmcgaG93IGFjdGlvbnMgYXJlIGhhbmRsZWQuIFNlZSB0aGUgVHdlZW4ge3sjY3Jvc3NMaW5rIFwiVHdlZW4vc2V0UG9zaXRpb25cIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kIGZvciBtb3JlIGRldGFpbHMuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB0aW1lbGluZSBpcyBjb21wbGV0ZSAoaWUuIHRoZSBmdWxsIHRpbWVsaW5lIGhhcyBydW4gJiB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9sb29wOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGlzIGBmYWxzZWApLlxuXHQgKiovXG5cdHAuc2V0UG9zaXRpb24gPSBmdW5jdGlvbih2YWx1ZSwgYWN0aW9uc01vZGUpIHtcblx0XHR2YXIgdCA9IHRoaXMuX2NhbGNQb3NpdGlvbih2YWx1ZSk7XG5cdFx0dmFyIGVuZCA9ICF0aGlzLmxvb3AgJiYgdmFsdWUgPj0gdGhpcy5kdXJhdGlvbjtcblx0XHRpZiAodCA9PSB0aGlzLl9wcmV2UG9zKSB7IHJldHVybiBlbmQ7IH1cblx0XHR0aGlzLl9wcmV2UG9zaXRpb24gPSB2YWx1ZTtcblx0XHR0aGlzLnBvc2l0aW9uID0gdGhpcy5fcHJldlBvcyA9IHQ7IC8vIGluIGNhc2UgYW4gYWN0aW9uIGNoYW5nZXMgdGhlIGN1cnJlbnQgZnJhbWUuXG5cdFx0Zm9yICh2YXIgaT0wLCBsPXRoaXMuX3R3ZWVucy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR0aGlzLl90d2VlbnNbaV0uc2V0UG9zaXRpb24odCwgYWN0aW9uc01vZGUpO1xuXHRcdFx0aWYgKHQgIT0gdGhpcy5fcHJldlBvcykgeyByZXR1cm4gZmFsc2U7IH0gLy8gYW4gYWN0aW9uIGNoYW5nZWQgdGhpcyB0aW1lbGluZSdzIHBvc2l0aW9uLlxuXHRcdH1cblx0XHRpZiAoZW5kKSB7IHRoaXMuc2V0UGF1c2VkKHRydWUpOyB9XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiY2hhbmdlXCIpO1xuXHRcdHJldHVybiBlbmQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhdXNlcyBvciBwbGF5cyB0aGlzIHRpbWVsaW5lLlxuXHQgKiBAbWV0aG9kIHNldFBhdXNlZFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0d2VlbiBzaG91bGQgYmUgcGF1c2VkIChgdHJ1ZWApIG9yIHBsYXllZCAoYGZhbHNlYCkuXG5cdCAqKi9cblx0cC5zZXRQYXVzZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHRoaXMuX3BhdXNlZCA9ICEhdmFsdWU7IFxuXHRcdGNyZWF0ZWpzLlR3ZWVuLl9yZWdpc3Rlcih0aGlzLCAhdmFsdWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZWNhbGN1bGF0ZXMgdGhlIGR1cmF0aW9uIG9mIHRoZSB0aW1lbGluZS4gVGhlIGR1cmF0aW9uIGlzIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCB3aGVuIHR3ZWVucyBhcmUgYWRkZWQgb3IgcmVtb3ZlZCxcblx0ICogYnV0IHRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBpZiB5b3UgbW9kaWZ5IGEgdHdlZW4gYWZ0ZXIgaXQgd2FzIGFkZGVkIHRvIHRoZSB0aW1lbGluZS5cblx0ICogQG1ldGhvZCB1cGRhdGVEdXJhdGlvblxuXHQgKiovXG5cdHAudXBkYXRlRHVyYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmR1cmF0aW9uID0gMDtcblx0XHRmb3IgKHZhciBpPTAsbD10aGlzLl90d2VlbnMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fdHdlZW5zW2ldO1xuXHRcdFx0aWYgKHR3ZWVuLmR1cmF0aW9uID4gdGhpcy5kdXJhdGlvbikgeyB0aGlzLmR1cmF0aW9uID0gdHdlZW4uZHVyYXRpb247IH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoaXMgdGltZWxpbmUgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZSBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgYHRydWVgKS5cblx0ICogVGhpcyBpcyBub3JtYWxseSBjYWxsZWQgYXV0b21hdGljYWxseSBieSB0aGUgVHdlZW4gZW5naW5lICh2aWEgdGhlIHt7I2Nyb3NzTGluayBcIlR3ZWVuL3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQpLCBidXQgaXMgZXhwb3NlZCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCB0aWNrXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YSBUaGUgdGltZSB0byBhZHZhbmNlIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgdXNlVGlja3MgaXMgdHJ1ZSkuXG5cdCAqKi9cblx0cC50aWNrID0gZnVuY3Rpb24oZGVsdGEpIHtcblx0XHR0aGlzLnNldFBvc2l0aW9uKHRoaXMuX3ByZXZQb3NpdGlvbitkZWx0YSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIElmIGEgbnVtZXJpYyBwb3NpdGlvbiBpcyBwYXNzZWQsIGl0IGlzIHJldHVybmVkIHVuY2hhbmdlZC4gSWYgYSBzdHJpbmcgaXMgcGFzc2VkLCB0aGUgcG9zaXRpb24gb2YgdGhlXG5cdCAqIGNvcnJlc3BvbmRpbmcgZnJhbWUgbGFiZWwgd2lsbCBiZSByZXR1cm5lZCwgb3IgYG51bGxgIGlmIGEgbWF0Y2hpbmcgbGFiZWwgaXMgbm90IGRlZmluZWQuXG5cdCAqIEBtZXRob2QgcmVzb2x2ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHBvc2l0aW9uT3JMYWJlbCBBIG51bWVyaWMgcG9zaXRpb24gdmFsdWUgb3IgbGFiZWwgc3RyaW5nLlxuXHQgKiovXG5cdHAucmVzb2x2ZSA9IGZ1bmN0aW9uKHBvc2l0aW9uT3JMYWJlbCkge1xuXHRcdHZhciBwb3MgPSBOdW1iZXIocG9zaXRpb25PckxhYmVsKTtcblx0XHRpZiAoaXNOYU4ocG9zKSkgeyBwb3MgPSB0aGlzLl9sYWJlbHNbcG9zaXRpb25PckxhYmVsXTsgfVxuXHRcdHJldHVybiBwb3M7XG5cdH07XG5cblx0LyoqXG5cdCogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0KiBAbWV0aG9kIHRvU3RyaW5nXG5cdCogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1RpbWVsaW5lXVwiO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3coXCJUaW1lbGluZSBjYW4gbm90IGJlIGNsb25lZC5cIilcblx0fTtcblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfZ290b1xuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gcG9zaXRpb25PckxhYmVsXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nb3RvID0gZnVuY3Rpb24ocG9zaXRpb25PckxhYmVsKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMucmVzb2x2ZShwb3NpdGlvbk9yTGFiZWwpO1xuXHRcdGlmIChwb3MgIT0gbnVsbCkgeyB0aGlzLnNldFBvc2l0aW9uKHBvcyk7IH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9jYWxjUG9zaXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2NhbGNQb3NpdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlIDwgMCkgeyByZXR1cm4gMDsgfVxuXHRcdGlmICh2YWx1ZSA8IHRoaXMuZHVyYXRpb24pIHsgcmV0dXJuIHZhbHVlOyB9XG5cdFx0cmV0dXJuIHRoaXMubG9vcCA/IHZhbHVlJXRoaXMuZHVyYXRpb24gOiB0aGlzLmR1cmF0aW9uO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLlRpbWVsaW5lID0gY3JlYXRlanMucHJvbW90ZShUaW1lbGluZSwgXCJFdmVudERpc3BhdGNoZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBFYXNlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIFRoZSBFYXNlIGNsYXNzIHByb3ZpZGVzIGEgY29sbGVjdGlvbiBvZiBlYXNpbmcgZnVuY3Rpb25zIGZvciB1c2Ugd2l0aCBUd2VlbkpTLiBJdCBkb2VzIG5vdCB1c2UgdGhlIHN0YW5kYXJkIDQgcGFyYW1cblx0ICogZWFzaW5nIHNpZ25hdHVyZS4gSW5zdGVhZCBpdCB1c2VzIGEgc2luZ2xlIHBhcmFtIHdoaWNoIGluZGljYXRlcyB0aGUgY3VycmVudCBsaW5lYXIgcmF0aW8gKDAgdG8gMSkgb2YgdGhlIHR3ZWVuLlxuXHQgKlxuXHQgKiBNb3N0IG1ldGhvZHMgb24gRWFzZSBjYW4gYmUgcGFzc2VkIGRpcmVjdGx5IGFzIGVhc2luZyBmdW5jdGlvbnM6XG5cdCAqXG5cdCAqICAgICAgVHdlZW4uZ2V0KHRhcmdldCkudG8oe3g6MTAwfSwgNTAwLCBFYXNlLmxpbmVhcik7XG5cdCAqXG5cdCAqIEhvd2V2ZXIsIG1ldGhvZHMgYmVnaW5uaW5nIHdpdGggXCJnZXRcIiB3aWxsIHJldHVybiBhbiBlYXNpbmcgZnVuY3Rpb24gYmFzZWQgb24gcGFyYW1ldGVyIHZhbHVlczpcblx0ICpcblx0ICogICAgICBUd2Vlbi5nZXQodGFyZ2V0KS50byh7eToyMDB9LCA1MDAsIEVhc2UuZ2V0UG93SW4oMi4yKSk7XG5cdCAqXG5cdCAqIFBsZWFzZSBzZWUgdGhlIDxhIGhyZWY9XCJodHRwOi8vd3d3LmNyZWF0ZWpzLmNvbS9EZW1vcy9Ud2VlbkpTL1R3ZWVuX1NwYXJrVGFibGVcIj5zcGFyayB0YWJsZSBkZW1vPC9hPiBmb3IgYW5cblx0ICogb3ZlcnZpZXcgb2YgdGhlIGRpZmZlcmVudCBlYXNlIHR5cGVzIG9uIDxhIGhyZWY9XCJodHRwOi8vdHdlZW5qcy5jb21cIj5Ud2VlbkpTLmNvbTwvYT4uXG5cdCAqXG5cdCAqIDxlbT5FcXVhdGlvbnMgZGVyaXZlZCBmcm9tIHdvcmsgYnkgUm9iZXJ0IFBlbm5lci48L2VtPlxuXHQgKiBAY2xhc3MgRWFzZVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0ZnVuY3Rpb24gRWFzZSgpIHtcblx0XHR0aHJvdyBcIkVhc2UgY2Fubm90IGJlIGluc3RhbnRpYXRlZC5cIjtcblx0fVxuXG5cbi8vIHN0YXRpYyBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGxpbmVhclxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmxpbmVhciA9IGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHQ7IH07XG5cblx0LyoqXG5cdCAqIElkZW50aWNhbCB0byBsaW5lYXIuXG5cdCAqIEBtZXRob2Qgbm9uZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLm5vbmUgPSBFYXNlLmxpbmVhcjtcblxuXHQvKipcblx0ICogTWltaWNzIHRoZSBzaW1wbGUgLTEwMCB0byAxMDAgZWFzaW5nIGluIEZsYXNoIFByby5cblx0ICogQG1ldGhvZCBnZXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCBBIHZhbHVlIGZyb20gLTEgKGVhc2UgaW4pIHRvIDEgKGVhc2Ugb3V0KSBpbmRpY2F0aW5nIHRoZSBzdHJlbmd0aCBhbmQgZGlyZWN0aW9uIG9mIHRoZSBlYXNlLlxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0ID0gZnVuY3Rpb24oYW1vdW50KSB7XG5cdFx0aWYgKGFtb3VudCA8IC0xKSB7IGFtb3VudCA9IC0xOyB9XG5cdFx0aWYgKGFtb3VudCA+IDEpIHsgYW1vdW50ID0gMTsgfVxuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRpZiAoYW1vdW50PT0wKSB7IHJldHVybiB0OyB9XG5cdFx0XHRpZiAoYW1vdW50PDApIHsgcmV0dXJuIHQqKHQqLWFtb3VudCsxK2Ftb3VudCk7IH1cblx0XHRcdHJldHVybiB0KigoMi10KSphbW91bnQrKDEtYW1vdW50KSk7XG5cdFx0fTtcblx0fTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIGV4cG9uZW50aWFsIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0UG93SW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvdyBUaGUgZXhwb25lbnQgdG8gdXNlIChleC4gMyB3b3VsZCByZXR1cm4gYSBjdWJpYyBlYXNlKS5cblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldFBvd0luID0gZnVuY3Rpb24ocG93KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiBNYXRoLnBvdyh0LHBvdyk7XG5cdFx0fTtcblx0fTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIGV4cG9uZW50aWFsIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0UG93T3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3cgVGhlIGV4cG9uZW50IHRvIHVzZSAoZXguIDMgd291bGQgcmV0dXJuIGEgY3ViaWMgZWFzZSkuXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRQb3dPdXQgPSBmdW5jdGlvbihwb3cpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0cmV0dXJuIDEtTWF0aC5wb3coMS10LHBvdyk7XG5cdFx0fTtcblx0fTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIGV4cG9uZW50aWFsIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0UG93SW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvdyBUaGUgZXhwb25lbnQgdG8gdXNlIChleC4gMyB3b3VsZCByZXR1cm4gYSBjdWJpYyBlYXNlKS5cblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldFBvd0luT3V0ID0gZnVuY3Rpb24ocG93KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdGlmICgodCo9Mik8MSkgcmV0dXJuIDAuNSpNYXRoLnBvdyh0LHBvdyk7XG5cdFx0XHRyZXR1cm4gMS0wLjUqTWF0aC5hYnMoTWF0aC5wb3coMi10LHBvdykpO1xuXHRcdH07XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgcXVhZEluXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVhZEluID0gRWFzZS5nZXRQb3dJbigyKTtcblx0LyoqXG5cdCAqIEBtZXRob2QgcXVhZE91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1YWRPdXQgPSBFYXNlLmdldFBvd091dCgyKTtcblx0LyoqXG5cdCAqIEBtZXRob2QgcXVhZEluT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVhZEluT3V0ID0gRWFzZS5nZXRQb3dJbk91dCgyKTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBjdWJpY0luXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuY3ViaWNJbiA9IEVhc2UuZ2V0UG93SW4oMyk7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGN1YmljT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuY3ViaWNPdXQgPSBFYXNlLmdldFBvd091dCgzKTtcblx0LyoqXG5cdCAqIEBtZXRob2QgY3ViaWNJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmN1YmljSW5PdXQgPSBFYXNlLmdldFBvd0luT3V0KDMpO1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1YXJ0SW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWFydEluID0gRWFzZS5nZXRQb3dJbig0KTtcblx0LyoqXG5cdCAqIEBtZXRob2QgcXVhcnRPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWFydE91dCA9IEVhc2UuZ2V0UG93T3V0KDQpO1xuXHQvKipcblx0ICogQG1ldGhvZCBxdWFydEluT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVhcnRJbk91dCA9IEVhc2UuZ2V0UG93SW5PdXQoNCk7XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgcXVpbnRJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1aW50SW4gPSBFYXNlLmdldFBvd0luKDUpO1xuXHQvKipcblx0ICogQG1ldGhvZCBxdWludE91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1aW50T3V0ID0gRWFzZS5nZXRQb3dPdXQoNSk7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1aW50SW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWludEluT3V0ID0gRWFzZS5nZXRQb3dJbk91dCg1KTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBzaW5lSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5zaW5lSW4gPSBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIDEtTWF0aC5jb3ModCpNYXRoLlBJLzIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHNpbmVPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5zaW5lT3V0ID0gZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiBNYXRoLnNpbih0Kk1hdGguUEkvMik7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2Qgc2luZUluT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2Uuc2luZUluT3V0ID0gZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtMC41KihNYXRoLmNvcyhNYXRoLlBJKnQpIC0gMSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBcImJhY2sgaW5cIiBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldEJhY2tJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IFRoZSBzdHJlbmd0aCBvZiB0aGUgZWFzZS5cblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldEJhY2tJbiA9IGZ1bmN0aW9uKGFtb3VudCkge1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRyZXR1cm4gdCp0KigoYW1vdW50KzEpKnQtYW1vdW50KTtcblx0XHR9O1xuXHR9O1xuXHQvKipcblx0ICogQG1ldGhvZCBiYWNrSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5iYWNrSW4gPSBFYXNlLmdldEJhY2tJbigxLjcpO1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgXCJiYWNrIG91dFwiIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0QmFja091dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IFRoZSBzdHJlbmd0aCBvZiB0aGUgZWFzZS5cblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldEJhY2tPdXQgPSBmdW5jdGlvbihhbW91bnQpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0cmV0dXJuICgtLXQqdCooKGFtb3VudCsxKSp0ICsgYW1vdW50KSArIDEpO1xuXHRcdH07XG5cdH07XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGJhY2tPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5iYWNrT3V0ID0gRWFzZS5nZXRCYWNrT3V0KDEuNyk7XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBcImJhY2sgaW4gb3V0XCIgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRCYWNrSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCBUaGUgc3RyZW5ndGggb2YgdGhlIGVhc2UuXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRCYWNrSW5PdXQgPSBmdW5jdGlvbihhbW91bnQpIHtcblx0XHRhbW91bnQqPTEuNTI1O1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRpZiAoKHQqPTIpPDEpIHJldHVybiAwLjUqKHQqdCooKGFtb3VudCsxKSp0LWFtb3VudCkpO1xuXHRcdFx0cmV0dXJuIDAuNSooKHQtPTIpKnQqKChhbW91bnQrMSkqdCthbW91bnQpKzIpO1xuXHRcdH07XG5cdH07XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGJhY2tJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmJhY2tJbk91dCA9IEVhc2UuZ2V0QmFja0luT3V0KDEuNyk7XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgY2lyY0luXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuY2lyY0luID0gZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtKE1hdGguc3FydCgxLXQqdCktIDEpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGNpcmNPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5jaXJjT3V0ID0gZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiBNYXRoLnNxcnQoMS0oLS10KSp0KTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBjaXJjSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5jaXJjSW5PdXQgPSBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKCh0Kj0yKSA8IDEpIHJldHVybiAtMC41KihNYXRoLnNxcnQoMS10KnQpLTEpO1xuXHRcdHJldHVybiAwLjUqKE1hdGguc3FydCgxLSh0LT0yKSp0KSsxKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBib3VuY2VJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmJvdW5jZUluID0gZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAxLUVhc2UuYm91bmNlT3V0KDEtdCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgYm91bmNlT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuYm91bmNlT3V0ID0gZnVuY3Rpb24odCkge1xuXHRcdGlmICh0IDwgMS8yLjc1KSB7XG5cdFx0XHRyZXR1cm4gKDcuNTYyNSp0KnQpO1xuXHRcdH0gZWxzZSBpZiAodCA8IDIvMi43NSkge1xuXHRcdFx0cmV0dXJuICg3LjU2MjUqKHQtPTEuNS8yLjc1KSp0KzAuNzUpO1xuXHRcdH0gZWxzZSBpZiAodCA8IDIuNS8yLjc1KSB7XG5cdFx0XHRyZXR1cm4gKDcuNTYyNSoodC09Mi4yNS8yLjc1KSp0KzAuOTM3NSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAoNy41NjI1Kih0LT0yLjYyNS8yLjc1KSp0ICswLjk4NDM3NSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGJvdW5jZUluT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuYm91bmNlSW5PdXQgPSBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKHQ8MC41KSByZXR1cm4gRWFzZS5ib3VuY2VJbiAodCoyKSAqIC41O1xuXHRcdHJldHVybiBFYXNlLmJvdW5jZU91dCh0KjItMSkqMC41KzAuNTtcblx0fTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIGVsYXN0aWMgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRFbGFzdGljSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFtcGxpdHVkZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGVyaW9kXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRFbGFzdGljSW4gPSBmdW5jdGlvbihhbXBsaXR1ZGUscGVyaW9kKSB7XG5cdFx0dmFyIHBpMiA9IE1hdGguUEkqMjtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0aWYgKHQ9PTAgfHwgdD09MSkgcmV0dXJuIHQ7XG5cdFx0XHR2YXIgcyA9IHBlcmlvZC9waTIqTWF0aC5hc2luKDEvYW1wbGl0dWRlKTtcblx0XHRcdHJldHVybiAtKGFtcGxpdHVkZSpNYXRoLnBvdygyLDEwKih0LT0xKSkqTWF0aC5zaW4oKHQtcykqcGkyL3BlcmlvZCkpO1xuXHRcdH07XG5cdH07XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGVsYXN0aWNJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmVsYXN0aWNJbiA9IEVhc2UuZ2V0RWxhc3RpY0luKDEsMC4zKTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIGVsYXN0aWMgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRFbGFzdGljT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbXBsaXR1ZGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBlcmlvZFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0RWxhc3RpY091dCA9IGZ1bmN0aW9uKGFtcGxpdHVkZSxwZXJpb2QpIHtcblx0XHR2YXIgcGkyID0gTWF0aC5QSSoyO1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRpZiAodD09MCB8fCB0PT0xKSByZXR1cm4gdDtcblx0XHRcdHZhciBzID0gcGVyaW9kL3BpMiAqIE1hdGguYXNpbigxL2FtcGxpdHVkZSk7XG5cdFx0XHRyZXR1cm4gKGFtcGxpdHVkZSpNYXRoLnBvdygyLC0xMCp0KSpNYXRoLnNpbigodC1zKSpwaTIvcGVyaW9kICkrMSk7XG5cdFx0fTtcblx0fTtcblx0LyoqXG5cdCAqIEBtZXRob2QgZWxhc3RpY091dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmVsYXN0aWNPdXQgPSBFYXNlLmdldEVsYXN0aWNPdXQoMSwwLjMpO1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgZWxhc3RpYyBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldEVsYXN0aWNJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW1wbGl0dWRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwZXJpb2Rcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldEVsYXN0aWNJbk91dCA9IGZ1bmN0aW9uKGFtcGxpdHVkZSxwZXJpb2QpIHtcblx0XHR2YXIgcGkyID0gTWF0aC5QSSoyO1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHR2YXIgcyA9IHBlcmlvZC9waTIgKiBNYXRoLmFzaW4oMS9hbXBsaXR1ZGUpO1xuXHRcdFx0aWYgKCh0Kj0yKTwxKSByZXR1cm4gLTAuNSooYW1wbGl0dWRlKk1hdGgucG93KDIsMTAqKHQtPTEpKSpNYXRoLnNpbiggKHQtcykqcGkyL3BlcmlvZCApKTtcblx0XHRcdHJldHVybiBhbXBsaXR1ZGUqTWF0aC5wb3coMiwtMTAqKHQtPTEpKSpNYXRoLnNpbigodC1zKSpwaTIvcGVyaW9kKSowLjUrMTtcblx0XHR9O1xuXHR9O1xuXHQvKipcblx0ICogQG1ldGhvZCBlbGFzdGljSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5lbGFzdGljSW5PdXQgPSBFYXNlLmdldEVsYXN0aWNJbk91dCgxLDAuMyoxLjUpO1xuXG5cdGNyZWF0ZWpzLkVhc2UgPSBFYXNlO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gTW90aW9uR3VpZGVQbHVnaW4uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogQSBUd2VlbkpTIHBsdWdpbiBmb3Igd29ya2luZyB3aXRoIG1vdGlvbiBndWlkZXMuXG5cdCAqXG5cdCAqIFRvIHVzZSwgaW5zdGFsbCB0aGUgcGx1Z2luIGFmdGVyIFR3ZWVuSlMgaGFzIGxvYWRlZC4gTmV4dCB0d2VlbiB0aGUgJ2d1aWRlJyBwcm9wZXJ0eSB3aXRoIGFuIG9iamVjdCBhcyBkZXRhaWxlZCBiZWxvdy5cblx0ICpcblx0ICogICAgICAgY3JlYXRlanMuTW90aW9uR3VpZGVQbHVnaW4uaW5zdGFsbCgpO1xuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgLy8gVXNpbmcgYSBNb3Rpb24gR3VpZGVcblx0ICpcdCAgICBjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0KS50byh7Z3VpZGU6eyBwYXRoOlswLDAsIDAsMjAwLDIwMCwyMDAsIDIwMCwwLDAsMF0gfX0sNzAwMCk7XG5cdCAqXHQgICAgLy8gVmlzdWFsaXppbmcgdGhlIGxpbmVcblx0ICpcdCAgICBncmFwaGljcy5tb3ZlVG8oMCwwKS5jdXJ2ZVRvKDAsMjAwLDIwMCwyMDApLmN1cnZlVG8oMjAwLDAsMCwwKTtcblx0ICpcblx0ICogRWFjaCBwYXRoIG5lZWRzIHByZS1jb21wdXRhdGlvbiB0byBlbnN1cmUgdGhlcmUncyBmYXN0IHBlcmZvcm1hbmNlLiBCZWNhdXNlIG9mIHRoZSBwcmUtY29tcHV0YXRpb24gdGhlcmUncyBub1xuXHQgKiBidWlsdCBpbiBzdXBwb3J0IGZvciBwYXRoIGNoYW5nZXMgbWlkIHR3ZWVuLiBUaGVzZSBhcmUgdGhlIEd1aWRlIE9iamVjdCdzIHByb3BlcnRpZXM6PFVMPlxuXHQgKiAgICAgIDxMST4gcGF0aDogUmVxdWlyZWQsIEFycmF5IDogVGhlIHgveSBwb2ludHMgdXNlZCB0byBkcmF3IHRoZSBwYXRoIHdpdGggYSBtb3ZlVG8gYW5kIDEgdG8gbiBjdXJ2ZVRvIGNhbGxzLjwvTEk+XG5cdCAqICAgICAgPExJPiBzdGFydDogT3B0aW9uYWwsIDAtMSA6IEluaXRpYWwgcG9zaXRpb24sIGRlZmF1bHQgMCBleGNlcHQgZm9yIHdoZW4gY29udGludWluZyBhbG9uZyB0aGUgc2FtZSBwYXRoLjwvTEk+XG5cdCAqICAgICAgPExJPiBlbmQ6IE9wdGlvbmFsLCAwLTEgOiBGaW5hbCBwb3NpdGlvbiwgZGVmYXVsdCAxIGlmIG5vdCBzcGVjaWZpZWQuPC9MST5cblx0ICogICAgICA8TEk+IG9yaWVudDogT3B0aW9uYWwsIHN0cmluZyA6IFwiZml4ZWRcIi9cImF1dG9cIi9cImN3XCIvXCJjY3dcIjxVTD5cblx0ICpcdFx0XHRcdDxMST5cImZpeGVkXCIgZm9yY2VzIHRoZSBvYmplY3QgdG8gZmFjZSBkb3duIHRoZSBwYXRoIGFsbCBtb3ZlbWVudCAocmVsYXRpdmUgdG8gc3RhcnQgcm90YXRpb24pLDwvTEk+XG5cdCAqICAgICAgXHRcdDxMST5cImF1dG9cIiByb3RhdGVzIHRoZSBvYmplY3QgYWxvbmcgdGhlIHBhdGggcmVsYXRpdmUgdG8gdGhlIGxpbmUuPC9MST5cblx0ICogICAgICBcdFx0PExJPlwiY3dcIi9cImNjd1wiIGZvcmNlIGNsb2Nrd2lzZSBvciBjb3VudGVyIGNsb2Nrd2lzZSByb3RhdGlvbnMgaW5jbHVkaW5nIGZsYXNoIGxpa2UgYmVoYXZpb3VyPC9MST5cblx0ICogXHRcdDwvVUw+PC9MST5cblx0ICogPC9VTD5cblx0ICogR3VpZGUgb2JqZWN0cyBzaG91bGQgbm90IGJlIHNoYXJlZCBiZXR3ZWVuIHR3ZWVucyBldmVuIGlmIGFsbCBwcm9wZXJ0aWVzIGFyZSBpZGVudGljYWwsIHRoZSBsaWJyYXJ5IHN0b3Jlc1xuXHQgKiBpbmZvcm1hdGlvbiBvbiB0aGVzZSBvYmplY3RzIGluIHRoZSBiYWNrZ3JvdW5kIGFuZCBzaGFyaW5nIHRoZW0gY2FuIGNhdXNlIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLiBWYWx1ZXNcblx0ICogb3V0c2lkZSAwLTEgcmFuZ2Ugb2YgdHdlZW5zIHdpbGwgYmUgYSBcImJlc3QgZ3Vlc3NcIiBmcm9tIHRoZSBhcHByb3ByaWF0ZSBwYXJ0IG9mIHRoZSBkZWZpbmVkIGN1cnZlLlxuXHQgKlxuXHQgKiBAY2xhc3MgTW90aW9uR3VpZGVQbHVnaW5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gTW90aW9uR3VpZGVQbHVnaW4oKSB7XG5cdFx0dGhyb3coXCJNb3Rpb25HdWlkZVBsdWdpbiBjYW5ub3QgYmUgaW5zdGFudGlhdGVkLlwiKVxuXHR9O1xuXG5cbi8vIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQHByb3BlcnR5IHByaW9yaXR5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLnByaW9yaXR5ID0gMDsgLy8gaGlnaCBwcmlvcml0eSwgc2hvdWxkIHJ1biBzb29uZXJcblxuXHQvKipcblx0ICogQHByb3BlcnR5IHRlbXBvcmFyeSB2YXJpYWJsZSBzdG9yYWdlXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLl9yb3RPZmZTO1xuXHQvKipcblx0ICogQHByb3BlcnR5IHRlbXBvcmFyeSB2YXJpYWJsZSBzdG9yYWdlXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLl9yb3RPZmZFO1xuXHQvKipcblx0ICogQHByb3BlcnR5IHRlbXBvcmFyeSB2YXJpYWJsZSBzdG9yYWdlXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLl9yb3ROb3JtUztcblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB0ZW1wb3JhcnkgdmFyaWFibGUgc3RvcmFnZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRNb3Rpb25HdWlkZVBsdWdpbi5fcm90Tm9ybUU7XG5cblxuLy8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIEluc3RhbGxzIHRoaXMgcGx1Z2luIGZvciB1c2Ugd2l0aCBUd2VlbkpTLiBDYWxsIHRoaXMgb25jZSBhZnRlciBUd2VlbkpTIGlzIGxvYWRlZCB0byBlbmFibGUgdGhpcyBwbHVnaW4uXG5cdCAqIEBtZXRob2QgaW5zdGFsbFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uaW5zdGFsbCA9IGZ1bmN0aW9uKCkge1xuXHRcdGNyZWF0ZWpzLlR3ZWVuLmluc3RhbGxQbHVnaW4oTW90aW9uR3VpZGVQbHVnaW4sIFtcImd1aWRlXCIsIFwieFwiLCBcInlcIiwgXCJyb3RhdGlvblwiXSk7XG5cdFx0cmV0dXJuIGNyZWF0ZWpzLlR3ZWVuLklHTk9SRTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBpbml0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLmluaXQgPSBmdW5jdGlvbih0d2VlbiwgcHJvcCwgdmFsdWUpIHtcblx0XHR2YXIgdGFyZ2V0ID0gdHdlZW4udGFyZ2V0O1xuXHRcdGlmKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoXCJ4XCIpKXsgdGFyZ2V0LnggPSAwOyB9XG5cdFx0aWYoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShcInlcIikpeyB0YXJnZXQueSA9IDA7IH1cblx0XHRpZighdGFyZ2V0Lmhhc093blByb3BlcnR5KFwicm90YXRpb25cIikpeyB0YXJnZXQucm90YXRpb24gPSAwOyB9XG5cblx0XHRpZihwcm9wPT1cInJvdGF0aW9uXCIpeyB0d2Vlbi5fX25lZWRzUm90ID0gdHJ1ZTsgfVxuXHRcdHJldHVybiBwcm9wPT1cImd1aWRlXCI/bnVsbDp2YWx1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBzdGVwXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLnN0ZXAgPSBmdW5jdGlvbih0d2VlbiwgcHJvcCwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGluamVjdFByb3BzKSB7XG5cdFx0Ly8gb3RoZXIgcHJvcHNcblx0XHRpZihwcm9wID09IFwicm90YXRpb25cIil7XG5cdFx0XHR0d2Vlbi5fX3JvdEdsb2JhbFMgPSBzdGFydFZhbHVlO1xuXHRcdFx0dHdlZW4uX19yb3RHbG9iYWxFID0gZW5kVmFsdWU7XG5cdFx0XHRNb3Rpb25HdWlkZVBsdWdpbi50ZXN0Um90RGF0YSh0d2VlbiwgaW5qZWN0UHJvcHMpO1xuXHRcdH1cblx0XHRpZihwcm9wICE9IFwiZ3VpZGVcIil7IHJldHVybiBlbmRWYWx1ZTsgfVxuXG5cdFx0Ly8gZ3VpZGUgb25seSBpbmZvcm1hdGlvbiAtIFN0YXJ0IC1cblx0XHR2YXIgdGVtcCwgZGF0YSA9IGVuZFZhbHVlO1xuXHRcdGlmKCFkYXRhLmhhc093blByb3BlcnR5KFwicGF0aFwiKSl7IGRhdGEucGF0aCA9IFtdOyB9XG5cdFx0dmFyIHBhdGggPSBkYXRhLnBhdGg7XG5cdFx0aWYoIWRhdGEuaGFzT3duUHJvcGVydHkoXCJlbmRcIikpeyBkYXRhLmVuZCA9IDE7IH1cblx0XHRpZighZGF0YS5oYXNPd25Qcm9wZXJ0eShcInN0YXJ0XCIpKXtcblx0XHRcdGRhdGEuc3RhcnQgPSAoc3RhcnRWYWx1ZSYmc3RhcnRWYWx1ZS5oYXNPd25Qcm9wZXJ0eShcImVuZFwiKSYmc3RhcnRWYWx1ZS5wYXRoPT09cGF0aCk/c3RhcnRWYWx1ZS5lbmQ6MDtcblx0XHR9XG5cblx0XHQvLyBGaWd1cmUgb3V0IHN1YmxpbmUgaW5mb3JtYXRpb25cblx0XHRpZihkYXRhLmhhc093blByb3BlcnR5KFwiX3NlZ21lbnRzXCIpICYmIGRhdGEuX2xlbmd0aCl7IHJldHVybiBlbmRWYWx1ZTsgfVxuXHRcdHZhciBsID0gcGF0aC5sZW5ndGg7XG5cdFx0dmFyIGFjY3VyYWN5ID0gMTA7XHRcdC8vIEFkanVzdCB0byBpbXByb3ZlIGxpbmUgZm9sbG93aW5nIHByZWNpc2lvbiBidXQgc2FjcmlmaWNlIHBlcmZvcm1hbmNlICgjIG9mIHNlZylcblx0XHRpZihsID49IDYgJiYgKGwtMikgJSA0ID09IDApe1x0Ly8gRW5vdWdoIHBvaW50cyAmJiBjb250YWlucyBjb3JyZWN0IG51bWJlciBwZXIgZW50cnkgaWdub3Jpbmcgc3RhcnRcblx0XHRcdGRhdGEuX3NlZ21lbnRzID0gW107XG5cdFx0XHRkYXRhLl9sZW5ndGggPSAwO1xuXHRcdFx0Zm9yKHZhciBpPTI7IGk8bDsgaSs9NCl7XG5cdFx0XHRcdHZhciBzeCA9IHBhdGhbaS0yXSwgc3kgPSBwYXRoW2ktMV07XG5cdFx0XHRcdHZhciBjeCA9IHBhdGhbaSswXSwgY3kgPSBwYXRoW2krMV07XG5cdFx0XHRcdHZhciBleCA9IHBhdGhbaSsyXSwgZXkgPSBwYXRoW2krM107XG5cdFx0XHRcdHZhciBvbGRYID0gc3gsIG9sZFkgPSBzeTtcblx0XHRcdFx0dmFyIHRlbXBYLCB0ZW1wWSwgdG90YWwgPSAwO1xuXHRcdFx0XHR2YXIgc3VibGluZXMgPSBbXTtcblx0XHRcdFx0Zm9yKHZhciBqPTE7IGo8PWFjY3VyYWN5OyBqKyspe1xuXHRcdFx0XHRcdHZhciB0ID0gai9hY2N1cmFjeTtcblx0XHRcdFx0XHR2YXIgaW52ID0gMSAtIHQ7XG5cdFx0XHRcdFx0dGVtcFggPSBpbnYqaW52ICogc3ggKyAyICogaW52ICogdCAqIGN4ICsgdCp0ICogZXg7XG5cdFx0XHRcdFx0dGVtcFkgPSBpbnYqaW52ICogc3kgKyAyICogaW52ICogdCAqIGN5ICsgdCp0ICogZXk7XG5cdFx0XHRcdFx0dG90YWwgKz0gc3VibGluZXNbc3VibGluZXMucHVzaChNYXRoLnNxcnQoKHRlbXA9dGVtcFgtb2xkWCkqdGVtcCArICh0ZW1wPXRlbXBZLW9sZFkpKnRlbXApKS0xXTtcblx0XHRcdFx0XHRvbGRYID0gdGVtcFg7XG5cdFx0XHRcdFx0b2xkWSA9IHRlbXBZO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGEuX3NlZ21lbnRzLnB1c2godG90YWwpO1xuXHRcdFx0XHRkYXRhLl9zZWdtZW50cy5wdXNoKHN1YmxpbmVzKTtcblx0XHRcdFx0ZGF0YS5fbGVuZ3RoICs9IHRvdGFsO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyhcImludmFsaWQgJ3BhdGgnIGRhdGEsIHBsZWFzZSBzZWUgZG9jdW1lbnRhdGlvbiBmb3IgdmFsaWQgcGF0aHNcIik7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0dXAgeC95IHR3ZWVuc1xuXHRcdHRlbXAgPSBkYXRhLm9yaWVudDtcblx0XHRkYXRhLm9yaWVudCA9IHRydWU7XG5cdFx0dmFyIG8gPSB7fTtcblx0XHRNb3Rpb25HdWlkZVBsdWdpbi5jYWxjKGRhdGEsIGRhdGEuc3RhcnQsIG8pO1xuXHRcdHR3ZWVuLl9fcm90UGF0aFMgPSBOdW1iZXIoby5yb3RhdGlvbi50b0ZpeGVkKDUpKTtcblx0XHRNb3Rpb25HdWlkZVBsdWdpbi5jYWxjKGRhdGEsIGRhdGEuZW5kLCBvKTtcblx0XHR0d2Vlbi5fX3JvdFBhdGhFID0gTnVtYmVyKG8ucm90YXRpb24udG9GaXhlZCg1KSk7XG5cdFx0ZGF0YS5vcmllbnQgPSBmYWxzZTtcdC8vaGVyZSBhbmQgbm93IHdlIGRvbid0IGtub3cgaWYgd2UgbmVlZCB0b1xuXHRcdE1vdGlvbkd1aWRlUGx1Z2luLmNhbGMoZGF0YSwgZGF0YS5lbmQsIGluamVjdFByb3BzKTtcblx0XHRkYXRhLm9yaWVudCA9IHRlbXA7XG5cblx0XHQvLyBTZXR1cCByb3RhdGlvbiBwcm9wZXJ0aWVzXG5cdFx0aWYoIWRhdGEub3JpZW50KXsgcmV0dXJuIGVuZFZhbHVlOyB9XG5cdFx0dHdlZW4uX19ndWlkZURhdGEgPSBkYXRhO1xuXHRcdE1vdGlvbkd1aWRlUGx1Z2luLnRlc3RSb3REYXRhKHR3ZWVuLCBpbmplY3RQcm9wcyk7XG5cdFx0cmV0dXJuIGVuZFZhbHVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHRlc3RSb3REYXRhXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLnRlc3RSb3REYXRhID0gZnVuY3Rpb24odHdlZW4sIGluamVjdFByb3BzKXtcblxuXHRcdC8vIG5vIHJvdGF0aW9uIGluZm9ybWF0PyBpZiB3ZSBuZWVkIGl0IGNvbWUgYmFjaywgaWYgd2UgZG9uJ3QgdXNlIDAgJiBlbnN1cmUgd2UgaGF2ZSBndWlkZSBkYXRhXG5cdFx0aWYodHdlZW4uX19yb3RHbG9iYWxTID09PSB1bmRlZmluZWQgfHwgdHdlZW4uX19yb3RHbG9iYWxFID09PSB1bmRlZmluZWQpe1xuXHRcdFx0aWYodHdlZW4uX19uZWVkc1JvdCl7IHJldHVybjsgfVxuXHRcdFx0aWYodHdlZW4uX2N1clF1ZXVlUHJvcHMucm90YXRpb24gIT09IHVuZGVmaW5lZCl7XG5cdFx0XHRcdHR3ZWVuLl9fcm90R2xvYmFsUyA9IHR3ZWVuLl9fcm90R2xvYmFsRSA9IHR3ZWVuLl9jdXJRdWV1ZVByb3BzLnJvdGF0aW9uO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uX19yb3RHbG9iYWxTID0gdHdlZW4uX19yb3RHbG9iYWxFID0gaW5qZWN0UHJvcHMucm90YXRpb24gPSB0d2Vlbi50YXJnZXQucm90YXRpb24gfHwgMDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYodHdlZW4uX19ndWlkZURhdGEgPT09IHVuZGVmaW5lZCl7IHJldHVybjsgfVxuXG5cdFx0Ly8gUHJvY2VzcyByb3RhdGlvbiBwcm9wZXJ0aWVzXG5cdFx0dmFyIGRhdGEgPSB0d2Vlbi5fX2d1aWRlRGF0YTtcblx0XHR2YXIgcm90R2xvYmFsRCA9IHR3ZWVuLl9fcm90R2xvYmFsRSAtIHR3ZWVuLl9fcm90R2xvYmFsUztcblx0XHR2YXIgcm90UGF0aEQgPSB0d2Vlbi5fX3JvdFBhdGhFIC0gdHdlZW4uX19yb3RQYXRoUztcblx0XHR2YXIgcm90ID0gcm90R2xvYmFsRCAtIHJvdFBhdGhEO1xuXG5cdFx0aWYoZGF0YS5vcmllbnQgPT0gXCJhdXRvXCIpe1xuXHRcdFx0aWYocm90ID4gMTgwKXtcdFx0XHRyb3QgLT0gMzYwOyB9XG5cdFx0XHRlbHNlIGlmKHJvdCA8IC0xODApe1x0cm90ICs9IDM2MDsgfVxuXG5cdFx0fSBlbHNlIGlmKGRhdGEub3JpZW50ID09IFwiY3dcIil7XG5cdFx0XHR3aGlsZShyb3QgPCAwKXsgcm90ICs9IDM2MDsgfVxuXHRcdFx0aWYocm90ID09IDAgJiYgcm90R2xvYmFsRCA+IDAgJiYgcm90R2xvYmFsRCAhPSAxODApeyByb3QgKz0gMzYwOyB9XG5cblx0XHR9IGVsc2UgaWYoZGF0YS5vcmllbnQgPT0gXCJjY3dcIil7XG5cdFx0XHRyb3QgPSByb3RHbG9iYWxEIC0gKChyb3RQYXRoRCA+IDE4MCk/KDM2MC1yb3RQYXRoRCk6KHJvdFBhdGhEKSk7XHQvLyBzaWduIGZsaXBwaW5nIG9uIHBhdGhcblx0XHRcdHdoaWxlKHJvdCA+IDApeyByb3QgLT0gMzYwOyB9XG5cdFx0XHRpZihyb3QgPT0gMCAmJiByb3RHbG9iYWxEIDwgMCAmJiByb3RHbG9iYWxEICE9IC0xODApeyByb3QgLT0gMzYwOyB9XG5cdFx0fVxuXG5cdFx0ZGF0YS5yb3REZWx0YSA9IHJvdDtcblx0XHRkYXRhLnJvdE9mZlMgPSB0d2Vlbi5fX3JvdEdsb2JhbFMgLSB0d2Vlbi5fX3JvdFBhdGhTO1xuXG5cdFx0Ly8gcmVzZXRcblx0XHR0d2Vlbi5fX3JvdEdsb2JhbFMgPSB0d2Vlbi5fX3JvdEdsb2JhbEUgPSB0d2Vlbi5fX2d1aWRlRGF0YSA9IHR3ZWVuLl9fbmVlZHNSb3QgPSB1bmRlZmluZWQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgdHdlZW5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0TW90aW9uR3VpZGVQbHVnaW4udHdlZW4gPSBmdW5jdGlvbih0d2VlbiwgcHJvcCwgdmFsdWUsIHN0YXJ0VmFsdWVzLCBlbmRWYWx1ZXMsIHJhdGlvLCB3YWl0LCBlbmQpIHtcblx0XHR2YXIgZGF0YSA9IGVuZFZhbHVlcy5ndWlkZTtcblx0XHRpZihkYXRhID09IHVuZGVmaW5lZCB8fCBkYXRhID09PSBzdGFydFZhbHVlcy5ndWlkZSl7IHJldHVybiB2YWx1ZTsgfVxuXHRcdGlmKGRhdGEubGFzdFJhdGlvICE9IHJhdGlvKXtcblx0XHRcdC8vIGZpcnN0IHRpbWUgdGhyb3VnaCBzbyBjYWxjdWxhdGUgd2hhdCBJIG5lZWQgdG9cblx0XHRcdHZhciB0ID0gKChkYXRhLmVuZC1kYXRhLnN0YXJ0KSood2FpdD9kYXRhLmVuZDpyYXRpbykrZGF0YS5zdGFydCk7XG5cdFx0XHRNb3Rpb25HdWlkZVBsdWdpbi5jYWxjKGRhdGEsIHQsIHR3ZWVuLnRhcmdldCk7XG5cdFx0XHRzd2l0Y2goZGF0YS5vcmllbnQpe1xuXHRcdFx0XHRjYXNlIFwiY3dcIjpcdFx0Ly8gbWl4IGluIHRoZSBvcmlnaW5hbCByb3RhdGlvblxuXHRcdFx0XHRjYXNlIFwiY2N3XCI6XG5cdFx0XHRcdGNhc2UgXCJhdXRvXCI6IHR3ZWVuLnRhcmdldC5yb3RhdGlvbiArPSBkYXRhLnJvdE9mZlMgKyBkYXRhLnJvdERlbHRhKnJhdGlvOyBicmVhaztcblx0XHRcdFx0Y2FzZSBcImZpeGVkXCI6XHQvLyBmb2xsb3cgZml4ZWQgYmVoYXZpb3VyIHRvIHNvbHZlIHBvdGVudGlhbCBpc3N1ZXNcblx0XHRcdFx0ZGVmYXVsdDogdHdlZW4udGFyZ2V0LnJvdGF0aW9uICs9IGRhdGEucm90T2ZmUzsgYnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRkYXRhLmxhc3RSYXRpbyA9IHJhdGlvO1xuXHRcdH1cblx0XHRpZihwcm9wID09IFwicm90YXRpb25cIiAmJiAoKCFkYXRhLm9yaWVudCkgfHwgZGF0YS5vcmllbnQgPT0gXCJmYWxzZVwiKSl7IHJldHVybiB2YWx1ZTsgfVxuXHRcdHJldHVybiB0d2Vlbi50YXJnZXRbcHJvcF07XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSB0aGUgYXBwcm9wcmlhdGUgeC95L3JvdGF0aW9uIGluZm9ybWF0aW9uIGFib3V0IGEgcGF0aCBmb3IgYSBnaXZlbiByYXRpbyBhbG9uZyB0aGUgcGF0aC5cblx0ICogQXNzdW1lcyBhIHBhdGggb2JqZWN0IHdpdGggYWxsIG9wdGlvbmFsIHBhcmFtZXRlcnMgc3BlY2lmaWVkLlxuXHQgKiBAcGFyYW0gZGF0YSBEYXRhIG9iamVjdCB5b3Ugd291bGQgcGFzcyB0byB0aGUgXCJndWlkZTpcIiBwcm9wZXJ0eSBpbiBhIFR3ZWVuXG5cdCAqIEBwYXJhbSByYXRpbyAwLTEgRGlzdGFuY2UgYWxvbmcgcGF0aCwgdmFsdWVzIG91dHNpZGUgMC0xIGFyZSBcImJlc3QgZ3Vlc3NcIlxuXHQgKiBAcGFyYW0gdGFyZ2V0IE9iamVjdCB0byBjb3B5IHRoZSByZXN1bHRzIG9udG8sIHdpbGwgdXNlIGEgbmV3IG9iamVjdCBpZiBub3Qgc3VwcGxpZWQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIHRhcmdldCBvYmplY3Qgb3IgYSBuZXcgb2JqZWN0IHcvIHRoZSB0d2VlbmVkIHByb3BlcnRpZXNcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uY2FsYyA9IGZ1bmN0aW9uKGRhdGEsIHJhdGlvLCB0YXJnZXQpIHtcblx0XHRpZihkYXRhLl9zZWdtZW50cyA9PSB1bmRlZmluZWQpeyBNb3Rpb25HdWlkZVBsdWdpbi52YWxpZGF0ZShkYXRhKTsgfVxuXHRcdGlmKHRhcmdldCA9PSB1bmRlZmluZWQpeyB0YXJnZXQgPSB7eDowLCB5OjAsIHJvdGF0aW9uOjB9OyB9XG5cdFx0dmFyIHNlZyA9IGRhdGEuX3NlZ21lbnRzO1xuXHRcdHZhciBwYXRoID0gZGF0YS5wYXRoO1xuXG5cdFx0Ly8gZmluZCBzZWdtZW50XG5cdFx0dmFyIHBvcyA9IGRhdGEuX2xlbmd0aCAqIHJhdGlvO1xuXHRcdHZhciBjYXAgPSBzZWcubGVuZ3RoIC0gMjtcblx0XHR2YXIgbiA9IDA7XG5cdFx0d2hpbGUocG9zID4gc2VnW25dICYmIG4gPCBjYXApe1xuXHRcdFx0cG9zIC09IHNlZ1tuXTtcblx0XHRcdG4rPTI7XG5cdFx0fVxuXG5cdFx0Ly8gZmluZCBzdWJsaW5lXG5cdFx0dmFyIHN1YmxpbmVzID0gc2VnW24rMV07XG5cdFx0dmFyIGkgPSAwO1xuXHRcdGNhcCA9IHN1YmxpbmVzLmxlbmd0aC0xO1xuXHRcdHdoaWxlKHBvcyA+IHN1YmxpbmVzW2ldICYmIGkgPCBjYXApe1xuXHRcdFx0cG9zIC09IHN1YmxpbmVzW2ldO1xuXHRcdFx0aSsrO1xuXHRcdH1cblx0XHR2YXIgdCA9IChpLysrY2FwKSsocG9zLyhjYXAqc3VibGluZXNbaV0pKTtcblxuXHRcdC8vIGZpbmQgeC95XG5cdFx0biA9IChuKjIpKzI7XG5cdFx0dmFyIGludiA9IDEgLSB0O1xuXHRcdHRhcmdldC54ID0gaW52KmludiAqIHBhdGhbbi0yXSArIDIgKiBpbnYgKiB0ICogcGF0aFtuKzBdICsgdCp0ICogcGF0aFtuKzJdO1xuXHRcdHRhcmdldC55ID0gaW52KmludiAqIHBhdGhbbi0xXSArIDIgKiBpbnYgKiB0ICogcGF0aFtuKzFdICsgdCp0ICogcGF0aFtuKzNdO1xuXG5cdFx0Ly8gb3JpZW50YXRpb25cblx0XHRpZihkYXRhLm9yaWVudCl7XG5cdFx0XHR0YXJnZXQucm90YXRpb24gPSA1Ny4yOTU3Nzk1ICogTWF0aC5hdGFuMihcblx0XHRcdFx0KHBhdGhbbisxXS1wYXRoW24tMV0pKmludiArIChwYXRoW24rM10tcGF0aFtuKzFdKSp0LFxuXHRcdFx0XHQocGF0aFtuKzBdLXBhdGhbbi0yXSkqaW52ICsgKHBhdGhbbisyXS1wYXRoW24rMF0pKnQpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH07XG5cblx0Y3JlYXRlanMuTW90aW9uR3VpZGVQbHVnaW4gPSBNb3Rpb25HdWlkZVBsdWdpbjtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIHZlcnNpb24uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBTdGF0aWMgY2xhc3MgaG9sZGluZyBsaWJyYXJ5IHNwZWNpZmljIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHZlcnNpb24gYW5kIGJ1aWxkRGF0ZSBvZlxuXHQgKiB0aGUgbGlicmFyeS5cblx0ICogQGNsYXNzIFR3ZWVuSlNcblx0ICoqL1xuXHR2YXIgcyA9IGNyZWF0ZWpzLlR3ZWVuSlMgPSBjcmVhdGVqcy5Ud2VlbkpTIHx8IHt9O1xuXG5cdC8qKlxuXHQgKiBUaGUgdmVyc2lvbiBzdHJpbmcgZm9yIHRoaXMgcmVsZWFzZS5cblx0ICogQHByb3BlcnR5IHZlcnNpb25cblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRzLnZlcnNpb24gPSAvKj12ZXJzaW9uKi9cIjAuNi4xXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxuXHQvKipcblx0ICogVGhlIGJ1aWxkIGRhdGUgZm9yIHRoaXMgcmVsZWFzZSBpbiBVVEMgZm9ybWF0LlxuXHQgKiBAcHJvcGVydHkgYnVpbGREYXRlXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy5idWlsZERhdGUgPSAvKj1kYXRlKi9cIlRodSwgMjEgTWF5IDIwMTUgMTY6MTc6MzcgR01UXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxufSkoKTtcbmlmKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSBtb2R1bGUuZXhwb3J0cyA9IHRoaXMuY3JlYXRlanM7IiwiLyohXG4gKiBlbnF1aXJlLmpzIHYyLjEuMSAtIEF3ZXNvbWUgTWVkaWEgUXVlcmllcyBpbiBKYXZhU2NyaXB0XG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgTmljayBXaWxsaWFtcyAtIGh0dHA6Ly93aWNreS5uaWxsaWEubXMvZW5xdWlyZS5qc1xuICogTGljZW5zZTogTUlUIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocClcbiAqL1xuXG47KGZ1bmN0aW9uIChuYW1lLCBjb250ZXh0LCBmYWN0b3J5KSB7XG5cdHZhciBtYXRjaE1lZGlhID0gd2luZG93Lm1hdGNoTWVkaWE7XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KG1hdGNoTWVkaWEpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRcdGRlZmluZShmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAoY29udGV4dFtuYW1lXSA9IGZhY3RvcnkobWF0Y2hNZWRpYSkpO1xuXHRcdH0pO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGNvbnRleHRbbmFtZV0gPSBmYWN0b3J5KG1hdGNoTWVkaWEpO1xuXHR9XG59KCdlbnF1aXJlJywgdGhpcywgZnVuY3Rpb24gKG1hdGNoTWVkaWEpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cbiAgICAvKmpzaGludCB1bnVzZWQ6ZmFsc2UgKi9cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGl0ZXJhdGluZyBvdmVyIGEgY29sbGVjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0gZm5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlYWNoKGNvbGxlY3Rpb24sIGZuKSB7XG4gICAgICAgIHZhciBpICAgICAgPSAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgICAgICBjb250O1xuXG4gICAgICAgIGZvcihpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnQgPSBmbihjb2xsZWN0aW9uW2ldLCBpKTtcbiAgICAgICAgICAgIGlmKGNvbnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vYWxsb3cgZWFybHkgZXhpdFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRhcmdldCBvYmplY3QgaXMgYW4gYXJyYXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXQgdGhlIG9iamVjdCB1bmRlciB0ZXN0XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBhcnJheSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodGFyZ2V0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGFyZ2V0IG9iamVjdCBpcyBhIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IHRoZSBvYmplY3QgdW5kZXIgdGVzdFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgZnVuY3Rpb24sIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGVnYXRlIHRvIGhhbmRsZSBhIG1lZGlhIHF1ZXJ5IGJlaW5nIG1hdGNoZWQgYW5kIHVubWF0Y2hlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5tYXRjaCBjYWxsYmFjayBmb3Igd2hlbiB0aGUgbWVkaWEgcXVlcnkgaXMgbWF0Y2hlZFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLnVubWF0Y2hdIGNhbGxiYWNrIGZvciB3aGVuIHRoZSBtZWRpYSBxdWVyeSBpcyB1bm1hdGNoZWRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5zZXR1cF0gb25lLXRpbWUgY2FsbGJhY2sgdHJpZ2dlcmVkIHRoZSBmaXJzdCB0aW1lIGEgcXVlcnkgaXMgbWF0Y2hlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVmZXJTZXR1cD1mYWxzZV0gc2hvdWxkIHRoZSBzZXR1cCBjYWxsYmFjayBiZSBydW4gaW1tZWRpYXRlbHksIHJhdGhlciB0aGFuIGZpcnN0IHRpbWUgcXVlcnkgaXMgbWF0Y2hlZD9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBRdWVyeUhhbmRsZXIob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAhb3B0aW9ucy5kZWZlclNldHVwICYmIHRoaXMuc2V0dXAoKTtcbiAgICB9XG4gICAgUXVlcnlIYW5kbGVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogY29vcmRpbmF0ZXMgc2V0dXAgb2YgdGhlIGhhbmRsZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzZXR1cCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnNldHVwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNldHVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpc2VkID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogY29vcmRpbmF0ZXMgc2V0dXAgYW5kIHRyaWdnZXJpbmcgb2YgdGhlIGhhbmRsZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBvbiA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgIXRoaXMuaW5pdGlhbGlzZWQgJiYgdGhpcy5zZXR1cCgpO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1hdGNoICYmIHRoaXMub3B0aW9ucy5tYXRjaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjb29yZGluYXRlcyB0aGUgdW5tYXRjaCBldmVudCBmb3IgdGhlIGhhbmRsZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBvZmYgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy51bm1hdGNoICYmIHRoaXMub3B0aW9ucy51bm1hdGNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNhbGxlZCB3aGVuIGEgaGFuZGxlciBpcyB0byBiZSBkZXN0cm95ZWQuXG4gICAgICAgICAqIGRlbGVnYXRlcyB0byB0aGUgZGVzdHJveSBvciB1bm1hdGNoIGNhbGxiYWNrcywgZGVwZW5kaW5nIG9uIGF2YWlsYWJpbGl0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZGVzdHJveSA/IHRoaXMub3B0aW9ucy5kZXN0cm95KCkgOiB0aGlzLm9mZigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZXRlcm1pbmVzIGVxdWFsaXR5IGJ5IHJlZmVyZW5jZS5cbiAgICAgICAgICogaWYgb2JqZWN0IGlzIHN1cHBsaWVkIGNvbXBhcmUgb3B0aW9ucywgaWYgZnVuY3Rpb24sIGNvbXBhcmUgbWF0Y2ggY2FsbGJhY2tcbiAgICAgICAgICpcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0IHx8IGZ1bmN0aW9ufSBbdGFyZ2V0XSB0aGUgdGFyZ2V0IGZvciBjb21wYXJpc29uXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMgOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMgPT09IHRhcmdldCB8fCB0aGlzLm9wdGlvbnMubWF0Y2ggPT09IHRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgc2luZ2xlIG1lZGlhIHF1ZXJ5LCBtYW5hZ2VzIGl0J3Mgc3RhdGUgYW5kIHJlZ2lzdGVyZWQgaGFuZGxlcnMgZm9yIHRoaXMgcXVlcnlcbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSB0aGUgbWVkaWEgcXVlcnkgc3RyaW5nXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNVbmNvbmRpdGlvbmFsPWZhbHNlXSB3aGV0aGVyIHRoZSBtZWRpYSBxdWVyeSBzaG91bGQgcnVuIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgY29uZGl0aW9ucyBhcmUgbWV0LiBQcmltYXJpbHkgZm9yIGhlbHBpbmcgb2xkZXIgYnJvd3NlcnMgZGVhbCB3aXRoIG1vYmlsZS1maXJzdCBkZXNpZ25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNZWRpYVF1ZXJ5KHF1ZXJ5LCBpc1VuY29uZGl0aW9uYWwpIHtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB0aGlzLmlzVW5jb25kaXRpb25hbCA9IGlzVW5jb25kaXRpb25hbDtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgICAgICB0aGlzLm1xbCA9IG1hdGNoTWVkaWEocXVlcnkpO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGZ1bmN0aW9uKG1xbCkge1xuICAgICAgICAgICAgc2VsZi5tcWwgPSBtcWw7XG4gICAgICAgICAgICBzZWxmLmFzc2VzcygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1xbC5hZGRMaXN0ZW5lcih0aGlzLmxpc3RlbmVyKTtcbiAgICB9XG4gICAgTWVkaWFRdWVyeS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFkZCBhIGhhbmRsZXIgZm9yIHRoaXMgcXVlcnksIHRyaWdnZXJpbmcgaWYgYWxyZWFkeSBhY3RpdmVcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZXJcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlci5tYXRjaCBjYWxsYmFjayBmb3Igd2hlbiBxdWVyeSBpcyBhY3RpdmF0ZWRcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2hhbmRsZXIudW5tYXRjaF0gY2FsbGJhY2sgZm9yIHdoZW4gcXVlcnkgaXMgZGVhY3RpdmF0ZWRcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2hhbmRsZXIuc2V0dXBdIGNhbGxiYWNrIGZvciBpbW1lZGlhdGUgZXhlY3V0aW9uIHdoZW4gYSBxdWVyeSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWRcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbaGFuZGxlci5kZWZlclNldHVwPWZhbHNlXSBzaG91bGQgdGhlIHNldHVwIGNhbGxiYWNrIGJlIGRlZmVycmVkIHVudGlsIHRoZSBmaXJzdCB0aW1lIHRoZSBoYW5kbGVyIGlzIG1hdGNoZWQ/XG4gICAgICAgICAqL1xuICAgICAgICBhZGRIYW5kbGVyIDogZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIHFoID0gbmV3IFF1ZXJ5SGFuZGxlcihoYW5kbGVyKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMucHVzaChxaCk7XG5cbiAgICAgICAgICAgIHRoaXMubWF0Y2hlcygpICYmIHFoLm9uKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlbW92ZXMgdGhlIGdpdmVuIGhhbmRsZXIgZnJvbSB0aGUgY29sbGVjdGlvbiwgYW5kIGNhbGxzIGl0J3MgZGVzdHJveSBtZXRob2RzXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdCB8fCBmdW5jdGlvbn0gaGFuZGxlciB0aGUgaGFuZGxlciB0byByZW1vdmVcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUhhbmRsZXIgOiBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICAgICAgZWFjaChoYW5kbGVycywgZnVuY3Rpb24oaCwgaSkge1xuICAgICAgICAgICAgICAgIGlmKGguZXF1YWxzKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGguZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWhhbmRsZXJzLnNwbGljZShpLDEpOyAvL3JlbW92ZSBmcm9tIGFycmF5IGFuZCBleGl0IGVhY2ggZWFybHlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIG1lZGlhIHF1ZXJ5IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgbWF0Y2hcbiAgICAgICAgICogXG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgbWVkaWEgcXVlcnkgY2FuIGJlIGNvbnNpZGVyZWQgYSBtYXRjaCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICAgICAqL1xuICAgICAgICBtYXRjaGVzIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tcWwubWF0Y2hlcyB8fCB0aGlzLmlzVW5jb25kaXRpb25hbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXJzIGFsbCBoYW5kbGVycyBhbmQgdW5iaW5kcyBldmVudHNcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBlYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5tcWwucmVtb3ZlTGlzdGVuZXIodGhpcy5saXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXJzLmxlbmd0aCA9IDA7IC8vY2xlYXIgYXJyYXlcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICAgKiBBc3Nlc3NlcyB0aGUgcXVlcnksIHR1cm5pbmcgb24gYWxsIGhhbmRsZXJzIGlmIGl0IG1hdGNoZXMsIHR1cm5pbmcgdGhlbSBvZmYgaWYgaXQgZG9lc24ndCBtYXRjaFxuICAgICAgICAgKi9cbiAgICAgICAgYXNzZXNzIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gdGhpcy5tYXRjaGVzKCkgPyAnb24nIDogJ29mZic7XG5cbiAgICAgICAgICAgIGVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJbYWN0aW9uXSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFsbG93cyBmb3IgcmVnaXN0cmF0aW9uIG9mIHF1ZXJ5IGhhbmRsZXJzLlxuICAgICAqIE1hbmFnZXMgdGhlIHF1ZXJ5IGhhbmRsZXIncyBzdGF0ZSBhbmQgaXMgcmVzcG9uc2libGUgZm9yIHdpcmluZyB1cCBicm93c2VyIGV2ZW50c1xuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWVkaWFRdWVyeURpc3BhdGNoICgpIHtcbiAgICAgICAgaWYoIW1hdGNoTWVkaWEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWF0Y2hNZWRpYSBub3QgcHJlc2VudCwgbGVnYWN5IGJyb3dzZXJzIHJlcXVpcmUgYSBwb2x5ZmlsbCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5xdWVyaWVzID0ge307XG4gICAgICAgIHRoaXMuYnJvd3NlcklzSW5jYXBhYmxlID0gIW1hdGNoTWVkaWEoJ29ubHkgYWxsJykubWF0Y2hlcztcbiAgICB9XG5cbiAgICBNZWRpYVF1ZXJ5RGlzcGF0Y2gucHJvdG90eXBlID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlcnMgYSBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gbWVkaWEgcXVlcnlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHEgdGhlIG1lZGlhIHF1ZXJ5XG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0IHx8IEFycmF5IHx8IEZ1bmN0aW9ufSBvcHRpb25zIGVpdGhlciBhIHNpbmdsZSBxdWVyeSBoYW5kbGVyIG9iamVjdCwgYSBmdW5jdGlvbiwgb3IgYW4gYXJyYXkgb2YgcXVlcnkgaGFuZGxlcnNcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5tYXRjaCBmaXJlZCB3aGVuIHF1ZXJ5IG1hdGNoZWRcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMudW5tYXRjaF0gZmlyZWQgd2hlbiBhIHF1ZXJ5IGlzIG5vIGxvbmdlciBtYXRjaGVkXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLnNldHVwXSBmaXJlZCB3aGVuIGhhbmRsZXIgZmlyc3QgdHJpZ2dlcmVkXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVmZXJTZXR1cD1mYWxzZV0gd2hldGhlciBzZXR1cCBzaG91bGQgYmUgcnVuIGltbWVkaWF0ZWx5IG9yIGRlZmVycmVkIHVudGlsIHF1ZXJ5IGlzIGZpcnN0IG1hdGNoZWRcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbc2hvdWxkRGVncmFkZT1mYWxzZV0gd2hldGhlciB0aGlzIHBhcnRpY3VsYXIgbWVkaWEgcXVlcnkgc2hvdWxkIGFsd2F5cyBydW4gb24gaW5jYXBhYmxlIGJyb3dzZXJzXG4gICAgICAgICAqL1xuICAgICAgICByZWdpc3RlciA6IGZ1bmN0aW9uKHEsIG9wdGlvbnMsIHNob3VsZERlZ3JhZGUpIHtcbiAgICAgICAgICAgIHZhciBxdWVyaWVzICAgICAgICAgPSB0aGlzLnF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgaXNVbmNvbmRpdGlvbmFsID0gc2hvdWxkRGVncmFkZSAmJiB0aGlzLmJyb3dzZXJJc0luY2FwYWJsZTtcblxuICAgICAgICAgICAgaWYoIXF1ZXJpZXNbcV0pIHtcbiAgICAgICAgICAgICAgICBxdWVyaWVzW3FdID0gbmV3IE1lZGlhUXVlcnkocSwgaXNVbmNvbmRpdGlvbmFsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9ub3JtYWxpc2UgdG8gb2JqZWN0IGluIGFuIGFycmF5XG4gICAgICAgICAgICBpZihpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgbWF0Y2ggOiBvcHRpb25zIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZighaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBbb3B0aW9uc107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlYWNoKG9wdGlvbnMsIGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBxdWVyaWVzW3FdLmFkZEhhbmRsZXIoaGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVucmVnaXN0ZXJzIGEgcXVlcnkgYW5kIGFsbCBpdCdzIGhhbmRsZXJzLCBvciBhIHNwZWNpZmljIGhhbmRsZXIgZm9yIGEgcXVlcnlcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHEgdGhlIG1lZGlhIHF1ZXJ5IHRvIHRhcmdldFxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdCB8fCBmdW5jdGlvbn0gW2hhbmRsZXJdIHNwZWNpZmljIGhhbmRsZXIgdG8gdW5yZWdpc3RlclxuICAgICAgICAgKi9cbiAgICAgICAgdW5yZWdpc3RlciA6IGZ1bmN0aW9uKHEsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcmllc1txXTtcblxuICAgICAgICAgICAgaWYocXVlcnkpIHtcbiAgICAgICAgICAgICAgICBpZihoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5LnJlbW92ZUhhbmRsZXIoaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeS5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5xdWVyaWVzW3FdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cdHJldHVybiBuZXcgTWVkaWFRdWVyeURpc3BhdGNoKCk7XG5cbn0pKTsiLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjIuMi4yXG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDMtMTdUMTc6NTFaXG4gKi9cblxuKGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59KHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gU3VwcG9ydDogRmlyZWZveCAxOCtcbi8vIENhbid0IGJlIGluIHN0cmljdCBtb2RlLCBzZXZlcmFsIGxpYnMgaW5jbHVkaW5nIEFTUC5ORVQgdHJhY2Vcbi8vIHRoZSBzdGFjayB2aWEgYXJndW1lbnRzLmNhbGxlci5jYWxsZWUgYW5kIEZpcmVmb3ggZGllcyBpZlxuLy8geW91IHRyeSB0byB0cmFjZSB0aHJvdWdoIFwidXNlIHN0cmljdFwiIGNhbGwgY2hhaW5zLiAoIzEzMzM1KVxuLy9cInVzZSBzdHJpY3RcIjtcbnZhciBhcnIgPSBbXTtcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIyLjIuMlwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXG5cblx0Ly8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG5cdHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbXFxkYS16XSkvZ2ksXG5cblx0Ly8gVXNlZCBieSBqUXVlcnkuY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuXHRmY2FtZWxDYXNlID0gZnVuY3Rpb24oIGFsbCwgbGV0dGVyICkge1xuXHRcdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFN0YXJ0IHdpdGggYW4gZW1wdHkgc2VsZWN0b3Jcblx0c2VsZWN0b3I6IFwiXCIsXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXHRcdHJldHVybiBudW0gIT0gbnVsbCA/XG5cblx0XHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRcdCggbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXSApIDpcblxuXHRcdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdFx0c2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblx0XHRyZXQuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheSggY29weSApICkgKSApIHtcblxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzQXJyYXkoIHNyYyApID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNGdW5jdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnR5cGUoIG9iaiApID09PSBcImZ1bmN0aW9uXCI7XG5cdH0sXG5cblx0aXNBcnJheTogQXJyYXkuaXNBcnJheSxcblxuXHRpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9LFxuXG5cdGlzTnVtZXJpYzogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChudWxsfHRydWV8ZmFsc2V8XCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0Ly8gYWRkaW5nIDEgY29ycmVjdHMgbG9zcyBvZiBwcmVjaXNpb24gZnJvbSBwYXJzZUZsb2F0ICgjMTUxMDApXG5cdFx0dmFyIHJlYWxTdHJpbmdPYmogPSBvYmogJiYgb2JqLnRvU3RyaW5nKCk7XG5cdFx0cmV0dXJuICFqUXVlcnkuaXNBcnJheSggb2JqICkgJiYgKCByZWFsU3RyaW5nT2JqIC0gcGFyc2VGbG9hdCggcmVhbFN0cmluZ09iaiApICsgMSApID49IDA7XG5cdH0sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIga2V5O1xuXG5cdFx0Ly8gTm90IHBsYWluIG9iamVjdHM6XG5cdFx0Ly8gLSBBbnkgb2JqZWN0IG9yIHZhbHVlIHdob3NlIGludGVybmFsIFtbQ2xhc3NdXSBwcm9wZXJ0eSBpcyBub3QgXCJbb2JqZWN0IE9iamVjdF1cIlxuXHRcdC8vIC0gRE9NIG5vZGVzXG5cdFx0Ly8gLSB3aW5kb3dcblx0XHRpZiAoIGpRdWVyeS50eXBlKCBvYmogKSAhPT0gXCJvYmplY3RcIiB8fCBvYmoubm9kZVR5cGUgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBOb3Qgb3duIGNvbnN0cnVjdG9yIHByb3BlcnR5IG11c3QgYmUgT2JqZWN0XG5cdFx0aWYgKCBvYmouY29uc3RydWN0b3IgJiZcblx0XHRcdFx0IWhhc093bi5jYWxsKCBvYmosIFwiY29uc3RydWN0b3JcIiApICYmXG5cdFx0XHRcdCFoYXNPd24uY2FsbCggb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSB8fCB7fSwgXCJpc1Byb3RvdHlwZU9mXCIgKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBPd24gcHJvcGVydGllcyBhcmUgZW51bWVyYXRlZCBmaXJzdGx5LCBzbyB0byBzcGVlZCB1cCxcblx0XHQvLyBpZiBsYXN0IG9uZSBpcyBvd24sIHRoZW4gYWxsIHByb3BlcnRpZXMgYXJlIG93blxuXHRcdGZvciAoIGtleSBpbiBvYmogKSB7fVxuXG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkIHx8IGhhc093bi5jYWxsKCBvYmosIGtleSApO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIG5hbWU7XG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdHR5cGU6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wLCBpT1M8NiAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdFx0dHlwZW9mIG9iajtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSApIHtcblx0XHR2YXIgc2NyaXB0LFxuXHRcdFx0aW5kaXJlY3QgPSBldmFsO1xuXG5cdFx0Y29kZSA9IGpRdWVyeS50cmltKCBjb2RlICk7XG5cblx0XHRpZiAoIGNvZGUgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBjb2RlIGluY2x1ZGVzIGEgdmFsaWQsIHByb2xvZ3VlIHBvc2l0aW9uXG5cdFx0XHQvLyBzdHJpY3QgbW9kZSBwcmFnbWEsIGV4ZWN1dGUgY29kZSBieSBpbmplY3RpbmcgYVxuXHRcdFx0Ly8gc2NyaXB0IHRhZyBpbnRvIHRoZSBkb2N1bWVudC5cblx0XHRcdGlmICggY29kZS5pbmRleE9mKCBcInVzZSBzdHJpY3RcIiApID09PSAxICkge1xuXHRcdFx0XHRzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cdFx0XHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgYXZvaWQgdGhlIERPTSBub2RlIGNyZWF0aW9uLCBpbnNlcnRpb25cblx0XHRcdFx0Ly8gYW5kIHJlbW92YWwgYnkgdXNpbmcgYW4gaW5kaXJlY3QgZ2xvYmFsIGV2YWxcblxuXHRcdFx0XHRpbmRpcmVjdCggY29kZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG5cdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0Ly8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuXHRjYW1lbENhc2U6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG5cdH0sXG5cblx0bm9kZU5hbWU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjFcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG5cdC8vIGFyZ3VtZW50cy5cblx0cHJveHk6IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0XHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdFx0Y29udGV4dCA9IGZuO1xuXHRcdFx0Zm4gPSB0bXA7XG5cdFx0fVxuXG5cdFx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0XHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBTaW11bGF0ZWQgYmluZFxuXHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0XHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdFx0fTtcblxuXHRcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdFx0cmV0dXJuIHByb3h5O1xuXHR9LFxuXG5cdG5vdzogRGF0ZS5ub3csXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuLy8gSlNIaW50IHdvdWxkIGVycm9yIG9uIHRoaXMgY29kZSBkdWUgdG8gdGhlIFN5bWJvbCBub3QgYmVpbmcgZGVmaW5lZCBpbiBFUzUuXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuanNoaW50cmMgd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBqdXN0IGRpc2FibGUgSlNIaW50IGZvciB0aGVzZVxuLy8gdGhyZWUgbGluZXMuXG4vKiBqc2hpbnQgaWdub3JlOiBzdGFydCAqL1xuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuLyoganNoaW50IGlnbm9yZTogZW5kICovXG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcbmZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiBpT1MgOC4yIChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXG5cdGlmICggdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjIuMVxuICogaHR0cDovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNS0xMC0xN1xuICovXG4oZnVuY3Rpb24oIHdpbmRvdyApIHtcblxudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gR2VuZXJhbC1wdXJwb3NlIGNvbnN0YW50c1xuXHRNQVhfTkVHQVRJVkUgPSAxIDw8IDMxLFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXFxceDAwLVxcXFx4YTBdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblxuXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cdHJlc2NhcGUgPSAvJ3xcXFxcL2csXG5cblx0Ly8gQ1NTIGVzY2FwZXMgaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9O1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG5pZHNlbGVjdCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXG5cdFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXG5cdFx0XHRcdC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB3b3JrYXJvdW5kIHRlY2huaXF1ZVxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PThcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0fSBlbHNlIGlmICggY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkpICkge1xuXHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJlc2NhcGUsIFwiXFxcXCQmXCIgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0bmlkc2VsZWN0ID0gcmlkZW50aWZpZXIudGVzdCggbmlkICkgPyBcIiNcIiArIG5pZCA6IFwiW2lkPSdcIiArIG5pZCArIFwiJ11cIjtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1tpXSA9IG5pZHNlbGVjdCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5ld1NlbGVjdG9yICkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHQvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcblx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0fVxuXHRcdHJldHVybiAoY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZGl2IGFuZCBleHBlY3RzIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZGl2ICk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBkaXYucGFyZW50Tm9kZSApIHtcblx0XHRcdGRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBkaXYgKTtcblx0XHR9XG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRkaXYgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0KCB+Yi5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKSAtXG5cdFx0XHQoIH5hLnNvdXJjZUluZGV4IHx8IE1BWF9ORUdBVElWRSApO1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3Rcblx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXG5cdHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXHRyZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBwYXJlbnQsXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2Vcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRpZiAoIChwYXJlbnQgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiYgcGFyZW50LnRvcCAhPT0gcGFyZW50ICkge1xuXHRcdC8vIFN1cHBvcnQ6IElFIDExXG5cdFx0aWYgKCBwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHBhcmVudC5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBwYXJlbnQuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRwYXJlbnQuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkaXYuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFkaXYuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRkaXYuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblx0XHRyZXR1cm4gIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZGl2ICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaW5kIGFuZCBmaWx0ZXJcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBtID8gWyBtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHQvLyBTdXBwb3J0OiBJRTYvN1xuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRkZWxldGUgRXhwci5maW5kW1wiSURcIl07XG5cblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZGl2ICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZGl2LCBcImRpdlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZGl2LCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRpZiAoIGEgPT09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHRcdGlmICggYiA9PT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0cmV0dXJuIGEgPT09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09PSBkb2N1bWVudCA/IDEgOlxuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cdFx0Y3VyID0gYjtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbaV0gPT09IGJwW2ldICkge1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpID9cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuXHRcdFx0YXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdDA7XG5cdH07XG5cblx0cmV0dXJuIGRvY3VtZW50O1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxuXHRleHByID0gZXhwci5yZXBsYWNlKCByYXR0cmlidXRlUXVvdGVzLCBcIj0nJDEnXVwiICk7XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFjb21waWxlckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQocGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkpICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gbm9kZVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHBhcmVudDtcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFswXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2U7XG5cdFx0fSxcblxuXHRcdFwiZGlzYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0pLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9KTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBkaXIgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHwgKG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0aWYgKCAob2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsgZGlyIF0pICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyBkaXIgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWzBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoZWxlbSA9IHRlbXBbaV0pICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbaV0gXSA9ICEobWF0Y2hlckluWyBwb3N0TWFwW2ldIF0gPSBlbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJlxuXHRcdFx0XHRcdFx0KHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIG91dGVybW9zdCApLFxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwpICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuXHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuXHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRzdXBwb3J0LmdldEJ5SWQgJiYgY29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdFx0XHRFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdjEgKSB7XG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZGl2MS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSApICYgMTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdGRpdi5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiIDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdGRpdi5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGRpdi5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdHJldHVybiBkaXYuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHZhbDtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0pO1xufVxuXG5yZXR1cm4gU2l6emxlO1xuXG59KSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcbmpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcblxuXG5cbnZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW1xcdy1dKylcXHMqXFwvPz4oPzo8XFwvXFwxPnwpJC8gKTtcblxuXG5cbnZhciByaXNTaW1wbGUgPSAvXi5bXjojXFxbXFwuLF0qJC87XG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cblx0fVxuXG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9ICk7XG5cblx0fVxuXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRpZiAoIHJpc1NpbXBsZS50ZXN0KCBxdWFsaWZpZXIgKSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcblx0XHR9XG5cblx0XHRxdWFsaWZpZXIgPSBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzICk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHR9ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRyZXR1cm4gZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgP1xuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXSA6XG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHRcdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdC8vIE5lZWRlZCBiZWNhdXNlICQoIHNlbGVjdG9yLCBjb250ZXh0ICkgYmVjb21lcyAkKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKVxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZSggcmV0ICkgOiByZXQgKTtcblx0XHRyZXQuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yID8gdGhpcy5zZWxlY3RvciArIFwiIFwiICsgc2VsZWN0b3IgOiBzZWxlY3Rvcjtcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0qKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBCbGFja2JlcnJ5IDQuNlxuXHRcdFx0XHRcdC8vIGdFQklEIHJldHVybnMgbm9kZXMgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAoIzY5NjMpXG5cdFx0XHRcdFx0aWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5jb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gdGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yLnNlbGVjdG9yICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3Iuc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBzZWxlY3Rvci5jb250ZXh0O1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0cG9zID0gcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSB8fCB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvcnMsIGNvbnRleHQgfHwgdGhpcy5jb250ZXh0ICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHBvcyA/XG5cdFx0XHRcdFx0cG9zLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuXHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cblx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQgfHwgalF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdHdoaXRlID0gKCAvXFxTKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIGpRdWVyeS50eXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgbGlzdGVuZXIgbGlzdCwgZmluYWwgc3RhdGVcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIFwicmVqZWN0ZWRcIiBdLFxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBqUXVlcnkuaXNGdW5jdGlvbiggZm5zWyBpIF0gKSAmJiBmbnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZFsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdIGZvciBmb3J3YXJkaW5nIGFjdGlvbnMgdG8gbmV3RGVmZXJcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMgPT09IHByb21pc2UgPyBuZXdEZWZlci5wcm9taXNlKCkgOiB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdHByb21pc2UucGlwZSA9IHByb21pc2UudGhlbjtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDMgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZVsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdC8vIHN0YXRlID0gWyByZXNvbHZlZCB8IHJlamVjdGVkIF1cblx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXG5cdFx0XHRcdC8vIFsgcmVqZWN0X2xpc3QgfCByZXNvbHZlX2xpc3QgXS5kaXNhYmxlOyBwcm9ncmVzc19saXN0LmxvY2tcblx0XHRcdFx0fSwgdHVwbGVzWyBpIF4gMSBdWyAyIF0uZGlzYWJsZSwgdHVwbGVzWyAyIF1bIDIgXS5sb2NrICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGRlZmVycmVkWyByZXNvbHZlIHwgcmVqZWN0IHwgbm90aWZ5IF1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHByb21pc2UgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzdWJvcmRpbmF0ZSAvKiAsIC4uLiwgc3Vib3JkaW5hdGVOICovICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblx0XHRcdGxlbmd0aCA9IHJlc29sdmVWYWx1ZXMubGVuZ3RoLFxuXG5cdFx0XHQvLyB0aGUgY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBsZW5ndGggIT09IDEgfHxcblx0XHRcdFx0KCBzdWJvcmRpbmF0ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggc3Vib3JkaW5hdGUucHJvbWlzZSApICkgPyBsZW5ndGggOiAwLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkLlxuXHRcdFx0Ly8gSWYgcmVzb2x2ZVZhbHVlcyBjb25zaXN0IG9mIG9ubHkgYSBzaW5nbGUgRGVmZXJyZWQsIGp1c3QgdXNlIHRoYXQuXG5cdFx0XHRkZWZlcnJlZCA9IHJlbWFpbmluZyA9PT0gMSA/IHN1Ym9yZGluYXRlIDogalF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIFVwZGF0ZSBmdW5jdGlvbiBmb3IgYm90aCByZXNvbHZlIGFuZCBwcm9ncmVzcyB2YWx1ZXNcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSwgY29udGV4dHMsIHZhbHVlcyApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRjb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHR2YWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoIHZhbHVlcyA9PT0gcHJvZ3Jlc3NWYWx1ZXMgKSB7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBjb250ZXh0cywgdmFsdWVzICk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjb250ZXh0cywgdmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblxuXHRcdFx0cHJvZ3Jlc3NWYWx1ZXMsIHByb2dyZXNzQ29udGV4dHMsIHJlc29sdmVDb250ZXh0cztcblxuXHRcdC8vIEFkZCBsaXN0ZW5lcnMgdG8gRGVmZXJyZWQgc3Vib3JkaW5hdGVzOyB0cmVhdCBvdGhlcnMgYXMgcmVzb2x2ZWRcblx0XHRpZiAoIGxlbmd0aCA+IDEgKSB7XG5cdFx0XHRwcm9ncmVzc1ZhbHVlcyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRwcm9ncmVzc0NvbnRleHRzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0LnByb2dyZXNzKCB1cGRhdGVGdW5jKCBpLCBwcm9ncmVzc0NvbnRleHRzLCBwcm9ncmVzc1ZhbHVlcyApIClcblx0XHRcdFx0XHRcdC5kb25lKCB1cGRhdGVGdW5jKCBpLCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKSApXG5cdFx0XHRcdFx0XHQuZmFpbCggZGVmZXJyZWQucmVqZWN0ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0LS1yZW1haW5pbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJZiB3ZSdyZSBub3Qgd2FpdGluZyBvbiBhbnl0aGluZywgcmVzb2x2ZSB0aGUgbWFzdGVyXG5cdFx0aWYgKCAhcmVtYWluaW5nICkge1xuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3Q7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHQvLyBBZGQgdGhlIGNhbGxiYWNrXG5cdGpRdWVyeS5yZWFkeS5wcm9taXNlKCkuZG9uZSggZm4gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIb2xkIChvciByZWxlYXNlKSB0aGUgcmVhZHkgZXZlbnRcblx0aG9sZFJlYWR5OiBmdW5jdGlvbiggaG9sZCApIHtcblx0XHRpZiAoIGhvbGQgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cblx0XHQvLyBUcmlnZ2VyIGFueSBib3VuZCByZWFkeSBldmVudHNcblx0XHRpZiAoIGpRdWVyeS5mbi50cmlnZ2VySGFuZGxlciApIHtcblx0XHRcdGpRdWVyeSggZG9jdW1lbnQgKS50cmlnZ2VySGFuZGxlciggXCJyZWFkeVwiICk7XG5cdFx0XHRqUXVlcnkoIGRvY3VtZW50ICkub2ZmKCBcInJlYWR5XCIgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuLyoqXG4gKiBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuICovXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbmpRdWVyeS5yZWFkeS5wcm9taXNlID0gZnVuY3Rpb24oIG9iaiApIHtcblx0aWYgKCAhcmVhZHlMaXN0ICkge1xuXG5cdFx0cmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cblx0XHQvLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuXHRcdC8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuXHRcdC8vIFN1cHBvcnQ6IElFOS0xMCBvbmx5XG5cdFx0Ly8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5cdFx0aWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0XHRcdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdFx0XHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHRcdFx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZWFkeUxpc3QucHJvbWlzZSggb2JqICk7XG59O1xuXG4vLyBLaWNrIG9mZiB0aGUgRE9NIHJlYWR5IGNoZWNrIGV2ZW4gaWYgdGhlIHVzZXIgZG9lcyBub3RcbmpRdWVyeS5yZWFkeS5wcm9taXNlKCk7XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggalF1ZXJ5LnR5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhalF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjaGFpbmFibGUgP1xuXHRcdGVsZW1zIDpcblxuXHRcdC8vIEdldHNcblx0XHRidWxrID9cblx0XHRcdGZuLmNhbGwoIGVsZW1zICkgOlxuXHRcdFx0bGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdC8qIGpzaGludCAtVzAxOCAqL1xuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0cmVnaXN0ZXI6IGZ1bmN0aW9uKCBvd25lciwgaW5pdGlhbCApIHtcblx0XHR2YXIgdmFsdWUgPSBpbml0aWFsIHx8IHt9O1xuXG5cdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlLCBub24td3JpdGFibGUgcHJvcGVydHlcblx0XHQvLyBjb25maWd1cmFiaWxpdHkgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdC8vIGRlbGV0ZWQgd2l0aCB0aGUgZGVsZXRlIG9wZXJhdG9yXG5cdFx0fSBlbHNlIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0cmV0dXJuIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0fSxcblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0aWYgKCAhYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblx0XHRcdHJldHVybiB7fTtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBkYXRhIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVbIHByb3AgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGtleSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgc3RvcmVkO1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRzdG9yZWQgPSB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXG5cdFx0XHRyZXR1cm4gc3RvcmVkICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRzdG9yZWQgOiB0aGlzLmdldCggb3duZXIsIGpRdWVyeS5jYW1lbENhc2UoIGtleSApICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLCBuYW1lLCBjYW1lbCxcblx0XHRcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLnJlZ2lzdGVyKCBvd25lciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIGtleSApICkge1xuXG5cdFx0XHRcdC8vIElmIFwibmFtZVwiIGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2hlbiBkYXRhIGlzIGluaXRpYWxseSBjcmVhdGVkLCB2aWEgKFwia2V5XCIsIFwidmFsXCIpIHNpZ25hdHVyZSxcblx0XHRcdFx0Ly8ga2V5cyB3aWxsIGJlIGNvbnZlcnRlZCB0byBjYW1lbENhc2UuXG5cdFx0XHRcdC8vIFNpbmNlIHRoZXJlIGlzIG5vIHdheSB0byB0ZWxsIF9ob3dfIGEga2V5IHdhcyBhZGRlZCwgcmVtb3ZlXG5cdFx0XHRcdC8vIGJvdGggcGxhaW4ga2V5IGFuZCBjYW1lbENhc2Uga2V5LiAjMTI3ODZcblx0XHRcdFx0Ly8gVGhpcyB3aWxsIG9ubHkgcGVuYWxpemUgdGhlIGFycmF5IGFyZ3VtZW50IHBhdGguXG5cdFx0XHRcdG5hbWUgPSBrZXkuY29uY2F0KCBrZXkubWFwKCBqUXVlcnkuY2FtZWxDYXNlICkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhbWVsID0galF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gVHJ5IHRoZSBzdHJpbmcgYXMgYSBrZXkgYmVmb3JlIGFueSBtYW5pcHVsYXRpb25cblx0XHRcdFx0aWYgKCBrZXkgaW4gY2FjaGUgKSB7XG5cdFx0XHRcdFx0bmFtZSA9IFsga2V5LCBjYW1lbCBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0bmFtZSA9IGNhbWVsO1xuXHRcdFx0XHRcdG5hbWUgPSBuYW1lIGluIGNhY2hlID9cblx0XHRcdFx0XHRcdFsgbmFtZSBdIDogKCBuYW1lLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsgbmFtZVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9IDM1LTQ1K1xuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDdcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhID09PSBcInRydWVcIiA/IHRydWUgOlxuXHRcdFx0XHRcdGRhdGEgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcIm51bGxcIiA/IG51bGwgOlxuXG5cdFx0XHRcdFx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0XHRcdFx0XHQrZGF0YSArIFwiXCIgPT09IGRhdGEgPyArZGF0YSA6XG5cdFx0XHRcdFx0cmJyYWNlLnRlc3QoIGRhdGEgKSA/IGpRdWVyeS5wYXJzZUpTT04oIGRhdGEgKSA6XG5cdFx0XHRcdFx0ZGF0YTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTExK1xuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGEsIGNhbWVsS2V5O1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyB3aXRoIHRoZSBrZXkgYXMtaXNcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICkgfHxcblxuXHRcdFx0XHRcdC8vIFRyeSB0byBmaW5kIGRhc2hlZCBrZXkgaWYgaXQgZXhpc3RzIChnaC0yNzc5KVxuXHRcdFx0XHRcdC8vIFRoaXMgaXMgZm9yIDIuMi54IG9ubHlcblx0XHRcdFx0XHRkYXRhVXNlci5nZXQoIGVsZW0sIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKSApO1xuXG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FtZWxLZXkgPSBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIHdpdGggdGhlIGtleSBjYW1lbGl6ZWRcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwgY2FtZWxLZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwgY2FtZWxLZXksIHVuZGVmaW5lZCApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdGNhbWVsS2V5ID0galF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICk7XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIEZpcnN0LCBhdHRlbXB0IHRvIHN0b3JlIGEgY29weSBvciByZWZlcmVuY2Ugb2YgYW55XG5cdFx0XHRcdC8vIGRhdGEgdGhhdCBtaWdodCd2ZSBiZWVuIHN0b3JlIHdpdGggYSBjYW1lbENhc2VkIGtleS5cblx0XHRcdFx0dmFyIGRhdGEgPSBkYXRhVXNlci5nZXQoIHRoaXMsIGNhbWVsS2V5ICk7XG5cblx0XHRcdFx0Ly8gRm9yIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGUgaW50ZXJvcCwgd2UgaGF2ZSB0b1xuXHRcdFx0XHQvLyBzdG9yZSBwcm9wZXJ0eSBuYW1lcyB3aXRoIGRhc2hlcyBpbiBhIGNhbWVsQ2FzZSBmb3JtLlxuXHRcdFx0XHQvLyBUaGlzIG1pZ2h0IG5vdCBhcHBseSB0byBhbGwgcHJvcGVydGllcy4uLipcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBjYW1lbEtleSwgdmFsdWUgKTtcblxuXHRcdFx0XHQvLyAqLi4uIEluIHRoZSBjYXNlIG9mIHByb3BlcnRpZXMgdGhhdCBtaWdodCBfYWN0dWFsbHlfXG5cdFx0XHRcdC8vIGhhdmUgZGFzaGVzLCB3ZSBuZWVkIHRvIGFsc28gc3RvcmUgYSBjb3B5IG9mIHRoYXRcblx0XHRcdFx0Ly8gdW5jaGFuZ2VkIHByb3BlcnR5LlxuXHRcdFx0XHRpZiAoIGtleS5pbmRleE9mKCBcIi1cIiApID4gLTEgJiYgZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgalF1ZXJ5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW4gbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCIgfHxcblx0XHRcdCFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHR9O1xuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLFxuXHRcdHNjYWxlID0gMSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0d2Vlbi5jdXIoKTsgfSA6XG5cdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTsgfSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0ZG8ge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyBpdGVyYXRpb24gemVyb2VkIG91dCwgZG91YmxlIHVudGlsIHdlIGdldCAqc29tZXRoaW5nKi5cblx0XHRcdC8vIFVzZSBzdHJpbmcgZm9yIGRvdWJsaW5nIHNvIHdlIGRvbid0IGFjY2lkZW50YWxseSBzZWUgc2NhbGUgYXMgdW5jaGFuZ2VkIGJlbG93XG5cdFx0XHRzY2FsZSA9IHNjYWxlIHx8IFwiLjVcIjtcblxuXHRcdFx0Ly8gQWRqdXN0IGFuZCBhcHBseVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXG5cdFx0Ly8gQnJlYWsgdGhlIGxvb3AgaWYgc2NhbGUgaXMgdW5jaGFuZ2VkIG9yIHBlcmZlY3QsIG9yIGlmIHdlJ3ZlIGp1c3QgaGFkIGVub3VnaC5cblx0XHR9IHdoaWxlIChcblx0XHRcdHNjYWxlICE9PSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsICkgJiYgc2NhbGUgIT09IDEgJiYgLS1tYXhJdGVyYXRpb25zXG5cdFx0KTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbnZhciBydGFnTmFtZSA9ICggLzwoW1xcdzotXSspLyApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRTlcblx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG4vLyBTdXBwb3J0OiBJRTlcbndyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxuXHR2YXIgcmV0ID0gdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICkgOlxuXHRcdFx0dHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiA/XG5cdFx0XHRcdGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICkgOlxuXHRcdFx0W107XG5cblx0cmV0dXJuIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBqUXVlcnkubm9kZU5hbWUoIGNvbnRleHQsIHRhZyApID9cblx0XHRqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKSA6XG5cdFx0cmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgY29udGFpbnMsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCBqUXVlcnkudHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBQaGFudG9tSlM8MlxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjEsIFBoYW50b21KUzwyXG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBjb250YWlucyApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wLTQuMywgU2FmYXJpPD01LjFcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IFNhZmFyaTw9NS4xLCBBbmRyb2lkPDQuMlxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFPD0xMStcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcbn0gKSgpO1xuXG5cbnZhclxuXHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTdXBwb3J0OiBJRTlcbi8vIFNlZSAjMTMzOTMgZm9yIG1vcmUgaW5mb1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0ZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApO1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cdFx0XHRoYW5kbGVycyA9ICggZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbIDAgXSA9IGV2ZW50O1xuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yIDIpIGhhdmUgbmFtZXNwYWNlKHMpXG5cdFx0XHRcdC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBtYXRjaGVzLCBzZWwsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBTdXBwb3J0IChhdCBsZWFzdCk6IENocm9tZSwgSUU5XG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICgjMTMxODApXG5cdFx0Ly9cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PD00Mitcblx0XHQvLyBBdm9pZCBub24tbGVmdC1jbGljayBpbiBGRiBidXQgZG9uJ3QgYmxvY2sgSUUgcmFkaW8gZXZlbnRzICgjMzg2MSwgZ2gtMjM0Mylcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiYgY3VyLm5vZGVUeXBlICYmXG5cdFx0XHQoIGV2ZW50LnR5cGUgIT09IFwiY2xpY2tcIiB8fCBpc05hTiggZXZlbnQuYnV0dG9uICkgfHwgZXZlbnQuYnV0dG9uIDwgMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICggY3VyLmRpc2FibGVkICE9PSB0cnVlIHx8IGV2ZW50LnR5cGUgIT09IFwiY2xpY2tcIiApICkge1xuXHRcdFx0XHRcdG1hdGNoZXMgPSBbXTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlcyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IHRoaXMsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdC8vIEluY2x1ZGVzIHNvbWUgZXZlbnQgcHJvcHMgc2hhcmVkIGJ5IEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50XG5cdHByb3BzOiAoIFwiYWx0S2V5IGJ1YmJsZXMgY2FuY2VsYWJsZSBjdHJsS2V5IGN1cnJlbnRUYXJnZXQgZGV0YWlsIGV2ZW50UGhhc2UgXCIgK1xuXHRcdFwibWV0YUtleSByZWxhdGVkVGFyZ2V0IHNoaWZ0S2V5IHRhcmdldCB0aW1lU3RhbXAgdmlldyB3aGljaFwiICkuc3BsaXQoIFwiIFwiICksXG5cblx0Zml4SG9va3M6IHt9LFxuXG5cdGtleUhvb2tzOiB7XG5cdFx0cHJvcHM6IFwiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZVwiLnNwbGl0KCBcIiBcIiApLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50LndoaWNoID0gb3JpZ2luYWwuY2hhckNvZGUgIT0gbnVsbCA/IG9yaWdpbmFsLmNoYXJDb2RlIDogb3JpZ2luYWwua2V5Q29kZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblx0fSxcblxuXHRtb3VzZUhvb2tzOiB7XG5cdFx0cHJvcHM6ICggXCJidXR0b24gYnV0dG9ucyBjbGllbnRYIGNsaWVudFkgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIFwiICtcblx0XHRcdFwic2NyZWVuWCBzY3JlZW5ZIHRvRWxlbWVudFwiICkuc3BsaXQoIFwiIFwiICksXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xuXHRcdFx0dmFyIGV2ZW50RG9jLCBkb2MsIGJvZHksXG5cdFx0XHRcdGJ1dHRvbiA9IG9yaWdpbmFsLmJ1dHRvbjtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHBhZ2VYL1kgaWYgbWlzc2luZyBhbmQgY2xpZW50WC9ZIGF2YWlsYWJsZVxuXHRcdFx0aWYgKCBldmVudC5wYWdlWCA9PSBudWxsICYmIG9yaWdpbmFsLmNsaWVudFggIT0gbnVsbCApIHtcblx0XHRcdFx0ZXZlbnREb2MgPSBldmVudC50YXJnZXQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcblx0XHRcdFx0ZG9jID0gZXZlbnREb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0XHRib2R5ID0gZXZlbnREb2MuYm9keTtcblxuXHRcdFx0XHRldmVudC5wYWdlWCA9IG9yaWdpbmFsLmNsaWVudFggK1xuXHRcdFx0XHRcdCggZG9jICYmIGRvYy5zY3JvbGxMZWZ0IHx8IGJvZHkgJiYgYm9keS5zY3JvbGxMZWZ0IHx8IDAgKSAtXG5cdFx0XHRcdFx0KCBkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCApO1xuXHRcdFx0XHRldmVudC5wYWdlWSA9IG9yaWdpbmFsLmNsaWVudFkgK1xuXHRcdFx0XHRcdCggZG9jICYmIGRvYy5zY3JvbGxUb3AgIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgIHx8IDAgKSAtXG5cdFx0XHRcdFx0KCBkb2MgJiYgZG9jLmNsaWVudFRvcCAgfHwgYm9keSAmJiBib2R5LmNsaWVudFRvcCAgfHwgMCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0XHQvLyBOb3RlOiBidXR0b24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIGRvbid0IHVzZSBpdFxuXHRcdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGV2ZW50LndoaWNoID0gKCBidXR0b24gJiAxID8gMSA6ICggYnV0dG9uICYgMiA/IDMgOiAoIGJ1dHRvbiAmIDQgPyAyIDogMCApICkgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRpZiAoIGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdICkge1xuXHRcdFx0cmV0dXJuIGV2ZW50O1xuXHRcdH1cblxuXHRcdC8vIENyZWF0ZSBhIHdyaXRhYmxlIGNvcHkgb2YgdGhlIGV2ZW50IG9iamVjdCBhbmQgbm9ybWFsaXplIHNvbWUgcHJvcGVydGllc1xuXHRcdHZhciBpLCBwcm9wLCBjb3B5LFxuXHRcdFx0dHlwZSA9IGV2ZW50LnR5cGUsXG5cdFx0XHRvcmlnaW5hbEV2ZW50ID0gZXZlbnQsXG5cdFx0XHRmaXhIb29rID0gdGhpcy5maXhIb29rc1sgdHlwZSBdO1xuXG5cdFx0aWYgKCAhZml4SG9vayApIHtcblx0XHRcdHRoaXMuZml4SG9va3NbIHR5cGUgXSA9IGZpeEhvb2sgPVxuXHRcdFx0XHRybW91c2VFdmVudC50ZXN0KCB0eXBlICkgPyB0aGlzLm1vdXNlSG9va3MgOlxuXHRcdFx0XHRya2V5RXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5rZXlIb29rcyA6XG5cdFx0XHRcdHt9O1xuXHRcdH1cblx0XHRjb3B5ID0gZml4SG9vay5wcm9wcyA/IHRoaXMucHJvcHMuY29uY2F0KCBmaXhIb29rLnByb3BzICkgOiB0aGlzLnByb3BzO1xuXG5cdFx0ZXZlbnQgPSBuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cblx0XHRpID0gY29weS5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRwcm9wID0gY29weVsgaSBdO1xuXHRcdFx0ZXZlbnRbIHByb3AgXSA9IG9yaWdpbmFsRXZlbnRbIHByb3AgXTtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBDb3Jkb3ZhIDIuNSAoV2ViS2l0KSAoIzEzMjU1KVxuXHRcdC8vIEFsbCBldmVudHMgc2hvdWxkIGhhdmUgYSB0YXJnZXQ7IENvcmRvdmEgZGV2aWNlcmVhZHkgZG9lc24ndFxuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGRvY3VtZW50O1xuXHRcdH1cblxuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA2LjArLCBDaHJvbWU8Mjhcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdGlmICggZXZlbnQudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZXZlbnQudGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZpeEhvb2suZmlsdGVyID8gZml4SG9vay5maWx0ZXIoIGV2ZW50LCBvcmlnaW5hbEV2ZW50ICkgOiBldmVudDtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Zm9jdXM6IHtcblxuXHRcdFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcblx0XHR9LFxuXHRcdGJsdXI6IHtcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyICkge1xuXHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgJiYgdGhpcy5jbGljayAmJiBqUXVlcnkubm9kZU5hbWUoIHRoaXMsIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHRoaXMuY2xpY2soKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZXZlbnQudGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IGpRdWVyeS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcdzotXSspW14+XSopXFwvPi9naSxcblxuXHQvLyBTdXBwb3J0OiBJRSAxMC0xMSwgRWRnZSAxMDI0MCtcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cnNjcmlwdFR5cGVNYXNrZWQgPSAvXnRydWVcXC8oLiopLyxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG4vLyBNYW5pcHVsYXRpbmcgdGFibGVzIHJlcXVpcmVzIGEgdGJvZHlcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRqUXVlcnkubm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgP1xuXG5cdFx0ZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJ0Ym9keVwiIClbIDAgXSB8fFxuXHRcdFx0ZWxlbS5hcHBlbmRDaGlsZCggZWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwidGJvZHlcIiApICkgOlxuXHRcdGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdHZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoIGVsZW0udHlwZSApO1xuXG5cdGlmICggbWF0Y2ggKSB7XG5cdFx0ZWxlbS50eXBlID0gbWF0Y2hbIDEgXTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0cGRhdGFDdXIuZXZlbnRzID0ge307XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCBpc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBQaGFudG9tSlM8MlxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0gMzUtNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9IDM1LTQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0Ly8gS2VlcCBkb21NYW5pcCBleHBvc2VkIHVudGlsIDMuMCAoZ2gtMjIyNSlcblx0ZG9tTWFuaXA6IGRvbU1hbmlwLFxuXG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzXG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcblxuXG52YXIgaWZyYW1lLFxuXHRlbGVtZGlzcGxheSA9IHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3hcblx0XHQvLyBXZSBoYXZlIHRvIHByZS1kZWZpbmUgdGhlc2UgdmFsdWVzIGZvciBGRiAoIzEwMjI3KVxuXHRcdEhUTUw6IFwiYmxvY2tcIixcblx0XHRCT0RZOiBcImJsb2NrXCJcblx0fTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgYWN0dWFsIGRpc3BsYXkgb2YgYSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBub2RlTmFtZSBvZiB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGRvYyBEb2N1bWVudCBvYmplY3RcbiAqL1xuXG4vLyBDYWxsZWQgb25seSBmcm9tIHdpdGhpbiBkZWZhdWx0RGlzcGxheVxuZnVuY3Rpb24gYWN0dWFsRGlzcGxheSggbmFtZSwgZG9jICkge1xuXHR2YXIgZWxlbSA9IGpRdWVyeSggZG9jLmNyZWF0ZUVsZW1lbnQoIG5hbWUgKSApLmFwcGVuZFRvKCBkb2MuYm9keSApLFxuXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW1bIDAgXSwgXCJkaXNwbGF5XCIgKTtcblxuXHQvLyBXZSBkb24ndCBoYXZlIGFueSBkYXRhIHN0b3JlZCBvbiB0aGUgZWxlbWVudCxcblx0Ly8gc28gdXNlIFwiZGV0YWNoXCIgbWV0aG9kIGFzIGZhc3Qgd2F5IHRvIGdldCByaWQgb2YgdGhlIGVsZW1lbnRcblx0ZWxlbS5kZXRhY2goKTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuLyoqXG4gKiBUcnkgdG8gZGV0ZXJtaW5lIHRoZSBkZWZhdWx0IGRpc3BsYXkgdmFsdWUgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IG5vZGVOYW1lXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHREaXNwbGF5KCBub2RlTmFtZSApIHtcblx0dmFyIGRvYyA9IGRvY3VtZW50LFxuXHRcdGRpc3BsYXkgPSBlbGVtZGlzcGxheVsgbm9kZU5hbWUgXTtcblxuXHRpZiAoICFkaXNwbGF5ICkge1xuXHRcdGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7XG5cblx0XHQvLyBJZiB0aGUgc2ltcGxlIHdheSBmYWlscywgcmVhZCBmcm9tIGluc2lkZSBhbiBpZnJhbWVcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiIHx8ICFkaXNwbGF5ICkge1xuXG5cdFx0XHQvLyBVc2UgdGhlIGFscmVhZHktY3JlYXRlZCBpZnJhbWUgaWYgcG9zc2libGVcblx0XHRcdGlmcmFtZSA9ICggaWZyYW1lIHx8IGpRdWVyeSggXCI8aWZyYW1lIGZyYW1lYm9yZGVyPScwJyB3aWR0aD0nMCcgaGVpZ2h0PScwJy8+XCIgKSApXG5cdFx0XHRcdC5hcHBlbmRUbyggZG9jLmRvY3VtZW50RWxlbWVudCApO1xuXG5cdFx0XHQvLyBBbHdheXMgd3JpdGUgYSBuZXcgSFRNTCBza2VsZXRvbiBzbyBXZWJraXQgYW5kIEZpcmVmb3ggZG9uJ3QgY2hva2Ugb24gcmV1c2Vcblx0XHRcdGRvYyA9IGlmcmFtZVsgMCBdLmNvbnRlbnREb2N1bWVudDtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUVcblx0XHRcdGRvYy53cml0ZSgpO1xuXHRcdFx0ZG9jLmNsb3NlKCk7XG5cblx0XHRcdGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7XG5cdFx0XHRpZnJhbWUuZGV0YWNoKCk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RvcmUgdGhlIGNvcnJlY3QgZGVmYXVsdCBkaXNwbGF5XG5cdFx0ZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXHR9XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG52YXIgcm1hcmdpbiA9ICggL15tYXJnaW4vICk7XG5cbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUU8PTExKywgRmlyZWZveDw9MzArICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgcGl4ZWxNYXJnaW5SaWdodFZhbCwgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowO3dpZHRoOjhweDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHg7XCIgK1xuXHRcdFwicGFkZGluZzowO21hcmdpbi10b3A6MXB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyOSwgQW5kcm9pZCAyLjNcblx0XHRcdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcInRvcDoxJTt3aWR0aDo1MCVcIjtcblx0XHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSBkaXZTdHlsZS5tYXJnaW5MZWZ0ID09PSBcIjJweFwiO1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI1MCVcIjtcblx0XHRwaXhlbE1hcmdpblJpZ2h0VmFsID0gZGl2U3R5bGUubWFyZ2luUmlnaHQgPT09IFwiNHB4XCI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXHR9XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBUaGlzIHRlc3QgaXMgZXhlY3V0ZWQgb25seSBvbmNlIGJ1dCB3ZSBzdGlsbCBkbyBtZW1vaXppbmdcblx0XHRcdC8vIHNpbmNlIHdlIGNhbiB1c2UgdGhlIGJveFNpemluZ1JlbGlhYmxlIHByZS1jb21wdXRpbmcuXG5cdFx0XHQvLyBObyBuZWVkIHRvIGNoZWNrIGlmIHRoZSB0ZXN0IHdhcyBhbHJlYWR5IHBlcmZvcm1lZCwgdGhvdWdoLlxuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBib3hTaXppbmdSZWxpYWJsZVZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wLTQuM1xuXHRcdFx0Ly8gV2UncmUgY2hlY2tpbmcgZm9yIGJveFNpemluZ1JlbGlhYmxlVmFsIGhlcmUgaW5zdGVhZCBvZiBwaXhlbE1hcmdpblJpZ2h0VmFsXG5cdFx0XHQvLyBzaW5jZSB0aGF0IGNvbXByZXNzZXMgYmV0dGVyIGFuZCB0aGV5J3JlIGNvbXB1dGVkIHRvZ2V0aGVyIGFueXdheS5cblx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwaXhlbE1hcmdpblJpZ2h0VmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IG9ubHksIEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gMzdcblx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcblx0XHRcdC8vIENoZWNrIGlmIGRpdiB3aXRoIGV4cGxpY2l0IHdpZHRoIGFuZCBubyBtYXJnaW4tcmlnaHQgaW5jb3JyZWN0bHlcblx0XHRcdC8vIGdldHMgY29tcHV0ZWQgbWFyZ2luLXJpZ2h0IGJhc2VkIG9uIHdpZHRoIG9mIGNvbnRhaW5lci4gKCMzMzMzKVxuXHRcdFx0Ly8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0XG5cdFx0XHQvLyBUaGlzIHN1cHBvcnQgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBvbmNlIHNvIG5vIG1lbW9pemluZyBpcyBuZWVkZWQuXG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHRtYXJnaW5EaXYgPSBkaXYuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHQvLyBSZXNldCBDU1M6IGJveC1zaXppbmc7IGRpc3BsYXk7IG1hcmdpbjsgYm9yZGVyOyBwYWRkaW5nXG5cdFx0XHRtYXJnaW5EaXYuc3R5bGUuY3NzVGV4dCA9IGRpdi5zdHlsZS5jc3NUZXh0ID1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0XHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcblx0XHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveDtcIiArXG5cdFx0XHRcdFwiZGlzcGxheTpibG9jazttYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjBcIjtcblx0XHRcdG1hcmdpbkRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IG1hcmdpbkRpdi5zdHlsZS53aWR0aCA9IFwiMFwiO1xuXHRcdFx0ZGl2LnN0eWxlLndpZHRoID0gXCIxcHhcIjtcblx0XHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHRcdHJldCA9ICFwYXJzZUZsb2F0KCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggbWFyZ2luRGl2ICkubWFyZ2luUmlnaHQgKTtcblxuXHRcdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblx0XHRcdGRpdi5yZW1vdmVDaGlsZCggbWFyZ2luRGl2ICk7XG5cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXHRyZXQgPSBjb21wdXRlZCA/IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdIDogdW5kZWZpbmVkO1xuXG5cdC8vIFN1cHBvcnQ6IE9wZXJhIDEyLjF4IG9ubHlcblx0Ly8gRmFsbCBiYWNrIHRvIHN0eWxlIGV2ZW4gd2l0aG91dCBjb21wdXRlZFxuXHQvLyBjb21wdXRlZCBpcyB1bmRlZmluZWQgZm9yIGVsZW1zIG9uIGRvY3VtZW50IGZyYWdtZW50c1xuXHRpZiAoICggcmV0ID09PSBcIlwiIHx8IHJldCA9PT0gdW5kZWZpbmVkICkgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRTlcblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBvbmx5IG5lZWRlZCBmb3IgLmNzcygnZmlsdGVyJykgKCMxMjUzNylcblx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbE1hcmdpblJpZ2h0KCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJtYXJnaW4udGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk9cIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGU7XG5cbi8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSwgaXNCb3JkZXJCb3gsIHN0eWxlcyApIHtcblx0dmFyIGkgPSBleHRyYSA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApID9cblxuXHRcdC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxuXHRcdDQgOlxuXG5cdFx0Ly8gT3RoZXJ3aXNlIGluaXRpYWxpemUgZm9yIGhvcml6b250YWwgb3IgdmVydGljYWwgcHJvcGVydGllc1xuXHRcdG5hbWUgPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXG5cdFx0dmFsID0gMDtcblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW4sIHNvIGFkZCBpdCBpZiB3ZSB3YW50IGl0XG5cdFx0aWYgKCBleHRyYSA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBleHRyYSArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBib3JkZXItYm94IGluY2x1ZGVzIHBhZGRpbmcsIHNvIHJlbW92ZSBpdCBpZiB3ZSB3YW50IGNvbnRlbnRcblx0XHRcdGlmICggZXh0cmEgPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50IG5vciBwYWRkaW5nLCBzbyBhZGQgYm9yZGVyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBvZmZzZXQgcHJvcGVydHksIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGJvcmRlci1ib3ggdmFsdWVcblx0dmFyIHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlLFxuXHRcdHZhbCA9IG5hbWUgPT09IFwid2lkdGhcIiA/IGVsZW0ub2Zmc2V0V2lkdGggOiBlbGVtLm9mZnNldEhlaWdodCxcblx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogSUUxMSBvbmx5XG5cdC8vIEluIElFIDExIGZ1bGxzY3JlZW4gZWxlbWVudHMgaW5zaWRlIG9mIGFuIGlmcmFtZSBoYXZlXG5cdC8vIDEwMHggdG9vIHNtYWxsIGRpbWVuc2lvbnMgKGdoLTE3NjQpLlxuXHRpZiAoIGRvY3VtZW50Lm1zRnVsbHNjcmVlbkVsZW1lbnQgJiYgd2luZG93LnRvcCAhPT0gd2luZG93ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUxMSBvbmx5XG5cdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRpZiAoIGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHR2YWwgPSBNYXRoLnJvdW5kKCBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpWyBuYW1lIF0gKiAxMDAgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBTb21lIG5vbi1odG1sIGVsZW1lbnRzIHJldHVybiB1bmRlZmluZWQgZm9yIG9mZnNldFdpZHRoLCBzbyBjaGVjayBmb3IgbnVsbC91bmRlZmluZWRcblx0Ly8gc3ZnIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjQ5Mjg1XG5cdC8vIE1hdGhNTCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTQ5MTY2OFxuXHRpZiAoIHZhbCA8PSAwIHx8IHZhbCA9PSBudWxsICkge1xuXG5cdFx0Ly8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW5jb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHRpZiAoIHZhbCA8IDAgfHwgdmFsID09IG51bGwgKSB7XG5cdFx0XHR2YWwgPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cblx0XHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0XHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmXG5cdFx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIG5hbWUgXSApO1xuXG5cdFx0Ly8gTm9ybWFsaXplIFwiXCIsIGF1dG8sIGFuZCBwcmVwYXJlIGZvciBleHRyYVxuXHRcdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cdH1cblxuXHQvLyBVc2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0ZWxlbSxcblx0XHRcdG5hbWUsXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLCBoaWRkZW4sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcIm9sZGRpc3BsYXlcIiApO1xuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBSZXNldCB0aGUgaW5saW5lIGRpc3BsYXkgb2YgdGhpcyBlbGVtZW50IHRvIGxlYXJuIGlmIGl0IGlzXG5cdFx0XHQvLyBiZWluZyBoaWRkZW4gYnkgY2FzY2FkZWQgcnVsZXMgb3Igbm90XG5cdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gJiYgZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBlbGVtZW50cyB3aGljaCBoYXZlIGJlZW4gb3ZlcnJpZGRlbiB3aXRoIGRpc3BsYXk6IG5vbmVcblx0XHRcdC8vIGluIGEgc3R5bGVzaGVldCB0byB3aGF0ZXZlciB0aGUgZGVmYXVsdCBicm93c2VyIHN0eWxlIGlzXG5cdFx0XHQvLyBmb3Igc3VjaCBhbiBlbGVtZW50XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbiggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5hY2Nlc3MoXG5cdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRcIm9sZGRpc3BsYXlcIixcblx0XHRcdFx0XHRkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhpZGRlbiA9IGlzSGlkZGVuKCBlbGVtICk7XG5cblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgfHwgIWhpZGRlbiApIHtcblx0XHRcdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0XCJvbGRkaXNwbGF5XCIsXG5cdFx0XHRcdFx0aGlkZGVuID8gZGlzcGxheSA6IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgbW9zdCBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcFxuXHQvLyB0byBhdm9pZCB0aGUgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0aWYgKCAhc2hvdyB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IHNob3cgPyB2YWx1ZXNbIGluZGV4IF0gfHwgXCJcIiA6IFwibm9uZVwiO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHtcblx0XHRcImZsb2F0XCI6IFwiY3NzRmxvYXRcIlxuXHR9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHxcblx0XHRcdCggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG9yaWdOYW1lICkgfHwgb3JpZ05hbWUgKTtcblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fFxuXHRcdFx0KCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggb3JpZ05hbWUgKSB8fCBvcmlnTmFtZSApO1xuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cdFx0XHRcdFx0ZWxlbS5vZmZzZXRXaWR0aCA9PT0gMCA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGV4dHJhICYmIGdldFN0eWxlcyggZWxlbSApLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhICYmIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHQpO1xuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xualF1ZXJ5LmNzc0hvb2tzLm1hcmdpblJpZ2h0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luUmlnaHQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuIHN3YXAoIGVsZW0sIHsgXCJkaXNwbGF5XCI6IFwiaW5saW5lLWJsb2NrXCIgfSxcblx0XHRcdFx0Y3VyQ1NTLCBbIGVsZW0sIFwibWFyZ2luUmlnaHRcIiBdICk7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoICFybWFyZ2luLnRlc3QoIHByZWZpeCApICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW4oIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRTlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH0sXG5cdF9kZWZhdWx0OiBcInN3aW5nXCJcbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIENvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCB0aW1lcklkLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBqUXVlcnkubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNCA7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHQvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCB0d2VlbiwgaG9va3MsIG9sZGZpcmUsIGRpc3BsYXksIGNoZWNrRGlzcGxheSxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW4oIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIEhhbmRsZSBxdWV1ZTogZmFsc2UgcHJvbWlzZXNcblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSGVpZ2h0L3dpZHRoIG92ZXJmbG93IHBhc3Ncblx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCJoZWlnaHRcIiBpbiBwcm9wcyB8fCBcIndpZHRoXCIgaW4gcHJvcHMgKSApIHtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG5vdGhpbmcgc25lYWtzIG91dFxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUU5LTEwIGRvIG5vdFxuXHRcdC8vIGNoYW5nZSB0aGUgb3ZlcmZsb3cgYXR0cmlidXRlIHdoZW4gb3ZlcmZsb3dYIGFuZFxuXHRcdC8vIG92ZXJmbG93WSBhcmUgc2V0IHRvIHRoZSBzYW1lIHZhbHVlXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBTZXQgZGlzcGxheSBwcm9wZXJ0eSB0byBpbmxpbmUtYmxvY2sgZm9yIGhlaWdodC93aWR0aFxuXHRcdC8vIGFuaW1hdGlvbnMgb24gaW5saW5lIGVsZW1lbnRzIHRoYXQgYXJlIGhhdmluZyB3aWR0aC9oZWlnaHQgYW5pbWF0ZWRcblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblxuXHRcdC8vIFRlc3QgZGVmYXVsdCBkaXNwbGF5IGlmIGRpc3BsYXkgaXMgY3VycmVudGx5IFwibm9uZVwiXG5cdFx0Y2hlY2tEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgP1xuXHRcdFx0ZGF0YVByaXYuZ2V0KCBlbGVtLCBcIm9sZGRpc3BsYXlcIiApIHx8IGRlZmF1bHREaXNwbGF5KCBlbGVtLm5vZGVOYW1lICkgOiBkaXNwbGF5O1xuXG5cdFx0aWYgKCBjaGVja0Rpc3BsYXkgPT09IFwiaW5saW5lXCIgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBzaG93L2hpZGUgcGFzc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLmV4ZWMoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGRhdGFTaG93IGxlZnQgb3ZlciBmcm9tIGEgc3RvcHBlZCBoaWRlIG9yIHNob3dcblx0XHRcdFx0Ly8gYW5kIHdlIGFyZSBnb2luZyB0byBwcm9jZWVkIHdpdGggc2hvdywgd2Ugc2hvdWxkIHByZXRlbmQgdG8gYmUgaGlkZGVuXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXG5cdFx0Ly8gQW55IG5vbi1meCB2YWx1ZSBzdG9wcyB1cyBmcm9tIHJlc3RvcmluZyB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXNwbGF5ID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwge30gKTtcblx0XHR9XG5cblx0XHQvLyBTdG9yZSBzdGF0ZSBpZiBpdHMgdG9nZ2xlIC0gZW5hYmxlcyAuc3RvcCgpLnRvZ2dsZSgpIHRvIFwicmV2ZXJzZVwiXG5cdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdH1cblx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdGpRdWVyeSggZWxlbSApLnNob3coKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5KCBlbGVtICkuaGlkZSgpO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHByb3A7XG5cblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHR0d2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXG5cdFx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0XHR0d2Vlbi5lbmQgPSB0d2Vlbi5zdGFydDtcblx0XHRcdFx0XHR0d2Vlbi5zdGFydCA9IHByb3AgPT09IFwid2lkdGhcIiB8fCBwcm9wID09PSBcImhlaWdodFwiID8gMSA6IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0Ly8gSWYgdGhpcyBpcyBhIG5vb3AgbGlrZSAuaGlkZSgpLmhpZGUoKSwgcmVzdG9yZSBhbiBvdmVyd3JpdHRlbiBkaXNwbGF5IHZhbHVlXG5cdH0gZWxzZSBpZiAoICggZGlzcGxheSA9PT0gXCJub25lXCIgPyBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheSApID09PSBcImlubGluZVwiICkge1xuXHRcdHN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5O1xuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRqUXVlcnkucHJveHkoIHJlc3VsdC5zdG9wLCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHQvLyBhdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRyZXR1cm4gYW5pbWF0aW9uLnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90d2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRqUXVlcnkuaXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4Lm9mZiA/IDAgOiB0eXBlb2Ygb3B0LmR1cmF0aW9uID09PSBcIm51bWJlclwiID9cblx0XHRvcHQuZHVyYXRpb24gOiBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyA/XG5cdFx0XHRqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXSA6IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW4gKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBqUXVlcnkubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBDaGVja3MgdGhlIHRpbWVyIGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlbW92ZWRcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRpZiAoIHRpbWVyKCkgKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnRpbWVycy5wb3AoKTtcblx0fVxufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCAhdGltZXJJZCApIHtcblx0XHR0aW1lcklkID0gd2luZG93LnNldEludGVydmFsKCBqUXVlcnkuZngudGljaywgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdHdpbmRvdy5jbGVhckludGVydmFsKCB0aW1lcklkICk7XG5cblx0dGltZXJJZCA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cDovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IGlPUzw9NS4xLCBBbmRyb2lkPD00LjIrXG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRTw9MTErXG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw9Mi4zXG5cdC8vIE9wdGlvbnMgaW5zaWRlIGRpc2FibGVkIHNlbGVjdHMgYXJlIGluY29ycmVjdGx5IG1hcmtlZCBhcyBkaXNhYmxlZFxuXHRzZWxlY3QuZGlzYWJsZWQgPSB0cnVlO1xuXHRzdXBwb3J0Lm9wdERpc2FibGVkID0gIW9wdC5kaXNhYmxlZDtcblxuXHQvLyBTdXBwb3J0OiBJRTw9MTErXG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgYXR0cmlidXRlcyBhcmUgbG93ZXJjYXNlXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSwgcHJvcE5hbWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0cHJvcE5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cblx0XHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGdldCBzcGVjaWFsIHRyZWF0bWVudCAoIzEwODcwKVxuXHRcdFx0XHRpZiAoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHRcdFx0Ly8gU2V0IGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdG8gZmFsc2Vcblx0XHRcdFx0XHRlbGVtWyBwcm9wTmFtZSBdID0gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZTtcblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIGh0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdHJldHVybiB0YWJpbmRleCA/XG5cdFx0XHRcdFx0cGFyc2VJbnQoIHRhYmluZGV4LCAxMCApIDpcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiYgZWxlbS5ocmVmID9cblx0XHRcdFx0XHRcdFx0MCA6XG5cdFx0XHRcdFx0XHRcdC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cbnZhciByY2xhc3MgPSAvW1xcdFxcclxcblxcZl0vZztcblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggXCIgXCIgKyBjdXJWYWx1ZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IGpRdWVyeS50cmltKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCBcIiBcIiArIGN1clZhbHVlICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIGdldENsYXNzKCBlbGVtICkgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nLFxuXHRyc3BhY2VzID0gL1tcXHgyMFxcdFxcclxcblxcZl0rL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIGlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmXG5cdFx0XHRcdFx0XCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0cmV0dXJuIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgP1xuXG5cdFx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRcdHJldC5yZXBsYWNlKCBycmV0dXJuLCBcIlwiICkgOlxuXG5cdFx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdFx0cmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBqUXVlcnkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFMTAtMTErXG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRqUXVlcnkudHJpbSggalF1ZXJ5LnRleHQoIGVsZW0gKSApLnJlcGxhY2UoIHJzcGFjZXMsIFwiIFwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIiB8fCBpbmRleCA8IDAsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoLFxuXHRcdFx0XHRcdGkgPSBpbmRleCA8IDAgP1xuXHRcdFx0XHRcdFx0bWF4IDpcblx0XHRcdFx0XHRcdG9uZSA/IGluZGV4IDogMDtcblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0KCBzdXBwb3J0Lm9wdERpc2FibGVkID9cblx0XHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkIDogb3B0aW9uLmdldEF0dHJpYnV0ZSggXCJkaXNhYmxlZFwiICkgPT09IG51bGwgKSAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFqUXVlcnkubm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC87XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cblx0XHRcdFx0Ly8gUHJldmlvdXNseSwgYG9yaWdpbmFsRXZlbnQ6IHt9YCB3YXMgc2V0IGhlcmUsIHNvIHN0b3BQcm9wYWdhdGlvbiBjYWxsXG5cdFx0XHRcdC8vIHdvdWxkIG5vdCBiZSB0cmlnZ2VyZWQgb24gZG9ub3IgZXZlbnQsIHNpbmNlIGluIG91ciBvd25cblx0XHRcdFx0Ly8galF1ZXJ5LmV2ZW50LnN0b3BQcm9wYWdhdGlvbiBmdW5jdGlvbiB3ZSBoYWQgYSBjaGVjayBmb3IgZXhpc3RlbmNlIG9mXG5cdFx0XHRcdC8vIG9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uIG1ldGhvZCwgc28sIGNvbnNlcXVlbnRseSBpdCB3b3VsZCBiZSBhIG5vb3AuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIEJ1dCBub3csIHRoaXMgXCJzaW11bGF0ZVwiIGZ1bmN0aW9uIGlzIHVzZWQgb25seSBmb3IgZXZlbnRzXG5cdFx0XHRcdC8vIGZvciB3aGljaCBzdG9wUHJvcGFnYXRpb24oKSBpcyBub29wLCBzbyB0aGVyZSBpcyBubyBuZWVkIGZvciB0aGF0IGFueW1vcmUuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIEZvciB0aGUgMS54IGJyYW5jaCB0aG91Z2gsIGd1YXJkIGZvciBcImNsaWNrXCIgYW5kIFwic3VibWl0XCJcblx0XHRcdFx0Ly8gZXZlbnRzIGlzIHN0aWxsIHVzZWQsIGJ1dCB3YXMgbW92ZWQgdG8galF1ZXJ5LmV2ZW50LnN0b3BQcm9wYWdhdGlvbiBmdW5jdGlvblxuXHRcdFx0XHQvLyBiZWNhdXNlIGBvcmlnaW5hbEV2ZW50YCBzaG91bGQgcG9pbnQgdG8gdGhlIG9yaWdpbmFsIGV2ZW50IGZvciB0aGUgY29uc3RhbmN5XG5cdFx0XHRcdC8vIHdpdGggb3RoZXIgZXZlbnRzIGFuZCBmb3IgbW9yZSBmb2N1c2VkIGxvZ2ljXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cblx0XHRpZiAoIGUuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxualF1ZXJ5LmVhY2goICggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxuXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUsIFNhZmFyaVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuLy8gV29ya2Fyb3VuZCBmYWlsdXJlIHRvIHN0cmluZy1jYXN0IG51bGwgaW5wdXRcbmpRdWVyeS5wYXJzZUpTT04gPSBmdW5jdGlvbiggZGF0YSApIHtcblx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKyBcIlwiICk7XG59O1xuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUU5XG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRydHMgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBqUXVlcnkucGFyc2VKU09OLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBUaGUganFYSFIgc3RhdGVcblx0XHRcdHN0YXRlID0gMCxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZSA9PT0gMiA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdHZhciBsbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFjayBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICkuY29tcGxldGUgPSBjb21wbGV0ZURlZmVycmVkLmFkZDtcblx0XHRqcVhIUi5zdWNjZXNzID0ganFYSFIuZG9uZTtcblx0XHRqcVhIUi5lcnJvciA9IGpxWEhSLmZhaWw7XG5cblx0XHQvLyBSZW1vdmUgaGFzaCBjaGFyYWN0ZXIgKCM3NTMxOiBhbmQgc3RyaW5nIHByb21vdGlvbilcblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiICkucmVwbGFjZSggcmhhc2gsIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSBqUXVlcnkudHJpbSggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgtMTErXG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIGlmIHVybCBpcyBtYWxmb3JtZWQsIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU4LTExK1xuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdGNhY2hlVVJMID0gcy51cmw7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gKCBzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhICk7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgYW50aS1jYWNoZSBpbiB1cmwgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRzLnVybCA9IHJ0cy50ZXN0KCBjYWNoZVVSTCApID9cblxuXHRcdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSAnXycgcGFyYW1ldGVyLCBzZXQgaXRzIHZhbHVlXG5cdFx0XHRcdFx0Y2FjaGVVUkwucmVwbGFjZSggcnRzLCBcIiQxXz1cIiArIG5vbmNlKysgKSA6XG5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UgYWRkIG9uZSB0byB0aGUgZW5kXG5cdFx0XHRcdFx0Y2FjaGVVUkwgKyAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgbm9uY2UrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgc3RhdGUgPT09IDIgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGZvciAoIGkgaW4geyBzdWNjZXNzOiAxLCBlcnJvcjogMSwgY29tcGxldGU6IDEgfSApIHtcblx0XHRcdGpxWEhSWyBpIF0oIHNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRzdGF0ZSA9IDE7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIGV4Y2VwdGlvbiBhcyBlcnJvciBpZiBub3QgZG9uZVxuXHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXG5cdFx0XHRcdC8vIFNpbXBseSByZXRocm93IG90aGVyd2lzZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBDYWxsZWQgb25jZVxuXHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0ZSBpcyBcImRvbmVcIiBub3dcblx0XHRcdHN0YXRlID0gMjtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cdFx0XCJ0aHJvd3NcIjogdHJ1ZVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJib2R5XCIgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdFx0fVxuXHRcdH0gKS5lbmQoKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0Ly8gU3VwcG9ydDogT3BlcmEgPD0gMTIuMTJcblx0Ly8gT3BlcmEgcmVwb3J0cyBvZmZzZXRXaWR0aHMgYW5kIG9mZnNldEhlaWdodHMgbGVzcyB0aGFuIHplcm8gb24gc29tZSBlbGVtZW50c1xuXHQvLyBVc2UgT1IgaW5zdGVhZCBvZiBBTkQgYXMgdGhlIGVsZW1lbnQgaXMgbm90IHZpc2libGUgaWYgZWl0aGVyIGlzIHRydWVcblx0Ly8gU2VlIHRpY2tldHMgIzEwNDA2IGFuZCAjMTMxMzJcblx0cmV0dXJuIGVsZW0ub2Zmc2V0V2lkdGggPiAwIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0ID4gMCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoID4gMDtcbn07XG5cblxuXG5cbnZhciByMjAgPSAvJTIwL2csXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcblx0XHRcdHZhbHVlID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgPyB2YWx1ZSgpIDogKCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSApO1xuXHRcdH07XG5cblx0Ly8gU2V0IHRyYWRpdGlvbmFsIHRvIHRydWUgZm9yIGpRdWVyeSA8PSAxLjMuMiBiZWhhdmlvci5cblx0aWYgKCB0cmFkaXRpb25hbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHRyYWRpdGlvbmFsID0galF1ZXJ5LmFqYXhTZXR0aW5ncyAmJiBqUXVlcnkuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsO1xuXHR9XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICkucmVwbGFjZSggcjIwLCBcIitcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRyZXR1cm4gdmFsID09IG51bGwgP1xuXHRcdFx0XHRudWxsIDpcblx0XHRcdFx0alF1ZXJ5LmlzQXJyYXkoIHZhbCApID9cblx0XHRcdFx0XHRqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0eyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFOVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFOSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKS5wcm9wKCB7XG5cdFx0XHRcdFx0Y2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxuXHRcdFx0XHRcdHNyYzogcy51cmxcblx0XHRcdFx0fSApLm9uKFxuXHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0galF1ZXJ5LmlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBqUXVlcnkuaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0dmFyIHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApLFxuXHRcdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8vIEtlZXAgYSBjb3B5IG9mIHRoZSBvbGQgbG9hZCBtZXRob2RcbnZhciBfbG9hZCA9IGpRdWVyeS5mbi5sb2FkO1xuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHRpZiAoIHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIgJiYgX2xvYWQgKSB7XG5cdFx0cmV0dXJuIF9sb2FkLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0fVxuXG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0aWYgKCBvZmYgPiAtMSApIHtcblx0XHRzZWxlY3RvciA9IGpRdWVyeS50cmltKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCBzZWxmLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZXhwci5maWx0ZXJzLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxuLyoqXG4gKiBHZXRzIGEgd2luZG93IGZyb20gYW4gZWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSA/IGVsZW0gOiBlbGVtLm5vZGVUeXBlID09PSA5ICYmIGVsZW0uZGVmYXVsdFZpZXc7XG59XG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciBkb2NFbGVtLCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0Ym94ID0geyB0b3A6IDAsIGxlZnQ6IDAgfSxcblx0XHRcdGRvYyA9IGVsZW0gJiYgZWxlbS5vd25lckRvY3VtZW50O1xuXG5cdFx0aWYgKCAhZG9jICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0Ly8gTWFrZSBzdXJlIGl0J3Mgbm90IGEgZGlzY29ubmVjdGVkIERPTSBub2RlXG5cdFx0aWYgKCAhalF1ZXJ5LmNvbnRhaW5zKCBkb2NFbGVtLCBlbGVtICkgKSB7XG5cdFx0XHRyZXR1cm4gYm94O1xuXHRcdH1cblxuXHRcdGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0d2luID0gZ2V0V2luZG93KCBkb2MgKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBib3gudG9wICsgd2luLnBhZ2VZT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRUb3AsXG5cdFx0XHRsZWZ0OiBib3gubGVmdCArIHdpbi5wYWdlWE9mZnNldCAtIGRvY0VsZW0uY2xpZW50TGVmdFxuXHRcdH07XG5cdH0sXG5cblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIEZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB3aW5kb3cgKHBhcmVudE9mZnNldCA9IHt0b3A6MCwgbGVmdDogMH0sXG5cdFx0Ly8gYmVjYXVzZSBpdCBpcyBpdHMgb25seSBvZmZzZXQgcGFyZW50XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIHRoZXJlIHdoZW4gY29tcHV0ZWQgcG9zaXRpb24gaXMgZml4ZWRcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuXHRcdFx0b2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQoKTtcblxuXHRcdFx0Ly8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggb2Zmc2V0UGFyZW50WyAwIF0sIFwiaHRtbFwiICkgKSB7XG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IG9mZnNldFBhcmVudC5vZmZzZXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9mZnNldFBhcmVudCBib3JkZXJzXG5cdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cdFx0XHR2YXIgd2luID0gZ2V0V2luZG93KCBlbGVtICk7XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaTw3LTgrLCBDaHJvbWU8MzctNDQrXG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yMjkyODBcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuXHRcdGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQXMgb2YgNS84LzIwMTIgdGhpcyB3aWxsIHlpZWxkIGluY29ycmVjdCByZXN1bHRzIGZvciBNb2JpbGUgU2FmYXJpLCBidXQgdGhlcmVcblx0XHRcdFx0XHQvLyBpc24ndCBhIHdob2xlIGxvdCB3ZSBjYW4gZG8uIFNlZSBwdWxsIHJlcXVlc3QgYXQgdGhpcyBVUkwgZm9yIGRpc2N1c3Npb246XG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC83NjRcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUsIG51bGwgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fSxcblx0c2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubGVuZ3RoO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5hbmRTZWxmID0galF1ZXJ5LmZuLmFkZEJhY2s7XG5cblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCAhbm9HbG9iYWwgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxucmV0dXJuIGpRdWVyeTtcbn0pKTtcbiIsIid1c2Ugc3RyaWN0J1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdGFnZSwgcmVzaXplZCkge1xyXG5cclxuXHR2YXIgY3JlYXRlanMgPSByZXF1aXJlKCdjcmVhdGVqcy1jb2xsZWN0aW9uJyk7XHJcblxyXG5cdHZhciBzcXVhcmVXaWR0aCwgc3F1YXJlSGVpZ2h0LCB4T2Zmc2V0LCB5T2Zmc2V0LCBzcGFjaW5nO1xyXG5cclxuXHRzZXRTdGFnZVNpemUoKTtcclxuXHRzZXRTcXVhcmVEaW1lbnNpb25zKCk7XHJcblx0c2V0T2Zmc2V0cygpO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG5cdFx0aWYgKCFyZXNpemVkKVxyXG5cdFx0XHRhZGRTcXVhcmUoKTtcclxuXHRcdGVsc2VcclxuXHRcdFx0cmVkcmF3U3F1YXJlKGkpO1xyXG5cdH1cclxuXHJcblx0c3RhZ2UudXBkYXRlKCk7XHJcblxyXG5cdGZ1bmN0aW9uIHNldFN0YWdlU2l6ZSgpIHtcclxuXHJcblx0XHR2YXIgZ2FtZVNlY3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2FtZVNlY3Rpb24nKTtcclxuXHJcblx0XHQvLyByZXNpemUgY2FudmFzIHRvIGJlIHJlc3BvbnNpdmUgd2l0aCBzZWN0aW9uIGVsZW1lbnRcclxuXHRcdHZhciB3aWR0aCA9IGdhbWVTZWN0aW9uLm9mZnNldFdpZHRoLFxyXG5cdFx0XHRoZWlnaHQgPSBnYW1lU2VjdGlvbi5vZmZzZXRIZWlnaHQ7XHJcblxyXG5cdFx0Ly8gdGhpcyBlbnN1cmVzIHRoZSBzcXVhcmVzIGFyZSBhbHdheXMgc3F1YXJlcyBhbmQgZml0IHdpdGhpbiB0aGUgc2NyZWVuXHJcblx0XHRpZiAod2lkdGggPiBoZWlnaHQpIHtcclxuXHRcdFx0c3RhZ2UuY2FudmFzLndpZHRoID0gaGVpZ2h0O1xyXG5cdFx0XHRzdGFnZS5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3RhZ2UuY2FudmFzLndpZHRoID0gd2lkdGg7XHJcblx0XHRcdHN0YWdlLmNhbnZhcy5oZWlnaHQgPSB3aWR0aDtcclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0U3F1YXJlRGltZW5zaW9ucygpIHtcclxuXHJcblx0XHQvLyBzcXVhcmUgZGltZW5zaW9uc1xyXG5cdFx0c3F1YXJlV2lkdGggPSBzdGFnZS5jYW52YXMud2lkdGggKiAwLjQ7XHJcblx0XHRzcXVhcmVIZWlnaHQgPSBzdGFnZS5jYW52YXMuaGVpZ2h0ICogMC40O1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBzZXRPZmZzZXRzKCkge1xyXG5cclxuXHRcdC8vIHggYW5kIHkgb2Zmc2V0cyBmcm9tIGNlbnRlciBmb3Igc3F1YXJlIHBvc2l0aW9uaW5nXHJcblx0XHR4T2Zmc2V0ID0gKHN0YWdlLmNhbnZhcy53aWR0aCAvIDIpIC0gc3F1YXJlV2lkdGggLSA1O1xyXG5cdFx0eU9mZnNldCA9IChzdGFnZS5jYW52YXMuaGVpZ2h0IC8gMikgLSBzcXVhcmVIZWlnaHQgLSA1O1xyXG5cclxuXHRcdC8vIHNwYWNpbmcgYmV0d2VlbiB0aGUgc3F1YXJlc1xyXG5cdFx0c3BhY2luZyA9IDEwO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBhZGRTcXVhcmUoKSB7XHJcblxyXG5cdFx0dmFyIHNxdWFyZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xyXG5cdFx0c3F1YXJlLmdyYXBoaWNzLmJlZ2luRmlsbChnZXRTcXVhcmVDb2xvcihzcXVhcmUuaWQpKS5kcmF3UmVjdCgwLCAwLCBzcXVhcmVXaWR0aCwgc3F1YXJlSGVpZ2h0KTtcclxuXHRcdHNxdWFyZS5zaGFkb3cgPSBuZXcgY3JlYXRlanMuU2hhZG93KFwiIzAwMFwiLCA1LCA1LCAxMCk7XHJcblx0XHRzcXVhcmUueCA9IGdldFhQb3NpdGlvbihzcXVhcmUuaWQpO1xyXG5cdFx0c3F1YXJlLnkgPSBnZXRZUG9zaXRpb24oc3F1YXJlLmlkKTtcclxuXHRcdHN0YWdlLmFkZENoaWxkKHNxdWFyZSk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHJlZHJhd1NxdWFyZShzcXVhcmVJbmRleCkge1xyXG5cclxuXHRcdHZhciBzcXVhcmUgPSBzdGFnZS5nZXRDaGlsZEF0KHNxdWFyZUluZGV4KTtcclxuXHRcdHNxdWFyZS5ncmFwaGljcy5jbGVhcigpO1xyXG5cdFx0c3F1YXJlLmdyYXBoaWNzLmJlZ2luRmlsbChnZXRTcXVhcmVDb2xvcihzcXVhcmUuaWQpKS5kcmF3UmVjdCgwLCAwLCBzcXVhcmVXaWR0aCwgc3F1YXJlSGVpZ2h0KTtcclxuXHRcdHNxdWFyZS5zaGFkb3cgPSBuZXcgY3JlYXRlanMuU2hhZG93KFwiIzAwMFwiLCA1LCA1LCAxMCk7XHJcblx0XHRzcXVhcmUueCA9IGdldFhQb3NpdGlvbihzcXVhcmUuaWQpO1xyXG5cdFx0c3F1YXJlLnkgPSBnZXRZUG9zaXRpb24oc3F1YXJlLmlkKTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gZ2V0U3F1YXJlQ29sb3Ioc3F1YXJlSWQpIHtcclxuXHJcblx0XHRpZiAoc3F1YXJlSWQgPT09IDEpIFxyXG5cdFx0XHRyZXR1cm4gXCJyZWRcIjtcclxuXHRcdGVsc2UgaWYgKHNxdWFyZUlkID09PSAyKSBcclxuXHRcdFx0cmV0dXJuIFwiZ3JlZW5cIjtcclxuXHRcdGVsc2UgaWYgKHNxdWFyZUlkID09PSAzKVxyXG5cdFx0XHRyZXR1cm4gXCJibHVlXCI7XHJcblx0XHRlbHNlXHJcblx0XHRcdHJldHVybiBcInllbGxvd1wiO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldFhQb3NpdGlvbihzcXVhcmVJZCkge1xyXG5cclxuXHRcdGlmIChzcXVhcmVJZCA9PT0gMSB8fCBzcXVhcmVJZCA9PT0gMykgXHJcblx0XHRcdHJldHVybiB4T2Zmc2V0O1xyXG5cdFx0ZWxzZSBcclxuXHRcdFx0cmV0dXJuIHhPZmZzZXQgKyBzcXVhcmVXaWR0aCArIHNwYWNpbmc7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGdldFlQb3NpdGlvbihzcXVhcmVJZCkge1xyXG5cclxuXHRcdGlmIChzcXVhcmVJZCA9PT0gMSB8fCBzcXVhcmVJZCA9PT0gMikgXHJcblx0XHRcdHJldHVybiB5T2Zmc2V0O1xyXG5cdFx0ZWxzZSBcclxuXHRcdFx0cmV0dXJuIHlPZmZzZXQgKyBzcXVhcmVIZWlnaHQgKyBzcGFjaW5nO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdFx0RHJhdyBGdW5jdGlvbiBVc2VzOlxyXG5cdFx0LSBkcmF3UmVjdFxyXG5cdFx0LSBhcHBseSBzaGFkb3dcclxuXHRcdC0gYWRkIHRoZSByZWN0YW5nbGUgdG8gdGhlIGNhbnZhc1xyXG5cclxuXHQvKiBcclxuXHRcdC1DaGFuZ2luZyB4IG1vdmVzIHRoZSBzaGFwZSBob3Jpem9uYXRhbGx5XHJcblx0XHQtQ2hhbmdpbmcgeSBtb3ZlcyB0aGUgc2hhcGUgdmVydGljYWxseVxyXG5cdFx0LUNoYW5naW5nIGFscGhhIHdpbGwgZmFkZSB0aGUgc2hhcGUgaW4gYW5kIG91dFxyXG5cdCovXHJcblxyXG5cdC8qXHJcblx0XHRjcmVhdGVqcy5Ud2Vlbi5nZXQoY2lyY2xlLCB7IGxvb3A6IHRydWUgfSlcclxuXHRcdFx0LnRvKHsgeDogNDAwIH0sIDEwMDAsIGNyZWF0ZWpzLkVhc2UuZ2V0UG93SW5PdXQoNCkpXHJcblx0XHRcdC50byh7IGFscGhhOiAwLCB5OiAxNzUgfSwgNTAwLCBjcmVhdGVqcy5FYXNlLmdldFBvd0luT3V0KDIpKVxyXG5cdFx0XHQudG8oeyBhbHBoYTogMCwgeTogMjI1IH0sIDEwMClcclxuXHRcdFx0LnRvKHsgYWxwaGE6IDEsIHk6IDIwMCB9LCA1MDAsIGNyZWF0ZWpzLkVhc2UuZ2V0UG93SW5PdXQoMikpXHJcblx0XHRcdC50byh7IHg6IDEwMCB9LCA4MDAsIGNyZWF0ZWpzLkVhc2UuZ2V0UG93SW5PdXQoMikpO1xyXG5cclxuXHRcdGNyZWF0ZWpzLlRpY2tlci5zZXRGUFMoNjApO1xyXG5cdFx0Y3JlYXRlanMuVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIHN0YWdlKTtcclxuXHQqL1xyXG5cclxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcclxuXHJcbiAgICB2YXIgZW5xdWlyZSA9IHJlcXVpcmUoJ2VucXVpcmUuanMnKTtcclxuICAgIHZhciBidXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhcnRCdXR0b24nKTtcclxuXHJcbiAgICBlbnF1aXJlXHJcbiAgICAgICAgLnJlZ2lzdGVyKFwiKG1pbi13aWR0aDogNzY4cHgpLCAobWluLWhlaWdodDogNzY4cHgpXCIsIHtcclxuICAgICAgICAgICAgbWF0Y2ggOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGJ1dHRvbi5jbGFzc05hbWUgPSAnYnRuIGJ0bi1zdWNjZXNzIGJ0bi1sZyc7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVubWF0Y2ggOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGJ1dHRvbi5jbGFzc05hbWUgPSAnYnRuIGJ0bi1zdWNjZXNzIGJ0bi1tZCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxufSk7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dmFyIGNyZWF0ZWpzID0gcmVxdWlyZSgnY3JlYXRlanMtY29sbGVjdGlvbicpO1xyXG5cclxuXHR2YXIgY2FudmFzLCBzdGFnZTtcclxuXHRcdFxyXG5cdGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnYW1lQ2FudmFzJyk7XHJcblx0c3RhZ2UgPSBuZXcgY3JlYXRlanMuU3RhZ2UoY2FudmFzKTtcclxuXHJcblx0Y3JlYXRlanMuVG91Y2guZW5hYmxlKHN0YWdlKTtcclxuXHJcblx0c3RhZ2UuZW5hYmxlTW91c2VPdmVyKDEwKTtcclxuXHRzdGFnZS5tb3VzZU1vdmVPdXRzaWRlID0gdHJ1ZTtcclxuXHJcblx0cmV0dXJuIHN0YWdlO1xyXG5cclxufTsiLCIoZnVuY3Rpb24oKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0J1xyXG5cclxuXHR2YXIgaW5pdCA9IHJlcXVpcmUoJy4vaW5pdCcpLFxyXG5cdFx0ZHJhdyA9IHJlcXVpcmUoJy4vZHJhd1NxdWFyZXMnKSxcclxuXHRcdHNlcXVlbmNlID0gcmVxdWlyZSgnLi9zdGFydFJhbmRvbVNlcXVlbmNlJyksXHJcblx0XHQkID0gcmVxdWlyZSgnanF1ZXJ5JyksXHJcblx0XHRlbnF1aXJlU3R5bGVzID0gcmVxdWlyZSgnLi9lbnF1aXJlSlNTdHlsZXMnKTtcclxuXHJcblx0Z2xvYmFsLmpRdWVyeSA9ICQ7XHJcblxyXG5cdHJlcXVpcmUoJ2Jvb3RzdHJhcCcpO1xyXG5cclxuXHR2YXIgc3RhZ2U7XHJcblxyXG5cdC8vIFBvbGxpbmcgZm9yIHRoZSBzYWtlIG9mIG15IGludGVybiB0ZXN0c1xyXG5cdHZhciBpbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xyXG5cdCAgICBpZihkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XHJcblx0ICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcclxuXHQgICAgICAgIGRvbmUoKTtcclxuXHQgICAgfSAgICBcclxuXHR9LCAxMDApO1xyXG5cclxuXHRmdW5jdGlvbiBkb25lKCkge1xyXG5cclxuXHRcdC8vIHNldHVwIHRoZSBzdGFnZVxyXG5cdFx0c3RhZ2UgPSBpbml0KCk7XHJcblxyXG5cdFx0Ly8gYXBwbHkgbWVkaWEgcXVlcnkgc3R5bGVzXHJcblx0XHRlbnF1aXJlU3R5bGVzKCk7XHJcblxyXG5cdFx0Ly8gZHJhdyBzcXVhcmVzIG9udG8gdGhlIHN0YWdlXHJcblx0XHRkcmF3KHN0YWdlLCBmYWxzZSk7XHJcblxyXG5cdFx0Ly8gZGlzcGxheSBnYW1lIHJ1bGVzIGFuZCBob3cgdG8gcGxheVxyXG5cdFx0JCgnI2dhbWVNb2RhbCcpLm1vZGFsKCdzaG93Jyk7XHJcblxyXG5cdFx0Y29uc29sZS5sb2coJ2luaXRpYWxpemVkJyk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIGJlZ2luIGdhbWUgd2l0aCBzdGFydCBidXR0b24gcHJlc3NcclxuXHR2YXIgc3RhcnRCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhcnRCdXR0b24nKTtcclxuXHJcblx0c3RhcnRCdG4ub25jbGljayA9IGZ1bmN0aW9uKGUpIHtcclxuXHJcblx0XHQvLyB1c2VyIGNhbid0IHNwYW0gdGhlIHN0YXJ0IGJ1dHRvblxyXG5cdFx0c3RhcnRCdG4uZGlzYWJsZWQgPSB0cnVlO1xyXG5cclxuXHRcdGNvbnNvbGUubG9nKFwiYmVnaW4gc2VxdWVuY2VcIik7XHJcblxyXG5cdFx0Ly8gYmVnaW4gdGhlIHNlcXVlbmNlXHJcblx0XHRzZXF1ZW5jZShzdGFnZSk7XHJcblxyXG5cdFx0XHJcblx0fTtcclxuXHJcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZSwgZmFsc2UpO1xyXG5cclxuXHRmdW5jdGlvbiByZXNpemUoKSB7XHJcblxyXG5cdFx0ZHJhdyhzdGFnZSwgdHJ1ZSk7XHJcblxyXG5cdH07XHJcblxyXG59KSgpOyIsIid1c2Ugc3RyaWN0J1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWluLCBtYXgpIHtcclxuXHJcblx0cmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXgtbWluKzEpICsgbWluKTtcclxuXHJcbn0iLCIndXNlIHN0cmljdCdcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0YWdlKSB7XHJcblxyXG5cdHZhciBzcXVhcmVOdW0gPSByZXF1aXJlKCcuL3JhbmRvbUludEZyb21JbnRlcnZhbCcpLFxyXG5cdGNyZWF0ZWpzID0gcmVxdWlyZSgnY3JlYXRlanMtY29sbGVjdGlvbicpO1xyXG5cclxuXHRjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgdGljayk7XHJcblxyXG5cdHZhciB1cGRhdGUgPSB0cnVlO1xyXG5cclxuXHQoZnVuY3Rpb24gZmFkZVNxdWFyZShpKSB7ICAgICAgICAgIFxyXG5cdCAgIFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7ICAgXHJcblx0ICAgXHRcdHZhciBzcXVhcmUgPSBzdGFnZS5nZXRDaGlsZEF0KHNxdWFyZU51bSgwLCAzKSk7XHJcblxyXG5cdFx0XHRjcmVhdGVqcy5Ud2Vlbi5nZXQoc3F1YXJlKS53YWl0KDEwMDApLnBsYXkoXHJcblx0XHRcdFx0Y3JlYXRlanMuVHdlZW4uZ2V0KHNxdWFyZSx7cGF1c2VkOnRydWV9KVxyXG5cdFx0XHRcdC50byh7YWxwaGE6MC41fSwgMTUwMClcclxuXHRcdFx0XHQudG8oe2FscGhhOjF9LCAxNTAwKVxyXG5cdFx0XHQpO1xyXG5cclxuXHQgICAgXHRpZiAoLS1pKSBmYWRlU3F1YXJlKGkpOyBcclxuXHQgICBcdH0sIDMwMDApXHJcblx0fSkoNCk7ICBcclxuXHJcblx0ZnVuY3Rpb24gdGljayhldmVudCkge1xyXG5cclxuXHRcdHVwZGF0ZSA9IGZhbHNlOyBcclxuXHRcdHN0YWdlLnVwZGF0ZShldmVudCk7XHJcblxyXG5cdH07XHJcblxyXG59Il19
