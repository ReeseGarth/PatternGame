(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
var createjs = (this.createjs = (this.createjs || {}));
/*!
* EaselJS
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2010 gskinner.com, inc.
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/


//##############################################################################
// extend.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Sets up the prototype chain and constructor property for a new class.
 *
 * This should be called right after creating the class constructor.
 *
 * 	function MySubClass() {}
 * 	createjs.extend(MySubClass, MySuperClass);
 * 	ClassB.prototype.doSomething = function() { }
 *
 * 	var foo = new MySubClass();
 * 	console.log(foo instanceof MySuperClass); // true
 * 	console.log(foo.prototype.constructor === MySubClass); // true
 *
 * @method extend
 * @param {Function} subclass The subclass.
 * @param {Function} superclass The superclass to extend.
 * @return {Function} Returns the subclass's new prototype.
 */
createjs.extend = function(subclass, superclass) {
	"use strict";

	function o() { this.constructor = subclass; }
	o.prototype = superclass.prototype;
	return (subclass.prototype = new o());
};

//##############################################################################
// promote.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.
 * It is recommended to use the super class's name as the prefix.
 * An alias to the super class's constructor is always added in the format `prefix_constructor`.
 * This allows the subclass to call super class methods without using `function.call`, providing better performance.
 *
 * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, "MySuperClass")`
 * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the
 * prototype of `MySubClass` as `MySuperClass_draw`.
 *
 * This should be called after the class's prototype is fully defined.
 *
 * 	function ClassA(name) {
 * 		this.name = name;
 * 	}
 * 	ClassA.prototype.greet = function() {
 * 		return "Hello "+this.name;
 * 	}
 *
 * 	function ClassB(name, punctuation) {
 * 		this.ClassA_constructor(name);
 * 		this.punctuation = punctuation;
 * 	}
 * 	createjs.extend(ClassB, ClassA);
 * 	ClassB.prototype.greet = function() {
 * 		return this.ClassA_greet()+this.punctuation;
 * 	}
 * 	createjs.promote(ClassB, "ClassA");
 *
 * 	var foo = new ClassB("World", "!?!");
 * 	console.log(foo.greet()); // Hello World!?!
 *
 * @method promote
 * @param {Function} subclass The class to promote super class methods on.
 * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.
 * @return {Function} Returns the subclass.
 */
createjs.promote = function(subclass, prefix) {
	"use strict";

	var subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;
	if (supP) {
		subP[(prefix+="_") + "constructor"] = supP.constructor; // constructor is not always innumerable
		for (var n in supP) {
			if (subP.hasOwnProperty(n) && (typeof supP[n] == "function")) { subP[prefix + n] = supP[n]; }
		}
	}
	return subclass;
};

//##############################################################################
// indexOf.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of
 * that value.  Returns -1 if value is not found.
 *
 *      var i = createjs.indexOf(myArray, myElementToFind);
 *
 * @method indexOf
 * @param {Array} array Array to search for searchElement
 * @param searchElement Element to find in array.
 * @return {Number} The first index of searchElement in array.
 */
createjs.indexOf = function (array, searchElement){
	"use strict";

	for (var i = 0,l=array.length; i < l; i++) {
		if (searchElement === array[i]) {
			return i;
		}
	}
	return -1;
};

//##############################################################################
// Event.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

// constructor:
	/**
	 * Contains properties and methods shared by all events for use with
	 * {{#crossLink "EventDispatcher"}}{{/crossLink}}.
	 * 
	 * Note that Event objects are often reused, so you should never
	 * rely on an event object's state outside of the call stack it was received in.
	 * @class Event
	 * @param {String} type The event type.
	 * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
	 * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
	 * @constructor
	 **/
	function Event(type, bubbles, cancelable) {
		
	
	// public properties:
		/**
		 * The type of event.
		 * @property type
		 * @type String
		 **/
		this.type = type;
	
		/**
		 * The object that generated an event.
		 * @property target
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.target = null;
	
		/**
		 * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will
		 * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event
		 * is generated from childObj, then a listener on parentObj would receive the event with
		 * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).
		 * @property currentTarget
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.currentTarget = null;
	
		/**
		 * For bubbling events, this indicates the current event phase:<OL>
		 * 	<LI> capture phase: starting from the top parent to the target</LI>
		 * 	<LI> at target phase: currently being dispatched from the target</LI>
		 * 	<LI> bubbling phase: from the target to the top parent</LI>
		 * </OL>
		 * @property eventPhase
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.eventPhase = 0;
	
		/**
		 * Indicates whether the event will bubble through the display list.
		 * @property bubbles
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.bubbles = !!bubbles;
	
		/**
		 * Indicates whether the default behaviour of this event can be cancelled via
		 * {{#crossLink "Event/preventDefault"}}{{/crossLink}}. This is set via the Event constructor.
		 * @property cancelable
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.cancelable = !!cancelable;
	
		/**
		 * The epoch time at which this event was created.
		 * @property timeStamp
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.timeStamp = (new Date()).getTime();
	
		/**
		 * Indicates if {{#crossLink "Event/preventDefault"}}{{/crossLink}} has been called
		 * on this event.
		 * @property defaultPrevented
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.defaultPrevented = false;
	
		/**
		 * Indicates if {{#crossLink "Event/stopPropagation"}}{{/crossLink}} or
		 * {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called on this event.
		 * @property propagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.propagationStopped = false;
	
		/**
		 * Indicates if {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called
		 * on this event.
		 * @property immediatePropagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.immediatePropagationStopped = false;
		
		/**
		 * Indicates if {{#crossLink "Event/remove"}}{{/crossLink}} has been called on this event.
		 * @property removed
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.removed = false;
	}
	var p = Event.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.

// public methods:
	/**
	 * Sets {{#crossLink "Event/defaultPrevented"}}{{/crossLink}} to true if the event is cancelable.
	 * Mirrors the DOM level 2 event standard. In general, cancelable events that have `preventDefault()` called will
	 * cancel the default behaviour associated with the event.
	 * @method preventDefault
	 **/
	p.preventDefault = function() {
		this.defaultPrevented = this.cancelable&&true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopPropagation
	 **/
	p.stopPropagation = function() {
		this.propagationStopped = true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} and
	 * {{#crossLink "Event/immediatePropagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopImmediatePropagation
	 **/
	p.stopImmediatePropagation = function() {
		this.immediatePropagationStopped = this.propagationStopped = true;
	};
	
	/**
	 * Causes the active listener to be removed via removeEventListener();
	 * 
	 * 		myBtn.addEventListener("click", function(evt) {
	 * 			// do stuff...
	 * 			evt.remove(); // removes this listener.
	 * 		});
	 * 
	 * @method remove
	 **/
	p.remove = function() {
		this.removed = true;
	};
	
	/**
	 * Returns a clone of the Event instance.
	 * @method clone
	 * @return {Event} a clone of the Event instance.
	 **/
	p.clone = function() {
		return new Event(this.type, this.bubbles, this.cancelable);
	};
	
	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the instance.
	 * @return {Event} Returns the instance the method is called on (useful for chaining calls.)
	 * @chainable
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Event (type="+this.type+")]";
	};

	createjs.Event = Event;
}());

//##############################################################################
// EventDispatcher.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * EventDispatcher provides methods for managing queues of event listeners and dispatching events.
	 *
	 * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the
	 * EventDispatcher {{#crossLink "EventDispatcher/initialize"}}{{/crossLink}} method.
	 * 
	 * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the
	 * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports
	 * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.
	 * 
	 * EventDispatcher also exposes a {{#crossLink "EventDispatcher/on"}}{{/crossLink}} method, which makes it easier
	 * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The 
	 * {{#crossLink "EventDispatcher/off"}}{{/crossLink}} method is merely an alias to
	 * {{#crossLink "EventDispatcher/removeEventListener"}}{{/crossLink}}.
	 * 
	 * Another addition to the DOM Level 2 model is the {{#crossLink "EventDispatcher/removeAllEventListeners"}}{{/crossLink}}
	 * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also 
	 * includes a {{#crossLink "Event/remove"}}{{/crossLink}} method which removes the active listener.
	 *
	 * <h4>Example</h4>
	 * Add EventDispatcher capabilities to the "MyClass" class.
	 *
	 *      EventDispatcher.initialize(MyClass.prototype);
	 *
	 * Add an event (see {{#crossLink "EventDispatcher/addEventListener"}}{{/crossLink}}).
	 *
	 *      instance.addEventListener("eventName", handlerMethod);
	 *      function handlerMethod(event) {
	 *          console.log(event.target + " Was Clicked");
	 *      }
	 *
	 * <b>Maintaining proper scope</b><br />
	 * Scope (ie. "this") can be be a challenge with events. Using the {{#crossLink "EventDispatcher/on"}}{{/crossLink}}
	 * method to subscribe to events simplifies this.
	 *
	 *      instance.addEventListener("click", function(event) {
	 *          console.log(instance == this); // false, scope is ambiguous.
	 *      });
	 *      
	 *      instance.on("click", function(event) {
	 *          console.log(instance == this); // true, "on" uses dispatcher scope by default.
	 *      });
	 * 
	 * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage scope.
	 *      
	 *
	 * @class EventDispatcher
	 * @constructor
	 **/
	function EventDispatcher() {
	
	
	// private properties:
		/**
		 * @protected
		 * @property _listeners
		 * @type Object
		 **/
		this._listeners = null;
		
		/**
		 * @protected
		 * @property _captureListeners
		 * @type Object
		 **/
		this._captureListeners = null;
	}
	var p = EventDispatcher.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// static public methods:
	/**
	 * Static initializer to mix EventDispatcher methods into a target object or prototype.
	 * 
	 * 		EventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class
	 * 		EventDispatcher.initialize(myObject); // add to a specific instance
	 * 
	 * @method initialize
	 * @static
	 * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a
	 * prototype.
	 **/
	EventDispatcher.initialize = function(target) {
		target.addEventListener = p.addEventListener;
		target.on = p.on;
		target.removeEventListener = target.off =  p.removeEventListener;
		target.removeAllEventListeners = p.removeAllEventListeners;
		target.hasEventListener = p.hasEventListener;
		target.dispatchEvent = p.dispatchEvent;
		target._dispatchEvent = p._dispatchEvent;
		target.willTrigger = p.willTrigger;
	};
	

// public methods:
	/**
	 * Adds the specified event listener. Note that adding multiple listeners to the same function will result in
	 * multiple callbacks getting fired.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.addEventListener("click", handleClick);
	 *      function handleClick(event) {
	 *         // Click happened.
	 *      }
	 *
	 * @method addEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function | Object} Returns the listener for chaining or assignment.
	 **/
	p.addEventListener = function(type, listener, useCapture) {
		var listeners;
		if (useCapture) {
			listeners = this._captureListeners = this._captureListeners||{};
		} else {
			listeners = this._listeners = this._listeners||{};
		}
		var arr = listeners[type];
		if (arr) { this.removeEventListener(type, listener, useCapture); }
		arr = listeners[type]; // remove may have deleted the array
		if (!arr) { listeners[type] = [listener];  }
		else { arr.push(listener); }
		return listener;
	};
	
	/**
	 * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener
	 * only run once, associate arbitrary data with the listener, and remove the listener.
	 * 
	 * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.
	 * The wrapper function is returned for use with `removeEventListener` (or `off`).
	 * 
	 * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener, or use
	 * {{#crossLink "Event/remove"}}{{/crossLink}}. Likewise, each time you call `on` a NEW wrapper function is subscribed, so multiple calls
	 * to `on` with the same params will create multiple listeners.
	 * 
	 * <h4>Example</h4>
	 * 
	 * 		var listener = myBtn.on("click", handleClick, null, false, {count:3});
	 * 		function handleClick(evt, data) {
	 * 			data.count -= 1;
	 * 			console.log(this == myBtn); // true - scope defaults to the dispatcher
	 * 			if (data.count == 0) {
	 * 				alert("clicked 3 times!");
	 * 				myBtn.off("click", listener);
	 * 				// alternately: evt.remove();
	 * 			}
	 * 		}
	 * 
	 * @method on
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).
	 * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.
	 * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.
	 * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.
	 **/
	p.on = function(type, listener, scope, once, data, useCapture) {
		if (listener.handleEvent) {
			scope = scope||listener;
			listener = listener.handleEvent;
		}
		scope = scope||this;
		return this.addEventListener(type, function(evt) {
				listener.call(scope, evt, data);
				once&&evt.remove();
			}, useCapture);
	};

	/**
	 * Removes the specified event listener.
	 *
	 * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy
	 * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or
	 * closure will not work.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.removeEventListener("click", handleClick);
	 *
	 * @method removeEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.removeEventListener = function(type, listener, useCapture) {
		var listeners = useCapture ? this._captureListeners : this._listeners;
		if (!listeners) { return; }
		var arr = listeners[type];
		if (!arr) { return; }
		for (var i=0,l=arr.length; i<l; i++) {
			if (arr[i] == listener) {
				if (l==1) { delete(listeners[type]); } // allows for faster checks.
				else { arr.splice(i,1); }
				break;
			}
		}
	};
	
	/**
	 * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the
	 * .on method.
	 * 
	 * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener. See 
	 * {{#crossLink "EventDispatcher/on"}}{{/crossLink}} for an example.
	 *
	 * @method off
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.off = p.removeEventListener;

	/**
	 * Removes all listeners for the specified type, or all listeners of all types.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Remove all listeners
	 *      displayObject.removeAllEventListeners();
	 *
	 *      // Remove all click listeners
	 *      displayObject.removeAllEventListeners("click");
	 *
	 * @method removeAllEventListeners
	 * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.
	 **/
	p.removeAllEventListeners = function(type) {
		if (!type) { this._listeners = this._captureListeners = null; }
		else {
			if (this._listeners) { delete(this._listeners[type]); }
			if (this._captureListeners) { delete(this._captureListeners[type]); }
		}
	};

	/**
	 * Dispatches the specified event to all listeners.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Use a string event
	 *      this.dispatchEvent("complete");
	 *
	 *      // Use an Event instance
	 *      var event = new createjs.Event("progress");
	 *      this.dispatchEvent(event);
	 *
	 * @method dispatchEvent
	 * @param {Object | String | Event} eventObj An object with a "type" property, or a string type.
	 * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,
	 * dispatchEvent will construct an Event instance if necessary with the specified type. This latter approach can
	 * be used to avoid event object instantiation for non-bubbling events that may not have any listeners.
	 * @param {Boolean} [bubbles] Specifies the `bubbles` value when a string was passed to eventObj.
	 * @param {Boolean} [cancelable] Specifies the `cancelable` value when a string was passed to eventObj.
	 * @return {Boolean} Returns false if `preventDefault()` was called on a cancelable event, true otherwise.
	 **/
	p.dispatchEvent = function(eventObj, bubbles, cancelable) {
		if (typeof eventObj == "string") {
			// skip everything if there's no listeners and it doesn't bubble:
			var listeners = this._listeners;
			if (!bubbles && (!listeners || !listeners[eventObj])) { return true; }
			eventObj = new createjs.Event(eventObj, bubbles, cancelable);
		} else if (eventObj.target && eventObj.clone) {
			// redispatching an active event object, so clone it:
			eventObj = eventObj.clone();
		}
		
		// TODO: it would be nice to eliminate this. Maybe in favour of evtObj instanceof Event? Or !!evtObj.createEvent
		try { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events

		if (!eventObj.bubbles || !this.parent) {
			this._dispatchEvent(eventObj, 2);
		} else {
			var top=this, list=[top];
			while (top.parent) { list.push(top = top.parent); }
			var i, l=list.length;

			// capture & atTarget
			for (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {
				list[i]._dispatchEvent(eventObj, 1+(i==0));
			}
			// bubbling
			for (i=1; i<l && !eventObj.propagationStopped; i++) {
				list[i]._dispatchEvent(eventObj, 3);
			}
		}
		return !eventObj.defaultPrevented;
	};

	/**
	 * Indicates whether there is at least one listener for the specified event type.
	 * @method hasEventListener
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns true if there is at least one listener for the specified event.
	 **/
	p.hasEventListener = function(type) {
		var listeners = this._listeners, captureListeners = this._captureListeners;
		return !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));
	};
	
	/**
	 * Indicates whether there is at least one listener for the specified event type on this object or any of its
	 * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the
	 * specified type is dispatched from this object, it will trigger at least one listener.
	 * 
	 * This is similar to {{#crossLink "EventDispatcher/hasEventListener"}}{{/crossLink}}, but it searches the entire
	 * event flow for a listener, not just this object.
	 * @method willTrigger
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns `true` if there is at least one listener for the specified event.
	 **/
	p.willTrigger = function(type) {
		var o = this;
		while (o) {
			if (o.hasEventListener(type)) { return true; }
			o = o.parent;
		}
		return false;
	};

	/**
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[EventDispatcher]";
	};


// private methods:
	/**
	 * @method _dispatchEvent
	 * @param {Object | String | Event} eventObj
	 * @param {Object} eventPhase
	 * @protected
	 **/
	p._dispatchEvent = function(eventObj, eventPhase) {
		var l, listeners = (eventPhase==1) ? this._captureListeners : this._listeners;
		if (eventObj && listeners) {
			var arr = listeners[eventObj.type];
			if (!arr||!(l=arr.length)) { return; }
			try { eventObj.currentTarget = this; } catch (e) {}
			try { eventObj.eventPhase = eventPhase; } catch (e) {}
			eventObj.removed = false;
			
			arr = arr.slice(); // to avoid issues with items being removed or added during the dispatch
			for (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {
				var o = arr[i];
				if (o.handleEvent) { o.handleEvent(eventObj); }
				else { o(eventObj); }
				if (eventObj.removed) {
					this.off(eventObj.type, o, eventPhase==1);
					eventObj.removed = false;
				}
			}
		}
	};


	createjs.EventDispatcher = EventDispatcher;
}());

//##############################################################################
// Ticker.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * The Ticker provides a centralized tick or heartbeat broadcast at a set interval. Listeners can subscribe to the tick
	 * event to be notified when a set time interval has elapsed.
	 *
	 * Note that the interval that the tick event is called is a target interval, and may be broadcast at a slower interval
	 * when under high CPU load. The Ticker class uses a static interface (ex. `Ticker.framerate = 30;`) and
	 * can not be instantiated.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.Ticker.addEventListener("tick", handleTick);
	 *      function handleTick(event) {
	 *          // Actions carried out each tick (aka frame)
	 *          if (!event.paused) {
	 *              // Actions carried out when the Ticker is not paused.
	 *          }
	 *      }
	 *
	 * @class Ticker
	 * @uses EventDispatcher
	 * @static
	 **/
	function Ticker() {
		throw "Ticker cannot be instantiated.";
	}


// constants:
	/**
	 * In this mode, Ticker uses the requestAnimationFrame API, but attempts to synch the ticks to target framerate. It
	 * uses a simple heuristic that compares the time of the RAF return to the target time for the current frame and
	 * dispatches the tick when the time is within a certain threshold.
	 *
	 * This mode has a higher variance for time between frames than {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}},
	 * but does not require that content be time based as with {{#crossLink "Ticker/RAF:property"}}{{/crossLink}} while
	 * gaining the benefits of that API (screen synch, background throttling).
	 *
	 * Variance is usually lowest for framerates that are a divisor of the RAF frequency. This is usually 60, so
	 * framerates of 10, 12, 15, 20, and 30 work well.
	 *
	 * Falls back to {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}} if the requestAnimationFrame API is not
	 * supported.
	 * @property RAF_SYNCHED
	 * @static
	 * @type {String}
	 * @default "synched"
	 * @readonly
	 **/
	Ticker.RAF_SYNCHED = "synched";

	/**
	 * In this mode, Ticker passes through the requestAnimationFrame heartbeat, ignoring the target framerate completely.
	 * Because requestAnimationFrame frequency is not deterministic, any content using this mode should be time based.
	 * You can leverage {{#crossLink "Ticker/getTime"}}{{/crossLink}} and the {{#crossLink "Ticker/tick:event"}}{{/crossLink}}
	 * event object's "delta" properties to make this easier.
	 *
	 * Falls back on {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}} if the requestAnimationFrame API is not
	 * supported.
	 * @property RAF
	 * @static
	 * @type {String}
	 * @default "raf"
	 * @readonly
	 **/
	Ticker.RAF = "raf";

	/**
	 * In this mode, Ticker uses the setTimeout API. This provides predictable, adaptive frame timing, but does not
	 * provide the benefits of requestAnimationFrame (screen synch, background throttling).
	 * @property TIMEOUT
	 * @static
	 * @type {String}
	 * @default "timeout"
	 * @readonly
	 **/
	Ticker.TIMEOUT = "timeout";


// static events:
	/**
	 * Dispatched each tick. The event will be dispatched to each listener even when the Ticker has been paused using
	 * {{#crossLink "Ticker/setPaused"}}{{/crossLink}}.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.Ticker.addEventListener("tick", handleTick);
	 *      function handleTick(event) {
	 *          console.log("Paused:", event.paused, event.delta);
	 *      }
	 *
	 * @event tick
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Boolean} paused Indicates whether the ticker is currently paused.
	 * @param {Number} delta The time elapsed in ms since the last tick.
	 * @param {Number} time The total time in ms since Ticker was initialized.
	 * @param {Number} runTime The total time in ms that Ticker was not paused since it was initialized. For example,
	 * 	you could determine the amount of time that the Ticker has been paused since initialization with `time-runTime`.
	 * @since 0.6.0
	 */


// public static properties:
	/**
	 * Deprecated in favour of {{#crossLink "Ticker/timingMode"}}{{/crossLink}}, and will be removed in a future version. If true, timingMode will
	 * use {{#crossLink "Ticker/RAF_SYNCHED"}}{{/crossLink}} by default.
	 * @deprecated Deprecated in favour of {{#crossLink "Ticker/timingMode"}}{{/crossLink}}.
	 * @property useRAF
	 * @static
	 * @type {Boolean}
	 * @default false
	 **/
	Ticker.useRAF = false;

	/**
	 * Specifies the timing api (setTimeout or requestAnimationFrame) and mode to use. See
	 * {{#crossLink "Ticker/TIMEOUT"}}{{/crossLink}}, {{#crossLink "Ticker/RAF"}}{{/crossLink}}, and
	 * {{#crossLink "Ticker/RAF_SYNCHED"}}{{/crossLink}} for mode details.
	 * @property timingMode
	 * @static
	 * @type {String}
	 * @default Ticker.TIMEOUT
	 **/
	Ticker.timingMode = null;

	/**
	 * Specifies a maximum value for the delta property in the tick event object. This is useful when building time
	 * based animations and systems to prevent issues caused by large time gaps caused by background tabs, system sleep,
	 * alert dialogs, or other blocking routines. Double the expected frame duration is often an effective value
	 * (ex. maxDelta=50 when running at 40fps).
	 * 
	 * This does not impact any other values (ex. time, runTime, etc), so you may experience issues if you enable maxDelta
	 * when using both delta and other values.
	 * 
	 * If 0, there is no maximum.
	 * @property maxDelta
	 * @static
	 * @type {number}
	 * @default 0
	 */
	Ticker.maxDelta = 0;
	
	/**
	 * When the ticker is paused, all listeners will still receive a tick event, but the <code>paused</code> property
	 * of the event will be `true`. Also, while paused the `runTime` will not increase. See {{#crossLink "Ticker/tick:event"}}{{/crossLink}},
	 * {{#crossLink "Ticker/getTime"}}{{/crossLink}}, and {{#crossLink "Ticker/getEventTime"}}{{/crossLink}} for more
	 * info.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.Ticker.addEventListener("tick", handleTick);
	 *      createjs.Ticker.paused = true;
	 *      function handleTick(event) {
	 *          console.log(event.paused,
	 *          	createjs.Ticker.getTime(false),
	 *          	createjs.Ticker.getTime(true));
	 *      }
	 *
	 * @property paused
	 * @static
	 * @type {Boolean}
	 * @default false
	 **/
	Ticker.paused = false;


// mix-ins:
	// EventDispatcher methods:
	Ticker.removeEventListener = null;
	Ticker.removeAllEventListeners = null;
	Ticker.dispatchEvent = null;
	Ticker.hasEventListener = null;
	Ticker._listeners = null;
	createjs.EventDispatcher.initialize(Ticker); // inject EventDispatcher methods.
	Ticker._addEventListener = Ticker.addEventListener;
	Ticker.addEventListener = function() {
		!Ticker._inited&&Ticker.init();
		return Ticker._addEventListener.apply(Ticker, arguments);
	};


// private static properties:
	/**
	 * @property _inited
	 * @static
	 * @type {Boolean}
	 * @protected
	 **/
	Ticker._inited = false;

	/**
	 * @property _startTime
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._startTime = 0;

	/**
	 * @property _pausedTime
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._pausedTime=0;

	/**
	 * The number of ticks that have passed
	 * @property _ticks
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._ticks = 0;

	/**
	 * The number of ticks that have passed while Ticker has been paused
	 * @property _pausedTicks
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._pausedTicks = 0;

	/**
	 * @property _interval
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._interval = 50;

	/**
	 * @property _lastTime
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._lastTime = 0;

	/**
	 * @property _times
	 * @static
	 * @type {Array}
	 * @protected
	 **/
	Ticker._times = null;

	/**
	 * @property _tickTimes
	 * @static
	 * @type {Array}
	 * @protected
	 **/
	Ticker._tickTimes = null;

	/**
	 * Stores the timeout or requestAnimationFrame id.
	 * @property _timerId
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._timerId = null;
	
	/**
	 * True if currently using requestAnimationFrame, false if using setTimeout. This may be different than timingMode
	 * if that property changed and a tick hasn't fired.
	 * @property _raf
	 * @static
	 * @type {Boolean}
	 * @protected
	 **/
	Ticker._raf = true;
	

// static getter / setters:
	/**
	 * Use the {{#crossLink "Ticker/interval:property"}}{{/crossLink}} property instead.
	 * @method setInterval
	 * @static
	 * @param {Number} interval
	 * @deprecated
	 **/
	Ticker.setInterval = function(interval) {
		Ticker._interval = interval;
		if (!Ticker._inited) { return; }
		Ticker._setupTick();
	};

	/**
	 * Use the {{#crossLink "Ticker/interval:property"}}{{/crossLink}} property instead.
	 * @method getInterval
	 * @static
	 * @return {Number}
	 * @deprecated
	 **/
	Ticker.getInterval = function() {
		return Ticker._interval;
	};

	/**
	 * Use the {{#crossLink "Ticker/framerate:property"}}{{/crossLink}} property instead.
	 * @method setFPS
	 * @static
	 * @param {Number} value
	 * @deprecated
	 **/
	Ticker.setFPS = function(value) {
		Ticker.setInterval(1000/value);
	};

	/**
	 * Use the {{#crossLink "Ticker/framerate:property"}}{{/crossLink}} property instead.
	 * @method getFPS
	 * @static
	 * @return {Number}
	 * @deprecated
	 **/
	Ticker.getFPS = function() {
		return 1000/Ticker._interval;
	};

	/**
	 * Indicates the target time (in milliseconds) between ticks. Default is 50 (20 FPS).
	 * Note that actual time between ticks may be more than specified depending on CPU load.
	 * This property is ignored if the ticker is using the `RAF` timing mode.
	 * @property interval
	 * @static
	 * @type {Number}
	 **/
	 
	/**
	 * Indicates the target frame rate in frames per second (FPS). Effectively just a shortcut to `interval`, where
	 * `framerate == 1000/interval`.
	 * @property framerate
	 * @static
	 * @type {Number}
	 **/
	try {
		Object.defineProperties(Ticker, {
			interval: { get: Ticker.getInterval, set: Ticker.setInterval },
			framerate: { get: Ticker.getFPS, set: Ticker.setFPS }
		});
	} catch (e) { console.log(e); }


// public static methods:
	/**
	 * Starts the tick. This is called automatically when the first listener is added.
	 * @method init
	 * @static
	 **/
	Ticker.init = function() {
		if (Ticker._inited) { return; }
		Ticker._inited = true;
		Ticker._times = [];
		Ticker._tickTimes = [];
		Ticker._startTime = Ticker._getTime();
		Ticker._times.push(Ticker._lastTime = 0);
		Ticker.interval = Ticker._interval;
	};
	
	/**
	 * Stops the Ticker and removes all listeners. Use init() to restart the Ticker.
	 * @method reset
	 * @static
	 **/
	Ticker.reset = function() {
		if (Ticker._raf) {
			var f = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;
			f&&f(Ticker._timerId);
		} else {
			clearTimeout(Ticker._timerId);
		}
		Ticker.removeAllEventListeners("tick");
		Ticker._timerId = Ticker._times = Ticker._tickTimes = null;
		Ticker._startTime = Ticker._lastTime = Ticker._ticks = 0;
		Ticker._inited = false;
	};

	/**
	 * Returns the average time spent within a tick. This can vary significantly from the value provided by getMeasuredFPS
	 * because it only measures the time spent within the tick execution stack. 
	 * 
	 * Example 1: With a target FPS of 20, getMeasuredFPS() returns 20fps, which indicates an average of 50ms between 
	 * the end of one tick and the end of the next. However, getMeasuredTickTime() returns 15ms. This indicates that 
	 * there may be up to 35ms of "idle" time between the end of one tick and the start of the next.
	 *
	 * Example 2: With a target FPS of 30, getFPS() returns 10fps, which indicates an average of 100ms between the end of
	 * one tick and the end of the next. However, getMeasuredTickTime() returns 20ms. This would indicate that something
	 * other than the tick is using ~80ms (another script, DOM rendering, etc).
	 * @method getMeasuredTickTime
	 * @static
	 * @param {Number} [ticks] The number of previous ticks over which to measure the average time spent in a tick.
	 * Defaults to the number of ticks per second. To get only the last tick's time, pass in 1.
	 * @return {Number} The average time spent in a tick in milliseconds.
	 **/
	Ticker.getMeasuredTickTime = function(ticks) {
		var ttl=0, times=Ticker._tickTimes;
		if (!times || times.length < 1) { return -1; }

		// by default, calculate average for the past ~1 second:
		ticks = Math.min(times.length, ticks||(Ticker.getFPS()|0));
		for (var i=0; i<ticks; i++) { ttl += times[i]; }
		return ttl/ticks;
	};

	/**
	 * Returns the actual frames / ticks per second.
	 * @method getMeasuredFPS
	 * @static
	 * @param {Number} [ticks] The number of previous ticks over which to measure the actual frames / ticks per second.
	 * Defaults to the number of ticks per second.
	 * @return {Number} The actual frames / ticks per second. Depending on performance, this may differ
	 * from the target frames per second.
	 **/
	Ticker.getMeasuredFPS = function(ticks) {
		var times = Ticker._times;
		if (!times || times.length < 2) { return -1; }

		// by default, calculate fps for the past ~1 second:
		ticks = Math.min(times.length-1, ticks||(Ticker.getFPS()|0));
		return 1000/((times[0]-times[ticks])/ticks);
	};

	/**
	 * Use the {{#crossLink "Ticker/paused:property"}}{{/crossLink}} property instead.
	 * @method setPaused
	 * @static
	 * @param {Boolean} value
	 * @deprecated
	 **/
	Ticker.setPaused = function(value) {
		// TODO: deprecated.
		Ticker.paused = value;
	};

	/**
	 * Use the {{#crossLink "Ticker/paused:property"}}{{/crossLink}} property instead.
	 * @method getPaused
	 * @static
	 * @return {Boolean}
	 * @deprecated
	 **/
	Ticker.getPaused = function() {
		// TODO: deprecated.
		return Ticker.paused;
	};

	/**
	 * Returns the number of milliseconds that have elapsed since Ticker was initialized via {{#crossLink "Ticker/init"}}.
	 * Returns -1 if Ticker has not been initialized. For example, you could use
	 * this in a time synchronized animation to determine the exact amount of time that has elapsed.
	 * @method getTime
	 * @static
	 * @param {Boolean} [runTime=false] If true only time elapsed while Ticker was not paused will be returned.
	 * If false, the value returned will be total time elapsed since the first tick event listener was added.
	 * @return {Number} Number of milliseconds that have elapsed since Ticker was initialized or -1.
	 **/
	Ticker.getTime = function(runTime) {
		return Ticker._startTime ? Ticker._getTime() - (runTime ? Ticker._pausedTime : 0) : -1;
	};

	/**
	 * Similar to the {{#crossLink "Ticker/getTime"}}{{/crossLink}} method, but returns the time on the most recent {{#crossLink "Ticker/tick:event"}}{{/crossLink}}
	 * event object.
	 * @method getEventTime
	 * @static
	 * @param runTime {Boolean} [runTime=false] If true, the runTime property will be returned instead of time.
	 * @returns {number} The time or runTime property from the most recent tick event or -1.
	 */
	Ticker.getEventTime = function(runTime) {
		return Ticker._startTime ? (Ticker._lastTime || Ticker._startTime) - (runTime ? Ticker._pausedTime : 0) : -1;
	};
	
	/**
	 * Returns the number of ticks that have been broadcast by Ticker.
	 * @method getTicks
	 * @static
	 * @param {Boolean} pauseable Indicates whether to include ticks that would have been broadcast
	 * while Ticker was paused. If true only tick events broadcast while Ticker is not paused will be returned.
	 * If false, tick events that would have been broadcast while Ticker was paused will be included in the return
	 * value. The default value is false.
	 * @return {Number} of ticks that have been broadcast.
	 **/
	Ticker.getTicks = function(pauseable) {
		return  Ticker._ticks - (pauseable ? Ticker._pausedTicks : 0);
	};


// private static methods:
	/**
	 * @method _handleSynch
	 * @static
	 * @protected
	 **/
	Ticker._handleSynch = function() {
		Ticker._timerId = null;
		Ticker._setupTick();

		// run if enough time has elapsed, with a little bit of flexibility to be early:
		if (Ticker._getTime() - Ticker._lastTime >= (Ticker._interval-1)*0.97) {
			Ticker._tick();
		}
	};

	/**
	 * @method _handleRAF
	 * @static
	 * @protected
	 **/
	Ticker._handleRAF = function() {
		Ticker._timerId = null;
		Ticker._setupTick();
		Ticker._tick();
	};

	/**
	 * @method _handleTimeout
	 * @static
	 * @protected
	 **/
	Ticker._handleTimeout = function() {
		Ticker._timerId = null;
		Ticker._setupTick();
		Ticker._tick();
	};

	/**
	 * @method _setupTick
	 * @static
	 * @protected
	 **/
	Ticker._setupTick = function() {
		if (Ticker._timerId != null) { return; } // avoid duplicates

		var mode = Ticker.timingMode||(Ticker.useRAF&&Ticker.RAF_SYNCHED);
		if (mode == Ticker.RAF_SYNCHED || mode == Ticker.RAF) {
			var f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
			if (f) {
				Ticker._timerId = f(mode == Ticker.RAF ? Ticker._handleRAF : Ticker._handleSynch);
				Ticker._raf = true;
				return;
			}
		}
		Ticker._raf = false;
		Ticker._timerId = setTimeout(Ticker._handleTimeout, Ticker._interval);
	};

	/**
	 * @method _tick
	 * @static
	 * @protected
	 **/
	Ticker._tick = function() {
		var paused = Ticker.paused;
		var time = Ticker._getTime();
		var elapsedTime = time-Ticker._lastTime;
		Ticker._lastTime = time;
		Ticker._ticks++;
		
		if (paused) {
			Ticker._pausedTicks++;
			Ticker._pausedTime += elapsedTime;
		}
		
		if (Ticker.hasEventListener("tick")) {
			var event = new createjs.Event("tick");
			var maxDelta = Ticker.maxDelta;
			event.delta = (maxDelta && elapsedTime > maxDelta) ? maxDelta : elapsedTime;
			event.paused = paused;
			event.time = time;
			event.runTime = time-Ticker._pausedTime;
			Ticker.dispatchEvent(event);
		}
		
		Ticker._tickTimes.unshift(Ticker._getTime()-time);
		while (Ticker._tickTimes.length > 100) { Ticker._tickTimes.pop(); }

		Ticker._times.unshift(time);
		while (Ticker._times.length > 100) { Ticker._times.pop(); }
	};

	/**
	 * @method _getTime
	 * @static
	 * @protected
	 **/
	var now = window.performance && (performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow);
	Ticker._getTime = function() {
		return ((now&&now.call(performance))||(new Date().getTime())) - Ticker._startTime;
	};


	createjs.Ticker = Ticker;
}());

//##############################################################################
// UID.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Global utility for generating sequential unique ID numbers. The UID class uses a static interface (ex. <code>UID.get()</code>)
	 * and should not be instantiated.
	 * @class UID
	 * @static
	 **/
	function UID() {
		throw "UID cannot be instantiated";
	}


// private static properties:
	/**
	 * @property _nextID
	 * @type Number
	 * @protected
	 **/
	UID._nextID = 0;


// public static methods:
	/**
	 * Returns the next unique id.
	 * @method get
	 * @return {Number} The next unique id
	 * @static
	 **/
	UID.get = function() {
		return UID._nextID++;
	};


	createjs.UID = UID;
}());

//##############################################################################
// MouseEvent.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Passed as the parameter to all mouse/pointer/touch related events. For a listing of mouse events and their properties,
	 * see the {{#crossLink "DisplayObject"}}{{/crossLink}} and {{#crossLink "Stage"}}{{/crossLink}} event listings.
	 * @class MouseEvent
	 * @param {String} type The event type.
	 * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
	 * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
	 * @param {Number} stageX The normalized x position relative to the stage.
	 * @param {Number} stageY The normalized y position relative to the stage.
	 * @param {MouseEvent} nativeEvent The native DOM event related to this mouse event.
	 * @param {Number} pointerID The unique id for the pointer.
	 * @param {Boolean} primary Indicates whether this is the primary pointer in a multitouch environment.
	 * @param {Number} rawX The raw x position relative to the stage.
	 * @param {Number} rawY The raw y position relative to the stage.
	 * @param {DisplayObject} relatedTarget The secondary target for the event.
	 * @extends Event
	 * @constructor
	 **/
	function MouseEvent(type, bubbles, cancelable, stageX, stageY, nativeEvent, pointerID, primary, rawX, rawY, relatedTarget) {
		this.Event_constructor(type, bubbles, cancelable);
		
		
	// public properties:
		/**
		 * The normalized x position on the stage. This will always be within the range 0 to stage width.
		 * @property stageX
		 * @type Number
		*/
		this.stageX = stageX;
	
		/**
		 * The normalized y position on the stage. This will always be within the range 0 to stage height.
		 * @property stageY
		 * @type Number
		 **/
		this.stageY = stageY;
	
		/**
		 * The raw x position relative to the stage. Normally this will be the same as the stageX value, unless
		 * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.
		 * @property rawX
		 * @type Number
		*/
		this.rawX = (rawX==null)?stageX:rawX;
	
		/**
		 * The raw y position relative to the stage. Normally this will be the same as the stageY value, unless
		 * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.
		 * @property rawY
		 * @type Number
		*/
		this.rawY = (rawY==null)?stageY:rawY;
	
		/**
		 * The native MouseEvent generated by the browser. The properties and API for this
		 * event may differ between browsers. This property will be null if the
		 * EaselJS property was not directly generated from a native MouseEvent.
		 * @property nativeEvent
		 * @type HtmlMouseEvent
		 * @default null
		 **/
		this.nativeEvent = nativeEvent;
	
		/**
		 * The unique id for the pointer (touch point or cursor). This will be either -1 for the mouse, or the system
		 * supplied id value.
		 * @property pointerID
		 * @type {Number}
		 */
		this.pointerID = pointerID;
	
		/**
		 * Indicates whether this is the primary pointer in a multitouch environment. This will always be true for the mouse.
		 * For touch pointers, the first pointer in the current stack will be considered the primary pointer.
		 * @property primary
		 * @type {Boolean}
		 */
		this.primary = !!primary;
		
		/**
		 * The secondary target for the event, if applicable. This is used for mouseout/rollout
		 * events to indicate the object that the mouse entered from, mouseover/rollover for the object the mouse exited,
		 * and stagemousedown/stagemouseup events for the object that was the under the cursor, if any.
		 * 
		 * Only valid interaction targets will be returned (ie. objects with mouse listeners or a cursor set).
		 * @property relatedTarget
		 * @type {DisplayObject}
		 */
		this.relatedTarget = relatedTarget;
	}
	var p = createjs.extend(MouseEvent, createjs.Event);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
	
// getter / setters:
	/**
	 * Returns the x position of the mouse in the local coordinate system of the current target (ie. the dispatcher).
	 * @property localX
	 * @type {Number}
	 * @readonly
	 */
	p._get_localX = function() {
		return this.currentTarget.globalToLocal(this.rawX, this.rawY).x;
	};
	
	/**
	 * Returns the y position of the mouse in the local coordinate system of the current target (ie. the dispatcher).
	 * @property localY
	 * @type {Number}
	 * @readonly
	 */
	p._get_localY = function() {
		return this.currentTarget.globalToLocal(this.rawX, this.rawY).y;
	};
	
	/**
	 * Indicates whether the event was generated by a touch input (versus a mouse input).
	 * @property isTouch
	 * @type {Boolean}
	 * @readonly
	 */
	p._get_isTouch = function() {
		return this.pointerID !== -1;
	};
	
	
	try {
		Object.defineProperties(p, {
			localX: { get: p._get_localX },
			localY: { get: p._get_localY },
			isTouch: { get: p._get_isTouch }
		});
	} catch (e) {} // TODO: use Log


// public methods:
	/**
	 * Returns a clone of the MouseEvent instance.
	 * @method clone
	 * @return {MouseEvent} a clone of the MouseEvent instance.
	 **/
	p.clone = function() {
		return new MouseEvent(this.type, this.bubbles, this.cancelable, this.stageX, this.stageY, this.nativeEvent, this.pointerID, this.primary, this.rawX, this.rawY);
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[MouseEvent (type="+this.type+" stageX="+this.stageX+" stageY="+this.stageY+")]";
	};


	createjs.MouseEvent = createjs.promote(MouseEvent, "Event");
}());

//##############################################################################
// Matrix2D.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Represents an affine transformation matrix, and provides tools for constructing and concatenating matrices.
	 *
	 * This matrix can be visualized as:
	 *
	 * 	[ a  c  tx
	 * 	  b  d  ty
	 * 	  0  0  1  ]
	 *
	 * Note the locations of b and c.
	 *
	 * @class Matrix2D
	 * @param {Number} [a=1] Specifies the a property for the new matrix.
	 * @param {Number} [b=0] Specifies the b property for the new matrix.
	 * @param {Number} [c=0] Specifies the c property for the new matrix.
	 * @param {Number} [d=1] Specifies the d property for the new matrix.
	 * @param {Number} [tx=0] Specifies the tx property for the new matrix.
	 * @param {Number} [ty=0] Specifies the ty property for the new matrix.
	 * @constructor
	 **/
	function Matrix2D(a, b, c, d, tx, ty) {
		this.setValues(a,b,c,d,tx,ty);
		
	// public properties:
		// assigned in the setValues method.
		/**
		 * Position (0, 0) in a 3x3 affine transformation matrix.
		 * @property a
		 * @type Number
		 **/
	
		/**
		 * Position (0, 1) in a 3x3 affine transformation matrix.
		 * @property b
		 * @type Number
		 **/
	
		/**
		 * Position (1, 0) in a 3x3 affine transformation matrix.
		 * @property c
		 * @type Number
		 **/
	
		/**
		 * Position (1, 1) in a 3x3 affine transformation matrix.
		 * @property d
		 * @type Number
		 **/
	
		/**
		 * Position (2, 0) in a 3x3 affine transformation matrix.
		 * @property tx
		 * @type Number
		 **/
	
		/**
		 * Position (2, 1) in a 3x3 affine transformation matrix.
		 * @property ty
		 * @type Number
		 **/
	}
	var p = Matrix2D.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// constants:
	/**
	 * Multiplier for converting degrees to radians. Used internally by Matrix2D.
	 * @property DEG_TO_RAD
	 * @static
	 * @final
	 * @type Number
	 * @readonly
	 **/
	Matrix2D.DEG_TO_RAD = Math.PI/180;


// static public properties:
	/**
	 * An identity matrix, representing a null transformation.
	 * @property identity
	 * @static
	 * @type Matrix2D
	 * @readonly
	 **/
	Matrix2D.identity = null; // set at bottom of class definition.
	

// public methods:
	/**
	 * Sets the specified values on this instance. 
	 * @method setValues
	 * @param {Number} [a=1] Specifies the a property for the new matrix.
	 * @param {Number} [b=0] Specifies the b property for the new matrix.
	 * @param {Number} [c=0] Specifies the c property for the new matrix.
	 * @param {Number} [d=1] Specifies the d property for the new matrix.
	 * @param {Number} [tx=0] Specifies the tx property for the new matrix.
	 * @param {Number} [ty=0] Specifies the ty property for the new matrix.
	 * @return {Matrix2D} This instance. Useful for chaining method calls.
	*/
	p.setValues = function(a, b, c, d, tx, ty) {
		// don't forget to update docs in the constructor if these change:
		this.a = (a == null) ? 1 : a;
		this.b = b || 0;
		this.c = c || 0;
		this.d = (d == null) ? 1 : d;
		this.tx = tx || 0;
		this.ty = ty || 0;
		return this;
	};

	/**
	 * Appends the specified matrix properties to this matrix. All parameters are required.
	 * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.
	 * @method append
	 * @param {Number} a
	 * @param {Number} b
	 * @param {Number} c
	 * @param {Number} d
	 * @param {Number} tx
	 * @param {Number} ty
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.append = function(a, b, c, d, tx, ty) {
		var a1 = this.a;
		var b1 = this.b;
		var c1 = this.c;
		var d1 = this.d;
		if (a != 1 || b != 0 || c != 0 || d != 1) {
			this.a  = a1*a+c1*b;
			this.b  = b1*a+d1*b;
			this.c  = a1*c+c1*d;
			this.d  = b1*c+d1*d;
		}
		this.tx = a1*tx+c1*ty+this.tx;
		this.ty = b1*tx+d1*ty+this.ty;
		return this;
	};

	/**
	 * Prepends the specified matrix properties to this matrix.
	 * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.
	 * All parameters are required.
	 * @method prepend
	 * @param {Number} a
	 * @param {Number} b
	 * @param {Number} c
	 * @param {Number} d
	 * @param {Number} tx
	 * @param {Number} ty
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.prepend = function(a, b, c, d, tx, ty) {
		var a1 = this.a;
		var c1 = this.c;
		var tx1 = this.tx;

		this.a  = a*a1+c*this.b;
		this.b  = b*a1+d*this.b;
		this.c  = a*c1+c*this.d;
		this.d  = b*c1+d*this.d;
		this.tx = a*tx1+c*this.ty+tx;
		this.ty = b*tx1+d*this.ty+ty;
		return this;
	};

	/**
	 * Appends the specified matrix to this matrix.
	 * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.
	 * @method appendMatrix
	 * @param {Matrix2D} matrix
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.appendMatrix = function(matrix) {
		return this.append(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
	};

	/**
	 * Prepends the specified matrix to this matrix.
	 * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.
	 * For example, you could calculate the combined transformation for a child object using:
	 * 
	 * 	var o = myDisplayObject;
	 * 	var mtx = o.getMatrix();
	 * 	while (o = o.parent) {
	 * 		// prepend each parent's transformation in turn:
	 * 		o.prependMatrix(o.getMatrix());
	 * 	}
	 * @method prependMatrix
	 * @param {Matrix2D} matrix
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.prependMatrix = function(matrix) {
		return this.prepend(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
	};

	/**
	 * Generates matrix properties from the specified display object transform properties, and appends them to this matrix.
	 * For example, you can use this to generate a matrix representing the transformations of a display object:
	 * 
	 * 	var mtx = new Matrix2D();
	 * 	mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);
	 * @method appendTransform
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} scaleX
	 * @param {Number} scaleY
	 * @param {Number} rotation
	 * @param {Number} skewX
	 * @param {Number} skewY
	 * @param {Number} regX Optional.
	 * @param {Number} regY Optional.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.appendTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
		if (rotation%360) {
			var r = rotation*Matrix2D.DEG_TO_RAD;
			var cos = Math.cos(r);
			var sin = Math.sin(r);
		} else {
			cos = 1;
			sin = 0;
		}

		if (skewX || skewY) {
			// TODO: can this be combined into a single append operation?
			skewX *= Matrix2D.DEG_TO_RAD;
			skewY *= Matrix2D.DEG_TO_RAD;
			this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
			this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
		} else {
			this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
		}
		
		if (regX || regY) {
			// append the registration offset:
			this.tx -= regX*this.a+regY*this.c; 
			this.ty -= regX*this.b+regY*this.d;
		}
		return this;
	};

	/**
	 * Generates matrix properties from the specified display object transform properties, and prepends them to this matrix.
	 * For example, you could calculate the combined transformation for a child object using:
	 * 
	 * 	var o = myDisplayObject;
	 * 	var mtx = new createjs.Matrix2D();
	 * 	do  {
	 * 		// prepend each parent's transformation in turn:
	 * 		mtx.prependTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);
	 * 	} while (o = o.parent);
	 * 	
	 * 	Note that the above example would not account for {{#crossLink "DisplayObject/transformMatrix:property"}}{{/crossLink}}
	 * 	values. See {{#crossLink "Matrix2D/prependMatrix"}}{{/crossLink}} for an example that does.
	 * @method prependTransform
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} scaleX
	 * @param {Number} scaleY
	 * @param {Number} rotation
	 * @param {Number} skewX
	 * @param {Number} skewY
	 * @param {Number} regX Optional.
	 * @param {Number} regY Optional.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.prependTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
		if (rotation%360) {
			var r = rotation*Matrix2D.DEG_TO_RAD;
			var cos = Math.cos(r);
			var sin = Math.sin(r);
		} else {
			cos = 1;
			sin = 0;
		}

		if (regX || regY) {
			// prepend the registration offset:
			this.tx -= regX; this.ty -= regY;
		}
		if (skewX || skewY) {
			// TODO: can this be combined into a single prepend operation?
			skewX *= Matrix2D.DEG_TO_RAD;
			skewY *= Matrix2D.DEG_TO_RAD;
			this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
			this.prepend(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
		} else {
			this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
		}
		return this;
	};

	/**
	 * Applies a clockwise rotation transformation to the matrix.
	 * @method rotate
	 * @param {Number} angle The angle to rotate by, in degrees. To use a value in radians, multiply it by `180/Math.PI`.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.rotate = function(angle) {
		angle = angle*Matrix2D.DEG_TO_RAD;
		var cos = Math.cos(angle);
		var sin = Math.sin(angle);

		var a1 = this.a;
		var b1 = this.b;

		this.a = a1*cos+this.c*sin;
		this.b = b1*cos+this.d*sin;
		this.c = -a1*sin+this.c*cos;
		this.d = -b1*sin+this.d*cos;
		return this;
	};

	/**
	 * Applies a skew transformation to the matrix.
	 * @method skew
	 * @param {Number} skewX The amount to skew horizontally in degrees. To use a value in radians, multiply it by `180/Math.PI`.
	 * @param {Number} skewY The amount to skew vertically in degrees.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	*/
	p.skew = function(skewX, skewY) {
		skewX = skewX*Matrix2D.DEG_TO_RAD;
		skewY = skewY*Matrix2D.DEG_TO_RAD;
		this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), 0, 0);
		return this;
	};

	/**
	 * Applies a scale transformation to the matrix.
	 * @method scale
	 * @param {Number} x The amount to scale horizontally. E.G. a value of 2 will double the size in the X direction, and 0.5 will halve it.
	 * @param {Number} y The amount to scale vertically.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.scale = function(x, y) {
		this.a *= x;
		this.b *= x;
		this.c *= y;
		this.d *= y;
		//this.tx *= x;
		//this.ty *= y;
		return this;
	};

	/**
	 * Translates the matrix on the x and y axes.
	 * @method translate
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.translate = function(x, y) {
		this.tx += this.a*x + this.c*y;
		this.ty += this.b*x + this.d*y;
		return this;
	};

	/**
	 * Sets the properties of the matrix to those of an identity matrix (one that applies a null transformation).
	 * @method identity
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.identity = function() {
		this.a = this.d = 1;
		this.b = this.c = this.tx = this.ty = 0;
		return this;
	};

	/**
	 * Inverts the matrix, causing it to perform the opposite transformation.
	 * @method invert
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.invert = function() {
		var a1 = this.a;
		var b1 = this.b;
		var c1 = this.c;
		var d1 = this.d;
		var tx1 = this.tx;
		var n = a1*d1-b1*c1;

		this.a = d1/n;
		this.b = -b1/n;
		this.c = -c1/n;
		this.d = a1/n;
		this.tx = (c1*this.ty-d1*tx1)/n;
		this.ty = -(a1*this.ty-b1*tx1)/n;
		return this;
	};

	/**
	 * Returns true if the matrix is an identity matrix.
	 * @method isIdentity
	 * @return {Boolean}
	 **/
	p.isIdentity = function() {
		return this.tx === 0 && this.ty === 0 && this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1;
	};
	
	/**
	 * Returns true if this matrix is equal to the specified matrix (all property values are equal).
	 * @method equals
	 * @param {Matrix2D} matrix The matrix to compare.
	 * @return {Boolean}
	 **/
	p.equals = function(matrix) {
		return this.tx === matrix.tx && this.ty === matrix.ty && this.a === matrix.a && this.b === matrix.b && this.c === matrix.c && this.d === matrix.d;
	};

	/**
	 * Transforms a point according to this matrix.
	 * @method transformPoint
	 * @param {Number} x The x component of the point to transform.
	 * @param {Number} y The y component of the point to transform.
	 * @param {Point | Object} [pt] An object to copy the result into. If omitted a generic object with x/y properties will be returned.
	 * @return {Point} This matrix. Useful for chaining method calls.
	 **/
	p.transformPoint = function(x, y, pt) {
		pt = pt||{};
		pt.x = x*this.a+y*this.c+this.tx;
		pt.y = x*this.b+y*this.d+this.ty;
		return pt;
	};

	/**
	 * Decomposes the matrix into transform properties (x, y, scaleX, scaleY, and rotation). Note that these values
	 * may not match the transform properties you used to generate the matrix, though they will produce the same visual
	 * results.
	 * @method decompose
	 * @param {Object} target The object to apply the transform properties to. If null, then a new object will be returned.
	 * @return {Object} The target, or a new generic object with the transform properties applied.
	*/
	p.decompose = function(target) {
		// TODO: it would be nice to be able to solve for whether the matrix can be decomposed into only scale/rotation even when scale is negative
		if (target == null) { target = {}; }
		target.x = this.tx;
		target.y = this.ty;
		target.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);
		target.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);

		var skewX = Math.atan2(-this.c, this.d);
		var skewY = Math.atan2(this.b, this.a);

		var delta = Math.abs(1-skewX/skewY);
		if (delta < 0.00001) { // effectively identical, can use rotation:
			target.rotation = skewY/Matrix2D.DEG_TO_RAD;
			if (this.a < 0 && this.d >= 0) {
				target.rotation += (target.rotation <= 0) ? 180 : -180;
			}
			target.skewX = target.skewY = 0;
		} else {
			target.skewX = skewX/Matrix2D.DEG_TO_RAD;
			target.skewY = skewY/Matrix2D.DEG_TO_RAD;
		}
		return target;
	};
	
	/**
	 * Copies all properties from the specified matrix to this matrix.
	 * @method copy
	 * @param {Matrix2D} matrix The matrix to copy properties from.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	*/
	p.copy = function(matrix) {
		return this.setValues(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
	};

	/**
	 * Returns a clone of the Matrix2D instance.
	 * @method clone
	 * @return {Matrix2D} a clone of the Matrix2D instance.
	 **/
	p.clone = function() {
		return new Matrix2D(this.a, this.b, this.c, this.d, this.tx, this.ty);
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Matrix2D (a="+this.a+" b="+this.b+" c="+this.c+" d="+this.d+" tx="+this.tx+" ty="+this.ty+")]";
	};

	// this has to be populated after the class is defined:
	Matrix2D.identity = new Matrix2D();


	createjs.Matrix2D = Matrix2D;
}());

//##############################################################################
// DisplayProps.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

	/**
	 * Used for calculating and encapsulating display related properties.
	 * @class DisplayProps
	 * @param {Number} [visible=true] Visible value.
	 * @param {Number} [alpha=0] Alpha value.
	 * @param {Number} [shadow=null] A Shadow instance or null.
	 * @param {Number} [compositeOperation=null] A compositeOperation value or null.
	 * @param {Number} [matrix] A transformation matrix. Defaults to a new identity matrix.
	 * @constructor
	 **/
	function DisplayProps(visible, alpha, shadow, compositeOperation, matrix) {
		this.setValues(visible, alpha, shadow, compositeOperation, matrix);
		
	// public properties:
		// assigned in the setValues method.
		/**
		 * Property representing the alpha that will be applied to a display object.
		 * @property alpha
		 * @type Number
		 **/
	
		/**
		 * Property representing the shadow that will be applied to a display object.
		 * @property shadow
		 * @type Shadow
		 **/
	
		/**
		 * Property representing the compositeOperation that will be applied to a display object.
		 * You can find a list of valid composite operations at:
		 * <a href="https://developer.mozilla.org/en/Canvas_tutorial/Compositing">https://developer.mozilla.org/en/Canvas_tutorial/Compositing</a>
		 * @property compositeOperation
		 * @type String
		 **/
		
		/**
		 * Property representing the value for visible that will be applied to a display object.
		 * @property visible
		 * @type Boolean
		 **/
		
		/**
		 * The transformation matrix that will be applied to a display object.
		 * @property matrix
		 * @type Matrix2D
		 **/
	}
	var p = DisplayProps.prototype;

// initialization:
	/**
	 * Reinitializes the instance with the specified values.
	 * @method setValues
	 * @param {Number} [visible=true] Visible value.
	 * @param {Number} [alpha=1] Alpha value.
	 * @param {Number} [shadow=null] A Shadow instance or null.
	 * @param {Number} [compositeOperation=null] A compositeOperation value or null.
	 * @param {Number} [matrix] A transformation matrix. Defaults to an identity matrix.
	 * @return {DisplayProps} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.setValues = function (visible, alpha, shadow, compositeOperation, matrix) {
		this.visible = visible == null ? true : !!visible;
		this.alpha = alpha == null ? 1 : alpha;
		this.shadow = shadow;
		this.compositeOperation = shadow;
		this.matrix = matrix || (this.matrix&&this.matrix.identity()) || new createjs.Matrix2D();
		return this;
	};

// public methods:
	/**
	 * Appends the specified display properties. This is generally used to apply a child's properties its parent's.
	 * @method append
	 * @param {Boolean} visible desired visible value
	 * @param {Number} alpha desired alpha value
	 * @param {Shadow} shadow desired shadow value
	 * @param {String} compositeOperation desired composite operation value
	 * @param {Matrix2D} [matrix] a Matrix2D instance
	 * @return {DisplayProps} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.append = function(visible, alpha, shadow, compositeOperation, matrix) {
		this.alpha *= alpha;
		this.shadow = shadow || this.shadow;
		this.compositeOperation = compositeOperation || this.compositeOperation;
		this.visible = this.visible && visible;
		matrix&&this.matrix.appendMatrix(matrix);
		return this;
	};
	
	/**
	 * Prepends the specified display properties. This is generally used to apply a parent's properties to a child's.
	 * For example, to get the combined display properties that would be applied to a child, you could use:
	 * 
	 * 	var o = myDisplayObject;
	 * 	var props = new createjs.DisplayProps();
	 * 	do {
	 * 		// prepend each parent's props in turn:
	 * 		props.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation, o.getMatrix());
	 * 	} while (o = o.parent);
	 * 	
	 * @method prepend
	 * @param {Boolean} visible desired visible value
	 * @param {Number} alpha desired alpha value
	 * @param {Shadow} shadow desired shadow value
	 * @param {String} compositeOperation desired composite operation value
	 * @param {Matrix2D} [matrix] a Matrix2D instance
	 * @return {DisplayProps} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.prepend = function(visible, alpha, shadow, compositeOperation, matrix) {
		this.alpha *= alpha;
		this.shadow = this.shadow || shadow;
		this.compositeOperation = this.compositeOperation || compositeOperation;
		this.visible = this.visible && visible;
		matrix&&this.matrix.prependMatrix(matrix);
		return this;
	};
	
	/**
	 * Resets this instance and its matrix to default values.
	 * @method identity
	 * @return {DisplayProps} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.identity = function() {
		this.visible = true;
		this.alpha = 1;
		this.shadow = this.compositeOperation = null;
		this.matrix.identity();
		return this;
	};
	
	/**
	 * Returns a clone of the DisplayProps instance. Clones the associated matrix.
	 * @method clone
	 * @return {DisplayProps} a clone of the DisplayProps instance.
	 **/
	p.clone = function() {
		return new DisplayProps(this.alpha, this.shadow, this.compositeOperation, this.visible, this.matrix.clone());
	};

// private methods:

	createjs.DisplayProps = DisplayProps;
})();

//##############################################################################
// Point.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Represents a point on a 2 dimensional x / y coordinate system.
	 *
	 * <h4>Example</h4>
	 * 
	 *      var point = new createjs.Point(0, 100);
	 * 
	 * @class Point
	 * @param {Number} [x=0] X position.
	 * @param {Number} [y=0] Y position.
	 * @constructor
	 **/
	function Point(x, y) {
	 	this.setValues(x, y);
	 	
	 	
	// public properties:
		// assigned in the setValues method.
		/**
		 * X position.
		 * @property x
		 * @type Number
		 **/
	
		/**
		 * Y position.
		 * @property y
		 * @type Number
		 **/
	}
	var p = Point.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.

	
// public methods:
	/** 
	 * Sets the specified values on this instance.
	 * @method setValues
	 * @param {Number} [x=0] X position.
	 * @param {Number} [y=0] Y position.
	 * @return {Point} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.setValues = function(x, y) {
		this.x = x||0;
		this.y = y||0;
		return this;
	};
	
	/**
	 * Copies all properties from the specified point to this point.
	 * @method copy
	 * @param {Point} point The point to copy properties from.
	 * @return {Point} This point. Useful for chaining method calls.
	 * @chainable
	*/
	p.copy = function(point) {
		this.x = point.x;
		this.y = point.y;
		return this;
	};
	
	/**
	 * Returns a clone of the Point instance.
	 * @method clone
	 * @return {Point} a clone of the Point instance.
	 **/
	p.clone = function() {
		return new Point(this.x, this.y);
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Point (x="+this.x+" y="+this.y+")]";
	};
	
	
	createjs.Point = Point;
}());

//##############################################################################
// Rectangle.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Represents a rectangle as defined by the points (x, y) and (x+width, y+height).
	 *
	 * <h4>Example</h4>
	 *
	 *      var rect = new createjs.Rectangle(0, 0, 100, 100);
	 *
	 * @class Rectangle
	 * @param {Number} [x=0] X position.
	 * @param {Number} [y=0] Y position.
	 * @param {Number} [width=0] The width of the Rectangle.
	 * @param {Number} [height=0] The height of the Rectangle.
	 * @constructor
	 **/
	function Rectangle(x, y, width, height) {
		this.setValues(x, y, width, height);
		
		
	// public properties:
		// assigned in the setValues method.
		/**
		 * X position.
		 * @property x
		 * @type Number
		 **/
	
		/**
		 * Y position.
		 * @property y
		 * @type Number
		 **/
	
		/**
		 * Width.
		 * @property width
		 * @type Number
		 **/
	
		/**
		 * Height.
		 * @property height
		 * @type Number
		 **/
	}
	var p = Rectangle.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// public methods:
	/** 
	 * Sets the specified values on this instance.
	 * @method setValues
	 * @param {Number} [x=0] X position.
	 * @param {Number} [y=0] Y position.
	 * @param {Number} [width=0] The width of the Rectangle.
	 * @param {Number} [height=0] The height of the Rectangle.
	 * @return {Rectangle} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.setValues = function(x, y, width, height) {
		// don't forget to update docs in the constructor if these change:
		this.x = x||0;
		this.y = y||0;
		this.width = width||0;
		this.height = height||0;
		return this;
	};
	
	/** 
	 * Extends the rectangle's bounds to include the described point or rectangle.
	 * @method extend
	 * @param {Number} x X position of the point or rectangle.
	 * @param {Number} y Y position of the point or rectangle.
	 * @param {Number} [width=0] The width of the rectangle.
	 * @param {Number} [height=0] The height of the rectangle.
	 * @return {Rectangle} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.extend = function(x, y, width, height) {
		width = width||0;
		height = height||0;
		if (x+width > this.x+this.width) { this.width = x+width-this.x; }
		if (y+height > this.y+this.height) { this.height = y+height-this.y; }
		if (x < this.x) { this.width += this.x-x; this.x = x; }
		if (y < this.y) { this.height += this.y-y; this.y = y; }
		return this;
	};
	
	/** 
	 * Adds the specified padding to the rectangle's bounds.
	 * @method extend
	 * @param {Number} [top=0]
	 * @param {Number} [left=0]
	 * @param {Number} [right=0]
	 * @param {Number} [bottom=0]
	 * @return {Rectangle} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.pad = function(top, left, bottom, right) {
		this.x -= left;
		this.y -= top;
		this.width += left+right;
		this.height += top+bottom;
		return this;
	};
	
	/**
	 * Copies all properties from the specified rectangle to this rectangle.
	 * @method copy
	 * @param {Rectangle} rectangle The rectangle to copy properties from.
	 * @return {Rectangle} This rectangle. Useful for chaining method calls.
	 * @chainable
	*/
	p.copy = function(rectangle) {
		return this.setValues(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
	};
	
	/** 
	 * Returns true if this rectangle fully encloses the described point or rectangle.
	 * @method contains
	 * @param {Number} x X position of the point or rectangle.
	 * @param {Number} y Y position of the point or rectangle.
	 * @param {Number} [width=0] The width of the rectangle.
	 * @param {Number} [height=0] The height of the rectangle.
	 * @return {Boolean} True if the described point or rectangle is contained within this rectangle.
	*/
	p.contains = function(x, y, width, height) {
		width = width||0;
		height = height||0;
		return (x >= this.x && x+width <= this.x+this.width && y >= this.y && y+height <= this.y+this.height);
	};
	
	/** 
	 * Returns a new rectangle which contains this rectangle and the specified rectangle.
	 * @method union
	 * @param {Rectangle} rect The rectangle to calculate a union with.
	 * @return {Rectangle} A new rectangle describing the union.
	*/
	p.union = function(rect) {
		return this.clone().extend(rect.x, rect.y, rect.width, rect.height);
	};
	
	/** 
	 * Returns a new rectangle which describes the intersection (overlap) of this rectangle and the specified rectangle,
	 * or null if they do not intersect.
	 * @method intersection
	 * @param {Rectangle} rect The rectangle to calculate an intersection with.
	 * @return {Rectangle} A new rectangle describing the intersection or null.
	*/
	p.intersection = function(rect) {
		var x1 = rect.x, y1 = rect.y, x2 = x1+rect.width, y2 = y1+rect.height;
		if (this.x > x1) { x1 = this.x; }
		if (this.y > y1) { y1 = this.y; }
		if (this.x + this.width < x2) { x2 = this.x + this.width; }
		if (this.y + this.height < y2) { y2 = this.y + this.height; }
		return (x2 <= x1 || y2 <= y1) ? null : new Rectangle(x1, y1, x2-x1, y2-y1);
	};
	
	/** 
	 * Returns true if the specified rectangle intersects (has any overlap) with this rectangle.
	 * @method intersects
	 * @param {Rectangle} rect The rectangle to compare.
	 * @return {Boolean} True if the rectangles intersect.
	*/
	p.intersects = function(rect) {
		return (rect.x <= this.x+this.width && this.x <= rect.x+rect.width && rect.y <= this.y+this.height && this.y <= rect.y + rect.height);
	};
	
	/** 
	 * Returns true if the width or height are equal or less than 0.
	 * @method isEmpty
	 * @return {Boolean} True if the rectangle is empty.
	*/
	p.isEmpty = function() {
		return this.width <= 0 || this.height <= 0;
	};
	
	/**
	 * Returns a clone of the Rectangle instance.
	 * @method clone
	 * @return {Rectangle} a clone of the Rectangle instance.
	 **/
	p.clone = function() {
		return new Rectangle(this.x, this.y, this.width, this.height);
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Rectangle (x="+this.x+" y="+this.y+" width="+this.width+" height="+this.height+")]";
	};
	
	
	createjs.Rectangle = Rectangle;
}());

//##############################################################################
// ButtonHelper.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * The ButtonHelper is a helper class to create interactive buttons from {{#crossLink "MovieClip"}}{{/crossLink}} or
	 * {{#crossLink "Sprite"}}{{/crossLink}} instances. This class will intercept mouse events from an object, and
	 * automatically call {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} or {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}},
	 * to the respective animation labels, add a pointer cursor, and allows the user to define a hit state frame.
	 *
	 * The ButtonHelper instance does not need to be added to the stage, but a reference should be maintained to prevent
	 * garbage collection.
	 * 
	 * Note that over states will not work unless you call {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}.
	 *
	 * <h4>Example</h4>
	 *
	 *      var helper = new createjs.ButtonHelper(myInstance, "out", "over", "down", false, myInstance, "hit");
	 *      myInstance.addEventListener("click", handleClick);
	 *      function handleClick(event) {
	 *          // Click Happened.
	 *      }
	 *
	 * @class ButtonHelper
	 * @param {Sprite|MovieClip} target The instance to manage.
	 * @param {String} [outLabel="out"] The label or animation to go to when the user rolls out of the button.
	 * @param {String} [overLabel="over"] The label or animation to go to when the user rolls over the button.
	 * @param {String} [downLabel="down"] The label or animation to go to when the user presses the button.
	 * @param {Boolean} [play=false] If the helper should call "gotoAndPlay" or "gotoAndStop" on the button when changing
	 * states.
	 * @param {DisplayObject} [hitArea] An optional item to use as the hit state for the button. If this is not defined,
	 * then the button's visible states will be used instead. Note that the same instance as the "target" argument can be
	 * used for the hitState.
	 * @param {String} [hitLabel] The label or animation on the hitArea instance that defines the hitArea bounds. If this is
	 * null, then the default state of the hitArea will be used. *
	 * @constructor
	 */
	function ButtonHelper(target, outLabel, overLabel, downLabel, play, hitArea, hitLabel) {
		if (!target.addEventListener) { return; }
	
	
	// public properties:
		/**
		 * The target for this button helper.
		 * @property target
		 * @type MovieClip | Sprite
		 * @readonly
		 **/
		this.target = target;
	
		/**
		 * The label name or frame number to display when the user mouses out of the target. Defaults to "over".
		 * @property overLabel
		 * @type String | Number
		 **/
		this.overLabel = overLabel == null ? "over" : overLabel;
	
		/**
		 * The label name or frame number to display when the user mouses over the target. Defaults to "out".
		 * @property outLabel
		 * @type String | Number
		 **/
		this.outLabel = outLabel == null ? "out" : outLabel;
	
		/**
		 * The label name or frame number to display when the user presses on the target. Defaults to "down".
		 * @property downLabel
		 * @type String | Number
		 **/
		this.downLabel = downLabel == null ? "down" : downLabel;
	
		/**
		 * If true, then ButtonHelper will call gotoAndPlay, if false, it will use gotoAndStop. Default is false.
		 * @property play
		 * @default false
		 * @type Boolean
		 **/
		this.play = play;
		
		
	//  private properties
		/**
		 * @property _isPressed
		 * @type Boolean
		 * @protected
		 **/
		this._isPressed = false;
	
		/**
		 * @property _isOver
		 * @type Boolean
		 * @protected
		 **/
		this._isOver = false;
	
		/**
		 * @property _enabled
		 * @type Boolean
		 * @protected
		 **/
		this._enabled = false;
		
	// setup:
		target.mouseChildren = false; // prevents issues when children are removed from the display list when state changes.
		this.enabled = true;
		this.handleEvent({});
		if (hitArea) {
			if (hitLabel) {
				hitArea.actionsEnabled = false;
				hitArea.gotoAndStop&&hitArea.gotoAndStop(hitLabel);
			}
			target.hitArea = hitArea;
		}
	}
	var p = ButtonHelper.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.

	
// getter / setters:
	/**
	 * Use the {{#crossLink "ButtonHelper/enabled:property"}}{{/crossLink}} property instead.
	 * @method setEnabled
	 * @param {Boolean} value
	 * @deprecated
	 **/
	p.setEnabled = function(value) { // TODO: deprecated.
		if (value == this._enabled) { return; }
		var o = this.target;
		this._enabled = value;
		if (value) {
			o.cursor = "pointer";
			o.addEventListener("rollover", this);
			o.addEventListener("rollout", this);
			o.addEventListener("mousedown", this);
			o.addEventListener("pressup", this);
			if (o._reset) { o.__reset = o._reset; o._reset = this._reset;}
		} else {
			o.cursor = null;
			o.removeEventListener("rollover", this);
			o.removeEventListener("rollout", this);
			o.removeEventListener("mousedown", this);
			o.removeEventListener("pressup", this);
			if (o.__reset) { o._reset = o.__reset; delete(o.__reset); }
		}
	};
	/**
	 * Use the {{#crossLink "ButtonHelper/enabled:property"}}{{/crossLink}} property instead.
	 * @method getEnabled
	 * @return {Boolean}
	 * @deprecated
	 **/
	p.getEnabled = function() {
		return this._enabled;
	};

	/**
	 * Enables or disables the button functionality on the target.
	 * @property enabled
	 * @type {Boolean}
	 **/
	try {
		Object.defineProperties(p, {
			enabled: { get: p.getEnabled, set: p.setEnabled }
		});
	} catch (e) {} // TODO: use Log


// public methods:
	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[ButtonHelper]";
	};


// private methods:
	/**
	 * @method handleEvent
	 * @param {Object} evt The mouse event to handle.
	 * @protected
	 **/
	p.handleEvent = function(evt) {
		var label, t = this.target, type = evt.type;
		if (type == "mousedown") {
			this._isPressed = true;
			label = this.downLabel;
		} else if (type == "pressup") {
			this._isPressed = false;
			label = this._isOver ? this.overLabel : this.outLabel;
		} else if (type == "rollover") {
			this._isOver = true;
			label = this._isPressed ? this.downLabel : this.overLabel;
		} else { // rollout and default
			this._isOver = false;
			label = this._isPressed ? this.overLabel : this.outLabel;
		}
		if (this.play) {
			t.gotoAndPlay&&t.gotoAndPlay(label);
		} else {
			t.gotoAndStop&&t.gotoAndStop(label);
		}
	};
	
	/**
	 * Injected into target. Preserves the paused state through a reset.
	 * @method _reset
	 * @protected
	 **/
	p._reset = function() {
		// TODO: explore better ways to handle this issue. This is hacky & disrupts object signatures.
		var p = this.paused;
		this.__reset();
		this.paused = p;
	};


	createjs.ButtonHelper = ButtonHelper;
}());

//##############################################################################
// Shadow.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * This class encapsulates the properties required to define a shadow to apply to a {{#crossLink "DisplayObject"}}{{/crossLink}}
	 * via its <code>shadow</code> property.
	 *
	 * <h4>Example</h4>
	 *
	 *      myImage.shadow = new createjs.Shadow("#000000", 5, 5, 10);
	 *
	 * @class Shadow
	 * @constructor
	 * @param {String} color The color of the shadow. This can be any valid CSS color value.
	 * @param {Number} offsetX The x offset of the shadow in pixels.
	 * @param {Number} offsetY The y offset of the shadow in pixels.
	 * @param {Number} blur The size of the blurring effect.
	 **/
	function Shadow(color, offsetX, offsetY, blur) {
		
		
	// public properties:
		/** 
		 * The color of the shadow. This can be any valid CSS color value.
		 * @property color
		 * @type String
		 * @default null
		 */
		this.color = color||"black";
	
		/** The x offset of the shadow.
		 * @property offsetX
		 * @type Number
		 * @default 0
		 */
		this.offsetX = offsetX||0;
	
		/** The y offset of the shadow.
		 * @property offsetY
		 * @type Number
		 * @default 0
		 */
		this.offsetY = offsetY||0;
	
		/** The blur of the shadow.
		 * @property blur
		 * @type Number
		 * @default 0
		 */
		this.blur = blur||0;
	}
	var p = Shadow.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// static public properties:
	/**
	 * An identity shadow object (all properties are set to 0).
	 * @property identity
	 * @type Shadow
	 * @static
	 * @final
	 * @readonly
	 **/
	Shadow.identity = new Shadow("transparent", 0, 0, 0);


// public methods:
	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Shadow]";
	};

	/**
	 * Returns a clone of this Shadow instance.
	 * @method clone
	 * @return {Shadow} A clone of the current Shadow instance.
	 **/
	p.clone = function() {
		return new Shadow(this.color, this.offsetX, this.offsetY, this.blur);
	};
	

	createjs.Shadow = Shadow;
}());

//##############################################################################
// SpriteSheet.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Encapsulates the properties and methods associated with a sprite sheet. A sprite sheet is a series of images (usually
	 * animation frames) combined into a larger image (or images). For example, an animation consisting of eight 100x100
	 * images could be combined into a single 400x200 sprite sheet (4 frames across by 2 high).
	 *
	 * The data passed to the SpriteSheet constructor defines:<ol>
	 * 	<li> The source image or images to use.</li>
	 * 	<li> The positions of individual image frames.</li>
	 * 	<li> Sequences of frames that form named animations. Optional.</li>
	 * 	<li> The target playback framerate. Optional.</li>
	 * </OL>
	 *
	 * <h3>SpriteSheet Format</h3>
	 *
	 * SpriteSheets are an object with two required properties (`images` and `frames`), and two optional properties
	 * (`framerate` and `animations`). This makes them easy to define in javascript code, or in JSON.
	 *
	 * <h4>images</h4>
	 * An array of source images. Images can be either an HTMLImage
	 * instance, or a uri to an image. The former is recommended to control preloading.
	 *
	 * 	images: [image1, "path/to/image2.png"],
	 *
	 * <h4>frames</h4>
	 * Defines the individual frames. There are two supported formats for frame data:<OL>
	 * <LI> when all of the frames are the same size (in a grid), use an object with `width`, `height`, `regX`, `regY`, and `count` properties.
	 * `width` & `height` are required and specify the dimensions of the frames.
	 * `regX` & `regY` indicate the registration point or "origin" of the frames.
	 * `spacing` indicate the spacing between frames.
	 * `margin` specify the margin around the image(s).
	 * `count` allows you to specify the total number of frames in the spritesheet; if omitted, this will be calculated
	 * based on the dimensions of the source images and the frames. Frames will be assigned indexes based on their position
	 * in the source images (left to right, top to bottom).
	 *
	 * 	frames: {width:64, height:64, count:20, regX: 32, regY:64, spacing:0, margin:0}
	 *
	 * <LI> if the frames are of different sizes, use an array of frame definitions. Each definition is itself an array
	 * with 4 required and 3 optional entries, in the order: `x`, `y`, `width`, `height`, `imageIndex`, `regX`, `regY`. The first
	 * four entries are required and define the frame rectangle. The fifth specifies the index of the source image (defaults to 0). The
	 * last two specify the registration point of the frame.
	 *
	 * 	frames: [
	 * 		// x, y, width, height, imageIndex*, regX*, regY*
	 * 		[64, 0, 96, 64],
	 * 		[0, 0, 64, 64, 1, 32, 32]
	 * 		// etc.
	 * 	]
	 *
	 * </OL>
	 *
	 * <h4>animations</h4>
	 * Optional. An object defining sequences of frames to play as named animations. Each property corresponds to an
	 * animation of the same name. Each animation must specify the frames to play, and may
	 * also include a relative playback `speed` (ex. 2 would playback at double speed, 0.5 at half), and
	 * the name of the `next` animation to sequence to after it completes.
	 *
	 * There are three formats supported for defining the frames in an animation, which can be mixed and matched as appropriate:<OL>
	 * <LI> for a single frame animation, you can simply specify the frame index
	 *
	 * 	animations: {
	 * 		sit: 7
	 * 	}
	 *
	 * <LI> for an animation of consecutive frames, you can use an array with two required, and two optional entries
	 * in the order: `start`, `end`, `next`, and `speed`. This will play the frames from start to end inclusive.
	 *
	 * 	animations: {
	 * 		// start, end, next*, speed*
	 * 		run: [0, 8],
	 * 		jump: [9, 12, "run", 2]
	 * 	}
	 *
	 * <LI> for non-consecutive frames, you can use an object with a `frames` property defining an array of frame indexes to
	 * play in order. The object can also specify `next` and `speed` properties.
	 *
	 * 	animations: {
	 * 		walk: {
	 * 			frames: [1,2,3,3,2,1]
	 * 		},
	 * 		shoot: {
	 * 			frames: [1,4,5,6],
	 * 			next: "walk",
	 * 			speed: 0.5
	 * 		}
	 * 	}
	 *
	 * </OL>
	 * <strong>Note:</strong> the `speed` property was added in EaselJS 0.7.0. Earlier versions had a `frequency`
	 * property instead, which was the inverse of `speed`. For example, a value of "4" would be 1/4 normal speed in earlier
	 * versions, but is 4x normal speed in 0.7.0+.
	 *
	 * <h4>framerate</h4>
	 * Optional. Indicates the default framerate to play this spritesheet at in frames per second.
	 * See {{#crossLink "SpriteSheet/framerate:property"}}{{/crossLink}} for more information.
	 *
	 * 	framerate: 20
	 *
	 * <h4>Example</h4>
	 * To define a simple sprite sheet, with a single image "sprites.jpg" arranged in a regular 50x50 grid with three
	 * animations: "stand" showing the first frame, "run" looping frame 1-5 inclusive, and "jump" playing  frame 6-8 and sequencing back to run.
	 *
	 * 	var data = {
	 * 		images: ["sprites.jpg"],
	 * 		frames: {width:50, height:50},
	 * 		animations: {
	 * 			stand:0,
	 * 			run:[1,5],
	 * 			jump:[6,8,"run"]
	 * 		}
	 * 	};
	 * 	var spriteSheet = new createjs.SpriteSheet(data);
	 * 	var animation = new createjs.Sprite(spriteSheet, "run");
	 *
	 *
	 * <strong>Warning:</strong> Images loaded cross-origin will throw cross-origin security errors when interacted with
	 * using a mouse, using methods such as `getObjectUnderPoint`, using filters, or caching. You can get around this by
	 * setting `crossOrigin` flags on your images before passing them to EaselJS, eg: `img.crossOrigin="Anonymous";`
	 *
	 * @class SpriteSheet
	 * @constructor
	 * @param {Object} data An object describing the SpriteSheet data.
	 * @extends EventDispatcher
	 **/
	function SpriteSheet(data) {
		this.EventDispatcher_constructor();


		// public properties:
		/**
		 * Indicates whether all images are finished loading.
		 * @property complete
		 * @type Boolean
		 * @readonly
		 **/
		this.complete = true;

		/**
		 * Specifies the framerate to use by default for Sprite instances using the SpriteSheet. See
		 * Sprite.framerate for more information.
		 * @property framerate
		 * @type Number
		 **/
		this.framerate = 0;


		// private properties:
		/**
		 * @property _animations
		 * @protected
		 * @type Array
		 **/
		this._animations = null;

		/**
		 * @property _frames
		 * @protected
		 * @type Array
		 **/
		this._frames = null;

		/**
		 * @property _images
		 * @protected
		 * @type Array
		 **/
		this._images = null;

		/**
		 * @property _data
		 * @protected
		 * @type Object
		 **/
		this._data = null;

		/**
		 * @property _loadCount
		 * @protected
		 * @type Number
		 **/
		this._loadCount = 0;

		// only used for simple frame defs:
		/**
		 * @property _frameHeight
		 * @protected
		 * @type Number
		 **/
		this._frameHeight = 0;

		/**
		 * @property _frameWidth
		 * @protected
		 * @type Number
		 **/
		this._frameWidth = 0;

		/**
		 * @property _numFrames
		 * @protected
		 * @type Number
		 **/
		this._numFrames = 0;

		/**
		 * @property _regX
		 * @protected
		 * @type Number
		 **/
		this._regX = 0;

		/**
		 * @property _regY
		 * @protected
		 * @type Number
		 **/
		this._regY = 0;

		/**
		 * @property _spacing
		 * @protected
		 * @type Number
		 **/
		this._spacing = 0;

		/**
		 * @property _margin
		 * @protected
		 * @type Number
		 **/
		this._margin = 0;

		// setup:
		this._parseData(data);
	}
	var p = createjs.extend(SpriteSheet, createjs.EventDispatcher);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// events:
	/**
	 * Dispatched when all images are loaded.  Note that this only fires if the images
	 * were not fully loaded when the sprite sheet was initialized. You should check the complete property
	 * to prior to adding a listener. Ex.
	 *
	 * 	var sheet = new SpriteSheet(data);
	 * 	if (!sheet.complete) {
	 * 		// not preloaded, listen for the complete event:
	 * 		sheet.addEventListener("complete", handler);
	 * 	}
	 *
	 * @event complete
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @since 0.6.0
	 */

	/**
	 * Dispatched when getFrame is called with a valid frame index. This is primarily intended for use by {{#crossLink "SpriteSheetBuilder"}}{{/crossLink}}
	 * when doing on-demand rendering.
	 * @event getframe
	 * @param {Number} index The frame index.
	 * @param {Object} frame The frame object that getFrame will return.
	 */


// getter / setters:
	/**
	 * Use the {{#crossLink "SpriteSheet/animations:property"}}{{/crossLink}} property instead.
	 * @method getAnimations
	 * @return {Array}
	 * @deprecated
	 **/
	p.getAnimations = function() {
		return this._animations.slice();
	};

	/**
	 * Returns an array of all available animation names available on this sprite sheet as strings.
	 * @property animations
	 * @type {Array}
	 * @readonly
	 **/
	try {
		Object.defineProperties(p, {
			animations: { get: p.getAnimations }
		});
	} catch (e) {}


// public methods:
	/**
	 * Returns the total number of frames in the specified animation, or in the whole sprite
	 * sheet if the animation param is omitted. Returns 0 if the spritesheet relies on calculated frame counts, and
	 * the images have not been fully loaded.
	 * @method getNumFrames
	 * @param {String} animation The name of the animation to get a frame count for.
	 * @return {Number} The number of frames in the animation, or in the entire sprite sheet if the animation param is omitted.
	 */
	p.getNumFrames = function(animation) {
		if (animation == null) {
			return this._frames ? this._frames.length : this._numFrames || 0;
		} else {
			var data = this._data[animation];
			if (data == null) { return 0; }
			else { return data.frames.length; }
		}
	};

	/**
	 * Returns an object defining the specified animation. The returned object contains:<UL>
	 * 	<LI>frames: an array of the frame ids in the animation</LI>
	 * 	<LI>speed: the playback speed for this animation</LI>
	 * 	<LI>name: the name of the animation</LI>
	 * 	<LI>next: the default animation to play next. If the animation loops, the name and next property will be the
	 * 	same.</LI>
	 * </UL>
	 * @method getAnimation
	 * @param {String} name The name of the animation to get.
	 * @return {Object} a generic object with frames, speed, name, and next properties.
	 **/
	p.getAnimation = function(name) {
		return this._data[name];
	};

	/**
	 * Returns an object specifying the image and source rect of the specified frame. The returned object has:<UL>
	 * 	<LI>an image property holding a reference to the image object in which the frame is found</LI>
	 * 	<LI>a rect property containing a Rectangle instance which defines the boundaries for the frame within that
	 * 	image.</LI>
	 * 	<LI> A regX and regY property corresponding to the regX/Y values for the frame.
	 * </UL>
	 * @method getFrame
	 * @param {Number} frameIndex The index of the frame.
	 * @return {Object} a generic object with image and rect properties. Returns null if the frame does not exist.
	 **/
	p.getFrame = function(frameIndex) {
		var frame;
		if (this._frames && (frame=this._frames[frameIndex])) { return frame; }
		return null;
	};

	/**
	 * Returns a {{#crossLink "Rectangle"}}{{/crossLink}} instance defining the bounds of the specified frame relative
	 * to the origin. For example, a 90 x 70 frame with a regX of 50 and a regY of 40 would return:
	 *
	 * 	[x=-50, y=-40, width=90, height=70]
	 *
	 * @method getFrameBounds
	 * @param {Number} frameIndex The index of the frame.
	 * @param {Rectangle} [rectangle] A Rectangle instance to copy the values into. By default a new instance is created.
	 * @return {Rectangle} A Rectangle instance. Returns null if the frame does not exist, or the image is not fully loaded.
	 **/
	p.getFrameBounds = function(frameIndex, rectangle) {
		var frame = this.getFrame(frameIndex);
		return frame ? (rectangle||new createjs.Rectangle()).setValues(-frame.regX, -frame.regY, frame.rect.width, frame.rect.height) : null;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[SpriteSheet]";
	};

	/**
	 * SpriteSheet cannot be cloned. A SpriteSheet can be shared by multiple Sprite instances without cloning it.
	 * @method clone
	 **/
	p.clone = function() {
		throw("SpriteSheet cannot be cloned.")
	};

// private methods:
	/**
	 * @method _parseData
	 * @param {Object} data An object describing the SpriteSheet data.
	 * @protected
	 **/
	p._parseData = function(data) {
		var i,l,o,a;
		if (data == null) { return; }

		this.framerate = data.framerate||0;

		// parse images:
		if (data.images && (l=data.images.length) > 0) {
			a = this._images = [];
			for (i=0; i<l; i++) {
				var img = data.images[i];
				if (typeof img == "string") {
					var src = img;
					img = document.createElement("img");
					img.src = src;
				}
				a.push(img);
				if (!img.getContext && !img.naturalWidth) {
					this._loadCount++;
					this.complete = false;
					(function(o) { img.onload = function() { o._handleImageLoad(); } })(this);
				}
			}
		}

		// parse frames:
		if (data.frames == null) { // nothing
		} else if (data.frames instanceof Array) {
			this._frames = [];
			a = data.frames;
			for (i=0,l=a.length;i<l;i++) {
				var arr = a[i];
				this._frames.push({image:this._images[arr[4]?arr[4]:0], rect:new createjs.Rectangle(arr[0],arr[1],arr[2],arr[3]), regX:arr[5]||0, regY:arr[6]||0 });
			}
		} else {
			o = data.frames;
			this._frameWidth = o.width;
			this._frameHeight = o.height;
			this._regX = o.regX||0;
			this._regY = o.regY||0;
			this._spacing = o.spacing||0;
			this._margin = o.margin||0;
			this._numFrames = o.count;
			if (this._loadCount == 0) { this._calculateFrames(); }
		}

		// parse animations:
		this._animations = [];
		if ((o=data.animations) != null) {
			this._data = {};
			var name;
			for (name in o) {
				var anim = {name:name};
				var obj = o[name];
				if (typeof obj == "number") { // single frame
					a = anim.frames = [obj];
				} else if (obj instanceof Array) { // simple
					if (obj.length == 1) { anim.frames = [obj[0]]; }
					else {
						anim.speed = obj[3];
						anim.next = obj[2];
						a = anim.frames = [];
						for (i=obj[0];i<=obj[1];i++) {
							a.push(i);
						}
					}
				} else { // complex
					anim.speed = obj.speed;
					anim.next = obj.next;
					var frames = obj.frames;
					a = anim.frames = (typeof frames == "number") ? [frames] : frames.slice(0);
				}
				if (anim.next === true || anim.next === undefined) { anim.next = name; } // loop
				if (anim.next === false || (a.length < 2 && anim.next == name)) { anim.next = null; } // stop
				if (!anim.speed) { anim.speed = 1; }
				this._animations.push(name);
				this._data[name] = anim;
			}
		}
	};

	/**
	 * @method _handleImageLoad
	 * @protected
	 **/
	p._handleImageLoad = function() {
		if (--this._loadCount == 0) {
			this._calculateFrames();
			this.complete = true;
			this.dispatchEvent("complete");
		}
	};

	/**
	 * @method _calculateFrames
	 * @protected
	 **/
	p._calculateFrames = function() {
		if (this._frames || this._frameWidth == 0) { return; }

		this._frames = [];

		var maxFrames = this._numFrames || 100000; // if we go over this, something is wrong.
		var frameCount = 0, frameWidth = this._frameWidth, frameHeight = this._frameHeight;
		var spacing = this._spacing, margin = this._margin;
		
		imgLoop:
		for (var i=0, imgs=this._images; i<imgs.length; i++) {
			var img = imgs[i], imgW = img.width, imgH = img.height;

			var y = margin;
			while (y <= imgH-margin-frameHeight) {
				var x = margin;
				while (x <= imgW-margin-frameWidth) {
					if (frameCount >= maxFrames) { break imgLoop; }
					frameCount++;
					this._frames.push({
							image: img,
							rect: new createjs.Rectangle(x, y, frameWidth, frameHeight),
							regX: this._regX,
							regY: this._regY
						});
					x += frameWidth+spacing;
				}
				y += frameHeight+spacing;
			}
		}
		this._numFrames = frameCount;
	};


	createjs.SpriteSheet = createjs.promote(SpriteSheet, "EventDispatcher");
}());

//##############################################################################
// Graphics.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * The Graphics class exposes an easy to use API for generating vector drawing instructions and drawing them to a
	 * specified context. Note that you can use Graphics without any dependency on the EaselJS framework by calling {{#crossLink "Graphics/draw"}}{{/crossLink}}
	 * directly, or it can be used with the {{#crossLink "Shape"}}{{/crossLink}} object to draw vector graphics within the
	 * context of an EaselJS display list.
	 *
	 * There are two approaches to working with Graphics object: calling methods on a Graphics instance (the "Graphics API"), or
	 * instantiating Graphics command objects and adding them to the graphics queue via {{#crossLink "Graphics/append"}}{{/crossLink}}.
	 * The former abstracts the latter, simplifying beginning and ending paths, fills, and strokes.
	 *
	 *      var g = new createjs.Graphics();
	 *      g.setStrokeStyle(1);
	 *      g.beginStroke("#000000");
	 *      g.beginFill("red");
	 *      g.drawCircle(0,0,30);
	 *
	 * All drawing methods in Graphics return the Graphics instance, so they can be chained together. For example,
	 * the following line of code would generate the instructions to draw a rectangle with a red stroke and blue fill:
	 *
	 *      myGraphics.beginStroke("red").beginFill("blue").drawRect(20, 20, 100, 50);
	 *
	 * Each graphics API call generates a command object (see below). The last command to be created can be accessed via
	 * {{#crossLink "Graphics/command:property"}}{{/crossLink}}:
	 *
	 *      var fillCommand = myGraphics.beginFill("red").command;
	 *      // ... later, update the fill style/color:
	 *      fillCommand.style = "blue";
	 *      // or change it to a bitmap fill:
	 *      fillCommand.bitmap(myImage);
	 *
	 * For more direct control of rendering, you can instantiate and append command objects to the graphics queue directly. In this case, you
	 * need to manage path creation manually, and ensure that fill/stroke is applied to a defined path:
	 *
	 *      // start a new path. Graphics.beginCmd is a reusable BeginPath instance:
	 *      myGraphics.append(createjs.Graphics.beginCmd);
	 *      // we need to define the path before applying the fill:
	 *      var circle = new createjs.Graphics.Circle(0,0,30);
	 *      myGraphics.append(circle);
	 *      // fill the path we just defined:
	 *      var fill = new createjs.Graphics.Fill("red");
	 *      myGraphics.append(fill);
	 *
	 * These approaches can be used together, for example to insert a custom command:
	 *
	 *      myGraphics.beginFill("red");
	 *      var customCommand = new CustomSpiralCommand(etc);
	 *      myGraphics.append(customCommand);
	 *      myGraphics.beginFill("blue");
	 *      myGraphics.drawCircle(0, 0, 30);
	 *
	 * See {{#crossLink "Graphics/append"}}{{/crossLink}} for more info on creating custom commands.
	 *
	 * <h4>Tiny API</h4>
	 * The Graphics class also includes a "tiny API", which is one or two-letter methods that are shortcuts for all of the
	 * Graphics methods. These methods are great for creating compact instructions, and is used by the Toolkit for CreateJS
	 * to generate readable code. All tiny methods are marked as protected, so you can view them by enabling protected
	 * descriptions in the docs.
	 *
	 * <table>
	 *     <tr><td><b>Tiny</b></td><td><b>Method</b></td><td><b>Tiny</b></td><td><b>Method</b></td></tr>
	 *     <tr><td>mt</td><td>{{#crossLink "Graphics/moveTo"}}{{/crossLink}} </td>
	 *     <td>lt</td> <td>{{#crossLink "Graphics/lineTo"}}{{/crossLink}}</td></tr>
	 *     <tr><td>a/at</td><td>{{#crossLink "Graphics/arc"}}{{/crossLink}} / {{#crossLink "Graphics/arcTo"}}{{/crossLink}} </td>
	 *     <td>bt</td><td>{{#crossLink "Graphics/bezierCurveTo"}}{{/crossLink}} </td></tr>
	 *     <tr><td>qt</td><td>{{#crossLink "Graphics/quadraticCurveTo"}}{{/crossLink}} (also curveTo)</td>
	 *     <td>r</td><td>{{#crossLink "Graphics/rect"}}{{/crossLink}} </td></tr>
	 *     <tr><td>cp</td><td>{{#crossLink "Graphics/closePath"}}{{/crossLink}} </td>
	 *     <td>c</td><td>{{#crossLink "Graphics/clear"}}{{/crossLink}} </td></tr>
	 *     <tr><td>f</td><td>{{#crossLink "Graphics/beginFill"}}{{/crossLink}} </td>
	 *     <td>lf</td><td>{{#crossLink "Graphics/beginLinearGradientFill"}}{{/crossLink}} </td></tr>
	 *     <tr><td>rf</td><td>{{#crossLink "Graphics/beginRadialGradientFill"}}{{/crossLink}} </td>
	 *     <td>bf</td><td>{{#crossLink "Graphics/beginBitmapFill"}}{{/crossLink}} </td></tr>
	 *     <tr><td>ef</td><td>{{#crossLink "Graphics/endFill"}}{{/crossLink}} </td>
	 *     <td>ss / sd</td><td>{{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} / {{#crossLink "Graphics/setStrokeDash"}}{{/crossLink}} </td></tr>
	 *     <tr><td>s</td><td>{{#crossLink "Graphics/beginStroke"}}{{/crossLink}} </td>
	 *     <td>ls</td><td>{{#crossLink "Graphics/beginLinearGradientStroke"}}{{/crossLink}} </td></tr>
	 *     <tr><td>rs</td><td>{{#crossLink "Graphics/beginRadialGradientStroke"}}{{/crossLink}} </td>
	 *     <td>bs</td><td>{{#crossLink "Graphics/beginBitmapStroke"}}{{/crossLink}} </td></tr>
	 *     <tr><td>es</td><td>{{#crossLink "Graphics/endStroke"}}{{/crossLink}} </td>
	 *     <td>dr</td><td>{{#crossLink "Graphics/drawRect"}}{{/crossLink}} </td></tr>
	 *     <tr><td>rr</td><td>{{#crossLink "Graphics/drawRoundRect"}}{{/crossLink}} </td>
	 *     <td>rc</td><td>{{#crossLink "Graphics/drawRoundRectComplex"}}{{/crossLink}} </td></tr>
	 *     <tr><td>dc</td><td>{{#crossLink "Graphics/drawCircle"}}{{/crossLink}} </td>
	 *     <td>de</td><td>{{#crossLink "Graphics/drawEllipse"}}{{/crossLink}} </td></tr>
	 *     <tr><td>dp</td><td>{{#crossLink "Graphics/drawPolyStar"}}{{/crossLink}} </td>
	 *     <td>p</td><td>{{#crossLink "Graphics/decodePath"}}{{/crossLink}} </td></tr>
	 * </table>
	 *
	 * Here is the above example, using the tiny API instead.
	 *
	 *      myGraphics.s("red").f("blue").r(20, 20, 100, 50);
	 *
	 * @class Graphics
	 * @constructor
	 **/
	function Graphics() {


	// public properties
		/**
		 * Holds a reference to the last command that was created or appended. For example, you could retain a reference
		 * to a Fill command in order to dynamically update the color later by using:
		 * 		myFill = myGraphics.beginFill("red").command;
		 * 		// update color later:
		 * 		myFill.style = "yellow";
		 * @property command
		 * @type Object
		 **/
		this.command = null;


	// private properties
		/**
		 * @property _stroke
		 * @protected
		 * @type {Stroke}
		 **/
		this._stroke = null;

		/**
		 * @property _strokeStyle
		 * @protected
		 * @type {StrokeStyle}
		 **/
		this._strokeStyle = null;
		
		/**
		 * @property _oldStrokeStyle
		 * @protected
		 * @type {StrokeStyle}
		 **/
		this._oldStrokeStyle = null;
		
		/**
		 * @property _strokeDash
		 * @protected
		 * @type {StrokeDash}
		 **/
		this._strokeDash = null;
		
		/**
		 * @property _oldStrokeDash
		 * @protected
		 * @type {StrokeDash}
		 **/
		this._oldStrokeDash = null;

		/**
		 * @property _strokeIgnoreScale
		 * @protected
		 * @type Boolean
		 **/
		this._strokeIgnoreScale = false;

		/**
		 * @property _fill
		 * @protected
		 * @type {Fill}
		 **/
		this._fill = null;

		/**
		 * @property _instructions
		 * @protected
		 * @type {Array}
		 **/
		this._instructions = [];

		/**
		 * Indicates the last instruction index that was committed.
		 * @property _commitIndex
		 * @protected
		 * @type {Number}
		 **/
		this._commitIndex = 0;

		/**
		 * Uncommitted instructions.
		 * @property _activeInstructions
		 * @protected
		 * @type {Array}
		 **/
		this._activeInstructions = [];

		/**
		 * This indicates that there have been changes to the activeInstruction list since the last updateInstructions call.
		 * @property _dirty
		 * @protected
		 * @type {Boolean}
		 * @default false
		 **/
		this._dirty = false;

		/**
		 * Index to draw from if a store operation has happened.
		 * @property _storeIndex
		 * @protected
		 * @type {Number}
		 * @default 0
		 **/
		this._storeIndex = 0;

	// setup:
		this.clear();
	}
	var p = Graphics.prototype;
	var G = Graphics; // shortcut

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// static public methods:
	/**
	 * Returns a CSS compatible color string based on the specified RGB numeric color values in the format
	 * "rgba(255,255,255,1.0)", or if alpha is null then in the format "rgb(255,255,255)". For example,
	 *
	 *      createjs.Graphics.getRGB(50, 100, 150, 0.5);
	 *      // Returns "rgba(50,100,150,0.5)"
	 *
	 * It also supports passing a single hex color value as the first param, and an optional alpha value as the second
	 * param. For example,
	 *
	 *      createjs.Graphics.getRGB(0xFF00FF, 0.2);
	 *      // Returns "rgba(255,0,255,0.2)"
	 *
	 * @method getRGB
	 * @static
	 * @param {Number} r The red component for the color, between 0 and 0xFF (255).
	 * @param {Number} g The green component for the color, between 0 and 0xFF (255).
	 * @param {Number} b The blue component for the color, between 0 and 0xFF (255).
	 * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.
	 * @return {String} A CSS compatible color string based on the specified RGB numeric color values in the format
	 * "rgba(255,255,255,1.0)", or if alpha is null then in the format "rgb(255,255,255)".
	 **/
	Graphics.getRGB = function(r, g, b, alpha) {
		if (r != null && b == null) {
			alpha = g;
			b = r&0xFF;
			g = r>>8&0xFF;
			r = r>>16&0xFF;
		}
		if (alpha == null) {
			return "rgb("+r+","+g+","+b+")";
		} else {
			return "rgba("+r+","+g+","+b+","+alpha+")";
		}
	};

	/**
	 * Returns a CSS compatible color string based on the specified HSL numeric color values in the format "hsla(360,100,100,1.0)",
	 * or if alpha is null then in the format "hsl(360,100,100)".
	 *
	 *      createjs.Graphics.getHSL(150, 100, 70);
	 *      // Returns "hsl(150,100,70)"
	 *
	 * @method getHSL
	 * @static
	 * @param {Number} hue The hue component for the color, between 0 and 360.
	 * @param {Number} saturation The saturation component for the color, between 0 and 100.
	 * @param {Number} lightness The lightness component for the color, between 0 and 100.
	 * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.
	 * @return {String} A CSS compatible color string based on the specified HSL numeric color values in the format
	 * "hsla(360,100,100,1.0)", or if alpha is null then in the format "hsl(360,100,100)".
	 **/
	Graphics.getHSL = function(hue, saturation, lightness, alpha) {
		if (alpha == null) {
			return "hsl("+(hue%360)+","+saturation+"%,"+lightness+"%)";
		} else {
			return "hsla("+(hue%360)+","+saturation+"%,"+lightness+"%,"+alpha+")";
		}
	};


// static properties:
	/**
	 * A reusable instance of {{#crossLink "Graphics/BeginPath"}}{{/crossLink}} to avoid
	 * unnecessary instantiation.
	 * @property beginCmd
	 * @type {Graphics.BeginPath}
	 * @static
	 **/
	 // defined at the bottom of this file.

	/**
	 * Map of Base64 characters to values. Used by {{#crossLink "Graphics/decodePath"}}{{/crossLink}}.
	 * @property BASE_64
	 * @static
	 * @final
	 * @readonly
	 * @type {Object}
	 **/
	Graphics.BASE_64 = {"A":0,"B":1,"C":2,"D":3,"E":4,"F":5,"G":6,"H":7,"I":8,"J":9,"K":10,"L":11,"M":12,"N":13,"O":14,"P":15,"Q":16,"R":17,"S":18,"T":19,"U":20,"V":21,"W":22,"X":23,"Y":24,"Z":25,"a":26,"b":27,"c":28,"d":29,"e":30,"f":31,"g":32,"h":33,"i":34,"j":35,"k":36,"l":37,"m":38,"n":39,"o":40,"p":41,"q":42,"r":43,"s":44,"t":45,"u":46,"v":47,"w":48,"x":49,"y":50,"z":51,"0":52,"1":53,"2":54,"3":55,"4":56,"5":57,"6":58,"7":59,"8":60,"9":61,"+":62,"/":63};

	/**
	 * Maps numeric values for the caps parameter of {{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} to
	 * corresponding string values. This is primarily for use with the tiny API. The mappings are as follows: 0 to
	 * "butt", 1 to "round", and 2 to "square".
	 * For example, to set the line caps to "square":
	 *
	 *      myGraphics.ss(16, 2);
	 *
	 * @property STROKE_CAPS_MAP
	 * @static
	 * @final
	 * @readonly
	 * @type {Array}
	 **/
	Graphics.STROKE_CAPS_MAP = ["butt", "round", "square"];

	/**
	 * Maps numeric values for the joints parameter of {{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} to
	 * corresponding string values. This is primarily for use with the tiny API. The mappings are as follows: 0 to
	 * "miter", 1 to "round", and 2 to "bevel".
	 * For example, to set the line joints to "bevel":
	 *
	 *      myGraphics.ss(16, 0, 2);
	 *
	 * @property STROKE_JOINTS_MAP
	 * @static
	 * @final
	 * @readonly
	 * @type {Array}
	 **/
	Graphics.STROKE_JOINTS_MAP = ["miter", "round", "bevel"];

	/**
	 * @property _ctx
	 * @static
	 * @protected
	 * @type {CanvasRenderingContext2D}
	 **/
	var canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"));
	if (canvas.getContext) {
		Graphics._ctx = canvas.getContext("2d");
		canvas.width = canvas.height = 1;
	}


// getter / setters:
	/**
	 * Use the {{#crossLink "Graphics/instructions:property"}}{{/crossLink}} property instead.
	 * @method getInstructions
	 * @return {Array}
	 * @deprecated
	 **/
	p.getInstructions = function() {
		this._updateInstructions();
		return this._instructions;
	};

	/**
	 * Returns the graphics instructions array. Each entry is a graphics command object (ex. Graphics.Fill, Graphics.Rect)
	 * Modifying the returned array directly is not recommended, and is likely to result in unexpected behaviour.
	 *
	 * This property is mainly intended for introspection of the instructions (ex. for graphics export).
	 * @property instructions
	 * @type {Array}
	 * @readonly
	 **/
	try {
		Object.defineProperties(p, {
			instructions: { get: p.getInstructions }
		});
	} catch (e) {}


// public methods:
	/**
	 * Returns true if this Graphics instance has no drawing commands.
	 * @method isEmpty
	 * @return {Boolean} Returns true if this Graphics instance has no drawing commands.
	 **/
	p.isEmpty = function() {
		return !(this._instructions.length || this._activeInstructions.length);
	};

	/**
	 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
	 * Returns true if the draw was handled (useful for overriding functionality).
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Object} data Optional data that is passed to graphics command exec methods. When called from a Shape instance, the shape passes itself as the data parameter. This can be used by custom graphic commands to insert contextual data.
	 **/
	p.draw = function(ctx, data) {
		this._updateInstructions();
		var instr = this._instructions;
		for (var i=this._storeIndex, l=instr.length; i<l; i++) {
			instr[i].exec(ctx, data);
		}
	};

	/**
	 * Draws only the path described for this Graphics instance, skipping any non-path instructions, including fill and
	 * stroke descriptions. Used for <code>DisplayObject.mask</code> to draw the clipping path, for example.
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method drawAsPath
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 **/
	p.drawAsPath = function(ctx) {
		this._updateInstructions();
		var instr, instrs = this._instructions;
		for (var i=this._storeIndex, l=instrs.length; i<l; i++) {
			// the first command is always a beginPath command.
			if ((instr = instrs[i]).path !== false) { instr.exec(ctx); }
		}
	};


// public methods that map directly to context 2D calls:
	/**
	 * Moves the drawing point to the specified position. A tiny API method "mt" also exists.
	 * @method moveTo
	 * @param {Number} x The x coordinate the drawing point should move to.
	 * @param {Number} y The y coordinate the drawing point should move to.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls).
	 * @chainable
	 **/
	p.moveTo = function(x, y) {
		return this.append(new G.MoveTo(x,y), true);
	};

	/**
	 * Draws a line from the current drawing point to the specified position, which become the new current drawing
	 * point. A tiny API method "lt" also exists.
	 *
	 * For detailed information, read the
	 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#complex-shapes-(paths)">
	 * whatwg spec</a>.
	 * @method lineTo
	 * @param {Number} x The x coordinate the drawing point should draw to.
	 * @param {Number} y The y coordinate the drawing point should draw to.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.lineTo = function(x, y) {
		return this.append(new G.LineTo(x,y));
	};

	/**
	 * Draws an arc with the specified control points and radius.  For detailed information, read the
	 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arcto">
	 * whatwg spec</a>. A tiny API method "at" also exists.
	 * @method arcTo
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} radius
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.arcTo = function(x1, y1, x2, y2, radius) {
		return this.append(new G.ArcTo(x1, y1, x2, y2, radius));
	};

	/**
	 * Draws an arc defined by the radius, startAngle and endAngle arguments, centered at the position (x, y). For
	 * example, to draw a full circle with a radius of 20 centered at (100, 100):
	 *
	 *      arc(100, 100, 20, 0, Math.PI*2);
	 *
	 * For detailed information, read the
	 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc">whatwg spec</a>.
	 * A tiny API method "a" also exists.
	 * @method arc
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} radius
	 * @param {Number} startAngle Measured in radians.
	 * @param {Number} endAngle Measured in radians.
	 * @param {Boolean} anticlockwise
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {
		return this.append(new G.Arc(x, y, radius, startAngle, endAngle, anticlockwise));
	};

	/**
	 * Draws a quadratic curve from the current drawing point to (x, y) using the control point (cpx, cpy). For detailed
	 * information, read the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto">
	 * whatwg spec</a>. A tiny API method "qt" also exists.
	 * @method quadraticCurveTo
	 * @param {Number} cpx
	 * @param {Number} cpy
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.quadraticCurveTo = function(cpx, cpy, x, y) {
		return this.append(new G.QuadraticCurveTo(cpx, cpy, x, y));
	};

	/**
	 * Draws a bezier curve from the current drawing point to (x, y) using the control points (cp1x, cp1y) and (cp2x,
	 * cp2y). For detailed information, read the
	 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-beziercurveto">
	 * whatwg spec</a>. A tiny API method "bt" also exists.
	 * @method bezierCurveTo
	 * @param {Number} cp1x
	 * @param {Number} cp1y
	 * @param {Number} cp2x
	 * @param {Number} cp2y
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
		return this.append(new G.BezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y));
	};

	/**
	 * Draws a rectangle at (x, y) with the specified width and height using the current fill and/or stroke.
	 * For detailed information, read the
	 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-rect">
	 * whatwg spec</a>. A tiny API method "r" also exists.
	 * @method rect
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w Width of the rectangle
	 * @param {Number} h Height of the rectangle
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.rect = function(x, y, w, h) {
		return this.append(new G.Rect(x, y, w, h));
	};

	/**
	 * Closes the current path, effectively drawing a line from the current drawing point to the first drawing point specified
	 * since the fill or stroke was last set. A tiny API method "cp" also exists.
	 * @method closePath
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.closePath = function() {
		return this._activeInstructions.length ? this.append(new G.ClosePath()) : this;
	};


// public methods that roughly map to Flash graphics APIs:
	/**
	 * Clears all drawing instructions, effectively resetting this Graphics instance. Any line and fill styles will need
	 * to be redefined to draw shapes following a clear call. A tiny API method "c" also exists.
	 * @method clear
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.clear = function() {
		this._instructions.length = this._activeInstructions.length = this._commitIndex = 0;
		this._strokeStyle = this._oldStrokeStyle = this._stroke = this._fill = this._strokeDash = this._oldStrokeDash = null;
		this._dirty = this._strokeIgnoreScale = false;
		return this;
	};

	/**
	 * Begins a fill with the specified color. This ends the current sub-path. A tiny API method "f" also exists.
	 * @method beginFill
	 * @param {String} color A CSS compatible color value (ex. "red", "#FF0000", or "rgba(255,0,0,0.5)"). Setting to
	 * null will result in no fill.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginFill = function(color) {
		return this._setFill(color ? new G.Fill(color) : null);
	};

	/**
	 * Begins a linear gradient fill defined by the line (x0, y0) to (x1, y1). This ends the current sub-path. For
	 * example, the following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a
	 * square to display it:
	 *
	 *      myGraphics.beginLinearGradientFill(["#000","#FFF"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);
	 *
	 * A tiny API method "lf" also exists.
	 * @method beginLinearGradientFill
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define a gradient
	 * drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw
	 * the first color to 10% then interpolating to the second color at 90%.
	 * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
	 * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginLinearGradientFill = function(colors, ratios, x0, y0, x1, y1) {
		return this._setFill(new G.Fill().linearGradient(colors, ratios, x0, y0, x1, y1));
	};

	/**
	 * Begins a radial gradient fill. This ends the current sub-path. For example, the following code defines a red to
	 * blue radial gradient centered at (100, 100), with a radius of 50, and draws a circle to display it:
	 *
	 *      myGraphics.beginRadialGradientFill(["#F00","#00F"], [0, 1], 100, 100, 0, 100, 100, 50).drawCircle(100, 100, 50);
	 *
	 * A tiny API method "rf" also exists.
	 * @method beginRadialGradientFill
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
	 * a gradient drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
	 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
	 * @param {Number} x0 Center position of the inner circle that defines the gradient.
	 * @param {Number} y0 Center position of the inner circle that defines the gradient.
	 * @param {Number} r0 Radius of the inner circle that defines the gradient.
	 * @param {Number} x1 Center position of the outer circle that defines the gradient.
	 * @param {Number} y1 Center position of the outer circle that defines the gradient.
	 * @param {Number} r1 Radius of the outer circle that defines the gradient.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginRadialGradientFill = function(colors, ratios, x0, y0, r0, x1, y1, r1) {
		return this._setFill(new G.Fill().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));
	};

	/**
	 * Begins a pattern fill using the specified image. This ends the current sub-path. A tiny API method "bf" also
	 * exists.
	 * @method beginBitmapFill
	 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
	 * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.
	 * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of "repeat",
	 * "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat". Note that Firefox does not support "repeat-x" or
	 * "repeat-y" (latest tests were in FF 20.0), and will default to "repeat".
	 * @param {Matrix2D} matrix Optional. Specifies a transformation matrix for the bitmap fill. This transformation
	 * will be applied relative to the parent transform.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginBitmapFill = function(image, repetition, matrix) {
		return this._setFill(new G.Fill(null,matrix).bitmap(image, repetition));
	};

	/**
	 * Ends the current sub-path, and begins a new one with no fill. Functionally identical to <code>beginFill(null)</code>.
	 * A tiny API method "ef" also exists.
	 * @method endFill
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.endFill = function() {
		return this.beginFill();
	};

	/**
	 * Sets the stroke style. Like all drawing methods, this can be chained, so you can define
	 * the stroke style and color in a single line of code like so:
	 *
	 * 	myGraphics.setStrokeStyle(8,"round").beginStroke("#F00");
	 *
	 * A tiny API method "ss" also exists.
	 * @method setStrokeStyle
	 * @param {Number} thickness The width of the stroke.
	 * @param {String | Number} [caps=0] Indicates the type of caps to use at the end of lines. One of butt,
	 * round, or square. Defaults to "butt". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with
	 * the tiny API.
	 * @param {String | Number} [joints=0] Specifies the type of joints that should be used where two lines meet.
	 * One of bevel, round, or miter. Defaults to "miter". Also accepts the values 0 (miter), 1 (round), and 2 (bevel)
	 * for use with the tiny API.
	 * @param {Number} [miterLimit=10] If joints is set to "miter", then you can specify a miter limit ratio which
	 * controls at what point a mitered joint will be clipped.
	 * @param {Boolean} [ignoreScale=false] If true, the stroke will be drawn at the specified thickness regardless
	 * of active transformations.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.setStrokeStyle = function(thickness, caps, joints, miterLimit, ignoreScale) {
		this._updateInstructions(true);
		this._strokeStyle = this.command = new G.StrokeStyle(thickness, caps, joints, miterLimit, ignoreScale);

		// ignoreScale lives on Stroke, not StrokeStyle, so we do a little trickery:
		if (this._stroke) { this._stroke.ignoreScale = ignoreScale; }
		this._strokeIgnoreScale = ignoreScale;
		return this;
	};
	
	/**
	 * Sets or clears the stroke dash pattern.
	 *
	 * 	myGraphics.setStrokeDash([20, 10], 0);
	 *
	 * A tiny API method `sd` also exists.
	 * @method setStrokeDash
	 * @param {Array} [segments] An array specifying the dash pattern, alternating between line and gap.
	 * For example, `[20,10]` would create a pattern of 20 pixel lines with 10 pixel gaps between them.
	 * Passing null or an empty array will clear the existing stroke dash.
	 * @param {Number} [offset=0] The offset of the dash pattern. For example, you could increment this value to create a "marching ants" effect.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.setStrokeDash = function(segments, offset) {
		this._updateInstructions(true);
		this._strokeDash = this.command = new G.StrokeDash(segments, offset);
		return this;
	};

	/**
	 * Begins a stroke with the specified color. This ends the current sub-path. A tiny API method "s" also exists.
	 * @method beginStroke
	 * @param {String} color A CSS compatible color value (ex. "#FF0000", "red", or "rgba(255,0,0,0.5)"). Setting to
	 * null will result in no stroke.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginStroke = function(color) {
		return this._setStroke(color ? new G.Stroke(color) : null);
	};

	/**
	 * Begins a linear gradient stroke defined by the line (x0, y0) to (x1, y1). This ends the current sub-path. For
	 * example, the following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a
	 * square to display it:
	 *
	 *      myGraphics.setStrokeStyle(10).
	 *          beginLinearGradientStroke(["#000","#FFF"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);
	 *
	 * A tiny API method "ls" also exists.
	 * @method beginLinearGradientStroke
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
	 * a gradient drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
	 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
	 * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
	 * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginLinearGradientStroke = function(colors, ratios, x0, y0, x1, y1) {
		return this._setStroke(new G.Stroke().linearGradient(colors, ratios, x0, y0, x1, y1));
	};

	/**
	 * Begins a radial gradient stroke. This ends the current sub-path. For example, the following code defines a red to
	 * blue radial gradient centered at (100, 100), with a radius of 50, and draws a rectangle to display it:
	 *
	 *      myGraphics.setStrokeStyle(10)
	 *          .beginRadialGradientStroke(["#F00","#00F"], [0, 1], 100, 100, 0, 100, 100, 50)
	 *          .drawRect(50, 90, 150, 110);
	 *
	 * A tiny API method "rs" also exists.
	 * @method beginRadialGradientStroke
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
	 * a gradient drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
	 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color
	 * to 100%.
	 * @param {Number} x0 Center position of the inner circle that defines the gradient.
	 * @param {Number} y0 Center position of the inner circle that defines the gradient.
	 * @param {Number} r0 Radius of the inner circle that defines the gradient.
	 * @param {Number} x1 Center position of the outer circle that defines the gradient.
	 * @param {Number} y1 Center position of the outer circle that defines the gradient.
	 * @param {Number} r1 Radius of the outer circle that defines the gradient.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginRadialGradientStroke = function(colors, ratios, x0, y0, r0, x1, y1, r1) {
		return this._setStroke(new G.Stroke().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));
	};

	/**
	 * Begins a pattern fill using the specified image. This ends the current sub-path. Note that unlike bitmap fills,
	 * strokes do not currently support a matrix parameter due to limitations in the canvas API. A tiny API method "bs"
	 * also exists.
	 * @method beginBitmapStroke
	 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
	 * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.
	 * @param {String} [repetition=repeat] Optional. Indicates whether to repeat the image in the fill area. One of
	 * "repeat", "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat".
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginBitmapStroke = function(image, repetition) {
		// NOTE: matrix is not supported for stroke because transforms on strokes also affect the drawn stroke width.
		return this._setStroke(new G.Stroke().bitmap(image, repetition));
	};

	/**
	 * Ends the current sub-path, and begins a new one with no stroke. Functionally identical to <code>beginStroke(null)</code>.
	 * A tiny API method "es" also exists.
	 * @method endStroke
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.endStroke = function() {
		return this.beginStroke();
	};

	/**
	 * Maps the familiar ActionScript <code>curveTo()</code> method to the functionally similar {{#crossLink "Graphics/quadraticCurveTo"}}{{/crossLink}}
	 * method.
	 * @method quadraticCurveTo
	 * @param {Number} cpx
	 * @param {Number} cpy
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.curveTo = p.quadraticCurveTo;

	/**
	 *
	 * Maps the familiar ActionScript <code>drawRect()</code> method to the functionally similar {{#crossLink "Graphics/rect"}}{{/crossLink}}
	 * method.
	 * @method drawRect
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w Width of the rectangle
	 * @param {Number} h Height of the rectangle
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.drawRect = p.rect;

	/**
	 * Draws a rounded rectangle with all corners with the specified radius.
	 * @method drawRoundRect
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w
	 * @param {Number} h
	 * @param {Number} radius Corner radius.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.drawRoundRect = function(x, y, w, h, radius) {
		return this.drawRoundRectComplex(x, y, w, h, radius, radius, radius, radius);
	};

	/**
	 * Draws a rounded rectangle with different corner radii. Supports positive and negative corner radii. A tiny API
	 * method "rc" also exists.
	 * @method drawRoundRectComplex
	 * @param {Number} x The horizontal coordinate to draw the round rect.
	 * @param {Number} y The vertical coordinate to draw the round rect.
	 * @param {Number} w The width of the round rect.
	 * @param {Number} h The height of the round rect.
	 * @param {Number} radiusTL Top left corner radius.
	 * @param {Number} radiusTR Top right corner radius.
	 * @param {Number} radiusBR Bottom right corner radius.
	 * @param {Number} radiusBL Bottom left corner radius.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.drawRoundRectComplex = function(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {
		return this.append(new G.RoundRect(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL));
	};

	/**
	 * Draws a circle with the specified radius at (x, y).
	 *
	 *      var g = new createjs.Graphics();
	 *	    g.setStrokeStyle(1);
	 *	    g.beginStroke(createjs.Graphics.getRGB(0,0,0));
	 *	    g.beginFill(createjs.Graphics.getRGB(255,0,0));
	 *	    g.drawCircle(0,0,3);
	 *
	 *	    var s = new createjs.Shape(g);
	 *		s.x = 100;
	 *		s.y = 100;
	 *
	 *	    stage.addChild(s);
	 *	    stage.update();
	 *
	 * A tiny API method "dc" also exists.
	 * @method drawCircle
	 * @param {Number} x x coordinate center point of circle.
	 * @param {Number} y y coordinate center point of circle.
	 * @param {Number} radius Radius of circle.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.drawCircle = function(x, y, radius) {
		return this.append(new G.Circle(x, y, radius));
	};

	/**
	 * Draws an ellipse (oval) with a specified width (w) and height (h). Similar to {{#crossLink "Graphics/drawCircle"}}{{/crossLink}},
	 * except the width and height can be different. A tiny API method "de" also exists.
	 * @method drawEllipse
	 * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}
	 * which draws from center.
	 * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}
	 * which draws from the center.
	 * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this
	 * number.
	 * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.drawEllipse = function(x, y, w, h) {
		return this.append(new G.Ellipse(x, y, w, h));
	};

	/**
	 * Draws a star if pointSize is greater than 0, or a regular polygon if pointSize is 0 with the specified number of
	 * points. For example, the following code will draw a familiar 5 pointed star shape centered at 100, 100 and with a
	 * radius of 50:
	 *
	 *      myGraphics.beginFill("#FF0").drawPolyStar(100, 100, 50, 5, 0.6, -90);
	 *      // Note: -90 makes the first point vertical
	 *
	 * A tiny API method "dp" also exists.
	 *
	 * @method drawPolyStar
	 * @param {Number} x Position of the center of the shape.
	 * @param {Number} y Position of the center of the shape.
	 * @param {Number} radius The outer radius of the shape.
	 * @param {Number} sides The number of points on the star or sides on the polygon.
	 * @param {Number} pointSize The depth or "pointy-ness" of the star points. A pointSize of 0 will draw a regular
	 * polygon (no points), a pointSize of 1 will draw nothing because the points are infinitely pointy.
	 * @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point
	 * directly to the right of the center.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.drawPolyStar = function(x, y, radius, sides, pointSize, angle) {
		return this.append(new G.PolyStar(x, y, radius, sides, pointSize, angle));
	};

	// TODO: deprecated.
	/**
	 * Removed in favour of using custom command objects with {{#crossLink "Graphics/append"}}{{/crossLink}}.
	 * @method inject
	 * @deprecated
	 **/

	/**
	 * Appends a graphics command object to the graphics queue. Command objects expose an "exec" method
	 * that accepts two parameters: the Context2D to operate on, and an arbitrary data object passed into
	 * {{#crossLink "Graphics/draw"}}{{/crossLink}}. The latter will usually be the Shape instance that called draw.
	 *
	 * This method is used internally by Graphics methods, such as drawCircle, but can also be used directly to insert
	 * built-in or custom graphics commands. For example:
	 *
	 * 		// attach data to our shape, so we can access it during the draw:
	 * 		myShape.color = "red";
	 *
	 * 		// append a Circle command object:
	 * 		myShape.graphics.append(new Graphics.Circle(50, 50, 30));
	 *
	 * 		// append a custom command object with an exec method that sets the fill style
	 * 		// based on the shape's data, and then fills the circle.
	 * 		myShape.graphics.append({exec:function(ctx, shape) {
	 * 			ctx.fillStyle = shape.color;
	 * 			ctx.fill();
	 * 		}});
	 *
	 * @method append
	 * @param {Object} command A graphics command object exposing an "exec" method.
	 * @param {boolean} clean The clean param is primarily for internal use. A value of true indicates that a command does not generate a path that should be stroked or filled.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.append = function(command, clean) {
		this._activeInstructions.push(command);
		this.command = command;
		if (!clean) { this._dirty = true; }
		return this;
	};

	/**
	 * Decodes a compact encoded path string into a series of draw instructions.
	 * This format is not intended to be human readable, and is meant for use by authoring tools.
	 * The format uses a base64 character set, with each character representing 6 bits, to define a series of draw
	 * commands.
	 *
	 * Each command is comprised of a single "header" character followed by a variable number of alternating x and y
	 * position values. Reading the header bits from left to right (most to least significant): bits 1 to 3 specify the
	 * type of operation (0-moveTo, 1-lineTo, 2-quadraticCurveTo, 3-bezierCurveTo, 4-closePath, 5-7 unused). Bit 4
	 * indicates whether position values use 12 bits (2 characters) or 18 bits (3 characters), with a one indicating the
	 * latter. Bits 5 and 6 are currently unused.
	 *
	 * Following the header is a series of 0 (closePath), 2 (moveTo, lineTo), 4 (quadraticCurveTo), or 6 (bezierCurveTo)
	 * parameters. These parameters are alternating x/y positions represented by 2 or 3 characters (as indicated by the
	 * 4th bit in the command char). These characters consist of a 1 bit sign (1 is negative, 0 is positive), followed
	 * by an 11 (2 char) or 17 (3 char) bit integer value. All position values are in tenths of a pixel. Except in the
	 * case of move operations which are absolute, this value is a delta from the previous x or y position (as
	 * appropriate).
	 *
	 * For example, the string "A3cAAMAu4AAA" represents a line starting at -150,0 and ending at 150,0.
	 * <br />A - bits 000000. First 3 bits (000) indicate a moveTo operation. 4th bit (0) indicates 2 chars per
	 * parameter.
	 * <br />n0 - 110111011100. Absolute x position of -150.0px. First bit indicates a negative value, remaining bits
	 * indicate 1500 tenths of a pixel.
	 * <br />AA - 000000000000. Absolute y position of 0.
	 * <br />I - 001100. First 3 bits (001) indicate a lineTo operation. 4th bit (1) indicates 3 chars per parameter.
	 * <br />Au4 - 000000101110111000. An x delta of 300.0px, which is added to the previous x value of -150.0px to
	 * provide an absolute position of +150.0px.
	 * <br />AAA - 000000000000000000. A y delta value of 0.
	 *
	 * A tiny API method "p" also exists.
	 * @method decodePath
	 * @param {String} str The path string to decode.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.decodePath = function(str) {
		var instructions = [this.moveTo, this.lineTo, this.quadraticCurveTo, this.bezierCurveTo, this.closePath];
		var paramCount = [2, 2, 4, 6, 0];
		var i=0, l=str.length;
		var params = [];
		var x=0, y=0;
		var base64 = Graphics.BASE_64;

		while (i<l) {
			var c = str.charAt(i);
			var n = base64[c];
			var fi = n>>3; // highest order bits 1-3 code for operation.
			var f = instructions[fi];
			// check that we have a valid instruction & that the unused bits are empty:
			if (!f || (n&3)) { throw("bad path data (@"+i+"): "+c); }
			var pl = paramCount[fi];
			if (!fi) { x=y=0; } // move operations reset the position.
			params.length = 0;
			i++;
			var charCount = (n>>2&1)+2;  // 4th header bit indicates number size for this operation.
			for (var p=0; p<pl; p++) {
				var num = base64[str.charAt(i)];
				var sign = (num>>5) ? -1 : 1;
				num = ((num&31)<<6)|(base64[str.charAt(i+1)]);
				if (charCount == 3) { num = (num<<6)|(base64[str.charAt(i+2)]); }
				num = sign*num/10;
				if (p%2) { x = (num += x); }
				else { y = (num += y); }
				params[p] = num;
				i += charCount;
			}
			f.apply(this,params);
		}
		return this;
	};

	/**
	 * Stores all graphics commands so they won't be executed in future draws. Calling store() a second time adds to
	 * the existing store. This also affects `drawAsPath()`.
	 *
	 * This is useful in cases where you are creating vector graphics in an iterative manner (ex. generative art), so
	 * that only new graphics need to be drawn (which can provide huge performance benefits), but you wish to retain all
	 * of the vector instructions for later use (ex. scaling, modifying, or exporting).
	 *
	 * Note that calling store() will force the active path (if any) to be ended in a manner similar to changing
	 * the fill or stroke.
	 *
	 * For example, consider a application where the user draws lines with the mouse. As each line segment (or collection of
	 * segments) are added to a Shape, it can be rasterized using {{#crossLink "DisplayObject/updateCache"}}{{/crossLink}},
	 * and then stored, so that it can be redrawn at a different scale when the application is resized, or exported to SVG.
	 *
	 * 	// set up cache:
	 * 	myShape.cache(0,0,500,500,scale);
	 *
	 * 	// when the user drags, draw a new line:
	 * 	myShape.graphics.moveTo(oldX,oldY).lineTo(newX,newY);
	 * 	// then draw it into the existing cache:
	 * 	myShape.updateCache("source-over");
	 * 	// store the new line, so it isn't redrawn next time:
	 * 	myShape.store();
	 *
	 * 	// then, when the window resizes, we can re-render at a different scale:
	 * 	// first, unstore all our lines:
	 * 	myShape.unstore();
	 * 	// then cache using the new scale:
	 * 	myShape.cache(0,0,500,500,newScale);
	 * 	// finally, store the existing commands again:
	 * 	myShape.store();
	 *
	 * @method store
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.store = function() {
		this._updateInstructions(true);
		this._storeIndex = this._instructions.length;
		return this;
	};

	/**
	 * Unstores any graphics commands that were previously stored using {{#crossLink "Graphics/store"}}{{/crossLink}}
	 * so that they will be executed in subsequent draw calls.
	 *
	 * @method unstore
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.unstore = function() {
		this._storeIndex = 0;
		return this;
	};

	/**
	 * Returns a clone of this Graphics instance. Note that the individual command objects are not cloned.
	 * @method clone
	 * @return {Graphics} A clone of the current Graphics instance.
	 **/
	p.clone = function() {
		var o = new Graphics();
		o.command = this.command;
		o._stroke = this._stroke;
		o._strokeStyle = this._strokeStyle;
		o._strokeDash = this._strokeDash;
		o._strokeIgnoreScale = this._strokeIgnoreScale;
		o._fill = this._fill;
		o._instructions = this._instructions.slice();
		o._commitIndex = this._commitIndex;
		o._activeInstructions = this._activeInstructions.slice();
		o._dirty = this._dirty;
		o._storeIndex = this._storeIndex;
		return o;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Graphics]";
	};


// tiny API:
	/**
	 * Shortcut to moveTo.
	 * @method mt
	 * @param {Number} x The x coordinate the drawing point should move to.
	 * @param {Number} y The y coordinate the drawing point should move to.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls).
	 * @chainable
	 * @protected
	 **/
	p.mt = p.moveTo;

	/**
	 * Shortcut to lineTo.
	 * @method lt
	 * @param {Number} x The x coordinate the drawing point should draw to.
	 * @param {Number} y The y coordinate the drawing point should draw to.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.lt = p.lineTo;

	/**
	 * Shortcut to arcTo.
	 * @method at
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} radius
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.at = p.arcTo;

	/**
	 * Shortcut to bezierCurveTo.
	 * @method bt
	 * @param {Number} cp1x
	 * @param {Number} cp1y
	 * @param {Number} cp2x
	 * @param {Number} cp2y
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.bt = p.bezierCurveTo;

	/**
	 * Shortcut to quadraticCurveTo / curveTo.
	 * @method qt
	 * @param {Number} cpx
	 * @param {Number} cpy
	 * @param {Number} x
	 * @param {Number} y
	 * @protected
	 * @chainable
	 **/
	p.qt = p.quadraticCurveTo;

	/**
	 * Shortcut to arc.
	 * @method a
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} radius
	 * @param {Number} startAngle Measured in radians.
	 * @param {Number} endAngle Measured in radians.
	 * @param {Boolean} anticlockwise
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @protected
	 * @chainable
	 **/
	p.a = p.arc;

	/**
	 * Shortcut to rect.
	 * @method r
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w Width of the rectangle
	 * @param {Number} h Height of the rectangle
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.r = p.rect;

	/**
	 * Shortcut to closePath.
	 * @method cp
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.cp = p.closePath;

	/**
	 * Shortcut to clear.
	 * @method c
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.c = p.clear;

	/**
	 * Shortcut to beginFill.
	 * @method f
	 * @param {String} color A CSS compatible color value (ex. "red", "#FF0000", or "rgba(255,0,0,0.5)"). Setting to
	 * null will result in no fill.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.f = p.beginFill;

	/**
	 * Shortcut to beginLinearGradientFill.
	 * @method lf
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define a gradient
	 * drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw
	 * the first color to 10% then interpolating to the second color at 90%.
	 * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
	 * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.lf = p.beginLinearGradientFill;

	/**
	 * Shortcut to beginRadialGradientFill.
	 * @method rf
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
	 * a gradient drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
	 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
	 * @param {Number} x0 Center position of the inner circle that defines the gradient.
	 * @param {Number} y0 Center position of the inner circle that defines the gradient.
	 * @param {Number} r0 Radius of the inner circle that defines the gradient.
	 * @param {Number} x1 Center position of the outer circle that defines the gradient.
	 * @param {Number} y1 Center position of the outer circle that defines the gradient.
	 * @param {Number} r1 Radius of the outer circle that defines the gradient.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.rf = p.beginRadialGradientFill;

	/**
	 * Shortcut to beginBitmapFill.
	 * @method bf
	 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
	 * as the pattern.
	 * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of "repeat",
	 * "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat". Note that Firefox does not support "repeat-x" or
	 * "repeat-y" (latest tests were in FF 20.0), and will default to "repeat".
	 * @param {Matrix2D} matrix Optional. Specifies a transformation matrix for the bitmap fill. This transformation
	 * will be applied relative to the parent transform.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.bf = p.beginBitmapFill;

	/**
	 * Shortcut to endFill.
	 * @method ef
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.ef = p.endFill;

	/**
	 * Shortcut to setStrokeStyle.
	 * @method ss
	 * @param {Number} thickness The width of the stroke.
	 * @param {String | Number} [caps=0] Indicates the type of caps to use at the end of lines. One of butt,
	 * round, or square. Defaults to "butt". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with
	 * the tiny API.
	 * @param {String | Number} [joints=0] Specifies the type of joints that should be used where two lines meet.
	 * One of bevel, round, or miter. Defaults to "miter". Also accepts the values 0 (miter), 1 (round), and 2 (bevel)
	 * for use with the tiny API.
	 * @param {Number} [miterLimit=10] If joints is set to "miter", then you can specify a miter limit ratio which
	 * controls at what point a mitered joint will be clipped.
	 * @param {Boolean} [ignoreScale=false] If true, the stroke will be drawn at the specified thickness regardless
	 * of active transformations.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.ss = p.setStrokeStyle;
	
	/**
	 * Shortcut to setStrokeDash.
	 * @method sd
	 * @param {Array} [segments] An array specifying the dash pattern, alternating between line and gap.
	 * For example, [20,10] would create a pattern of 20 pixel lines with 10 pixel gaps between them.
	 * Passing null or an empty array will clear any existing dash.
	 * @param {Number} [offset=0] The offset of the dash pattern. For example, you could increment this value to create a "marching ants" effect.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.sd = p.setStrokeDash;

	/**
	 * Shortcut to beginStroke.
	 * @method s
	 * @param {String} color A CSS compatible color value (ex. "#FF0000", "red", or "rgba(255,0,0,0.5)"). Setting to
	 * null will result in no stroke.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.s = p.beginStroke;

	/**
	 * Shortcut to beginLinearGradientStroke.
	 * @method ls
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
	 * a gradient drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
	 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
	 * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
	 * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.ls = p.beginLinearGradientStroke;

	/**
	 * Shortcut to beginRadialGradientStroke.
	 * @method rs
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
	 * a gradient drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
	 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color
	 * to 100%.
	 * @param {Number} x0 Center position of the inner circle that defines the gradient.
	 * @param {Number} y0 Center position of the inner circle that defines the gradient.
	 * @param {Number} r0 Radius of the inner circle that defines the gradient.
	 * @param {Number} x1 Center position of the outer circle that defines the gradient.
	 * @param {Number} y1 Center position of the outer circle that defines the gradient.
	 * @param {Number} r1 Radius of the outer circle that defines the gradient.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.rs = p.beginRadialGradientStroke;

	/**
	 * Shortcut to beginBitmapStroke.
	 * @method bs
	 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
	 * as the pattern.
	 * @param {String} [repetition=repeat] Optional. Indicates whether to repeat the image in the fill area. One of
	 * "repeat", "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat".
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.bs = p.beginBitmapStroke;

	/**
	 * Shortcut to endStroke.
	 * @method es
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.es = p.endStroke;

	/**
	 * Shortcut to drawRect.
	 * @method dr
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w Width of the rectangle
	 * @param {Number} h Height of the rectangle
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.dr = p.drawRect;

	/**
	 * Shortcut to drawRoundRect.
	 * @method rr
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w
	 * @param {Number} h
	 * @param {Number} radius Corner radius.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.rr = p.drawRoundRect;

	/**
	 * Shortcut to drawRoundRectComplex.
	 * @method rc
	 * @param {Number} x The horizontal coordinate to draw the round rect.
	 * @param {Number} y The vertical coordinate to draw the round rect.
	 * @param {Number} w The width of the round rect.
	 * @param {Number} h The height of the round rect.
	 * @param {Number} radiusTL Top left corner radius.
	 * @param {Number} radiusTR Top right corner radius.
	 * @param {Number} radiusBR Bottom right corner radius.
	 * @param {Number} radiusBL Bottom left corner radius.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.rc = p.drawRoundRectComplex;

	/**
	 * Shortcut to drawCircle.
	 * @method dc
	 * @param {Number} x x coordinate center point of circle.
	 * @param {Number} y y coordinate center point of circle.
	 * @param {Number} radius Radius of circle.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.dc = p.drawCircle;

	/**
	 * Shortcut to drawEllipse.
	 * @method de
	 * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}
	 * which draws from center.
	 * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}
	 * which draws from the center.
	 * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this
	 * number.
	 * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.de = p.drawEllipse;

	/**
	 * Shortcut to drawPolyStar.
	 * @method dp
	 * @param {Number} x Position of the center of the shape.
	 * @param {Number} y Position of the center of the shape.
	 * @param {Number} radius The outer radius of the shape.
	 * @param {Number} sides The number of points on the star or sides on the polygon.
	 * @param {Number} pointSize The depth or "pointy-ness" of the star points. A pointSize of 0 will draw a regular
	 * polygon (no points), a pointSize of 1 will draw nothing because the points are infinitely pointy.
	 * @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point
	 * directly to the right of the center.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.dp = p.drawPolyStar;

	/**
	 * Shortcut to decodePath.
	 * @method p
	 * @param {String} str The path string to decode.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.p = p.decodePath;


// private methods:
	/**
	 * @method _updateInstructions
	 * @param commit
	 * @protected
	 **/
	p._updateInstructions = function(commit) {
		var instr = this._instructions, active = this._activeInstructions, commitIndex = this._commitIndex;

		if (this._dirty && active.length) {
			instr.length = commitIndex; // remove old, uncommitted commands
			instr.push(Graphics.beginCmd);

			var l = active.length, ll = instr.length;
			instr.length = ll+l;
			for (var i=0; i<l; i++) { instr[i+ll] = active[i]; }

			if (this._fill) { instr.push(this._fill); }
			if (this._stroke) {
				// doesn't need to be re-applied if it hasn't changed.
				if (this._strokeDash !== this._oldStrokeDash) {
					this._oldStrokeDash = this._strokeDash;
					instr.push(this._strokeDash);
				}
				if (this._strokeStyle !== this._oldStrokeStyle) {
					this._oldStrokeStyle = this._strokeStyle;
					instr.push(this._strokeStyle);
				}
				instr.push(this._stroke);
			}

			this._dirty = false;
		}

		if (commit) {
			active.length = 0;
			this._commitIndex = instr.length;
		}
	};

	/**
	 * @method _setFill
	 * @param fill
	 * @protected
	 **/
	p._setFill = function(fill) {
		this._updateInstructions(true);
		this.command = this._fill = fill;
		return this;
	};

	/**
	 * @method _setStroke
	 * @param stroke
	 * @protected
	 **/
	p._setStroke = function(stroke) {
		this._updateInstructions(true);
		if (this.command = this._stroke = stroke) {
			stroke.ignoreScale = this._strokeIgnoreScale;
		}
		return this;
	};

// Command Objects:
	/**
	 * @namespace Graphics
	 */
	/**
	 * Graphics command object. See {{#crossLink "Graphics/lineTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information. See {{#crossLink "Graphics"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class LineTo
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.LineTo = function(x, y) {
		this.x = x; this.y = y;
	}).prototype.exec = function(ctx) { ctx.lineTo(this.x,this.y); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/moveTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class MoveTo
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.MoveTo = function(x, y) {
		this.x = x; this.y = y;
	}).prototype.exec = function(ctx) { ctx.moveTo(this.x, this.y); };


	/**
	 * Graphics command object. See {{#crossLink "Graphics/arcTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class ArcTo
	 * @constructor
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} radius
	 **/
	/**
	 * @property x1
	 * @type Number
	 */
	/**
	 * @property y1
	 * @type Number
	 */
	/**
	 * @property x2
	 * @type Number
	 */
	/**
	 * @property y2
	 * @type Number
	 */
	/**
	 * @property radius
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.ArcTo = function(x1, y1, x2, y2, radius) {
		this.x1 = x1; this.y1 = y1;
		this.x2 = x2; this.y2 = y2;
		this.radius = radius;
	}).prototype.exec = function(ctx) { ctx.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/arc"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class Arc
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} radius
	 * @param {Number} startAngle
	 * @param {Number} endAngle
	 * @param {Number} anticlockwise
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @property radius
	 * @type Number
	 */
	/**
	 * @property startAngle
	 * @type Number
	 */
	/**
	 * @property endAngle
	 * @type Number
	 */
	/**
	 * @property anticlockwise
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.Arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {
		this.x = x; this.y = y;
		this.radius = radius;
		this.startAngle = startAngle; this.endAngle = endAngle;
		this.anticlockwise = !!anticlockwise;
	}).prototype.exec = function(ctx) { ctx.arc(this.x, this.y, this.radius, this.startAngle, this.endAngle, this.anticlockwise); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/quadraticCurveTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class QuadraticCurveTo
	 * @constructor
	 * @param {Number} cpx
	 * @param {Number} cpy
	 * @param {Number} x
	 * @param {Number} y
	 **/
	/**
	 * @property cpx
	 * @type Number
	 */
	/**
	 * @property cpy
	 * @type Number
	 */
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.QuadraticCurveTo = function(cpx, cpy, x, y) {
		this.cpx = cpx; this.cpy = cpy;
		this.x = x; this.y = y;
	}).prototype.exec = function(ctx) { ctx.quadraticCurveTo(this.cpx, this.cpy, this.x, this.y); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/bezierCurveTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class BezierCurveTo
	 * @constructor
	 * @param {Number} cp1x
	 * @param {Number} cp1y
	 * @param {Number} cp2x
	 * @param {Number} cp2y
	 * @param {Number} x
	 * @param {Number} y
	 **/
	/**
	 * @property cp1x
	 * @type Number
	 */
	/**
	 * @property cp1y
	 * @type Number
	 */
	/**
	 * @property cp2x
	 * @type Number
	 */
	/**
	 * @property cp2y
	 * @type Number
	 */
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.BezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
		this.cp1x = cp1x; this.cp1y = cp1y;
		this.cp2x = cp2x; this.cp2y = cp2y;
		this.x = x; this.y = y;
	}).prototype.exec = function(ctx) { ctx.bezierCurveTo(this.cp1x, this.cp1y, this.cp2x, this.cp2y, this.x, this.y); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/rect"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class Rect
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w
	 * @param {Number} h
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @property w
	 * @type Number
	 */
	/**
	 * @property h
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.Rect = function(x, y, w, h) {
		this.x = x; this.y = y;
		this.w = w; this.h = h;
	}).prototype.exec = function(ctx) { ctx.rect(this.x, this.y, this.w, this.h); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/closePath"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class ClosePath
	 * @constructor
	 **/
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.ClosePath = function() {
	}).prototype.exec = function(ctx) { ctx.closePath(); };

	/**
	 * Graphics command object to begin a new path. See {{#crossLink "Graphics"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class BeginPath
	 * @constructor
	 **/
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.BeginPath = function() {
	}).prototype.exec = function(ctx) { ctx.beginPath(); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/beginFill"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class Fill
	 * @constructor
	 * @param {Object} style A valid Context2D fillStyle.
	 * @param {Matrix2D} matrix
	 **/
	/**
	 * A valid Context2D fillStyle.
	 * @property style
	 * @type Object
	 */
	/**
	 * @property matrix
	 * @type Matrix2D
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	p = (G.Fill = function(style, matrix) {
		this.style = style;
		this.matrix = matrix;
	}).prototype;
	p.exec = function(ctx) {
		if (!this.style) { return; }
		ctx.fillStyle = this.style;
		var mtx = this.matrix;
		if (mtx) { ctx.save(); ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty); }
		ctx.fill();
		if (mtx) { ctx.restore(); }
	};
	/**
	 * Creates a linear gradient style and assigns it to {{#crossLink "Fill/style:property"}}{{/crossLink}}.
	 * See {{#crossLink "Graphics/beginLinearGradientFill"}}{{/crossLink}} for more information.
	 * @method linearGradient
	 * @param {Array} colors
	 * @param {Array} ratios
	 * @param {Number} x0
	 * @param {Number} y0
	 * @param {Number} x1
	 * @param {Number} y1
	 * @return {Fill} Returns this Fill object for chaining or assignment.
	 */
	p.linearGradient = function(colors, ratios, x0, y0, x1, y1) {
		var o = this.style =  Graphics._ctx.createLinearGradient(x0, y0, x1, y1);
		for (var i=0, l=colors.length; i<l; i++) { o.addColorStop(ratios[i], colors[i]); }
		o.props = {colors:colors, ratios:ratios, x0:x0, y0:y0, x1:x1, y1:y1, type:"linear"};
		return this;
	};
	/**
	 * Creates a radial gradient style and assigns it to {{#crossLink "Fill/style:property"}}{{/crossLink}}.
	 * See {{#crossLink "Graphics/beginRadialGradientFill"}}{{/crossLink}} for more information.
	 * @method radialGradient
	 * @param {Array} colors
	 * @param {Array} ratios
	 * @param {Number} x0
	 * @param {Number} y0
	 * @param {Number} r0
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} r1
	 * @return {Fill} Returns this Fill object for chaining or assignment.
	 */
	p.radialGradient = function(colors, ratios, x0, y0, r0, x1, y1, r1) {
		var o = this.style =  Graphics._ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
		for (var i=0, l=colors.length; i<l; i++) { o.addColorStop(ratios[i], colors[i]); }
		o.props = {colors:colors, ratios:ratios, x0:x0, y0:y0, r0:r0, x1:x1, y1:y1, r1:r1, type:"radial"};
		return this;
	};
	/**
	 * Creates a bitmap fill style and assigns it to the {{#crossLink "Fill/style:property"}}{{/crossLink}}.
	 * See {{#crossLink "Graphics/beginBitmapFill"}}{{/crossLink}} for more information.
	 * @method bitmap
	 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image  Must be loaded prior to creating a bitmap fill, or the fill will be empty.
	 * @param {String} [repetition] One of: repeat, repeat-x, repeat-y, or no-repeat.
	 * @return {Fill} Returns this Fill object for chaining or assignment.
	 */
	p.bitmap = function(image, repetition) {
		if (image.naturalWidth || image.getContext || image.readyState >= 2) {
			var o = this.style = Graphics._ctx.createPattern(image, repetition || "");
			o.props = {image: image, repetition: repetition, type: "bitmap"};
		}
		return this;
	};
	p.path = false;

	/**
	 * Graphics command object. See {{#crossLink "Graphics/beginStroke"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class Stroke
	 * @constructor
	 * @param {Object} style A valid Context2D fillStyle.
	 * @param {Boolean} ignoreScale
	 **/
	/**
	 * A valid Context2D strokeStyle.
	 * @property style
	 * @type Object
	 */
	/**
	 * @property ignoreScale
	 * @type Boolean
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	p = (G.Stroke = function(style, ignoreScale) {
		this.style = style;
		this.ignoreScale = ignoreScale;
	}).prototype;
	p.exec = function(ctx) {
		if (!this.style) { return; }
		ctx.strokeStyle = this.style;
		if (this.ignoreScale) { ctx.save(); ctx.setTransform(1,0,0,1,0,0); }
		ctx.stroke();
		if (this.ignoreScale) { ctx.restore(); }
	};
	/**
	 * Creates a linear gradient style and assigns it to {{#crossLink "Stroke/style:property"}}{{/crossLink}}.
	 * See {{#crossLink "Graphics/beginLinearGradientStroke"}}{{/crossLink}} for more information.
	 * @method linearGradient
	 * @param {Array} colors
	 * @param {Array} ratios
	 * @param {Number} x0
	 * @param {Number} y0
	 * @param {Number} x1
	 * @param {Number} y1
	 * @return {Fill} Returns this Stroke object for chaining or assignment.
	 */
	p.linearGradient = G.Fill.prototype.linearGradient;
	/**
	 * Creates a radial gradient style and assigns it to {{#crossLink "Stroke/style:property"}}{{/crossLink}}.
	 * See {{#crossLink "Graphics/beginRadialGradientStroke"}}{{/crossLink}} for more information.
	 * @method radialGradient
	 * @param {Array} colors
	 * @param {Array} ratios
	 * @param {Number} x0
	 * @param {Number} y0
	 * @param {Number} r0
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} r1
	 * @return {Fill} Returns this Stroke object for chaining or assignment.
	 */
	p.radialGradient = G.Fill.prototype.radialGradient;
	/**
	 * Creates a bitmap fill style and assigns it to {{#crossLink "Stroke/style:property"}}{{/crossLink}}.
	 * See {{#crossLink "Graphics/beginBitmapStroke"}}{{/crossLink}} for more information.
	 * @method bitmap
	 * @param {HTMLImageElement} image
	 * @param {String} [repetition] One of: repeat, repeat-x, repeat-y, or no-repeat.
	 * @return {Fill} Returns this Stroke object for chaining or assignment.
	 */
	p.bitmap = G.Fill.prototype.bitmap;
	p.path = false;

	/**
	 * Graphics command object. See {{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class StrokeStyle
	 * @constructor
	 * @param {Number} width
	 * @param {String} [caps]
	 * @param {String} [joints]
	 * @param {Number} [miterLimit]
	 **/
	/**
	 * @property width
	 * @type Number
	 */
	/**
	 * One of: butt, round, square
	 * @property caps
	 * @type String
	 */
	/**
	 * One of: round, bevel, miter
	 * @property joints
	 * @type String
	 */
	/**
	 * @property miterLimit
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	p = (G.StrokeStyle = function(width, caps, joints, miterLimit) {
		this.width = width;
		this.caps = caps;
		this.joints = joints;
		this.miterLimit = miterLimit;
	}).prototype;
	p.exec = function(ctx) {
		ctx.lineWidth = (this.width == null ? "1" : this.width);
		ctx.lineCap = (this.caps == null ? "butt" : (isNaN(this.caps) ? this.caps : Graphics.STROKE_CAPS_MAP[this.caps]));
		ctx.lineJoin = (this.joints == null ? "miter" : (isNaN(this.joints) ? this.joints : Graphics.STROKE_JOINTS_MAP[this.joints]));
		ctx.miterLimit = (this.miterLimit == null ? "10" : this.miterLimit);
	};
	p.path = false;
	
	/**
	 * Graphics command object. See {{#crossLink "Graphics/setStrokeDash"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class StrokeDash
	 * @constructor
	 * @param {Array} [segments]
	 * @param {Number} [offset=0]
	 **/
	/**
	 * @property segments
	 * @type Array
	 */
	/**
	 * @property offset
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.StrokeDash = function(segments, offset) {
		this.segments = segments;
		this.offset = offset||0;
	}).prototype.exec = function(ctx) {
		if (ctx.setLineDash) { // feature detection.
			ctx.setLineDash(this.segments|| G.StrokeDash.EMPTY_SEGMENTS); // instead of [] to reduce churn.
			ctx.lineDashOffset = this.offset||0;
		}
	};
	/**
	 * The default value for segments (ie. no dash).
	 * @property EMPTY_SEGMENTS
	 * @static
	 * @final
	 * @readonly
	 * @protected
	 * @type {Array}
	 **/
	G.StrokeDash.EMPTY_SEGMENTS = [];

	/**
	 * Graphics command object. See {{#crossLink "Graphics/drawRoundRectComplex"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class RoundRect
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w
	 * @param {Number} h
	 * @param {Number} radiusTL
	 * @param {Number} radiusTR
	 * @param {Number} radiusBR
	 * @param {Number} radiusBL
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @property w
	 * @type Number
	 */
	/**
	 * @property h
	 * @type Number
	 */
	/**
	 * @property radiusTL
	 * @type Number
	 */
	/**
	 * @property radiusTR
	 * @type Number
	 */
	/**
	 * @property radiusBR
	 * @type Number
	 */
	/**
	 * @property radiusBL
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.RoundRect = function(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {
		this.x = x; this.y = y;
		this.w = w; this.h = h;
		this.radiusTL = radiusTL; this.radiusTR = radiusTR;
		this.radiusBR = radiusBR; this.radiusBL = radiusBL;
	}).prototype.exec = function(ctx) {
		var max = (w<h?w:h)/2;
		var mTL=0, mTR=0, mBR=0, mBL=0;
		var x = this.x, y = this.y, w = this.w, h = this.h;
		var rTL = this.radiusTL, rTR = this.radiusTR, rBR = this.radiusBR, rBL = this.radiusBL;

		if (rTL < 0) { rTL *= (mTL=-1); }
		if (rTL > max) { rTL = max; }
		if (rTR < 0) { rTR *= (mTR=-1); }
		if (rTR > max) { rTR = max; }
		if (rBR < 0) { rBR *= (mBR=-1); }
		if (rBR > max) { rBR = max; }
		if (rBL < 0) { rBL *= (mBL=-1); }
		if (rBL > max) { rBL = max; }

		ctx.moveTo(x+w-rTR, y);
		ctx.arcTo(x+w+rTR*mTR, y-rTR*mTR, x+w, y+rTR, rTR);
		ctx.lineTo(x+w, y+h-rBR);
		ctx.arcTo(x+w+rBR*mBR, y+h+rBR*mBR, x+w-rBR, y+h, rBR);
		ctx.lineTo(x+rBL, y+h);
		ctx.arcTo(x-rBL*mBL, y+h+rBL*mBL, x, y+h-rBL, rBL);
		ctx.lineTo(x, y+rTL);
		ctx.arcTo(x-rTL*mTL, y-rTL*mTL, x+rTL, y, rTL);
		ctx.closePath();
	};

	/**
	 * Graphics command object. See {{#crossLink "Graphics/drawCircle"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class Circle
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} radius
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @property radius
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.Circle = function(x, y, radius) {
		this.x = x; this.y = y;
		this.radius = radius;
	}).prototype.exec = function(ctx) { ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/drawEllipse"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class Ellipse
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w
	 * @param {Number} h
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @property w
	 * @type Number
	 */
	/**
	 * @property h
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.Ellipse = function(x, y, w, h) {
		this.x = x; this.y = y;
		this.w = w; this.h = h;
	}).prototype.exec = function(ctx) {
		var x = this.x, y = this.y;
		var w = this.w, h = this.h;

		var k = 0.5522848;
		var ox = (w / 2) * k;
		var oy = (h / 2) * k;
		var xe = x + w;
		var ye = y + h;
		var xm = x + w / 2;
		var ym = y + h / 2;

		ctx.moveTo(x, ym);
		ctx.bezierCurveTo(x, ym-oy, xm-ox, y, xm, y);
		ctx.bezierCurveTo(xm+ox, y, xe, ym-oy, xe, ym);
		ctx.bezierCurveTo(xe, ym+oy, xm+ox, ye, xm, ye);
		ctx.bezierCurveTo(xm-ox, ye, x, ym+oy, x, ym);
	};

	/**
	 * Graphics command object. See {{#crossLink "Graphics/drawPolyStar"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class PolyStar
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} radius
	 * @param {Number} sides
	 * @param {Number} pointSize
	 * @param {Number} angle
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @property radius
	 * @type Number
	 */
	/**
	 * @property sides
	 * @type Number
	 */
	/**
	 * @property pointSize
	 * @type Number
	 */
	/**
	 * @property angle
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.PolyStar = function(x, y, radius, sides, pointSize, angle) {
		this.x = x; this.y = y;
		this.radius = radius;
		this.sides = sides;
		this.pointSize = pointSize;
		this.angle = angle;
	}).prototype.exec = function(ctx) {
		var x = this.x, y = this.y;
		var radius = this.radius;
		var angle = (this.angle||0)/180*Math.PI;
		var sides = this.sides;
		var ps = 1-(this.pointSize||0);
		var a = Math.PI/sides;

		ctx.moveTo(x+Math.cos(angle)*radius, y+Math.sin(angle)*radius);
		for (var i=0; i<sides; i++) {
			angle += a;
			if (ps != 1) {
				ctx.lineTo(x+Math.cos(angle)*radius*ps, y+Math.sin(angle)*radius*ps);
			}
			angle += a;
			ctx.lineTo(x+Math.cos(angle)*radius, y+Math.sin(angle)*radius);
		}
		ctx.closePath();
	};

	// docced above.
	Graphics.beginCmd = new G.BeginPath(); // so we don't have to instantiate multiple instances.


	createjs.Graphics = Graphics;
}());

//##############################################################################
// DisplayObject.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * DisplayObject is an abstract class that should not be constructed directly. Instead construct subclasses such as
	 * {{#crossLink "Container"}}{{/crossLink}}, {{#crossLink "Bitmap"}}{{/crossLink}}, and {{#crossLink "Shape"}}{{/crossLink}}.
	 * DisplayObject is the base class for all display classes in the EaselJS library. It defines the core properties and
	 * methods that are shared between all display objects, such as transformation properties (x, y, scaleX, scaleY, etc),
	 * caching, and mouse handlers.
	 * @class DisplayObject
	 * @extends EventDispatcher
	 * @constructor
	 **/
	function DisplayObject() {
		this.EventDispatcher_constructor();
		
		
	// public properties:
		/**
		 * The alpha (transparency) for this display object. 0 is fully transparent, 1 is fully opaque.
		 * @property alpha
		 * @type {Number}
		 * @default 1
		 **/
		this.alpha = 1;
	
		/**
		 * If a cache is active, this returns the canvas that holds the cached version of this display object. See {{#crossLink "cache"}}{{/crossLink}}
		 * for more information.
		 * @property cacheCanvas
		 * @type {HTMLCanvasElement | Object}
		 * @default null
		 * @readonly
		 **/
		this.cacheCanvas = null;
	
		/**
		 * Returns an ID number that uniquely identifies the current cache for this display object. This can be used to
		 * determine if the cache has changed since a previous check.
		 * @property cacheID
		 * @type {Number}
		 * @default 0
		 */
		this.cacheID = 0;
	
		/**
		 * Unique ID for this display object. Makes display objects easier for some uses.
		 * @property id
		 * @type {Number}
		 * @default -1
		 **/
		this.id = createjs.UID.get();
	
		/**
		 * Indicates whether to include this object when running mouse interactions. Setting this to `false` for children
		 * of a {{#crossLink "Container"}}{{/crossLink}} will cause events on the Container to not fire when that child is
		 * clicked. Setting this property to `false` does not prevent the {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}}
		 * method from returning the child.
		 *
		 * <strong>Note:</strong> In EaselJS 0.7.0, the mouseEnabled property will not work properly with nested Containers. Please
		 * check out the latest NEXT version in <a href="https://github.com/CreateJS/EaselJS/tree/master/lib">GitHub</a> for an updated version with this issue resolved. The fix will be
		 * provided in the next release of EaselJS.
		 * @property mouseEnabled
		 * @type {Boolean}
		 * @default true
		 **/
		this.mouseEnabled = true;
		
		/**
		 * If false, the tick will not run on this display object (or its children). This can provide some performance benefits.
		 * In addition to preventing the "tick" event from being dispatched, it will also prevent tick related updates
		 * on some display objects (ex. Sprite & MovieClip frame advancing, DOMElement visibility handling).
		 * @property tickEnabled
		 * @type Boolean
		 * @default true
		 **/
		this.tickEnabled = true;
	
		/**
		 * An optional name for this display object. Included in {{#crossLink "DisplayObject/toString"}}{{/crossLink}} . Useful for
		 * debugging.
		 * @property name
		 * @type {String}
		 * @default null
		 **/
		this.name = null;
	
		/**
		 * A reference to the {{#crossLink "Container"}}{{/crossLink}} or {{#crossLink "Stage"}}{{/crossLink}} object that
		 * contains this display object, or null if it has not been added
		 * to one.
		 * @property parent
		 * @final
		 * @type {Container}
		 * @default null
		 * @readonly
		 **/
		this.parent = null;
	
		/**
		 * The left offset for this display object's registration point. For example, to make a 100x100px Bitmap rotate
		 * around its center, you would set regX and {{#crossLink "DisplayObject/regY:property"}}{{/crossLink}} to 50.
		 * @property regX
		 * @type {Number}
		 * @default 0
		 **/
		this.regX = 0;
	
		/**
		 * The y offset for this display object's registration point. For example, to make a 100x100px Bitmap rotate around
		 * its center, you would set {{#crossLink "DisplayObject/regX:property"}}{{/crossLink}} and regY to 50.
		 * @property regY
		 * @type {Number}
		 * @default 0
		 **/
		this.regY = 0;
	
		/**
		 * The rotation in degrees for this display object.
		 * @property rotation
		 * @type {Number}
		 * @default 0
		 **/
		this.rotation = 0;
	
		/**
		 * The factor to stretch this display object horizontally. For example, setting scaleX to 2 will stretch the display
		 * object to twice its nominal width. To horizontally flip an object, set the scale to a negative number.
		 * @property scaleX
		 * @type {Number}
		 * @default 1
		 **/
		this.scaleX = 1;
	
		/**
		 * The factor to stretch this display object vertically. For example, setting scaleY to 0.5 will stretch the display
		 * object to half its nominal height. To vertically flip an object, set the scale to a negative number.
		 * @property scaleY
		 * @type {Number}
		 * @default 1
		 **/
		this.scaleY = 1;
	
		/**
		 * The factor to skew this display object horizontally.
		 * @property skewX
		 * @type {Number}
		 * @default 0
		 **/
		this.skewX = 0;
	
		/**
		 * The factor to skew this display object vertically.
		 * @property skewY
		 * @type {Number}
		 * @default 0
		 **/
		this.skewY = 0;
	
		/**
		 * A shadow object that defines the shadow to render on this display object. Set to `null` to remove a shadow. If
		 * null, this property is inherited from the parent container.
		 * @property shadow
		 * @type {Shadow}
		 * @default null
		 **/
		this.shadow = null;
	
		/**
		 * Indicates whether this display object should be rendered to the canvas and included when running the Stage
		 * {{#crossLink "Stage/getObjectsUnderPoint"}}{{/crossLink}} method.
		 * @property visible
		 * @type {Boolean}
		 * @default true
		 **/
		this.visible = true;
	
		/**
		 * The x (horizontal) position of the display object, relative to its parent.
		 * @property x
		 * @type {Number}
		 * @default 0
		 **/
		this.x = 0;
	
		/** The y (vertical) position of the display object, relative to its parent.
		 * @property y
		 * @type {Number}
		 * @default 0
		 **/
		this.y = 0;
		
		/**
		 * If set, defines the transformation for this display object, overriding all other transformation properties
		 * (x, y, rotation, scale, skew).
		 * @property transformMatrix
		 * @type {Matrix2D}
		 * @default null
		 **/
		this.transformMatrix = null;
		
		/**
		 * The composite operation indicates how the pixels of this display object will be composited with the elements
		 * behind it. If `null`, this property is inherited from the parent container. For more information, read the
		 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#compositing">
		 * whatwg spec on compositing</a>.
		 * @property compositeOperation
		 * @type {String}
		 * @default null
		 **/
		this.compositeOperation = null;
	
		/**
		 * Indicates whether the display object should be drawn to a whole pixel when
		 * {{#crossLink "Stage/snapToPixelEnabled"}}{{/crossLink}} is true. To enable/disable snapping on whole
		 * categories of display objects, set this value on the prototype (Ex. Text.prototype.snapToPixel = true).
		 * @property snapToPixel
		 * @type {Boolean}
		 * @default true
		 **/
		this.snapToPixel = true;
	
		/**
		 * An array of Filter objects to apply to this display object. Filters are only applied / updated when {{#crossLink "cache"}}{{/crossLink}}
		 * or {{#crossLink "updateCache"}}{{/crossLink}} is called on the display object, and only apply to the area that is
		 * cached.
		 * @property filters
		 * @type {Array}
		 * @default null
		 **/
		this.filters = null;
		
		/**
		 * A Shape instance that defines a vector mask (clipping path) for this display object.  The shape's transformation
		 * will be applied relative to the display object's parent coordinates (as if it were a child of the parent).
		 * @property mask
		 * @type {Shape}
		 * @default null
		 */
		this.mask = null;
		
		/**
		 * A display object that will be tested when checking mouse interactions or testing {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}}.
		 * The hit area will have its transformation applied relative to this display object's coordinate space (as though
		 * the hit test object were a child of this display object and relative to its regX/Y). The hitArea will be tested
		 * using only its own `alpha` value regardless of the alpha value on the target display object, or the target's
		 * ancestors (parents).
		 * 
		 * If set on a {{#crossLink "Container"}}{{/crossLink}}, children of the Container will not receive mouse events.
		 * This is similar to setting {{#crossLink "mouseChildren"}}{{/crossLink}} to false.
		 *
		 * Note that hitArea is NOT currently used by the `hitTest()` method, nor is it supported for {{#crossLink "Stage"}}{{/crossLink}}.
		 * @property hitArea
		 * @type {DisplayObject}
		 * @default null
		 */
		this.hitArea = null;
		
		/**
		 * A CSS cursor (ex. "pointer", "help", "text", etc) that will be displayed when the user hovers over this display
		 * object. You must enable mouseover events using the {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}} method to
		 * use this property. Setting a non-null cursor on a Container will override the cursor set on its descendants.
		 * @property cursor
		 * @type {String}
		 * @default null
		 */
		this.cursor = null;
	
	
	// private properties:
		/**
		 * @property _cacheOffsetX
		 * @protected
		 * @type {Number}
		 * @default 0
		 **/
		this._cacheOffsetX = 0;
	
		/**
		 * @property _cacheOffsetY
		 * @protected
		 * @type {Number}
		 * @default 0
		 **/
		this._cacheOffsetY = 0;
		
		/**
		 * @property _filterOffsetX
		 * @protected
		 * @type {Number}
		 * @default 0
		 **/
		this._filterOffsetX = 0;
		
		/**
		 * @property _filterOffsetY
		 * @protected
		 * @type {Number}
		 * @default 0
		 **/
		this._filterOffsetY = 0;
		
		/**
		 * @property _cacheScale
		 * @protected
		 * @type {Number}
		 * @default 1
		 **/
		this._cacheScale = 1;
	
		/**
		* @property _cacheDataURLID
		* @protected
		* @type {Number}
		* @default 0
		*/
		this._cacheDataURLID = 0;
		
		/**
		* @property _cacheDataURL
		* @protected
		* @type {String}
		* @default null
		*/
		this._cacheDataURL = null;
	
		/**
		 * @property _props
		 * @protected
		 * @type {DisplayObject}
		 * @default null
		 **/
		this._props = new createjs.DisplayProps();
	
		/**
		 * @property _rectangle
		 * @protected
		 * @type {Rectangle}
		 * @default null
		 **/
		this._rectangle = new createjs.Rectangle();
	
		/**
		 * @property _bounds
		 * @protected
		 * @type {Rectangle}
		 * @default null
		 **/
		this._bounds = null;
	}
	var p = createjs.extend(DisplayObject, createjs.EventDispatcher);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
// static properties:
	/**
	 * Listing of mouse event names. Used in _hasMouseEventListener.
	 * @property _MOUSE_EVENTS
	 * @protected
	 * @static
	 * @type {Array}
	 **/
	DisplayObject._MOUSE_EVENTS = ["click","dblclick","mousedown","mouseout","mouseover","pressmove","pressup","rollout","rollover"];

	/**
	 * Suppresses errors generated when using features like hitTest, mouse events, and {{#crossLink "getObjectsUnderPoint"}}{{/crossLink}}
	 * with cross domain content.
	 * @property suppressCrossDomainErrors
	 * @static
	 * @type {Boolean}
	 * @default false
	 **/
	DisplayObject.suppressCrossDomainErrors = false;
	
	/**
	 * @property _snapToPixelEnabled
	 * @protected
	 * @static
	 * @type {Boolean}
	 * @default false
	 **/
	DisplayObject._snapToPixelEnabled = false; // stage.snapToPixelEnabled is temporarily copied here during a draw to provide global access.

	/**
	 * @property _hitTestCanvas
	 * @type {HTMLCanvasElement | Object}
	 * @static
	 * @protected
	 **/
	/**
	 * @property _hitTestContext
	 * @type {CanvasRenderingContext2D}
	 * @static
	 * @protected
	 **/
	var canvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"); // prevent errors on load in browsers without canvas.
	if (canvas.getContext) {
		DisplayObject._hitTestCanvas = canvas;
		DisplayObject._hitTestContext = canvas.getContext("2d");
		canvas.width = canvas.height = 1;
	}

	/**
	 * @property _nextCacheID
	 * @type {Number}
	 * @static
	 * @protected
	 **/
	DisplayObject._nextCacheID = 1;


// events:
	/**
	 * Dispatched when the user presses their left mouse button over the display object. See the 
	 * {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event mousedown
	 * @since 0.6.0
	 */
	 
	/**
	 * Dispatched when the user presses their left mouse button and then releases it while over the display object.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event click
	 * @since 0.6.0
	 */
	 
	/**
	 * Dispatched when the user double clicks their left mouse button over this display object.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event dblclick
	 * @since 0.6.0
	 */
	 
	/**
	 * Dispatched when the user's mouse enters this display object. This event must be enabled using 
	 * {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}. See also {{#crossLink "DisplayObject/rollover:event"}}{{/crossLink}}.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event mouseover
	 * @since 0.6.0
	 */

	/**
	 * Dispatched when the user's mouse leaves this display object. This event must be enabled using 
	 * {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}. See also {{#crossLink "DisplayObject/rollout:event"}}{{/crossLink}}.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event mouseout
	 * @since 0.6.0
	 */
	 
	/**
	 * This event is similar to {{#crossLink "DisplayObject/mouseover:event"}}{{/crossLink}}, with the following
	 * differences: it does not bubble, and it considers {{#crossLink "Container"}}{{/crossLink}} instances as an
	 * aggregate of their content.
	 * 
	 * For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over
	 * shapeA and then directly on to shapeB. With a listener for {{#crossLink "mouseover:event"}}{{/crossLink}} on
	 * myContainer, two events would be received, each targeting a child element:<OL>
	 * <LI>when the mouse enters shapeA (target=shapeA)</LI>
	 * <LI>when the mouse enters shapeB (target=shapeB)</LI>
	 * </OL>
	 * However, with a listener for "rollover" instead, only a single event is received when the mouse first enters
	 * the aggregate myContainer content (target=myContainer).
	 * 
	 * This event must be enabled using {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event rollover
	 * @since 0.7.0
	 */
	 
	/**
	 * This event is similar to {{#crossLink "DisplayObject/mouseout:event"}}{{/crossLink}}, with the following
	 * differences: it does not bubble, and it considers {{#crossLink "Container"}}{{/crossLink}} instances as an
	 * aggregate of their content.
	 * 
	 * For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over
	 * shapeA, then directly on to shapeB, then off both. With a listener for {{#crossLink "mouseout:event"}}{{/crossLink}}
	 * on myContainer, two events would be received, each targeting a child element:<OL>
	 * <LI>when the mouse leaves shapeA (target=shapeA)</LI>
	 * <LI>when the mouse leaves shapeB (target=shapeB)</LI>
	 * </OL>
	 * However, with a listener for "rollout" instead, only a single event is received when the mouse leaves
	 * the aggregate myContainer content (target=myContainer).
	 * 
	 * This event must be enabled using {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event rollout
	 * @since 0.7.0
	 */
	 
	/**
	 * After a {{#crossLink "DisplayObject/mousedown:event"}}{{/crossLink}} occurs on a display object, a pressmove
	 * event will be generated on that object whenever the mouse moves until the mouse press is released. This can be
	 * useful for dragging and similar operations.
	 * @event pressmove
	 * @since 0.7.0
	 */
	 
	/**
	 * After a {{#crossLink "DisplayObject/mousedown:event"}}{{/crossLink}} occurs on a display object, a pressup event
	 * will be generated on that object when that mouse press is released. This can be useful for dragging and similar
	 * operations.
	 * @event pressup
	 * @since 0.7.0
	 */
	 
	/**
	 * Dispatched when the display object is added to a parent container.
	 * @event added
	 */
	 
	/**
	 * Dispatched when the display object is removed from its parent container.
	 * @event removed
	 */
	 
	/**
	 * Dispatched on each display object on a stage whenever the stage updates. This occurs immediately before the
	 * rendering (draw) pass. When {{#crossLink "Stage/update"}}{{/crossLink}} is called, first all display objects on
	 * the stage dispatch the tick event, then all of the display objects are drawn to stage. Children will have their
	 * {{#crossLink "tick:event"}}{{/crossLink}} event dispatched in order of their depth prior to the event being
	 * dispatched on their parent.
	 * @event tick
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Array} params An array containing any arguments that were passed to the Stage.update() method. For
	 *      example if you called stage.update("hello"), then the params would be ["hello"].
	 * @since 0.6.0
	 */
	
	
// getter / setters:
	/**
	 * Use the {{#crossLink "DisplayObject/stage:property"}}{{/crossLink}} property instead.
	 * @method getStage
	 * @return {Stage}
	 * @deprecated
	 **/
	p.getStage = function() {
		// uses dynamic access to avoid circular dependencies;
		var o = this, _Stage = createjs["Stage"];
		while (o.parent) { o = o.parent; }
		if (o instanceof _Stage) { return o; }
		return null;
	};

	/**
	 * Returns the Stage instance that this display object will be rendered on, or null if it has not been added to one.
	 * @property stage
	 * @type {Stage}
	 * @readonly
	 **/
	try {
		Object.defineProperties(p, {
			stage: { get: p.getStage }
		});
	} catch (e) {}


// public methods:
	/**
	 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
	 **/
	p.isVisible = function() {
		return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0);
	};

	/**
	 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
	 * Returns <code>true</code> if the draw was handled (useful for overriding functionality).
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,
	 * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).
	 * @return {Boolean}
	 **/
	p.draw = function(ctx, ignoreCache) {
		var cacheCanvas = this.cacheCanvas;
		if (ignoreCache || !cacheCanvas) { return false; }
		var scale = this._cacheScale;
		ctx.drawImage(cacheCanvas, this._cacheOffsetX+this._filterOffsetX, this._cacheOffsetY+this._filterOffsetY, cacheCanvas.width/scale, cacheCanvas.height/scale);
		return true;
	};
	
	/**
	 * Applies this display object's transformation, alpha, globalCompositeOperation, clipping path (mask), and shadow
	 * to the specified context. This is typically called prior to {{#crossLink "DisplayObject/draw"}}{{/crossLink}}.
	 * @method updateContext
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D to update.
	 **/
	p.updateContext = function(ctx) {
		var o=this, mask=o.mask, mtx= o._props.matrix;
		
		if (mask && mask.graphics && !mask.graphics.isEmpty()) {
			mask.getMatrix(mtx);
			ctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);
			
			mask.graphics.drawAsPath(ctx);
			ctx.clip();
			
			mtx.invert();
			ctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);
		}
		
		this.getMatrix(mtx);
		var tx = mtx.tx, ty = mtx.ty;
		if (DisplayObject._snapToPixelEnabled && o.snapToPixel) {
			tx = tx + (tx < 0 ? -0.5 : 0.5) | 0;
			ty = ty + (ty < 0 ? -0.5 : 0.5) | 0;
		}
		ctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, tx, ty);
		ctx.globalAlpha *= o.alpha;
		if (o.compositeOperation) { ctx.globalCompositeOperation = o.compositeOperation; }
		if (o.shadow) { this._applyShadow(ctx, o.shadow); }
	};

	/**
	 * Draws the display object into a new canvas, which is then used for subsequent draws. For complex content
	 * that does not change frequently (ex. a Container with many children that do not move, or a complex vector Shape),
	 * this can provide for much faster rendering because the content does not need to be re-rendered each tick. The
	 * cached display object can be moved, rotated, faded, etc freely, however if its content changes, you must
	 * manually update the cache by calling <code>updateCache()</code> or <code>cache()</code> again. You must specify
	 * the cache area via the x, y, w, and h parameters. This defines the rectangle that will be rendered and cached
	 * using this display object's coordinates.
	 *
	 * <h4>Example</h4>
	 * For example if you defined a Shape that drew a circle at 0, 0 with a radius of 25:
	 *
	 *      var shape = new createjs.Shape();
	 *      shape.graphics.beginFill("#ff0000").drawCircle(0, 0, 25);
	 *      myShape.cache(-25, -25, 50, 50);
	 *
	 * Note that filters need to be defined <em>before</em> the cache is applied. Check out the {{#crossLink "Filter"}}{{/crossLink}}
	 * class for more information. Some filters (ex. BlurFilter) will not work as expected in conjunction with the scale param.
	 * 
	 * Usually, the resulting cacheCanvas will have the dimensions width*scale by height*scale, however some filters (ex. BlurFilter)
	 * will add padding to the canvas dimensions.
	 *
	 * @method cache
	 * @param {Number} x The x coordinate origin for the cache region.
	 * @param {Number} y The y coordinate origin for the cache region.
	 * @param {Number} width The width of the cache region.
	 * @param {Number} height The height of the cache region.
	 * @param {Number} [scale=1] The scale at which the cache will be created. For example, if you cache a vector shape using
	 * 	myShape.cache(0,0,100,100,2) then the resulting cacheCanvas will be 200x200 px. This lets you scale and rotate
	 * 	cached elements with greater fidelity. Default is 1.
	 **/
	p.cache = function(x, y, width, height, scale) {
		// draw to canvas.
		scale = scale||1;
		if (!this.cacheCanvas) { this.cacheCanvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"); }
		this._cacheWidth = width;
		this._cacheHeight = height;
		this._cacheOffsetX = x;
		this._cacheOffsetY = y;
		this._cacheScale = scale;
		this.updateCache();
	};

	/**
	 * Redraws the display object to its cache. Calling updateCache without an active cache will throw an error.
	 * If compositeOperation is null the current cache will be cleared prior to drawing. Otherwise the display object
	 * will be drawn over the existing cache using the specified compositeOperation.
	 *
	 * <h4>Example</h4>
	 * Clear the current graphics of a cached shape, draw some new instructions, and then update the cache. The new line
	 * will be drawn on top of the old one.
	 *
	 *      // Not shown: Creating the shape, and caching it.
	 *      shapeInstance.clear();
	 *      shapeInstance.setStrokeStyle(3).beginStroke("#ff0000").moveTo(100, 100).lineTo(200,200);
	 *      shapeInstance.updateCache();
	 *
	 * @method updateCache
	 * @param {String} compositeOperation The compositeOperation to use, or null to clear the cache and redraw it.
	 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#compositing">
	 * whatwg spec on compositing</a>.
	 **/
	p.updateCache = function(compositeOperation) {
		var cacheCanvas = this.cacheCanvas;
		if (!cacheCanvas) { throw "cache() must be called before updateCache()"; }
		var scale = this._cacheScale, offX = this._cacheOffsetX*scale, offY = this._cacheOffsetY*scale;
		var w = this._cacheWidth, h = this._cacheHeight, ctx = cacheCanvas.getContext("2d");
		
		var fBounds = this._getFilterBounds();
		offX += (this._filterOffsetX = fBounds.x);
		offY += (this._filterOffsetY = fBounds.y);
		
		w = Math.ceil(w*scale) + fBounds.width;
		h = Math.ceil(h*scale) + fBounds.height;
		if (w != cacheCanvas.width || h != cacheCanvas.height) {
			// TODO: it would be nice to preserve the content if there is a compositeOperation.
			cacheCanvas.width = w;
			cacheCanvas.height = h;
		} else if (!compositeOperation) {
			ctx.clearRect(0, 0, w+1, h+1);
		}
		
		ctx.save();
		ctx.globalCompositeOperation = compositeOperation;
		ctx.setTransform(scale, 0, 0, scale, -offX, -offY);
		this.draw(ctx, true);
		// TODO: filters and cache scale don't play well together at present.
		this._applyFilters();
		ctx.restore();
		this.cacheID = DisplayObject._nextCacheID++;
	};

	/**
	 * Clears the current cache. See {{#crossLink "DisplayObject/cache"}}{{/crossLink}} for more information.
	 * @method uncache
	 **/
	p.uncache = function() {
		this._cacheDataURL = this.cacheCanvas = null;
		this.cacheID = this._cacheOffsetX = this._cacheOffsetY = this._filterOffsetX = this._filterOffsetY = 0;
		this._cacheScale = 1;
	};
	
	/**
	 * Returns a data URL for the cache, or null if this display object is not cached.
	 * Uses cacheID to ensure a new data URL is not generated if the cache has not changed.
	 * @method getCacheDataURL
	 * @return {String} The image data url for the cache.
	 **/
	p.getCacheDataURL = function() {
		if (!this.cacheCanvas) { return null; }
		if (this.cacheID != this._cacheDataURLID) { this._cacheDataURL = this.cacheCanvas.toDataURL(); }
		return this._cacheDataURL;
	};

	/**
	 * Transforms the specified x and y position from the coordinate space of the display object
	 * to the global (stage) coordinate space. For example, this could be used to position an HTML label
	 * over a specific point on a nested display object. Returns a Point instance with x and y properties
	 * correlating to the transformed coordinates on the stage.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.x = 300;
	 *      displayObject.y = 200;
	 *      stage.addChild(displayObject);
	 *      var point = myDisplayObject.localToGlobal(100, 100);
	 *      // Results in x=400, y=300
	 *
	 * @method localToGlobal
	 * @param {Number} x The x position in the source display object to transform.
	 * @param {Number} y The y position in the source display object to transform.
	 * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. 
	 * @return {Point} A Point instance with x and y properties correlating to the transformed coordinates
	 * on the stage.
	 **/
	p.localToGlobal = function(x, y, pt) {
		return this.getConcatenatedMatrix(this._props.matrix).transformPoint(x,y, pt||new createjs.Point());
	};

	/**
	 * Transforms the specified x and y position from the global (stage) coordinate space to the
	 * coordinate space of the display object. For example, this could be used to determine
	 * the current mouse position within the display object. Returns a Point instance with x and y properties
	 * correlating to the transformed position in the display object's coordinate space.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.x = 300;
	 *      displayObject.y = 200;
	 *      stage.addChild(displayObject);
	 *      var point = myDisplayObject.globalToLocal(100, 100);
	 *      // Results in x=-200, y=-100
	 *
	 * @method globalToLocal
	 * @param {Number} x The x position on the stage to transform.
	 * @param {Number} y The y position on the stage to transform.
	 * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. 
	 * @return {Point} A Point instance with x and y properties correlating to the transformed position in the
	 * display object's coordinate space.
	 **/
	p.globalToLocal = function(x, y, pt) {
		return this.getConcatenatedMatrix(this._props.matrix).invert().transformPoint(x,y, pt||new createjs.Point());
	};

	/**
	 * Transforms the specified x and y position from the coordinate space of this display object to the coordinate
	 * space of the target display object. Returns a Point instance with x and y properties correlating to the
	 * transformed position in the target's coordinate space. Effectively the same as using the following code with
	 * {{#crossLink "DisplayObject/localToGlobal"}}{{/crossLink}} and {{#crossLink "DisplayObject/globalToLocal"}}{{/crossLink}}.
	 *
	 *      var pt = this.localToGlobal(x, y);
	 *      pt = target.globalToLocal(pt.x, pt.y);
	 *
	 * @method localToLocal
	 * @param {Number} x The x position in the source display object to transform.
	 * @param {Number} y The y position on the source display object to transform.
	 * @param {DisplayObject} target The target display object to which the coordinates will be transformed.
	 * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. 
	 * @return {Point} Returns a Point instance with x and y properties correlating to the transformed position
	 * in the target's coordinate space.
	 **/
	p.localToLocal = function(x, y, target, pt) {
		pt = this.localToGlobal(x, y, pt);
		return target.globalToLocal(pt.x, pt.y, pt);
	};

	/**
	 * Shortcut method to quickly set the transform properties on the display object. All parameters are optional.
	 * Omitted parameters will have the default value set.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.setTransform(100, 100, 2, 2);
	 *
	 * @method setTransform
	 * @param {Number} [x=0] The horizontal translation (x position) in pixels
	 * @param {Number} [y=0] The vertical translation (y position) in pixels
	 * @param {Number} [scaleX=1] The horizontal scale, as a percentage of 1
	 * @param {Number} [scaleY=1] the vertical scale, as a percentage of 1
	 * @param {Number} [rotation=0] The rotation, in degrees
	 * @param {Number} [skewX=0] The horizontal skew factor
	 * @param {Number} [skewY=0] The vertical skew factor
	 * @param {Number} [regX=0] The horizontal registration point in pixels
	 * @param {Number} [regY=0] The vertical registration point in pixels
	 * @return {DisplayObject} Returns this instance. Useful for chaining commands.
	 * @chainable
	*/
	p.setTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
		this.x = x || 0;
		this.y = y || 0;
		this.scaleX = scaleX == null ? 1 : scaleX;
		this.scaleY = scaleY == null ? 1 : scaleY;
		this.rotation = rotation || 0;
		this.skewX = skewX || 0;
		this.skewY = skewY || 0;
		this.regX = regX || 0;
		this.regY = regY || 0;
		return this;
	};
	
	/**
	 * Returns a matrix based on this object's current transform.
	 * @method getMatrix
	 * @param {Matrix2D} matrix Optional. A Matrix2D object to populate with the calculated values. If null, a new
	 * Matrix object is returned.
	 * @return {Matrix2D} A matrix representing this display object's transform.
	 **/
	p.getMatrix = function(matrix) {
		var o = this, mtx = matrix&&matrix.identity() || new createjs.Matrix2D();
		return o.transformMatrix ?  mtx.copy(o.transformMatrix) : mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);
	};
	
	/**
	 * Generates a Matrix2D object representing the combined transform of the display object and all of its
	 * parent Containers up to the highest level ancestor (usually the {{#crossLink "Stage"}}{{/crossLink}}). This can
	 * be used to transform positions between coordinate spaces, such as with {{#crossLink "DisplayObject/localToGlobal"}}{{/crossLink}}
	 * and {{#crossLink "DisplayObject/globalToLocal"}}{{/crossLink}}.
	 * @method getConcatenatedMatrix
	 * @param {Matrix2D} [matrix] A {{#crossLink "Matrix2D"}}{{/crossLink}} object to populate with the calculated values.
	 * If null, a new Matrix2D object is returned.
	 * @return {Matrix2D} The combined matrix.
	 **/
	p.getConcatenatedMatrix = function(matrix) {
		var o = this, mtx = this.getMatrix(matrix);
		while (o = o.parent) {
			mtx.prependMatrix(o.getMatrix(o._props.matrix));
		}
		return mtx;
	};
	
	/**
	 * Generates a DisplayProps object representing the combined display properties of the  object and all of its
	 * parent Containers up to the highest level ancestor (usually the {{#crossLink "Stage"}}{{/crossLink}}).
	 * @method getConcatenatedDisplayProps
	 * @param {DisplayProps} [props] A {{#crossLink "DisplayProps"}}{{/crossLink}} object to populate with the calculated values.
	 * If null, a new DisplayProps object is returned.
	 * @return {DisplayProps} The combined display properties.
	 **/
	p.getConcatenatedDisplayProps = function(props) {
		props = props ? props.identity() : new createjs.DisplayProps();
		var o = this, mtx = o.getMatrix(props.matrix); 
		do {
			props.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation);
			
			// we do this to avoid problems with the matrix being used for both operations when o._props.matrix is passed in as the props param.
			// this could be simplified (ie. just done as part of the prepend above) if we switched to using a pool.
			if (o != this) { mtx.prependMatrix(o.getMatrix(o._props.matrix)); }
		} while (o = o.parent);
		return props;
	};

	/**
	 * Tests whether the display object intersects the specified point in local coordinates (ie. draws a pixel with alpha > 0 at
	 * the specified position). This ignores the alpha, shadow, hitArea, mask, and compositeOperation of the display object.
	 *
	 * <h4>Example</h4>
	 *
	 *      stage.addEventListener("stagemousedown", handleMouseDown);
	 *      function handleMouseDown(event) {
	 *          var hit = myShape.hitTest(event.stageX, event.stageY);
	 *      }
	 *
	 * Please note that shape-to-shape collision is not currently supported by EaselJS.
	 * @method hitTest
	 * @param {Number} x The x position to check in the display object's local coordinates.
	 * @param {Number} y The y position to check in the display object's local coordinates.
	 * @return {Boolean} A Boolean indicating whether a visible portion of the DisplayObject intersect the specified
	 * local Point.
	*/
	p.hitTest = function(x, y) {
		var ctx = DisplayObject._hitTestContext;
		ctx.setTransform(1, 0, 0, 1, -x, -y);
		this.draw(ctx);

		var hit = this._testHit(ctx);
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		ctx.clearRect(0, 0, 2, 2);
		return hit;
	};
	
	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * <h4>Example</h4>
	 *
	 *      var myGraphics = new createjs.Graphics().beginFill("#ff0000").drawCircle(0, 0, 25);
	 *      var shape = stage.addChild(new Shape()).set({graphics:myGraphics, x:100, y:100, alpha:0.5});
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the DisplayObject instance.
	 * @return {DisplayObject} Returns the instance the method is called on (useful for chaining calls.)
	 * @chainable
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};
	
	/**
	 * Returns a rectangle representing this object's bounds in its local coordinate system (ie. with no transformation).
	 * Objects that have been cached will return the bounds of the cache.
	 * 
	 * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use 
	 * {{#crossLink "DisplayObject/setBounds"}}{{/crossLink}} so that they are included when calculating Container
	 * bounds.
	 * 
	 * <table>
	 * 	<tr><td><b>All</b></td><td>
	 * 		All display objects support setting bounds manually using setBounds(). Likewise, display objects that
	 * 		have been cached using cache() will return the bounds of their cache. Manual and cache bounds will override
	 * 		the automatic calculations listed below.
	 * 	</td></tr>
	 * 	<tr><td><b>Bitmap</b></td><td>
	 * 		Returns the width and height of the sourceRect (if specified) or image, extending from (x=0,y=0).
	 * 	</td></tr>
	 * 	<tr><td><b>Sprite</b></td><td>
	 * 		Returns the bounds of the current frame. May have non-zero x/y if a frame registration point was specified
	 * 		in the spritesheet data. See also {{#crossLink "SpriteSheet/getFrameBounds"}}{{/crossLink}}
	 * 	</td></tr>
	 * 	<tr><td><b>Container</b></td><td>
	 * 		Returns the aggregate (combined) bounds of all children that return a non-null value from getBounds().
	 * 	</td></tr>
	 * 	<tr><td><b>Shape</b></td><td>
	 * 		Does not currently support automatic bounds calculations. Use setBounds() to manually define bounds.
	 * 	</td></tr>
	 * 	<tr><td><b>Text</b></td><td>
	 * 		Returns approximate bounds. Horizontal values (x/width) are quite accurate, but vertical values (y/height) are
	 * 		not, especially when using textBaseline values other than "top".
	 * 	</td></tr>
	 * 	<tr><td><b>BitmapText</b></td><td>
	 * 		Returns approximate bounds. Values will be more accurate if spritesheet frame registration points are close
	 * 		to (x=0,y=0).
	 * 	</td></tr>
	* </table>
	 * 
	 * Bounds can be expensive to calculate for some objects (ex. text, or containers with many children), and
	 * are recalculated each time you call getBounds(). You can prevent recalculation on static objects by setting the
	 * bounds explicitly:
	 * 
	 * 	var bounds = obj.getBounds();
	 * 	obj.setBounds(bounds.x, bounds.y, bounds.width, bounds.height);
	 * 	// getBounds will now use the set values, instead of recalculating
	 * 
	 * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its
	 * values if you need to retain it.
	 * 
	 * 	var myBounds = obj.getBounds().clone();
	 * 	// OR:
	 * 	myRect.copy(obj.getBounds());
	 * 
	 * @method getBounds
	 * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this
	 * object.
	 **/
	p.getBounds = function() {
		if (this._bounds) { return this._rectangle.copy(this._bounds); }
		var cacheCanvas = this.cacheCanvas;
		if (cacheCanvas) {
			var scale = this._cacheScale;
			return this._rectangle.setValues(this._cacheOffsetX, this._cacheOffsetY, cacheCanvas.width/scale, cacheCanvas.height/scale);
		}
		return null;
	};
	
	/**
	 * Returns a rectangle representing this object's bounds in its parent's coordinate system (ie. with transformations applied).
	 * Objects that have been cached will return the transformed bounds of the cache.
	 * 
	 * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use 
	 * {{#crossLink "DisplayObject/setBounds"}}{{/crossLink}} so that they are included when calculating Container
	 * bounds.
	 * 
	 * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its
	 * values if you need to retain it.
	 * 
	 * Container instances calculate aggregate bounds for all children that return bounds via getBounds.
	 * @method getTransformedBounds
	 * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this object.
	 **/
	p.getTransformedBounds = function() {
		return this._getBounds();
	};
	
	/**
	 * Allows you to manually specify the bounds of an object that either cannot calculate their own bounds (ex. Shape &
	 * Text) for future reference, or so the object can be included in Container bounds. Manually set bounds will always
	 * override calculated bounds.
	 * 
	 * The bounds should be specified in the object's local (untransformed) coordinates. For example, a Shape instance
	 * with a 25px radius circle centered at 0,0 would have bounds of (-25, -25, 50, 50).
	 * @method setBounds
	 * @param {Number} x The x origin of the bounds. Pass null to remove the manual bounds.
	 * @param {Number} y The y origin of the bounds.
	 * @param {Number} width The width of the bounds.
	 * @param {Number} height The height of the bounds.
	 **/
	p.setBounds = function(x, y, width, height) {
		if (x == null) { this._bounds = x; }
		this._bounds = (this._bounds || new createjs.Rectangle()).setValues(x, y, width, height);
	};

	/**
	 * Returns a clone of this DisplayObject. Some properties that are specific to this instance's current context are
	 * reverted to their defaults (for example .parent). Caches are not maintained across clones, and some elements
	 * are copied by reference (masks, individual filter instances, hit area)
	 * @method clone
	 * @return {DisplayObject} A clone of the current DisplayObject instance.
	 **/
	p.clone = function() {
		return this._cloneProps(new DisplayObject());
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[DisplayObject (name="+  this.name +")]";
	};


// private methods:
	// separated so it can be used more easily in subclasses:
	/**
	 * @method _cloneProps
	 * @param {DisplayObject} o The DisplayObject instance which will have properties from the current DisplayObject
	 * instance copied into.
	 * @return {DisplayObject} o
	 * @protected
	 **/
	p._cloneProps = function(o) {
		o.alpha = this.alpha;
		o.mouseEnabled = this.mouseEnabled;
		o.tickEnabled = this.tickEnabled;
		o.name = this.name;
		o.regX = this.regX;
		o.regY = this.regY;
		o.rotation = this.rotation;
		o.scaleX = this.scaleX;
		o.scaleY = this.scaleY;
		o.shadow = this.shadow;
		o.skewX = this.skewX;
		o.skewY = this.skewY;
		o.visible = this.visible;
		o.x  = this.x;
		o.y = this.y;
		o.compositeOperation = this.compositeOperation;
		o.snapToPixel = this.snapToPixel;
		o.filters = this.filters==null?null:this.filters.slice(0);
		o.mask = this.mask;
		o.hitArea = this.hitArea;
		o.cursor = this.cursor;
		o._bounds = this._bounds;
		return o;
	};

	/**
	 * @method _applyShadow
	 * @protected
	 * @param {CanvasRenderingContext2D} ctx
	 * @param {Shadow} shadow
	 **/
	p._applyShadow = function(ctx, shadow) {
		shadow = shadow || Shadow.identity;
		ctx.shadowColor = shadow.color;
		ctx.shadowOffsetX = shadow.offsetX;
		ctx.shadowOffsetY = shadow.offsetY;
		ctx.shadowBlur = shadow.blur;
	};
	
	
	/**
	 * @method _tick
	 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
	 * @protected
	 **/
	p._tick = function(evtObj) {
		// because tick can be really performance sensitive, check for listeners before calling dispatchEvent.
		var ls = this._listeners;
		if (ls && ls["tick"]) {
			// reset & reuse the event object to avoid construction / GC costs:
			evtObj.target = null;
			evtObj.propagationStopped = evtObj.immediatePropagationStopped = false;
			this.dispatchEvent(evtObj);
		}
	};

	/**
	 * @method _testHit
	 * @protected
	 * @param {CanvasRenderingContext2D} ctx
	 * @return {Boolean}
	 **/
	p._testHit = function(ctx) {
		try {
			var hit = ctx.getImageData(0, 0, 1, 1).data[3] > 1;
		} catch (e) {
			if (!DisplayObject.suppressCrossDomainErrors) {
				throw "An error has occurred. This is most likely due to security restrictions on reading canvas pixel data with local or cross-domain images.";
			}
		}
		return hit;
	};

	/**
	 * @method _applyFilters
	 * @protected
	 **/
	p._applyFilters = function() {
		if (!this.filters || this.filters.length == 0 || !this.cacheCanvas) { return; }
		var l = this.filters.length;
		var ctx = this.cacheCanvas.getContext("2d");
		var w = this.cacheCanvas.width;
		var h = this.cacheCanvas.height;
		for (var i=0; i<l; i++) {
			this.filters[i].applyFilter(ctx, 0, 0, w, h);
		}
	};
	
	/**
	 * @method _getFilterBounds
	 * @return {Rectangle}
	 * @protected
	 **/
	p._getFilterBounds = function(rect) {
		var l, filters = this.filters, bounds = this._rectangle.setValues(0,0,0,0);
		if (!filters || !(l=filters.length)) { return bounds; }
		
		for (var i=0; i<l; i++) {
			var f = this.filters[i];
			f.getBounds&&f.getBounds(bounds);
		}
		return bounds;
	};
	
	/**
	 * @method _getBounds
	 * @param {Matrix2D} matrix
	 * @param {Boolean} ignoreTransform If true, does not apply this object's transform.
	 * @return {Rectangle}
	 * @protected
	 **/
	p._getBounds = function(matrix, ignoreTransform){
		return this._transformBounds(this.getBounds(), matrix, ignoreTransform);
	};
	
	/**
	 * @method _transformBounds
	 * @param {Rectangle} bounds
	 * @param {Matrix2D} matrix
	 * @param {Boolean} ignoreTransform
	 * @return {Rectangle}
	 * @protected
	 **/
	p._transformBounds = function(bounds, matrix, ignoreTransform) {
		if (!bounds) { return bounds; }
		var x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height, mtx = this._props.matrix;
		mtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);
		
		if (x || y) { mtx.appendTransform(0,0,1,1,0,0,0,-x,-y); } // TODO: simplify this.
		if (matrix) { mtx.prependMatrix(matrix); }
		
		var x_a = width*mtx.a, x_b = width*mtx.b;
		var y_c = height*mtx.c, y_d = height*mtx.d;
		var tx = mtx.tx, ty = mtx.ty;
		
		var minX = tx, maxX = tx, minY = ty, maxY = ty;

		if ((x = x_a + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }
		if ((x = x_a + y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }
		if ((x = y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }
		
		if ((y = x_b + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }
		if ((y = x_b + y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }
		if ((y = y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }
		
		return bounds.setValues(minX, minY, maxX-minX, maxY-minY);
	};
	
	/**
	 * Indicates whether the display object has any mouse event listeners or a cursor.
	 * @method _isMouseOpaque
	 * @return {Boolean}
	 * @protected
	 **/
	p._hasMouseEventListener = function() {
		var evts = DisplayObject._MOUSE_EVENTS;
		for (var i= 0, l=evts.length; i<l; i++) {
			if (this.hasEventListener(evts[i])) { return true; }
		}
		return !!this.cursor;
	};

	createjs.DisplayObject = createjs.promote(DisplayObject, "EventDispatcher");
}());

//##############################################################################
// Container.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";
	

// constructor:
/**
 * A Container is a nestable display list that allows you to work with compound display elements. For  example you could
 * group arm, leg, torso and head {{#crossLink "Bitmap"}}{{/crossLink}} instances together into a Person Container, and
 * transform them as a group, while still being able to move the individual parts relative to each other. Children of
 * containers have their <code>transform</code> and <code>alpha</code> properties concatenated with their parent
 * Container.
 *
 * For example, a {{#crossLink "Shape"}}{{/crossLink}} with x=100 and alpha=0.5, placed in a Container with <code>x=50</code>
 * and <code>alpha=0.7</code> will be rendered to the canvas at <code>x=150</code> and <code>alpha=0.35</code>.
 * Containers have some overhead, so you generally shouldn't create a Container to hold a single child.
 *
 * <h4>Example</h4>
 *
 *      var container = new createjs.Container();
 *      container.addChild(bitmapInstance, shapeInstance);
 *      container.x = 100;
 *
 * @class Container
 * @extends DisplayObject
 * @constructor
 **/
	function Container() {
		this.DisplayObject_constructor();
		
	// public properties:
		/**
		 * The array of children in the display list. You should usually use the child management methods such as
		 * {{#crossLink "Container/addChild"}}{{/crossLink}}, {{#crossLink "Container/removeChild"}}{{/crossLink}},
		 * {{#crossLink "Container/swapChildren"}}{{/crossLink}}, etc, rather than accessing this directly, but it is
		 * included for advanced uses.
		 * @property children
		 * @type Array
		 * @default null
		 **/
		this.children = [];
		
		/**
		 * Indicates whether the children of this container are independently enabled for mouse/pointer interaction.
		 * If false, the children will be aggregated under the container - for example, a click on a child shape would
		 * trigger a click event on the container.
		 * @property mouseChildren
		 * @type Boolean
		 * @default true
		 **/
		this.mouseChildren = true;
		
		/**
		 * If false, the tick will not be propagated to children of this Container. This can provide some performance benefits.
		 * In addition to preventing the "tick" event from being dispatched, it will also prevent tick related updates
		 * on some display objects (ex. Sprite & MovieClip frame advancing, DOMElement visibility handling).
		 * @property tickChildren
		 * @type Boolean
		 * @default true
		 **/
		this.tickChildren = true;
	}
	var p = createjs.extend(Container, createjs.DisplayObject);
	
	
// getter / setters:
	/**
	 * Use the {{#crossLink "Container/numChildren:property"}}{{/crossLink}} property instead.
	 * @method getNumChildren
	 * @return {Number}
	 * @deprecated
	 **/
	p.getNumChildren = function() {
		return this.children.length;
	};

	/**
	 * Returns the number of children in the container.
	 * @property numChildren
	 * @type {Number}
	 * @readonly
	 **/
	try {
		Object.defineProperties(p, {
			numChildren: { get: p.getNumChildren }
		});
	} catch (e) {}
	

// public methods:
	/**
	 * Constructor alias for backwards compatibility. This method will be removed in future versions.
	 * Subclasses should be updated to use {{#crossLink "Utility Methods/extends"}}{{/crossLink}}.
	 * @method initialize
	 * @deprecated in favour of `createjs.promote()`
	 **/
	p.initialize = Container; // TODO: deprecated.
	
	/**
	 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
	 **/
	p.isVisible = function() {
		var hasContent = this.cacheCanvas || this.children.length;
		return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
	};

	/**
	 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
	 * Returns true if the draw was handled (useful for overriding functionality).
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache.
	 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
	 * into itself).
	 **/
	p.draw = function(ctx, ignoreCache) {
		if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
		
		// this ensures we don't have issues with display list changes that occur during a draw:
		var list = this.children.slice();
		for (var i=0,l=list.length; i<l; i++) {
			var child = list[i];
			if (!child.isVisible()) { continue; }
			
			// draw the child:
			ctx.save();
			child.updateContext(ctx);
			child.draw(ctx);
			ctx.restore();
		}
		return true;
	};
	
	/**
	 * Adds a child to the top of the display list.
	 *
	 * <h4>Example</h4>
	 *
	 * 		container.addChild(bitmapInstance);
	 *
	 * You can also add multiple children at once:
	 *
	 * 		container.addChild(bitmapInstance, shapeInstance, textInstance);
	 *
	 * @method addChild
	 * @param {DisplayObject} child The display object to add.
	 * @return {DisplayObject} The child that was added, or the last child if multiple children were added.
	 **/
	p.addChild = function(child) {
		if (child == null) { return child; }
		var l = arguments.length;
		if (l > 1) {
			for (var i=0; i<l; i++) { this.addChild(arguments[i]); }
			return arguments[l-1];
		}
		if (child.parent) { child.parent.removeChild(child); }
		child.parent = this;
		this.children.push(child);
		child.dispatchEvent("added");
		return child;
	};

	/**
	 * Adds a child to the display list at the specified index, bumping children at equal or greater indexes up one, and
	 * setting its parent to this Container.
	 *
	 * <h4>Example</h4>
	 *
	 *      addChildAt(child1, index);
	 *
	 * You can also add multiple children, such as:
	 *
	 *      addChildAt(child1, child2, ..., index);
	 *
	 * The index must be between 0 and numChildren. For example, to add myShape under otherShape in the display list,
	 * you could use:
	 *
	 *      container.addChildAt(myShape, container.getChildIndex(otherShape));
	 *
	 * This would also bump otherShape's index up by one. Fails silently if the index is out of range.
	 *
	 * @method addChildAt
	 * @param {DisplayObject} child The display object to add.
	 * @param {Number} index The index to add the child at.
	 * @return {DisplayObject} Returns the last child that was added, or the last child if multiple children were added.
	 **/
	p.addChildAt = function(child, index) {
		var l = arguments.length;
		var indx = arguments[l-1]; // can't use the same name as the index param or it replaces arguments[1]
		if (indx < 0 || indx > this.children.length) { return arguments[l-2]; }
		if (l > 2) {
			for (var i=0; i<l-1; i++) { this.addChildAt(arguments[i], indx+i); }
			return arguments[l-2];
		}
		if (child.parent) { child.parent.removeChild(child); }
		child.parent = this;
		this.children.splice(index, 0, child);
		child.dispatchEvent("added");
		return child;
	};

	/**
	 * Removes the specified child from the display list. Note that it is faster to use removeChildAt() if the index is
	 * already known.
	 *
	 * <h4>Example</h4>
	 *
	 *      container.removeChild(child);
	 *
	 * You can also remove multiple children:
	 *
	 *      removeChild(child1, child2, ...);
	 *
	 * Returns true if the child (or children) was removed, or false if it was not in the display list.
	 * @method removeChild
	 * @param {DisplayObject} child The child to remove.
	 * @return {Boolean} true if the child (or children) was removed, or false if it was not in the display list.
	 **/
	p.removeChild = function(child) {
		var l = arguments.length;
		if (l > 1) {
			var good = true;
			for (var i=0; i<l; i++) { good = good && this.removeChild(arguments[i]); }
			return good;
		}
		return this.removeChildAt(createjs.indexOf(this.children, child));
	};

	/**
	 * Removes the child at the specified index from the display list, and sets its parent to null.
	 *
	 * <h4>Example</h4>
	 *
	 *      container.removeChildAt(2);
	 *
	 * You can also remove multiple children:
	 *
	 *      container.removeChild(2, 7, ...)
	 *
	 * Returns true if the child (or children) was removed, or false if any index was out of range.
	 * @method removeChildAt
	 * @param {Number} index The index of the child to remove.
	 * @return {Boolean} true if the child (or children) was removed, or false if any index was out of range.
	 **/
	p.removeChildAt = function(index) {
		var l = arguments.length;
		if (l > 1) {
			var a = [];
			for (var i=0; i<l; i++) { a[i] = arguments[i]; }
			a.sort(function(a, b) { return b-a; });
			var good = true;
			for (var i=0; i<l; i++) { good = good && this.removeChildAt(a[i]); }
			return good;
		}
		if (index < 0 || index > this.children.length-1) { return false; }
		var child = this.children[index];
		if (child) { child.parent = null; }
		this.children.splice(index, 1);
		child.dispatchEvent("removed");
		return true;
	};

	/**
	 * Removes all children from the display list.
	 *
	 * <h4>Example</h4>
	 *
	 * 	container.removeAllChildren();
	 *
	 * @method removeAllChildren
	 **/
	p.removeAllChildren = function() {
		var kids = this.children;
		while (kids.length) { this.removeChildAt(0); }
	};

	/**
	 * Returns the child at the specified index.
	 *
	 * <h4>Example</h4>
	 *
	 *      container.getChildAt(2);
	 *
	 * @method getChildAt
	 * @param {Number} index The index of the child to return.
	 * @return {DisplayObject} The child at the specified index. Returns null if there is no child at the index.
	 **/
	p.getChildAt = function(index) {
		return this.children[index];
	};
	
	/**
	 * Returns the child with the specified name.
	 * @method getChildByName
	 * @param {String} name The name of the child to return.
	 * @return {DisplayObject} The child with the specified name.
	 **/
	p.getChildByName = function(name) {
		var kids = this.children;
		for (var i=0,l=kids.length;i<l;i++) {
			if(kids[i].name == name) { return kids[i]; }
		}
		return null;
	};

	/**
	 * Performs an array sort operation on the child list.
	 *
	 * <h4>Example: Display children with a higher y in front.</h4>
	 * 
	 *      var sortFunction = function(obj1, obj2, options) {
	 *          if (obj1.y > obj2.y) { return 1; }
	 *          if (obj1.y < obj2.y) { return -1; }
	 *          return 0;
	 *      }
	 *      container.sortChildren(sortFunction);
	 *
	 * @method sortChildren
	 * @param {Function} sortFunction the function to use to sort the child list. See JavaScript's <code>Array.sort</code>
	 * documentation for details.
	 **/
	p.sortChildren = function(sortFunction) {
		this.children.sort(sortFunction);
	};

	/**
	 * Returns the index of the specified child in the display list, or -1 if it is not in the display list.
	 *
	 * <h4>Example</h4>
	 *
	 *      var index = container.getChildIndex(child);
	 *
	 * @method getChildIndex
	 * @param {DisplayObject} child The child to return the index of.
	 * @return {Number} The index of the specified child. -1 if the child is not found.
	 **/
	p.getChildIndex = function(child) {
		return createjs.indexOf(this.children, child);
	};
	
	/**
	 * Swaps the children at the specified indexes. Fails silently if either index is out of range.
	 * @method swapChildrenAt
	 * @param {Number} index1
	 * @param {Number} index2
	 **/
	p.swapChildrenAt = function(index1, index2) {
		var kids = this.children;
		var o1 = kids[index1];
		var o2 = kids[index2];
		if (!o1 || !o2) { return; }
		kids[index1] = o2;
		kids[index2] = o1;
	};
	
	/**
	 * Swaps the specified children's depth in the display list. Fails silently if either child is not a child of this
	 * Container.
	 * @method swapChildren
	 * @param {DisplayObject} child1
	 * @param {DisplayObject} child2
	 **/
	p.swapChildren = function(child1, child2) {
		var kids = this.children;
		var index1,index2;
		for (var i=0,l=kids.length;i<l;i++) {
			if (kids[i] == child1) { index1 = i; }
			if (kids[i] == child2) { index2 = i; }
			if (index1 != null && index2 != null) { break; }
		}
		if (i==l) { return; } // TODO: throw error?
		kids[index1] = child2;
		kids[index2] = child1;
	};
	
	/**
	 * Changes the depth of the specified child. Fails silently if the child is not a child of this container, or the index is out of range.
	 * @param {DisplayObject} child
	 * @param {Number} index  
	 * @method setChildIndex
	 **/
	p.setChildIndex = function(child, index) {
		var kids = this.children, l=kids.length;
		if (child.parent != this || index < 0 || index >= l) { return; }
		for (var i=0;i<l;i++) {
			if (kids[i] == child) { break; }
		}
		if (i==l || i == index) { return; }
		kids.splice(i,1);
		kids.splice(index,0,child);
	};

	/**
	 * Returns true if the specified display object either is this container or is a descendent (child, grandchild, etc)
	 * of this container.
	 * @method contains
	 * @param {DisplayObject} child The DisplayObject to be checked.
	 * @return {Boolean} true if the specified display object either is this container or is a descendent.
	 **/
	p.contains = function(child) {
		while (child) {
			if (child == this) { return true; }
			child = child.parent;
		}
		return false;
	};

	/**
	 * Tests whether the display object intersects the specified local point (ie. draws a pixel with alpha > 0 at the
	 * specified position). This ignores the alpha, shadow and compositeOperation of the display object, and all
	 * transform properties including regX/Y.
	 * @method hitTest
	 * @param {Number} x The x position to check in the display object's local coordinates.
	 * @param {Number} y The y position to check in the display object's local coordinates.
	 * @return {Boolean} A Boolean indicating whether there is a visible section of a DisplayObject that overlaps the specified
	 * coordinates.
	 **/
	p.hitTest = function(x, y) {
		// TODO: optimize to use the fast cache check where possible.
		return (this.getObjectUnderPoint(x, y) != null);
	};

	/**
	 * Returns an array of all display objects under the specified coordinates that are in this container's display
	 * list. This routine ignores any display objects with {{#crossLink "DisplayObject/mouseEnabled:property"}}{{/crossLink}}
	 * set to `false`. The array will be sorted in order of visual depth, with the top-most display object at index 0.
	 * This uses shape based hit detection, and can be an expensive operation to run, so it is best to use it carefully.
	 * For example, if testing for objects under the mouse, test on tick (instead of on {{#crossLink "DisplayObject/mousemove:event"}}{{/crossLink}}),
	 * and only if the mouse's position has changed.
	 * 
	 * <ul>
	 *     <li>By default (mode=0) this method evaluates all display objects.</li>
	 *     <li>By setting the `mode` parameter to `1`, the {{#crossLink "DisplayObject/mouseEnabled:property"}}{{/crossLink}}
	 * 		and {{#crossLink "mouseChildren:property"}}{{/crossLink}} properties will be respected.</li>
	 * 	   <li>Setting the `mode` to `2` additionally excludes display objects that do not have active mouse event
	 * 	   	listeners or a {{#crossLink "DisplayObject:cursor:property"}}{{/crossLink}} property. That is, only objects
	 * 	   	that would normally intercept mouse interaction will be included. This can significantly improve performance
	 * 	   	in some cases by reducing the number of display objects that need to be tested.</li>
	 * </li>
	 * 
	 * This method accounts for both {{#crossLink "DisplayObject/hitArea:property"}}{{/crossLink}} and {{#crossLink "DisplayObject/mask:property"}}{{/crossLink}}.
	 * @method getObjectsUnderPoint
	 * @param {Number} x The x position in the container to test.
	 * @param {Number} y The y position in the container to test.
	 * @param {Number} [mode=0] The mode to use to determine which display objects to include. 0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.
	 * @return {Array} An Array of DisplayObjects under the specified coordinates.
	 **/
	p.getObjectsUnderPoint = function(x, y, mode) {
		var arr = [];
		var pt = this.localToGlobal(x, y);
		this._getObjectsUnderPoint(pt.x, pt.y, arr, mode>0, mode==1);
		return arr;
	};

	/**
	 * Similar to {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}}, but returns only the top-most display
	 * object. This runs significantly faster than <code>getObjectsUnderPoint()</code>, but is still potentially an expensive
	 * operation. See {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}} for more information.
	 * @method getObjectUnderPoint
	 * @param {Number} x The x position in the container to test.
	 * @param {Number} y The y position in the container to test.
	 * @param {Number} mode The mode to use to determine which display objects to include.  0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.
	 * @return {DisplayObject} The top-most display object under the specified coordinates.
	 **/
	p.getObjectUnderPoint = function(x, y, mode) {
		var pt = this.localToGlobal(x, y);
		return this._getObjectsUnderPoint(pt.x, pt.y, null, mode>0, mode==1);
	};
	
	/**
	 * Docced in superclass.
	 */
	p.getBounds = function() {
		return this._getBounds(null, true);
	};
	
	
	/**
	 * Docced in superclass.
	 */
	p.getTransformedBounds = function() {
		return this._getBounds();
	};

	/**
	 * Returns a clone of this Container. Some properties that are specific to this instance's current context are
	 * reverted to their defaults (for example .parent).
	 * @method clone
	 * @param {Boolean} [recursive=false] If true, all of the descendants of this container will be cloned recursively. If false, the
	 * properties of the container will be cloned, but the new instance will not have any children.
	 * @return {Container} A clone of the current Container instance.
	 **/
	p.clone = function(recursive) {
		var o = this._cloneProps(new Container());
		if (recursive) { this._cloneChildren(o); }
		return o;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Container (name="+  this.name +")]";
	};


// private methods:
	/**
	 * @method _tick
	 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
	 * @protected
	 **/
	p._tick = function(evtObj) {
		if (this.tickChildren) {
			for (var i=this.children.length-1; i>=0; i--) {
				var child = this.children[i];
				if (child.tickEnabled && child._tick) { child._tick(evtObj); }
			}
		}
		this.DisplayObject__tick(evtObj);
	};
	
	/**
	 * Recursively clones all children of this container, and adds them to the target container.
	 * @method cloneChildren
	 * @protected
	 * @param {Container} o The target container.
	 **/
	p._cloneChildren = function(o) {
		if (o.children.length) { o.removeAllChildren(); }
		var arr = o.children;
		for (var i=0, l=this.children.length; i<l; i++) {
			var clone = this.children[i].clone(true);
			clone.parent = o;
			arr.push(clone);
		}
	};

	/**
	 * @method _getObjectsUnderPoint
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Array} arr
	 * @param {Boolean} mouse If true, it will respect mouse interaction properties like mouseEnabled, mouseChildren, and active listeners.
	 * @param {Boolean} activeListener If true, there is an active mouse event listener on a parent object.
	 * @param {Number} currentDepth Indicates the current depth of the search.
	 * @return {DisplayObject}
	 * @protected
	 **/
	p._getObjectsUnderPoint = function(x, y, arr, mouse, activeListener, currentDepth) {
		currentDepth = currentDepth || 0;
		if (!currentDepth && !this._testMask(this, x, y)) { return null; }
		var mtx, ctx = createjs.DisplayObject._hitTestContext;
		activeListener = activeListener || (mouse&&this._hasMouseEventListener());

		// draw children one at a time, and check if we get a hit:
		var children = this.children, l = children.length;
		for (var i=l-1; i>=0; i--) {
			var child = children[i];
			var hitArea = child.hitArea;
			if (!child.visible || (!hitArea && !child.isVisible()) || (mouse && !child.mouseEnabled)) { continue; }
			if (!hitArea && !this._testMask(child, x, y)) { continue; }
			
			// if a child container has a hitArea then we only need to check its hitArea, so we can treat it as a normal DO:
			if (!hitArea && child instanceof Container) {
				var result = child._getObjectsUnderPoint(x, y, arr, mouse, activeListener, currentDepth+1);
				if (!arr && result) { return (mouse && !this.mouseChildren) ? this : result; }
			} else {
				if (mouse && !activeListener && !child._hasMouseEventListener()) { continue; }
				
				// TODO: can we pass displayProps forward, to avoid having to calculate this backwards every time? It's kind of a mixed bag. When we're only hunting for DOs with event listeners, it may not make sense.
				var props = child.getConcatenatedDisplayProps(child._props);
				mtx = props.matrix;
				
				if (hitArea) {
					mtx.appendMatrix(hitArea.getMatrix(hitArea._props.matrix));
					props.alpha = hitArea.alpha;
				}
				
				ctx.globalAlpha = props.alpha;
				ctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);
				(hitArea||child).draw(ctx);
				if (!this._testHit(ctx)) { continue; }
				ctx.setTransform(1, 0, 0, 1, 0, 0);
				ctx.clearRect(0, 0, 2, 2);
				if (arr) { arr.push(child); }
				else { return (mouse && !this.mouseChildren) ? this : child; }
			}
		}
		return null;
	};
	
	/**
	 * @method _testMask
	 * @param {DisplayObject} target
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Boolean} Indicates whether the x/y is within the masked region.
	 * @protected
	 **/
	p._testMask = function(target, x, y) {
		var mask = target.mask;
		if (!mask || !mask.graphics || mask.graphics.isEmpty()) { return true; }
		
		var mtx = this._props.matrix, parent = target.parent;
		mtx = parent ? parent.getConcatenatedMatrix(mtx) : mtx.identity();
		mtx = mask.getMatrix(mask._props.matrix).prependMatrix(mtx);
		
		var ctx = createjs.DisplayObject._hitTestContext;
		ctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);
		
		// draw the mask as a solid fill:
		mask.graphics.drawAsPath(ctx);
		ctx.fillStyle = "#000";
		ctx.fill();
		
		if (!this._testHit(ctx)) { return false; }
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		ctx.clearRect(0, 0, 2, 2);
		
		return true;
	};
	
	/**
	 * @method _getBounds
	 * @param {Matrix2D} matrix
	 * @param {Boolean} ignoreTransform If true, does not apply this object's transform.
	 * @return {Rectangle}
	 * @protected
	 **/
	p._getBounds = function(matrix, ignoreTransform) {
		var bounds = this.DisplayObject_getBounds();
		if (bounds) { return this._transformBounds(bounds, matrix, ignoreTransform); }
		
		var mtx = this._props.matrix;
		mtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);
		if (matrix) { mtx.prependMatrix(matrix); }
		
		var l = this.children.length, rect=null;
		for (var i=0; i<l; i++) {
			var child = this.children[i];
			if (!child.visible || !(bounds = child._getBounds(mtx))) { continue; }
			if (rect) { rect.extend(bounds.x, bounds.y, bounds.width, bounds.height); }
			else { rect = bounds.clone(); }
		}
		return rect;
	};


	createjs.Container = createjs.promote(Container, "DisplayObject");
}());

//##############################################################################
// Stage.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * A stage is the root level {{#crossLink "Container"}}{{/crossLink}} for a display list. Each time its {{#crossLink "Stage/tick"}}{{/crossLink}}
	 * method is called, it will render its display list to its target canvas.
	 *
	 * <h4>Example</h4>
	 * This example creates a stage, adds a child to it, then uses {{#crossLink "Ticker"}}{{/crossLink}} to update the child
	 * and redraw the stage using {{#crossLink "Stage/update"}}{{/crossLink}}.
	 *
	 *      var stage = new createjs.Stage("canvasElementId");
	 *      var image = new createjs.Bitmap("imagePath.png");
	 *      stage.addChild(image);
	 *      createjs.Ticker.addEventListener("tick", handleTick);
	 *      function handleTick(event) {
	 *          image.x += 10;
	 *          stage.update();
	 *      }
	 *
	 * @class Stage
	 * @extends Container
	 * @constructor
	 * @param {HTMLCanvasElement | String | Object} canvas A canvas object that the Stage will render to, or the string id
	 * of a canvas object in the current document.
	 **/
	function Stage(canvas) {
		this.Container_constructor();
	
	
	// public properties:
		/**
		 * Indicates whether the stage should automatically clear the canvas before each render. You can set this to <code>false</code>
		 * to manually control clearing (for generative art, or when pointing multiple stages at the same canvas for
		 * example).
		 *
		 * <h4>Example</h4>
		 *
		 *      var stage = new createjs.Stage("canvasId");
		 *      stage.autoClear = false;
		 *
		 * @property autoClear
		 * @type Boolean
		 * @default true
		 **/
		this.autoClear = true;
	
		/**
		 * The canvas the stage will render to. Multiple stages can share a single canvas, but you must disable autoClear for all but the
		 * first stage that will be ticked (or they will clear each other's render).
		 *
		 * When changing the canvas property you must disable the events on the old canvas, and enable events on the
		 * new canvas or mouse events will not work as expected. For example:
		 *
		 *      myStage.enableDOMEvents(false);
		 *      myStage.canvas = anotherCanvas;
		 *      myStage.enableDOMEvents(true);
		 *
		 * @property canvas
		 * @type HTMLCanvasElement | Object
		 **/
		this.canvas = (typeof canvas == "string") ? document.getElementById(canvas) : canvas;
	
		/**
		 * The current mouse X position on the canvas. If the mouse leaves the canvas, this will indicate the most recent
		 * position over the canvas, and mouseInBounds will be set to false.
		 * @property mouseX
		 * @type Number
		 * @readonly
		 **/
		this.mouseX = 0;
	
		/**
		 * The current mouse Y position on the canvas. If the mouse leaves the canvas, this will indicate the most recent
		 * position over the canvas, and mouseInBounds will be set to false.
		 * @property mouseY
		 * @type Number
		 * @readonly
		 **/
		this.mouseY = 0;
	
		/**
		 * Specifies the area of the stage to affect when calling update. This can be use to selectively
		 * re-draw specific regions of the canvas. If null, the whole canvas area is drawn.
		 * @property drawRect
		 * @type {Rectangle}
		 */
		this.drawRect = null;
	
		/**
		 * Indicates whether display objects should be rendered on whole pixels. You can set the
		 * {{#crossLink "DisplayObject/snapToPixel"}}{{/crossLink}} property of
		 * display objects to false to enable/disable this behaviour on a per instance basis.
		 * @property snapToPixelEnabled
		 * @type Boolean
		 * @default false
		 **/
		this.snapToPixelEnabled = false;
	
		/**
		 * Indicates whether the mouse is currently within the bounds of the canvas.
		 * @property mouseInBounds
		 * @type Boolean
		 * @default false
		 **/
		this.mouseInBounds = false;
	
		/**
		 * If true, tick callbacks will be called on all display objects on the stage prior to rendering to the canvas.
		 * @property tickOnUpdate
		 * @type Boolean
		 * @default true
		 **/
		this.tickOnUpdate = true;
	
		/**
		 * If true, mouse move events will continue to be called when the mouse leaves the target canvas. See
		 * {{#crossLink "Stage/mouseInBounds:property"}}{{/crossLink}}, and {{#crossLink "MouseEvent"}}{{/crossLink}}
		 * x/y/rawX/rawY.
		 * @property mouseMoveOutside
		 * @type Boolean
		 * @default false
		 **/
		this.mouseMoveOutside = false;
		
		
		/**
		 * Prevents selection of other elements in the html page if the user clicks and drags, or double clicks on the canvas.
		 * This works by calling `preventDefault()` on any mousedown events (or touch equivalent) originating on the canvas.
		 * @property preventSelection
		 * @type Boolean
		 * @default true
		 **/
		this.preventSelection = true;
	
		/**
		 * The hitArea property is not supported for Stage.
		 * @property hitArea
		 * @type {DisplayObject}
		 * @default null
		 */
		 
		 
	// private properties:
		/**
		 * Holds objects with data for each active pointer id. Each object has the following properties:
		 * x, y, event, target, overTarget, overX, overY, inBounds, posEvtObj (native event that last updated position)
		 * @property _pointerData
		 * @type {Object}
		 * @private
		 */
		this._pointerData = {};
	
		/**
		 * Number of active pointers.
		 * @property _pointerCount
		 * @type {Object}
		 * @private
		 */
		this._pointerCount = 0;
	
		/**
		 * The ID of the primary pointer.
		 * @property _primaryPointerID
		 * @type {Object}
		 * @private
		 */
		this._primaryPointerID = null;
	
		/**
		 * @property _mouseOverIntervalID
		 * @protected
		 * @type Number
		 **/
		this._mouseOverIntervalID = null;
		
		/**
		 * @property _nextStage
		 * @protected
		 * @type Stage
		 **/
		this._nextStage = null;
		
		/**
		 * @property _prevStage
		 * @protected
		 * @type Stage
		 **/
		this._prevStage = null;
		
		
	// initialize:
		this.enableDOMEvents(true);
	}
	var p = createjs.extend(Stage, createjs.Container);

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// events:
	/**
	 * Dispatched when the user moves the mouse over the canvas.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event stagemousemove
	 * @since 0.6.0
	 */

	/**
	 * Dispatched when the user presses their left mouse button on the canvas. See the {{#crossLink "MouseEvent"}}{{/crossLink}}
	 * class for a listing of event properties.
	 * @event stagemousedown
	 * @since 0.6.0
	 */

	/**
	 * Dispatched when the user the user presses somewhere on the stage, then releases the mouse button anywhere that the page can detect it (this varies slightly between browsers).
	 * You can use {{#crossLink "Stage/mouseInBounds:property"}}{{/crossLink}} to check whether the mouse is currently within the stage bounds.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event stagemouseup
	 * @since 0.6.0
	 */

	/**
	 * Dispatched when the mouse moves from within the canvas area (mouseInBounds == true) to outside it (mouseInBounds == false).
	 * This is currently only dispatched for mouse input (not touch). See the {{#crossLink "MouseEvent"}}{{/crossLink}}
	 * class for a listing of event properties.
	 * @event mouseleave
	 * @since 0.7.0
	 */

	/**
	 * Dispatched when the mouse moves into the canvas area (mouseInBounds == false) from outside it (mouseInBounds == true).
	 * This is currently only dispatched for mouse input (not touch). See the {{#crossLink "MouseEvent"}}{{/crossLink}}
	 * class for a listing of event properties.
	 * @event mouseenter
	 * @since 0.7.0
	 */
	 
	/**
	 * Dispatched each update immediately before the tick event is propagated through the display list.
	 * You can call preventDefault on the event object to cancel propagating the tick event.
	 * @event tickstart
	 * @since 0.7.0
	 */
	 
	/**
	 * Dispatched each update immediately after the tick event is propagated through the display list. Does not fire if
	 * tickOnUpdate is false. Precedes the "drawstart" event.
	 * @event tickend
	 * @since 0.7.0
	 */
	 
	/**
	 * Dispatched each update immediately before the canvas is cleared and the display list is drawn to it.
	 * You can call preventDefault on the event object to cancel the draw.
	 * @event drawstart
	 * @since 0.7.0
	 */
	 
	/**
	 * Dispatched each update immediately after the display list is drawn to the canvas and the canvas context is restored.
	 * @event drawend
	 * @since 0.7.0
	 */

	 
// getter / setters:
	/**
	 * Specifies a target stage that will have mouse / touch interactions relayed to it after this stage handles them.
	 * This can be useful in cases where you have multiple layered canvases and want user interactions
	 * events to pass through. For example, this would relay mouse events from topStage to bottomStage:
	 *
	 *      topStage.nextStage = bottomStage;
	 *
	 * To disable relaying, set nextStage to null.
	 * 
	 * MouseOver, MouseOut, RollOver, and RollOut interactions are also passed through using the mouse over settings
	 * of the top-most stage, but are only processed if the target stage has mouse over interactions enabled.
	 * Considerations when using roll over in relay targets:<OL>
	 * <LI> The top-most (first) stage must have mouse over interactions enabled (via enableMouseOver)</LI>
	 * <LI> All stages that wish to participate in mouse over interaction must enable them via enableMouseOver</LI>
	 * <LI> All relay targets will share the frequency value of the top-most stage</LI>
	 * </OL>
	 * To illustrate, in this example the targetStage would process mouse over interactions at 10hz (despite passing
	 * 30 as it's desired frequency):
	 * 	topStage.nextStage = targetStage;
	 * 	topStage.enableMouseOver(10);
	 * 	targetStage.enableMouseOver(30);
	 * 
	 * If the target stage's canvas is completely covered by this stage's canvas, you may also want to disable its
	 * DOM events using:
	 * 
	 *	targetStage.enableDOMEvents(false);
	 * 
	 * @property nextStage
	 * @type {Stage}
	 **/
	p._get_nextStage = function() {
		return this._nextStage;
	};
	p._set_nextStage = function(value) {
		if (this._nextStage) { this._nextStage._prevStage = null; }
		if (value) { value._prevStage = this; }
		this._nextStage = value;
	};
	
	try {
		Object.defineProperties(p, {
			nextStage: { get: p._get_nextStage, set: p._set_nextStage }
		});
	} catch (e) {} // TODO: use Log


// public methods:
	/**
	 * Each time the update method is called, the stage will call {{#crossLink "Stage/tick"}}{{/crossLink}}
	 * unless {{#crossLink "Stage/tickOnUpdate:property"}}{{/crossLink}} is set to false,
	 * and then render the display list to the canvas.
	 *
	 * @method update
	 * @param {Object} [props] Props object to pass to `tick()`. Should usually be a {{#crossLink "Ticker"}}{{/crossLink}} event object, or similar object with a delta property.
	 **/
	p.update = function(props) {
		if (!this.canvas) { return; }
		if (this.tickOnUpdate) { this.tick(props); }
		if (this.dispatchEvent("drawstart", false, true) === false) { return; }
		createjs.DisplayObject._snapToPixelEnabled = this.snapToPixelEnabled;
		var r = this.drawRect, ctx = this.canvas.getContext("2d");
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		if (this.autoClear) {
			if (r) { ctx.clearRect(r.x, r.y, r.width, r.height); }
			else { ctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1); }
		}
		ctx.save();
		if (this.drawRect) {
			ctx.beginPath();
			ctx.rect(r.x, r.y, r.width, r.height);
			ctx.clip();
		}
		this.updateContext(ctx);
		this.draw(ctx, false);
		ctx.restore();
		this.dispatchEvent("drawend");
	};
	
	/**
	 * Propagates a tick event through the display list. This is automatically called by {{#crossLink "Stage/update"}}{{/crossLink}}
	 * unless {{#crossLink "Stage/tickOnUpdate:property"}}{{/crossLink}} is set to false.
	 *
	 * If a props object is passed to `tick()`, then all of its properties will be copied to the event object that is
	 * propagated to listeners.
	 *
	 * Some time-based features in EaselJS (for example {{#crossLink "Sprite/framerate"}}{{/crossLink}} require that
	 * a {{#crossLink "Ticker/tick:event"}}{{/crossLink}} event object (or equivalent object with a delta property) be
	 * passed as the `props` parameter to `tick()`. For example:
	 *
	 * 	Ticker.on("tick", handleTick);
	 * 	function handleTick(evtObj) {
	 * 		// clone the event object from Ticker, and add some custom data to it:
	 * 		var evt = evtObj.clone().set({greeting:"hello", name:"world"});
	 * 		
	 * 		// pass it to stage.update():
	 * 		myStage.update(evt); // subsequently calls tick() with the same param
	 * 	}
	 * 	
	 * 	// ...
	 * 	myDisplayObject.on("tick", handleDisplayObjectTick);
	 * 	function handleDisplayObjectTick(evt) {
	 * 		console.log(evt.delta); // the delta property from the Ticker tick event object
	 * 		console.log(evt.greeting, evt.name); // custom data: "hello world"
	 * 	}
	 * 
	 * @method tick
	 * @param {Object} [props] An object with properties that should be copied to the event object. Should usually be a Ticker event object, or similar object with a delta property.
	 **/
	p.tick = function(props) {
		if (!this.tickEnabled || this.dispatchEvent("tickstart", false, true) === false) { return; }
		var evtObj = new createjs.Event("tick");
		if (props) {
			for (var n in props) {
				if (props.hasOwnProperty(n)) { evtObj[n] = props[n]; }
			}
		}
		this._tick(evtObj);
		this.dispatchEvent("tickend");
	};

	/**
	 * Default event handler that calls the Stage {{#crossLink "Stage/update"}}{{/crossLink}} method when a {{#crossLink "DisplayObject/tick:event"}}{{/crossLink}}
	 * event is received. This allows you to register a Stage instance as a event listener on {{#crossLink "Ticker"}}{{/crossLink}}
	 * directly, using:
	 *
	 *      Ticker.addEventListener("tick", myStage");
	 *
	 * Note that if you subscribe to ticks using this pattern, then the tick event object will be passed through to
	 * display object tick handlers, instead of <code>delta</code> and <code>paused</code> parameters.
	 * @property handleEvent
	 * @type Function
	 **/
	p.handleEvent = function(evt) {
		if (evt.type == "tick") { this.update(evt); }
	};

	/**
	 * Clears the target canvas. Useful if {{#crossLink "Stage/autoClear:property"}}{{/crossLink}} is set to `false`.
	 * @method clear
	 **/
	p.clear = function() {
		if (!this.canvas) { return; }
		var ctx = this.canvas.getContext("2d");
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		ctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1);
	};

	/**
	 * Returns a data url that contains a Base64-encoded image of the contents of the stage. The returned data url can
	 * be specified as the src value of an image element.
	 * @method toDataURL
	 * @param {String} [backgroundColor] The background color to be used for the generated image. Any valid CSS color
	 * value is allowed. The default value is a transparent background.
	 * @param {String} [mimeType="image/png"] The MIME type of the image format to be create. The default is "image/png". If an unknown MIME type
	 * is passed in, or if the browser does not support the specified MIME type, the default value will be used.
	 * @return {String} a Base64 encoded image.
	 **/
	p.toDataURL = function(backgroundColor, mimeType) {
		var data, ctx = this.canvas.getContext('2d'), w = this.canvas.width, h = this.canvas.height;

		if (backgroundColor) {
			data = ctx.getImageData(0, 0, w, h);
			var compositeOperation = ctx.globalCompositeOperation;
			ctx.globalCompositeOperation = "destination-over";
			
			ctx.fillStyle = backgroundColor;
			ctx.fillRect(0, 0, w, h);
		}

		var dataURL = this.canvas.toDataURL(mimeType||"image/png");

		if(backgroundColor) {
			ctx.putImageData(data, 0, 0);
			ctx.globalCompositeOperation = compositeOperation;
		}

		return dataURL;
	};

	/**
	 * Enables or disables (by passing a frequency of 0) mouse over ({{#crossLink "DisplayObject/mouseover:event"}}{{/crossLink}}
	 * and {{#crossLink "DisplayObject/mouseout:event"}}{{/crossLink}}) and roll over events ({{#crossLink "DisplayObject/rollover:event"}}{{/crossLink}}
	 * and {{#crossLink "DisplayObject/rollout:event"}}{{/crossLink}}) for this stage's display list. These events can
	 * be expensive to generate, so they are disabled by default. The frequency of the events can be controlled
	 * independently of mouse move events via the optional `frequency` parameter.
	 *
	 * <h4>Example</h4>
	 *
	 *      var stage = new createjs.Stage("canvasId");
	 *      stage.enableMouseOver(10); // 10 updates per second
	 *
	 * @method enableMouseOver
	 * @param {Number} [frequency=20] Optional param specifying the maximum number of times per second to broadcast
	 * mouse over/out events. Set to 0 to disable mouse over events completely. Maximum is 50. A lower frequency is less
	 * responsive, but uses less CPU.
	 **/
	p.enableMouseOver = function(frequency) {
		if (this._mouseOverIntervalID) {
			clearInterval(this._mouseOverIntervalID);
			this._mouseOverIntervalID = null;
			if (frequency == 0) {
				this._testMouseOver(true);
			}
		}
		if (frequency == null) { frequency = 20; }
		else if (frequency <= 0) { return; }
		var o = this;
		this._mouseOverIntervalID = setInterval(function(){ o._testMouseOver(); }, 1000/Math.min(50,frequency));
	};

	/**
	 * Enables or disables the event listeners that stage adds to DOM elements (window, document and canvas). It is good
	 * practice to disable events when disposing of a Stage instance, otherwise the stage will continue to receive
	 * events from the page.
	 *
	 * When changing the canvas property you must disable the events on the old canvas, and enable events on the
	 * new canvas or mouse events will not work as expected. For example:
	 *
	 *      myStage.enableDOMEvents(false);
	 *      myStage.canvas = anotherCanvas;
	 *      myStage.enableDOMEvents(true);
	 *
	 * @method enableDOMEvents
	 * @param {Boolean} [enable=true] Indicates whether to enable or disable the events. Default is true.
	 **/
	p.enableDOMEvents = function(enable) {
		if (enable == null) { enable = true; }
		var n, o, ls = this._eventListeners;
		if (!enable && ls) {
			for (n in ls) {
				o = ls[n];
				o.t.removeEventListener(n, o.f, false);
			}
			this._eventListeners = null;
		} else if (enable && !ls && this.canvas) {
			var t = window.addEventListener ? window : document;
			var _this = this;
			ls = this._eventListeners = {};
			ls["mouseup"] = {t:t, f:function(e) { _this._handleMouseUp(e)} };
			ls["mousemove"] = {t:t, f:function(e) { _this._handleMouseMove(e)} };
			ls["dblclick"] = {t:this.canvas, f:function(e) { _this._handleDoubleClick(e)} };
			ls["mousedown"] = {t:this.canvas, f:function(e) { _this._handleMouseDown(e)} };

			for (n in ls) {
				o = ls[n];
				o.t.addEventListener(n, o.f, false);
			}
		}
	};

	/**
	 * Stage instances cannot be cloned.
	 * @method clone
	 **/
	p.clone = function() {
		throw("Stage cannot be cloned.");
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Stage (name="+  this.name +")]";
	};


// private methods:
	/**
	 * @method _getElementRect
	 * @protected
	 * @param {HTMLElement} e
	 **/
	p._getElementRect = function(e) {
		var bounds;
		try { bounds = e.getBoundingClientRect(); } // this can fail on disconnected DOM elements in IE9
		catch (err) { bounds = {top: e.offsetTop, left: e.offsetLeft, width:e.offsetWidth, height:e.offsetHeight}; }

		var offX = (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || document.body.clientLeft || 0);
		var offY = (window.pageYOffset || document.scrollTop || 0) - (document.clientTop  || document.body.clientTop  || 0);

		var styles = window.getComputedStyle ? getComputedStyle(e,null) : e.currentStyle; // IE <9 compatibility.
		var padL = parseInt(styles.paddingLeft)+parseInt(styles.borderLeftWidth);
		var padT = parseInt(styles.paddingTop)+parseInt(styles.borderTopWidth);
		var padR = parseInt(styles.paddingRight)+parseInt(styles.borderRightWidth);
		var padB = parseInt(styles.paddingBottom)+parseInt(styles.borderBottomWidth);

		// note: in some browsers bounds properties are read only.
		return {
			left: bounds.left+offX+padL,
			right: bounds.right+offX-padR,
			top: bounds.top+offY+padT,
			bottom: bounds.bottom+offY-padB
		}
	};

	/**
	 * @method _getPointerData
	 * @protected
	 * @param {Number} id
	 **/
	p._getPointerData = function(id) {
		var data = this._pointerData[id];
		if (!data) { data = this._pointerData[id] = {x:0,y:0}; }
		return data;
	};

	/**
	 * @method _handleMouseMove
	 * @protected
	 * @param {MouseEvent} e
	 **/
	p._handleMouseMove = function(e) {
		if(!e){ e = window.event; }
		this._handlePointerMove(-1, e, e.pageX, e.pageY);
	};

	/**
	 * @method _handlePointerMove
	 * @protected
	 * @param {Number} id
	 * @param {Event} e
	 * @param {Number} pageX
	 * @param {Number} pageY
	 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
	 **/
	p._handlePointerMove = function(id, e, pageX, pageY, owner) {
		if (this._prevStage && owner === undefined) { return; } // redundant listener.
		if (!this.canvas) { return; }
		var nextStage=this._nextStage, o=this._getPointerData(id);

		var inBounds = o.inBounds;
		this._updatePointerPosition(id, e, pageX, pageY);
		if (inBounds || o.inBounds || this.mouseMoveOutside) {
			if (id === -1 && o.inBounds == !inBounds) {
				this._dispatchMouseEvent(this, (inBounds ? "mouseleave" : "mouseenter"), false, id, o, e);
			}
			
			this._dispatchMouseEvent(this, "stagemousemove", false, id, o, e);
			this._dispatchMouseEvent(o.target, "pressmove", true, id, o, e);
		}
		
		nextStage&&nextStage._handlePointerMove(id, e, pageX, pageY, null);
	};

	/**
	 * @method _updatePointerPosition
	 * @protected
	 * @param {Number} id
	 * @param {Event} e
	 * @param {Number} pageX
	 * @param {Number} pageY
	 **/
	p._updatePointerPosition = function(id, e, pageX, pageY) {
		var rect = this._getElementRect(this.canvas);
		pageX -= rect.left;
		pageY -= rect.top;

		var w = this.canvas.width;
		var h = this.canvas.height;
		pageX /= (rect.right-rect.left)/w;
		pageY /= (rect.bottom-rect.top)/h;
		var o = this._getPointerData(id);
		if (o.inBounds = (pageX >= 0 && pageY >= 0 && pageX <= w-1 && pageY <= h-1)) {
			o.x = pageX;
			o.y = pageY;
		} else if (this.mouseMoveOutside) {
			o.x = pageX < 0 ? 0 : (pageX > w-1 ? w-1 : pageX);
			o.y = pageY < 0 ? 0 : (pageY > h-1 ? h-1 : pageY);
		}

		o.posEvtObj = e;
		o.rawX = pageX;
		o.rawY = pageY;

		if (id === this._primaryPointerID || id === -1) {
			this.mouseX = o.x;
			this.mouseY = o.y;
			this.mouseInBounds = o.inBounds;
		}
	};

	/**
	 * @method _handleMouseUp
	 * @protected
	 * @param {MouseEvent} e
	 **/
	p._handleMouseUp = function(e) {
		this._handlePointerUp(-1, e, false);
	};

	/**
	 * @method _handlePointerUp
	 * @protected
	 * @param {Number} id
	 * @param {Event} e
	 * @param {Boolean} clear
	 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
	 **/
	p._handlePointerUp = function(id, e, clear, owner) {
		var nextStage = this._nextStage, o = this._getPointerData(id);
		if (this._prevStage && owner === undefined) { return; } // redundant listener.
		
		var target=null, oTarget = o.target;
		if (!owner && (oTarget || nextStage)) { target = this._getObjectsUnderPoint(o.x, o.y, null, true); }
		
		if (o.down) { this._dispatchMouseEvent(this, "stagemouseup", false, id, o, e, target); o.down = false; }
		
		if (target == oTarget) { this._dispatchMouseEvent(oTarget, "click", true, id, o, e); }
		this._dispatchMouseEvent(oTarget, "pressup", true, id, o, e);
		
		if (clear) {
			if (id==this._primaryPointerID) { this._primaryPointerID = null; }
			delete(this._pointerData[id]);
		} else { o.target = null; }
		
		nextStage&&nextStage._handlePointerUp(id, e, clear, owner || target && this);
	};

	/**
	 * @method _handleMouseDown
	 * @protected
	 * @param {MouseEvent} e
	 **/
	p._handleMouseDown = function(e) {
		this._handlePointerDown(-1, e, e.pageX, e.pageY);
	};

	/**
	 * @method _handlePointerDown
	 * @protected
	 * @param {Number} id
	 * @param {Event} e
	 * @param {Number} pageX
	 * @param {Number} pageY
	 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
	 **/
	p._handlePointerDown = function(id, e, pageX, pageY, owner) {
		if (this.preventSelection) { e.preventDefault(); }
		if (this._primaryPointerID == null || id === -1) { this._primaryPointerID = id; } // mouse always takes over.
		
		if (pageY != null) { this._updatePointerPosition(id, e, pageX, pageY); }
		var target = null, nextStage = this._nextStage, o = this._getPointerData(id);
		if (!owner) { target = o.target = this._getObjectsUnderPoint(o.x, o.y, null, true); }

		if (o.inBounds) { this._dispatchMouseEvent(this, "stagemousedown", false, id, o, e, target); o.down = true; }
		this._dispatchMouseEvent(target, "mousedown", true, id, o, e);
		
		nextStage&&nextStage._handlePointerDown(id, e, pageX, pageY, owner || target && this);
	};

	/**
	 * @method _testMouseOver
	 * @param {Boolean} clear If true, clears the mouseover / rollover (ie. no target)
	 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
	 * @param {Stage} eventTarget The stage that the cursor is actively over.
	 * @protected
	 **/
	p._testMouseOver = function(clear, owner, eventTarget) {
		if (this._prevStage && owner === undefined) { return; } // redundant listener.
		
		var nextStage = this._nextStage;
		if (!this._mouseOverIntervalID) {
			// not enabled for mouseover, but should still relay the event.
			nextStage&&nextStage._testMouseOver(clear, owner, eventTarget);
			return;
		}
		var o = this._getPointerData(-1);
		// only update if the mouse position has changed. This provides a lot of optimization, but has some trade-offs.
		if (!o || (!clear && this.mouseX == this._mouseOverX && this.mouseY == this._mouseOverY && this.mouseInBounds)) { return; }
		
		var e = o.posEvtObj;
		var isEventTarget = eventTarget || e&&(e.target == this.canvas);
		var target=null, common = -1, cursor="", t, i, l;
		
		if (!owner && (clear || this.mouseInBounds && isEventTarget)) {
			target = this._getObjectsUnderPoint(this.mouseX, this.mouseY, null, true);
			this._mouseOverX = this.mouseX;
			this._mouseOverY = this.mouseY;
		}

		var oldList = this._mouseOverTarget||[];
		var oldTarget = oldList[oldList.length-1];
		var list = this._mouseOverTarget = [];

		// generate ancestor list and check for cursor:
		t = target;
		while (t) {
			list.unshift(t);
			if (!cursor) { cursor = t.cursor; }
			t = t.parent;
		}
		this.canvas.style.cursor = cursor;
		if (!owner && eventTarget) { eventTarget.canvas.style.cursor = cursor; }

		// find common ancestor:
		for (i=0,l=list.length; i<l; i++) {
			if (list[i] != oldList[i]) { break; }
			common = i;
		}

		if (oldTarget != target) {
			this._dispatchMouseEvent(oldTarget, "mouseout", true, -1, o, e, target);
		}

		for (i=oldList.length-1; i>common; i--) {
			this._dispatchMouseEvent(oldList[i], "rollout", false, -1, o, e, target);
		}

		for (i=list.length-1; i>common; i--) {
			this._dispatchMouseEvent(list[i], "rollover", false, -1, o, e, oldTarget);
		}

		if (oldTarget != target) {
			this._dispatchMouseEvent(target, "mouseover", true, -1, o, e, oldTarget);
		}
		
		nextStage&&nextStage._testMouseOver(clear, owner || target && this, eventTarget || isEventTarget && this);
	};

	/**
	 * @method _handleDoubleClick
	 * @protected
	 * @param {MouseEvent} e
	 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
	 **/
	p._handleDoubleClick = function(e, owner) {
		var target=null, nextStage=this._nextStage, o=this._getPointerData(-1);
		if (!owner) {
			target = this._getObjectsUnderPoint(o.x, o.y, null, true);
			this._dispatchMouseEvent(target, "dblclick", true, -1, o, e);
		}
		nextStage&&nextStage._handleDoubleClick(e, owner || target && this);
	};

	/**
	 * @method _dispatchMouseEvent
	 * @protected
	 * @param {DisplayObject} target
	 * @param {String} type
	 * @param {Boolean} bubbles
	 * @param {Number} pointerId
	 * @param {Object} o
	 * @param {MouseEvent} [nativeEvent]
	 * @param {DisplayObject} [relatedTarget]
	 **/
	p._dispatchMouseEvent = function(target, type, bubbles, pointerId, o, nativeEvent, relatedTarget) {
		// TODO: might be worth either reusing MouseEvent instances, or adding a willTrigger method to avoid GC.
		if (!target || (!bubbles && !target.hasEventListener(type))) { return; }
		/*
		// TODO: account for stage transformations?
		this._mtx = this.getConcatenatedMatrix(this._mtx).invert();
		var pt = this._mtx.transformPoint(o.x, o.y);
		var evt = new createjs.MouseEvent(type, bubbles, false, pt.x, pt.y, nativeEvent, pointerId, pointerId==this._primaryPointerID || pointerId==-1, o.rawX, o.rawY);
		*/
		var evt = new createjs.MouseEvent(type, bubbles, false, o.x, o.y, nativeEvent, pointerId, pointerId === this._primaryPointerID || pointerId === -1, o.rawX, o.rawY, relatedTarget);
		target.dispatchEvent(evt);
	};


	createjs.Stage = createjs.promote(Stage, "Container");
}());

//##############################################################################
// Bitmap.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	
	/**
	 * A Bitmap represents an Image, Canvas, or Video in the display list. A Bitmap can be instantiated using an existing
	 * HTML element, or a string.
	 *
	 * <h4>Example</h4>
	 *
	 *      var bitmap = new createjs.Bitmap("imagePath.jpg");
	 *
	 * <strong>Notes:</strong>
	 * <ol>
	 *     <li>When a string path or image tag that is not yet loaded is used, the stage may need to be redrawn before it
	 *      will be displayed.</li>
	 *     <li>Bitmaps with an SVG source currently will not respect an alpha value other than 0 or 1. To get around this,
	 *     the Bitmap can be cached.</li>
	 *     <li>Bitmaps with an SVG source will taint the canvas with cross-origin data, which prevents interactivity. This
	 *     happens in all browsers except recent Firefox builds.</li>
	 *     <li>Images loaded cross-origin will throw cross-origin security errors when interacted with using a mouse, using
	 *     methods such as `getObjectUnderPoint`, or using filters, or caching. You can get around this by setting
	 *     `crossOrigin` flags on your images before passing them to EaselJS, eg: `img.crossOrigin="Anonymous";`</li>
	 * </ol>
	 *
	 * @class Bitmap
	 * @extends DisplayObject
	 * @constructor
	 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | String} imageOrUri The source object or URI to an image to
	 * display. This can be either an Image, Canvas, or Video object, or a string URI to an image file to load and use.
	 * If it is a URI, a new Image object will be constructed and assigned to the .image property.
	 **/
	function Bitmap(imageOrUri) {
		this.DisplayObject_constructor();
		
		
	// public properties:
		/**
		 * The image to render. This can be an Image, a Canvas, or a Video. Not all browsers (especially
		 * mobile browsers) support drawing video to a canvas.
		 * @property image
		 * @type HTMLImageElement | HTMLCanvasElement | HTMLVideoElement
		 **/
		if (typeof imageOrUri == "string") {
			this.image = document.createElement("img");
			this.image.src = imageOrUri;
		} else {
			this.image = imageOrUri;
		}
	
		/**
		 * Specifies an area of the source image to draw. If omitted, the whole image will be drawn.
		 * Note that video sources must have a width / height set to work correctly with `sourceRect`.
		 * @property sourceRect
		 * @type Rectangle
		 * @default null
		 */
		this.sourceRect = null;
	}
	var p = createjs.extend(Bitmap, createjs.DisplayObject);
	
	
// public methods:
	/**
	 * Constructor alias for backwards compatibility. This method will be removed in future versions.
	 * Subclasses should be updated to use {{#crossLink "Utility Methods/extends"}}{{/crossLink}}.
	 * @method initialize
	 * @deprecated in favour of `createjs.promote()`
	 **/
	p.initialize = Bitmap; // TODO: deprecated.

	/**
	 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
	 **/
	p.isVisible = function() {
		var image = this.image;
		var hasContent = this.cacheCanvas || (image && (image.naturalWidth || image.getContext || image.readyState >= 2));
		return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
	};

	/**
	 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
	 * Returns true if the draw was handled (useful for overriding functionality).
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache.
	 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
	 * into itself).
	 * @return {Boolean}
	 **/
	p.draw = function(ctx, ignoreCache) {
		if (this.DisplayObject_draw(ctx, ignoreCache) || !this.image) { return true; }
		var img = this.image, rect = this.sourceRect;
		if (rect) {
			// some browsers choke on out of bound values, so we'll fix them:
			var x1 = rect.x, y1 = rect.y, x2 = x1 + rect.width, y2 = y1 + rect.height, x = 0, y = 0, w = img.width, h = img.height;
			if (x1 < 0) { x -= x1; x1 = 0; }
			if (x2 > w) { x2 = w; }
			if (y1 < 0) { y -= y1; y1 = 0; }
			if (y2 > h) { y2 = h; }
			ctx.drawImage(img, x1, y1, x2-x1, y2-y1, x, y, x2-x1, y2-y1);
		} else {
			ctx.drawImage(img, 0, 0);
		}
		return true;
	};
	
	//Note, the doc sections below document using the specified APIs (from DisplayObject)  from
	//Bitmap. This is why they have no method implementations.
	
	/**
	 * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.
	 * You should <b>not</b> cache Bitmap instances as it can degrade performance.
	 *
	 * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>
	 * To see the API for caching, please visit the DisplayObject {{#crossLink "DisplayObject/cache"}}{{/crossLink}}
	 * method.
	 * @method cache
	 **/
	
	/**
	 * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.
	 * You should <b>not</b> cache Bitmap instances as it can degrade performance.
	 *
	 * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>
	 * To see the API for caching, please visit the DisplayObject {{#crossLink "DisplayObject/cache"}}{{/crossLink}}
	 * method.
	 * @method updateCache
	 **/
	
	/**
	 * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.
	 * You should <b>not</b> cache Bitmap instances as it can degrade performance.
	 *
	 * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>
	 * To see the API for caching, please visit the DisplayObject {{#crossLink "DisplayObject/cache"}}{{/crossLink}}
	 * method.
	 * @method uncache
	 **/

	/**
	 * Docced in superclass.
	 */
	p.getBounds = function() {
		var rect = this.DisplayObject_getBounds();
		if (rect) { return rect; }
		var image = this.image, o = this.sourceRect || image;
		var hasContent = (image && (image.naturalWidth || image.getContext || image.readyState >= 2));
		return hasContent ? this._rectangle.setValues(0, 0, o.width, o.height) : null;
	};
	
	/**
	 * Returns a clone of the Bitmap instance.
	 * @method clone
	 * @return {Bitmap} a clone of the Bitmap instance.
	 **/
	p.clone = function() {
		var o = new Bitmap(this.image);
		if (this.sourceRect) { o.sourceRect = this.sourceRect.clone(); }
		this._cloneProps(o);
		return o;
	};
	
	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Bitmap (name="+  this.name +")]";
	};

	
	createjs.Bitmap = createjs.promote(Bitmap, "DisplayObject");
}());

//##############################################################################
// Sprite.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Displays a frame or sequence of frames (ie. an animation) from a SpriteSheet instance. A sprite sheet is a series of
	 * images (usually animation frames) combined into a single image. For example, an animation consisting of 8 100x100
	 * images could be combined into a 400x200 sprite sheet (4 frames across by 2 high). You can display individual frames,
	 * play frames as an animation, and even sequence animations together.
	 *
	 * See the {{#crossLink "SpriteSheet"}}{{/crossLink}} class for more information on setting up frames and animations.
	 *
	 * <h4>Example</h4>
	 *
	 *      var instance = new createjs.Sprite(spriteSheet);
	 *      instance.gotoAndStop("frameName");
	 *
	 * Until {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} or {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}} is called,
	 * only the first defined frame defined in the sprite sheet will be displayed.
	 *
	 * @class Sprite
	 * @extends DisplayObject
	 * @constructor
	 * @param {SpriteSheet} spriteSheet The SpriteSheet instance to play back. This includes the source image(s), frame
	 * dimensions, and frame data. See {{#crossLink "SpriteSheet"}}{{/crossLink}} for more information.
	 * @param {String|Number} [frameOrAnimation] The frame number or animation to play initially.
	 **/
	function Sprite(spriteSheet, frameOrAnimation) {
		this.DisplayObject_constructor();
		
		
	// public properties:
		/**
		 * The frame index that will be drawn when draw is called. Note that with some {{#crossLink "SpriteSheet"}}{{/crossLink}}
		 * definitions, this will advance non-sequentially. This will always be an integer value.
		 * @property currentFrame
		 * @type {Number}
		 * @default 0
		 * @readonly
		 **/
		this.currentFrame = 0;
	
		/**
		 * Returns the name of the currently playing animation.
		 * @property currentAnimation
		 * @type {String}
		 * @final
		 * @readonly
		 **/
		this.currentAnimation = null;
	
		/**
		 * Prevents the animation from advancing each tick automatically. For example, you could create a sprite
		 * sheet of icons, set paused to true, and display the appropriate icon by setting <code>currentFrame</code>.
		 * @property paused
		 * @type {Boolean}
		 * @default false
		 **/
		this.paused = true;
	
		/**
		 * The SpriteSheet instance to play back. This includes the source image, frame dimensions, and frame
		 * data. See {{#crossLink "SpriteSheet"}}{{/crossLink}} for more information.
		 * @property spriteSheet
		 * @type {SpriteSheet}
		 * @readonly
		 **/
		this.spriteSheet = spriteSheet;
	
		/**
		 * Specifies the current frame index within the currently playing animation. When playing normally, this will increase
		 * from 0 to n-1, where n is the number of frames in the current animation.
		 *
		 * This could be a non-integer value if
		 * using time-based playback (see {{#crossLink "Sprite/framerate"}}{{/crossLink}}, or if the animation's speed is
		 * not an integer.
		 * @property currentAnimationFrame
		 * @type {Number}
		 * @default 0
		 **/
		this.currentAnimationFrame = 0;
	
		/**
		 * By default Sprite instances advance one frame per tick. Specifying a framerate for the Sprite (or its related
		 * SpriteSheet) will cause it to advance based on elapsed time between ticks as appropriate to maintain the target
		 * framerate.
		 *
		 * For example, if a Sprite with a framerate of 10 is placed on a Stage being updated at 40fps, then the Sprite will
		 * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will
		 * vary slightly between frames.
		 *
		 * This feature is dependent on the tick event object (or an object with an appropriate "delta" property) being
		 * passed into {{#crossLink "Stage/update"}}{{/crossLink}}.
		 * @property framerate
		 * @type {Number}
		 * @default 0
		 **/
		this.framerate = 0;
	
	
	// private properties:
		/**
		 * Current animation object.
		 * @property _animation
		 * @protected
		 * @type {Object}
		 * @default null
		 **/
		this._animation = null;
	
		/**
		 * Current frame index.
		 * @property _currentFrame
		 * @protected
		 * @type {Number}
		 * @default null
		 **/
		this._currentFrame = null;
		
		/**
		 * Skips the next auto advance. Used by gotoAndPlay to avoid immediately jumping to the next frame
		 * @property _skipAdvance
		 * @protected
		 * @type {Boolean}
		 * @default false
		 **/
		this._skipAdvance = false;
		
		
		if (frameOrAnimation != null) { this.gotoAndPlay(frameOrAnimation); }
	}
	var p = createjs.extend(Sprite, createjs.DisplayObject);

	/**
	 * Constructor alias for backwards compatibility. This method will be removed in future versions.
	 * Subclasses should be updated to use {{#crossLink "Utility Methods/extends"}}{{/crossLink}}.
	 * @method initialize
	 * @deprecated in favour of `createjs.promote()`
	 **/
	p.initialize = Sprite; // TODO: Deprecated. This is for backwards support of FlashCC spritesheet export.


// events:
	/**
	 * Dispatched when an animation reaches its ends.
	 * @event animationend
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {String} name The name of the animation that just ended.
	 * @param {String} next The name of the next animation that will be played, or null. This will be the same as name if the animation is looping.
	 * @since 0.6.0
	 */
	 
	/**
	 * Dispatched any time the current frame changes. For example, this could be due to automatic advancement on a tick,
	 * or calling gotoAndPlay() or gotoAndStop().
	 * @event change
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 */


// public methods:
	/**
	 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
	 **/
	p.isVisible = function() {
		var hasContent = this.cacheCanvas || this.spriteSheet.complete;
		return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
	};

	/**
	 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
	 * Returns true if the draw was handled (useful for overriding functionality).
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.
	 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
	 * into itself).
	 **/
	p.draw = function(ctx, ignoreCache) {
		if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
		this._normalizeFrame();
		var o = this.spriteSheet.getFrame(this._currentFrame|0);
		if (!o) { return false; }
		var rect = o.rect;
		if (rect.width && rect.height) { ctx.drawImage(o.image, rect.x, rect.y, rect.width, rect.height, -o.regX, -o.regY, rect.width, rect.height); }
		return true;
	};

	//Note, the doc sections below document using the specified APIs (from DisplayObject)  from
	//Bitmap. This is why they have no method implementations.

	/**
	 * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.
	 * You should not cache Sprite instances as it can degrade performance.
	 * @method cache
	 **/

	/**
	 * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.
	 * You should not cache Sprite instances as it can degrade performance.
	 * @method updateCache
	 **/

	/**
	 * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.
	 * You should not cache Sprite instances as it can degrade performance.
	 * @method uncache
	 **/

	/**
	 * Play (unpause) the current animation. The Sprite will be paused if either {{#crossLink "Sprite/stop"}}{{/crossLink}}
	 * or {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} is called. Single frame animations will remain
	 * unchanged.
	 * @method play
	 **/
	p.play = function() {
		this.paused = false;
	};

	/**
	 * Stop playing a running animation. The Sprite will be playing if {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}}
	 * is called. Note that calling {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}} or {{#crossLink "Sprite/play"}}{{/crossLink}}
	 * will resume playback.
	 * @method stop
	 **/
	p.stop = function() {
		this.paused = true;
	};

	/**
	 * Sets paused to false and plays the specified animation name, named frame, or frame number.
	 * @method gotoAndPlay
	 * @param {String|Number} frameOrAnimation The frame number or animation name that the playhead should move to
	 * and begin playing.
	 **/
	p.gotoAndPlay = function(frameOrAnimation) {
		this.paused = false;
		this._skipAdvance = true;
		this._goto(frameOrAnimation);
	};

	/**
	 * Sets paused to true and seeks to the specified animation name, named frame, or frame number.
	 * @method gotoAndStop
	 * @param {String|Number} frameOrAnimation The frame number or animation name that the playhead should move to
	 * and stop.
	 **/
	p.gotoAndStop = function(frameOrAnimation) {
		this.paused = true;
		this._goto(frameOrAnimation);
	};

	/**
	 * Advances the playhead. This occurs automatically each tick by default.
	 * @param [time] {Number} The amount of time in ms to advance by. Only applicable if framerate is set on the Sprite
	 * or its SpriteSheet.
	 * @method advance
	*/
	p.advance = function(time) {
		var fps = this.framerate || this.spriteSheet.framerate;
		var t = (fps && time != null) ? time/(1000/fps) : 1;
		this._normalizeFrame(t);
	};
	
	/**
	 * Returns a {{#crossLink "Rectangle"}}{{/crossLink}} instance defining the bounds of the current frame relative to
	 * the origin. For example, a 90 x 70 frame with <code>regX=50</code> and <code>regY=40</code> would return a
	 * rectangle with [x=-50, y=-40, width=90, height=70]. This ignores transformations on the display object.
	 *
	 * Also see the SpriteSheet {{#crossLink "SpriteSheet/getFrameBounds"}}{{/crossLink}} method.
	 * @method getBounds
	 * @return {Rectangle} A Rectangle instance. Returns null if the frame does not exist, or the image is not fully
	 * loaded.
	 **/
	p.getBounds = function() {
		// TODO: should this normalizeFrame?
		return this.DisplayObject_getBounds() || this.spriteSheet.getFrameBounds(this.currentFrame, this._rectangle);
	};

	/**
	 * Returns a clone of the Sprite instance. Note that the same SpriteSheet is shared between cloned
	 * instances.
	 * @method clone
	 * @return {Sprite} a clone of the Sprite instance.
	 **/
	p.clone = function() {
		return this._cloneProps(new Sprite(this.spriteSheet));
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Sprite (name="+  this.name +")]";
	};

// private methods:
	/**
	 * @method _cloneProps
	 * @param {Sprite} o
	 * @return {Sprite} o
	 * @protected
	 **/
	p._cloneProps = function(o) {
		this.DisplayObject__cloneProps(o);
		o.currentFrame = this.currentFrame;
		o.currentAnimation = this.currentAnimation;
		o.paused = this.paused;
		o.currentAnimationFrame = this.currentAnimationFrame;
		o.framerate = this.framerate;
		
		o._animation = this._animation;
		o._currentFrame = this._currentFrame;
		o._skipAdvance = this._skipAdvance;
		return o;
	};
	
	/**
	 * Advances the <code>currentFrame</code> if paused is not true. This is called automatically when the {{#crossLink "Stage"}}{{/crossLink}}
	 * ticks.
	 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
	 * @protected
	 * @method _tick
	 **/
	p._tick = function(evtObj) {
		if (!this.paused) {
			if (!this._skipAdvance) { this.advance(evtObj&&evtObj.delta); }
			this._skipAdvance = false;
		}
		this.DisplayObject__tick(evtObj);
	};


	/**
	 * Normalizes the current frame, advancing animations and dispatching callbacks as appropriate.
	 * @protected
	 * @method _normalizeFrame
	 **/
	p._normalizeFrame = function(frameDelta) {
		frameDelta = frameDelta || 0;
		var animation = this._animation;
		var paused = this.paused;
		var frame = this._currentFrame;
		var l;
		
		if (animation) {
			var speed = animation.speed || 1;
			var animFrame = this.currentAnimationFrame;
			l = animation.frames.length;
			if (animFrame + frameDelta * speed >= l) {
				var next = animation.next;
				if (this._dispatchAnimationEnd(animation, frame, paused, next, l - 1)) {
					// something changed in the event stack, so we shouldn't make any more changes here.
					return;
				} else if (next) {
					// sequence. Automatically calls _normalizeFrame again with the remaining frames.
					return this._goto(next, frameDelta - (l - animFrame) / speed);
				} else {
					// end.
					this.paused = true;
					animFrame = animation.frames.length - 1;
				}
			} else {
				animFrame += frameDelta * speed;
			}
			this.currentAnimationFrame = animFrame;
			this._currentFrame = animation.frames[animFrame | 0]
		} else {
			frame = (this._currentFrame += frameDelta);
			l = this.spriteSheet.getNumFrames();
			if (frame >= l && l > 0) {
				if (!this._dispatchAnimationEnd(animation, frame, paused, l - 1)) {
					// looped.
					if ((this._currentFrame -= l) >= l) { return this._normalizeFrame(); }
				}
			}
		}
		frame = this._currentFrame | 0;
		if (this.currentFrame != frame) {
			this.currentFrame = frame;
			this.dispatchEvent("change");
		}
	};

	/**
	 * Dispatches the "animationend" event. Returns true if a handler changed the animation (ex. calling {{#crossLink "Sprite/stop"}}{{/crossLink}},
	 * {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}}, etc.)
	 * @property _dispatchAnimationEnd
	 * @private
	 * @type {Function}
	 **/
	p._dispatchAnimationEnd = function(animation, frame, paused, next, end) {
		var name = animation ? animation.name : null;
		if (this.hasEventListener("animationend")) {
			var evt = new createjs.Event("animationend");
			evt.name = name;
			evt.next = next;
			this.dispatchEvent(evt);
		}
		// did the animation get changed in the event stack?:
		var changed = (this._animation != animation || this._currentFrame != frame);
		// if the animation hasn't changed, but the sprite was paused, then we want to stick to the last frame:
		if (!changed && !paused && this.paused) { this.currentAnimationFrame = end; changed = true; }
		return changed;
	};

	/**
	 * Moves the playhead to the specified frame number or animation.
	 * @method _goto
	 * @param {String|Number} frameOrAnimation The frame number or animation that the playhead should move to.
	 * @param {Boolean} [frame] The frame of the animation to go to. Defaults to 0.
	 * @protected
	 **/
	p._goto = function(frameOrAnimation, frame) {
		this.currentAnimationFrame = 0;
		if (isNaN(frameOrAnimation)) {
			var data = this.spriteSheet.getAnimation(frameOrAnimation);
			if (data) {
				this._animation = data;
				this.currentAnimation = frameOrAnimation;
				this._normalizeFrame(frame);
			}
		} else {
			this.currentAnimation = this._animation = null;
			this._currentFrame = frameOrAnimation;
			this._normalizeFrame();
		}
	};


	createjs.Sprite = createjs.promote(Sprite, "DisplayObject");
}());

//##############################################################################
// Shape.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * A Shape allows you to display vector art in the display list. It composites a {{#crossLink "Graphics"}}{{/crossLink}}
	 * instance which exposes all of the vector drawing methods. The Graphics instance can be shared between multiple Shape
	 * instances to display the same vector graphics with different positions or transforms.
	 *
	 * If the vector art will not
	 * change between draws, you may want to use the {{#crossLink "DisplayObject/cache"}}{{/crossLink}} method to reduce the
	 * rendering cost.
	 *
	 * <h4>Example</h4>
	 *
	 *      var graphics = new createjs.Graphics().beginFill("#ff0000").drawRect(0, 0, 100, 100);
	 *      var shape = new createjs.Shape(graphics);
	 *
	 *      //Alternatively use can also use the graphics property of the Shape class to renderer the same as above.
	 *      var shape = new createjs.Shape();
	 *      shape.graphics.beginFill("#ff0000").drawRect(0, 0, 100, 100);
	 *
	 * @class Shape
	 * @extends DisplayObject
	 * @constructor
	 * @param {Graphics} graphics Optional. The graphics instance to display. If null, a new Graphics instance will be created.
	 **/
	function Shape(graphics) {
		this.DisplayObject_constructor();
		
		
	// public properties:
		/**
		 * The graphics instance to display.
		 * @property graphics
		 * @type Graphics
		 **/
		this.graphics = graphics ? graphics : new createjs.Graphics();
	}
	var p = createjs.extend(Shape, createjs.DisplayObject);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// public methods:
	/**
	 * Returns true or false indicating whether the Shape would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Boolean indicating whether the Shape would be visible if drawn to a canvas
	 **/
	p.isVisible = function() {
		var hasContent = this.cacheCanvas || (this.graphics && !this.graphics.isEmpty());
		return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
	};

	/**
	 * Draws the Shape into the specified context ignoring its visible, alpha, shadow, and transform. Returns true if
	 * the draw was handled (useful for overriding functionality).
	 *
	 * <i>NOTE: This method is mainly for internal use, though it may be useful for advanced uses.</i>
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,
	 * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).
	 * @return {Boolean}
	 **/
	p.draw = function(ctx, ignoreCache) {
		if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
		this.graphics.draw(ctx, this);
		return true;
	};

	/**
	 * Returns a clone of this Shape. Some properties that are specific to this instance's current context are reverted to
	 * their defaults (for example .parent).
	 * @method clone
	 * @param {Boolean} recursive If true, this Shape's {{#crossLink "Graphics"}}{{/crossLink}} instance will also be
	 * cloned. If false, the Graphics instance will be shared with the new Shape.
	 **/
	p.clone = function(recursive) {
		var g = (recursive && this.graphics) ? this.graphics.clone() : this.graphics;
		return  this._cloneProps(new Shape(g));
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Shape (name="+  this.name +")]";
	};


	createjs.Shape = createjs.promote(Shape, "DisplayObject");
}());

//##############################################################################
// Text.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Display one or more lines of dynamic text (not user editable) in the display list. Line wrapping support (using the
	 * lineWidth) is very basic, wrapping on spaces and tabs only. Note that as an alternative to Text, you can position HTML
	 * text above or below the canvas relative to items in the display list using the {{#crossLink "DisplayObject/localToGlobal"}}{{/crossLink}}
	 * method, or using {{#crossLink "DOMElement"}}{{/crossLink}}.
	 *
	 * <b>Please note that Text does not support HTML text, and can only display one font style at a time.</b> To use
	 * multiple font styles, you will need to create multiple text instances, and position them manually.
	 *
	 * <h4>Example</h4>
	 *
	 *      var text = new createjs.Text("Hello World", "20px Arial", "#ff7700");
	 *      text.x = 100;
	 *      text.textBaseline = "alphabetic";
	 *
	 * CreateJS Text supports web fonts (the same rules as Canvas). The font must be loaded and supported by the browser
	 * before it can be displayed.
	 *
	 * <strong>Note:</strong> Text can be expensive to generate, so cache instances where possible. Be aware that not all
	 * browsers will render Text exactly the same.
	 * @class Text
	 * @extends DisplayObject
	 * @constructor
	 * @param {String} [text] The text to display.
	 * @param {String} [font] The font style to use. Any valid value for the CSS font attribute is acceptable (ex. "bold
	 * 36px Arial").
	 * @param {String} [color] The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex.
	 * "#F00", "red", or "#FF0000").
	 **/
	function Text(text, font, color) {
		this.DisplayObject_constructor();
		
		
	// public properties:
		/**
		 * The text to display.
		 * @property text
		 * @type String
		 **/
		this.text = text;
	
		/**
		 * The font style to use. Any valid value for the CSS font attribute is acceptable (ex. "bold 36px Arial").
		 * @property font
		 * @type String
		 **/
		this.font = font;
	
		/**
		 * The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex. "#F00"). Default is "#000".
		 * It will also accept valid canvas fillStyle values.
		 * @property color
		 * @type String
		 **/
		this.color = color;
	
		/**
		 * The horizontal text alignment. Any of "start", "end", "left", "right", and "center". For detailed
		 * information view the
		 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles">
		 * whatwg spec</a>. Default is "left".
		 * @property textAlign
		 * @type String
		 **/
		this.textAlign = "left";
	
		/**
		 * The vertical alignment point on the font. Any of "top", "hanging", "middle", "alphabetic", "ideographic", or
		 * "bottom". For detailed information view the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles">
		 * whatwg spec</a>. Default is "top".
		 * @property textBaseline
		 * @type String
		*/
		this.textBaseline = "top";
	
		/**
		 * The maximum width to draw the text. If maxWidth is specified (not null), the text will be condensed or
		 * shrunk to make it fit in this width. For detailed information view the
		 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles">
		 * whatwg spec</a>.
		 * @property maxWidth
		 * @type Number
		*/
		this.maxWidth = null;
	
		/**
		 * If greater than 0, the text will be drawn as a stroke (outline) of the specified width.
		 * @property outline
		 * @type Number
		 **/
		this.outline = 0;
	
		/**
		 * Indicates the line height (vertical distance between baselines) for multi-line text. If null or 0,
		 * the value of getMeasuredLineHeight is used.
		 * @property lineHeight
		 * @type Number
		 **/
		this.lineHeight = 0;
	
		/**
		 * Indicates the maximum width for a line of text before it is wrapped to multiple lines. If null,
		 * the text will not be wrapped.
		 * @property lineWidth
		 * @type Number
		 **/
		this.lineWidth = null;
	}
	var p = createjs.extend(Text, createjs.DisplayObject);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.

	
// static properties:
	/**
	 * @property _workingContext
	 * @type CanvasRenderingContext2D
	 * @private
	 **/
	var canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"));
	if (canvas.getContext) { Text._workingContext = canvas.getContext("2d"); canvas.width = canvas.height = 1; }
	
	
// constants:
	/**
	 * Lookup table for the ratio to offset bounds x calculations based on the textAlign property.
	 * @property H_OFFSETS
	 * @type Object
	 * @protected
	 * @static
	 **/
	Text.H_OFFSETS = {start: 0, left: 0, center: -0.5, end: -1, right: -1};
	
	/**
	 * Lookup table for the ratio to offset bounds y calculations based on the textBaseline property.
	 * @property H_OFFSETS
	 * @type Object
	 * @protected
	 * @static
	 **/
	Text.V_OFFSETS = {top: 0, hanging: -0.01, middle: -0.4, alphabetic: -0.8, ideographic: -0.85, bottom: -1};


// public methods:
	/**
	 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Whether the display object would be visible if drawn to a canvas
	 **/
	p.isVisible = function() {
		var hasContent = this.cacheCanvas || (this.text != null && this.text !== "");
		return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
	};

	/**
	 * Draws the Text into the specified context ignoring its visible, alpha, shadow, and transform.
	 * Returns true if the draw was handled (useful for overriding functionality).
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.
	 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
	 * into itself).
	 **/
	p.draw = function(ctx, ignoreCache) {
		if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }

		var col = this.color || "#000";
		if (this.outline) { ctx.strokeStyle = col; ctx.lineWidth = this.outline*1; }
		else { ctx.fillStyle = col; }
		
		this._drawText(this._prepContext(ctx));
		return true;
	};

	/**
	 * Returns the measured, untransformed width of the text without wrapping. Use getBounds for a more robust value.
	 * @method getMeasuredWidth
	 * @return {Number} The measured, untransformed width of the text.
	 **/
	p.getMeasuredWidth = function() {
		return this._getMeasuredWidth(this.text);
	};

	/**
	 * Returns an approximate line height of the text, ignoring the lineHeight property. This is based on the measured
	 * width of a "M" character multiplied by 1.2, which provides an approximate line height for most fonts.
	 * @method getMeasuredLineHeight
	 * @return {Number} an approximate line height of the text, ignoring the lineHeight property. This is
	 * based on the measured width of a "M" character multiplied by 1.2, which approximates em for most fonts.
	 **/
	p.getMeasuredLineHeight = function() {
		return this._getMeasuredWidth("M")*1.2;
	};

	/**
	 * Returns the approximate height of multi-line text by multiplying the number of lines against either the
	 * <code>lineHeight</code> (if specified) or {{#crossLink "Text/getMeasuredLineHeight"}}{{/crossLink}}. Note that
	 * this operation requires the text flowing logic to run, which has an associated CPU cost.
	 * @method getMeasuredHeight
	 * @return {Number} The approximate height of the untransformed multi-line text.
	 **/
	p.getMeasuredHeight = function() {
		return this._drawText(null,{}).height;
	};

	/**
	 * Docced in superclass.
	 */
	p.getBounds = function() {
		var rect = this.DisplayObject_getBounds();
		if (rect) { return rect; }
		if (this.text == null || this.text === "") { return null; }
		var o = this._drawText(null, {});
		var w = (this.maxWidth && this.maxWidth < o.width) ? this.maxWidth : o.width;
		var x = w * Text.H_OFFSETS[this.textAlign||"left"];
		var lineHeight = this.lineHeight||this.getMeasuredLineHeight();
		var y = lineHeight * Text.V_OFFSETS[this.textBaseline||"top"];
		return this._rectangle.setValues(x, y, w, o.height);
	};
	
	/**
	 * Returns an object with width, height, and lines properties. The width and height are the visual width and height
	 * of the drawn text. The lines property contains an array of strings, one for
	 * each line of text that will be drawn, accounting for line breaks and wrapping. These strings have trailing
	 * whitespace removed.
	 * @method getMetrics
	 * @return {Object} An object with width, height, and lines properties.
	 **/
	p.getMetrics = function() {
		var o = {lines:[]};
		o.lineHeight = this.lineHeight || this.getMeasuredLineHeight();
		o.vOffset = o.lineHeight * Text.V_OFFSETS[this.textBaseline||"top"];
		return this._drawText(null, o, o.lines);
	};

	/**
	 * Returns a clone of the Text instance.
	 * @method clone
	 * @return {Text} a clone of the Text instance.
	 **/
	p.clone = function() {
		return this._cloneProps(new Text(this.text, this.font, this.color));
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Text (text="+  (this.text.length > 20 ? this.text.substr(0, 17)+"..." : this.text) +")]";
	};


// private methods:
	/**
	 * @method _cloneProps
	 * @param {Text} o
	 * @protected
	 * @return {Text} o
	 **/
	p._cloneProps = function(o) {
		this.DisplayObject__cloneProps(o);
		o.textAlign = this.textAlign;
		o.textBaseline = this.textBaseline;
		o.maxWidth = this.maxWidth;
		o.outline = this.outline;
		o.lineHeight = this.lineHeight;
		o.lineWidth = this.lineWidth;
		return o;
	};

	/**
	 * @method _getWorkingContext
	 * @param {CanvasRenderingContext2D} ctx
	 * @return {CanvasRenderingContext2D}
	 * @protected
	 **/
	p._prepContext = function(ctx) {
		ctx.font = this.font||"10px sans-serif";
		ctx.textAlign = this.textAlign||"left";
		ctx.textBaseline = this.textBaseline||"top";
		return ctx;
	};

	/**
	 * Draws multiline text.
	 * @method _drawText
	 * @param {CanvasRenderingContext2D} ctx
	 * @param {Object} o
	 * @param {Array} lines
	 * @return {Object}
	 * @protected
	 **/
	p._drawText = function(ctx, o, lines) {
		var paint = !!ctx;
		if (!paint) {
			ctx = Text._workingContext;
			ctx.save();
			this._prepContext(ctx);
		}
		var lineHeight = this.lineHeight||this.getMeasuredLineHeight();
		
		var maxW = 0, count = 0;
		var hardLines = String(this.text).split(/(?:\r\n|\r|\n)/);
		for (var i=0, l=hardLines.length; i<l; i++) {
			var str = hardLines[i];
			var w = null;
			
			if (this.lineWidth != null && (w = ctx.measureText(str).width) > this.lineWidth) {
				// text wrapping:
				var words = str.split(/(\s)/);
				str = words[0];
				w = ctx.measureText(str).width;
				
				for (var j=1, jl=words.length; j<jl; j+=2) {
					// Line needs to wrap:
					var wordW = ctx.measureText(words[j] + words[j+1]).width;
					if (w + wordW > this.lineWidth) {
						if (paint) { this._drawTextLine(ctx, str, count*lineHeight); }
						if (lines) { lines.push(str); }
						if (w > maxW) { maxW = w; }
						str = words[j+1];
						w = ctx.measureText(str).width;
						count++;
					} else {
						str += words[j] + words[j+1];
						w += wordW;
					}
				}
			}
			
			if (paint) { this._drawTextLine(ctx, str, count*lineHeight); }
			if (lines) { lines.push(str); }
			if (o && w == null) { w = ctx.measureText(str).width; }
			if (w > maxW) { maxW = w; }
			count++;
		}
		
		if (o) {
			o.width = maxW;
			o.height = count*lineHeight;
		}
		if (!paint) { ctx.restore(); }
		return o;
	};

	/**
	 * @method _drawTextLine
	 * @param {CanvasRenderingContext2D} ctx
	 * @param {String} text
	 * @param {Number} y
	 * @protected
	 **/
	p._drawTextLine = function(ctx, text, y) {
		// Chrome 17 will fail to draw the text if the last param is included but null, so we feed it a large value instead:
		if (this.outline) { ctx.strokeText(text, 0, y, this.maxWidth||0xFFFF); }
		else { ctx.fillText(text, 0, y, this.maxWidth||0xFFFF); }
	};
	
	
	/**
	 * @method _getMeasuredWidth
	 * @param {String} text
	 * @protected
	 **/
	p._getMeasuredWidth = function(text) {
		var ctx = Text._workingContext;
		ctx.save();
		var w = this._prepContext(ctx).measureText(text).width;
		ctx.restore();
		return w;
	};


	createjs.Text = createjs.promote(Text, "DisplayObject");
}());

//##############################################################################
// BitmapText.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";


// constructor:
	/**
	 * Displays text using bitmap glyphs defined in a sprite sheet. Multi-line text is supported
	 * using new line characters, but automatic wrapping is not supported. See the 
	 * {{#crossLink "BitmapText/spriteSheet:property"}}{{/crossLink}}
	 * property for more information on defining glyphs.
	 * 
	 * <strong>Important:</strong> BitmapText extends Container, but is not designed to be used as one.
	 * As such, methods like addChild and removeChild are disabled.
	 * @class BitmapText
	 * @extends DisplayObject
	 * @param {String} [text=""] The text to display.
	 * @param {SpriteSheet} [spriteSheet=null] The spritesheet that defines the character glyphs.
	 * @constructor
	 **/
	function BitmapText(text, spriteSheet) {
		this.Container_constructor();
		
		
	// public properties:
		/**
		 * The text to display.
		 * @property text
		 * @type String
		 * @default ""
		 **/
		this.text = text||"";
		
		/**
		 * A SpriteSheet instance that defines the glyphs for this bitmap text. Each glyph/character
		 * should have a single frame animation defined in the sprite sheet named the same as
		 * corresponding character. For example, the following animation definition:
		 *
		 * 		"A": {frames: [0]}
		 *
		 * would indicate that the frame at index 0 of the spritesheet should be drawn for the "A" character. The short form
		 * is also acceptable:
		 * 
		 * 		"A": 0
		 *
		 * Note that if a character in the text is not found in the sprite sheet, it will also
		 * try to use the alternate case (upper or lower).
		 *
		 * See SpriteSheet for more information on defining sprite sheet data.
		 * @property spriteSheet
		 * @type SpriteSheet
		 * @default null
		 **/
		this.spriteSheet = spriteSheet;
	
		/**
		 * The height of each line of text. If 0, then it will use a line height calculated
		 * by checking for the height of the "1", "T", or "L" character (in that order). If
		 * those characters are not defined, it will use the height of the first frame of the
		 * sprite sheet.
		 * @property lineHeight
		 * @type Number
		 * @default 0
		 **/
		this.lineHeight = 0;
	
		/**
		 * This spacing (in pixels) will be added after each character in the output.
		 * @property letterSpacing
		 * @type Number
		 * @default 0
		 **/
		this.letterSpacing = 0;
	
		/**
		 * If a space character is not defined in the sprite sheet, then empty pixels equal to
		 * spaceWidth will be inserted instead. If 0, then it will use a value calculated
		 * by checking for the width of the "1", "l", "E", or "A" character (in that order). If
		 * those characters are not defined, it will use the width of the first frame of the
		 * sprite sheet.
		 * @property spaceWidth
		 * @type Number
		 * @default 0
		 **/
		this.spaceWidth = 0;
		
		
	// private properties:
	 	/**
		 * @property _oldProps
		 * @type Object
		 * @protected
		 **/
		this._oldProps = {text:0,spriteSheet:0,lineHeight:0,letterSpacing:0,spaceWidth:0};
	}
	var p = createjs.extend(BitmapText, createjs.Container);

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.

// static properties:
	/**
	 * BitmapText uses Sprite instances to draw text. To reduce the creation and destruction of instances (and thus garbage collection), it maintains
	 * an internal object pool of sprite instances to reuse. Increasing this value can cause more sprites to be
	 * retained, slightly increasing memory use, but reducing instantiation.
	 * @property maxPoolSize
	 * @type Number
	 * @static
	 * @default 100
	 **/
	BitmapText.maxPoolSize = 100;
	
	/**
	 * Sprite object pool.
	 * @type {Array}
	 * @static
	 * @private
	 */
	BitmapText._spritePool = [];

	
// public methods:
	/**
	 * Docced in superclass.
	 **/
	p.draw = function(ctx, ignoreCache) {
		if (this.DisplayObject_draw(ctx, ignoreCache)) { return; }
		this._updateText();
		this.Container_draw(ctx, ignoreCache);
	};
	
	/**
	 * Docced in superclass.
	 **/
	p.getBounds = function() {
		this._updateText();
		return this.Container_getBounds();
	};
	
	/**
	 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
	 **/
	p.isVisible = function() {
		var hasContent = this.cacheCanvas || (this.spriteSheet && this.spriteSheet.complete && this.text);
		return !!(this.visible && this.alpha > 0 && this.scaleX !== 0 && this.scaleY !== 0 && hasContent);
	};
	
	p.clone = function() {
		return this._cloneProps(new BitmapText(this.text, this.spriteSheet));
	};
	
	/**
	 * <strong>Disabled in BitmapText.</strong>
	 * @method addChild
	 **/
	/**
	 * <strong>Disabled in BitmapText.</strong>
	 * @method addChildAt
	 **/
	/**
	 * <strong>Disabled in BitmapText.</strong>
	 * @method removeChild
	 **/
	/**
	 * <strong>Disabled in BitmapText.</strong>
	 * @method removeChildAt
	 **/
	/**
	 * <strong>Disabled in BitmapText.</strong>
	 * @method removeAllChildren
	 **/
	p.addChild = p.addChildAt = p.removeChild = p.removeChildAt = p.removeAllChildren = function() {};


// private methods:
 	/**
	 * @method _cloneProps
	 * @param {BitmapText} o
	 * @return {BitmapText} o
	 * @protected
	 **/
	p._cloneProps = function(o) {
		this.Container__cloneProps(o);
		o.lineHeight = this.lineHeight;
		o.letterSpacing = this.letterSpacing;
		o.spaceWidth = this.spaceWidth;
		return o;
	};
	
	/**
	 * @method _getFrameIndex
	 * @param {String} character
	 * @param {SpriteSheet} spriteSheet
	 * @return {Number}
	 * @protected
	 **/
	p._getFrameIndex = function(character, spriteSheet) {
		var c, o = spriteSheet.getAnimation(character);
		if (!o) {
			(character != (c = character.toUpperCase())) || (character != (c = character.toLowerCase())) || (c=null);
			if (c) { o = spriteSheet.getAnimation(c); }
		}
		return o && o.frames[0];
	};
	
	/**
	 * @method _getFrame
	 * @param {String} character
	 * @param {SpriteSheet} spriteSheet
	 * @return {Object}
	 * @protected
	 **/
	p._getFrame = function(character, spriteSheet) {
		var index = this._getFrameIndex(character, spriteSheet);
		return index == null ? index : spriteSheet.getFrame(index);
	};
	
	/**
	 * @method _getLineHeight
	 * @param {SpriteSheet} ss
	 * @return {Number}
	 * @protected
	 **/
	p._getLineHeight = function(ss) {
		var frame = this._getFrame("1",ss) || this._getFrame("T",ss) || this._getFrame("L",ss) || ss.getFrame(0);
		return frame ? frame.rect.height : 1;
	};
	/**
	 * @method _getSpaceWidth
	 * @param {SpriteSheet} ss
	 * @return {Number}
	 * @protected
	 **/
	p._getSpaceWidth = function(ss) {
		var frame = this._getFrame("1",ss) || this._getFrame("l",ss) || this._getFrame("e",ss) || this._getFrame("a",ss) || ss.getFrame(0);
		return frame ? frame.rect.width : 1;
	};
	
	/**
	 * @method _drawText
	 * @protected
	 **/
	p._updateText = function() {
		var x=0, y=0, o=this._oldProps, change=false, spaceW=this.spaceWidth, lineH=this.lineHeight, ss=this.spriteSheet;
		var pool=BitmapText._spritePool, kids=this.children, childIndex=0, numKids=kids.length, sprite;
		
		for (var n in o) {
			if (o[n] != this[n]) {
				o[n] = this[n];
				change = true;
			}
		}
		if (!change) { return; }
		
		var hasSpace = !!this._getFrame(" ", ss);
		if (!hasSpace && !spaceW) { spaceW = this._getSpaceWidth(ss); }
		if (!lineH) { lineH = this._getLineHeight(ss); }
		
		for(var i=0, l=this.text.length; i<l; i++) {
			var character = this.text.charAt(i);
			if (character == " " && !hasSpace) {
				x += spaceW;
				continue;
			} else if (character=="\n" || character=="\r") {
				if (character=="\r" && this.text.charAt(i+1) == "\n") { i++; } // crlf
				x = 0;
				y += lineH;
				continue;
			}

			var index = this._getFrameIndex(character, ss);
			if (index == null) { continue; }
			
			if (childIndex < numKids) {
				sprite = kids[childIndex];
			} else {
				kids.push(sprite = pool.length ? pool.pop() : new createjs.Sprite());
				sprite.parent = this;
				numKids++;
			}
			sprite.spriteSheet = ss;
			sprite.gotoAndStop(index);
			sprite.x = x;
			sprite.y = y;
			childIndex++;
			
			x += sprite.getBounds().width + this.letterSpacing;
		}
		while (numKids > childIndex) {
			 // faster than removeChild.
			pool.push(sprite = kids.pop());
			sprite.parent = null;
			numKids--;
		}
		if (pool.length > BitmapText.maxPoolSize) { pool.length = BitmapText.maxPoolSize; }
	};


	createjs.BitmapText = createjs.promote(BitmapText, "Container");
}());

//##############################################################################
// SpriteSheetUtils.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";
	
	
// constructor:
	/**
	 * The SpriteSheetUtils class is a collection of static methods for working with {{#crossLink "SpriteSheet"}}{{/crossLink}}s.
	 * A sprite sheet is a series of images (usually animation frames) combined into a single image on a regular grid. For
	 * example, an animation consisting of 8 100x100 images could be combined into a 400x200 sprite sheet (4 frames across
	 * by 2 high). The SpriteSheetUtils class uses a static interface and should not be instantiated.
	 * @class SpriteSheetUtils
	 * @static
	 **/
	function SpriteSheetUtils() {
		throw "SpriteSheetUtils cannot be instantiated";
	}


// private static properties:
	/**
	 * @property _workingCanvas
	 * @static
	 * @type HTMLCanvasElement | Object
	 * @protected
	*/
	/**
	 * @property _workingContext
	 * @static
	 * @type CanvasRenderingContext2D
	 * @protected
	*/
	var canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"));
	if (canvas.getContext) {
		SpriteSheetUtils._workingCanvas = canvas;
		SpriteSheetUtils._workingContext = canvas.getContext("2d");
		canvas.width = canvas.height = 1;
	}


// public static methods:
	/**
	 * <b>This is an experimental method, and may be buggy. Please report issues.</b><br/><br/>
	 * Extends the existing sprite sheet by flipping the original frames horizontally, vertically, or both,
	 * and adding appropriate animation & frame data. The flipped animations will have a suffix added to their names
	 * (_h, _v, _hv as appropriate). Make sure the sprite sheet images are fully loaded before using this method.
	 * <br/><br/>
	 * For example:<br/>
	 * SpriteSheetUtils.addFlippedFrames(mySpriteSheet, true, true);
	 * The above would add frames that are flipped horizontally AND frames that are flipped vertically.
	 * <br/><br/>
	 * Note that you can also flip any display object by setting its scaleX or scaleY to a negative value. On some
	 * browsers (especially those without hardware accelerated canvas) this can result in slightly degraded performance,
	 * which is why addFlippedFrames is available.
	 * @method addFlippedFrames
	 * @static
	 * @param {SpriteSheet} spriteSheet
	 * @param {Boolean} horizontal If true, horizontally flipped frames will be added.
	 * @param {Boolean} vertical If true, vertically flipped frames will be added.
	 * @param {Boolean} both If true, frames that are flipped both horizontally and vertically will be added.
	 * @deprecated Modern browsers perform better when flipping via a transform (ex. scaleX=-1) rendering this obsolete.
	 **/
	SpriteSheetUtils.addFlippedFrames = function(spriteSheet, horizontal, vertical, both) {
		if (!horizontal && !vertical && !both) { return; }

		var count = 0;
		if (horizontal) { SpriteSheetUtils._flip(spriteSheet,++count,true,false); }
		if (vertical) { SpriteSheetUtils._flip(spriteSheet,++count,false,true); }
		if (both) { SpriteSheetUtils._flip(spriteSheet,++count,true,true); }
	};

	/**
	 * Returns a single frame of the specified sprite sheet as a new PNG image. An example of when this may be useful is
	 * to use a spritesheet frame as the source for a bitmap fill.
	 *
	 * <strong>WARNING:</strong> In almost all cases it is better to display a single frame using a {{#crossLink "Sprite"}}{{/crossLink}}
	 * with a {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} call than it is to slice out a frame using this
	 * method and display it with a Bitmap instance. You can also crop an image using the {{#crossLink "Bitmap/sourceRect"}}{{/crossLink}}
	 * property of {{#crossLink "Bitmap"}}{{/crossLink}}.
	 *
	 * The extractFrame method may cause cross-domain warnings since it accesses pixels directly on the canvas.
	 * @method extractFrame
	 * @static
	 * @param {SpriteSheet} spriteSheet The SpriteSheet instance to extract a frame from.
	 * @param {Number|String} frameOrAnimation The frame number or animation name to extract. If an animation
	 * name is specified, only the first frame of the animation will be extracted.
	 * @return {HTMLImageElement} a single frame of the specified sprite sheet as a new PNG image.
	*/
	SpriteSheetUtils.extractFrame = function(spriteSheet, frameOrAnimation) {
		if (isNaN(frameOrAnimation)) {
			frameOrAnimation = spriteSheet.getAnimation(frameOrAnimation).frames[0];
		}
		var data = spriteSheet.getFrame(frameOrAnimation);
		if (!data) { return null; }
		var r = data.rect;
		var canvas = SpriteSheetUtils._workingCanvas;
		canvas.width = r.width;
		canvas.height = r.height;
		SpriteSheetUtils._workingContext.drawImage(data.image, r.x, r.y, r.width, r.height, 0, 0, r.width, r.height);
		var img = document.createElement("img");
		img.src = canvas.toDataURL("image/png");
		return img;
	};

	/**
	 * Merges the rgb channels of one image with the alpha channel of another. This can be used to combine a compressed
	 * JPEG image containing color data with a PNG32 monochromatic image containing alpha data. With certain types of
	 * images (those with detail that lend itself to JPEG compression) this can provide significant file size savings
	 * versus a single RGBA PNG32. This method is very fast (generally on the order of 1-2 ms to run).
	 * @method mergeAlpha
	 * @static
	 * @param {HTMLImageElement} rbgImage The image (or canvas) containing the RGB channels to use.
	 * @param {HTMLImageElement} alphaImage The image (or canvas) containing the alpha channel to use.
	 * @param {HTMLCanvasElement} canvas Optional. If specified, this canvas will be used and returned. If not, a new canvas will be created.
	 * @return {HTMLCanvasElement} A canvas with the combined image data. This can be used as a source for Bitmap or SpriteSheet.
	 * @deprecated Tools such as ImageAlpha generally provide better results. This will be moved to sandbox in the future.
	*/
	SpriteSheetUtils.mergeAlpha = function(rgbImage, alphaImage, canvas) {
		if (!canvas) { canvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"); }
		canvas.width = Math.max(alphaImage.width, rgbImage.width);
		canvas.height = Math.max(alphaImage.height, rgbImage.height);
		var ctx = canvas.getContext("2d");
		ctx.save();
		ctx.drawImage(rgbImage,0,0);
		ctx.globalCompositeOperation = "destination-in";
		ctx.drawImage(alphaImage,0,0);
		ctx.restore();
		return canvas;
	};


// private static methods:
	SpriteSheetUtils._flip = function(spriteSheet, count, h, v) {
		var imgs = spriteSheet._images;
		var canvas = SpriteSheetUtils._workingCanvas;
		var ctx = SpriteSheetUtils._workingContext;
		var il = imgs.length/count;
		for (var i=0;i<il;i++) {
			var src = imgs[i];
			src.__tmp = i; // a bit hacky, but faster than doing indexOf below.
			ctx.setTransform(1,0,0,1,0,0);
			ctx.clearRect(0,0,canvas.width+1,canvas.height+1);
			canvas.width = src.width;
			canvas.height = src.height;
			ctx.setTransform(h?-1:1, 0, 0, v?-1:1, h?src.width:0, v?src.height:0);
			ctx.drawImage(src,0,0);
			var img = document.createElement("img");
			img.src = canvas.toDataURL("image/png");
			// work around a strange bug in Safari:
			img.width = src.width;
			img.height = src.height;
			imgs.push(img);
		}

		var frames = spriteSheet._frames;
		var fl = frames.length/count;
		for (i=0;i<fl;i++) {
			src = frames[i];
			var rect = src.rect.clone();
			img = imgs[src.image.__tmp+il*count];

			var frame = {image:img,rect:rect,regX:src.regX,regY:src.regY};
			if (h) {
				rect.x = img.width-rect.x-rect.width; // update rect
				frame.regX = rect.width-src.regX; // update registration point
			}
			if (v) {
				rect.y = img.height-rect.y-rect.height;  // update rect
				frame.regY = rect.height-src.regY; // update registration point
			}
			frames.push(frame);
		}

		var sfx = "_"+(h?"h":"")+(v?"v":"");
		var names = spriteSheet._animations;
		var data = spriteSheet._data;
		var al = names.length/count;
		for (i=0;i<al;i++) {
			var name = names[i];
			src = data[name];
			var anim = {name:name+sfx,speed:src.speed,next:src.next,frames:[]};
			if (src.next) { anim.next += sfx; }
			frames = src.frames;
			for (var j=0,l=frames.length;j<l;j++) {
				anim.frames.push(frames[j]+fl*count);
			}
			data[anim.name] = anim;
			names.push(anim.name);
		}
	};


	createjs.SpriteSheetUtils = SpriteSheetUtils;
}());

//##############################################################################
// SpriteSheetBuilder.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * The SpriteSheetBuilder allows you to generate sprite sheets at run time from any display object. This can allow
	 * you to maintain your assets as vector graphics (for low file size), and render them at run time as sprite sheets
	 * for better performance.
	 *
	 * Sprite sheets can be built either synchronously, or asynchronously, so that large sprite sheets can be generated
	 * without locking the UI.
	 *
	 * Note that the "images" used in the generated sprite sheet are actually canvas elements, and that they will be sized
	 * to the nearest power of 2 up to the value of <code>maxWidth</code> or <code>maxHeight</code>.
	 * @class SpriteSheetBuilder
	 * @extends EventDispatcher
	 * @constructor
	 **/
	function SpriteSheetBuilder() {
		this.EventDispatcher_constructor();
		
	// public properties:
		/**
		 * The maximum width for the images (not individual frames) in the generated sprite sheet. It is recommended to use
		 * a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max dimensions, then
		 * additional images will be created as needed.
		 * @property maxWidth
		 * @type Number
		 * @default 2048
		*/
		this.maxWidth = 2048;
	
		/**
		 * The maximum height for the images (not individual frames) in the generated sprite sheet. It is recommended to use
		 * a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max dimensions, then
		 * additional images will be created as needed.
		 * @property maxHeight
		 * @type Number
		 * @default 2048
		 **/
		this.maxHeight = 2048;
	
		/**
		 * The sprite sheet that was generated. This will be null before a build is completed successfully.
		 * @property spriteSheet
		 * @type SpriteSheet
		 **/
		this.spriteSheet = null;
	
		/**
		 * The scale to apply when drawing all frames to the sprite sheet. This is multiplied against any scale specified
		 * in the addFrame call. This can be used, for example, to generate a sprite sheet at run time that is tailored to
		 * the a specific device resolution (ex. tablet vs mobile).
		 * @property scale
		 * @type Number
		 * @default 1
		 **/
		this.scale = 1;
	
		/**
		* The padding to use between frames. This is helpful to preserve antialiasing on drawn vector content.
		* @property padding
		* @type Number
		* @default 1
		**/
		this.padding = 1;
	
		/**
		 * A number from 0.01 to 0.99 that indicates what percentage of time the builder can use. This can be
		 * thought of as the number of seconds per second the builder will use. For example, with a timeSlice value of 0.3,
		 * the builder will run 20 times per second, using approximately 15ms per build (30% of available time, or 0.3s per second).
		 * Defaults to 0.3.
		 * @property timeSlice
		 * @type Number
		 * @default 0.3
		 **/
		this.timeSlice = 0.3;
	
		/**
		 * A value between 0 and 1 that indicates the progress of a build, or -1 if a build has not
		 * been initiated.
		 * @property progress
		 * @type Number
		 * @default -1
		 * @readonly
		 **/
		this.progress = -1;
	
	
	// private properties:
		/**
		 * @property _frames
		 * @protected
		 * @type Array
		 **/
		this._frames = [];
	
		/**
		 * @property _animations
		 * @protected
		 * @type Array
		 **/
		this._animations = {};
	
		/**
		 * @property _data
		 * @protected
		 * @type Array
		 **/
		this._data = null;
	
		/**
		 * @property _nextFrameIndex
		 * @protected
		 * @type Number
		 **/
		this._nextFrameIndex = 0;
	
		/**
		 * @property _index
		 * @protected
		 * @type Number
		 **/
		this._index = 0;
	
		/**
		 * @property _timerID
		 * @protected
		 * @type Number
		 **/
		this._timerID = null;
	
		/**
		 * @property _scale
		 * @protected
		 * @type Number
		 **/
		this._scale = 1;
	}
	var p = createjs.extend(SpriteSheetBuilder, createjs.EventDispatcher);

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// constants:
	SpriteSheetBuilder.ERR_DIMENSIONS = "frame dimensions exceed max spritesheet dimensions";
	SpriteSheetBuilder.ERR_RUNNING = "a build is already running";

// events:
	/**
	 * Dispatched when a build completes.
	 * @event complete
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @since 0.6.0
	 */

	/**
	 * Dispatched when an asynchronous build has progress.
	 * @event progress
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Number} progress The current progress value (0-1).
	 * @since 0.6.0
	 */


// public methods:
	/**
	 * Adds a frame to the {{#crossLink "SpriteSheet"}}{{/crossLink}}. Note that the frame will not be drawn until you
	 * call {{#crossLink "SpriteSheetBuilder/build"}}{{/crossLink}} method. The optional setup params allow you to have
	 * a function run immediately before the draw occurs. For example, this allows you to add a single source multiple
	 * times, but manipulate it or its children to change it to generate different frames.
	 *
	 * Note that the source's transformations (x, y, scale, rotate, alpha) will be ignored, except for regX/Y. To apply
	 * transforms to a source object and have them captured in the sprite sheet, simply place it into a {{#crossLink "Container"}}{{/crossLink}}
	 * and pass in the Container as the source.
	 * @method addFrame
	 * @param {DisplayObject} source The source {{#crossLink "DisplayObject"}}{{/crossLink}}  to draw as the frame.
	 * @param {Rectangle} [sourceRect] A {{#crossLink "Rectangle"}}{{/crossLink}} defining the portion of the
	 * source to draw to the frame. If not specified, it will look for a <code>getBounds</code> method, bounds property,
	 * or <code>nominalBounds</code> property on the source to use. If one is not found, the frame will be skipped.
	 * @param {Number} [scale=1] Optional. The scale to draw this frame at. Default is 1.
	 * @param {Function} [setupFunction] A function to call immediately before drawing this frame. It will be called with two parameters: the source, and setupData.
	 * @param {Object} [setupData] Arbitrary setup data to pass to setupFunction as the second parameter.
	 * @return {Number} The index of the frame that was just added, or null if a sourceRect could not be determined.
	 **/
	p.addFrame = function(source, sourceRect, scale, setupFunction, setupData) {
		if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
		var rect = sourceRect||source.bounds||source.nominalBounds;
		if (!rect&&source.getBounds) { rect = source.getBounds(); }
		if (!rect) { return null; }
		scale = scale||1;
		return this._frames.push({source:source, sourceRect:rect, scale:scale, funct:setupFunction, data:setupData, index:this._frames.length, height:rect.height*scale})-1;
	};

	/**
	 * Adds an animation that will be included in the created sprite sheet.
	 * @method addAnimation
	 * @param {String} name The name for the animation.
	 * @param {Array} frames An array of frame indexes that comprise the animation. Ex. [3,6,5] would describe an animation
	 * that played frame indexes 3, 6, and 5 in that order.
	 * @param {String} [next] Specifies the name of the animation to continue to after this animation ends. You can
	 * also pass false to have the animation stop when it ends. By default it will loop to the start of the same animation.
	 * @param {Number} [frequency] Specifies a frame advance frequency for this animation. For example, a value
	 * of 2 would cause the animation to advance every second tick.
	 **/
	p.addAnimation = function(name, frames, next, frequency) {
		if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
		this._animations[name] = {frames:frames, next:next, frequency:frequency};
	};

	/**
	 * This will take a MovieClip instance, and add its frames and labels to this builder. Labels will be added as an animation
	 * running from the label index to the next label. For example, if there is a label named "foo" at frame 0 and a label
	 * named "bar" at frame 10, in a MovieClip with 15 frames, it will add an animation named "foo" that runs from frame
	 * index 0 to 9, and an animation named "bar" that runs from frame index 10 to 14.
	 *
	 * Note that this will iterate through the full MovieClip with actionsEnabled set to false, ending on the last frame.
	 * @method addMovieClip
	 * @param {MovieClip} source The source MovieClip instance to add to the sprite sheet.
	 * @param {Rectangle} [sourceRect] A {{#crossLink "Rectangle"}}{{/crossLink}} defining the portion of the source to
	 * draw to the frame. If not specified, it will look for a <code>getBounds</code> method, <code>frameBounds</code>
	 * Array, <code>bounds</code> property, or <code>nominalBounds</code> property on the source to use. If one is not
	 * found, the MovieClip will be skipped.
	 * @param {Number} [scale=1] The scale to draw the movie clip at.
	 * @param {Function} [setupFunction] A function to call immediately before drawing each frame. It will be called with three parameters: the source, setupData, and the frame index.
	 * @param {Object} [setupData] Arbitrary setup data to pass to setupFunction as the second parameter.
	 * @param {Function} [labelFunction] This method will be called for each movieclip label that is added with four parameters: the label name, the source movieclip instance, the starting frame index (in the movieclip timeline) and the end index. It must return a new name for the label/animation, or false to exclude the label.
	 **/
	p.addMovieClip = function(source, sourceRect, scale, setupFunction, setupData, labelFunction) {
		if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
		var rects = source.frameBounds;
		var rect = sourceRect||source.bounds||source.nominalBounds;
		if (!rect&&source.getBounds) { rect = source.getBounds(); }
		if (!rect && !rects) { return; }

		var i, l, baseFrameIndex = this._frames.length;
		var duration = source.timeline.duration;
		for (i=0; i<duration; i++) {
			var r = (rects&&rects[i]) ? rects[i] : rect;
			this.addFrame(source, r, scale, this._setupMovieClipFrame, {i:i, f:setupFunction, d:setupData});
		}
		var labels = source.timeline._labels;
		var lbls = [];
		for (var n in labels) {
			lbls.push({index:labels[n], label:n});
		}
		if (lbls.length) {
			lbls.sort(function(a,b){ return a.index-b.index; });
			for (i=0,l=lbls.length; i<l; i++) {
				var label = lbls[i].label;
				var start = baseFrameIndex+lbls[i].index;
				var end = baseFrameIndex+((i == l-1) ? duration : lbls[i+1].index);
				var frames = [];
				for (var j=start; j<end; j++) { frames.push(j); }
				if (labelFunction) {
					label = labelFunction(label, source, start, end);
					if (!label) { continue; }
				}
				this.addAnimation(label, frames, true); // for now, this loops all animations.
			}
		}
	};

	/**
	 * Builds a SpriteSheet instance based on the current frames.
	 * @method build
	 * @return {SpriteSheet} The created SpriteSheet instance, or null if a build is already running or an error occurred.
	 **/
	p.build = function() {
		if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
		this._startBuild();
		while (this._drawNext()) {}
		this._endBuild();
		return this.spriteSheet;
	};

	/**
	 * Asynchronously builds a {{#crossLink "SpriteSheet"}}{{/crossLink}} instance based on the current frames. It will
	 * run 20 times per second, using an amount of time defined by <code>timeSlice</code>. When it is complete it will
	 * call the specified callback.
	 * @method buildAsync
	 * @param {Number} [timeSlice] Sets the timeSlice property on this instance.
	 **/
	p.buildAsync = function(timeSlice) {
		if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
		this.timeSlice = timeSlice;
		this._startBuild();
		var _this = this;
		this._timerID = setTimeout(function() { _this._run(); }, 50-Math.max(0.01, Math.min(0.99, this.timeSlice||0.3))*50);
	};

	/**
	 * Stops the current asynchronous build.
	 * @method stopAsync
	 **/
	p.stopAsync = function() {
		clearTimeout(this._timerID);
		this._data = null;
	};

	/**
	 * SpriteSheetBuilder instances cannot be cloned.
	 * @method clone
	 **/
	p.clone = function() {
		throw("SpriteSheetBuilder cannot be cloned.");
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[SpriteSheetBuilder]";
	};


// private methods:
	/**
	 * @method _startBuild
	 * @protected
	 **/
	p._startBuild = function() {
		var pad = this.padding||0;
		this.progress = 0;
		this.spriteSheet = null;
		this._index = 0;
		this._scale = this.scale;
		var dataFrames = [];
		this._data = {
			images: [],
			frames: dataFrames,
			animations: this._animations // TODO: should we "clone" _animations in case someone adds more animations after a build?
		};

		var frames = this._frames.slice();
		frames.sort(function(a,b) { return (a.height<=b.height) ? -1 : 1; });

		if (frames[frames.length-1].height+pad*2 > this.maxHeight) { throw SpriteSheetBuilder.ERR_DIMENSIONS; }
		var y=0, x=0;
		var img = 0;
		while (frames.length) {
			var o = this._fillRow(frames, y, img, dataFrames, pad);
			if (o.w > x) { x = o.w; }
			y += o.h;
			if (!o.h || !frames.length) {
				var canvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");
				canvas.width = this._getSize(x,this.maxWidth);
				canvas.height = this._getSize(y,this.maxHeight);
				this._data.images[img] = canvas;
				if (!o.h) {
					x=y=0;
					img++;
				}
			}
		}
	};
	
	/**
	 * @method _setupMovieClipFrame
	 * @protected
	 * @return {Number} The width & height of the row.
	 **/
	p._setupMovieClipFrame = function(source, data) {
		var ae = source.actionsEnabled;
		source.actionsEnabled = false;
		source.gotoAndStop(data.i);
		source.actionsEnabled = ae;
		data.f&&data.f(source, data.d, data.i);
	};

	/**
	 * @method _getSize
	 * @protected
	 * @return {Number} The width & height of the row.
	 **/
	p._getSize = function(size,max) {
		var pow = 4;
		while (Math.pow(2,++pow) < size){}
		return Math.min(max,Math.pow(2,pow));
	};

	/**
	 * @method _fillRow
	 * @param {Array} frames
	 * @param {Number} y
	 * @param {HTMLImageElement} img
	 * @param {Object} dataFrames
	 * @param {Number} pad
	 * @protected
	 * @return {Number} The width & height of the row.
	 **/
	p._fillRow = function(frames, y, img, dataFrames, pad) {
		var w = this.maxWidth;
		var maxH = this.maxHeight;
		y += pad;
		var h = maxH-y;
		var x = pad;
		var height = 0;
		for (var i=frames.length-1; i>=0; i--) {
			var frame = frames[i];
			var sc = this._scale*frame.scale;
			var rect = frame.sourceRect;
			var source = frame.source;
			var rx = Math.floor(sc*rect.x-pad);
			var ry = Math.floor(sc*rect.y-pad);
			var rh = Math.ceil(sc*rect.height+pad*2);
			var rw = Math.ceil(sc*rect.width+pad*2);
			if (rw > w) { throw SpriteSheetBuilder.ERR_DIMENSIONS; }
			if (rh > h || x+rw > w) { continue; }
			frame.img = img;
			frame.rect = new createjs.Rectangle(x,y,rw,rh);
			height = height || rh;
			frames.splice(i,1);
			dataFrames[frame.index] = [x,y,rw,rh,img,Math.round(-rx+sc*source.regX-pad),Math.round(-ry+sc*source.regY-pad)];
			x += rw;
		}
		return {w:x, h:height};
	};

	/**
	 * @method _endBuild
	 * @protected
	 **/
	p._endBuild = function() {
		this.spriteSheet = new createjs.SpriteSheet(this._data);
		this._data = null;
		this.progress = 1;
		this.dispatchEvent("complete");
	};

	/**
	 * @method _run
	 * @protected
	 **/
	p._run = function() {
		var ts = Math.max(0.01, Math.min(0.99, this.timeSlice||0.3))*50;
		var t = (new Date()).getTime()+ts;
		var complete = false;
		while (t > (new Date()).getTime()) {
			if (!this._drawNext()) { complete = true; break; }
		}
		if (complete) {
			this._endBuild();
		} else {
			var _this = this;
			this._timerID = setTimeout(function() { _this._run(); }, 50-ts);
		}
		var p = this.progress = this._index/this._frames.length;
		if (this.hasEventListener("progress")) {
			var evt = new createjs.Event("progress");
			evt.progress = p;
			this.dispatchEvent(evt);
		}
	};

	/**
	 * @method _drawNext
	 * @protected
	 * @return Boolean Returns false if this is the last draw.
	 **/
	p._drawNext = function() {
		var frame = this._frames[this._index];
		var sc = frame.scale*this._scale;
		var rect = frame.rect;
		var sourceRect = frame.sourceRect;
		var canvas = this._data.images[frame.img];
		var ctx = canvas.getContext("2d");
		frame.funct&&frame.funct(frame.source, frame.data);
		ctx.save();
		ctx.beginPath();
		ctx.rect(rect.x, rect.y, rect.width, rect.height);
		ctx.clip();
		ctx.translate(Math.ceil(rect.x-sourceRect.x*sc), Math.ceil(rect.y-sourceRect.y*sc));
		ctx.scale(sc,sc);
		frame.source.draw(ctx); // display object will draw itself.
		ctx.restore();
		return (++this._index) < this._frames.length;
	};


	createjs.SpriteSheetBuilder = createjs.promote(SpriteSheetBuilder, "EventDispatcher");
}());

//##############################################################################
// DOMElement.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * <b>This class is still experimental, and more advanced use is likely to be buggy. Please report bugs.</b>
	 *
	 * A DOMElement allows you to associate a HTMLElement with the display list. It will be transformed
	 * within the DOM as though it is child of the {{#crossLink "Container"}}{{/crossLink}} it is added to. However, it is
	 * not rendered to canvas, and as such will retain whatever z-index it has relative to the canvas (ie. it will be
	 * drawn in front of or behind the canvas).
	 *
	 * The position of a DOMElement is relative to their parent node in the DOM. It is recommended that
	 * the DOM Object be added to a div that also contains the canvas so that they share the same position
	 * on the page.
	 *
	 * DOMElement is useful for positioning HTML elements over top of canvas content, and for elements
	 * that you want to display outside the bounds of the canvas. For example, a tooltip with rich HTML
	 * content.
	 *
	 * <h4>Mouse Interaction</h4>
	 *
	 * DOMElement instances are not full EaselJS display objects, and do not participate in EaselJS mouse
	 * events or support methods like hitTest. To get mouse events from a DOMElement, you must instead add handlers to
	 * the htmlElement (note, this does not support EventDispatcher)
	 *
	 *      var domElement = new createjs.DOMElement(htmlElement);
	 *      domElement.htmlElement.onclick = function() {
	 *          console.log("clicked");
	 *      }
	 *
	 * @class DOMElement
	 * @extends DisplayObject
	 * @constructor
	 * @param {HTMLElement} htmlElement A reference or id for the DOM element to manage.
	 */
	function DOMElement(htmlElement) {
		this.DisplayObject_constructor();
		
		if (typeof(htmlElement)=="string") { htmlElement = document.getElementById(htmlElement); }
		this.mouseEnabled = false;
		
		var style = htmlElement.style;
		style.position = "absolute";
		style.transformOrigin = style.WebkitTransformOrigin = style.msTransformOrigin = style.MozTransformOrigin = style.OTransformOrigin = "0% 0%";
		
		
	// public properties:
		/**
		 * The DOM object to manage.
		 * @property htmlElement
		 * @type HTMLElement
		 */
		this.htmlElement = htmlElement;
	
	
	// private properties:
		/**
		 * @property _oldMtx
		 * @type Matrix2D
		 * @protected
		 */
		this._oldProps = null;
	}
	var p = createjs.extend(DOMElement, createjs.DisplayObject);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// public methods:
	/**
	 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
	 */
	p.isVisible = function() {
		return this.htmlElement != null;
	};

	/**
	 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
	 * Returns true if the draw was handled (useful for overriding functionality).
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.
	 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
	 * into itself).
	 * @return {Boolean}
	 */
	p.draw = function(ctx, ignoreCache) {
		// this relies on the _tick method because draw isn't called if the parent is not visible.
		// the actual update happens in _handleDrawEnd
		return true;
	};

	/**
	 * Not applicable to DOMElement.
	 * @method cache
	 */
	p.cache = function() {};

	/**
	 * Not applicable to DOMElement.
	 * @method uncache
	 */
	p.uncache = function() {};

	/**
	 * Not applicable to DOMElement.
	 * @method updateCache
	 */
	p.updateCache = function() {};

	/**
	 * Not applicable to DOMElement.
	 * @method hitTest
	 */
	p.hitTest = function() {};

	/**
	 * Not applicable to DOMElement.
	 * @method localToGlobal
	 */
	p.localToGlobal = function() {};

	/**
	 * Not applicable to DOMElement.
	 * @method globalToLocal
	 */
	p.globalToLocal = function() {};

	/**
	 * Not applicable to DOMElement.
	 * @method localToLocal
	 */
	p.localToLocal = function() {};

	/**
	 * DOMElement cannot be cloned. Throws an error.
	 * @method clone
	 */
	p.clone = function() {
		throw("DOMElement cannot be cloned.")
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 */
	p.toString = function() {
		return "[DOMElement (name="+  this.name +")]";
	};

	/**
     * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances
	 * are not full EaselJS display objects and do not participate in EaselJS mouse events.
	 * @event click
	 */

     /**
     * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances
 	 * are not full EaselJS display objects and do not participate in EaselJS mouse events.
	 * @event dblClick
	 */

     /**
      * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances
 	  * are not full EaselJS display objects and do not participate in EaselJS mouse events.
	  * @event mousedown
	  */

     /**
      * The HTMLElement can listen for the mouseover event, not the DOMElement instance.
      * Since DOMElement instances are not full EaselJS display objects and do not participate in EaselJS mouse events.
      * @event mouseover
	  */

     /**
      * Not applicable to DOMElement.
	  * @event tick
	  */


// private methods:
	/**
	 * @method _tick
	 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
	 * function.
	 * @protected
	 */
	p._tick = function(evtObj) {
		var stage = this.getStage();
		stage&&stage.on("drawend", this._handleDrawEnd, this, true);
		this.DisplayObject__tick(evtObj);
	};
	
	/**
	 * @method _handleDrawEnd
	 * @param {Event} evt
	 * @protected
	 */
	p._handleDrawEnd = function(evt) {
		var o = this.htmlElement;
		if (!o) { return; }
		var style = o.style;
		
		var props = this.getConcatenatedDisplayProps(this._props), mtx = props.matrix;
		
		var visibility = props.visible ? "visible" : "hidden";
		if (visibility != style.visibility) { style.visibility = visibility; }
		if (!props.visible) { return; }
		
		var oldProps = this._oldProps, oldMtx = oldProps&&oldProps.matrix;
		var n = 10000; // precision
		
		if (!oldMtx || !oldMtx.equals(mtx)) {
			var str = "matrix(" + (mtx.a*n|0)/n +","+ (mtx.b*n|0)/n +","+ (mtx.c*n|0)/n +","+ (mtx.d*n|0)/n +","+ (mtx.tx+0.5|0);
			style.transform = style.WebkitTransform = style.OTransform = style.msTransform = str +","+ (mtx.ty+0.5|0) +")";
			style.MozTransform = str +"px,"+ (mtx.ty+0.5|0) +"px)";
			if (!oldProps) { oldProps = this._oldProps = new createjs.DisplayProps(true, NaN); }
			oldProps.matrix.copy(mtx);
		}
		
		if (oldProps.alpha != props.alpha) {
			style.opacity = ""+(props.alpha*n|0)/n;
			oldProps.alpha = props.alpha;
		}
	};


	createjs.DOMElement = createjs.promote(DOMElement, "DisplayObject");
}());

//##############################################################################
// Filter.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Base class that all filters should inherit from. Filters need to be applied to objects that have been cached using
	 * the {{#crossLink "DisplayObject/cache"}}{{/crossLink}} method. If an object changes, please cache it again, or use
	 * {{#crossLink "DisplayObject/updateCache"}}{{/crossLink}}. Note that the filters must be applied before caching.
	 *
	 * <h4>Example</h4>
	 *
	 *      myInstance.filters = [
	 *          new createjs.ColorFilter(0, 0, 0, 1, 255, 0, 0),
	 *          new createjs.BlurFilter(5, 5, 10)
	 *      ];
	 *      myInstance.cache(0,0, 100, 100);
	 *
	 * Note that each filter can implement a {{#crossLink "Filter/getBounds"}}{{/crossLink}} method, which returns the
	 * margins that need to be applied in order to fully display the filter. For example, the {{#crossLink "BlurFilter"}}{{/crossLink}}
	 * will cause an object to feather outwards, resulting in a margin around the shape.
	 *
	 * <h4>EaselJS Filters</h4>
	 * EaselJS comes with a number of pre-built filters. Note that individual filters are not compiled into the minified
	 * version of EaselJS. To use them, you must include them manually in the HTML.
	 * <ul><li>{{#crossLink "AlphaMapFilter"}}{{/crossLink}} : Map a greyscale image to the alpha channel of a display object</li>
	 *      <li>{{#crossLink "AlphaMaskFilter"}}{{/crossLink}}: Map an image's alpha channel to the alpha channel of a display object</li>
	 *      <li>{{#crossLink "BlurFilter"}}{{/crossLink}}: Apply vertical and horizontal blur to a display object</li>
	 *      <li>{{#crossLink "ColorFilter"}}{{/crossLink}}: Color transform a display object</li>
	 *      <li>{{#crossLink "ColorMatrixFilter"}}{{/crossLink}}: Transform an image using a {{#crossLink "ColorMatrix"}}{{/crossLink}}</li>
	 * </ul>
	 *
	 * @class Filter
	 * @constructor
	 **/
	function Filter() {}
	var p = Filter.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// public methods:
	/**
	 * Provides padding values for this filter. That is, how much the filter will extend the visual bounds of an object it is applied to.
	 * @method getBounds
	 * @param {Rectangle} [rect] If specified, the provided Rectangle instance will be expanded by the padding amounts and returned.
	 * @return {Rectangle} If a `rect` param was provided, it is returned. If not, either a new rectangle with the padding values, or null if no padding is required for this filter.
	 **/
	p.getBounds = function(rect) {
		return rect;
	};

	/**
	 * Applies the filter to the specified context.
	 * @method applyFilter
	 * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.
	 * @param {Number} x The x position to use for the source rect.
	 * @param {Number} y The y position to use for the source rect.
	 * @param {Number} width The width to use for the source rect.
	 * @param {Number} height The height to use for the source rect.
	 * @param {CanvasRenderingContext2D} [targetCtx] The 2D context to draw the result to. Defaults to the context passed to ctx.
	 * @param {Number} [targetX] The x position to draw the result to. Defaults to the value passed to x.
	 * @param {Number} [targetY] The y position to draw the result to. Defaults to the value passed to y.
	 * @return {Boolean} If the filter was applied successfully.
	 **/
	p.applyFilter = function(ctx, x, y, width, height, targetCtx, targetX, targetY) {
		// this is the default behaviour because most filters access pixel data. It is overridden when not needed.
		targetCtx = targetCtx || ctx;
		if (targetX == null) { targetX = x; }
		if (targetY == null) { targetY = y; }
		try {
			var imageData = ctx.getImageData(x, y, width, height);
		} catch (e) {
			return false;
		}
		if (this._applyFilter(imageData)) {
			targetCtx.putImageData(imageData, targetX, targetY);
			return true;
		}
		return false;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Filter]";
	};

	/**
	 * Returns a clone of this Filter instance.
	 * @method clone
	 * @return {Filter} A clone of the current Filter instance.
	 **/
	p.clone = function() {
		return new Filter();
	};
	
// private methods:
	/**
	 * @method _applyFilter
	 * @param {ImageData} imageData Target ImageData instance.
	 * @return {Boolean}
	 **/
	p._applyFilter = function(imageData) { return true; };


	createjs.Filter = Filter;
}());

//##############################################################################
// BlurFilter.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Applies a box blur to DisplayObjects. Note that this filter is fairly CPU intensive, particularly if the quality is
	 * set higher than 1.
	 *
	 * <h4>Example</h4>
	 * This example creates a red circle, and then applies a 5 pixel blur to it. It uses the {{#crossLink "Filter/getBounds"}}{{/crossLink}}
	 * method to account for the spread that the blur causes.
	 *
	 *      var shape = new createjs.Shape().set({x:100,y:100});
	 *      shape.graphics.beginFill("#ff0000").drawCircle(0,0,50);
	 *
	 *      var blurFilter = new createjs.BlurFilter(5, 5, 1);
	 *      shape.filters = [blurFilter];
	 *      var bounds = blurFilter.getBounds();
	 *
	 *      shape.cache(-50+bounds.x, -50+bounds.y, 100+bounds.width, 100+bounds.height);
	 *
	 * See {{#crossLink "Filter"}}{{/crossLink}} for an more information on applying filters.
	 * @class BlurFilter
	 * @extends Filter
	 * @constructor
	 * @param {Number} [blurX=0] The horizontal blur radius in pixels.
	 * @param {Number} [blurY=0] The vertical blur radius in pixels.
	 * @param {Number} [quality=1] The number of blur iterations.
	 **/
	function BlurFilter( blurX, blurY, quality) {
		if ( isNaN(blurX) || blurX < 0 ) blurX = 0;
		if ( isNaN(blurY) || blurY < 0 ) blurY = 0;
		if ( isNaN(quality) || quality < 1  ) quality = 1;


		// public properties:
		/**
		 * Horizontal blur radius in pixels
		 * @property blurX
		 * @default 0
		 * @type Number
		 **/
		this.blurX = blurX | 0;

		/**
		 * Vertical blur radius in pixels
		 * @property blurY
		 * @default 0
		 * @type Number
		 **/
		this.blurY = blurY | 0;

		/**
		 * Number of blur iterations. For example, a value of 1 will produce a rough blur. A value of 2 will produce a
		 * smoother blur, but take twice as long to run.
		 * @property quality
		 * @default 1
		 * @type Number
		 **/
		this.quality = quality | 0;
	}
	var p = createjs.extend(BlurFilter, createjs.Filter);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// constants:
	/**
	 * Array of multiply values for blur calculations.
	 * @property MUL_TABLE
	 * @type Array
	 * @protected
	 * @static
	 **/
	BlurFilter.MUL_TABLE = [1, 171, 205, 293, 57, 373, 79, 137, 241, 27, 391, 357, 41, 19, 283, 265, 497, 469, 443, 421, 25, 191, 365, 349, 335, 161, 155, 149, 9, 278, 269, 261, 505, 245, 475, 231, 449, 437, 213, 415, 405, 395, 193, 377, 369, 361, 353, 345, 169, 331, 325, 319, 313, 307, 301, 37, 145, 285, 281, 69, 271, 267, 263, 259, 509, 501, 493, 243, 479, 118, 465, 459, 113, 446, 55, 435, 429, 423, 209, 413, 51, 403, 199, 393, 97, 3, 379, 375, 371, 367, 363, 359, 355, 351, 347, 43, 85, 337, 333, 165, 327, 323, 5, 317, 157, 311, 77, 305, 303, 75, 297, 294, 73, 289, 287, 71, 141, 279, 277, 275, 68, 135, 67, 133, 33, 262, 260, 129, 511, 507, 503, 499, 495, 491, 61, 121, 481, 477, 237, 235, 467, 232, 115, 457, 227, 451, 7, 445, 221, 439, 218, 433, 215, 427, 425, 211, 419, 417, 207, 411, 409, 203, 202, 401, 399, 396, 197, 49, 389, 387, 385, 383, 95, 189, 47, 187, 93, 185, 23, 183, 91, 181, 45, 179, 89, 177, 11, 175, 87, 173, 345, 343, 341, 339, 337, 21, 167, 83, 331, 329, 327, 163, 81, 323, 321, 319, 159, 79, 315, 313, 39, 155, 309, 307, 153, 305, 303, 151, 75, 299, 149, 37, 295, 147, 73, 291, 145, 289, 287, 143, 285, 71, 141, 281, 35, 279, 139, 69, 275, 137, 273, 17, 271, 135, 269, 267, 133, 265, 33, 263, 131, 261, 130, 259, 129, 257, 1];

	/**
	 * Array of shift values for blur calculations.
	 * @property SHG_TABLE
	 * @type Array
	 * @protected
	 * @static
	 **/
	BlurFilter.SHG_TABLE = [0, 9, 10, 11, 9, 12, 10, 11, 12, 9, 13, 13, 10, 9, 13, 13, 14, 14, 14, 14, 10, 13, 14, 14, 14, 13, 13, 13, 9, 14, 14, 14, 15, 14, 15, 14, 15, 15, 14, 15, 15, 15, 14, 15, 15, 15, 15, 15, 14, 15, 15, 15, 15, 15, 15, 12, 14, 15, 15, 13, 15, 15, 15, 15, 16, 16, 16, 15, 16, 14, 16, 16, 14, 16, 13, 16, 16, 16, 15, 16, 13, 16, 15, 16, 14, 9, 16, 16, 16, 16, 16, 16, 16, 16, 16, 13, 14, 16, 16, 15, 16, 16, 10, 16, 15, 16, 14, 16, 16, 14, 16, 16, 14, 16, 16, 14, 15, 16, 16, 16, 14, 15, 14, 15, 13, 16, 16, 15, 17, 17, 17, 17, 17, 17, 14, 15, 17, 17, 16, 16, 17, 16, 15, 17, 16, 17, 11, 17, 16, 17, 16, 17, 16, 17, 17, 16, 17, 17, 16, 17, 17, 16, 16, 17, 17, 17, 16, 14, 17, 17, 17, 17, 15, 16, 14, 16, 15, 16, 13, 16, 15, 16, 14, 16, 15, 16, 12, 16, 15, 16, 17, 17, 17, 17, 17, 13, 16, 15, 17, 17, 17, 16, 15, 17, 17, 17, 16, 15, 17, 17, 14, 16, 17, 17, 16, 17, 17, 16, 15, 17, 16, 14, 17, 16, 15, 17, 16, 17, 17, 16, 17, 15, 16, 17, 14, 17, 16, 15, 17, 16, 17, 13, 17, 16, 17, 17, 16, 17, 14, 17, 16, 17, 16, 17, 16, 17, 9];

// public methods:
	/** docced in super class **/
	p.getBounds = function (rect) {
		var x = this.blurX|0, y = this.blurY| 0;
		if (x <= 0 && y <= 0) { return rect; }
		var q = Math.pow(this.quality, 0.2);
		return (rect || new createjs.Rectangle()).pad(x*q+1,y*q+1,x*q+1,y*q+1);
	};

	/** docced in super class **/
	p.clone = function() {
		return new BlurFilter(this.blurX, this.blurY, this.quality);
	};

	/** docced in super class **/
	p.toString = function() {
		return "[BlurFilter]";
	};


// private methods:

	/** docced in super class **/
	p._applyFilter = function (imageData) {

		var radiusX = this.blurX >> 1;
		if (isNaN(radiusX) || radiusX < 0) return false;
		var radiusY = this.blurY >> 1;
		if (isNaN(radiusY) || radiusY < 0) return false;
		if (radiusX == 0 && radiusY == 0) return false;

		var iterations = this.quality;
		if (isNaN(iterations) || iterations < 1) iterations = 1;
		iterations |= 0;
		if (iterations > 3) iterations = 3;
		if (iterations < 1) iterations = 1;

		var px = imageData.data;
		var x=0, y=0, i=0, p=0, yp=0, yi=0, yw=0, r=0, g=0, b=0, a=0, pr=0, pg=0, pb=0, pa=0;

		var divx = (radiusX + radiusX + 1) | 0;
		var divy = (radiusY + radiusY + 1) | 0;
		var w = imageData.width | 0;
		var h = imageData.height | 0;

		var w1 = (w - 1) | 0;
		var h1 = (h - 1) | 0;
		var rxp1 = (radiusX + 1) | 0;
		var ryp1 = (radiusY + 1) | 0;

		var ssx = {r:0,b:0,g:0,a:0};
		var sx = ssx;
		for ( i = 1; i < divx; i++ )
		{
			sx = sx.n = {r:0,b:0,g:0,a:0};
		}
		sx.n = ssx;

		var ssy = {r:0,b:0,g:0,a:0};
		var sy = ssy;
		for ( i = 1; i < divy; i++ )
		{
			sy = sy.n = {r:0,b:0,g:0,a:0};
		}
		sy.n = ssy;

		var si = null;


		var mtx = BlurFilter.MUL_TABLE[radiusX] | 0;
		var stx = BlurFilter.SHG_TABLE[radiusX] | 0;
		var mty = BlurFilter.MUL_TABLE[radiusY] | 0;
		var sty = BlurFilter.SHG_TABLE[radiusY] | 0;

		while (iterations-- > 0) {

			yw = yi = 0;
			var ms = mtx;
			var ss = stx;
			for (y = h; --y > -1;) {
				r = rxp1 * (pr = px[(yi) | 0]);
				g = rxp1 * (pg = px[(yi + 1) | 0]);
				b = rxp1 * (pb = px[(yi + 2) | 0]);
				a = rxp1 * (pa = px[(yi + 3) | 0]);

				sx = ssx;

				for( i = rxp1; --i > -1; )
				{
					sx.r = pr;
					sx.g = pg;
					sx.b = pb;
					sx.a = pa;
					sx = sx.n;
				}

				for( i = 1; i < rxp1; i++ )
				{
					p = (yi + ((w1 < i ? w1 : i) << 2)) | 0;
					r += ( sx.r = px[p]);
					g += ( sx.g = px[p+1]);
					b += ( sx.b = px[p+2]);
					a += ( sx.a = px[p+3]);

					sx = sx.n;
				}

				si = ssx;
				for ( x = 0; x < w; x++ )
				{
					px[yi++] = (r * ms) >>> ss;
					px[yi++] = (g * ms) >>> ss;
					px[yi++] = (b * ms) >>> ss;
					px[yi++] = (a * ms) >>> ss;

					p = ((yw + ((p = x + radiusX + 1) < w1 ? p : w1)) << 2);

					r -= si.r - ( si.r = px[p]);
					g -= si.g - ( si.g = px[p+1]);
					b -= si.b - ( si.b = px[p+2]);
					a -= si.a - ( si.a = px[p+3]);

					si = si.n;

				}
				yw += w;
			}

			ms = mty;
			ss = sty;
			for (x = 0; x < w; x++) {
				yi = (x << 2) | 0;

				r = (ryp1 * (pr = px[yi])) | 0;
				g = (ryp1 * (pg = px[(yi + 1) | 0])) | 0;
				b = (ryp1 * (pb = px[(yi + 2) | 0])) | 0;
				a = (ryp1 * (pa = px[(yi + 3) | 0])) | 0;

				sy = ssy;
				for( i = 0; i < ryp1; i++ )
				{
					sy.r = pr;
					sy.g = pg;
					sy.b = pb;
					sy.a = pa;
					sy = sy.n;
				}

				yp = w;

				for( i = 1; i <= radiusY; i++ )
				{
					yi = ( yp + x ) << 2;

					r += ( sy.r = px[yi]);
					g += ( sy.g = px[yi+1]);
					b += ( sy.b = px[yi+2]);
					a += ( sy.a = px[yi+3]);

					sy = sy.n;

					if( i < h1 )
					{
						yp += w;
					}
				}

				yi = x;
				si = ssy;
				if ( iterations > 0 )
				{
					for ( y = 0; y < h; y++ )
					{
						p = yi << 2;
						px[p+3] = pa =(a * ms) >>> ss;
						if ( pa > 0 )
						{
							px[p]   = ((r * ms) >>> ss );
							px[p+1] = ((g * ms) >>> ss );
							px[p+2] = ((b * ms) >>> ss );
						} else {
							px[p] = px[p+1] = px[p+2] = 0
						}

						p = ( x + (( ( p = y + ryp1) < h1 ? p : h1 ) * w )) << 2;

						r -= si.r - ( si.r = px[p]);
						g -= si.g - ( si.g = px[p+1]);
						b -= si.b - ( si.b = px[p+2]);
						a -= si.a - ( si.a = px[p+3]);

						si = si.n;

						yi += w;
					}
				} else {
					for ( y = 0; y < h; y++ )
					{
						p = yi << 2;
						px[p+3] = pa =(a * ms) >>> ss;
						if ( pa > 0 )
						{
							pa = 255 / pa;
							px[p]   = ((r * ms) >>> ss ) * pa;
							px[p+1] = ((g * ms) >>> ss ) * pa;
							px[p+2] = ((b * ms) >>> ss ) * pa;
						} else {
							px[p] = px[p+1] = px[p+2] = 0
						}

						p = ( x + (( ( p = y + ryp1) < h1 ? p : h1 ) * w )) << 2;

						r -= si.r - ( si.r = px[p]);
						g -= si.g - ( si.g = px[p+1]);
						b -= si.b - ( si.b = px[p+2]);
						a -= si.a - ( si.a = px[p+3]);

						si = si.n;

						yi += w;
					}
				}
			}

		}
		return true;
	};

	createjs.BlurFilter = createjs.promote(BlurFilter, "Filter");
}());

//##############################################################################
// AlphaMapFilter.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";
	
	
// constructor:
	/**
	 * Applies a greyscale alpha map image (or canvas) to the target, such that the alpha channel of the result will
	 * be copied from the red channel of the map, and the RGB channels will be copied from the target.
	 *
	 * Generally, it is recommended that you use {{#crossLink "AlphaMaskFilter"}}{{/crossLink}}, because it has much
	 * better performance.
	 *
	 * <h4>Example</h4>
	 * This example draws a red->blue box, caches it, and then uses the cache canvas as an alpha map on a 100x100 image.
	 *
	 *       var box = new createjs.Shape();
	 *       box.graphics.beginLinearGradientFill(["#ff0000", "#0000ff"], [0, 1], 0, 0, 0, 100)
	 *       box.graphics.drawRect(0, 0, 100, 100);
	 *       box.cache(0, 0, 100, 100);
	 *
	 *       var bmp = new createjs.Bitmap("path/to/image.jpg");
	 *       bmp.filters = [
	 *           new createjs.AlphaMapFilter(box.cacheCanvas)
	 *       ];
	 *       bmp.cache(0, 0, 100, 100);
	 *       stage.addChild(bmp);
	 *
	 * See {{#crossLink "Filter"}}{{/crossLink}} for more information on applying filters.
	 * @class AlphaMapFilter
	 * @extends Filter
	 * @constructor
	 * @param {HTMLImageElement|HTMLCanvasElement} alphaMap The greyscale image (or canvas) to use as the alpha value for the
	 * result. This should be exactly the same dimensions as the target.
	 **/
	function AlphaMapFilter(alphaMap) {
	
	
	// public properties:
		/**
		 * The greyscale image (or canvas) to use as the alpha value for the result. This should be exactly the same
		 * dimensions as the target.
		 * @property alphaMap
		 * @type HTMLImageElement|HTMLCanvasElement
		 **/
		this.alphaMap = alphaMap;
		
		
	// private properties:
		/**
		 * @property _alphaMap
		 * @protected
		 * @type HTMLImageElement|HTMLCanvasElement
		 **/
		this._alphaMap = null;
		
		/**
		 * @property _mapData
		 * @protected
		 * @type Uint8ClampedArray
		 **/
		this._mapData = null;
	}
	var p = createjs.extend(AlphaMapFilter, createjs.Filter);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// public methods:
	/** docced in super class **/
	p.clone = function () {
		var o = new AlphaMapFilter(this.alphaMap);
		o._alphaMap = this._alphaMap;
		o._mapData = this._mapData;
		return o;
	};

	/** docced in super class **/
	p.toString = function () {
		return "[AlphaMapFilter]";
	};


// private methods:
	/** docced in super class **/
	p._applyFilter = function (imageData) {
		if (!this.alphaMap) { return true; }
		if (!this._prepAlphaMap()) { return false; }
		
		// TODO: update to support scenarios where the target has different dimensions.
		var data = imageData.data;
		var map = this._mapData;
		for(var i=0, l=data.length; i<l; i += 4) { data[i + 3] = map[i] || 0; }
		
		return true;
	};

	/**
	 * @method _prepAlphaMap
	 * @protected
	 **/
	p._prepAlphaMap = function () {
		if (!this.alphaMap) { return false; }
		if (this.alphaMap == this._alphaMap && this._mapData) { return true; }

		this._mapData = null;
		var map = this._alphaMap = this.alphaMap;
		var canvas = map;
		var ctx;
		if (map instanceof HTMLCanvasElement) {
			ctx = canvas.getContext("2d");
		} else {
			canvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement("canvas");
			canvas.width = map.width;
			canvas.height = map.height;
			ctx = canvas.getContext("2d");
			ctx.drawImage(map, 0, 0);
		}

		try {
			var imgData = ctx.getImageData(0, 0, map.width, map.height);
		} catch (e) {
			//if (!this.suppressCrossDomainErrors) throw new Error("unable to access local image data: " + e);
			return false;
		}
		
		this._mapData = imgData.data;
		return true;
	};


	createjs.AlphaMapFilter = createjs.promote(AlphaMapFilter, "Filter");
}());

//##############################################################################
// AlphaMaskFilter.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";


// constructor:
	/**
	 * Applies the alpha from the mask image (or canvas) to the target, such that the alpha channel of the result will
	 * be derived from the mask, and the RGB channels will be copied from the target. This can be used, for example, to
	 * apply an alpha mask to a display object. This can also be used to combine a JPG compressed RGB image with a PNG32
	 * alpha mask, which can result in a much smaller file size than a single PNG32 containing ARGB.
	 *
	 * <b>IMPORTANT NOTE: This filter currently does not support the targetCtx, or targetX/Y parameters correctly.</b>
	 *
	 * <h4>Example</h4>
	 * This example draws a gradient box, then caches it and uses the "cacheCanvas" as the alpha mask on a 100x100 image.
	 *
	 *      var box = new createjs.Shape();
	 *      box.graphics.beginLinearGradientFill(["#000000", "rgba(0, 0, 0, 0)"], [0, 1], 0, 0, 100, 100)
	 *      box.graphics.drawRect(0, 0, 100, 100);
	 *      box.cache(0, 0, 100, 100);
	 *
	 *      var bmp = new createjs.Bitmap("path/to/image.jpg");
	 *      bmp.filters = [
	 *          new createjs.AlphaMaskFilter(box.cacheCanvas)
	 *      ];
	 *      bmp.cache(0, 0, 100, 100);
	 *
	 * See {{#crossLink "Filter"}}{{/crossLink}} for more information on applying filters.
	 * @class AlphaMaskFilter
	 * @extends Filter
	 * @constructor
	 * @param {HTMLImageElement|HTMLCanvasElement} mask
	 **/
	function AlphaMaskFilter(mask) {
	
	
	// public properties:
		/**
		 * The image (or canvas) to use as the mask.
		 * @property mask
		 * @type HTMLImageElement|HTMLCanvasElement
		 **/
		this.mask = mask;
	}
	var p = createjs.extend(AlphaMaskFilter, createjs.Filter);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	

// public methods:
	/**
	 * Applies the filter to the specified context.
	 *
	 * <strong>IMPORTANT NOTE: This filter currently does not support the targetCtx, or targetX/Y parameters
	 * correctly.</strong>
	 * @method applyFilter
	 * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.
	 * @param {Number} x The x position to use for the source rect.
	 * @param {Number} y The y position to use for the source rect.
	 * @param {Number} width The width to use for the source rect.
	 * @param {Number} height The height to use for the source rect.
	 * @param {CanvasRenderingContext2D} [targetCtx] NOT SUPPORTED IN THIS FILTER. The 2D context to draw the result to. Defaults to the context passed to ctx.
	 * @param {Number} [targetX] NOT SUPPORTED IN THIS FILTER. The x position to draw the result to. Defaults to the value passed to x.
	 * @param {Number} [targetY] NOT SUPPORTED IN THIS FILTER. The y position to draw the result to. Defaults to the value passed to y.
	 * @return {Boolean} If the filter was applied successfully.
	 **/
	p.applyFilter = function (ctx, x, y, width, height, targetCtx, targetX, targetY) {
		if (!this.mask) { return true; }
		targetCtx = targetCtx || ctx;
		if (targetX == null) { targetX = x; }
		if (targetY == null) { targetY = y; }

		targetCtx.save();
		if (ctx != targetCtx) {
			// TODO: support targetCtx and targetX/Y
			// clearRect, then draw the ctx in?
			return false;
		}

		targetCtx.globalCompositeOperation = "destination-in";
		targetCtx.drawImage(this.mask, targetX, targetY);
		targetCtx.restore();
		return true;
	};

	/** docced in super class **/
	p.clone = function () {
		return new AlphaMaskFilter(this.mask);
	};

	/** docced in super class **/
	p.toString = function () {
		return "[AlphaMaskFilter]";
	};


	createjs.AlphaMaskFilter = createjs.promote(AlphaMaskFilter, "Filter");
}());

//##############################################################################
// ColorFilter.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Applies a color transform to DisplayObjects.
	 *
	 * <h4>Example</h4>
	 * This example draws a red circle, and then transforms it to Blue. This is accomplished by multiplying all the channels
	 * to 0 (except alpha, which is set to 1), and then adding 255 to the blue channel.
	 *
	 *      var shape = new createjs.Shape().set({x:100,y:100});
	 *      shape.graphics.beginFill("#ff0000").drawCircle(0,0,50);
	 *
	 *      shape.filters = [
	 *          new createjs.ColorFilter(0,0,0,1, 0,0,255,0)
	 *      ];
	 *      shape.cache(-50, -50, 100, 100);
	 *
	 * See {{#crossLink "Filter"}}{{/crossLink}} for an more information on applying filters.
	 * @class ColorFilter
	 * @param {Number} [redMultiplier=1] The amount to multiply against the red channel. This is a range between 0 and 1.
	 * @param {Number} [greenMultiplier=1] The amount to multiply against the green channel. This is a range between 0 and 1.
	 * @param {Number} [blueMultiplier=1] The amount to multiply against the blue channel. This is a range between 0 and 1.
	 * @param {Number} [alphaMultiplier=1] The amount to multiply against the alpha channel. This is a range between 0 and 1.
	 * @param {Number} [redOffset=0] The amount to add to the red channel after it has been multiplied. This is a range
	 * between -255 and 255.
	 * @param {Number} [greenOffset=0] The amount to add to the green channel after it has been multiplied. This is a range
	  * between -255 and 255.
	 * @param {Number} [blueOffset=0] The amount to add to the blue channel after it has been multiplied. This is a range
	  * between -255 and 255.
	 * @param {Number} [alphaOffset=0] The amount to add to the alpha channel after it has been multiplied. This is a range
	  * between -255 and 255.
	 * @constructor
	 * @extends Filter
	 **/
	function ColorFilter(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
		
	
	// public properties:
		/**
		 * Red channel multiplier.
		 * @property redMultiplier
		 * @type Number
		 **/
		this.redMultiplier = redMultiplier != null ? redMultiplier : 1;
	
		/**
		 * Green channel multiplier.
		 * @property greenMultiplier
		 * @type Number
		 **/
		this.greenMultiplier = greenMultiplier != null ? greenMultiplier : 1;
	
		/**
		 * Blue channel multiplier.
		 * @property blueMultiplier
		 * @type Number
		 **/
		this.blueMultiplier = blueMultiplier != null ? blueMultiplier : 1;
	
		/**
		 * Alpha channel multiplier.
		 * @property alphaMultiplier
		 * @type Number
		 **/
		this.alphaMultiplier = alphaMultiplier != null ? alphaMultiplier : 1;
	
		/**
		 * Red channel offset (added to value).
		 * @property redOffset
		 * @type Number
		 **/
		this.redOffset = redOffset || 0;
	
		/**
		 * Green channel offset (added to value).
		 * @property greenOffset
		 * @type Number
		 **/
		this.greenOffset = greenOffset || 0;
	
		/**
		 * Blue channel offset (added to value).
		 * @property blueOffset
		 * @type Number
		 **/
		this.blueOffset = blueOffset || 0;
	
		/**
		 * Alpha channel offset (added to value).
		 * @property alphaOffset
		 * @type Number
		 **/
		this.alphaOffset = alphaOffset || 0;
	}
	var p = createjs.extend(ColorFilter, createjs.Filter);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// public methods:
	/** docced in super class **/
	p.toString = function() {
		return "[ColorFilter]";
	};

	/** docced in super class **/
	p.clone = function() {
		return new ColorFilter(this.redMultiplier, this.greenMultiplier, this.blueMultiplier, this.alphaMultiplier, this.redOffset, this.greenOffset, this.blueOffset, this.alphaOffset);
	};
	

// private methods:
	/** docced in super class **/
	p._applyFilter = function(imageData) {
		var data = imageData.data;
		var l = data.length;
		for (var i=0; i<l; i+=4) {
			data[i] = data[i]*this.redMultiplier+this.redOffset;
			data[i+1] = data[i+1]*this.greenMultiplier+this.greenOffset;
			data[i+2] = data[i+2]*this.blueMultiplier+this.blueOffset;
			data[i+3] = data[i+3]*this.alphaMultiplier+this.alphaOffset;
		}
		return true;
	};


	createjs.ColorFilter = createjs.promote(ColorFilter, "Filter");
}());

//##############################################################################
// ColorMatrix.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Provides helper functions for assembling a matrix for use with the {{#crossLink "ColorMatrixFilter"}}{{/crossLink}}.
	 * Most methods return the instance to facilitate chained calls.
	 *
	 * <h4>Example</h4>
	 *
	 *      myColorMatrix.adjustHue(20).adjustBrightness(50);
	 *
	 * See {{#crossLink "Filter"}}{{/crossLink}} for an example of how to apply filters, or {{#crossLink "ColorMatrixFilter"}}{{/crossLink}}
	 * for an example of how to use ColorMatrix to change a DisplayObject's color.
	 * @class ColorMatrix
	 * @param {Number} brightness
	 * @param {Number} contrast
	 * @param {Number} saturation
	 * @param {Number} hue
	 * @constructor
	 **/
	function ColorMatrix(brightness, contrast, saturation, hue) {
		this.setColor(brightness, contrast, saturation, hue);
	}
	var p = ColorMatrix.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// constants:
	/**
	 * Array of delta values for contrast calculations.
	 * @property DELTA_INDEX
	 * @type Array
	 * @protected
	 * @static
	 **/
	ColorMatrix.DELTA_INDEX = [
		0,    0.01, 0.02, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1,  0.11,
		0.12, 0.14, 0.15, 0.16, 0.17, 0.18, 0.20, 0.21, 0.22, 0.24,
		0.25, 0.27, 0.28, 0.30, 0.32, 0.34, 0.36, 0.38, 0.40, 0.42,
		0.44, 0.46, 0.48, 0.5,  0.53, 0.56, 0.59, 0.62, 0.65, 0.68,
		0.71, 0.74, 0.77, 0.80, 0.83, 0.86, 0.89, 0.92, 0.95, 0.98,
		1.0,  1.06, 1.12, 1.18, 1.24, 1.30, 1.36, 1.42, 1.48, 1.54,
		1.60, 1.66, 1.72, 1.78, 1.84, 1.90, 1.96, 2.0,  2.12, 2.25,
		2.37, 2.50, 2.62, 2.75, 2.87, 3.0,  3.2,  3.4,  3.6,  3.8,
		4.0,  4.3,  4.7,  4.9,  5.0,  5.5,  6.0,  6.5,  6.8,  7.0,
		7.3,  7.5,  7.8,  8.0,  8.4,  8.7,  9.0,  9.4,  9.6,  9.8,
		10.0
	];

	/**
	 * Identity matrix values.
	 * @property IDENTITY_MATRIX
	 * @type Array
	 * @protected
	 * @static
	 **/
	ColorMatrix.IDENTITY_MATRIX = [
		1,0,0,0,0,
		0,1,0,0,0,
		0,0,1,0,0,
		0,0,0,1,0,
		0,0,0,0,1
	];

	/**
	 * The constant length of a color matrix.
	 * @property LENGTH
	 * @type Number
	 * @protected
	 * @static
	 **/
	ColorMatrix.LENGTH = ColorMatrix.IDENTITY_MATRIX.length;


// public methods:
	/**
	 * Resets the instance with the specified values.
	 * @method setColor
	 * @param {Number} brightness
	 * @param {Number} contrast
	 * @param {Number} saturation
	 * @param {Number} hue
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 */
	p.setColor = function(brightness,contrast,saturation,hue) {
		return this.reset().adjustColor(brightness,contrast,saturation,hue);
	};

	/**
	 * Resets the matrix to identity values.
	 * @method reset
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 */
	p.reset = function() {
		return this.copy(ColorMatrix.IDENTITY_MATRIX);
	};

	/**
	 * Shortcut method to adjust brightness, contrast, saturation and hue.
	 * Equivalent to calling adjustHue(hue), adjustContrast(contrast),
	 * adjustBrightness(brightness), adjustSaturation(saturation), in that order.
	 * @method adjustColor
	 * @param {Number} brightness
	 * @param {Number} contrast
	 * @param {Number} saturation
	 * @param {Number} hue
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.adjustColor = function(brightness,contrast,saturation,hue) {
		this.adjustHue(hue);
		this.adjustContrast(contrast);
		this.adjustBrightness(brightness);
		return this.adjustSaturation(saturation);
	};

	/**
	 * Adjusts the brightness of pixel color by adding the specified value to the red, green and blue channels.
	 * Positive values will make the image brighter, negative values will make it darker.
	 * @method adjustBrightness
	 * @param {Number} value A value between -255 & 255 that will be added to the RGB channels.
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.adjustBrightness = function(value) {
		if (value == 0 || isNaN(value)) { return this; }
		value = this._cleanValue(value,255);
		this._multiplyMatrix([
			1,0,0,0,value,
			0,1,0,0,value,
			0,0,1,0,value,
			0,0,0,1,0,
			0,0,0,0,1
		]);
		return this;
	};

	/**
	 * Adjusts the contrast of pixel color.
	 * Positive values will increase contrast, negative values will decrease contrast.
	 * @method adjustContrast
	 * @param {Number} value A value between -100 & 100.
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.adjustContrast = function(value) {
		if (value == 0 || isNaN(value)) { return this; }
		value = this._cleanValue(value,100);
		var x;
		if (value<0) {
			x = 127+value/100*127;
		} else {
			x = value%1;
			if (x == 0) {
				x = ColorMatrix.DELTA_INDEX[value];
			} else {
				x = ColorMatrix.DELTA_INDEX[(value<<0)]*(1-x)+ColorMatrix.DELTA_INDEX[(value<<0)+1]*x; // use linear interpolation for more granularity.
			}
			x = x*127+127;
		}
		this._multiplyMatrix([
			x/127,0,0,0,0.5*(127-x),
			0,x/127,0,0,0.5*(127-x),
			0,0,x/127,0,0.5*(127-x),
			0,0,0,1,0,
			0,0,0,0,1
		]);
		return this;
	};

	/**
	 * Adjusts the color saturation of the pixel.
	 * Positive values will increase saturation, negative values will decrease saturation (trend towards greyscale).
	 * @method adjustSaturation
	 * @param {Number} value A value between -100 & 100.
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.adjustSaturation = function(value) {
		if (value == 0 || isNaN(value)) { return this; }
		value = this._cleanValue(value,100);
		var x = 1+((value > 0) ? 3*value/100 : value/100);
		var lumR = 0.3086;
		var lumG = 0.6094;
		var lumB = 0.0820;
		this._multiplyMatrix([
			lumR*(1-x)+x,lumG*(1-x),lumB*(1-x),0,0,
			lumR*(1-x),lumG*(1-x)+x,lumB*(1-x),0,0,
			lumR*(1-x),lumG*(1-x),lumB*(1-x)+x,0,0,
			0,0,0,1,0,
			0,0,0,0,1
		]);
		return this;
	};


	/**
	 * Adjusts the hue of the pixel color.
	 * @method adjustHue
	 * @param {Number} value A value between -180 & 180.
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.adjustHue = function(value) {
		if (value == 0 || isNaN(value)) { return this; }
		value = this._cleanValue(value,180)/180*Math.PI;
		var cosVal = Math.cos(value);
		var sinVal = Math.sin(value);
		var lumR = 0.213;
		var lumG = 0.715;
		var lumB = 0.072;
		this._multiplyMatrix([
			lumR+cosVal*(1-lumR)+sinVal*(-lumR),lumG+cosVal*(-lumG)+sinVal*(-lumG),lumB+cosVal*(-lumB)+sinVal*(1-lumB),0,0,
			lumR+cosVal*(-lumR)+sinVal*(0.143),lumG+cosVal*(1-lumG)+sinVal*(0.140),lumB+cosVal*(-lumB)+sinVal*(-0.283),0,0,
			lumR+cosVal*(-lumR)+sinVal*(-(1-lumR)),lumG+cosVal*(-lumG)+sinVal*(lumG),lumB+cosVal*(1-lumB)+sinVal*(lumB),0,0,
			0,0,0,1,0,
			0,0,0,0,1
		]);
		return this;
	};

	/**
	 * Concatenates (multiplies) the specified matrix with this one.
	 * @method concat
	 * @param {Array} matrix An array or ColorMatrix instance.
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.concat = function(matrix) {
		matrix = this._fixMatrix(matrix);
		if (matrix.length != ColorMatrix.LENGTH) { return this; }
		this._multiplyMatrix(matrix);
		return this;
	};

	/**
	 * Returns a clone of this ColorMatrix.
	 * @method clone
	 * @return {ColorMatrix} A clone of this ColorMatrix.
	 **/
	p.clone = function() {
		return (new ColorMatrix()).copy(this);
	};

	/**
	 * Return a length 25 (5x5) array instance containing this matrix's values.
	 * @method toArray
	 * @return {Array} An array holding this matrix's values.
	 **/
	p.toArray = function() {
		var arr = [];
		for (var i= 0, l=ColorMatrix.LENGTH; i<l; i++) {
			arr[i] = this[i];
		}
		return arr;
	};

	/**
	 * Copy the specified matrix's values to this matrix.
	 * @method copy
	 * @param {Array} matrix An array or ColorMatrix instance.
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.copy = function(matrix) {
		var l = ColorMatrix.LENGTH;
		for (var i=0;i<l;i++) {
			this[i] = matrix[i];
		}
		return this;
	};
	
	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[ColorMatrix]";
	};


// private methods:
	/**
	 * @method _multiplyMatrix
	 * @param {Array} matrix
	 * @protected
	 **/
	p._multiplyMatrix = function(matrix) {
		var i, j, k, col = [];

		for (i=0;i<5;i++) {
			for (j=0;j<5;j++) {
				col[j] = this[j+i*5];
			}
			for (j=0;j<5;j++) {
				var val=0;
				for (k=0;k<5;k++) {
					val += matrix[j+k*5]*col[k];
				}
				this[j+i*5] = val;
			}
		}
	};

	/**
	 * Make sure values are within the specified range, hue has a limit of 180, brightness is 255, others are 100.
	 * @method _cleanValue
	 * @param {Number} value The raw number
	 * @param {Number} limit The maximum that the number can be. The minimum is the limit * -1.
	 * @protected
	 **/
	p._cleanValue = function(value, limit) {
		return Math.min(limit,Math.max(-limit,value));
	};

	/**
	 * Makes sure matrixes are 5x5 (25 long).
	 * @method _fixMatrix
	 * @param {Array} matrix
	 * @protected
	 **/
	p._fixMatrix = function(matrix) {
		if (matrix instanceof ColorMatrix) { matrix = matrix.toArray(); }
		if (matrix.length < ColorMatrix.LENGTH) {
			matrix = matrix.slice(0,matrix.length).concat(ColorMatrix.IDENTITY_MATRIX.slice(matrix.length,ColorMatrix.LENGTH));
		} else if (matrix.length > ColorMatrix.LENGTH) {
			matrix = matrix.slice(0,ColorMatrix.LENGTH);
		}
		return matrix;
	};


	createjs.ColorMatrix = ColorMatrix;
}());

//##############################################################################
// ColorMatrixFilter.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Allows you to carry out complex color operations such as modifying saturation, brightness, or inverting. See the
	 * {{#crossLink "ColorMatrix"}}{{/crossLink}} for more information on changing colors. For an easier color transform,
	 * consider the {{#crossLink "ColorFilter"}}{{/crossLink}}.
	 *
	 * <h4>Example</h4>
	 * This example creates a red circle, inverts its hue, and then saturates it to brighten it up.
	 *
	 *      var shape = new createjs.Shape().set({x:100,y:100});
	 *      shape.graphics.beginFill("#ff0000").drawCircle(0,0,50);
	 *
	 *      var matrix = new createjs.ColorMatrix().adjustHue(180).adjustSaturation(100);
	 *      shape.filters = [
	 *          new createjs.ColorMatrixFilter(matrix)
	 *      ];
	 *
	 *      shape.cache(-50, -50, 100, 100);
	 *
	 * See {{#crossLink "Filter"}}{{/crossLink}} for an more information on applying filters.
	 * @class ColorMatrixFilter
	 * @constructor
	 * @extends Filter
	 * @param {Array | ColorMatrix} matrix A 4x5 matrix describing the color operation to perform. See also the {{#crossLink "ColorMatrix"}}{{/crossLink}}
	 * class.
	 **/
	function ColorMatrixFilter(matrix) {
	
		
	// public properties:
		/**
		 * A 4x5 matrix describing the color operation to perform. See also the {{#crossLink "ColorMatrix"}}{{/crossLink}}
		 * @property matrix
		 * @type Array | ColorMatrix
		 **/
		this.matrix = matrix;
	}
	var p = createjs.extend(ColorMatrixFilter, createjs.Filter);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	

// public methods:
	/** docced in super class **/
	p.toString = function() {
		return "[ColorMatrixFilter]";
	};

	/** docced in super class **/
	p.clone = function() {
		return new ColorMatrixFilter(this.matrix);
	};

// private methods:
	/** docced in super class **/
	p._applyFilter = function(imageData) { 
		var data = imageData.data;
		var l = data.length;
		var r,g,b,a;
		var mtx = this.matrix;
		var m0 =  mtx[0],  m1 =  mtx[1],  m2 =  mtx[2],  m3 =  mtx[3],  m4 =  mtx[4];
		var m5 =  mtx[5],  m6 =  mtx[6],  m7 =  mtx[7],  m8 =  mtx[8],  m9 =  mtx[9];
		var m10 = mtx[10], m11 = mtx[11], m12 = mtx[12], m13 = mtx[13], m14 = mtx[14];
		var m15 = mtx[15], m16 = mtx[16], m17 = mtx[17], m18 = mtx[18], m19 = mtx[19];

		for (var i=0; i<l; i+=4) {
			r = data[i];
			g = data[i+1];
			b = data[i+2];
			a = data[i+3];
			data[i] = r*m0+g*m1+b*m2+a*m3+m4; // red
			data[i+1] = r*m5+g*m6+b*m7+a*m8+m9; // green
			data[i+2] = r*m10+g*m11+b*m12+a*m13+m14; // blue
			data[i+3] = r*m15+g*m16+b*m17+a*m18+m19; // alpha
		}
		return true;
	};


	createjs.ColorMatrixFilter = createjs.promote(ColorMatrixFilter, "Filter");
}());

//##############################################################################
// Touch.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
 * Global utility for working with multi-touch enabled devices in EaselJS. Currently supports W3C Touch API (iOS and
 * modern Android browser) and the Pointer API (IE), including ms-prefixed events in IE10, and unprefixed in IE11.
 *
 * Ensure that you {{#crossLink "Touch/disable"}}{{/crossLink}} touch when cleaning up your application. You do not have
 * to check if touch is supported to enable it, as it will fail gracefully if it is not supported.
 *
 * <h4>Example</h4>
 *
 *      var stage = new createjs.Stage("canvasId");
 *      createjs.Touch.enable(stage);
 *
 * <strong>Note:</strong> It is important to disable Touch on a stage that you are no longer using:
 *
 *      createjs.Touch.disable(stage);
 *
 * @class Touch
 * @static
 **/
	function Touch() {
		throw "Touch cannot be instantiated";
	}


// public static methods:
	/**
	 * Returns `true` if touch is supported in the current browser.
	 * @method isSupported
	 * @return {Boolean} Indicates whether touch is supported in the current browser.
	 * @static
	 **/
	Touch.isSupported = function() {
		return	!!(('ontouchstart' in window) // iOS & Android
			|| (window.navigator['msPointerEnabled'] && window.navigator['msMaxTouchPoints'] > 0) // IE10
			|| (window.navigator['pointerEnabled'] && window.navigator['maxTouchPoints'] > 0)); // IE11+
	};

	/**
	 * Enables touch interaction for the specified EaselJS {{#crossLink "Stage"}}{{/crossLink}}. Currently supports iOS
	 * (and compatible browsers, such as modern Android browsers), and IE10/11. Supports both single touch and
	 * multi-touch modes. Extends the EaselJS {{#crossLink "MouseEvent"}}{{/crossLink}} model, but without support for
	 * double click or over/out events. See the MouseEvent {{#crossLink "MouseEvent/pointerId:property"}}{{/crossLink}}
	 * for more information.
	 * @method enable
	 * @param {Stage} stage The {{#crossLink "Stage"}}{{/crossLink}} to enable touch on.
	 * @param {Boolean} [singleTouch=false] If `true`, only a single touch will be active at a time.
	 * @param {Boolean} [allowDefault=false] If `true`, then default gesture actions (ex. scrolling, zooming) will be
	 * allowed when the user is interacting with the target canvas.
	 * @return {Boolean} Returns `true` if touch was successfully enabled on the target stage.
	 * @static
	 **/
	Touch.enable = function(stage, singleTouch, allowDefault) {
		if (!stage || !stage.canvas || !Touch.isSupported()) { return false; }
		if (stage.__touch) { return true; }

		// inject required properties on stage:
		stage.__touch = {pointers:{}, multitouch:!singleTouch, preventDefault:!allowDefault, count:0};

		// note that in the future we may need to disable the standard mouse event model before adding
		// these to prevent duplicate calls. It doesn't seem to be an issue with iOS devices though.
		if ('ontouchstart' in window) { Touch._IOS_enable(stage); }
		else if (window.navigator['msPointerEnabled'] || window.navigator["pointerEnabled"]) { Touch._IE_enable(stage); }
		return true;
	};

	/**
	 * Removes all listeners that were set up when calling `Touch.enable()` on a stage.
	 * @method disable
	 * @param {Stage} stage The {{#crossLink "Stage"}}{{/crossLink}} to disable touch on.
	 * @static
	 **/
	Touch.disable = function(stage) {
		if (!stage) { return; }
		if ('ontouchstart' in window) { Touch._IOS_disable(stage); }
		else if (window.navigator['msPointerEnabled'] || window.navigator["pointerEnabled"]) { Touch._IE_disable(stage); }
		
		delete stage.__touch;
	};


// Private static methods:
	/**
	 * @method _IOS_enable
	 * @protected
	 * @param {Stage} stage
	 * @static
	 **/
	Touch._IOS_enable = function(stage) {
		var canvas = stage.canvas;
		var f = stage.__touch.f = function(e) { Touch._IOS_handleEvent(stage,e); };
		canvas.addEventListener("touchstart", f, false);
		canvas.addEventListener("touchmove", f, false);
		canvas.addEventListener("touchend", f, false);
		canvas.addEventListener("touchcancel", f, false);
	};

	/**
	 * @method _IOS_disable
	 * @protected
	 * @param {Stage} stage
	 * @static
	 **/
	Touch._IOS_disable = function(stage) {
		var canvas = stage.canvas;
		if (!canvas) { return; }
		var f = stage.__touch.f;
		canvas.removeEventListener("touchstart", f, false);
		canvas.removeEventListener("touchmove", f, false);
		canvas.removeEventListener("touchend", f, false);
		canvas.removeEventListener("touchcancel", f, false);
	};

	/**
	 * @method _IOS_handleEvent
	 * @param {Stage} stage
	 * @param {Object} e The event to handle
	 * @protected
	 * @static
	 **/
	Touch._IOS_handleEvent = function(stage, e) {
		if (!stage) { return; }
		if (stage.__touch.preventDefault) { e.preventDefault&&e.preventDefault(); }
		var touches = e.changedTouches;
		var type = e.type;
		for (var i= 0,l=touches.length; i<l; i++) {
			var touch = touches[i];
			var id = touch.identifier;
			if (touch.target != stage.canvas) { continue; }

			if (type == "touchstart") {
				this._handleStart(stage, id, e, touch.pageX, touch.pageY);
			} else if (type == "touchmove") {
				this._handleMove(stage, id, e, touch.pageX, touch.pageY);
			} else if (type == "touchend" || type == "touchcancel") {
				this._handleEnd(stage, id, e);
			}
		}
	};

	/**
	 * @method _IE_enable
	 * @protected
	 * @param {Stage} stage
	 * @static
	 **/
	Touch._IE_enable = function(stage) {
		var canvas = stage.canvas;
		var f = stage.__touch.f = function(e) { Touch._IE_handleEvent(stage,e); };

		if (window.navigator["pointerEnabled"] === undefined) {
			canvas.addEventListener("MSPointerDown", f, false);
			window.addEventListener("MSPointerMove", f, false);
			window.addEventListener("MSPointerUp", f, false);
			window.addEventListener("MSPointerCancel", f, false);
			if (stage.__touch.preventDefault) { canvas.style.msTouchAction = "none"; }
		} else {
			canvas.addEventListener("pointerdown", f, false);
			window.addEventListener("pointermove", f, false);
			window.addEventListener("pointerup", f, false);
			window.addEventListener("pointercancel", f, false);
			if (stage.__touch.preventDefault) { canvas.style.touchAction = "none"; }

		}
		stage.__touch.activeIDs = {};
	};

	/**
	 * @method _IE_disable
	 * @protected
	 * @param {Stage} stage
	 * @static
	 **/
	Touch._IE_disable = function(stage) {
		var f = stage.__touch.f;

		if (window.navigator["pointerEnabled"] === undefined) {
			window.removeEventListener("MSPointerMove", f, false);
			window.removeEventListener("MSPointerUp", f, false);
			window.removeEventListener("MSPointerCancel", f, false);
			if (stage.canvas) {
				stage.canvas.removeEventListener("MSPointerDown", f, false);
			}
		} else {
			window.removeEventListener("pointermove", f, false);
			window.removeEventListener("pointerup", f, false);
			window.removeEventListener("pointercancel", f, false);
			if (stage.canvas) {
				stage.canvas.removeEventListener("pointerdown", f, false);
			}
		}
	};

	/**
	 * @method _IE_handleEvent
	 * @param {Stage} stage
	 * @param {Object} e The event to handle.
	 * @protected
	 * @static
	 **/
	Touch._IE_handleEvent = function(stage, e) {
		if (!stage) { return; }
		if (stage.__touch.preventDefault) { e.preventDefault && e.preventDefault(); }
		var type = e.type;
		var id = e.pointerId;
		var ids = stage.__touch.activeIDs;

		if (type == "MSPointerDown" || type == "pointerdown") {
			if (e.srcElement != stage.canvas) { return; }
			ids[id] = true;
			this._handleStart(stage, id, e, e.pageX, e.pageY);
		} else if (ids[id]) { // it's an id we're watching
			if (type == "MSPointerMove" || type == "pointermove") {
				this._handleMove(stage, id, e, e.pageX, e.pageY);
			} else if (type == "MSPointerUp" || type == "MSPointerCancel"
					|| type == "pointerup" || type == "pointercancel") {
				delete(ids[id]);
				this._handleEnd(stage, id, e);
			}
		}
	};

	/**
	 * @method _handleStart
	 * @param {Stage} stage
	 * @param {String|Number} id
	 * @param {Object} e
	 * @param {Number} x
	 * @param {Number} y
	 * @protected
	 **/
	Touch._handleStart = function(stage, id, e, x, y) {
		var props = stage.__touch;
		if (!props.multitouch && props.count) { return; }
		var ids = props.pointers;
		if (ids[id]) { return; }
		ids[id] = true;
		props.count++;
		stage._handlePointerDown(id, e, x, y);
	};

	/**
	 * @method _handleMove
	 * @param {Stage} stage
	 * @param {String|Number} id
	 * @param {Object} e
	 * @param {Number} x
	 * @param {Number} y
	 * @protected
	 **/
	Touch._handleMove = function(stage, id, e, x, y) {
		if (!stage.__touch.pointers[id]) { return; }
		stage._handlePointerMove(id, e, x, y);
	};

	/**
	 * @method _handleEnd
	 * @param {Stage} stage
	 * @param {String|Number} id
	 * @param {Object} e
	 * @protected
	 **/
	Touch._handleEnd = function(stage, id, e) {
		// TODO: cancel should be handled differently for proper UI (ex. an up would trigger a click, a cancel would more closely resemble an out).
		var props = stage.__touch;
		var ids = props.pointers;
		if (!ids[id]) { return; }
		props.count--;
		stage._handlePointerUp(id, e, true);
		delete(ids[id]);
	};


	createjs.Touch = Touch;
}());

//##############################################################################
// version.js
//##############################################################################

this.createjs = this.createjs || {};

(function() {
	"use strict";

	/**
	 * Static class holding library specific information such as the version and buildDate of
	 * the library.
	 * @class EaselJS
	 **/
	var s = createjs.EaselJS = createjs.EaselJS || {};

	/**
	 * The version string for this release.
	 * @property version
	 * @type String
	 * @static
	 **/
	s.version = /*=version*/"0.8.1"; // injected by build process

	/**
	 * The build date for this release in UTC format.
	 * @property buildDate
	 * @type String
	 * @static
	 **/
	s.buildDate = /*=date*/"Thu, 21 May 2015 16:17:39 GMT"; // injected by build process

})();
/*!
* PreloadJS
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2010 gskinner.com, inc.
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/


//##############################################################################
// version.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	/**
	 * Static class holding library specific information such as the version and buildDate of the library.
	 * @class PreloadJS
	 **/
	var s = createjs.PreloadJS = createjs.PreloadJS || {};

	/**
	 * The version string for this release.
	 * @property version
	 * @type {String}
	 * @static
	 **/
	s.version = /*=version*/"0.6.1"; // injected by build process

	/**
	 * The build date for this release in UTC format.
	 * @property buildDate
	 * @type {String}
	 * @static
	 **/
	s.buildDate = /*=date*/"Thu, 21 May 2015 16:17:37 GMT"; // injected by build process

})();

//##############################################################################
// extend.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Sets up the prototype chain and constructor property for a new class.
 *
 * This should be called right after creating the class constructor.
 *
 * 	function MySubClass() {}
 * 	createjs.extend(MySubClass, MySuperClass);
 * 	ClassB.prototype.doSomething = function() { }
 *
 * 	var foo = new MySubClass();
 * 	console.log(foo instanceof MySuperClass); // true
 * 	console.log(foo.prototype.constructor === MySubClass); // true
 *
 * @method extend
 * @param {Function} subclass The subclass.
 * @param {Function} superclass The superclass to extend.
 * @return {Function} Returns the subclass's new prototype.
 */
createjs.extend = function(subclass, superclass) {
	"use strict";

	function o() { this.constructor = subclass; }
	o.prototype = superclass.prototype;
	return (subclass.prototype = new o());
};

//##############################################################################
// promote.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.
 * It is recommended to use the super class's name as the prefix.
 * An alias to the super class's constructor is always added in the format `prefix_constructor`.
 * This allows the subclass to call super class methods without using `function.call`, providing better performance.
 *
 * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, "MySuperClass")`
 * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the
 * prototype of `MySubClass` as `MySuperClass_draw`.
 *
 * This should be called after the class's prototype is fully defined.
 *
 * 	function ClassA(name) {
 * 		this.name = name;
 * 	}
 * 	ClassA.prototype.greet = function() {
 * 		return "Hello "+this.name;
 * 	}
 *
 * 	function ClassB(name, punctuation) {
 * 		this.ClassA_constructor(name);
 * 		this.punctuation = punctuation;
 * 	}
 * 	createjs.extend(ClassB, ClassA);
 * 	ClassB.prototype.greet = function() {
 * 		return this.ClassA_greet()+this.punctuation;
 * 	}
 * 	createjs.promote(ClassB, "ClassA");
 *
 * 	var foo = new ClassB("World", "!?!");
 * 	console.log(foo.greet()); // Hello World!?!
 *
 * @method promote
 * @param {Function} subclass The class to promote super class methods on.
 * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.
 * @return {Function} Returns the subclass.
 */
createjs.promote = function(subclass, prefix) {
	"use strict";

	var subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;
	if (supP) {
		subP[(prefix+="_") + "constructor"] = supP.constructor; // constructor is not always innumerable
		for (var n in supP) {
			if (subP.hasOwnProperty(n) && (typeof supP[n] == "function")) { subP[prefix + n] = supP[n]; }
		}
	}
	return subclass;
};

//##############################################################################
// indexOf.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of
 * that value.  Returns -1 if value is not found.
 *
 *      var i = createjs.indexOf(myArray, myElementToFind);
 *
 * @method indexOf
 * @param {Array} array Array to search for searchElement
 * @param searchElement Element to find in array.
 * @return {Number} The first index of searchElement in array.
 */
createjs.indexOf = function (array, searchElement){
	"use strict";

	for (var i = 0,l=array.length; i < l; i++) {
		if (searchElement === array[i]) {
			return i;
		}
	}
	return -1;
};

//##############################################################################
// proxy.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * Various utilities that the CreateJS Suite uses. Utilities are created as separate files, and will be available on the
 * createjs namespace directly.
 *
 * <h4>Example</h4>
 *
 *      myObject.addEventListener("change", createjs.proxy(myMethod, scope));
 *
 * @class Utility Methods
 * @main Utility Methods
 */

(function() {
	"use strict";

	/**
	 * A function proxy for methods. By default, JavaScript methods do not maintain scope, so passing a method as a
	 * callback will result in the method getting called in the scope of the caller. Using a proxy ensures that the
	 * method gets called in the correct scope.
	 *
	 * Additional arguments can be passed that will be applied to the function when it is called.
	 *
	 * <h4>Example</h4>
	 *
	 *      myObject.addEventListener("event", createjs.proxy(myHandler, this, arg1, arg2));
	 *
	 *      function myHandler(arg1, arg2) {
	 *           // This gets called when myObject.myCallback is executed.
	 *      }
	 *
	 * @method proxy
	 * @param {Function} method The function to call
	 * @param {Object} scope The scope to call the method name on
	 * @param {mixed} [arg] * Arguments that are appended to the callback for additional params.
	 * @public
	 * @static
	 */
	createjs.proxy = function (method, scope) {
		var aArgs = Array.prototype.slice.call(arguments, 2);
		return function () {
			return method.apply(scope, Array.prototype.slice.call(arguments, 0).concat(aArgs));
		};
	}

}());

//##############################################################################
// BrowserDetect.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */
(function() {
	"use strict";

	/**
	 * An object that determines the current browser, version, operating system, and other environment
	 * variables via user agent string.
	 *
	 * Used for audio because feature detection is unable to detect the many limitations of mobile devices.
	 *
	 * <h4>Example</h4>
	 *
	 *      if (createjs.BrowserDetect.isIOS) { // do stuff }
	 *
	 * @property BrowserDetect
	 * @type {Object}
	 * @param {Boolean} isFirefox True if our browser is Firefox.
	 * @param {Boolean} isOpera True if our browser is opera.
	 * @param {Boolean} isChrome True if our browser is Chrome.  Note that Chrome for Android returns true, but is a
	 * completely different browser with different abilities.
	 * @param {Boolean} isIOS True if our browser is safari for iOS devices (iPad, iPhone, and iPod).
	 * @param {Boolean} isAndroid True if our browser is Android.
	 * @param {Boolean} isBlackberry True if our browser is Blackberry.
	 * @constructor
	 * @static
	 */
	function BrowserDetect() {
		throw "BrowserDetect cannot be instantiated";
	}

	var agent = BrowserDetect.agent = window.navigator.userAgent;
	BrowserDetect.isWindowPhone = (agent.indexOf("IEMobile") > -1) || (agent.indexOf("Windows Phone") > -1);
	BrowserDetect.isFirefox = (agent.indexOf("Firefox") > -1);
	BrowserDetect.isOpera = (window.opera != null);
	BrowserDetect.isChrome = (agent.indexOf("Chrome") > -1);  // NOTE that Chrome on Android returns true but is a completely different browser with different abilities
	BrowserDetect.isIOS = (agent.indexOf("iPod") > -1 || agent.indexOf("iPhone") > -1 || agent.indexOf("iPad") > -1) && !BrowserDetect.isWindowPhone;
	BrowserDetect.isAndroid = (agent.indexOf("Android") > -1) && !BrowserDetect.isWindowPhone;
	BrowserDetect.isBlackberry = (agent.indexOf("Blackberry") > -1);

	createjs.BrowserDetect = BrowserDetect;

}());

//##############################################################################
// Event.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

// constructor:
	/**
	 * Contains properties and methods shared by all events for use with
	 * {{#crossLink "EventDispatcher"}}{{/crossLink}}.
	 * 
	 * Note that Event objects are often reused, so you should never
	 * rely on an event object's state outside of the call stack it was received in.
	 * @class Event
	 * @param {String} type The event type.
	 * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
	 * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
	 * @constructor
	 **/
	function Event(type, bubbles, cancelable) {
		
	
	// public properties:
		/**
		 * The type of event.
		 * @property type
		 * @type String
		 **/
		this.type = type;
	
		/**
		 * The object that generated an event.
		 * @property target
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.target = null;
	
		/**
		 * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will
		 * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event
		 * is generated from childObj, then a listener on parentObj would receive the event with
		 * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).
		 * @property currentTarget
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.currentTarget = null;
	
		/**
		 * For bubbling events, this indicates the current event phase:<OL>
		 * 	<LI> capture phase: starting from the top parent to the target</LI>
		 * 	<LI> at target phase: currently being dispatched from the target</LI>
		 * 	<LI> bubbling phase: from the target to the top parent</LI>
		 * </OL>
		 * @property eventPhase
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.eventPhase = 0;
	
		/**
		 * Indicates whether the event will bubble through the display list.
		 * @property bubbles
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.bubbles = !!bubbles;
	
		/**
		 * Indicates whether the default behaviour of this event can be cancelled via
		 * {{#crossLink "Event/preventDefault"}}{{/crossLink}}. This is set via the Event constructor.
		 * @property cancelable
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.cancelable = !!cancelable;
	
		/**
		 * The epoch time at which this event was created.
		 * @property timeStamp
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.timeStamp = (new Date()).getTime();
	
		/**
		 * Indicates if {{#crossLink "Event/preventDefault"}}{{/crossLink}} has been called
		 * on this event.
		 * @property defaultPrevented
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.defaultPrevented = false;
	
		/**
		 * Indicates if {{#crossLink "Event/stopPropagation"}}{{/crossLink}} or
		 * {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called on this event.
		 * @property propagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.propagationStopped = false;
	
		/**
		 * Indicates if {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called
		 * on this event.
		 * @property immediatePropagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.immediatePropagationStopped = false;
		
		/**
		 * Indicates if {{#crossLink "Event/remove"}}{{/crossLink}} has been called on this event.
		 * @property removed
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.removed = false;
	}
	var p = Event.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.
	

// public methods:
	/**
	 * Sets {{#crossLink "Event/defaultPrevented"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method preventDefault
	 **/
	p.preventDefault = function() {
		this.defaultPrevented = this.cancelable&&true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopPropagation
	 **/
	p.stopPropagation = function() {
		this.propagationStopped = true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} and
	 * {{#crossLink "Event/immediatePropagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopImmediatePropagation
	 **/
	p.stopImmediatePropagation = function() {
		this.immediatePropagationStopped = this.propagationStopped = true;
	};
	
	/**
	 * Causes the active listener to be removed via removeEventListener();
	 * 
	 * 		myBtn.addEventListener("click", function(evt) {
	 * 			// do stuff...
	 * 			evt.remove(); // removes this listener.
	 * 		});
	 * 
	 * @method remove
	 **/
	p.remove = function() {
		this.removed = true;
	};
	
	/**
	 * Returns a clone of the Event instance.
	 * @method clone
	 * @return {Event} a clone of the Event instance.
	 **/
	p.clone = function() {
		return new Event(this.type, this.bubbles, this.cancelable);
	};
	
	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the instance.
	 * @return {Event} Returns the instance the method is called on (useful for chaining calls.)
	 * @chainable
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Event (type="+this.type+")]";
	};

	createjs.Event = Event;
}());

//##############################################################################
// ErrorEvent.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

	/**
	 * A general error {{#crossLink "Event"}}{{/crossLink}}, that describes an error that occurred, as well as any details.
	 * @class ErrorEvent
	 * @param {String} [title] The error title
	 * @param {String} [message] The error description
	 * @param {Object} [data] Additional error data
	 * @constructor
	 */
	function ErrorEvent(title, message, data) {
		this.Event_constructor("error");

		/**
		 * The short error title, which indicates the type of error that occurred.
		 * @property title
		 * @type String
		 */
		this.title = title;

		/**
		 * The verbose error message, containing details about the error.
		 * @property message
		 * @type String
		 */
		this.message = message;

		/**
		 * Additional data attached to an error.
		 * @property data
		 * @type {Object}
		 */
		this.data = data;
	}

	var p = createjs.extend(ErrorEvent, createjs.Event);

	p.clone = function() {
		return new createjs.ErrorEvent(this.title, this.message, this.data);
	};

	createjs.ErrorEvent = createjs.promote(ErrorEvent, "Event");

}());

//##############################################################################
// EventDispatcher.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * EventDispatcher provides methods for managing queues of event listeners and dispatching events.
	 *
	 * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the
	 * EventDispatcher {{#crossLink "EventDispatcher/initialize"}}{{/crossLink}} method.
	 * 
	 * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the
	 * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports
	 * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.
	 * 
	 * EventDispatcher also exposes a {{#crossLink "EventDispatcher/on"}}{{/crossLink}} method, which makes it easier
	 * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The 
	 * {{#crossLink "EventDispatcher/off"}}{{/crossLink}} method is merely an alias to
	 * {{#crossLink "EventDispatcher/removeEventListener"}}{{/crossLink}}.
	 * 
	 * Another addition to the DOM Level 2 model is the {{#crossLink "EventDispatcher/removeAllEventListeners"}}{{/crossLink}}
	 * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also 
	 * includes a {{#crossLink "Event/remove"}}{{/crossLink}} method which removes the active listener.
	 *
	 * <h4>Example</h4>
	 * Add EventDispatcher capabilities to the "MyClass" class.
	 *
	 *      EventDispatcher.initialize(MyClass.prototype);
	 *
	 * Add an event (see {{#crossLink "EventDispatcher/addEventListener"}}{{/crossLink}}).
	 *
	 *      instance.addEventListener("eventName", handlerMethod);
	 *      function handlerMethod(event) {
	 *          console.log(event.target + " Was Clicked");
	 *      }
	 *
	 * <b>Maintaining proper scope</b><br />
	 * Scope (ie. "this") can be be a challenge with events. Using the {{#crossLink "EventDispatcher/on"}}{{/crossLink}}
	 * method to subscribe to events simplifies this.
	 *
	 *      instance.addEventListener("click", function(event) {
	 *          console.log(instance == this); // false, scope is ambiguous.
	 *      });
	 *      
	 *      instance.on("click", function(event) {
	 *          console.log(instance == this); // true, "on" uses dispatcher scope by default.
	 *      });
	 * 
	 * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage scope.
	 *      
	 *
	 * @class EventDispatcher
	 * @constructor
	 **/
	function EventDispatcher() {
	
	
	// private properties:
		/**
		 * @protected
		 * @property _listeners
		 * @type Object
		 **/
		this._listeners = null;
		
		/**
		 * @protected
		 * @property _captureListeners
		 * @type Object
		 **/
		this._captureListeners = null;
	}
	var p = EventDispatcher.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// static public methods:
	/**
	 * Static initializer to mix EventDispatcher methods into a target object or prototype.
	 * 
	 * 		EventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class
	 * 		EventDispatcher.initialize(myObject); // add to a specific instance
	 * 
	 * @method initialize
	 * @static
	 * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a
	 * prototype.
	 **/
	EventDispatcher.initialize = function(target) {
		target.addEventListener = p.addEventListener;
		target.on = p.on;
		target.removeEventListener = target.off =  p.removeEventListener;
		target.removeAllEventListeners = p.removeAllEventListeners;
		target.hasEventListener = p.hasEventListener;
		target.dispatchEvent = p.dispatchEvent;
		target._dispatchEvent = p._dispatchEvent;
		target.willTrigger = p.willTrigger;
	};
	

// public methods:
	/**
	 * Adds the specified event listener. Note that adding multiple listeners to the same function will result in
	 * multiple callbacks getting fired.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.addEventListener("click", handleClick);
	 *      function handleClick(event) {
	 *         // Click happened.
	 *      }
	 *
	 * @method addEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function | Object} Returns the listener for chaining or assignment.
	 **/
	p.addEventListener = function(type, listener, useCapture) {
		var listeners;
		if (useCapture) {
			listeners = this._captureListeners = this._captureListeners||{};
		} else {
			listeners = this._listeners = this._listeners||{};
		}
		var arr = listeners[type];
		if (arr) { this.removeEventListener(type, listener, useCapture); }
		arr = listeners[type]; // remove may have deleted the array
		if (!arr) { listeners[type] = [listener];  }
		else { arr.push(listener); }
		return listener;
	};
	
	/**
	 * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener
	 * only run once, associate arbitrary data with the listener, and remove the listener.
	 * 
	 * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.
	 * The created anonymous function is returned for use with .removeEventListener (or .off).
	 * 
	 * <h4>Example</h4>
	 * 
	 * 		var listener = myBtn.on("click", handleClick, null, false, {count:3});
	 * 		function handleClick(evt, data) {
	 * 			data.count -= 1;
	 * 			console.log(this == myBtn); // true - scope defaults to the dispatcher
	 * 			if (data.count == 0) {
	 * 				alert("clicked 3 times!");
	 * 				myBtn.off("click", listener);
	 * 				// alternately: evt.remove();
	 * 			}
	 * 		}
	 * 
	 * @method on
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).
	 * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.
	 * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.
	 * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.
	 **/
	p.on = function(type, listener, scope, once, data, useCapture) {
		if (listener.handleEvent) {
			scope = scope||listener;
			listener = listener.handleEvent;
		}
		scope = scope||this;
		return this.addEventListener(type, function(evt) {
				listener.call(scope, evt, data);
				once&&evt.remove();
			}, useCapture);
	};

	/**
	 * Removes the specified event listener.
	 *
	 * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy
	 * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or
	 * closure will not work.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.removeEventListener("click", handleClick);
	 *
	 * @method removeEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.removeEventListener = function(type, listener, useCapture) {
		var listeners = useCapture ? this._captureListeners : this._listeners;
		if (!listeners) { return; }
		var arr = listeners[type];
		if (!arr) { return; }
		for (var i=0,l=arr.length; i<l; i++) {
			if (arr[i] == listener) {
				if (l==1) { delete(listeners[type]); } // allows for faster checks.
				else { arr.splice(i,1); }
				break;
			}
		}
	};
	
	/**
	 * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the
	 * .on method.
	 *
	 * @method off
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.off = p.removeEventListener;

	/**
	 * Removes all listeners for the specified type, or all listeners of all types.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Remove all listeners
	 *      displayObject.removeAllEventListeners();
	 *
	 *      // Remove all click listeners
	 *      displayObject.removeAllEventListeners("click");
	 *
	 * @method removeAllEventListeners
	 * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.
	 **/
	p.removeAllEventListeners = function(type) {
		if (!type) { this._listeners = this._captureListeners = null; }
		else {
			if (this._listeners) { delete(this._listeners[type]); }
			if (this._captureListeners) { delete(this._captureListeners[type]); }
		}
	};

	/**
	 * Dispatches the specified event to all listeners.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Use a string event
	 *      this.dispatchEvent("complete");
	 *
	 *      // Use an Event instance
	 *      var event = new createjs.Event("progress");
	 *      this.dispatchEvent(event);
	 *
	 * @method dispatchEvent
	 * @param {Object | String | Event} eventObj An object with a "type" property, or a string type.
	 * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,
	 * dispatchEvent will construct an Event instance with the specified type.
	 * @return {Boolean} Returns the value of eventObj.defaultPrevented.
	 **/
	p.dispatchEvent = function(eventObj) {
		if (typeof eventObj == "string") {
			// won't bubble, so skip everything if there's no listeners:
			var listeners = this._listeners;
			if (!listeners || !listeners[eventObj]) { return false; }
			eventObj = new createjs.Event(eventObj);
		} else if (eventObj.target && eventObj.clone) {
			// redispatching an active event object, so clone it:
			eventObj = eventObj.clone();
		}
		try { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events

		if (!eventObj.bubbles || !this.parent) {
			this._dispatchEvent(eventObj, 2);
		} else {
			var top=this, list=[top];
			while (top.parent) { list.push(top = top.parent); }
			var i, l=list.length;

			// capture & atTarget
			for (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {
				list[i]._dispatchEvent(eventObj, 1+(i==0));
			}
			// bubbling
			for (i=1; i<l && !eventObj.propagationStopped; i++) {
				list[i]._dispatchEvent(eventObj, 3);
			}
		}
		return eventObj.defaultPrevented;
	};

	/**
	 * Indicates whether there is at least one listener for the specified event type.
	 * @method hasEventListener
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns true if there is at least one listener for the specified event.
	 **/
	p.hasEventListener = function(type) {
		var listeners = this._listeners, captureListeners = this._captureListeners;
		return !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));
	};
	
	/**
	 * Indicates whether there is at least one listener for the specified event type on this object or any of its
	 * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the
	 * specified type is dispatched from this object, it will trigger at least one listener.
	 * 
	 * This is similar to {{#crossLink "EventDispatcher/hasEventListener"}}{{/crossLink}}, but it searches the entire
	 * event flow for a listener, not just this object.
	 * @method willTrigger
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns `true` if there is at least one listener for the specified event.
	 **/
	p.willTrigger = function(type) {
		var o = this;
		while (o) {
			if (o.hasEventListener(type)) { return true; }
			o = o.parent;
		}
		return false;
	};

	/**
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[EventDispatcher]";
	};


// private methods:
	/**
	 * @method _dispatchEvent
	 * @param {Object | String | Event} eventObj
	 * @param {Object} eventPhase
	 * @protected
	 **/
	p._dispatchEvent = function(eventObj, eventPhase) {
		var l, listeners = (eventPhase==1) ? this._captureListeners : this._listeners;
		if (eventObj && listeners) {
			var arr = listeners[eventObj.type];
			if (!arr||!(l=arr.length)) { return; }
			try { eventObj.currentTarget = this; } catch (e) {}
			try { eventObj.eventPhase = eventPhase; } catch (e) {}
			eventObj.removed = false;
			
			arr = arr.slice(); // to avoid issues with items being removed or added during the dispatch
			for (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {
				var o = arr[i];
				if (o.handleEvent) { o.handleEvent(eventObj); }
				else { o(eventObj); }
				if (eventObj.removed) {
					this.off(eventObj.type, o, eventPhase==1);
					eventObj.removed = false;
				}
			}
		}
	};


	createjs.EventDispatcher = EventDispatcher;
}());

//##############################################################################
// ProgressEvent.js
//##############################################################################

this.createjs = this.createjs || {};

(function (scope) {
	"use strict";

	// constructor
	/**
	 * A CreateJS {{#crossLink "Event"}}{{/crossLink}} that is dispatched when progress changes.
	 * @class ProgressEvent
	 * @param {Number} loaded The amount that has been loaded. This can be any number relative to the total.
	 * @param {Number} [total=1] The total amount that will load. This will default to 1, so if the `loaded` value is
	 * a percentage (between 0 and 1), it can be omitted.
	 * @todo Consider having this event be a "fileprogress" event as well
	 * @constructor
	 */
	function ProgressEvent(loaded, total) {
		this.Event_constructor("progress");

		/**
		 * The amount that has been loaded (out of a total amount)
		 * @property loaded
		 * @type {Number}
		 */
		this.loaded = loaded;

		/**
		 * The total "size" of the load.
		 * @property total
		 * @type {Number}
		 * @default 1
		 */
		this.total = (total == null) ? 1 : total;

		/**
		 * The percentage (out of 1) that the load has been completed. This is calculated using `loaded/total`.
		 * @property progress
		 * @type {Number}
		 * @default 0
		 */
		this.progress = (total == 0) ? 0 : this.loaded / this.total;
	};

	var p = createjs.extend(ProgressEvent, createjs.Event);

	/**
	 * Returns a clone of the ProgressEvent instance.
	 * @method clone
	 * @return {ProgressEvent} a clone of the Event instance.
	 **/
	p.clone = function() {
		return new createjs.ProgressEvent(this.loaded, this.total);
	};

	createjs.ProgressEvent = createjs.promote(ProgressEvent, "Event");

}(window));

//##############################################################################
// json3.js
//##############################################################################

/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

//##############################################################################
// DomUtils.js
//##############################################################################

(function () {

	/**
	 * A few utilities for interacting with the dom.
	 * @class DomUtils
	 */
	var s = {};

	s.appendToHead = function (el) {
		s.getHead().appendChild(el)
	}

	s.getHead = function () {
		return document.head || document.getElementsByTagName("head")[0];
	}

	s.getBody = function () {
		return document.body || document.getElementsByTagName("body")[0];
	}

	createjs.DomUtils = s;

}());

//##############################################################################
// DataUtils.js
//##############################################################################

(function () {

	/**
	 * A few data utilities for formatting different data types.
	 * @class DataUtils
	 */
	var s = {};

	// static methods
	/**
	 * Parse XML using the DOM. This is required when preloading XML or SVG.
	 * @method parseXML
	 * @param {String} text The raw text or XML that is loaded by XHR.
	 * @param {String} type The mime type of the XML. Use "text/xml" for XML, and  "image/svg+xml" for SVG parsing.
	 * @return {XML} An XML document
	 * @static
	 */
	s.parseXML = function (text, type) {
		var xml = null;
		// CocoonJS does not support XML parsing with either method.

		// Most browsers will use DOMParser
		// IE fails on certain SVG files, so we have a fallback below.
		try {
			if (window.DOMParser) {
				var parser = new DOMParser();
				xml = parser.parseFromString(text, type);
			}
		} catch (e) {
		}

		// Fallback for IE support.
		if (!xml) {
			try {
				xml = new ActiveXObject("Microsoft.XMLDOM");
				xml.async = false;
				xml.loadXML(text);
			} catch (e) {
				xml = null;
			}
		}

		return xml;
	};

	/**
	 * Parse a string into an Object.
	 * @method parseJSON
	 * @param {String} value The loaded JSON string
	 * @returns {Object} A JavaScript object.
	 */
	s.parseJSON = function (value) {
		if (value == null) {
			return null;
		}

		try {
			return JSON.parse(value);
		} catch (e) {
			// TODO; Handle this with a custom error?
			throw e;
		}
	};

	createjs.DataUtils = s;

}());

//##############################################################################
// LoadItem.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	/**
	 * All loaders accept an item containing the properties defined in this class. If a raw object is passed instead,
	 * it will not be affected, but it must contain at least a {{#crossLink "src:property"}}{{/crossLink}} property. A
	 * string path or HTML tag is also acceptable, but it will be automatically converted to a LoadItem using the
	 * {{#crossLink "create"}}{{/crossLink}} method by {{#crossLink "AbstractLoader"}}{{/crossLink}}
	 * @class LoadItem
	 * @constructor
	 * @since 0.6.0
	 */
	function LoadItem() {
		/**
		 * The source of the file that is being loaded. This property is <b>required</b>. The source can either be a
		 * string (recommended), or an HTML tag.
		 * This can also be an object, but in that case it has to include a type and be handled by a plugin.
		 * @property src
		 * @type {String}
		 * @default null
		 */
		this.src = null;

		/**
		 * The type file that is being loaded. The type of the file is usually inferred by the extension, but can also
		 * be set manually. This is helpful in cases where a file does not have an extension.
		 * @property type
		 * @type {String}
		 * @default null
		 */
		this.type = null;

		/**
		 * A string identifier which can be used to reference the loaded object. If none is provided, this will be
		 * automatically set to the {{#crossLink "src:property"}}{{/crossLink}}.
		 * @property id
		 * @type {String}
		 * @default null
		 */
		this.id = null;

		/**
		 * Determines if a manifest will maintain the order of this item, in relation to other items in the manifest
		 * that have also set the `maintainOrder` property to `true`. This only applies when the max connections has
		 * been set above 1 (using {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}). Everything with this
		 * property set to `false` will finish as it is loaded. Ordered items are combined with script tags loading in
		 * order when {{#crossLink "LoadQueue/maintainScriptOrder:property"}}{{/crossLink}} is set to `true`.
		 * @property maintainOrder
		 * @type {Boolean}
		 * @default false
		 */
		this.maintainOrder = false;

		/**
		 * A callback used by JSONP requests that defines what global method to call when the JSONP content is loaded.
		 * @property callback
		 * @type {String}
		 * @default null
		 */
		this.callback = null;

		/**
		 * An arbitrary data object, which is included with the loaded object.
		 * @property data
		 * @type {Object}
		 * @default null
		 */
		this.data = null;

		/**
		 * The request method used for HTTP calls. Both {{#crossLink "AbstractLoader/GET:property"}}{{/crossLink}} or
		 * {{#crossLink "AbstractLoader/POST:property"}}{{/crossLink}} request types are supported, and are defined as
		 * constants on {{#crossLink "AbstractLoader"}}{{/crossLink}}.
		 * @property method
		 * @type {String}
		 * @default get
		 */
		this.method = createjs.LoadItem.GET;

		/**
		 * An object hash of name/value pairs to send to the server.
		 * @property values
		 * @type {Object}
		 * @default null
		 */
		this.values = null;

		/**
		 * An object hash of headers to attach to an XHR request. PreloadJS will automatically attach some default
		 * headers when required, including "Origin", "Content-Type", and "X-Requested-With". You may override the
		 * default headers by including them in your headers object.
		 * @property headers
		 * @type {Object}
		 * @default null
		 */
		this.headers = null;

		/**
		 * Enable credentials for XHR requests.
		 * @property withCredentials
		 * @type {Boolean}
		 * @default false
		 */
		this.withCredentials = false;

		/**
		 * Set the mime type of XHR-based requests. This is automatically set to "text/plain; charset=utf-8" for text
		 * based files (json, xml, text, css, js).
		 * @property mimeType
		 * @type {String}
		 * @default null
		 */
		this.mimeType = null;

		/**
		 * Sets the crossOrigin attribute for CORS-enabled images loading cross-domain.
		 * @property crossOrigin
		 * @type {boolean}
		 * @default Anonymous
		 */
		this.crossOrigin = null;

		/**
		 * The duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR
		 * (level one) loading, as XHR (level 2) provides its own timeout event.
		 * @property loadTimeout
		 * @type {Number}
		 * @default 8000 (8 seconds)
		 */
		this.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;
	};

	var p = LoadItem.prototype = {};
	var s = LoadItem;

	/**
	 * Default duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR
	 * (level one) loading, as XHR (level 2) provides its own timeout event.
	 * @property LOAD_TIMEOUT_DEFAULT
	 * @type {number}
	 * @static
	 */
	s.LOAD_TIMEOUT_DEFAULT = 8000;

	/**
	 * Create a LoadItem.
	 * <ul>
	 *     <li>String-based items are converted to a LoadItem with a populated {{#crossLink "src:property"}}{{/crossLink}}.</li>
	 *     <li>LoadItem instances are returned as-is</li>
	 *     <li>Objects are returned with any needed properties added</li>
	 * </ul>
	 * @method create
	 * @param {LoadItem|String|Object} value The load item value
	 * @returns {LoadItem|Object}
	 * @static
	 */
	s.create = function (value) {
		if (typeof value == "string") {
			var item = new LoadItem();
			item.src = value;
			return item;
		} else if (value instanceof s) {
			return value;
		} else if (value instanceof Object && value.src) {
			if (value.loadTimeout == null) {
				value.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;
			}
			return value;
		} else {
			throw new Error("Type not recognized.");
		}
	};

	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * <h4>Example</h4>
	 *
	 *      var loadItem = new createjs.LoadItem().set({src:"image.png", maintainOrder:true});
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the LoadItem instance.
	 * @return {LoadItem} Returns the instance the method is called on (useful for chaining calls.)
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};

	createjs.LoadItem = s;

}());

//##############################################################################
// RequestUtils.js
//##############################################################################

(function () {

	/**
	 * Utilities that assist with parsing load items, and determining file types, etc.
	 * @class RequestUtils
	 */
	var s = {};

	/**
	 * The Regular Expression used to test file URLS for an absolute path.
	 * @property ABSOLUTE_PATH
	 * @type {RegExp}
	 * @static
	 */
	s.ABSOLUTE_PATT = /^(?:\w+:)?\/{2}/i;

	/**
	 * The Regular Expression used to test file URLS for a relative path.
	 * @property RELATIVE_PATH
	 * @type {RegExp}
	 * @static
	 */
	s.RELATIVE_PATT = (/^[./]*?\//i);

	/**
	 * The Regular Expression used to test file URLS for an extension. Note that URIs must already have the query string
	 * removed.
	 * @property EXTENSION_PATT
	 * @type {RegExp}
	 * @static
	 */
	s.EXTENSION_PATT = /\/?[^/]+\.(\w{1,5})$/i;

	/**
	 * Parse a file path to determine the information we need to work with it. Currently, PreloadJS needs to know:
	 * <ul>
	 *     <li>If the path is absolute. Absolute paths start with a protocol (such as `http://`, `file://`, or
	 *     `//networkPath`)</li>
	 *     <li>If the path is relative. Relative paths start with `../` or `/path` (or similar)</li>
	 *     <li>The file extension. This is determined by the filename with an extension. Query strings are dropped, and
	 *     the file path is expected to follow the format `name.ext`.</li>
	 * </ul>
	 * @method parseURI
	 * @param {String} path
	 * @returns {Object} An Object with an `absolute` and `relative` Boolean values, as well as an optional 'extension`
	 * property, which is the lowercase extension.
	 * @static
	 */
	s.parseURI = function (path) {
		var info = {absolute: false, relative: false};
		if (path == null) { return info; }

		// Drop the query string
		var queryIndex = path.indexOf("?");
		if (queryIndex > -1) {
			path = path.substr(0, queryIndex);
		}

		// Absolute
		var match;
		if (s.ABSOLUTE_PATT.test(path)) {
			info.absolute = true;

			// Relative
		} else if (s.RELATIVE_PATT.test(path)) {
			info.relative = true;
		}

		// Extension
		if (match = path.match(s.EXTENSION_PATT)) {
			info.extension = match[1].toLowerCase();
		}
		return info;
	};

	/**
	 * Formats an object into a query string for either a POST or GET request.
	 * @method formatQueryString
	 * @param {Object} data The data to convert to a query string.
	 * @param {Array} [query] Existing name/value pairs to append on to this query.
	 * @static
	 */
	s.formatQueryString = function (data, query) {
		if (data == null) {
			throw new Error('You must specify data.');
		}
		var params = [];
		for (var n in data) {
			params.push(n + '=' + escape(data[n]));
		}
		if (query) {
			params = params.concat(query);
		}
		return params.join('&');
	};

	/**
	 * A utility method that builds a file path using a source and a data object, and formats it into a new path.
	 * @method buildPath
	 * @param {String} src The source path to add values to.
	 * @param {Object} [data] Object used to append values to this request as a query string. Existing parameters on the
	 * path will be preserved.
	 * @returns {string} A formatted string that contains the path and the supplied parameters.
	 * @static
	 */
	s.buildPath = function (src, data) {
		if (data == null) {
			return src;
		}

		var query = [];
		var idx = src.indexOf('?');

		if (idx != -1) {
			var q = src.slice(idx + 1);
			query = query.concat(q.split('&'));
		}

		if (idx != -1) {
			return src.slice(0, idx) + '?' + this._formatQueryString(data, query);
		} else {
			return src + '?' + this._formatQueryString(data, query);
		}
	};

	/**
	 * @method isCrossDomain
	 * @param {LoadItem|Object} item A load item with a `src` property.
	 * @return {Boolean} If the load item is loading from a different domain than the current location.
	 * @static
	 */
	s.isCrossDomain = function (item) {
		var target = document.createElement("a");
		target.href = item.src;

		var host = document.createElement("a");
		host.href = location.href;

		var crossdomain = (target.hostname != "") &&
						  (target.port != host.port ||
						   target.protocol != host.protocol ||
						   target.hostname != host.hostname);
		return crossdomain;
	};

	/**
	 * @method isLocal
	 * @param {LoadItem|Object} item A load item with a `src` property
	 * @return {Boolean} If the load item is loading from the "file:" protocol. Assume that the host must be local as
	 * well.
	 * @static
	 */
	s.isLocal = function (item) {
		var target = document.createElement("a");
		target.href = item.src;
		return target.hostname == "" && target.protocol == "file:";
	};

	/**
	 * Determine if a specific type should be loaded as a binary file. Currently, only images and items marked
	 * specifically as "binary" are loaded as binary. Note that audio is <b>not</b> a binary type, as we can not play
	 * back using an audio tag if it is loaded as binary. Plugins can change the item type to binary to ensure they get
	 * a binary result to work with. Binary files are loaded using XHR2. Types are defined as static constants on
	 * {{#crossLink "AbstractLoader"}}{{/crossLink}}.
	 * @method isBinary
	 * @param {String} type The item type.
	 * @return {Boolean} If the specified type is binary.
	 * @static
	 */
	s.isBinary = function (type) {
		switch (type) {
			case createjs.AbstractLoader.IMAGE:
			case createjs.AbstractLoader.BINARY:
				return true;
			default:
				return false;
		}
	};

	/**
	 * Check if item is a valid HTMLImageElement
	 * @method isImageTag
	 * @param {Object} item
	 * @returns {Boolean}
	 * @static
	 */
	s.isImageTag = function(item) {
		return item instanceof HTMLImageElement;
	};

	/**
	 * Check if item is a valid HTMLAudioElement
	 * @method isAudioTag
	 * @param {Object} item
	 * @returns {Boolean}
	 * @static
	 */
	s.isAudioTag = function(item) {
		if (window.HTMLAudioElement) {
			return item instanceof HTMLAudioElement;
		} else {
			return false;
		}
	};

	/**
	 * Check if item is a valid HTMLVideoElement
	 * @method isVideoTag
	 * @param {Object} item
	 * @returns {Boolean}
	 * @static
	 */
	s.isVideoTag = function(item) {
		if (window.HTMLVideoElement) {
			return item instanceof HTMLVideoElement;
		} else {
			return false;
		}
	};

	/**
	 * Determine if a specific type is a text-based asset, and should be loaded as UTF-8.
	 * @method isText
	 * @param {String} type The item type.
	 * @return {Boolean} If the specified type is text.
	 * @static
	 */
	s.isText = function (type) {
		switch (type) {
			case createjs.AbstractLoader.TEXT:
			case createjs.AbstractLoader.JSON:
			case createjs.AbstractLoader.MANIFEST:
			case createjs.AbstractLoader.XML:
			case createjs.AbstractLoader.CSS:
			case createjs.AbstractLoader.SVG:
			case createjs.AbstractLoader.JAVASCRIPT:
			case createjs.AbstractLoader.SPRITESHEET:
				return true;
			default:
				return false;
		}
	};

	/**
	 * Determine the type of the object using common extensions. Note that the type can be passed in with the load item
	 * if it is an unusual extension.
	 * @method getTypeByExtension
	 * @param {String} extension The file extension to use to determine the load type.
	 * @return {String} The determined load type (for example, <code>AbstractLoader.IMAGE</code>). Will return `null` if
	 * the type can not be determined by the extension.
	 * @static
	 */
	s.getTypeByExtension = function (extension) {
		if (extension == null) {
			return createjs.AbstractLoader.TEXT;
		}

		switch (extension.toLowerCase()) {
			case "jpeg":
			case "jpg":
			case "gif":
			case "png":
			case "webp":
			case "bmp":
				return createjs.AbstractLoader.IMAGE;
			case "ogg":
			case "mp3":
			case "webm":
				return createjs.AbstractLoader.SOUND;
			case "mp4":
			case "webm":
			case "ts":
				return createjs.AbstractLoader.VIDEO;
			case "json":
				return createjs.AbstractLoader.JSON;
			case "xml":
				return createjs.AbstractLoader.XML;
			case "css":
				return createjs.AbstractLoader.CSS;
			case "js":
				return createjs.AbstractLoader.JAVASCRIPT;
			case 'svg':
				return createjs.AbstractLoader.SVG;
			default:
				return createjs.AbstractLoader.TEXT;
		}
	};

	createjs.RequestUtils = s;

}());

//##############################################################################
// AbstractLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

// constructor
	/**
	 * The base loader, which defines all the generic methods, properties, and events. All loaders extend this class,
	 * including the {{#crossLink "LoadQueue"}}{{/crossLink}}.
	 * @class AbstractLoader
	 * @param {LoadItem|object|string} loadItem The item to be loaded.
	 * @param {Boolean} [preferXHR] Determines if the LoadItem should <em>try</em> and load using XHR, or take a
	 * tag-based approach, which can be better in cross-domain situations. Not all loaders can load using one or the
	 * other, so this is a suggested directive.
	 * @param {String} [type] The type of loader. Loader types are defined as constants on the AbstractLoader class,
	 * such as {{#crossLink "IMAGE:property"}}{{/crossLink}}, {{#crossLink "CSS:property"}}{{/crossLink}}, etc.
	 * @extends EventDispatcher
	 */
	function AbstractLoader(loadItem, preferXHR, type) {
		this.EventDispatcher_constructor();

		// public properties
		/**
		 * If the loader has completed loading. This provides a quick check, but also ensures that the different approaches
		 * used for loading do not pile up resulting in more than one `complete` {{#crossLink "Event"}}{{/crossLink}}.
		 * @property loaded
		 * @type {Boolean}
		 * @default false
		 */
		this.loaded = false;

		/**
		 * Determine if the loader was canceled. Canceled loads will not fire complete events. Note that this property
		 * is readonly, so {{#crossLink "LoadQueue"}}{{/crossLink}} queues should be closed using {{#crossLink "LoadQueue/close"}}{{/crossLink}}
		 * instead.
		 * @property canceled
		 * @type {Boolean}
		 * @default false
		 * @readonly
		 */
		this.canceled = false;

		/**
		 * The current load progress (percentage) for this item. This will be a number between 0 and 1.
		 *
		 * <h4>Example</h4>
		 *
		 *     var queue = new createjs.LoadQueue();
		 *     queue.loadFile("largeImage.png");
		 *     queue.on("progress", function() {
		 *         console.log("Progress:", queue.progress, event.progress);
		 *     });
		 *
		 * @property progress
		 * @type {Number}
		 * @default 0
		 */
		this.progress = 0;

		/**
		 * The type of item this loader will load. See {{#crossLink "AbstractLoader"}}{{/crossLink}} for a full list of
		 * supported types.
		 * @property type
		 * @type {String}
		 */
		this.type = type;

		/**
		 * A formatter function that converts the loaded raw result into the final result. For example, the JSONLoader
		 * converts a string of text into a JavaScript object. Not all loaders have a resultFormatter, and this property
		 * can be overridden to provide custom formatting.
		 *
		 * Optionally, a resultFormatter can return a callback function in cases where the formatting needs to be
		 * asynchronous, such as creating a new image.
		 * @property resultFormatter
		 * @type {Function}
		 * @default null
		 */
		this.resultFormatter = null;

		// protected properties
		/**
		 * The {{#crossLink "LoadItem"}}{{/crossLink}} this loader represents. Note that this is null in a {{#crossLink "LoadQueue"}}{{/crossLink}},
		 * but will be available on loaders such as {{#crossLink "XMLLoader"}}{{/crossLink}} and {{#crossLink "ImageLoader"}}{{/crossLink}}.
		 * @property _item
		 * @type {LoadItem|Object}
		 * @private
		 */
		if (loadItem) {
			this._item = createjs.LoadItem.create(loadItem);
		} else {
			this._item = null;
		}

		/**
		 * Whether the loader will try and load content using XHR (true) or HTML tags (false).
		 * @property _preferXHR
		 * @type {Boolean}
		 * @private
		 */
		this._preferXHR = preferXHR;

		/**
		 * The loaded result after it is formatted by an optional {{#crossLink "resultFormatter"}}{{/crossLink}}. For
		 * items that are not formatted, this will be the same as the {{#crossLink "_rawResult:property"}}{{/crossLink}}.
		 * The result is accessed using the {{#crossLink "getResult"}}{{/crossLink}} method.
		 * @property _result
		 * @type {Object|String}
		 * @private
		 */
		this._result = null;

		/**
		 * The loaded result before it is formatted. The rawResult is accessed using the {{#crossLink "getResult"}}{{/crossLink}}
		 * method, and passing `true`.
		 * @property _rawResult
		 * @type {Object|String}
		 * @private
		 */
		this._rawResult = null;

		/**
		 * A list of items that loaders load behind the scenes. This does not include the main item the loader is
		 * responsible for loading. Examples of loaders that have sub-items include the {{#crossLink "SpriteSheetLoader"}}{{/crossLink}} and
		 * {{#crossLink "ManifestLoader"}}{{/crossLink}}.
		 * @property _loadItems
		 * @type {null}
		 * @protected
		 */
		this._loadedItems = null;

		/**
		 * The attribute the items loaded using tags use for the source.
		 * @type {string}
		 * @default null
		 * @private
		 */
		this._tagSrcAttribute = null;

		/**
		 * An HTML tag (or similar) that a loader may use to load HTML content, such as images, scripts, etc.
		 * @property _tag
		 * @type {Object}
		 * @private
		 */
		this._tag = null;
	};

	var p = createjs.extend(AbstractLoader, createjs.EventDispatcher);
	var s = AbstractLoader;

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


	/**
	 * Defines a POST request, use for a method value when loading data.
	 * @property POST
	 * @type {string}
	 * @default post
	 * @static
	 */
	s.POST = "POST";

	/**
	 * Defines a GET request, use for a method value when loading data.
	 * @property GET
	 * @type {string}
	 * @default get
	 * @static
	 */
	s.GET = "GET";

	/**
	 * The preload type for generic binary types. Note that images are loaded as binary files when using XHR.
	 * @property BINARY
	 * @type {String}
	 * @default binary
	 * @static
	 * @since 0.6.0
	 */
	s.BINARY = "binary";

	/**
	 * The preload type for css files. CSS files are loaded using a &lt;link&gt; when loaded with XHR, or a
	 * &lt;style&gt; tag when loaded with tags.
	 * @property CSS
	 * @type {String}
	 * @default css
	 * @static
	 * @since 0.6.0
	 */
	s.CSS = "css";

	/**
	 * The preload type for image files, usually png, gif, or jpg/jpeg. Images are loaded into an &lt;image&gt; tag.
	 * @property IMAGE
	 * @type {String}
	 * @default image
	 * @static
	 * @since 0.6.0
	 */
	s.IMAGE = "image";

	/**
	 * The preload type for javascript files, usually with the "js" file extension. JavaScript files are loaded into a
	 * &lt;script&gt; tag.
	 *
	 * Since version 0.4.1+, due to how tag-loaded scripts work, all JavaScript files are automatically injected into
	 * the body of the document to maintain parity between XHR and tag-loaded scripts. In version 0.4.0 and earlier,
	 * only tag-loaded scripts are injected.
	 * @property JAVASCRIPT
	 * @type {String}
	 * @default javascript
	 * @static
	 * @since 0.6.0
	 */
	s.JAVASCRIPT = "javascript";

	/**
	 * The preload type for json files, usually with the "json" file extension. JSON data is loaded and parsed into a
	 * JavaScript object. Note that if a `callback` is present on the load item, the file will be loaded with JSONP,
	 * no matter what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}} property is set to, and the JSON
	 * must contain a matching wrapper function.
	 * @property JSON
	 * @type {String}
	 * @default json
	 * @static
	 * @since 0.6.0
	 */
	s.JSON = "json";

	/**
	 * The preload type for jsonp files, usually with the "json" file extension. JSON data is loaded and parsed into a
	 * JavaScript object. You are required to pass a callback parameter that matches the function wrapper in the JSON.
	 * Note that JSONP will always be used if there is a callback present, no matter what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}}
	 * property is set to.
	 * @property JSONP
	 * @type {String}
	 * @default jsonp
	 * @static
	 * @since 0.6.0
	 */
	s.JSONP = "jsonp";

	/**
	 * The preload type for json-based manifest files, usually with the "json" file extension. The JSON data is loaded
	 * and parsed into a JavaScript object. PreloadJS will then look for a "manifest" property in the JSON, which is an
	 * Array of files to load, following the same format as the {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}
	 * method. If a "callback" is specified on the manifest object, then it will be loaded using JSONP instead,
	 * regardless of what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}} property is set to.
	 * @property MANIFEST
	 * @type {String}
	 * @default manifest
	 * @static
	 * @since 0.6.0
	 */
	s.MANIFEST = "manifest";

	/**
	 * The preload type for sound files, usually mp3, ogg, or wav. When loading via tags, audio is loaded into an
	 * &lt;audio&gt; tag.
	 * @property SOUND
	 * @type {String}
	 * @default sound
	 * @static
	 * @since 0.6.0
	 */
	s.SOUND = "sound";

	/**
	 * The preload type for video files, usually mp4, ts, or ogg. When loading via tags, video is loaded into an
	 * &lt;video&gt; tag.
	 * @property VIDEO
	 * @type {String}
	 * @default video
	 * @static
	 * @since 0.6.0
	 */
	s.VIDEO = "video";

	/**
	 * The preload type for SpriteSheet files. SpriteSheet files are JSON files that contain string image paths.
	 * @property SPRITESHEET
	 * @type {String}
	 * @default spritesheet
	 * @static
	 * @since 0.6.0
	 */
	s.SPRITESHEET = "spritesheet";

	/**
	 * The preload type for SVG files.
	 * @property SVG
	 * @type {String}
	 * @default svg
	 * @static
	 * @since 0.6.0
	 */
	s.SVG = "svg";

	/**
	 * The preload type for text files, which is also the default file type if the type can not be determined. Text is
	 * loaded as raw text.
	 * @property TEXT
	 * @type {String}
	 * @default text
	 * @static
	 * @since 0.6.0
	 */
	s.TEXT = "text";

	/**
	 * The preload type for xml files. XML is loaded into an XML document.
	 * @property XML
	 * @type {String}
	 * @default xml
	 * @static
	 * @since 0.6.0
	 */
	s.XML = "xml";

// Events
	/**
	 * The {{#crossLink "ProgressEvent"}}{{/crossLink}} that is fired when the overall progress changes. Prior to
	 * version 0.6.0, this was just a regular {{#crossLink "Event"}}{{/crossLink}}.
	 * @event progress
	 * @since 0.3.0
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when a load starts.
	 * @event loadstart
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @since 0.3.1
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when the entire queue has been loaded.
	 * @event complete
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @since 0.3.0
	 */

	/**
	 * The {{#crossLink "ErrorEvent"}}{{/crossLink}} that is fired when the loader encounters an error. If the error was
	 * encountered by a file, the event will contain the item that caused the error. Prior to version 0.6.0, this was
	 * just a regular {{#crossLink "Event"}}{{/crossLink}}.
	 * @event error
	 * @since 0.3.0
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when the loader encounters an internal file load error.
	 * This enables loaders to maintain internal queues, and surface file load errors.
	 * @event fileerror
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The even type ("fileerror")
	 * @param {LoadItem|object} The item that encountered the error
	 * @since 0.6.0
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when a loader internally loads a file. This enables
	 * loaders such as {{#crossLink "ManifestLoader"}}{{/crossLink}} to maintain internal {{#crossLink "LoadQueue"}}{{/crossLink}}s
	 * and notify when they have loaded a file. The {{#crossLink "LoadQueue"}}{{/crossLink}} class dispatches a
	 * slightly different {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event.
	 * @event fileload
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type ("fileload")
	 * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a `src` property.
	 * @param {Object} result The HTML tag or parsed result of the loaded item.
	 * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted
	 * to a usable object.
	 * @since 0.6.0
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired after the internal request is created, but before a load.
	 * This allows updates to the loader for specific loading needs, such as binary or XHR image loading.
	 * @event initialize
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type ("initialize")
	 * @param {AbstractLoader} loader The loader that has been initialized.
	 */


	/**
	 * Get a reference to the manifest item that is loaded by this loader. In some cases this will be the value that was
	 * passed into {{#crossLink "LoadQueue"}}{{/crossLink}} using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or
	 * {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. However if only a String path was passed in, then it will
	 * be a {{#crossLink "LoadItem"}}{{/crossLink}}.
	 * @method getItem
	 * @return {Object} The manifest item that this loader is responsible for loading.
	 * @since 0.6.0
	 */
	p.getItem = function () {
		return this._item;
	};

	/**
	 * Get a reference to the content that was loaded by the loader (only available after the {{#crossLink "complete:event"}}{{/crossLink}}
	 * event is dispatched.
	 * @method getResult
	 * @param {Boolean} [raw=false] Determines if the returned result will be the formatted content, or the raw loaded
	 * data (if it exists).
	 * @return {Object}
	 * @since 0.6.0
	 */
	p.getResult = function (raw) {
		return raw ? this._rawResult : this._result;
	};

	/**
	 * Return the `tag` this object creates or uses for loading.
	 * @method getTag
	 * @return {Object} The tag instance
	 * @since 0.6.0
	 */
	p.getTag = function () {
		return this._tag;
	};

	/**
	 * Set the `tag` this item uses for loading.
	 * @method setTag
	 * @param {Object} tag The tag instance
	 * @since 0.6.0
	 */
	p.setTag = function(tag) {
	  this._tag = tag;
	};

	/**
	 * Begin loading the item. This method is required when using a loader by itself.
	 *
	 * <h4>Example</h4>
	 *
	 *      var queue = new createjs.LoadQueue();
	 *      queue.on("complete", handleComplete);
	 *      queue.loadManifest(fileArray, false); // Note the 2nd argument that tells the queue not to start loading yet
	 *      queue.load();
	 *
	 * @method load
	 */
	p.load = function () {
		this._createRequest();

		this._request.on("complete", this, this);
		this._request.on("progress", this, this);
		this._request.on("loadStart", this, this);
		this._request.on("abort", this, this);
		this._request.on("timeout", this, this);
		this._request.on("error", this, this);

		var evt = new createjs.Event("initialize");
		evt.loader = this._request;
		this.dispatchEvent(evt);

		this._request.load();
	};

	/**
	 * Close the the item. This will stop any open requests (although downloads using HTML tags may still continue in
	 * the background), but events will not longer be dispatched.
	 * @method cancel
	 */
	p.cancel = function () {
		this.canceled = true;
		this.destroy();
	};

	/**
	 * Clean up the loader.
	 * @method destroy
	 */
	p.destroy = function() {
		if (this._request) {
			this._request.removeAllEventListeners();
			this._request.destroy();
		}

		this._request = null;

		this._item = null;
		this._rawResult = null;
		this._result = null;

		this._loadItems = null;

		this.removeAllEventListeners();
	};

	/**
	 * Get any items loaded internally by the loader. The enables loaders such as {{#crossLink "ManifestLoader"}}{{/crossLink}}
	 * to expose items it loads internally.
	 * @method getLoadedItems
	 * @return {Array} A list of the items loaded by the loader.
	 * @since 0.6.0
	 */
	p.getLoadedItems = function () {
		return this._loadedItems;
	};


	// Private methods
	/**
	 * Create an internal request used for loading. By default, an {{#crossLink "XHRRequest"}}{{/crossLink}} or
	 * {{#crossLink "TagRequest"}}{{/crossLink}} is created, depending on the value of {{#crossLink "preferXHR:property"}}{{/crossLink}}.
	 * Other loaders may override this to use different request types, such as {{#crossLink "ManifestLoader"}}{{/crossLink}},
	 * which uses {{#crossLink "JSONLoader"}}{{/crossLink}} or {{#crossLink "JSONPLoader"}}{{/crossLink}} under the hood.
	 * @method _createRequest
	 * @protected
	 */
	p._createRequest = function() {
		if (!this._preferXHR) {
			this._request = new createjs.TagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);
		} else {
			this._request = new createjs.XHRRequest(this._item);
		}
	};

	/**
	 * Create the HTML tag used for loading. This method does nothing by default, and needs to be implemented
	 * by loaders that require tag loading.
	 * @method _createTag
	 * @param {String} src The tag source
	 * @return {HTMLElement} The tag that was created
	 * @protected
	 */
	p._createTag = function(src) { return null; };

	/**
	 * Dispatch a loadstart {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/loadstart:event"}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendLoadStart
	 * @protected
	 */
	p._sendLoadStart = function () {
		if (this._isCanceled()) { return; }
		this.dispatchEvent("loadstart");
	};

	/**
	 * Dispatch a {{#crossLink "ProgressEvent"}}{{/crossLink}}.
	 * @method _sendProgress
	 * @param {Number | Object} value The progress of the loaded item, or an object containing <code>loaded</code>
	 * and <code>total</code> properties.
	 * @protected
	 */
	p._sendProgress = function (value) {
		if (this._isCanceled()) { return; }
		var event = null;
		if (typeof(value) == "number") {
			this.progress = value;
			event = new createjs.ProgressEvent(this.progress);
		} else {
			event = value;
			this.progress = value.loaded / value.total;
			event.progress = this.progress;
			if (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }
		}
		this.hasEventListener("progress") && this.dispatchEvent(event);
	};

	/**
	 * Dispatch a complete {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}} event
	 * @method _sendComplete
	 * @protected
	 */
	p._sendComplete = function () {
		if (this._isCanceled()) { return; }

		this.loaded = true;

		var event = new createjs.Event("complete");
		event.rawResult = this._rawResult;

		if (this._result != null) {
			event.result = this._result;
		}

		this.dispatchEvent(event);
	};

	/**
	 * Dispatch an error {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendError
	 * @param {ErrorEvent} event The event object containing specific error properties.
	 * @protected
	 */
	p._sendError = function (event) {
		if (this._isCanceled() || !this.hasEventListener("error")) { return; }
		if (event == null) {
			event = new createjs.ErrorEvent("PRELOAD_ERROR_EMPTY"); // TODO: Populate error
		}
		this.dispatchEvent(event);
	};

	/**
	 * Determine if the load has been canceled. This is important to ensure that method calls or asynchronous events
	 * do not cause issues after the queue has been cleaned up.
	 * @method _isCanceled
	 * @return {Boolean} If the loader has been canceled.
	 * @protected
	 */
	p._isCanceled = function () {
		if (window.createjs == null || this.canceled) {
			return true;
		}
		return false;
	};

	/**
	 * A custom result formatter function, which is called just before a request dispatches its complete event. Most
	 * loader types already have an internal formatter, but this can be user-overridden for custom formatting. The
	 * formatted result will be available on Loaders using {{#crossLink "getResult"}}{{/crossLink}}, and passing `true`.
	 * @property resultFormatter
	 * @type Function
	 * @return {Object} The formatted result
	 * @since 0.6.0
	 */
	p.resultFormatter = null;

	/**
	 * Handle events from internal requests. By default, loaders will handle, and redispatch the necessary events, but
	 * this method can be overridden for custom behaviours.
	 * @method handleEvent
	 * @param {Event} event The event that the internal request dispatches.
	 * @protected
	 * @since 0.6.0
	 */
	p.handleEvent = function (event) {
		switch (event.type) {
			case "complete":
				this._rawResult = event.target._response;
				var result = this.resultFormatter && this.resultFormatter(this);
				var _this = this;
				if (result instanceof Function) {
					result(function(result) {
						_this._result = result;
						_this._sendComplete();
					});
				} else {
					this._result =  result || this._rawResult;
					this._sendComplete();
				}
				break;
			case "progress":
				this._sendProgress(event);
				break;
			case "error":
				this._sendError(event);
				break;
			case "loadstart":
				this._sendLoadStart();
				break;
			case "abort":
			case "timeout":
				if (!this._isCanceled()) {
					this.dispatchEvent(event.type);
				}
				break;
		}
	};

	/**
	 * @method buildPath
	 * @protected
	 * @deprecated Use the {{#crossLink "RequestUtils"}}{{/crossLink}} method {{#crossLink "RequestUtils/buildPath"}}{{/crossLink}}
	 * instead.
	 */
	p.buildPath = function (src, data) {
		return createjs.RequestUtils.buildPath(src, data);
	};

	/**
	 * @method toString
	 * @return {String} a string representation of the instance.
	 */
	p.toString = function () {
		return "[PreloadJS AbstractLoader]";
	};

	createjs.AbstractLoader = createjs.promote(AbstractLoader, "EventDispatcher");

}());

//##############################################################################
// AbstractMediaLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * The AbstractMediaLoader is a base class that handles some of the shared methods and properties of loaders that
	 * handle HTML media elements, such as Video and Audio.
	 * @class AbstractMediaLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @param {String} type The type of media to load. Usually "video" or "audio".
	 * @extends AbstractLoader
	 * @constructor
	 */
	function AbstractMediaLoader(loadItem, preferXHR, type) {
		this.AbstractLoader_constructor(loadItem, preferXHR, type);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = "src";
	};

	var p = createjs.extend(AbstractMediaLoader, createjs.AbstractLoader);

	// static properties
	// public methods
	p.load = function () {
		// TagRequest will handle most of this, but Sound / Video need a few custom properties, so just handle them here.
		if (!this._tag) {
			this._tag = this._createTag(this._item.src);
		}

		this._tag.preload = "auto";
		this._tag.load();

		this.AbstractLoader_load();
	};

	// protected methods
	/**
	 * Creates a new tag for loading if it doesn't exist yet.
	 * @method _createTag
	 * @private
	 */
	p._createTag = function () {};


	p._createRequest = function() {
		if (!this._preferXHR) {
			this._request = new createjs.MediaTagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);
		} else {
			this._request = new createjs.XHRRequest(this._item);
		}
	};

	/**
	 * The result formatter for media files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLVideoElement|HTMLAudioElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler);
		this._tag.onstalled = null;
		if (this._preferXHR) {
			loader.getTag().src = loader.getResult(true);
		}
		return loader.getTag();
	};

	createjs.AbstractMediaLoader = createjs.promote(AbstractMediaLoader, "AbstractLoader");

}());

//##############################################################################
// AbstractRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	/**
	 * A base class for actual data requests, such as {{#crossLink "XHRRequest"}}{{/crossLink}}, {{#crossLink "TagRequest"}}{{/crossLink}},
	 * and {{#crossLink "MediaRequest"}}{{/crossLink}}. PreloadJS loaders will typically use a data loader under the
	 * hood to get data.
	 * @class AbstractRequest
	 * @param {LoadItem} item
	 * @constructor
	 */
	var AbstractRequest = function (item) {
		this._item = item;
	};

	var p = createjs.extend(AbstractRequest, createjs.EventDispatcher);

	// public methods
	/**
	 * Begin a load.
	 * @method load
	 */
	p.load =  function() {};

	/**
	 * Clean up a request.
	 * @method destroy
	 */
	p.destroy = function() {};

	/**
	 * Cancel an in-progress request.
	 * @method cancel
	 */
	p.cancel = function() {};

	createjs.AbstractRequest = createjs.promote(AbstractRequest, "EventDispatcher");

}());

//##############################################################################
// TagRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * An {{#crossLink "AbstractRequest"}}{{/crossLink}} that loads HTML tags, such as images and scripts.
	 * @class TagRequest
	 * @param {LoadItem} loadItem
	 * @param {HTMLElement} tag
	 * @param {String} srcAttribute The tag attribute that specifies the source, such as "src", "href", etc.
	 */
	function TagRequest(loadItem, tag, srcAttribute) {
		this.AbstractRequest_constructor(loadItem);

		// protected properties
		/**
		 * The HTML tag instance that is used to load.
		 * @property _tag
		 * @type {HTMLElement}
		 * @protected
		 */
		this._tag = tag;

		/**
		 * The tag attribute that specifies the source, such as "src", "href", etc.
		 * @property _tagSrcAttribute
		 * @type {String}
		 * @protected
		 */
		this._tagSrcAttribute = srcAttribute;

		/**
		 * A method closure used for handling the tag load event.
		 * @property _loadedHandler
		 * @type {Function}
		 * @private
		 */
		this._loadedHandler = createjs.proxy(this._handleTagComplete, this);

		/**
		 * Determines if the element was added to the DOM automatically by PreloadJS, so it can be cleaned up after.
		 * @property _addedToDOM
		 * @type {Boolean}
		 * @private
		 */
		this._addedToDOM = false;

		/**
		 * Determines what the tags initial style.visibility was, so we can set it correctly after a load.
		 *
		 * @type {null}
		 * @private
		 */
		this._startTagVisibility = null;
	};

	var p = createjs.extend(TagRequest, createjs.AbstractRequest);

	// public methods
	p.load = function () {
		this._tag.onload = createjs.proxy(this._handleTagComplete, this);
		this._tag.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this);
		this._tag.onerror = createjs.proxy(this._handleError, this);

		var evt = new createjs.Event("initialize");
		evt.loader = this._tag;

		this.dispatchEvent(evt);

		this._hideTag();

		this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);

		this._tag[this._tagSrcAttribute] = this._item.src;

		// wdg:: Append the tag AFTER setting the src, or SVG loading on iOS will fail.
		if (this._tag.parentNode == null) {
			window.document.body.appendChild(this._tag);
			this._addedToDOM = true;
		}
	};

	p.destroy = function() {
		this._clean();
		this._tag = null;

		this.AbstractRequest_destroy();
	};

	// private methods
	/**
	 * Handle the readyStateChange event from a tag. We need this in place of the `onload` callback (mainly SCRIPT
	 * and LINK tags), but other cases may exist.
	 * @method _handleReadyStateChange
	 * @private
	 */
	p._handleReadyStateChange = function () {
		clearTimeout(this._loadTimeout);
		// This is strictly for tags in browsers that do not support onload.
		var tag = this._tag;

		// Complete is for old IE support.
		if (tag.readyState == "loaded" || tag.readyState == "complete") {
			this._handleTagComplete();
		}
	};

	/**
	 * Handle any error events from the tag.
	 * @method _handleError
	 * @protected
	 */
	p._handleError = function() {
		this._clean();
		this.dispatchEvent("error");
	};

	/**
	 * Handle the tag's onload callback.
	 * @method _handleTagComplete
	 * @private
	 */
	p._handleTagComplete = function () {
		this._rawResult = this._tag;
		this._result = this.resultFormatter && this.resultFormatter(this) || this._rawResult;

		this._clean();
		this._showTag();

		this.dispatchEvent("complete");
	};

	/**
	 * The tag request has not loaded within the time specified in loadTimeout.
	 * @method _handleError
	 * @param {Object} event The XHR error event.
	 * @private
	 */
	p._handleTimeout = function () {
		this._clean();
		this.dispatchEvent(new createjs.Event("timeout"));
	};

	/**
	 * Remove event listeners, but don't destroy the request object
	 * @method _clean
	 * @private
	 */
	p._clean = function() {
		this._tag.onload = null;
		this._tag.onreadystatechange = null;
		this._tag.onerror = null;
		if (this._addedToDOM && this._tag.parentNode != null) {
			this._tag.parentNode.removeChild(this._tag);
		}
		clearTimeout(this._loadTimeout);
	};

	p._hideTag = function() {
		this._startTagVisibility = this._tag.style.visibility;
		this._tag.style.visibility = "hidden";
	};

	p._showTag = function() {
		this._tag.style.visibility = this._startTagVisibility;
	};

	/**
	 * Handle a stalled audio event. The main place this happens is with HTMLAudio in Chrome when playing back audio
	 * that is already in a load, but not complete.
	 * @method _handleStalled
	 * @private
	 */
	p._handleStalled = function () {
		//Ignore, let the timeout take care of it. Sometimes its not really stopped.
	};

	createjs.TagRequest = createjs.promote(TagRequest, "AbstractRequest");

}());

//##############################################################################
// MediaTagRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * An {{#crossLink "TagRequest"}}{{/crossLink}} that loads HTML tags for video and audio.
	 * @class MediaTagRequest
	 * @param {LoadItem} loadItem
	 * @param {HTMLAudioElement|HTMLVideoElement} tag
	 * @param {String} srcAttribute The tag attribute that specifies the source, such as "src", "href", etc.
	 * @constructor
	 */
	function MediaTagRequest(loadItem, tag, srcAttribute) {
		this.AbstractRequest_constructor(loadItem);

		// protected properties
		this._tag = tag;
		this._tagSrcAttribute = srcAttribute;
		this._loadedHandler = createjs.proxy(this._handleTagComplete, this);
	};

	var p = createjs.extend(MediaTagRequest, createjs.TagRequest);
	var s = MediaTagRequest;

	// public methods
	p.load = function () {
		var sc = createjs.proxy(this._handleStalled, this);
		this._stalledCallback = sc;

		var pc = createjs.proxy(this._handleProgress, this);
		this._handleProgress = pc;

		this._tag.addEventListener("stalled", sc);
		this._tag.addEventListener("progress", pc);

		// This will tell us when audio is buffered enough to play through, but not when its loaded.
		// The tag doesn't keep loading in Chrome once enough has buffered, and we have decided that behaviour is sufficient.
		this._tag.addEventListener && this._tag.addEventListener("canplaythrough", this._loadedHandler, false); // canplaythrough callback doesn't work in Chrome, so we use an event.

		this.TagRequest_load();
	};

	// private methods
	p._handleReadyStateChange = function () {
		clearTimeout(this._loadTimeout);
		// This is strictly for tags in browsers that do not support onload.
		var tag = this._tag;

		// Complete is for old IE support.
		if (tag.readyState == "loaded" || tag.readyState == "complete") {
			this._handleTagComplete();
		}
	};

	p._handleStalled = function () {
		//Ignore, let the timeout take care of it. Sometimes its not really stopped.
	};

	/**
	 * An XHR request has reported progress.
	 * @method _handleProgress
	 * @param {Object} event The XHR progress event.
	 * @private
	 */
	p._handleProgress = function (event) {
		if (!event || event.loaded > 0 && event.total == 0) {
			return; // Sometimes we get no "total", so just ignore the progress event.
		}

		var newEvent = new createjs.ProgressEvent(event.loaded, event.total);
		this.dispatchEvent(newEvent);
	};

	// protected methods
	p._clean = function () {
		this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler);
		this._tag.removeEventListener("stalled", this._stalledCallback);
		this._tag.removeEventListener("progress", this._progressCallback);

		this.TagRequest__clean();
	};

	createjs.MediaTagRequest = createjs.promote(MediaTagRequest, "TagRequest");

}());

//##############################################################################
// XHRRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

// constructor
	/**
	 * A preloader that loads items using XHR requests, usually XMLHttpRequest. However XDomainRequests will be used
	 * for cross-domain requests if possible, and older versions of IE fall back on to ActiveX objects when necessary.
	 * XHR requests load the content as text or binary data, provide progress and consistent completion events, and
	 * can be canceled during load. Note that XHR is not supported in IE 6 or earlier, and is not recommended for
	 * cross-domain loading.
	 * @class XHRRequest
	 * @constructor
	 * @param {Object} item The object that defines the file to load. Please see the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * for an overview of supported file properties.
	 * @extends AbstractLoader
	 */
	function XHRRequest (item) {
		this.AbstractRequest_constructor(item);

		// protected properties
		/**
		 * A reference to the XHR request used to load the content.
		 * @property _request
		 * @type {XMLHttpRequest | XDomainRequest | ActiveX.XMLHTTP}
		 * @private
		 */
		this._request = null;

		/**
		 * A manual load timeout that is used for browsers that do not support the onTimeout event on XHR (XHR level 1,
		 * typically IE9).
		 * @property _loadTimeout
		 * @type {Number}
		 * @private
		 */
		this._loadTimeout = null;

		/**
		 * The browser's XHR (XMLHTTPRequest) version. Supported versions are 1 and 2. There is no official way to detect
		 * the version, so we use capabilities to make a best guess.
		 * @property _xhrLevel
		 * @type {Number}
		 * @default 1
		 * @private
		 */
		this._xhrLevel = 1;

		/**
		 * The response of a loaded file. This is set because it is expensive to look up constantly. This property will be
		 * null until the file is loaded.
		 * @property _response
		 * @type {mixed}
		 * @private
		 */
		this._response = null;

		/**
		 * The response of the loaded file before it is modified. In most cases, content is converted from raw text to
		 * an HTML tag or a formatted object which is set to the <code>result</code> property, but the developer may still
		 * want to access the raw content as it was loaded.
		 * @property _rawResponse
		 * @type {String|Object}
		 * @private
		 */
		this._rawResponse = null;

		this._canceled = false;

		// Setup our event handlers now.
		this._handleLoadStartProxy = createjs.proxy(this._handleLoadStart, this);
		this._handleProgressProxy = createjs.proxy(this._handleProgress, this);
		this._handleAbortProxy = createjs.proxy(this._handleAbort, this);
		this._handleErrorProxy = createjs.proxy(this._handleError, this);
		this._handleTimeoutProxy = createjs.proxy(this._handleTimeout, this);
		this._handleLoadProxy = createjs.proxy(this._handleLoad, this);
		this._handleReadyStateChangeProxy = createjs.proxy(this._handleReadyStateChange, this);

		if (!this._createXHR(item)) {
			//TODO: Throw error?
		}
	};

	var p = createjs.extend(XHRRequest, createjs.AbstractRequest);

// static properties
	/**
	 * A list of XMLHTTP object IDs to try when building an ActiveX object for XHR requests in earlier versions of IE.
	 * @property ACTIVEX_VERSIONS
	 * @type {Array}
	 * @since 0.4.2
	 * @private
	 */
	XHRRequest.ACTIVEX_VERSIONS = [
		"Msxml2.XMLHTTP.6.0",
		"Msxml2.XMLHTTP.5.0",
		"Msxml2.XMLHTTP.4.0",
		"MSXML2.XMLHTTP.3.0",
		"MSXML2.XMLHTTP",
		"Microsoft.XMLHTTP"
	];

// Public methods
	/**
	 * Look up the loaded result.
	 * @method getResult
	 * @param {Boolean} [raw=false] Return a raw result instead of a formatted result. This applies to content
	 * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be
	 * returned instead.
	 * @return {Object} A result object containing the content that was loaded, such as:
	 * <ul>
	 *      <li>An image tag (&lt;image /&gt;) for images</li>
	 *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts loaded with tags may be added to the
	 *      HTML head.</li>
	 *      <li>A style tag for CSS (&lt;style /&gt;)</li>
	 *      <li>Raw text for TEXT</li>
	 *      <li>A formatted JavaScript object defined by JSON</li>
	 *      <li>An XML document</li>
	 *      <li>An binary arraybuffer loaded by XHR</li>
	 * </ul>
	 * Note that if a raw result is requested, but not found, the result will be returned instead.
	 */
	p.getResult = function (raw) {
		if (raw && this._rawResponse) {
			return this._rawResponse;
		}
		return this._response;
	};

	// Overrides abstract method in AbstractRequest
	p.cancel = function () {
		this.canceled = true;
		this._clean();
		this._request.abort();
	};

	// Overrides abstract method in AbstractLoader
	p.load = function () {
		if (this._request == null) {
			this._handleError();
			return;
		}

		//Events
		if (this._request.addEventListener != null) {
			this._request.addEventListener("loadstart", this._handleLoadStartProxy, false);
			this._request.addEventListener("progress", this._handleProgressProxy, false);
			this._request.addEventListener("abort", this._handleAbortProxy, false);
			this._request.addEventListener("error", this._handleErrorProxy, false);
			this._request.addEventListener("timeout", this._handleTimeoutProxy, false);

			// Note: We don't get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.
			this._request.addEventListener("load", this._handleLoadProxy, false);
			this._request.addEventListener("readystatechange", this._handleReadyStateChangeProxy, false);
		} else {
			// IE9 support
			this._request.onloadstart = this._handleLoadStartProxy;
			this._request.onprogress = this._handleProgressProxy;
			this._request.onabort = this._handleAbortProxy;
			this._request.onerror = this._handleErrorProxy;
			this._request.ontimeout = this._handleTimeoutProxy;

			// Note: We don't get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.
			this._request.onload = this._handleLoadProxy;
			this._request.onreadystatechange = this._handleReadyStateChangeProxy;
		}

		// Set up a timeout if we don't have XHR2
		if (this._xhrLevel == 1) {
			this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);
		}

		// Sometimes we get back 404s immediately, particularly when there is a cross origin request.  // note this does not catch in Chrome
		try {
			if (!this._item.values || this._item.method == createjs.AbstractLoader.GET) {
				this._request.send();
			} else if (this._item.method == createjs.AbstractLoader.POST) {
				this._request.send(createjs.RequestUtils.formatQueryString(this._item.values));
			}
		} catch (error) {
			this.dispatchEvent(new createjs.ErrorEvent("XHR_SEND", null, error));
		}
	};

	p.setResponseType = function (type) {
		// Some old browsers doesn't support blob, so we convert arraybuffer to blob after response is downloaded
		if (type === 'blob') {
			type = window.URL ? 'blob' : 'arraybuffer';
			this._responseType = type;
		}
		this._request.responseType = type;
	};

	/**
	 * Get all the response headers from the XmlHttpRequest.
	 *
	 * <strong>From the docs:</strong> Return all the HTTP headers, excluding headers that are a case-insensitive match
	 * for Set-Cookie or Set-Cookie2, as a single string, with each header line separated by a U+000D CR U+000A LF pair,
	 * excluding the status line, and with each header name and header value separated by a U+003A COLON U+0020 SPACE
	 * pair.
	 * @method getAllResponseHeaders
	 * @return {String}
	 * @since 0.4.1
	 */
	p.getAllResponseHeaders = function () {
		if (this._request.getAllResponseHeaders instanceof Function) {
			return this._request.getAllResponseHeaders();
		} else {
			return null;
		}
	};

	/**
	 * Get a specific response header from the XmlHttpRequest.
	 *
	 * <strong>From the docs:</strong> Returns the header field value from the response of which the field name matches
	 * header, unless the field name is Set-Cookie or Set-Cookie2.
	 * @method getResponseHeader
	 * @param {String} header The header name to retrieve.
	 * @return {String}
	 * @since 0.4.1
	 */
	p.getResponseHeader = function (header) {
		if (this._request.getResponseHeader instanceof Function) {
			return this._request.getResponseHeader(header);
		} else {
			return null;
		}
	};

// protected methods
	/**
	 * The XHR request has reported progress.
	 * @method _handleProgress
	 * @param {Object} event The XHR progress event.
	 * @private
	 */
	p._handleProgress = function (event) {
		if (!event || event.loaded > 0 && event.total == 0) {
			return; // Sometimes we get no "total", so just ignore the progress event.
		}

		var newEvent = new createjs.ProgressEvent(event.loaded, event.total);
		this.dispatchEvent(newEvent);
	};

	/**
	 * The XHR request has reported a load start.
	 * @method _handleLoadStart
	 * @param {Object} event The XHR loadStart event.
	 * @private
	 */
	p._handleLoadStart = function (event) {
		clearTimeout(this._loadTimeout);
		this.dispatchEvent("loadstart");
	};

	/**
	 * The XHR request has reported an abort event.
	 * @method handleAbort
	 * @param {Object} event The XHR abort event.
	 * @private
	 */
	p._handleAbort = function (event) {
		this._clean();
		this.dispatchEvent(new createjs.ErrorEvent("XHR_ABORTED", null, event));
	};

	/**
	 * The XHR request has reported an error event.
	 * @method _handleError
	 * @param {Object} event The XHR error event.
	 * @private
	 */
	p._handleError = function (event) {
		this._clean();
		this.dispatchEvent(new createjs.ErrorEvent(event.message));
	};

	/**
	 * The XHR request has reported a readyState change. Note that older browsers (IE 7 & 8) do not provide an onload
	 * event, so we must monitor the readyStateChange to determine if the file is loaded.
	 * @method _handleReadyStateChange
	 * @param {Object} event The XHR readyStateChange event.
	 * @private
	 */
	p._handleReadyStateChange = function (event) {
		if (this._request.readyState == 4) {
			this._handleLoad();
		}
	};

	/**
	 * The XHR request has completed. This is called by the XHR request directly, or by a readyStateChange that has
	 * <code>request.readyState == 4</code>. Only the first call to this method will be processed.
	 * @method _handleLoad
	 * @param {Object} event The XHR load event.
	 * @private
	 */
	p._handleLoad = function (event) {
		if (this.loaded) {
			return;
		}
		this.loaded = true;

		var error = this._checkError();
		if (error) {
			this._handleError(error);
			return;
		}

		this._response = this._getResponse();
		// Convert arraybuffer back to blob
		if (this._responseType === 'arraybuffer') {
			try {
				this._response = new Blob([this._response]);
			} catch (e) {
				// Fallback to use BlobBuilder if Blob constructor is not supported
				// Tested on Android 2.3 ~ 4.2 and iOS5 safari
				window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
				if (e.name === 'TypeError' && window.BlobBuilder) {
					var builder = new BlobBuilder();
					builder.append(this._response);
					this._response = builder.getBlob();
				}
			}
		}
		this._clean();

		this.dispatchEvent(new createjs.Event("complete"));
	};

	/**
	 * The XHR request has timed out. This is called by the XHR request directly, or via a <code>setTimeout</code>
	 * callback.
	 * @method _handleTimeout
	 * @param {Object} [event] The XHR timeout event. This is occasionally null when called by the backup setTimeout.
	 * @private
	 */
	p._handleTimeout = function (event) {
		this._clean();

		this.dispatchEvent(new createjs.ErrorEvent("PRELOAD_TIMEOUT", null, event));
	};

// Protected
	/**
	 * Determine if there is an error in the current load. This checks the status of the request for problem codes. Note
	 * that this does not check for an actual response. Currently, it only checks for 404 or 0 error code.
	 * @method _checkError
	 * @return {int} If the request status returns an error code.
	 * @private
	 */
	p._checkError = function () {
		//LM: Probably need additional handlers here, maybe 501
		var status = parseInt(this._request.status);

		switch (status) {
			case 404:   // Not Found
			case 0:     // Not Loaded
				return new Error(status);
		}
		return null;
	};

	/**
	 * Validate the response. Different browsers have different approaches, some of which throw errors when accessed
	 * in other browsers. If there is no response, the <code>_response</code> property will remain null.
	 * @method _getResponse
	 * @private
	 */
	p._getResponse = function () {
		if (this._response != null) {
			return this._response;
		}

		if (this._request.response != null) {
			return this._request.response;
		}

		// Android 2.2 uses .responseText
		try {
			if (this._request.responseText != null) {
				return this._request.responseText;
			}
		} catch (e) {
		}

		// When loading XML, IE9 does not return .response, instead it returns responseXML.xml
		try {
			if (this._request.responseXML != null) {
				return this._request.responseXML;
			}
		} catch (e) {
		}

		return null;
	};

	/**
	 * Create an XHR request. Depending on a number of factors, we get totally different results.
	 * <ol><li>Some browsers get an <code>XDomainRequest</code> when loading cross-domain.</li>
	 *      <li>XMLHttpRequest are created when available.</li>
	 *      <li>ActiveX.XMLHTTP objects are used in older IE browsers.</li>
	 *      <li>Text requests override the mime type if possible</li>
	 *      <li>Origin headers are sent for crossdomain requests in some browsers.</li>
	 *      <li>Binary loads set the response type to "arraybuffer"</li></ol>
	 * @method _createXHR
	 * @param {Object} item The requested item that is being loaded.
	 * @return {Boolean} If an XHR request or equivalent was successfully created.
	 * @private
	 */
	p._createXHR = function (item) {
		// Check for cross-domain loads. We can't fully support them, but we can try.
		var crossdomain = createjs.RequestUtils.isCrossDomain(item);
		var headers = {};

		// Create the request. Fallback to whatever support we have.
		var req = null;
		if (window.XMLHttpRequest) {
			req = new XMLHttpRequest();
			// This is 8 or 9, so use XDomainRequest instead.
			if (crossdomain && req.withCredentials === undefined && window.XDomainRequest) {
				req = new XDomainRequest();
			}
		} else { // Old IE versions use a different approach
			for (var i = 0, l = s.ACTIVEX_VERSIONS.length; i < l; i++) {
				var axVersion = s.ACTIVEX_VERSIONS[i];
				try {
					req = new ActiveXObject(axVersion);
					break;
				} catch (e) {
				}
			}
			if (req == null) {
				return false;
			}
		}

		// Default to utf-8 for Text requests.
		if (item.mimeType == null && createjs.RequestUtils.isText(item.type)) {
			item.mimeType = "text/plain; charset=utf-8";
		}

		// IE9 doesn't support overrideMimeType(), so we need to check for it.
		if (item.mimeType && req.overrideMimeType) {
			req.overrideMimeType(item.mimeType);
		}

		// Determine the XHR level
		this._xhrLevel = (typeof req.responseType === "string") ? 2 : 1;

		var src = null;
		if (item.method == createjs.AbstractLoader.GET) {
			src = createjs.RequestUtils.buildPath(item.src, item.values);
		} else {
			src = item.src;
		}

		// Open the request.  Set cross-domain flags if it is supported (XHR level 1 only)
		req.open(item.method || createjs.AbstractLoader.GET, src, true);

		if (crossdomain && req instanceof XMLHttpRequest && this._xhrLevel == 1) {
			headers["Origin"] = location.origin;
		}

		// To send data we need to set the Content-type header)
		if (item.values && item.method == createjs.AbstractLoader.POST) {
			headers["Content-Type"] = "application/x-www-form-urlencoded";
		}

		if (!crossdomain && !headers["X-Requested-With"]) {
			headers["X-Requested-With"] = "XMLHttpRequest";
		}

		if (item.headers) {
			for (var n in item.headers) {
				headers[n] = item.headers[n];
			}
		}

		for (n in headers) {
			req.setRequestHeader(n, headers[n])
		}

		if (req instanceof XMLHttpRequest && item.withCredentials !== undefined) {
			req.withCredentials = item.withCredentials;
		}

		this._request = req;

		return true;
	};

	/**
	 * A request has completed (or failed or canceled), and needs to be disposed.
	 * @method _clean
	 * @private
	 */
	p._clean = function () {
		clearTimeout(this._loadTimeout);

		if (this._request.removeEventListener != null) {
			this._request.removeEventListener("loadstart", this._handleLoadStartProxy);
			this._request.removeEventListener("progress", this._handleProgressProxy);
			this._request.removeEventListener("abort", this._handleAbortProxy);
			this._request.removeEventListener("error", this._handleErrorProxy);
			this._request.removeEventListener("timeout", this._handleTimeoutProxy);
			this._request.removeEventListener("load", this._handleLoadProxy);
			this._request.removeEventListener("readystatechange", this._handleReadyStateChangeProxy);
		} else {
			this._request.onloadstart = null;
			this._request.onprogress = null;
			this._request.onabort = null;
			this._request.onerror = null;
			this._request.ontimeout = null;
			this._request.onload = null;
			this._request.onreadystatechange = null;
		}
	};

	p.toString = function () {
		return "[PreloadJS XHRRequest]";
	};

	createjs.XHRRequest = createjs.promote(XHRRequest, "AbstractRequest");

}());

//##############################################################################
// LoadQueue.js
//##############################################################################

this.createjs = this.createjs || {};

/*
 TODO: WINDOWS ISSUES
 * No error for HTML audio in IE 678
 * SVG no failure error in IE 67 (maybe 8) TAGS AND XHR
 * No script complete handler in IE 67 TAGS (XHR is fine)
 * No XML/JSON in IE6 TAGS
 * Need to hide loading SVG in Opera TAGS
 * No CSS onload/readystatechange in Safari or Android TAGS (requires rule checking)
 * SVG no load or failure in Opera XHR
 * Reported issues with IE7/8
 */

(function () {
	"use strict";

// constructor
	/**
	 * The LoadQueue class is the main API for preloading content. LoadQueue is a load manager, which can preload either
	 * a single file, or queue of files.
	 *
	 * <b>Creating a Queue</b><br />
	 * To use LoadQueue, create a LoadQueue instance. If you want to force tag loading where possible, set the preferXHR
	 * argument to false.
	 *
	 *      var queue = new createjs.LoadQueue(true);
	 *
	 * <b>Listening for Events</b><br />
	 * Add any listeners you want to the queue. Since PreloadJS 0.3.0, the {{#crossLink "EventDispatcher"}}{{/crossLink}}
	 * lets you add as many listeners as you want for events. You can subscribe to the following events:<ul>
	 *     <li>{{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}}: fired when a queue completes loading all
	 *     files</li>
	 *     <li>{{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}: fired when the queue encounters an error with
	 *     any file.</li>
	 *     <li>{{#crossLink "AbstractLoader/progress:event"}}{{/crossLink}}: Progress for the entire queue has
	 *     changed.</li>
	 *     <li>{{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}: A single file has completed loading.</li>
	 *     <li>{{#crossLink "LoadQueue/fileprogress:event"}}{{/crossLink}}: Progress for a single file has changes. Note
	 *     that only files loaded with XHR (or possibly by plugins) will fire progress events other than 0 or 100%.</li>
	 * </ul>
	 *
	 *      queue.on("fileload", handleFileLoad, this);
	 *      queue.on("complete", handleComplete, this);
	 *
	 * <b>Adding files and manifests</b><br />
	 * Add files you want to load using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or add multiple files at a
	 * time using a list or a manifest definition using {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. Files are
	 * appended to the end of the active queue, so you can use these methods as many times as you like, whenever you
	 * like.
	 *
	 *      queue.loadFile("filePath/file.jpg");
	 *      queue.loadFile({id:"image", src:"filePath/file.jpg"});
	 *      queue.loadManifest(["filePath/file.jpg", {id:"image", src:"filePath/file.jpg"}]);
	 *
	 *      // Use an external manifest
	 *      queue.loadManifest("path/to/manifest.json");
	 *      queue.loadManifest({src:"manifest.json", type:"manifest"});
	 *
	 * If you pass `false` as the `loadNow` parameter, the queue will not kick of the load of the files, but it will not
	 * stop if it has already been started. Call the {{#crossLink "AbstractLoader/load"}}{{/crossLink}} method to begin
	 * a paused queue. Note that a paused queue will automatically resume when new files are added to it with a
	 * `loadNow` argument of `true`.
	 *
	 *      queue.load();
	 *
	 * <b>File Types</b><br />
	 * The file type of a manifest item is auto-determined by the file extension. The pattern matching in PreloadJS
	 * should handle the majority of standard file and url formats, and works with common file extensions. If you have
	 * either a non-standard file extension, or are serving the file using a proxy script, then you can pass in a
	 * <code>type</code> property with any manifest item.
	 *
	 *      queue.loadFile({src:"path/to/myFile.mp3x", type:createjs.AbstractLoader.SOUND});
	 *
	 *      // Note that PreloadJS will not read a file extension from the query string
	 *      queue.loadFile({src:"http://server.com/proxy?file=image.jpg", type:createjs.AbstractLoader.IMAGE});
	 *
	 * Supported types are defined on the {{#crossLink "AbstractLoader"}}{{/crossLink}} class, and include:
	 * <ul>
	 *     <li>{{#crossLink "AbstractLoader/BINARY:property"}}{{/crossLink}}: Raw binary data via XHR</li>
	 *     <li>{{#crossLink "AbstractLoader/CSS:property"}}{{/crossLink}}: CSS files</li>
	 *     <li>{{#crossLink "AbstractLoader/IMAGE:property"}}{{/crossLink}}: Common image formats</li>
	 *     <li>{{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}}: JavaScript files</li>
	 *     <li>{{#crossLink "AbstractLoader/JSON:property"}}{{/crossLink}}: JSON data</li>
	 *     <li>{{#crossLink "AbstractLoader/JSONP:property"}}{{/crossLink}}: JSON files cross-domain</li>
	 *     <li>{{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}}: A list of files to load in JSON format, see
	 *     {{#crossLink "AbstractLoader/loadManifest"}}{{/crossLink}}</li>
	 *     <li>{{#crossLink "AbstractLoader/SOUND:property"}}{{/crossLink}}: Audio file formats</li>
	 *     <li>{{#crossLink "AbstractLoader/SPRITESHEET:property"}}{{/crossLink}}: JSON SpriteSheet definiteions. This
	 *     will also load sub-images, and provide a {{#crossLink "SpriteSheet"}}{{/crossLink}} instance.</li>
	 *     <li>{{#crossLink "AbstractLoader/SVG:property"}}{{/crossLink}}: SVG files</li>
	 *     <li>{{#crossLink "AbstractLoader/TEXT:property"}}{{/crossLink}}: Text files - XHR only</li>
	 *     <li>{{#crossLink "AbstractLoader/XML:property"}}{{/crossLink}}: XML data</li>
	 * </ul>
	 *
	 * <em>Note: Loader types used to be defined on LoadQueue, but have been moved to AbstractLoader for better
	 * portability of loader classes, which can be used individually now. The properties on LoadQueue still exist, but
	 * are deprecated.</em>
	 *
	 * <b>Handling Results</b><br />
	 * When a file is finished downloading, a {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event is
	 * dispatched. In an example above, there is an event listener snippet for fileload. Loaded files are usually a
	 * formatted object that can be used immediately, including:
	 * <ul>
	 *     <li>Binary: The binary loaded result</li>
	 *     <li>CSS: A &lt;link /&gt; tag</li>
	 *     <li>Image: An &lt;img /&gt; tag</li>
	 *     <li>JavaScript: A &lt;script /&gt; tag</li>
	 *     <li>JSON/JSONP: A formatted JavaScript Object</li>
	 *     <li>Manifest: A JavaScript object.
	 *     <li>Sound: An &lt;audio /&gt; tag</a>
	 *     <li>SpriteSheet: A {{#crossLink "SpriteSheet"}}{{/crossLink}} instance, containing loaded images.
	 *     <li>SVG: An &lt;object /&gt; tag</li>
	 *     <li>Text: Raw text</li>
	 *     <li>XML: An XML DOM node</li>
	 * </ul>
	 *
	 *      function handleFileLoad(event) {
	 *          var item = event.item; // A reference to the item that was passed in to the LoadQueue
	 *          var type = item.type;
	 *
	 *          // Add any images to the page body.
	 *          if (type == createjs.LoadQueue.IMAGE) {
	 *              document.body.appendChild(event.result);
	 *          }
	 *      }
	 *
	 * At any time after the file has been loaded (usually after the queue has completed), any result can be looked up
	 * via its "id" using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}. If no id was provided, then the
	 * "src" or file path can be used instead, including the `path` defined by a manifest, but <strong>not including</strong>
	 * a base path defined on the LoadQueue. It is recommended to always pass an id if you want to look up content.
	 *
	 *      var image = queue.getResult("image");
	 *      document.body.appendChild(image);
	 *
	 * Raw loaded content can be accessed using the <code>rawResult</code> property of the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}
	 * event, or can be looked up using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}, passing `true` as the 2nd
	 * argument. This is only applicable for content that has been parsed for the browser, specifically: JavaScript,
	 * CSS, XML, SVG, and JSON objects, or anything loaded with XHR.
	 *
	 *      var image = queue.getResult("image", true); // load the binary image data loaded with XHR.
	 *
	 * <b>Plugins</b><br />
	 * LoadQueue has a simple plugin architecture to help process and preload content. For example, to preload audio,
	 * make sure to install the <a href="http://soundjs.com">SoundJS</a> Sound class, which will help load HTML audio,
	 * Flash audio, and WebAudio files. This should be installed <strong>before</strong> loading any audio files.
	 *
	 *      queue.installPlugin(createjs.Sound);
	 *
	 * <h4>Known Browser Issues</h4>
	 * <ul>
	 *     <li>Browsers without audio support can not load audio files.</li>
	 *     <li>Safari on Mac OS X can only play HTML audio if QuickTime is installed</li>
	 *     <li>HTML Audio tags will only download until their <code>canPlayThrough</code> event is fired. Browsers other
	 *     than Chrome will continue to download in the background.</li>
	 *     <li>When loading scripts using tags, they are automatically added to the document.</li>
	 *     <li>Scripts loaded via XHR may not be properly inspectable with browser tools.</li>
	 *     <li>IE6 and IE7 (and some other browsers) may not be able to load XML, Text, or JSON, since they require
	 *     XHR to work.</li>
	 *     <li>Content loaded via tags will not show progress, and will continue to download in the background when
	 *     canceled, although no events will be dispatched.</li>
	 * </ul>
	 *
	 * @class LoadQueue
	 * @param {Boolean} [preferXHR=true] Determines whether the preload instance will favor loading with XHR (XML HTTP
	 * Requests), or HTML tags. When this is `false`, the queue will use tag loading when possible, and fall back on XHR
	 * when necessary.
	 * @param {String} [basePath=""] A path that will be prepended on to the source parameter of all items in the queue
	 * before they are loaded.  Sources beginning with a protocol such as `http://` or a relative path such as `../`
	 * will not receive a base path.
	 * @param {String|Boolean} [crossOrigin=""] An optional flag to support images loaded from a CORS-enabled server. To
	 * use it, set this value to `true`, which will default the crossOrigin property on images to "Anonymous". Any
	 * string value will be passed through, but only "" and "Anonymous" are recommended. <strong>Note: The crossOrigin
	 * parameter is deprecated. Use LoadItem.crossOrigin instead</strong>
	 *
	 * @constructor
	 * @extends AbstractLoader
	 */
	function LoadQueue (preferXHR, basePath, crossOrigin) {
		this.AbstractLoader_constructor();

		/**
		 * An array of the plugins registered using {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}}.
		 * @property _plugins
		 * @type {Array}
		 * @private
		 * @since 0.6.1
		 */
		this._plugins = [];

		/**
		 * An object hash of callbacks that are fired for each file type before the file is loaded, giving plugins the
		 * ability to override properties of the load. Please see the {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}}
		 * method for more information.
		 * @property _typeCallbacks
		 * @type {Object}
		 * @private
		 */
		this._typeCallbacks = {};

		/**
		 * An object hash of callbacks that are fired for each file extension before the file is loaded, giving plugins the
		 * ability to override properties of the load. Please see the {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}}
		 * method for more information.
		 * @property _extensionCallbacks
		 * @type {null}
		 * @private
		 */
		this._extensionCallbacks = {};

		/**
		 * The next preload queue to process when this one is complete. If an error is thrown in the current queue, and
		 * {{#crossLink "LoadQueue/stopOnError:property"}}{{/crossLink}} is `true`, the next queue will not be processed.
		 * @property next
		 * @type {LoadQueue}
		 * @default null
		 */
		this.next = null;

		/**
		 * Ensure loaded scripts "complete" in the order they are specified. Loaded scripts are added to the document head
		 * once they are loaded. Scripts loaded via tags will load one-at-a-time when this property is `true`, whereas
		 * scripts loaded using XHR can load in any order, but will "finish" and be added to the document in the order
		 * specified.
		 *
		 * Any items can be set to load in order by setting the {{#crossLink "maintainOrder:property"}}{{/crossLink}}
		 * property on the load item, or by ensuring that only one connection can be open at a time using
		 * {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}. Note that when the `maintainScriptOrder` property
		 * is set to `true`, scripts items are automatically set to `maintainOrder=true`, and changing the
		 * `maintainScriptOrder` to `false` during a load will not change items already in a queue.
		 *
		 * <h4>Example</h4>
		 *
		 *      var queue = new createjs.LoadQueue();
		 *      queue.setMaxConnections(3); // Set a higher number to load multiple items at once
		 *      queue.maintainScriptOrder = true; // Ensure scripts are loaded in order
		 *      queue.loadManifest([
		 *          "script1.js",
		 *          "script2.js",
		 *          "image.png", // Load any time
		 *          {src: "image2.png", maintainOrder: true} // Will wait for script2.js
		 *          "image3.png",
		 *          "script3.js" // Will wait for image2.png before loading (or completing when loading with XHR)
		 *      ]);
		 *
		 * @property maintainScriptOrder
		 * @type {Boolean}
		 * @default true
		 */
		this.maintainScriptOrder = true;

		/**
		 * Determines if the LoadQueue will stop processing the current queue when an error is encountered.
		 * @property stopOnError
		 * @type {Boolean}
		 * @default false
		 */
		this.stopOnError = false;

		/**
		 * The number of maximum open connections that a loadQueue tries to maintain. Please see
		 * {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}} for more information.
		 * @property _maxConnections
		 * @type {Number}
		 * @default 1
		 * @private
		 */
		this._maxConnections = 1;

		/**
		 * An internal list of all the default Loaders that are included with PreloadJS. Before an item is loaded, the
		 * available loader list is iterated, in the order they are included, and as soon as a loader indicates it can
		 * handle the content, it will be selected. The default loader, ({{#crossLink "TextLoader"}}{{/crossLink}} is
		 * last in the list, so it will be used if no other match is found. Typically, loaders will match based on the
		 * {{#crossLink "LoadItem/type"}}{{/crossLink}}, which is automatically determined using the file extension of
		 * the {{#crossLink "LoadItem/src:property"}}{{/crossLink}}.
		 *
		 * Loaders can be removed from PreloadJS by simply not including them.
		 *
		 * Custom loaders installed using {{#crossLink "registerLoader"}}{{/crossLink}} will be prepended to this list
		 * so that they are checked first.
		 * @property _availableLoaders
		 * @type {Array}
		 * @private
		 * @since 0.6.0
		 */
		this._availableLoaders = [
			createjs.ImageLoader,
			createjs.JavaScriptLoader,
			createjs.CSSLoader,
			createjs.JSONLoader,
			createjs.JSONPLoader,
			createjs.SoundLoader,
			createjs.ManifestLoader,
			createjs.SpriteSheetLoader,
			createjs.XMLLoader,
			createjs.SVGLoader,
			createjs.BinaryLoader,
			createjs.VideoLoader,
			createjs.TextLoader,
		];

		/**
		 * The number of built in loaders, so they can't be removed by {{#crossLink "unregisterLoader"}}{{/crossLink}.
				 * @property _defaultLoaderLength
		 * @type {Number}
		 * @private
		 * @since 0.6.0
		 */
		this._defaultLoaderLength = this._availableLoaders.length;

		this.init(preferXHR, basePath, crossOrigin);
	}

	var p = createjs.extend(LoadQueue, createjs.AbstractLoader);
	var s = LoadQueue;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.

	/**
	 * An internal initialization method, which is used for initial set up, but also to reset the LoadQueue.
	 * @method init
	 * @param preferXHR
	 * @param basePath
	 * @param crossOrigin
	 * @private
	 */
	p.init = function (preferXHR, basePath, crossOrigin) {

		// public properties
		/**
		 * @property useXHR
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 * @deprecated Use preferXHR instead.
		 */
		this.useXHR = true;

		/**
		 * Try and use XMLHttpRequest (XHR) when possible. Note that LoadQueue will default to tag loading or XHR
		 * loading depending on the requirements for a media type. For example, HTML audio can not be loaded with XHR,
		 * and plain text can not be loaded with tags, so it will default the the correct type instead of using the
		 * user-defined type.
		 * @type {Boolean}
		 * @default true
		 * @since 0.6.0
		 */
		this.preferXHR = true; //TODO: Get/Set
		this._preferXHR = true;
		this.setPreferXHR(preferXHR);

		// protected properties
		/**
		 * Whether the queue is currently paused or not.
		 * @property _paused
		 * @type {boolean}
		 * @private
		 */
		this._paused = false;

		/**
		 * A path that will be prepended on to the item's {{#crossLink "LoadItem/src:property"}}{{/crossLink}}. The
		 * `_basePath` property will only be used if an item's source is relative, and does not include a protocol such
		 * as `http://`, or a relative path such as `../`.
		 * @property _basePath
		 * @type {String}
		 * @private
		 * @since 0.3.1
		 */
		this._basePath = basePath;

		/**
		 * An optional flag to set on images that are loaded using PreloadJS, which enables CORS support. Images loaded
		 * cross-domain by servers that support CORS require the crossOrigin flag to be loaded and interacted with by
		 * a canvas. When loading locally, or with a server with no CORS support, this flag can cause other security issues,
		 * so it is recommended to only set it if you are sure the server supports it. Currently, supported values are ""
		 * and "Anonymous".
		 * @property _crossOrigin
		 * @type {String}
		 * @default ""
		 * @private
		 * @since 0.4.1
		 */
		this._crossOrigin = crossOrigin;

		/**
		 * Determines if the loadStart event was dispatched already. This event is only fired one time, when the first
		 * file is requested.
		 * @property _loadStartWasDispatched
		 * @type {Boolean}
		 * @default false
		 * @private
		 */
		this._loadStartWasDispatched = false;

		/**
		 * Determines if there is currently a script loading. This helps ensure that only a single script loads at once when
		 * using a script tag to do preloading.
		 * @property _currentlyLoadingScript
		 * @type {Boolean}
		 * @private
		 */
		this._currentlyLoadingScript = null;

		/**
		 * An array containing the currently downloading files.
		 * @property _currentLoads
		 * @type {Array}
		 * @private
		 */
		this._currentLoads = [];

		/**
		 * An array containing the queued items that have not yet started downloading.
		 * @property _loadQueue
		 * @type {Array}
		 * @private
		 */
		this._loadQueue = [];

		/**
		 * An array containing downloads that have not completed, so that the LoadQueue can be properly reset.
		 * @property _loadQueueBackup
		 * @type {Array}
		 * @private
		 */
		this._loadQueueBackup = [];

		/**
		 * An object hash of items that have finished downloading, indexed by the {{#crossLink "LoadItem"}}{{/crossLink}}
		 * id.
		 * @property _loadItemsById
		 * @type {Object}
		 * @private
		 */
		this._loadItemsById = {};

		/**
		 * An object hash of items that have finished downloading, indexed by {{#crossLink "LoadItem"}}{{/crossLink}}
		 * source.
		 * @property _loadItemsBySrc
		 * @type {Object}
		 * @private
		 */
		this._loadItemsBySrc = {};

		/**
		 * An object hash of loaded items, indexed by the ID of the {{#crossLink "LoadItem"}}{{/crossLink}}.
		 * @property _loadedResults
		 * @type {Object}
		 * @private
		 */
		this._loadedResults = {};

		/**
		 * An object hash of un-parsed loaded items, indexed by the ID of the {{#crossLink "LoadItem"}}{{/crossLink}}.
		 * @property _loadedRawResults
		 * @type {Object}
		 * @private
		 */
		this._loadedRawResults = {};

		/**
		 * The number of items that have been requested. This helps manage an overall progress without knowing how large
		 * the files are before they are downloaded. This does not include items inside of loaders such as the
		 * {{#crossLink "ManifestLoader"}}{{/crossLink}}.
		 * @property _numItems
		 * @type {Number}
		 * @default 0
		 * @private
		 */
		this._numItems = 0;

		/**
		 * The number of items that have completed loaded. This helps manage an overall progress without knowing how large
		 * the files are before they are downloaded.
		 * @property _numItemsLoaded
		 * @type {Number}
		 * @default 0
		 * @private
		 */
		this._numItemsLoaded = 0;

		/**
		 * A list of scripts in the order they were requested. This helps ensure that scripts are "completed" in the right
		 * order.
		 * @property _scriptOrder
		 * @type {Array}
		 * @private
		 */
		this._scriptOrder = [];

		/**
		 * A list of scripts that have been loaded. Items are added to this list as <code>null</code> when they are
		 * requested, contain the loaded item if it has completed, but not been dispatched to the user, and <code>true</true>
		 * once they are complete and have been dispatched.
		 * @property _loadedScripts
		 * @type {Array}
		 * @private
		 */
		this._loadedScripts = [];

		/**
		 * The last progress amount. This is used to suppress duplicate progress events.
		 * @property _lastProgress
		 * @type {Number}
		 * @private
		 * @since 0.6.0
		 */
		this._lastProgress = NaN;

	};

// static properties
	/**
	 * The time in milliseconds to assume a load has failed. An {{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}
	 * event is dispatched if the timeout is reached before any data is received.
	 * @property loadTimeout
	 * @type {Number}
	 * @default 8000
	 * @static
	 * @since 0.4.1
	 * @deprecated In favour of {{#crossLink "LoadItem/LOAD_TIMEOUT_DEFAULT:property}}{{/crossLink}} property.
	 */
	s.loadTimeout = 8000;

	/**
	 * The time in milliseconds to assume a load has failed.
	 * @property LOAD_TIMEOUT
	 * @type {Number}
	 * @default 0
	 * @deprecated in favor of the {{#crossLink "LoadQueue/loadTimeout:property"}}{{/crossLink}} property.
	 */
	s.LOAD_TIMEOUT = 0;

// Preload Types
	/**
	 * @property BINARY
	 * @type {String}
	 * @default binary
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/BINARY:property"}}{{/crossLink}} instead.
	 */
	s.BINARY = createjs.AbstractLoader.BINARY;

	/**
	 * @property CSS
	 * @type {String}
	 * @default css
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/CSS:property"}}{{/crossLink}} instead.
	 */
	s.CSS = createjs.AbstractLoader.CSS;

	/**
	 * @property IMAGE
	 * @type {String}
	 * @default image
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/CSS:property"}}{{/crossLink}} instead.
	 */
	s.IMAGE = createjs.AbstractLoader.IMAGE;

	/**
	 * @property JAVASCRIPT
	 * @type {String}
	 * @default javascript
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}} instead.
	 */
	s.JAVASCRIPT = createjs.AbstractLoader.JAVASCRIPT;

	/**
	 * @property JSON
	 * @type {String}
	 * @default json
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JSON:property"}}{{/crossLink}} instead.
	 */
	s.JSON = createjs.AbstractLoader.JSON;

	/**
	 * @property JSONP
	 * @type {String}
	 * @default jsonp
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JSONP:property"}}{{/crossLink}} instead.
	 */
	s.JSONP = createjs.AbstractLoader.JSONP;

	/**
	 * @property MANIFEST
	 * @type {String}
	 * @default manifest
	 * @static
	 * @since 0.4.1
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}} instead.
	 */
	s.MANIFEST = createjs.AbstractLoader.MANIFEST;

	/**
	 * @property SOUND
	 * @type {String}
	 * @default sound
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}} instead.
	 */
	s.SOUND = createjs.AbstractLoader.SOUND;

	/**
	 * @property VIDEO
	 * @type {String}
	 * @default video
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}} instead.
	 */
	s.VIDEO = createjs.AbstractLoader.VIDEO;

	/**
	 * @property SVG
	 * @type {String}
	 * @default svg
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/SVG:property"}}{{/crossLink}} instead.
	 */
	s.SVG = createjs.AbstractLoader.SVG;

	/**
	 * @property TEXT
	 * @type {String}
	 * @default text
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/TEXT:property"}}{{/crossLink}} instead.
	 */
	s.TEXT = createjs.AbstractLoader.TEXT;

	/**
	 * @property XML
	 * @type {String}
	 * @default xml
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/XML:property"}}{{/crossLink}} instead.
	 */
	s.XML = createjs.AbstractLoader.XML;

	/**
	 * @property POST
	 * @type {string}
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/POST:property"}}{{/crossLink}} instead.
	 */
	s.POST = createjs.AbstractLoader.POST;

	/**
	 * @property GET
	 * @type {string}
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/GET:property"}}{{/crossLink}} instead.
	 */
	s.GET = createjs.AbstractLoader.GET;

// events
	/**
	 * This event is fired when an individual file has loaded, and been processed.
	 * @event fileload
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a `src` property.
	 * @param {Object} result The HTML tag or parsed result of the loaded item.
	 * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted
	 * to a usable object.
	 * @since 0.3.0
	 */

	/**
	 * This {{#crossLink "ProgressEvent"}}{{/crossLink}} that is fired when an an individual file's progress changes.
	 * @event fileprogress
	 * @since 0.3.0
	 */

	/**
	 * This event is fired when an individual file starts to load.
	 * @event filestart
	 * @param {Object} The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a property.
	 */

// public methods
	/**
	 * Register a custom loaders class. New loaders are given precedence over loaders added earlier and default loaders.
	 * It is recommended that loaders extend {{#crossLink "AbstractLoader"}}{{/crossLink}}. Loaders can only be added
	 * once, and will be prepended to the list of available loaders.
	 * @method registerLoader
	 * @param {Function|AbstractLoader} loader The AbstractLoader class to add.
	 * @since 0.6.0
	 */
	p.registerLoader = function (loader) {
		if (!loader || !loader.canLoadItem) {
			throw new Error("loader is of an incorrect type.");
		} else if (this._availableLoaders.indexOf(loader) != -1) {
			throw new Error("loader already exists."); //LM: Maybe just silently fail here
		}

		this._availableLoaders.unshift(loader);
	};

	/**
	 * Remove a custom loader added usig {{#crossLink "registerLoader"}}{{/crossLink}}. Only custom loaders can be
	 * unregistered, the default loaders will always be available.
	 * @method unregisterLoader
	 * @param {Function|AbstractLoader} loader The AbstractLoader class to remove
	 */
	p.unregisterLoader = function (loader) {
		var idx = this._availableLoaders.indexOf(loader);
		if (idx != -1 && idx < this._defaultLoaderLength - 1) {
			this._availableLoaders.splice(idx, 1);
		}
	};

	/**
	 * @method setUseXHR
	 * @param {Boolean} value The new useXHR value to set.
	 * @return {Boolean} The new useXHR value. If XHR is not supported by the browser, this will return false, even if
	 * the provided value argument was true.
	 * @since 0.3.0
	 * @deprecated use the {{#crossLink "preferXHR:property"}}{{/crossLink}} property, or the {{#crossLink "setUseXHR"}}{{/crossLink}}
	 * method instead.
	 */
	p.setUseXHR = function (value) {
		return this.setPreferXHR(value);
	};

	/**
	 * Change the {{#crossLink "preferXHR:property"}}{{/crossLink}} value. Note that if this is set to `true`, it may
	 * fail, or be ignored depending on the browser's capabilities and the load type.
	 * @method setPreferXHR
	 * @param {Boolean} value
	 * @returns {Boolean} The value of {{#crossLink "preferXHR"}}{{/crossLink}} that was successfully set.
	 * @since 0.6.0
	 */
	p.setPreferXHR = function (value) {
		// Determine if we can use XHR. XHR defaults to TRUE, but the browser may not support it.
		//TODO: Should we be checking for the other XHR types? Might have to do a try/catch on the different types similar to createXHR.
		this.preferXHR = (value != false && window.XMLHttpRequest != null);
		return this.preferXHR;
	};

	/**
	 * Stops all queued and loading items, and clears the queue. This also removes all internal references to loaded
	 * content, and allows the queue to be used again.
	 * @method removeAll
	 * @since 0.3.0
	 */
	p.removeAll = function () {
		this.remove();
	};

	/**
	 * Stops an item from being loaded, and removes it from the queue. If nothing is passed, all items are removed.
	 * This also removes internal references to loaded item(s).
	 *
	 * <h4>Example</h4>
	 *
	 *      queue.loadManifest([
	 *          {src:"test.png", id:"png"},
	 *          {src:"test.jpg", id:"jpg"},
	 *          {src:"test.mp3", id:"mp3"}
	 *      ]);
	 *      queue.remove("png"); // Single item by ID
	 *      queue.remove("png", "test.jpg"); // Items as arguments. Mixed id and src.
	 *      queue.remove(["test.png", "jpg"]); // Items in an Array. Mixed id and src.
	 *
	 * @method remove
	 * @param {String | Array} idsOrUrls* The id or ids to remove from this queue. You can pass an item, an array of
	 * items, or multiple items as arguments.
	 * @since 0.3.0
	 */
	p.remove = function (idsOrUrls) {
		var args = null;

		if (idsOrUrls && !(idsOrUrls instanceof Array)) {
			args = [idsOrUrls];
		} else if (idsOrUrls) {
			args = idsOrUrls;
		} else if (arguments.length > 0) {
			return;
		}

		var itemsWereRemoved = false;

		// Destroy everything
		if (!args) {
			this.close();
			for (var n in this._loadItemsById) {
				this._disposeItem(this._loadItemsById[n]);
			}
			this.init(this.preferXHR, this._basePath);

			// Remove specific items
		} else {
			while (args.length) {
				var item = args.pop();
				var r = this.getResult(item);

				//Remove from the main load Queue
				for (i = this._loadQueue.length - 1; i >= 0; i--) {
					loadItem = this._loadQueue[i].getItem();
					if (loadItem.id == item || loadItem.src == item) {
						this._loadQueue.splice(i, 1)[0].cancel();
						break;
					}
				}

				//Remove from the backup queue
				for (i = this._loadQueueBackup.length - 1; i >= 0; i--) {
					loadItem = this._loadQueueBackup[i].getItem();
					if (loadItem.id == item || loadItem.src == item) {
						this._loadQueueBackup.splice(i, 1)[0].cancel();
						break;
					}
				}

				if (r) {
					this._disposeItem(this.getItem(item));
				} else {
					for (var i = this._currentLoads.length - 1; i >= 0; i--) {
						var loadItem = this._currentLoads[i].getItem();
						if (loadItem.id == item || loadItem.src == item) {
							this._currentLoads.splice(i, 1)[0].cancel();
							itemsWereRemoved = true;
							break;
						}
					}
				}
			}

			// If this was called during a load, try to load the next item.
			if (itemsWereRemoved) {
				this._loadNext();
			}
		}
	};

	/**
	 * Stops all open loads, destroys any loaded items, and resets the queue, so all items can
	 * be reloaded again by calling {{#crossLink "AbstractLoader/load"}}{{/crossLink}}. Items are not removed from the
	 * queue. To remove items use the {{#crossLink "LoadQueue/remove"}}{{/crossLink}} or
	 * {{#crossLink "LoadQueue/removeAll"}}{{/crossLink}} method.
	 * @method reset
	 * @since 0.3.0
	 */
	p.reset = function () {
		this.close();
		for (var n in this._loadItemsById) {
			this._disposeItem(this._loadItemsById[n]);
		}

		//Reset the queue to its start state
		var a = [];
		for (var i = 0, l = this._loadQueueBackup.length; i < l; i++) {
			a.push(this._loadQueueBackup[i].getItem());
		}

		this.loadManifest(a, false);
	};

	/**
	 * Register a plugin. Plugins can map to load types (sound, image, etc), or specific extensions (png, mp3, etc).
	 * Currently, only one plugin can exist per type/extension.
	 *
	 * When a plugin is installed, a <code>getPreloadHandlers()</code> method will be called on it. For more information
	 * on this method, check out the {{#crossLink "SamplePlugin/getPreloadHandlers"}}{{/crossLink}} method in the
	 * {{#crossLink "SamplePlugin"}}{{/crossLink}} class.
	 *
	 * Before a file is loaded, a matching plugin has an opportunity to modify the load. If a `callback` is returned
	 * from the {{#crossLink "SamplePlugin/getPreloadHandlers"}}{{/crossLink}} method, it will be invoked first, and its
	 * result may cancel or modify the item. The callback method can also return a `completeHandler` to be fired when
	 * the file is loaded, or a `tag` object, which will manage the actual download. For more information on these
	 * methods, check out the {{#crossLink "SamplePlugin/preloadHandler"}}{{/crossLink}} and {{#crossLink "SamplePlugin/fileLoadHandler"}}{{/crossLink}}
	 * methods on the {{#crossLink "SamplePlugin"}}{{/crossLink}}.
	 *
	 * @method installPlugin
	 * @param {Function} plugin The plugin class to install.
	 */
	p.installPlugin = function (plugin) {
		if (plugin == null) {
			return;
		}

		if (plugin.getPreloadHandlers != null) {
			this._plugins.push(plugin);
			var map = plugin.getPreloadHandlers();
			map.scope = plugin;

			if (map.types != null) {
				for (var i = 0, l = map.types.length; i < l; i++) {
					this._typeCallbacks[map.types[i]] = map;
				}
			}

			if (map.extensions != null) {
				for (i = 0, l = map.extensions.length; i < l; i++) {
					this._extensionCallbacks[map.extensions[i]] = map;
				}
			}
		}
	};

	/**
	 * Set the maximum number of concurrent connections. Note that browsers and servers may have a built-in maximum
	 * number of open connections, so any additional connections may remain in a pending state until the browser
	 * opens the connection. When loading scripts using tags, and when {{#crossLink "LoadQueue/maintainScriptOrder:property"}}{{/crossLink}}
	 * is `true`, only one script is loaded at a time due to browser limitations.
	 *
	 * <h4>Example</h4>
	 *
	 *      var queue = new createjs.LoadQueue();
	 *      queue.setMaxConnections(10); // Allow 10 concurrent loads
	 *
	 * @method setMaxConnections
	 * @param {Number} value The number of concurrent loads to allow. By default, only a single connection per LoadQueue
	 * is open at any time.
	 */
	p.setMaxConnections = function (value) {
		this._maxConnections = value;
		if (!this._paused && this._loadQueue.length > 0) {
			this._loadNext();
		}
	};

	/**
	 * Load a single file. To add multiple files at once, use the {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}
	 * method.
	 *
	 * Files are always appended to the current queue, so this method can be used multiple times to add files.
	 * To clear the queue first, use the {{#crossLink "AbstractLoader/close"}}{{/crossLink}} method.
	 * @method loadFile
	 * @param {LoadItem|Object|String} file The file object or path to load. A file can be either
	 * <ul>
	 *     <li>A {{#crossLink "LoadItem"}}{{/crossLink}} instance</li>
	 *     <li>An object containing properties defined by {{#crossLink "LoadItem"}}{{/crossLink}}</li>
	 *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink "LoadItem"}}{{/crossLink}}
	 *     in the background.</li>
	 * </ul>
	 * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default
	 * value is true. If the queue is paused using {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}}, and the value is
	 * `true`, the queue will resume automatically.
	 * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the
	 * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}},
	 * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>
	 * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue
	 * constructor, or a `path` property in a manifest definition.
	 */
	p.loadFile = function (file, loadNow, basePath) {
		if (file == null) {
			var event = new createjs.ErrorEvent("PRELOAD_NO_FILE");
			this._sendError(event);
			return;
		}
		this._addItem(file, null, basePath);

		if (loadNow !== false) {
			this.setPaused(false);
		} else {
			this.setPaused(true);
		}
	};

	/**
	 * Load an array of files. To load a single file, use the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} method.
	 * The files in the manifest are requested in the same order, but may complete in a different order if the max
	 * connections are set above 1 using {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}. Scripts will load
	 * in the right order as long as {{#crossLink "LoadQueue/maintainScriptOrder"}}{{/crossLink}} is true (which is
	 * default).
	 *
	 * Files are always appended to the current queue, so this method can be used multiple times to add files.
	 * To clear the queue first, use the {{#crossLink "AbstractLoader/close"}}{{/crossLink}} method.
	 * @method loadManifest
	 * @param {Array|String|Object} manifest An list of files to load. The loadManifest call supports four types of
	 * manifests:
	 * <ol>
	 *     <li>A string path, which points to a manifest file, which is a JSON file that contains a "manifest" property,
	 *     which defines the list of files to load, and can optionally contain a "path" property, which will be
	 *     prepended to each file in the list.</li>
	 *     <li>An object which defines a "src", which is a JSON or JSONP file. A "callback" can be defined for JSONP
	 *     file. The JSON/JSONP file should contain a "manifest" property, which defines the list of files to load,
	 *     and can optionally contain a "path" property, which will be prepended to each file in the list.</li>
	 *     <li>An object which contains a "manifest" property, which defines the list of files to load, and can
	 *     optionally contain a "path" property, which will be prepended to each file in the list.</li>
	 *     <li>An Array of files to load.</li>
	 * </ol>
	 *
	 * Each "file" in a manifest can be either:
	 * <ul>
	 *     <li>A {{#crossLink "LoadItem"}}{{/crossLink}} instance</li>
	 *     <li>An object containing properties defined by {{#crossLink "LoadItem"}}{{/crossLink}}</li>
	 *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink "LoadItem"}}{{/crossLink}}
	 *     in the background.</li>
	 * </ul>
	 *
	 * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default
	 * value is true. If the queue is paused using {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}} and this value is
	 * `true`, the queue will resume automatically.
	 * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the
	 * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink "LoadQueue/MANIFEST:property"}}{{/crossLink}},
	 * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>
	 * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue
	 * constructor, or a `path` property in a manifest definition.
	 */
	p.loadManifest = function (manifest, loadNow, basePath) {
		var fileList = null;
		var path = null;

		// Array-based list of items
		if (manifest instanceof Array) {
			if (manifest.length == 0) {
				var event = new createjs.ErrorEvent("PRELOAD_MANIFEST_EMPTY");
				this._sendError(event);
				return;
			}
			fileList = manifest;

			// String-based. Only file manifests can be specified this way. Any other types will cause an error when loaded.
		} else if (typeof(manifest) === "string") {
			fileList = [
				{
					src: manifest,
					type: s.MANIFEST
				}
			];

		} else if (typeof(manifest) == "object") {

			// An object that defines a manifest path
			if (manifest.src !== undefined) {
				if (manifest.type == null) {
					manifest.type = s.MANIFEST;
				} else if (manifest.type != s.MANIFEST) {
					var event = new createjs.ErrorEvent("PRELOAD_MANIFEST_TYPE");
					this._sendError(event);
				}
				fileList = [manifest];

				// An object that defines a manifest
			} else if (manifest.manifest !== undefined) {
				fileList = manifest.manifest;
				path = manifest.path;
			}

			// Unsupported. This will throw an error.
		} else {
			var event = new createjs.ErrorEvent("PRELOAD_MANIFEST_NULL");
			this._sendError(event);
			return;
		}

		for (var i = 0, l = fileList.length; i < l; i++) {
			this._addItem(fileList[i], path, basePath);
		}

		if (loadNow !== false) {
			this.setPaused(false);
		} else {
			this.setPaused(true);
		}

	};

	/**
	 * Start a LoadQueue that was created, but not automatically started.
	 * @method load
	 */
	p.load = function () {
		this.setPaused(false);
	};

	/**
	 * Look up a {{#crossLink "LoadItem"}}{{/crossLink}} using either the "id" or "src" that was specified when loading it. Note that if no "id" was
	 * supplied with the load item, the ID will be the "src", including a `path` property defined by a manifest. The
	 * `basePath` will not be part of the ID.
	 * @method getItem
	 * @param {String} value The <code>id</code> or <code>src</code> of the load item.
	 * @return {Object} The load item that was initially requested using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. This object is also returned via the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}
	 * event as the `item` parameter.
	 */
	p.getItem = function (value) {
		return this._loadItemsById[value] || this._loadItemsBySrc[value];
	};

	/**
	 * Look up a loaded result using either the "id" or "src" that was specified when loading it. Note that if no "id"
	 * was supplied with the load item, the ID will be the "src", including a `path` property defined by a manifest. The
	 * `basePath` will not be part of the ID.
	 * @method getResult
	 * @param {String} value The <code>id</code> or <code>src</code> of the load item.
	 * @param {Boolean} [rawResult=false] Return a raw result instead of a formatted result. This applies to content
	 * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be
	 * returned instead.
	 * @return {Object} A result object containing the content that was loaded, such as:
	 * <ul>
	 *      <li>An image tag (&lt;image /&gt;) for images</li>
	 *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts are automatically added to the HTML
	 *      DOM.</li>
	 *      <li>A style tag for CSS (&lt;style /&gt; or &lt;link &gt;)</li>
	 *      <li>Raw text for TEXT</li>
	 *      <li>A formatted JavaScript object defined by JSON</li>
	 *      <li>An XML document</li>
	 *      <li>A binary arraybuffer loaded by XHR</li>
	 *      <li>An audio tag (&lt;audio &gt;) for HTML audio. Note that it is recommended to use SoundJS APIs to play
	 *      loaded audio. Specifically, audio loaded by Flash and WebAudio will return a loader object using this method
	 *      which can not be used to play audio back.</li>
	 * </ul>
	 * This object is also returned via the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event as the 'item`
	 * parameter. Note that if a raw result is requested, but not found, the result will be returned instead.
	 */
	p.getResult = function (value, rawResult) {
		var item = this._loadItemsById[value] || this._loadItemsBySrc[value];
		if (item == null) {
			return null;
		}
		var id = item.id;
		if (rawResult && this._loadedRawResults[id]) {
			return this._loadedRawResults[id];
		}
		return this._loadedResults[id];
	};

	/**
	 * Generate an list of items loaded by this queue.
	 * @method getItems
	 * @param {Boolean} loaded Determines if only items that have been loaded should be returned. If false, in-progress
	 * and failed load items will also be included.
	 * @returns {Array} A list of objects that have been loaded. Each item includes the {{#crossLink "LoadItem"}}{{/crossLink}},
	 * result, and rawResult.
	 * @since 0.6.0
	 */
	p.getItems = function (loaded) {
		var arr = [];
		for (var n in this._loadItemsById) {
			var item = this._loadItemsById[n];
			var result = this.getResult(n);
			if (loaded === true && result == null) {
				continue;
			}
			arr.push({
				item: item,
				result: result,
				rawResult: this.getResult(n, true)
			});
		}
		return arr;
	};

	/**
	 * Pause or resume the current load. Active loads will not be cancelled, but the next items in the queue will not
	 * be processed when active loads complete. LoadQueues are not paused by default.
	 *
	 * Note that if new items are added to the queue using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or
	 * {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}, a paused queue will be resumed, unless the `loadNow`
	 * argument is `false`.
	 * @method setPaused
	 * @param {Boolean} value Whether the queue should be paused or not.
	 */
	p.setPaused = function (value) {
		this._paused = value;
		if (!this._paused) {
			this._loadNext();
		}
	};

	/**
	 * Close the active queue. Closing a queue completely empties the queue, and prevents any remaining items from
	 * starting to download. Note that currently any active loads will remain open, and events may be processed.
	 *
	 * To stop and restart a queue, use the {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}} method instead.
	 * @method close
	 */
	p.close = function () {
		while (this._currentLoads.length) {
			this._currentLoads.pop().cancel();
		}
		this._scriptOrder.length = 0;
		this._loadedScripts.length = 0;
		this.loadStartWasDispatched = false;
		this._itemCount = 0;
		this._lastProgress = NaN;
	};

// protected methods
	/**
	 * Add an item to the queue. Items are formatted into a usable object containing all the properties necessary to
	 * load the content. The load queue is populated with the loader instance that handles preloading, and not the load
	 * item that was passed in by the user. To look up the load item by id or src, use the {{#crossLink "LoadQueue.getItem"}}{{/crossLink}}
	 * method.
	 * @method _addItem
	 * @param {String|Object} value The item to add to the queue.
	 * @param {String} [path] An optional path prepended to the `src`. The path will only be prepended if the src is
	 * relative, and does not start with a protocol such as `http://`, or a path like `../`. If the LoadQueue was
	 * provided a {{#crossLink "_basePath"}}{{/crossLink}}, then it will optionally be prepended after.
	 * @param {String} [basePath] <strong>Deprecated</strong>An optional basePath passed into a {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} call. This parameter will be removed in a future tagged
	 * version.
	 * @private
	 */
	p._addItem = function (value, path, basePath) {
		var item = this._createLoadItem(value, path, basePath); // basePath and manifest path are added to the src.
		if (item == null) {
			return;
		} // Sometimes plugins or types should be skipped.
		var loader = this._createLoader(item);
		if (loader != null) {
			if ("plugins" in loader) {
				loader.plugins = this._plugins;
			}
			item._loader = loader;
			this._loadQueue.push(loader);
			this._loadQueueBackup.push(loader);

			this._numItems++;
			this._updateProgress();

			// Only worry about script order when using XHR to load scripts. Tags are only loading one at a time.
			if ((this.maintainScriptOrder
					&& item.type == createjs.LoadQueue.JAVASCRIPT
						//&& loader instanceof createjs.XHRLoader //NOTE: Have to track all JS files this way
					)
					|| item.maintainOrder === true) {
				this._scriptOrder.push(item);
				this._loadedScripts.push(null);
			}
		}
	};

	/**
	 * Create a refined {{#crossLink "LoadItem"}}{{/crossLink}}, which contains all the required properties. The type of
	 * item is determined by browser support, requirements based on the file type, and developer settings. For example,
	 * XHR is only used for file types that support it in new browsers.
	 *
	 * Before the item is returned, any plugins registered to handle the type or extension will be fired, which may
	 * alter the load item.
	 * @method _createLoadItem
	 * @param {String | Object | HTMLAudioElement | HTMLImageElement} value The item that needs to be preloaded.
	 * @param {String} [path] A path to prepend to the item's source. Sources beginning with http:// or similar will
	 * not receive a path. Since PreloadJS 0.4.1, the src will be modified to include the `path` and {{#crossLink "LoadQueue/_basePath:property"}}{{/crossLink}}
	 * when it is added.
	 * @param {String} [basePath] <strong>Deprectated</strong> A base path to prepend to the items source in addition to
	 * the path argument.
	 * @return {Object} The loader instance that will be used.
	 * @private
	 */
	p._createLoadItem = function (value, path, basePath) {
		var item = createjs.LoadItem.create(value);
		if (item == null) {
			return null;
		}

		var bp = ""; // Store the generated basePath
		var useBasePath = basePath || this._basePath;

		if (item.src instanceof Object) {
			if (!item.type) {
				return null;
			} // the the src is an object, type is required to pass off to plugin
			if (path) {
				bp = path;
				var pathMatch = createjs.RequestUtils.parseURI(path);
				// Also append basePath
				if (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {
					bp = useBasePath + bp;
				}
			} else if (useBasePath != null) {
				bp = useBasePath;
			}
		} else {
			// Determine Extension, etc.
			var match = createjs.RequestUtils.parseURI(item.src);
			if (match.extension) {
				item.ext = match.extension;
			}
			if (item.type == null) {
				item.type = createjs.RequestUtils.getTypeByExtension(item.ext);
			}

			// Inject path & basePath
			var autoId = item.src;
			if (!match.absolute && !match.relative) {
				if (path) {
					bp = path;
					var pathMatch = createjs.RequestUtils.parseURI(path);
					autoId = path + autoId;
					// Also append basePath
					if (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {
						bp = useBasePath + bp;
					}
				} else if (useBasePath != null) {
					bp = useBasePath;
				}
			}
			item.src = bp + item.src;
		}
		item.path = bp;

		// If there's no id, set one now.
		if (item.id === undefined || item.id === null || item.id === "") {
			item.id = autoId;
		}

		// Give plugins a chance to modify the loadItem:
		var customHandler = this._typeCallbacks[item.type] || this._extensionCallbacks[item.ext];
		if (customHandler) {
			// Plugins are now passed both the full source, as well as a combined path+basePath (appropriately)
			var result = customHandler.callback.call(customHandler.scope, item, this);

			// The plugin will handle the load, or has canceled it. Ignore it.
			if (result === false) {
				return null;

				// Load as normal:
			} else if (result === true) {
				// Do Nothing

				// Result is a loader class:
			} else if (result != null) {
				item._loader = result;
			}

			// Update the extension in case the type changed:
			match = createjs.RequestUtils.parseURI(item.src);
			if (match.extension != null) {
				item.ext = match.extension;
			}
		}

		// Store the item for lookup. This also helps clean-up later.
		this._loadItemsById[item.id] = item;
		this._loadItemsBySrc[item.src] = item;

		if (item.crossOrigin == null) {
			item.crossOrigin = this._crossOrigin;
		}

		return item;
	};

	/**
	 * Create a loader for a load item.
	 * @method _createLoader
	 * @param {Object} item A formatted load item that can be used to generate a loader.
	 * @return {AbstractLoader} A loader that can be used to load content.
	 * @private
	 */
	p._createLoader = function (item) {
		if (item._loader != null) { // A plugin already specified a loader
			return item._loader;
		}

		// Initially, try and use the provided/supported XHR mode:
		var preferXHR = this.preferXHR;

		for (var i = 0; i < this._availableLoaders.length; i++) {
			var loader = this._availableLoaders[i];
			if (loader && loader.canLoadItem(item)) {
				return new loader(item, preferXHR);
			}
		}

		// TODO: Log error (requires createjs.log)
		return null;
	};

	/**
	 * Load the next item in the queue. If the queue is empty (all items have been loaded), then the complete event
	 * is processed. The queue will "fill up" any empty slots, up to the max connection specified using
	 * {{#crossLink "LoadQueue.setMaxConnections"}}{{/crossLink}} method. The only exception is scripts that are loaded
	 * using tags, which have to be loaded one at a time to maintain load order.
	 * @method _loadNext
	 * @private
	 */
	p._loadNext = function () {
		if (this._paused) {
			return;
		}

		// Only dispatch loadstart event when the first file is loaded.
		if (!this._loadStartWasDispatched) {
			this._sendLoadStart();
			this._loadStartWasDispatched = true;
		}

		// The queue has completed.
		if (this._numItems == this._numItemsLoaded) {
			this.loaded = true;
			this._sendComplete();

			// Load the next queue, if it has been defined.
			if (this.next && this.next.load) {
				this.next.load();
			}
		} else {
			this.loaded = false;
		}

		// Must iterate forwards to load in the right order.
		for (var i = 0; i < this._loadQueue.length; i++) {
			if (this._currentLoads.length >= this._maxConnections) {
				break;
			}
			var loader = this._loadQueue[i];

			// Determine if we should be only loading one tag-script at a time:
			// Note: maintainOrder items don't do anything here because we can hold onto their loaded value
			if (!this._canStartLoad(loader)) {
				continue;
			}
			this._loadQueue.splice(i, 1);
			i--;
			this._loadItem(loader);
		}
	};

	/**
	 * Begin loading an item. Event listeners are not added to the loaders until the load starts.
	 * @method _loadItem
	 * @param {AbstractLoader} loader The loader instance to start. Currently, this will be an XHRLoader or TagLoader.
	 * @private
	 */
	p._loadItem = function (loader) {
		loader.on("fileload", this._handleFileLoad, this);
		loader.on("progress", this._handleProgress, this);
		loader.on("complete", this._handleFileComplete, this);
		loader.on("error", this._handleError, this);
		loader.on("fileerror", this._handleFileError, this);
		this._currentLoads.push(loader);
		this._sendFileStart(loader.getItem());
		loader.load();
	};

	/**
	 * The callback that is fired when a loader loads a file. This enables loaders like {{#crossLink "ManifestLoader"}}{{/crossLink}}
	 * to maintain internal queues, but for this queue to dispatch the {{#crossLink "fileload:event"}}{{/crossLink}}
	 * events.
	 * @param {Event} event The {{#crossLink "AbstractLoader/fileload:event"}}{{/crossLink}} event from the loader.
	 * @private
	 * @since 0.6.0
	 */
	p._handleFileLoad = function (event) {
		event.target = null;
		this.dispatchEvent(event);
	};

	/**
	 * The callback that is fired when a loader encounters an error from an internal file load operation. This enables
	 * loaders like M
	 * @param event
	 * @private
	 */
	p._handleFileError = function (event) {
		var newEvent = new createjs.ErrorEvent("FILE_LOAD_ERROR", null, event.item);
		this._sendError(newEvent);
	};

	/**
	 * The callback that is fired when a loader encounters an error. The queue will continue loading unless {{#crossLink "LoadQueue/stopOnError:property"}}{{/crossLink}}
	 * is set to `true`.
	 * @method _handleError
	 * @param {ErrorEvent} event The error event, containing relevant error information.
	 * @private
	 */
	p._handleError = function (event) {
		var loader = event.target;
		this._numItemsLoaded++;

		this._finishOrderedItem(loader, true);
		this._updateProgress();

		var newEvent = new createjs.ErrorEvent("FILE_LOAD_ERROR", null, loader.getItem());
		// TODO: Propagate actual error message.

		this._sendError(newEvent);

		if (!this.stopOnError) {
			this._removeLoadItem(loader);
			this._cleanLoadItem(loader);
			this._loadNext();
		} else {
			this.setPaused(true);
		}
	};

	/**
	 * An item has finished loading. We can assume that it is totally loaded, has been parsed for immediate use, and
	 * is available as the "result" property on the load item. The raw text result for a parsed item (such as JSON, XML,
	 * CSS, JavaScript, etc) is available as the "rawResult" property, and can also be looked up using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}.
	 * @method _handleFileComplete
	 * @param {Event} event The event object from the loader.
	 * @private
	 */
	p._handleFileComplete = function (event) {
		var loader = event.target;
		var item = loader.getItem();

		var result = loader.getResult();
		this._loadedResults[item.id] = result;
		var rawResult = loader.getResult(true);
		if (rawResult != null && rawResult !== result) {
			this._loadedRawResults[item.id] = rawResult;
		}

		this._saveLoadedItems(loader);

		// Remove the load item
		this._removeLoadItem(loader);

		if (!this._finishOrderedItem(loader)) {
			// The item was NOT managed, so process it now
			this._processFinishedLoad(item, loader);
		}

		// Clean up the load item
		this._cleanLoadItem(loader);
	};

	/**
	 * Some loaders might load additional content, other than the item they were passed (such as {{#crossLink "ManifestLoader"}}{{/crossLink}}).
	 * Any items exposed by the loader using {{#crossLink "AbstractLoader/getLoadItems"}}{{/crossLink}} are added to the
	 * LoadQueue's look-ups, including {{#crossLink "getItem"}}{{/crossLink}} and {{#crossLink "getResult"}}{{/crossLink}}
	 * methods.
	 * @method _saveLoadedItems
	 * @param {AbstractLoader} loader
	 * @protected
	 * @since 0.6.0
	 */
	p._saveLoadedItems = function (loader) {
		// TODO: Not sure how to handle this. Would be nice to expose the items.
		// Loaders may load sub-items. This adds them to this queue
		var list = loader.getLoadedItems();
		if (list === null) {
			return;
		}

		for (var i = 0; i < list.length; i++) {
			var item = list[i].item;

			// Store item lookups
			this._loadItemsBySrc[item.src] = item;
			this._loadItemsById[item.id] = item;

			// Store loaded content
			this._loadedResults[item.id] = list[i].result;
			this._loadedRawResults[item.id] = list[i].rawResult;
		}
	};

	/**
	 * Flag an item as finished. If the item's order is being managed, then ensure that it is allowed to finish, and if
	 * so, trigger prior items to trigger as well.
	 * @method _finishOrderedItem
	 * @param {AbstractLoader} loader
	 * @param {Boolean} loadFailed
	 * @return {Boolean} If the item's order is being managed. This allows the caller to take an alternate
	 * behaviour if it is.
	 * @private
	 */
	p._finishOrderedItem = function (loader, loadFailed) {
		var item = loader.getItem();

		if ((this.maintainScriptOrder && item.type == createjs.LoadQueue.JAVASCRIPT)
				|| item.maintainOrder) {

			//TODO: Evaluate removal of the _currentlyLoadingScript
			if (loader instanceof createjs.JavaScriptLoader) {
				this._currentlyLoadingScript = false;
			}

			var index = createjs.indexOf(this._scriptOrder, item);
			if (index == -1) {
				return false;
			} // This loader no longer exists
			this._loadedScripts[index] = (loadFailed === true) ? true : item;

			this._checkScriptLoadOrder();
			return true;
		}

		return false;
	};

	/**
	 * Ensure the scripts load and dispatch in the correct order. When using XHR, scripts are stored in an array in the
	 * order they were added, but with a "null" value. When they are completed, the value is set to the load item,
	 * and then when they are processed and dispatched, the value is set to `true`. This method simply
	 * iterates the array, and ensures that any loaded items that are not preceded by a `null` value are
	 * dispatched.
	 * @method _checkScriptLoadOrder
	 * @private
	 */
	p._checkScriptLoadOrder = function () {
		var l = this._loadedScripts.length;

		for (var i = 0; i < l; i++) {
			var item = this._loadedScripts[i];
			if (item === null) {
				break;
			} // This is still loading. Do not process further.
			if (item === true) {
				continue;
			} // This has completed, and been processed. Move on.

			var loadItem = this._loadedResults[item.id];
			if (item.type == createjs.LoadQueue.JAVASCRIPT) {
				// Append script tags to the head automatically.
				createjs.DomUtils.appendToHead(loadItem);
			}

			var loader = item._loader;
			this._processFinishedLoad(item, loader);
			this._loadedScripts[i] = true;
		}
	};

	/**
	 * A file has completed loading, and the LoadQueue can move on. This triggers the complete event, and kick-starts
	 * the next item.
	 * @method _processFinishedLoad
	 * @param {LoadItem|Object} item
	 * @param {AbstractLoader} loader
	 * @protected
	 */
	p._processFinishedLoad = function (item, loader) {
		this._numItemsLoaded++;

		// Since LoadQueue needs maintain order, we can't append scripts in the loader.
		// So we do it here instead. Or in _checkScriptLoadOrder();
		if (!this.maintainScriptOrder && item.type == createjs.LoadQueue.JAVASCRIPT) {
			createjs.DomUtils.appendToHead(item.result);
		}

		this._updateProgress();
		this._sendFileComplete(item, loader);
		this._loadNext();
	};

	/**
	 * Ensure items with `maintainOrder=true` that are before the specified item have loaded. This only applies to
	 * JavaScript items that are being loaded with a TagLoader, since they have to be loaded and completed <strong>before</strong>
	 * the script can even be started, since it exist in the DOM while loading.
	 * @method _canStartLoad
	 * @param {AbstractLoader} loader The loader for the item
	 * @return {Boolean} Whether the item can start a load or not.
	 * @private
	 */
	p._canStartLoad = function (loader) {
		if (!this.maintainScriptOrder || loader.preferXHR) {
			return true;
		}
		var item = loader.getItem();
		if (item.type != createjs.LoadQueue.JAVASCRIPT) {
			return true;
		}
		if (this._currentlyLoadingScript) {
			return false;
		}

		var index = this._scriptOrder.indexOf(item);
		var i = 0;
		while (i < index) {
			var checkItem = this._loadedScripts[i];
			if (checkItem == null) {
				return false;
			}
			i++;
		}
		this._currentlyLoadingScript = true;
		return true;
	};

	/**
	 * A load item is completed or was canceled, and needs to be removed from the LoadQueue.
	 * @method _removeLoadItem
	 * @param {AbstractLoader} loader A loader instance to remove.
	 * @private
	 */
	p._removeLoadItem = function (loader) {
		var l = this._currentLoads.length;
		for (var i = 0; i < l; i++) {
			if (this._currentLoads[i] == loader) {
				this._currentLoads.splice(i, 1);
				break;
			}
		}
	};

	/**
	 * Remove unneeded references from a loader.
	 *
	 * @param loader
	 * @private
	 */
	p._cleanLoadItem = function(loader) {
		var item = loader.getItem();
		if (item) {
			delete item._loader;
		}
	}

	/**
	 * An item has dispatched progress. Propagate that progress, and update the LoadQueue's overall progress.
	 * @method _handleProgress
	 * @param {ProgressEvent} event The progress event from the item.
	 * @private
	 */
	p._handleProgress = function (event) {
		var loader = event.target;
		this._sendFileProgress(loader.getItem(), loader.progress);
		this._updateProgress();
	};

	/**
	 * Overall progress has changed, so determine the new progress amount and dispatch it. This changes any time an
	 * item dispatches progress or completes. Note that since we don't always know the actual filesize of items before
	 * they are loaded. In this case, we define a "slot" for each item (1 item in 10 would get 10%), and then append
	 * loaded progress on top of the already-loaded items.
	 *
	 * For example, if 5/10 items have loaded, and item 6 is 20% loaded, the total progress would be:
	 * <ul>
	 *      <li>5/10 of the items in the queue (50%)</li>
	 *      <li>plus 20% of item 6's slot (2%)</li>
	 *      <li>equals 52%</li>
	 * </ul>
	 * @method _updateProgress
	 * @private
	 */
	p._updateProgress = function () {
		var loaded = this._numItemsLoaded / this._numItems; // Fully Loaded Progress
		var remaining = this._numItems - this._numItemsLoaded;
		if (remaining > 0) {
			var chunk = 0;
			for (var i = 0, l = this._currentLoads.length; i < l; i++) {
				chunk += this._currentLoads[i].progress;
			}
			loaded += (chunk / remaining) * (remaining / this._numItems);
		}

		if (this._lastProgress != loaded) {
			this._sendProgress(loaded);
			this._lastProgress = loaded;
		}
	};

	/**
	 * Clean out item results, to free them from memory. Mainly, the loaded item and results are cleared from internal
	 * hashes.
	 * @method _disposeItem
	 * @param {LoadItem|Object} item The item that was passed in for preloading.
	 * @private
	 */
	p._disposeItem = function (item) {
		delete this._loadedResults[item.id];
		delete this._loadedRawResults[item.id];
		delete this._loadItemsById[item.id];
		delete this._loadItemsBySrc[item.src];
	};

	/**
	 * Dispatch a "fileprogress" {{#crossLink "Event"}}{{/crossLink}}. Please see the LoadQueue {{#crossLink "LoadQueue/fileprogress:event"}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendFileProgress
	 * @param {LoadItem|Object} item The item that is being loaded.
	 * @param {Number} progress The amount the item has been loaded (between 0 and 1).
	 * @protected
	 */
	p._sendFileProgress = function (item, progress) {
		if (this._isCanceled() || this._paused) {
			return;
		}
		if (!this.hasEventListener("fileprogress")) {
			return;
		}

		//LM: Rework ProgressEvent to support this?
		var event = new createjs.Event("fileprogress");
		event.progress = progress;
		event.loaded = progress;
		event.total = 1;
		event.item = item;

		this.dispatchEvent(event);
	};

	/**
	 * Dispatch a fileload {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event for
	 * details on the event payload.
	 * @method _sendFileComplete
	 * @param {LoadItemObject} item The item that is being loaded.
	 * @param {AbstractLoader} loader
	 * @protected
	 */
	p._sendFileComplete = function (item, loader) {
		if (this._isCanceled() || this._paused) {
			return;
		}

		var event = new createjs.Event("fileload");
		event.loader = loader;
		event.item = item;
		event.result = this._loadedResults[item.id];
		event.rawResult = this._loadedRawResults[item.id];

		// This calls a handler specified on the actual load item. Currently, the SoundJS plugin uses this.
		if (item.completeHandler) {
			item.completeHandler(event);
		}

		this.hasEventListener("fileload") && this.dispatchEvent(event);
	};

	/**
	 * Dispatch a filestart {{#crossLink "Event"}}{{/crossLink}} immediately before a file starts to load. Please see
	 * the {{#crossLink "LoadQueue/filestart:event"}}{{/crossLink}} event for details on the event payload.
	 * @method _sendFileStart
	 * @param {LoadItem|Object} item The item that is being loaded.
	 * @protected
	 */
	p._sendFileStart = function (item) {
		var event = new createjs.Event("filestart");
		event.item = item;
		this.hasEventListener("filestart") && this.dispatchEvent(event);
	};

	p.toString = function () {
		return "[PreloadJS LoadQueue]";
	};

	createjs.LoadQueue = createjs.promote(LoadQueue, "AbstractLoader");
}());

//##############################################################################
// TextLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for Text files.
	 * @class TextLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function TextLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.TEXT);
	};

	var p = createjs.extend(TextLoader, createjs.AbstractLoader);
	var s = TextLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader loads items that are of type {{#crossLink "AbstractLoader/TEXT:property"}}{{/crossLink}},
	 * but is also the default loader if a file type can not be determined.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.TEXT;
	};

	createjs.TextLoader = createjs.promote(TextLoader, "AbstractLoader");

}());

//##############################################################################
// BinaryLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for binary files. This is useful for loading web audio, or content that requires an ArrayBuffer.
	 * @class BinaryLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function BinaryLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.BINARY);
		this.on("initialize", this._updateXHR, this);
	};

	var p = createjs.extend(BinaryLoader, createjs.AbstractLoader);
	var s = BinaryLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/BINARY:property"}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.BINARY;
	};

	// private methods
	/**
	 * Before the item loads, set the response type to "arraybuffer"
	 * @property _updateXHR
	 * @param {Event} event
	 * @private
	 */
	p._updateXHR = function (event) {
		event.loader.setResponseType("arraybuffer");
	};

	createjs.BinaryLoader = createjs.promote(BinaryLoader, "AbstractLoader");

}());

//##############################################################################
// CSSLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for CSS files.
	 * @class CSSLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractLoader
	 * @constructor
	 */
	function CSSLoader(loadItem, preferXHR) {
		this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.CSS);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = "href";

		if (preferXHR) {
			this._tag = document.createElement("style");
		} else {
			this._tag = document.createElement("link");
		}

		this._tag.rel = "stylesheet";
		this._tag.type = "text/css";
	};

	var p = createjs.extend(CSSLoader, createjs.AbstractLoader);
	var s = CSSLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/CSS:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.CSS;
	};

	// protected methods
	/**
	 * The result formatter for CSS files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLLinkElement|HTMLStyleElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		if (this._preferXHR) {
			var tag = loader.getTag();

			if (tag.styleSheet) { // IE
				tag.styleSheet.cssText = loader.getResult(true);
			} else {
				var textNode = document.createTextNode(loader.getResult(true));
				tag.appendChild(textNode);
			}
		} else {
			tag = this._tag;
		}

		createjs.DomUtils.appendToHead(tag);

		return tag;
	};

	createjs.CSSLoader = createjs.promote(CSSLoader, "AbstractLoader");

}());

//##############################################################################
// ImageLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for image files.
	 * @class ImageLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractLoader
	 * @constructor
	 */
	function ImageLoader (loadItem, preferXHR) {
		this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.IMAGE);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = "src";

		// Check if the preload item is already a tag.
		if (createjs.RequestUtils.isImageTag(loadItem)) {
			this._tag = loadItem;
		} else if (createjs.RequestUtils.isImageTag(loadItem.src)) {
			this._tag = loadItem.src;
		} else if (createjs.RequestUtils.isImageTag(loadItem.tag)) {
			this._tag = loadItem.tag;
		}

		if (this._tag != null) {
			this._preferXHR = false;
		} else {
			this._tag = document.createElement("img");
		}

		this.on("initialize", this._updateXHR, this);
	};

	var p = createjs.extend(ImageLoader, createjs.AbstractLoader);
	var s = ImageLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/IMAGE:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.IMAGE;
	};

	// public methods
	p.load = function () {
		if (this._tag.src != "" && this._tag.complete) {
			this._sendComplete();
			return;
		}

		var crossOrigin = this._item.crossOrigin;
		if (crossOrigin == true) { crossOrigin = "Anonymous"; }
		if (crossOrigin != null && !createjs.RequestUtils.isLocal(this._item.src)) {
			this._tag.crossOrigin = crossOrigin;
		}

		this.AbstractLoader_load();
	};

	// protected methods
	/**
	 * Before the item loads, set its mimeType and responseType.
	 * @property _updateXHR
	 * @param {Event} event
	 * @private
	 */
	p._updateXHR = function (event) {
		event.loader.mimeType = 'text/plain; charset=x-user-defined-binary';

		// Only exists for XHR
		if (event.loader.setResponseType) {
			event.loader.setResponseType("blob");
		}
	};

	/**
	 * The result formatter for Image files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLImageElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		var _this = this;
		return function (done) {
			var tag = _this._tag;
			var URL = window.URL || window.webkitURL;

			if (!_this._preferXHR) {
				//document.body.removeChild(tag);
			} else if (URL) {
				var objURL = URL.createObjectURL(loader.getResult(true));
				tag.src = objURL;
				tag.onload = function () {
					URL.revokeObjectURL(_this.src);
				}
			} else {
				tag.src = loader.getItem().src;
			}

			if (tag.complete) {
				done(tag);
			} else {
				tag.onload = function () {
					done(this);
				}
			}
		};
	};

	createjs.ImageLoader = createjs.promote(ImageLoader, "AbstractLoader");

}());

//##############################################################################
// JavaScriptLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for JavaScript files.
	 * @class JavaScriptLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractLoader
	 * @constructor
	 */
	function JavaScriptLoader(loadItem, preferXHR) {
		this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.JAVASCRIPT);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = "src";
		this.setTag(document.createElement("script"));
	};

	var p = createjs.extend(JavaScriptLoader, createjs.AbstractLoader);
	var s = JavaScriptLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.JAVASCRIPT;
	};

	// protected methods
	/**
	 * The result formatter for JavaScript files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLLinkElement|HTMLStyleElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		var tag = loader.getTag();
		if (this._preferXHR) {
			tag.text = loader.getResult(true);
		}
		return tag;
	};

	createjs.JavaScriptLoader = createjs.promote(JavaScriptLoader, "AbstractLoader");

}());

//##############################################################################
// JSONLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for JSON files. To load JSON cross-domain, use JSONP and the {{#crossLink "JSONPLoader"}}{{/crossLink}}
	 * instead. To load JSON-formatted manifests, use {{#crossLink "ManifestLoader"}}{{/crossLink}}, and to
	 * load EaselJS SpriteSheets, use {{#crossLink "SpriteSheetLoader"}}{{/crossLink}}.
	 * @class JSONLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function JSONLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.JSON);

		// public properties
		this.resultFormatter = this._formatResult;
	};

	var p = createjs.extend(JSONLoader, createjs.AbstractLoader);
	var s = JSONLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/JSON:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.JSON && !item._loadAsJSONP;
	};

	// protected methods
	/**
	 * The result formatter for JSON files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLLinkElement|HTMLStyleElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		var json = null;
		try {
			json = createjs.DataUtils.parseJSON(loader.getResult(true));
		} catch (e) {
			var event = new createjs.ErrorEvent("JSON_FORMAT", null, e);
			this._sendError(event);
			return e;
		}

		return json;
	};

	createjs.JSONLoader = createjs.promote(JSONLoader, "AbstractLoader");

}());

//##############################################################################
// JSONPLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for JSONP files, which are JSON-formatted text files, wrapped in a callback. To load regular JSON
	 * without a callback use the {{#crossLink "JSONLoader"}}{{/crossLink}} instead. To load JSON-formatted manifests,
	 * use {{#crossLink "ManifestLoader"}}{{/crossLink}}, and to load EaselJS SpriteSheets, use
	 * {{#crossLink "SpriteSheetLoader"}}{{/crossLink}}.
	 *
	 * Note that JSONP files loaded concurrently require a <em>unique</em> callback. To ensure JSONP files are loaded
	 * in order, either use the {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}} method (set to 1),
	 * or set {{#crossLink "LoadItem/maintainOrder:property"}}{{/crossLink}} on items with the same callback.
	 * @class JSONPLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function JSONPLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, false, createjs.AbstractLoader.JSONP);
		this.setTag(document.createElement("script"));
		this.getTag().type = "text/javascript";
	};

	var p = createjs.extend(JSONPLoader, createjs.AbstractLoader);
	var s = JSONPLoader;


	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/JSONP:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.JSONP || item._loadAsJSONP;
	};

	// public methods
	p.cancel = function () {
		this.AbstractLoader_cancel();
		this._dispose();
	};

	/**
	 * Loads the JSONp file.  Because of the unique loading needs of jsonP
	 * we don't use the AbstractLoader.load() method.
	 *
	 * @method load
	 *
	 */
	p.load = function () {
		if (this._item.callback == null) {
			throw new Error('callback is required for loading JSONP requests.');
		}

		// TODO: Look into creating our own iFrame to handle the load
		// In the first attempt, FF did not get the result
		//   result instanceof Object did not work either
		//   so we would need to clone the result.
		if (window[this._item.callback] != null) {
			throw new Error(
				"JSONP callback '" +
				this._item.callback +
				"' already exists on window. You need to specify a different callback or re-name the current one.");
		}

		window[this._item.callback] = createjs.proxy(this._handleLoad, this);
		window.document.body.appendChild(this._tag);

		this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);

		// Load the tag
		this._tag.src = this._item.src;
	};

	// private methods
	/**
	 * Handle the JSONP callback, which is a public method defined on `window`.
	 * @method _handleLoad
	 * @param {Object} data The formatted JSON data.
	 * @private
	 */
	p._handleLoad = function (data) {
		this._result = this._rawResult = data;
		this._sendComplete();

		this._dispose();
	};

	/**
	 * The tag request has not loaded within the time specfied in loadTimeout.
	 * @method _handleError
	 * @param {Object} event The XHR error event.
	 * @private
	 */
	p._handleTimeout = function () {
		this._dispose();
		this.dispatchEvent(new createjs.ErrorEvent("timeout"));
	};

	/**
	 * Clean up the JSONP load. This clears out the callback and script tag that this loader creates.
	 * @method _dispose
	 * @private
	 */
	p._dispose = function () {
		window.document.body.removeChild(this._tag);
		delete window[this._item.callback];

		clearTimeout(this._loadTimeout);
	};

	createjs.JSONPLoader = createjs.promote(JSONPLoader, "AbstractLoader");

}());

//##############################################################################
// ManifestLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for JSON manifests. Items inside the manifest are loaded before the loader completes. To load manifests
	 * using JSONP, specify a {{#crossLink "LoadItem/callback:property"}}{{/crossLink}} as part of the
	 * {{#crossLink "LoadItem"}}{{/crossLink}}.
	 *
	 * The list of files in the manifest must be defined on the top-level JSON object in a `manifest` property. This
	 * example shows a sample manifest definition, as well as how to to include a sub-manifest.
	 *
	 * 		{
	 * 			"path": "assets/",
	 *	 	    "manifest": [
	 *				"image.png",
	 *				{"src": "image2.png", "id":"image2"},
	 *				{"src": "sub-manifest.json", "type":"manifest", "callback":"jsonCallback"}
	 *	 	    ]
	 *	 	}
	 *
	 * When a ManifestLoader has completed loading, the parent loader (usually a {{#crossLink "LoadQueue"}}{{/crossLink}},
	 * but could also be another ManifestLoader) will inherit all the loaded items, so you can access them directly.
	 *
	 * Note that the {{#crossLink "JSONLoader"}}{{/crossLink}} and {{#crossLink "JSONPLoader"}}{{/crossLink}} are
	 * higher priority loaders, so manifests <strong>must</strong> set the {{#crossLink "LoadItem"}}{{/crossLink}}
	 * {{#crossLink "LoadItem/type:property"}}{{/crossLink}} property to {{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}}.
	 * @class ManifestLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function ManifestLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, null, createjs.AbstractLoader.MANIFEST);

	// Public Properties
		/**
		 * An array of the plugins registered using {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}},
		 * used to pass plugins to new LoadQueues that may be created.
		 * @property _plugins
		 * @type {Array}
		 * @private
		 * @since 0.6.1
		 */
		this.plugins = null;


	// Protected Properties
		/**
		 * An internal {{#crossLink "LoadQueue"}}{{/crossLink}} that loads the contents of the manifest.
		 * @property _manifestQueue
		 * @type {LoadQueue}
		 * @private
		 */
		this._manifestQueue = null;
	};

	var p = createjs.extend(ManifestLoader, createjs.AbstractLoader);
	var s = ManifestLoader;

	// static properties
	/**
	 * The amount of progress that the manifest itself takes up.
	 * @property MANIFEST_PROGRESS
	 * @type {number}
	 * @default 0.25 (25%)
	 * @private
	 * @static
	 */
	s.MANIFEST_PROGRESS = 0.25;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.MANIFEST;
	};

	// public methods
	p.load = function () {
		this.AbstractLoader_load();
	};

	// protected methods
	p._createRequest = function() {
		var callback = this._item.callback;
		if (callback != null) {
			this._request = new createjs.JSONPLoader(this._item);
		} else {
			this._request = new createjs.JSONLoader(this._item);
		}
	};

	p.handleEvent = function (event) {
		switch (event.type) {
			case "complete":
				this._rawResult = event.target.getResult(true);
				this._result = event.target.getResult();
				this._sendProgress(s.MANIFEST_PROGRESS);
				this._loadManifest(this._result);
				return;
			case "progress":
				event.loaded *= s.MANIFEST_PROGRESS;
				this.progress = event.loaded / event.total;
				if (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }
				this._sendProgress(event);
				return;
		}
		this.AbstractLoader_handleEvent(event);
	};

	p.destroy = function() {
		this.AbstractLoader_destroy();
		this._manifestQueue.close();
	};

	/**
	 * Create and load the manifest items once the actual manifest has been loaded.
	 * @method _loadManifest
	 * @param {Object} json
	 * @private
	 */
	p._loadManifest = function (json) {
		if (json && json.manifest) {
			var queue = this._manifestQueue = new createjs.LoadQueue();
			queue.on("fileload", this._handleManifestFileLoad, this);
			queue.on("progress", this._handleManifestProgress, this);
			queue.on("complete", this._handleManifestComplete, this, true);
			queue.on("error", this._handleManifestError, this, true);
			for(var i = 0, l = this.plugins.length; i < l; i++) {	// conserve order of plugins
				queue.installPlugin(this.plugins[i]);
			}
			queue.loadManifest(json);
		} else {
			this._sendComplete();
		}
	};

	/**
	 * An item from the {{#crossLink "_manifestQueue:property"}}{{/crossLink}} has completed.
	 * @method _handleManifestFileLoad
	 * @param {Event} event
	 * @private
	 */
	p._handleManifestFileLoad = function (event) {
		event.target = null;
		this.dispatchEvent(event);
	};

	/**
	 * The manifest has completed loading. This triggers the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}}
	 * {{#crossLink "Event"}}{{/crossLink}} from the ManifestLoader.
	 * @method _handleManifestComplete
	 * @param {Event} event
	 * @private
	 */
	p._handleManifestComplete = function (event) {
		this._loadedItems = this._manifestQueue.getItems(true);
		this._sendComplete();
	};

	/**
	 * The manifest has reported progress.
	 * @method _handleManifestProgress
	 * @param {ProgressEvent} event
	 * @private
	 */
	p._handleManifestProgress = function (event) {
		this.progress = event.progress * (1 - s.MANIFEST_PROGRESS) + s.MANIFEST_PROGRESS;
		this._sendProgress(this.progress);
	};

	/**
	 * The manifest has reported an error with one of the files.
	 * @method _handleManifestError
	 * @param {ErrorEvent} event
	 * @private
	 */
	p._handleManifestError = function (event) {
		var newEvent = new createjs.Event("fileerror");
		newEvent.item = event.data;
		this.dispatchEvent(newEvent);
	};

	createjs.ManifestLoader = createjs.promote(ManifestLoader, "AbstractLoader");

}());

//##############################################################################
// SoundLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for HTML audio files. PreloadJS can not load WebAudio files, as a WebAudio context is required, which
	 * should be created by either a library playing the sound (such as <a href="http://soundjs.com">SoundJS</a>, or an
	 * external framework that handles audio playback. To load content that can be played by WebAudio, use the
	 * {{#crossLink "BinaryLoader"}}{{/crossLink}}, and handle the audio context decoding manually.
	 * @class SoundLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractMediaLoader
	 * @constructor
	 */
	function SoundLoader(loadItem, preferXHR) {
		this.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SOUND);

		// protected properties
		if (createjs.RequestUtils.isAudioTag(loadItem)) {
			this._tag = loadItem;
		} else if (createjs.RequestUtils.isAudioTag(loadItem.src)) {
			this._tag = loadItem;
		} else if (createjs.RequestUtils.isAudioTag(loadItem.tag)) {
			this._tag = createjs.RequestUtils.isAudioTag(loadItem) ? loadItem : loadItem.src;
		}

		if (this._tag != null) {
			this._preferXHR = false;
		}
	};

	var p = createjs.extend(SoundLoader, createjs.AbstractMediaLoader);
	var s = SoundLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/SOUND:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.SOUND;
	};

	// protected methods
	p._createTag = function (src) {
		var tag = document.createElement("audio");
		tag.autoplay = false;
		tag.preload = "none";

		//LM: Firefox fails when this the preload="none" for other tags, but it needs to be "none" to ensure PreloadJS works.
		tag.src = src;
		return tag;
	};

	createjs.SoundLoader = createjs.promote(SoundLoader, "AbstractMediaLoader");

}());

//##############################################################################
// VideoLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for video files.
	 * @class VideoLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractMediaLoader
	 * @constructor
	 */
	function VideoLoader(loadItem, preferXHR) {
		this.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.VIDEO);

		if (createjs.RequestUtils.isVideoTag(loadItem) || createjs.RequestUtils.isVideoTag(loadItem.src)) {
			this.setTag(createjs.RequestUtils.isVideoTag(loadItem)?loadItem:loadItem.src);

			// We can't use XHR for a tag that's passed in.
			this._preferXHR = false;
		} else {
			this.setTag(this._createTag());
		}
	};

	var p = createjs.extend(VideoLoader, createjs.AbstractMediaLoader);
	var s = VideoLoader;

	/**
	 * Create a new video tag
	 *
	 * @returns {HTMLElement}
	 * @private
	 */
	p._createTag = function () {
		return document.createElement("video");
	};

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/VIDEO:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.VIDEO;
	};

	createjs.VideoLoader = createjs.promote(VideoLoader, "AbstractMediaLoader");

}());

//##############################################################################
// SpriteSheetLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for EaselJS SpriteSheets. Images inside the spritesheet definition are loaded before the loader
	 * completes. To load SpriteSheets using JSONP, specify a {{#crossLink "LoadItem/callback:property"}}{{/crossLink}}
	 * as part of the {{#crossLink "LoadItem"}}{{/crossLink}}. Note that the {{#crossLink "JSONLoader"}}{{/crossLink}}
	 * and {{#crossLink "JSONPLoader"}}{{/crossLink}} are higher priority loaders, so SpriteSheets <strong>must</strong>
	 * set the {{#crossLink "LoadItem"}}{{/crossLink}} {{#crossLink "LoadItem/type:property"}}{{/crossLink}} property
	 * to {{#crossLink "AbstractLoader/SPRITESHEET:property"}}{{/crossLink}}.
	 * @class SpriteSheetLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function SpriteSheetLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, null, createjs.AbstractLoader.SPRITESHEET);

		// protected properties
		/**
		 * An internal queue which loads the SpriteSheet's images.
		 * @method _manifestQueue
		 * @type {LoadQueue}
		 * @private
		 */
		this._manifestQueue = null;
	}

	var p = createjs.extend(SpriteSheetLoader, createjs.AbstractLoader);
	var s = SpriteSheetLoader;

	// static properties
	/**
	 * The amount of progress that the manifest itself takes up.
	 * @property SPRITESHEET_PROGRESS
	 * @type {number}
	 * @default 0.25 (25%)
	 * @private
	 * @static
	 */
	s.SPRITESHEET_PROGRESS = 0.25;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/SPRITESHEET:property"}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.SPRITESHEET;
	};

	// public methods
	p.destroy = function() {
		this.AbstractLoader_destroy;
		this._manifestQueue.close();
	};

	// protected methods
	p._createRequest = function() {
		var callback = this._item.callback;
		if (callback != null && callback instanceof Function) {
			this._request = new createjs.JSONPLoader(this._item);
		} else {
			this._request = new createjs.JSONLoader(this._item);
		}
	};

	p.handleEvent = function (event) {
		switch (event.type) {
			case "complete":
				this._rawResult = event.target.getResult(true);
				this._result = event.target.getResult();
				this._sendProgress(s.SPRITESHEET_PROGRESS);
				this._loadManifest(this._result);
				return;
			case "progress":
				event.loaded *= s.SPRITESHEET_PROGRESS;
				this.progress = event.loaded / event.total;
				if (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }
				this._sendProgress(event);
				return;
		}
		this.AbstractLoader_handleEvent(event);
	};

	/**
	 * Create and load the images once the SpriteSheet JSON has been loaded.
	 * @method _loadManifest
	 * @param {Object} json
	 * @private
	 */
	p._loadManifest = function (json) {
		if (json && json.images) {
			var queue = this._manifestQueue = new createjs.LoadQueue();
			queue.on("complete", this._handleManifestComplete, this, true);
			queue.on("fileload", this._handleManifestFileLoad, this);
			queue.on("progress", this._handleManifestProgress, this);
			queue.on("error", this._handleManifestError, this, true);
			queue.loadManifest(json.images);
		}
	};

	/**
	 * An item from the {{#crossLink "_manifestQueue:property"}}{{/crossLink}} has completed.
	 * @method _handleManifestFileLoad
	 * @param {Event} event
	 * @private
	 */
	p._handleManifestFileLoad = function (event) {
		var image = event.result;
		if (image != null) {
			var images = this.getResult().images;
			var pos = images.indexOf(event.item.src);
			images[pos] = image;
		}
	};

	/**
	 * The images have completed loading. This triggers the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}}
	 * {{#crossLink "Event"}}{{/crossLink}} from the SpriteSheetLoader.
	 * @method _handleManifestComplete
	 * @param {Event} event
	 * @private
	 */
	p._handleManifestComplete = function (event) {
		this._result = new createjs.SpriteSheet(this._result);
		this._loadedItems = this._manifestQueue.getItems(true);
		this._sendComplete();
	};

	/**
	 * The images {{#crossLink "LoadQueue"}}{{/crossLink}} has reported progress.
	 * @method _handleManifestProgress
	 * @param {ProgressEvent} event
	 * @private
	 */
	p._handleManifestProgress = function (event) {
		this.progress = event.progress * (1 - s.SPRITESHEET_PROGRESS) + s.SPRITESHEET_PROGRESS;
		this._sendProgress(this.progress);
	};

	/**
	 * An image has reported an error.
	 * @method _handleManifestError
	 * @param {ErrorEvent} event
	 * @private
	 */
	p._handleManifestError = function (event) {
		var newEvent = new createjs.Event("fileerror");
		newEvent.item = event.data;
		this.dispatchEvent(newEvent);
	};

	createjs.SpriteSheetLoader = createjs.promote(SpriteSheetLoader, "AbstractLoader");

}());

//##############################################################################
// SVGLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for SVG files.
	 * @class SVGLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractLoader
	 * @constructor
	 */
	function SVGLoader(loadItem, preferXHR) {
		this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SVG);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = "data";

		if (preferXHR) {
			this.setTag(document.createElement("svg"));
		} else {
			this.setTag(document.createElement("object"));
			this.getTag().type = "image/svg+xml";
		}
	};

	var p = createjs.extend(SVGLoader, createjs.AbstractLoader);
	var s = SVGLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/SVG:property"}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.SVG;
	};

	// protected methods
	/**
	 * The result formatter for SVG files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {Object}
	 * @private
	 */
	p._formatResult = function (loader) {
		// mime should be image/svg+xml, but Opera requires text/xml
		var xml = createjs.DataUtils.parseXML(loader.getResult(true), "text/xml");
		var tag = loader.getTag();

		if (!this._preferXHR && document.body.contains(tag)) {
			document.body.removeChild(tag);
		}

		if (xml.documentElement != null) {
			tag.appendChild(xml.documentElement);
			tag.style.visibility = "visible";
			return tag;
		} else { // For browsers that don't support SVG, just give them the XML. (IE 9-8)
			return xml;
		}
	};

	createjs.SVGLoader = createjs.promote(SVGLoader, "AbstractLoader");

}());

//##############################################################################
// XMLLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for CSS files.
	 * @class XMLLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function XMLLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.XML);

		// public properties
		this.resultFormatter = this._formatResult;
	};

	var p = createjs.extend(XMLLoader, createjs.AbstractLoader);
	var s = XMLLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/XML:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.XML;
	};

	// protected methods
	/**
	 * The result formatter for XML files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {XMLDocument}
	 * @private
	 */
	p._formatResult = function (loader) {
		return createjs.DataUtils.parseXML(loader.getResult(true), "text/xml");
	};

	createjs.XMLLoader = createjs.promote(XMLLoader, "AbstractLoader");

}());
/*!
* TweenJS
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2010 gskinner.com, inc.
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/


//##############################################################################
// extend.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Sets up the prototype chain and constructor property for a new class.
 *
 * This should be called right after creating the class constructor.
 *
 * 	function MySubClass() {}
 * 	createjs.extend(MySubClass, MySuperClass);
 * 	ClassB.prototype.doSomething = function() { }
 *
 * 	var foo = new MySubClass();
 * 	console.log(foo instanceof MySuperClass); // true
 * 	console.log(foo.prototype.constructor === MySubClass); // true
 *
 * @method extend
 * @param {Function} subclass The subclass.
 * @param {Function} superclass The superclass to extend.
 * @return {Function} Returns the subclass's new prototype.
 */
createjs.extend = function(subclass, superclass) {
	"use strict";

	function o() { this.constructor = subclass; }
	o.prototype = superclass.prototype;
	return (subclass.prototype = new o());
};

//##############################################################################
// promote.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.
 * It is recommended to use the super class's name as the prefix.
 * An alias to the super class's constructor is always added in the format `prefix_constructor`.
 * This allows the subclass to call super class methods without using `function.call`, providing better performance.
 *
 * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, "MySuperClass")`
 * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the
 * prototype of `MySubClass` as `MySuperClass_draw`.
 *
 * This should be called after the class's prototype is fully defined.
 *
 * 	function ClassA(name) {
 * 		this.name = name;
 * 	}
 * 	ClassA.prototype.greet = function() {
 * 		return "Hello "+this.name;
 * 	}
 *
 * 	function ClassB(name, punctuation) {
 * 		this.ClassA_constructor(name);
 * 		this.punctuation = punctuation;
 * 	}
 * 	createjs.extend(ClassB, ClassA);
 * 	ClassB.prototype.greet = function() {
 * 		return this.ClassA_greet()+this.punctuation;
 * 	}
 * 	createjs.promote(ClassB, "ClassA");
 *
 * 	var foo = new ClassB("World", "!?!");
 * 	console.log(foo.greet()); // Hello World!?!
 *
 * @method promote
 * @param {Function} subclass The class to promote super class methods on.
 * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.
 * @return {Function} Returns the subclass.
 */
createjs.promote = function(subclass, prefix) {
	"use strict";

	var subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;
	if (supP) {
		subP[(prefix+="_") + "constructor"] = supP.constructor; // constructor is not always innumerable
		for (var n in supP) {
			if (subP.hasOwnProperty(n) && (typeof supP[n] == "function")) { subP[prefix + n] = supP[n]; }
		}
	}
	return subclass;
};

//##############################################################################
// Event.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

// constructor:
	/**
	 * Contains properties and methods shared by all events for use with
	 * {{#crossLink "EventDispatcher"}}{{/crossLink}}.
	 * 
	 * Note that Event objects are often reused, so you should never
	 * rely on an event object's state outside of the call stack it was received in.
	 * @class Event
	 * @param {String} type The event type.
	 * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
	 * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
	 * @constructor
	 **/
	function Event(type, bubbles, cancelable) {
		
	
	// public properties:
		/**
		 * The type of event.
		 * @property type
		 * @type String
		 **/
		this.type = type;
	
		/**
		 * The object that generated an event.
		 * @property target
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.target = null;
	
		/**
		 * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will
		 * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event
		 * is generated from childObj, then a listener on parentObj would receive the event with
		 * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).
		 * @property currentTarget
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.currentTarget = null;
	
		/**
		 * For bubbling events, this indicates the current event phase:<OL>
		 * 	<LI> capture phase: starting from the top parent to the target</LI>
		 * 	<LI> at target phase: currently being dispatched from the target</LI>
		 * 	<LI> bubbling phase: from the target to the top parent</LI>
		 * </OL>
		 * @property eventPhase
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.eventPhase = 0;
	
		/**
		 * Indicates whether the event will bubble through the display list.
		 * @property bubbles
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.bubbles = !!bubbles;
	
		/**
		 * Indicates whether the default behaviour of this event can be cancelled via
		 * {{#crossLink "Event/preventDefault"}}{{/crossLink}}. This is set via the Event constructor.
		 * @property cancelable
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.cancelable = !!cancelable;
	
		/**
		 * The epoch time at which this event was created.
		 * @property timeStamp
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.timeStamp = (new Date()).getTime();
	
		/**
		 * Indicates if {{#crossLink "Event/preventDefault"}}{{/crossLink}} has been called
		 * on this event.
		 * @property defaultPrevented
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.defaultPrevented = false;
	
		/**
		 * Indicates if {{#crossLink "Event/stopPropagation"}}{{/crossLink}} or
		 * {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called on this event.
		 * @property propagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.propagationStopped = false;
	
		/**
		 * Indicates if {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called
		 * on this event.
		 * @property immediatePropagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.immediatePropagationStopped = false;
		
		/**
		 * Indicates if {{#crossLink "Event/remove"}}{{/crossLink}} has been called on this event.
		 * @property removed
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.removed = false;
	}
	var p = Event.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.
	

// public methods:
	/**
	 * Sets {{#crossLink "Event/defaultPrevented"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method preventDefault
	 **/
	p.preventDefault = function() {
		this.defaultPrevented = this.cancelable&&true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopPropagation
	 **/
	p.stopPropagation = function() {
		this.propagationStopped = true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} and
	 * {{#crossLink "Event/immediatePropagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopImmediatePropagation
	 **/
	p.stopImmediatePropagation = function() {
		this.immediatePropagationStopped = this.propagationStopped = true;
	};
	
	/**
	 * Causes the active listener to be removed via removeEventListener();
	 * 
	 * 		myBtn.addEventListener("click", function(evt) {
	 * 			// do stuff...
	 * 			evt.remove(); // removes this listener.
	 * 		});
	 * 
	 * @method remove
	 **/
	p.remove = function() {
		this.removed = true;
	};
	
	/**
	 * Returns a clone of the Event instance.
	 * @method clone
	 * @return {Event} a clone of the Event instance.
	 **/
	p.clone = function() {
		return new Event(this.type, this.bubbles, this.cancelable);
	};
	
	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the instance.
	 * @return {Event} Returns the instance the method is called on (useful for chaining calls.)
	 * @chainable
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Event (type="+this.type+")]";
	};

	createjs.Event = Event;
}());

//##############################################################################
// EventDispatcher.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * EventDispatcher provides methods for managing queues of event listeners and dispatching events.
	 *
	 * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the
	 * EventDispatcher {{#crossLink "EventDispatcher/initialize"}}{{/crossLink}} method.
	 * 
	 * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the
	 * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports
	 * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.
	 * 
	 * EventDispatcher also exposes a {{#crossLink "EventDispatcher/on"}}{{/crossLink}} method, which makes it easier
	 * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The 
	 * {{#crossLink "EventDispatcher/off"}}{{/crossLink}} method is merely an alias to
	 * {{#crossLink "EventDispatcher/removeEventListener"}}{{/crossLink}}.
	 * 
	 * Another addition to the DOM Level 2 model is the {{#crossLink "EventDispatcher/removeAllEventListeners"}}{{/crossLink}}
	 * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also 
	 * includes a {{#crossLink "Event/remove"}}{{/crossLink}} method which removes the active listener.
	 *
	 * <h4>Example</h4>
	 * Add EventDispatcher capabilities to the "MyClass" class.
	 *
	 *      EventDispatcher.initialize(MyClass.prototype);
	 *
	 * Add an event (see {{#crossLink "EventDispatcher/addEventListener"}}{{/crossLink}}).
	 *
	 *      instance.addEventListener("eventName", handlerMethod);
	 *      function handlerMethod(event) {
	 *          console.log(event.target + " Was Clicked");
	 *      }
	 *
	 * <b>Maintaining proper scope</b><br />
	 * Scope (ie. "this") can be be a challenge with events. Using the {{#crossLink "EventDispatcher/on"}}{{/crossLink}}
	 * method to subscribe to events simplifies this.
	 *
	 *      instance.addEventListener("click", function(event) {
	 *          console.log(instance == this); // false, scope is ambiguous.
	 *      });
	 *      
	 *      instance.on("click", function(event) {
	 *          console.log(instance == this); // true, "on" uses dispatcher scope by default.
	 *      });
	 * 
	 * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage scope.
	 *      
	 *
	 * @class EventDispatcher
	 * @constructor
	 **/
	function EventDispatcher() {
	
	
	// private properties:
		/**
		 * @protected
		 * @property _listeners
		 * @type Object
		 **/
		this._listeners = null;
		
		/**
		 * @protected
		 * @property _captureListeners
		 * @type Object
		 **/
		this._captureListeners = null;
	}
	var p = EventDispatcher.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// static public methods:
	/**
	 * Static initializer to mix EventDispatcher methods into a target object or prototype.
	 * 
	 * 		EventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class
	 * 		EventDispatcher.initialize(myObject); // add to a specific instance
	 * 
	 * @method initialize
	 * @static
	 * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a
	 * prototype.
	 **/
	EventDispatcher.initialize = function(target) {
		target.addEventListener = p.addEventListener;
		target.on = p.on;
		target.removeEventListener = target.off =  p.removeEventListener;
		target.removeAllEventListeners = p.removeAllEventListeners;
		target.hasEventListener = p.hasEventListener;
		target.dispatchEvent = p.dispatchEvent;
		target._dispatchEvent = p._dispatchEvent;
		target.willTrigger = p.willTrigger;
	};
	

// public methods:
	/**
	 * Adds the specified event listener. Note that adding multiple listeners to the same function will result in
	 * multiple callbacks getting fired.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.addEventListener("click", handleClick);
	 *      function handleClick(event) {
	 *         // Click happened.
	 *      }
	 *
	 * @method addEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function | Object} Returns the listener for chaining or assignment.
	 **/
	p.addEventListener = function(type, listener, useCapture) {
		var listeners;
		if (useCapture) {
			listeners = this._captureListeners = this._captureListeners||{};
		} else {
			listeners = this._listeners = this._listeners||{};
		}
		var arr = listeners[type];
		if (arr) { this.removeEventListener(type, listener, useCapture); }
		arr = listeners[type]; // remove may have deleted the array
		if (!arr) { listeners[type] = [listener];  }
		else { arr.push(listener); }
		return listener;
	};
	
	/**
	 * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener
	 * only run once, associate arbitrary data with the listener, and remove the listener.
	 * 
	 * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.
	 * The created anonymous function is returned for use with .removeEventListener (or .off).
	 * 
	 * <h4>Example</h4>
	 * 
	 * 		var listener = myBtn.on("click", handleClick, null, false, {count:3});
	 * 		function handleClick(evt, data) {
	 * 			data.count -= 1;
	 * 			console.log(this == myBtn); // true - scope defaults to the dispatcher
	 * 			if (data.count == 0) {
	 * 				alert("clicked 3 times!");
	 * 				myBtn.off("click", listener);
	 * 				// alternately: evt.remove();
	 * 			}
	 * 		}
	 * 
	 * @method on
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).
	 * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.
	 * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.
	 * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.
	 **/
	p.on = function(type, listener, scope, once, data, useCapture) {
		if (listener.handleEvent) {
			scope = scope||listener;
			listener = listener.handleEvent;
		}
		scope = scope||this;
		return this.addEventListener(type, function(evt) {
				listener.call(scope, evt, data);
				once&&evt.remove();
			}, useCapture);
	};

	/**
	 * Removes the specified event listener.
	 *
	 * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy
	 * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or
	 * closure will not work.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.removeEventListener("click", handleClick);
	 *
	 * @method removeEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.removeEventListener = function(type, listener, useCapture) {
		var listeners = useCapture ? this._captureListeners : this._listeners;
		if (!listeners) { return; }
		var arr = listeners[type];
		if (!arr) { return; }
		for (var i=0,l=arr.length; i<l; i++) {
			if (arr[i] == listener) {
				if (l==1) { delete(listeners[type]); } // allows for faster checks.
				else { arr.splice(i,1); }
				break;
			}
		}
	};
	
	/**
	 * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the
	 * .on method.
	 *
	 * @method off
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.off = p.removeEventListener;

	/**
	 * Removes all listeners for the specified type, or all listeners of all types.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Remove all listeners
	 *      displayObject.removeAllEventListeners();
	 *
	 *      // Remove all click listeners
	 *      displayObject.removeAllEventListeners("click");
	 *
	 * @method removeAllEventListeners
	 * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.
	 **/
	p.removeAllEventListeners = function(type) {
		if (!type) { this._listeners = this._captureListeners = null; }
		else {
			if (this._listeners) { delete(this._listeners[type]); }
			if (this._captureListeners) { delete(this._captureListeners[type]); }
		}
	};

	/**
	 * Dispatches the specified event to all listeners.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Use a string event
	 *      this.dispatchEvent("complete");
	 *
	 *      // Use an Event instance
	 *      var event = new createjs.Event("progress");
	 *      this.dispatchEvent(event);
	 *
	 * @method dispatchEvent
	 * @param {Object | String | Event} eventObj An object with a "type" property, or a string type.
	 * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,
	 * dispatchEvent will construct an Event instance with the specified type.
	 * @return {Boolean} Returns the value of eventObj.defaultPrevented.
	 **/
	p.dispatchEvent = function(eventObj) {
		if (typeof eventObj == "string") {
			// won't bubble, so skip everything if there's no listeners:
			var listeners = this._listeners;
			if (!listeners || !listeners[eventObj]) { return false; }
			eventObj = new createjs.Event(eventObj);
		} else if (eventObj.target && eventObj.clone) {
			// redispatching an active event object, so clone it:
			eventObj = eventObj.clone();
		}
		try { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events

		if (!eventObj.bubbles || !this.parent) {
			this._dispatchEvent(eventObj, 2);
		} else {
			var top=this, list=[top];
			while (top.parent) { list.push(top = top.parent); }
			var i, l=list.length;

			// capture & atTarget
			for (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {
				list[i]._dispatchEvent(eventObj, 1+(i==0));
			}
			// bubbling
			for (i=1; i<l && !eventObj.propagationStopped; i++) {
				list[i]._dispatchEvent(eventObj, 3);
			}
		}
		return eventObj.defaultPrevented;
	};

	/**
	 * Indicates whether there is at least one listener for the specified event type.
	 * @method hasEventListener
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns true if there is at least one listener for the specified event.
	 **/
	p.hasEventListener = function(type) {
		var listeners = this._listeners, captureListeners = this._captureListeners;
		return !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));
	};
	
	/**
	 * Indicates whether there is at least one listener for the specified event type on this object or any of its
	 * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the
	 * specified type is dispatched from this object, it will trigger at least one listener.
	 * 
	 * This is similar to {{#crossLink "EventDispatcher/hasEventListener"}}{{/crossLink}}, but it searches the entire
	 * event flow for a listener, not just this object.
	 * @method willTrigger
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns `true` if there is at least one listener for the specified event.
	 **/
	p.willTrigger = function(type) {
		var o = this;
		while (o) {
			if (o.hasEventListener(type)) { return true; }
			o = o.parent;
		}
		return false;
	};

	/**
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[EventDispatcher]";
	};


// private methods:
	/**
	 * @method _dispatchEvent
	 * @param {Object | String | Event} eventObj
	 * @param {Object} eventPhase
	 * @protected
	 **/
	p._dispatchEvent = function(eventObj, eventPhase) {
		var l, listeners = (eventPhase==1) ? this._captureListeners : this._listeners;
		if (eventObj && listeners) {
			var arr = listeners[eventObj.type];
			if (!arr||!(l=arr.length)) { return; }
			try { eventObj.currentTarget = this; } catch (e) {}
			try { eventObj.eventPhase = eventPhase; } catch (e) {}
			eventObj.removed = false;
			
			arr = arr.slice(); // to avoid issues with items being removed or added during the dispatch
			for (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {
				var o = arr[i];
				if (o.handleEvent) { o.handleEvent(eventObj); }
				else { o(eventObj); }
				if (eventObj.removed) {
					this.off(eventObj.type, o, eventPhase==1);
					eventObj.removed = false;
				}
			}
		}
	};


	createjs.EventDispatcher = EventDispatcher;
}());

//##############################################################################
// Ticker.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * The Ticker provides a centralized tick or heartbeat broadcast at a set interval. Listeners can subscribe to the tick
	 * event to be notified when a set time interval has elapsed.
	 *
	 * Note that the interval that the tick event is called is a target interval, and may be broadcast at a slower interval
	 * when under high CPU load. The Ticker class uses a static interface (ex. `Ticker.framerate = 30;`) and
	 * can not be instantiated.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.Ticker.addEventListener("tick", handleTick);
	 *      function handleTick(event) {
	 *          // Actions carried out each tick (aka frame)
	 *          if (!event.paused) {
	 *              // Actions carried out when the Ticker is not paused.
	 *          }
	 *      }
	 *
	 * @class Ticker
	 * @uses EventDispatcher
	 * @static
	 **/
	function Ticker() {
		throw "Ticker cannot be instantiated.";
	}


// constants:
	/**
	 * In this mode, Ticker uses the requestAnimationFrame API, but attempts to synch the ticks to target framerate. It
	 * uses a simple heuristic that compares the time of the RAF return to the target time for the current frame and
	 * dispatches the tick when the time is within a certain threshold.
	 *
	 * This mode has a higher variance for time between frames than {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}},
	 * but does not require that content be time based as with {{#crossLink "Ticker/RAF:property"}}{{/crossLink}} while
	 * gaining the benefits of that API (screen synch, background throttling).
	 *
	 * Variance is usually lowest for framerates that are a divisor of the RAF frequency. This is usually 60, so
	 * framerates of 10, 12, 15, 20, and 30 work well.
	 *
	 * Falls back to {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}} if the requestAnimationFrame API is not
	 * supported.
	 * @property RAF_SYNCHED
	 * @static
	 * @type {String}
	 * @default "synched"
	 * @readonly
	 **/
	Ticker.RAF_SYNCHED = "synched";

	/**
	 * In this mode, Ticker passes through the requestAnimationFrame heartbeat, ignoring the target framerate completely.
	 * Because requestAnimationFrame frequency is not deterministic, any content using this mode should be time based.
	 * You can leverage {{#crossLink "Ticker/getTime"}}{{/crossLink}} and the {{#crossLink "Ticker/tick:event"}}{{/crossLink}}
	 * event object's "delta" properties to make this easier.
	 *
	 * Falls back on {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}} if the requestAnimationFrame API is not
	 * supported.
	 * @property RAF
	 * @static
	 * @type {String}
	 * @default "raf"
	 * @readonly
	 **/
	Ticker.RAF = "raf";

	/**
	 * In this mode, Ticker uses the setTimeout API. This provides predictable, adaptive frame timing, but does not
	 * provide the benefits of requestAnimationFrame (screen synch, background throttling).
	 * @property TIMEOUT
	 * @static
	 * @type {String}
	 * @default "timeout"
	 * @readonly
	 **/
	Ticker.TIMEOUT = "timeout";


// static events:
	/**
	 * Dispatched each tick. The event will be dispatched to each listener even when the Ticker has been paused using
	 * {{#crossLink "Ticker/setPaused"}}{{/crossLink}}.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.Ticker.addEventListener("tick", handleTick);
	 *      function handleTick(event) {
	 *          console.log("Paused:", event.paused, event.delta);
	 *      }
	 *
	 * @event tick
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Boolean} paused Indicates whether the ticker is currently paused.
	 * @param {Number} delta The time elapsed in ms since the last tick.
	 * @param {Number} time The total time in ms since Ticker was initialized.
	 * @param {Number} runTime The total time in ms that Ticker was not paused since it was initialized. For example,
	 * 	you could determine the amount of time that the Ticker has been paused since initialization with `time-runTime`.
	 * @since 0.6.0
	 */


// public static properties:
	/**
	 * Deprecated in favour of {{#crossLink "Ticker/timingMode"}}{{/crossLink}}, and will be removed in a future version. If true, timingMode will
	 * use {{#crossLink "Ticker/RAF_SYNCHED"}}{{/crossLink}} by default.
	 * @deprecated Deprecated in favour of {{#crossLink "Ticker/timingMode"}}{{/crossLink}}.
	 * @property useRAF
	 * @static
	 * @type {Boolean}
	 * @default false
	 **/
	Ticker.useRAF = false;

	/**
	 * Specifies the timing api (setTimeout or requestAnimationFrame) and mode to use. See
	 * {{#crossLink "Ticker/TIMEOUT"}}{{/crossLink}}, {{#crossLink "Ticker/RAF"}}{{/crossLink}}, and
	 * {{#crossLink "Ticker/RAF_SYNCHED"}}{{/crossLink}} for mode details.
	 * @property timingMode
	 * @static
	 * @type {String}
	 * @default Ticker.TIMEOUT
	 **/
	Ticker.timingMode = null;

	/**
	 * Specifies a maximum value for the delta property in the tick event object. This is useful when building time
	 * based animations and systems to prevent issues caused by large time gaps caused by background tabs, system sleep,
	 * alert dialogs, or other blocking routines. Double the expected frame duration is often an effective value
	 * (ex. maxDelta=50 when running at 40fps).
	 * 
	 * This does not impact any other values (ex. time, runTime, etc), so you may experience issues if you enable maxDelta
	 * when using both delta and other values.
	 * 
	 * If 0, there is no maximum.
	 * @property maxDelta
	 * @static
	 * @type {number}
	 * @default 0
	 */
	Ticker.maxDelta = 0;
	
	/**
	 * When the ticker is paused, all listeners will still receive a tick event, but the <code>paused</code> property
	 * of the event will be `true`. Also, while paused the `runTime` will not increase. See {{#crossLink "Ticker/tick:event"}}{{/crossLink}},
	 * {{#crossLink "Ticker/getTime"}}{{/crossLink}}, and {{#crossLink "Ticker/getEventTime"}}{{/crossLink}} for more
	 * info.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.Ticker.addEventListener("tick", handleTick);
	 *      createjs.Ticker.paused = true;
	 *      function handleTick(event) {
	 *          console.log(event.paused,
	 *          	createjs.Ticker.getTime(false),
	 *          	createjs.Ticker.getTime(true));
	 *      }
	 *
	 * @property paused
	 * @static
	 * @type {Boolean}
	 * @default false
	 **/
	Ticker.paused = false;


// mix-ins:
	// EventDispatcher methods:
	Ticker.removeEventListener = null;
	Ticker.removeAllEventListeners = null;
	Ticker.dispatchEvent = null;
	Ticker.hasEventListener = null;
	Ticker._listeners = null;
	createjs.EventDispatcher.initialize(Ticker); // inject EventDispatcher methods.
	Ticker._addEventListener = Ticker.addEventListener;
	Ticker.addEventListener = function() {
		!Ticker._inited&&Ticker.init();
		return Ticker._addEventListener.apply(Ticker, arguments);
	};


// private static properties:
	/**
	 * @property _inited
	 * @static
	 * @type {Boolean}
	 * @protected
	 **/
	Ticker._inited = false;

	/**
	 * @property _startTime
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._startTime = 0;

	/**
	 * @property _pausedTime
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._pausedTime=0;

	/**
	 * The number of ticks that have passed
	 * @property _ticks
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._ticks = 0;

	/**
	 * The number of ticks that have passed while Ticker has been paused
	 * @property _pausedTicks
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._pausedTicks = 0;

	/**
	 * @property _interval
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._interval = 50;

	/**
	 * @property _lastTime
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._lastTime = 0;

	/**
	 * @property _times
	 * @static
	 * @type {Array}
	 * @protected
	 **/
	Ticker._times = null;

	/**
	 * @property _tickTimes
	 * @static
	 * @type {Array}
	 * @protected
	 **/
	Ticker._tickTimes = null;

	/**
	 * Stores the timeout or requestAnimationFrame id.
	 * @property _timerId
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._timerId = null;
	
	/**
	 * True if currently using requestAnimationFrame, false if using setTimeout. This may be different than timingMode
	 * if that property changed and a tick hasn't fired.
	 * @property _raf
	 * @static
	 * @type {Boolean}
	 * @protected
	 **/
	Ticker._raf = true;
	

// static getter / setters:
	/**
	 * Use the {{#crossLink "Ticker/interval:property"}}{{/crossLink}} property instead.
	 * @method setInterval
	 * @static
	 * @param {Number} interval
	 * @deprecated
	 **/
	Ticker.setInterval = function(interval) {
		Ticker._interval = interval;
		if (!Ticker._inited) { return; }
		Ticker._setupTick();
	};

	/**
	 * Use the {{#crossLink "Ticker/framerate:property"}}{{/crossLink}} property instead.
	 * @method getInterval
	 * @static
	 * @return {Number}
	 * @deprecated
	 **/
	Ticker.getInterval = function() {
		return Ticker._interval;
	};

	/**
	 * Use the {{#crossLink "Ticker/framerate:property"}}{{/crossLink}} property instead.
	 * @method setFPS
	 * @static
	 * @param {Number} value
	 * @deprecated
	 **/
	Ticker.setFPS = function(value) {
		Ticker.setInterval(1000/value);
	};

	/**
	 * Use the {{#crossLink "Ticker/interval:property"}}{{/crossLink}} property instead.
	 * @method getFPS
	 * @static
	 * @return {Number}
	 * @deprecated
	 **/
	Ticker.getFPS = function() {
		return 1000/Ticker._interval;
	};

	/**
	 * Indicates the target time (in milliseconds) between ticks. Default is 50 (20 FPS).
	 * Note that actual time between ticks may be more than specified depending on CPU load.
	 * This property is ignored if the ticker is using the `RAF` timing mode.
	 * @property interval
	 * @static
	 * @type {Number}
	 **/
	 
	/**
	 * Indicates the target frame rate in frames per second (FPS). Effectively just a shortcut to `interval`, where
	 * `framerate == 1000/interval`.
	 * @property framerate
	 * @static
	 * @type {Number}
	 **/
	try {
		Object.defineProperties(Ticker, {
			interval: { get: Ticker.getInterval, set: Ticker.setInterval },
			framerate: { get: Ticker.getFPS, set: Ticker.setFPS }
		});
	} catch (e) { console.log(e); }


// public static methods:
	/**
	 * Starts the tick. This is called automatically when the first listener is added.
	 * @method init
	 * @static
	 **/
	Ticker.init = function() {
		if (Ticker._inited) { return; }
		Ticker._inited = true;
		Ticker._times = [];
		Ticker._tickTimes = [];
		Ticker._startTime = Ticker._getTime();
		Ticker._times.push(Ticker._lastTime = 0);
		Ticker.interval = Ticker._interval;
	};
	
	/**
	 * Stops the Ticker and removes all listeners. Use init() to restart the Ticker.
	 * @method reset
	 * @static
	 **/
	Ticker.reset = function() {
		if (Ticker._raf) {
			var f = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;
			f&&f(Ticker._timerId);
		} else {
			clearTimeout(Ticker._timerId);
		}
		Ticker.removeAllEventListeners("tick");
		Ticker._timerId = Ticker._times = Ticker._tickTimes = null;
		Ticker._startTime = Ticker._lastTime = Ticker._ticks = 0;
		Ticker._inited = false;
	};

	/**
	 * Returns the average time spent within a tick. This can vary significantly from the value provided by getMeasuredFPS
	 * because it only measures the time spent within the tick execution stack. 
	 * 
	 * Example 1: With a target FPS of 20, getMeasuredFPS() returns 20fps, which indicates an average of 50ms between 
	 * the end of one tick and the end of the next. However, getMeasuredTickTime() returns 15ms. This indicates that 
	 * there may be up to 35ms of "idle" time between the end of one tick and the start of the next.
	 *
	 * Example 2: With a target FPS of 30, getFPS() returns 10fps, which indicates an average of 100ms between the end of
	 * one tick and the end of the next. However, getMeasuredTickTime() returns 20ms. This would indicate that something
	 * other than the tick is using ~80ms (another script, DOM rendering, etc).
	 * @method getMeasuredTickTime
	 * @static
	 * @param {Number} [ticks] The number of previous ticks over which to measure the average time spent in a tick.
	 * Defaults to the number of ticks per second. To get only the last tick's time, pass in 1.
	 * @return {Number} The average time spent in a tick in milliseconds.
	 **/
	Ticker.getMeasuredTickTime = function(ticks) {
		var ttl=0, times=Ticker._tickTimes;
		if (!times || times.length < 1) { return -1; }

		// by default, calculate average for the past ~1 second:
		ticks = Math.min(times.length, ticks||(Ticker.getFPS()|0));
		for (var i=0; i<ticks; i++) { ttl += times[i]; }
		return ttl/ticks;
	};

	/**
	 * Returns the actual frames / ticks per second.
	 * @method getMeasuredFPS
	 * @static
	 * @param {Number} [ticks] The number of previous ticks over which to measure the actual frames / ticks per second.
	 * Defaults to the number of ticks per second.
	 * @return {Number} The actual frames / ticks per second. Depending on performance, this may differ
	 * from the target frames per second.
	 **/
	Ticker.getMeasuredFPS = function(ticks) {
		var times = Ticker._times;
		if (!times || times.length < 2) { return -1; }

		// by default, calculate fps for the past ~1 second:
		ticks = Math.min(times.length-1, ticks||(Ticker.getFPS()|0));
		return 1000/((times[0]-times[ticks])/ticks);
	};

	/**
	 * Use the {{#crossLink "Ticker/paused:property"}}{{/crossLink}} property instead.
	 * @method setPaused
	 * @static
	 * @param {Boolean} value
	 * @deprecated
	 **/
	Ticker.setPaused = function(value) {
		// TODO: deprecated.
		Ticker.paused = value;
	};

	/**
	 * Use the {{#crossLink "Ticker/paused:property"}}{{/crossLink}} property instead.
	 * @method getPaused
	 * @static
	 * @return {Boolean}
	 * @deprecated
	 **/
	Ticker.getPaused = function() {
		// TODO: deprecated.
		return Ticker.paused;
	};

	/**
	 * Returns the number of milliseconds that have elapsed since Ticker was initialized via {{#crossLink "Ticker/init"}}.
	 * Returns -1 if Ticker has not been initialized. For example, you could use
	 * this in a time synchronized animation to determine the exact amount of time that has elapsed.
	 * @method getTime
	 * @static
	 * @param {Boolean} [runTime=false] If true only time elapsed while Ticker was not paused will be returned.
	 * If false, the value returned will be total time elapsed since the first tick event listener was added.
	 * @return {Number} Number of milliseconds that have elapsed since Ticker was initialized or -1.
	 **/
	Ticker.getTime = function(runTime) {
		return Ticker._startTime ? Ticker._getTime() - (runTime ? Ticker._pausedTime : 0) : -1;
	};

	/**
	 * Similar to getTime(), but returns the time on the most recent tick event object.
	 * @method getEventTime
	 * @static
	 * @param runTime {Boolean} [runTime=false] If true, the runTime property will be returned instead of time.
	 * @returns {number} The time or runTime property from the most recent tick event or -1.
	 */
	Ticker.getEventTime = function(runTime) {
		return Ticker._startTime ? (Ticker._lastTime || Ticker._startTime) - (runTime ? Ticker._pausedTime : 0) : -1;
	};
	
	/**
	 * Returns the number of ticks that have been broadcast by Ticker.
	 * @method getTicks
	 * @static
	 * @param {Boolean} pauseable Indicates whether to include ticks that would have been broadcast
	 * while Ticker was paused. If true only tick events broadcast while Ticker is not paused will be returned.
	 * If false, tick events that would have been broadcast while Ticker was paused will be included in the return
	 * value. The default value is false.
	 * @return {Number} of ticks that have been broadcast.
	 **/
	Ticker.getTicks = function(pauseable) {
		return  Ticker._ticks - (pauseable ? Ticker._pausedTicks : 0);
	};


// private static methods:
	/**
	 * @method _handleSynch
	 * @static
	 * @protected
	 **/
	Ticker._handleSynch = function() {
		Ticker._timerId = null;
		Ticker._setupTick();

		// run if enough time has elapsed, with a little bit of flexibility to be early:
		if (Ticker._getTime() - Ticker._lastTime >= (Ticker._interval-1)*0.97) {
			Ticker._tick();
		}
	};

	/**
	 * @method _handleRAF
	 * @static
	 * @protected
	 **/
	Ticker._handleRAF = function() {
		Ticker._timerId = null;
		Ticker._setupTick();
		Ticker._tick();
	};

	/**
	 * @method _handleTimeout
	 * @static
	 * @protected
	 **/
	Ticker._handleTimeout = function() {
		Ticker._timerId = null;
		Ticker._setupTick();
		Ticker._tick();
	};

	/**
	 * @method _setupTick
	 * @static
	 * @protected
	 **/
	Ticker._setupTick = function() {
		if (Ticker._timerId != null) { return; } // avoid duplicates

		var mode = Ticker.timingMode||(Ticker.useRAF&&Ticker.RAF_SYNCHED);
		if (mode == Ticker.RAF_SYNCHED || mode == Ticker.RAF) {
			var f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
			if (f) {
				Ticker._timerId = f(mode == Ticker.RAF ? Ticker._handleRAF : Ticker._handleSynch);
				Ticker._raf = true;
				return;
			}
		}
		Ticker._raf = false;
		Ticker._timerId = setTimeout(Ticker._handleTimeout, Ticker._interval);
	};

	/**
	 * @method _tick
	 * @static
	 * @protected
	 **/
	Ticker._tick = function() {
		var paused = Ticker.paused;
		var time = Ticker._getTime();
		var elapsedTime = time-Ticker._lastTime;
		Ticker._lastTime = time;
		Ticker._ticks++;
		
		if (paused) {
			Ticker._pausedTicks++;
			Ticker._pausedTime += elapsedTime;
		}
		
		if (Ticker.hasEventListener("tick")) {
			var event = new createjs.Event("tick");
			var maxDelta = Ticker.maxDelta;
			event.delta = (maxDelta && elapsedTime > maxDelta) ? maxDelta : elapsedTime;
			event.paused = paused;
			event.time = time;
			event.runTime = time-Ticker._pausedTime;
			Ticker.dispatchEvent(event);
		}
		
		Ticker._tickTimes.unshift(Ticker._getTime()-time);
		while (Ticker._tickTimes.length > 100) { Ticker._tickTimes.pop(); }

		Ticker._times.unshift(time);
		while (Ticker._times.length > 100) { Ticker._times.pop(); }
	};

	/**
	 * @method _getTime
	 * @static
	 * @protected
	 **/
	var now = window.performance && (performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow);
	Ticker._getTime = function() {
		return ((now&&now.call(performance))||(new Date().getTime())) - Ticker._startTime;
	};


	createjs.Ticker = Ticker;
}());

//##############################################################################
// Tween.js
//##############################################################################

// TODO: possibly add a END actionsMode (only runs actions that == position)?
// TODO: evaluate a way to decouple paused from tick registration.


this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor
	/**
	 * A Tween instance tweens properties for a single target. Instance methods can be chained for easy construction and sequencing:
	 *
	 * <h4>Example</h4>
	 *
	 *      target.alpha = 1;
	 *	    createjs.Tween.get(target)
	 *	         .wait(500)
	 *	         .to({alpha:0, visible:false}, 1000)
	 *	         .call(handleComplete);
	 *	    function handleComplete() {
	 *	    	//Tween complete
	 *	    }
	 *
	 * Multiple tweens can point to the same instance, however if they affect the same properties there could be unexpected
	 * behaviour. To stop all tweens on an object, use {{#crossLink "Tween/removeTweens"}}{{/crossLink}} or pass `override:true`
	 * in the props argument.
	 *
	 *      createjs.Tween.get(target, {override:true}).to({x:100});
	 *
	 * Subscribe to the {{#crossLink "Tween/change:event"}}{{/crossLink}} event to get notified when a property of the
	 * target is changed.
	 *
	 *      createjs.Tween.get(target, {override:true}).to({x:100}).addEventListener("change", handleChange);
	 *      function handleChange(event) {
	 *          // The tween changed.
	 *      }
	 *
	 * See the Tween {{#crossLink "Tween/get"}}{{/crossLink}} method for additional param documentation.
	 * @class Tween
	 * @param {Object} target The target object that will have its properties tweened.
	 * @param {Object} [props] The configuration properties to apply to this tween instance (ex. `{loop:true, paused:true}`.
	 * All properties default to false. Supported props are:<UL>
	 *    <LI> loop: sets the loop property on this tween.</LI>
	 *    <LI> useTicks: uses ticks for all durations instead of milliseconds.</LI>
	 *    <LI> ignoreGlobalPause: sets the {{#crossLink "Tween/ignoreGlobalPause:property"}}{{/crossLink}} property on this tween.</LI>
	 *    <LI> override: if true, `Tween.removeTweens(target)` will be called to remove any other tweens with the same target.
	 *    <LI> paused: indicates whether to start the tween paused.</LI>
	 *    <LI> position: indicates the initial position for this tween.</LI>
	 *    <LI> onChange: specifies a listener for the "change" event.</LI>
	 * </UL>
	 * @param {Object} [pluginData] An object containing data for use by installed plugins. See individual
	 * plugins' documentation for details.
	 * @extends EventDispatcher
	 * @constructor
	 */
	function Tween(target, props, pluginData) {

	// public properties:
		/**
		 * Causes this tween to continue playing when a global pause is active. For example, if TweenJS is using {{#crossLink "Ticker"}}{{/crossLink}},
		 * then setting this to true (the default) will cause this tween to be paused when <code>Ticker.setPaused(true)</code>
		 * is called. See the Tween {{#crossLink "Tween/tick"}}{{/crossLink}} method for more info. Can be set via the props
		 * parameter.
		 * @property ignoreGlobalPause
		 * @type Boolean
		 * @default false
		 */
		this.ignoreGlobalPause = false;
	
		/**
		 * If true, the tween will loop when it reaches the end. Can be set via the props param.
		 * @property loop
		 * @type {Boolean}
		 * @default false
		 */
		this.loop = false;
	
		/**
		 * Specifies the total duration of this tween in milliseconds (or ticks if useTicks is true).
		 * This value is automatically updated as you modify the tween. Changing it directly could result in unexpected
		 * behaviour.
		 * @property duration
		 * @type {Number}
		 * @default 0
		 * @readonly
		 */
		this.duration = 0;
	
		/**
		 * Allows you to specify data that will be used by installed plugins. Each plugin uses this differently, but in general
		 * you specify data by setting it to a property of pluginData with the same name as the plugin class.
		 * @example
		 *	myTween.pluginData.PluginClassName = data;
		 * <br/>
		 * Also, most plugins support a property to enable or disable them. This is typically the plugin class name followed by "_enabled".<br/>
		 * @example
		 *	myTween.pluginData.PluginClassName_enabled = false;<br/>
		 * <br/>
		 * Some plugins also store instance data in this object, usually in a property named _PluginClassName.
		 * See the documentation for individual plugins for more details.
		 * @property pluginData
		 * @type {Object}
		 */
		this.pluginData = pluginData || {};
	
		/**
		 * The target of this tween. This is the object on which the tweened properties will be changed. Changing
		 * this property after the tween is created will not have any effect.
		 * @property target
		 * @type {Object}
		 * @readonly
		 */
		this.target = target;
	
		/**
		 * The current normalized position of the tween. This will always be a value between 0 and duration.
		 * Changing this property directly will have no effect.
		 * @property position
		 * @type {Object}
		 * @readonly
		 */
		this.position = null;
	
		/**
		 * Indicates the tween's current position is within a passive wait.
		 * @property passive
		 * @type {Boolean}
		 * @default false
		 * @readonly
		 **/
		this.passive = false;
	
	// private properties:	
		/**
		 * @property _paused
		 * @type {Boolean}
		 * @default false
		 * @protected
		 */
		this._paused = false;
	
		/**
		 * @property _curQueueProps
		 * @type {Object}
		 * @protected
		 */
		this._curQueueProps = {};
	
		/**
		 * @property _initQueueProps
		 * @type {Object}
		 * @protected
		 */
		this._initQueueProps = {};
	
		/**
		 * @property _steps
		 * @type {Array}
		 * @protected
		 */
		this._steps = [];
	
		/**
		 * @property _actions
		 * @type {Array}
		 * @protected
		 */
		this._actions = [];
	
		/**
		 * Raw position.
		 * @property _prevPosition
		 * @type {Number}
		 * @default 0
		 * @protected
		 */
		this._prevPosition = 0;
	
		/**
		 * The position within the current step.
		 * @property _stepPosition
		 * @type {Number}
		 * @default 0
		 * @protected
		 */
		this._stepPosition = 0; // this is needed by MovieClip.
	
		/**
		 * Normalized position.
		 * @property _prevPos
		 * @type {Number}
		 * @default -1
		 * @protected
		 */
		this._prevPos = -1;
	
		/**
		 * @property _target
		 * @type {Object}
		 * @protected
		 */
		this._target = target;
	
		/**
		 * @property _useTicks
		 * @type {Boolean}
		 * @default false
		 * @protected
		 */
		this._useTicks = false;
	
		/**
		 * @property _inited
		 * @type {boolean}
		 * @default false
		 * @protected
		 */
		this._inited = false;
		
		/**
		 * Indicates whether the tween is currently registered with Tween.
		 * @property _registered
		 * @type {boolean}
		 * @default false
		 * @protected
		 */
		this._registered = false;


		if (props) {
			this._useTicks = props.useTicks;
			this.ignoreGlobalPause = props.ignoreGlobalPause;
			this.loop = props.loop;
			props.onChange && this.addEventListener("change", props.onChange);
			if (props.override) { Tween.removeTweens(target); }
		}
		if (props&&props.paused) { this._paused=true; }
		else { createjs.Tween._register(this,true); }
		if (props&&props.position!=null) { this.setPosition(props.position, Tween.NONE); }

	};

	var p = createjs.extend(Tween, createjs.EventDispatcher);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	

// static properties
	/**
	 * Constant defining the none actionsMode for use with setPosition.
	 * @property NONE
	 * @type Number
	 * @default 0
	 * @static
	 */
	Tween.NONE = 0;

	/**
	 * Constant defining the loop actionsMode for use with setPosition.
	 * @property LOOP
	 * @type Number
	 * @default 1
	 * @static
	 */
	Tween.LOOP = 1;

	/**
	 * Constant defining the reverse actionsMode for use with setPosition.
	 * @property REVERSE
	 * @type Number
	 * @default 2
	 * @static
	 */
	Tween.REVERSE = 2;

	/**
	 * Constant returned by plugins to tell the tween not to use default assignment.
	 * @property IGNORE
	 * @type Object
	 * @static
	 */
	Tween.IGNORE = {};

	/**
	 * @property _listeners
	 * @type Array[Tween]
	 * @static
	 * @protected
	 */
	Tween._tweens = [];

	/**
	 * @property _plugins
	 * @type Object
	 * @static
	 * @protected
	 */
	Tween._plugins = {};


// static methods	
	/**
	 * Returns a new tween instance. This is functionally identical to using "new Tween(...)", but looks cleaner
	 * with the chained syntax of TweenJS.
	 * <h4>Example</h4>
	 *
	 *		var tween = createjs.Tween.get(target);
	 *
	 * @method get
	 * @param {Object} target The target object that will have its properties tweened.
	 * @param {Object} [props] The configuration properties to apply to this tween instance (ex. `{loop:true, paused:true}`).
	 * All properties default to `false`. Supported props are:
	 * <UL>
	 *    <LI> loop: sets the loop property on this tween.</LI>
	 *    <LI> useTicks: uses ticks for all durations instead of milliseconds.</LI>
	 *    <LI> ignoreGlobalPause: sets the {{#crossLink "Tween/ignoreGlobalPause:property"}}{{/crossLink}} property on
	 *    this tween.</LI>
	 *    <LI> override: if true, `createjs.Tween.removeTweens(target)` will be called to remove any other tweens with
	 *    the same target.
	 *    <LI> paused: indicates whether to start the tween paused.</LI>
	 *    <LI> position: indicates the initial position for this tween.</LI>
	 *    <LI> onChange: specifies a listener for the {{#crossLink "Tween/change:event"}}{{/crossLink}} event.</LI>
	 * </UL>
	 * @param {Object} [pluginData] An object containing data for use by installed plugins. See individual plugins'
	 * documentation for details.
	 * @param {Boolean} [override=false] If true, any previous tweens on the same target will be removed. This is the
	 * same as calling `Tween.removeTweens(target)`.
	 * @return {Tween} A reference to the created tween. Additional chained tweens, method calls, or callbacks can be
	 * applied to the returned tween instance.
	 * @static
	 */
	Tween.get = function(target, props, pluginData, override) {
		if (override) { Tween.removeTweens(target); }
		return new Tween(target, props, pluginData);
	};

	/**
	 * Advances all tweens. This typically uses the {{#crossLink "Ticker"}}{{/crossLink}} class, but you can call it
	 * manually if you prefer to use your own "heartbeat" implementation.
	 * @method tick
	 * @param {Number} delta The change in time in milliseconds since the last tick. Required unless all tweens have
	 * `useTicks` set to true.
	 * @param {Boolean} paused Indicates whether a global pause is in effect. Tweens with {{#crossLink "Tween/ignoreGlobalPause:property"}}{{/crossLink}}
	 * will ignore this, but all others will pause if this is `true`.
	 * @static
	 */
	Tween.tick = function(delta, paused) {
		var tweens = Tween._tweens.slice(); // to avoid race conditions.
		for (var i=tweens.length-1; i>=0; i--) {
			var tween = tweens[i];
			if ((paused && !tween.ignoreGlobalPause) || tween._paused) { continue; }
			tween.tick(tween._useTicks?1:delta);
		}
	};

	/**
	 * Handle events that result from Tween being used as an event handler. This is included to allow Tween to handle
	 * {{#crossLink "Ticker/tick:event"}}{{/crossLink}} events from the createjs {{#crossLink "Ticker"}}{{/crossLink}}.
	 * No other events are handled in Tween.
	 * @method handleEvent
	 * @param {Object} event An event object passed in by the {{#crossLink "EventDispatcher"}}{{/crossLink}}. Will
	 * usually be of type "tick".
	 * @private
	 * @static
	 * @since 0.4.2
	 */
	Tween.handleEvent = function(event) {
		if (event.type == "tick") {
			this.tick(event.delta, event.paused);
		}
	};

	/**
	 * Removes all existing tweens for a target. This is called automatically by new tweens if the `override`
	 * property is `true`.
	 * @method removeTweens
	 * @param {Object} target The target object to remove existing tweens from.
	 * @static
	 */
	Tween.removeTweens = function(target) {
		if (!target.tweenjs_count) { return; }
		var tweens = Tween._tweens;
		for (var i=tweens.length-1; i>=0; i--) {
			var tween = tweens[i];
			if (tween._target == target) {
				tween._paused = true;
				tweens.splice(i, 1);
			}
		}
		target.tweenjs_count = 0;
	};

	/**
	 * Stop and remove all existing tweens.
	 * @method removeAllTweens
	 * @static
	 * @since 0.4.1
	 */
	Tween.removeAllTweens = function() {
		var tweens = Tween._tweens;
		for (var i= 0, l=tweens.length; i<l; i++) {
			var tween = tweens[i];
			tween._paused = true;
			tween.target&&(tween.target.tweenjs_count = 0);
		}
		tweens.length = 0;
	};

	/**
	 * Indicates whether there are any active tweens (and how many) on the target object (if specified) or in general.
	 * @method hasActiveTweens
	 * @param {Object} [target] The target to check for active tweens. If not specified, the return value will indicate
	 * if there are any active tweens on any target.
	 * @return {Boolean} If there are active tweens.
	 * @static
	 */
	Tween.hasActiveTweens = function(target) {
		if (target) { return target.tweenjs_count != null && !!target.tweenjs_count; }
		return Tween._tweens && !!Tween._tweens.length;
	};

	/**
	 * Installs a plugin, which can modify how certain properties are handled when tweened. See the {{#crossLink "CSSPlugin"}}{{/crossLink}}
	 * for an example of how to write TweenJS plugins.
	 * @method installPlugin
	 * @static
	 * @param {Object} plugin The plugin class to install
	 * @param {Array} properties An array of properties that the plugin will handle.
	 */
	Tween.installPlugin = function(plugin, properties) {
		var priority = plugin.priority;
		if (priority == null) { plugin.priority = priority = 0; }
		for (var i=0,l=properties.length,p=Tween._plugins;i<l;i++) {
			var n = properties[i];
			if (!p[n]) { p[n] = [plugin]; }
			else {
				var arr = p[n];
				for (var j=0,jl=arr.length;j<jl;j++) {
					if (priority < arr[j].priority) { break; }
				}
				p[n].splice(j,0,plugin);
			}
		}
	};

	/**
	 * Registers or unregisters a tween with the ticking system.
	 * @method _register
	 * @param {Tween} tween The tween instance to register or unregister.
	 * @param {Boolean} value If `true`, the tween is registered. If `false` the tween is unregistered.
	 * @static
	 * @protected
	 */
	Tween._register = function(tween, value) {
		var target = tween._target;
		var tweens = Tween._tweens;
		if (value && !tween._registered) {
			// TODO: this approach might fail if a dev is using sealed objects in ES5
			if (target) { target.tweenjs_count = target.tweenjs_count ? target.tweenjs_count+1 : 1; }
			tweens.push(tween);
			if (!Tween._inited && createjs.Ticker) { createjs.Ticker.addEventListener("tick", Tween); Tween._inited = true; }
		} else if (!value && tween._registered) {
			if (target) { target.tweenjs_count--; }
			var i = tweens.length;
			while (i--) {
				if (tweens[i] == tween) {
					tweens.splice(i, 1);
					break;
				}
			}
		}
		tween._registered = value;
	};


// events:
	/**
	 * Called whenever the tween's position changes.
	 * @event change
	 * @since 0.4.0
	 **/
	

// public methods:
	/**
	 * Queues a wait (essentially an empty tween).
	 * <h4>Example</h4>
	 *
	 *		//This tween will wait 1s before alpha is faded to 0.
	 *		createjs.Tween.get(target).wait(1000).to({alpha:0}, 1000);
	 *
	 * @method wait
	 * @param {Number} duration The duration of the wait in milliseconds (or in ticks if `useTicks` is true).
	 * @param {Boolean} [passive] Tween properties will not be updated during a passive wait. This
	 * is mostly useful for use with {{#crossLink "Timeline"}}{{/crossLink}} instances that contain multiple tweens
	 * affecting the same target at different times.
	 * @return {Tween} This tween instance (for chaining calls).
	 **/
	p.wait = function(duration, passive) {
		if (duration == null || duration <= 0) { return this; }
		var o = this._cloneProps(this._curQueueProps);
		return this._addStep({d:duration, p0:o, e:this._linearEase, p1:o, v:passive});
	};

	/**
	 * Queues a tween from the current values to the target properties. Set duration to 0 to jump to these value.
	 * Numeric properties will be tweened from their current value in the tween to the target value. Non-numeric
	 * properties will be set at the end of the specified duration.
	 * <h4>Example</h4>
	 *
	 *		createjs.Tween.get(target).to({alpha:0}, 1000);
	 *
	 * @method to
	 * @param {Object} props An object specifying property target values for this tween (Ex. `{x:300}` would tween the x
	 * property of the target to 300).
	 * @param {Number} [duration=0] The duration of the wait in milliseconds (or in ticks if `useTicks` is true).
	 * @param {Function} [ease="linear"] The easing function to use for this tween. See the {{#crossLink "Ease"}}{{/crossLink}}
	 * class for a list of built-in ease functions.
	 * @return {Tween} This tween instance (for chaining calls).
	 */
	p.to = function(props, duration, ease) {
		if (isNaN(duration) || duration < 0) { duration = 0; }
		return this._addStep({d:duration||0, p0:this._cloneProps(this._curQueueProps), e:ease, p1:this._cloneProps(this._appendQueueProps(props))});
	};

	/**
	 * Queues an action to call the specified function.
	 * <h4>Example</h4>
	 *
	 *   	//would call myFunction() after 1 second.
	 *   	myTween.wait(1000).call(myFunction);
	 *
	 * @method call
	 * @param {Function} callback The function to call.
	 * @param {Array} [params]. The parameters to call the function with. If this is omitted, then the function
	 *      will be called with a single param pointing to this tween.
	 * @param {Object} [scope]. The scope to call the function in. If omitted, it will be called in the target's
	 *      scope.
	 * @return {Tween} This tween instance (for chaining calls).
	 */
	p.call = function(callback, params, scope) {
		return this._addAction({f:callback, p:params ? params : [this], o:scope ? scope : this._target});
	};

	// TODO: add clarification between this and a 0 duration .to:
	/**
	 * Queues an action to set the specified props on the specified target. If target is null, it will use this tween's
	 * target.
	 * <h4>Example</h4>
	 *
	 *		myTween.wait(1000).set({visible:false},foo);
	 *
	 * @method set
	 * @param {Object} props The properties to set (ex. `{visible:false}`).
	 * @param {Object} [target] The target to set the properties on. If omitted, they will be set on the tween's target.
	 * @return {Tween} This tween instance (for chaining calls).
	 */
	p.set = function(props, target) {
		return this._addAction({f:this._set, o:this, p:[props, target ? target : this._target]});
	};

	/**
	 * Queues an action to play (unpause) the specified tween. This enables you to sequence multiple tweens.
	 * <h4>Example</h4>
	 *
	 *		myTween.to({x:100},500).play(otherTween);
	 *
	 * @method play
	 * @param {Tween} tween The tween to play.
	 * @return {Tween} This tween instance (for chaining calls).
	 */
	p.play = function(tween) {
		if (!tween) { tween = this; }
		return this.call(tween.setPaused, [false], tween);
	};

	/**
	 * Queues an action to pause the specified tween.
	 * @method pause
	 * @param {Tween} tween The tween to pause. If null, it pauses this tween.
	 * @return {Tween} This tween instance (for chaining calls)
	 */
	p.pause = function(tween) {
		if (!tween) { tween = this; }
		return this.call(tween.setPaused, [true], tween);
	};

	/**
	 * Advances the tween to a specified position.
	 * @method setPosition
	 * @param {Number} value The position to seek to in milliseconds (or ticks if useTicks is true).
	 * @param {Number} [actionsMode=1] Specifies how actions are handled (ie. call, set, play, pause):
	 * <ul>
	 *      <li>{{#crossLink "Tween/NONE:property"}}{{/crossLink}} (0) - run no actions.</li>
	 *      <li>{{#crossLink "Tween/LOOP:property"}}{{/crossLink}} (1) - if new position is less than old, then run all
	 *      actions between old and duration, then all actions between 0 and new.</li>
	 *      <li>{{#crossLink "Tween/REVERSE:property"}}{{/crossLink}} (2) - if new position is less than old, run all
	 *      actions between them in reverse.</li>
	 * </ul>
	 * @return {Boolean} Returns `true` if the tween is complete (ie. the full tween has run & {{#crossLink "Tween/loop:property"}}{{/crossLink}}
	 * is `false`).
	 */
	p.setPosition = function(value, actionsMode) {
		if (value < 0) { value = 0; }
		if (actionsMode == null) { actionsMode = 1; }

		// normalize position:
		var t = value;
		var end = false;
		if (t >= this.duration) {
			if (this.loop) { t = t%this.duration; }
			else {
				t = this.duration;
				end = true;
			}
		}
		if (t == this._prevPos) { return end; }


		var prevPos = this._prevPos;
		this.position = this._prevPos = t; // set this in advance in case an action modifies position.
		this._prevPosition = value;

		// handle tweens:
		if (this._target) {
			if (end) {
				// addresses problems with an ending zero length step.
				this._updateTargetProps(null,1);
			} else if (this._steps.length > 0) {
				// find our new tween index:
				for (var i=0, l=this._steps.length; i<l; i++) {
					if (this._steps[i].t > t) { break; }
				}
				var step = this._steps[i-1];
				this._updateTargetProps(step,(this._stepPosition = t-step.t)/step.d);
			}
		}

		// run actions:
		if (actionsMode != 0 && this._actions.length > 0) {
			if (this._useTicks) {
				// only run the actions we landed on.
				this._runActions(t,t);
			} else if (actionsMode == 1 && t<prevPos) {
				if (prevPos != this.duration) { this._runActions(prevPos, this.duration); }
				this._runActions(0, t, true);
			} else {
				this._runActions(prevPos, t);
			}
		}

		if (end) { this.setPaused(true); }

        this.dispatchEvent("change");
		return end;
	};

	/**
	 * Advances this tween by the specified amount of time in milliseconds (or ticks if`useTicks` is `true`).
	 * This is normally called automatically by the Tween engine (via {{#crossLink "Tween/tick"}}{{/crossLink}}), but is
	 * exposed for advanced uses.
	 * @method tick
	 * @param {Number} delta The time to advance in milliseconds (or ticks if `useTicks` is `true`).
	 */
	p.tick = function(delta) {
		if (this._paused) { return; }
		this.setPosition(this._prevPosition+delta);
	};

	/**
	 * Pauses or plays this tween.
	 * @method setPaused
	 * @param {Boolean} [value=true] Indicates whether the tween should be paused (`true`) or played (`false`).
	 * @return {Tween} This tween instance (for chaining calls)
	 */
	p.setPaused = function(value) {
		if (this._paused === !!value) { return this; }
		this._paused = !!value;
		Tween._register(this, !value);
		return this;
	};

	// tiny api (primarily for tool output):
	p.w = p.wait;
	p.t = p.to;
	p.c = p.call;
	p.s = p.set;

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 */
	p.toString = function() {
		return "[Tween]";
	};

	/**
	 * @method clone
	 * @protected
	 */
	p.clone = function() {
		throw("Tween can not be cloned.")
	};

// private methods:
	/**
	 * @method _updateTargetProps
	 * @param {Object} step
	 * @param {Number} ratio
	 * @protected
	 */
	p._updateTargetProps = function(step, ratio) {
		var p0,p1,v,v0,v1,arr;
		if (!step && ratio == 1) {
			// GDS: when does this run? Just at the very end? Shouldn't.
			this.passive = false;
			p0 = p1 = this._curQueueProps;
		} else {
			this.passive = !!step.v;
			if (this.passive) { return; } // don't update props.
			// apply ease to ratio.
			if (step.e) { ratio = step.e(ratio,0,1,1); }
			p0 = step.p0;
			p1 = step.p1;
		}

		for (var n in this._initQueueProps) {
			if ((v0 = p0[n]) == null) { p0[n] = v0 = this._initQueueProps[n]; }
			if ((v1 = p1[n]) == null) { p1[n] = v1 = v0; }
			if (v0 == v1 || ratio == 0 || ratio == 1 || (typeof(v0) != "number")) {
				// no interpolation - either at start, end, values don't change, or the value is non-numeric.
				v = ratio == 1 ? v1 : v0;
			} else {
				v = v0+(v1-v0)*ratio;
			}

			var ignore = false;
			if (arr = Tween._plugins[n]) {
				for (var i=0,l=arr.length;i<l;i++) {
					var v2 = arr[i].tween(this, n, v, p0, p1, ratio, !!step&&p0==p1, !step);
					if (v2 == Tween.IGNORE) { ignore = true; }
					else { v = v2; }
				}
			}
			if (!ignore) { this._target[n] = v; }
		}

	};

	/**
	 * @method _runActions
	 * @param {Number} startPos
	 * @param {Number} endPos
	 * @param {Boolean} includeStart
	 * @protected
	 */
	p._runActions = function(startPos, endPos, includeStart) {
		var sPos = startPos;
		var ePos = endPos;
		var i = -1;
		var j = this._actions.length;
		var k = 1;
		if (startPos > endPos) {
			// running backwards, flip everything:
			sPos = endPos;
			ePos = startPos;
			i = j;
			j = k = -1;
		}
		while ((i+=k) != j) {
			var action = this._actions[i];
			var pos = action.t;
			if (pos == ePos || (pos > sPos && pos < ePos) || (includeStart && pos == startPos) ) {
				action.f.apply(action.o, action.p);
			}
		}
	};

	/**
	 * @method _appendQueueProps
	 * @param {Object} o
	 * @protected
	 */
	p._appendQueueProps = function(o) {
		var arr,oldValue,i, l, injectProps;
		for (var n in o) {
			if (this._initQueueProps[n] === undefined) {
				oldValue = this._target[n];

				// init plugins:
				if (arr = Tween._plugins[n]) {
					for (i=0,l=arr.length;i<l;i++) {
						oldValue = arr[i].init(this, n, oldValue);
					}
				}
				this._initQueueProps[n] = this._curQueueProps[n] = (oldValue===undefined) ? null : oldValue;
			} else {
				oldValue = this._curQueueProps[n];
			}
		}

		for (var n in o) {
			oldValue = this._curQueueProps[n];
			if (arr = Tween._plugins[n]) {
				injectProps = injectProps||{};
				for (i=0, l=arr.length;i<l;i++) {
					// TODO: remove the check for .step in the next version. It's here for backwards compatibility.
					if (arr[i].step) { arr[i].step(this, n, oldValue, o[n], injectProps); }
				}
			}
			this._curQueueProps[n] = o[n];
		}
		if (injectProps) { this._appendQueueProps(injectProps); }
		return this._curQueueProps;
	};

	/**
	 * @method _cloneProps
	 * @param {Object} props
	 * @protected
	 */
	p._cloneProps = function(props) {
		var o = {};
		for (var n in props) {
			o[n] = props[n];
		}
		return o;
	};

	/**
	 * @method _addStep
	 * @param {Object} o
	 * @protected
	 */
	p._addStep = function(o) {
		if (o.d > 0) {
			this._steps.push(o);
			o.t = this.duration;
			this.duration += o.d;
		}
		return this;
	};

	/**
	 * @method _addAction
	 * @param {Object} o
	 * @protected
	 */
	p._addAction = function(o) {
		o.t = this.duration;
		this._actions.push(o);
		return this;
	};

	/**
	 * @method _set
	 * @param {Object} props
	 * @param {Object} o
	 * @protected
	 */
	p._set = function(props, o) {
		for (var n in props) {
			o[n] = props[n];
		}
	};

	createjs.Tween = createjs.promote(Tween, "EventDispatcher");

}());

//##############################################################################
// Timeline.js
//##############################################################################

this.createjs = this.createjs||{};


(function() {
	"use strict";
	

// constructor	
	/**
	 * The Timeline class synchronizes multiple tweens and allows them to be controlled as a group. Please note that if a
	 * timeline is looping, the tweens on it may appear to loop even if the "loop" property of the tween is false.
	 * @class Timeline
	 * @param {Array} tweens An array of Tweens to add to this timeline. See {{#crossLink "Timeline/addTween"}}{{/crossLink}}
	 * for more info.
	 * @param {Object} labels An object defining labels for using {{#crossLink "Timeline/gotoAndPlay"}}{{/crossLink}}/{{#crossLink "Timeline/gotoAndStop"}}{{/crossLink}}.
	 * See {{#crossLink "Timeline/setLabels"}}{{/crossLink}}
	 * for details.
	 * @param {Object} props The configuration properties to apply to this tween instance (ex. `{loop:true}`). All properties
	 * default to false. Supported props are:<UL>
	 *    <LI> loop: sets the loop property on this tween.</LI>
	 *    <LI> useTicks: uses ticks for all durations instead of milliseconds.</LI>
	 *    <LI> ignoreGlobalPause: sets the ignoreGlobalPause property on this tween.</LI>
	 *    <LI> paused: indicates whether to start the tween paused.</LI>
	 *    <LI> position: indicates the initial position for this timeline.</LI>
	 *    <LI> onChange: specifies a listener to add for the {{#crossLink "Timeline/change:event"}}{{/crossLink}} event.</LI>
	 * </UL>
	 * @extends EventDispatcher
	 * @constructor
	 **/
	function Timeline(tweens, labels, props) {
		this.EventDispatcher_constructor();

	// public properties:
		/**
		 * Causes this timeline to continue playing when a global pause is active.
		 * @property ignoreGlobalPause
		 * @type Boolean
		 **/
		this.ignoreGlobalPause = false;

		/**
		 * The total duration of this timeline in milliseconds (or ticks if `useTicks `is `true`). This value is usually
		 * automatically updated as you modify the timeline. See {{#crossLink "Timeline/updateDuration"}}{{/crossLink}}
		 * for more information.
		 * @property duration
		 * @type Number
		 * @default 0
		 * @readonly
		 **/
		this.duration = 0;

		/**
		 * If true, the timeline will loop when it reaches the end. Can be set via the props param.
		 * @property loop
		 * @type Boolean
		 **/
		this.loop = false;

		/**
		 * The current normalized position of the timeline. This will always be a value between 0 and
		 * {{#crossLink "Timeline/duration:property"}}{{/crossLink}}.
		 * Changing this property directly will have no effect.
		 * @property position
		 * @type Object
		 * @readonly
		 **/
		this.position = null;

		// private properties:
		/**
		 * @property _paused
		 * @type Boolean
		 * @protected
		 **/
		this._paused = false;

		/**
		 * @property _tweens
		 * @type Array[Tween]
		 * @protected
		 **/
		this._tweens = [];

		/**
		 * @property _labels
		 * @type Object
		 * @protected
		 **/
		this._labels = null;

		/**
		 * @property _labelList
		 * @type Array[Object]
		 * @protected
		 **/
		this._labelList = null;

		/**
		 * @property _prevPosition
		 * @type Number
		 * @default 0
		 * @protected
		 **/
		this._prevPosition = 0;

		/**
		 * @property _prevPos
		 * @type Number
		 * @default -1
		 * @protected
		 **/
		this._prevPos = -1;

		/**
		 * @property _useTicks
		 * @type Boolean
		 * @default false
		 * @protected
		 **/
		this._useTicks = false;
		
		/**
		 * Indicates whether the timeline is currently registered with Tween.
		 * @property _registered
		 * @type {boolean}
		 * @default false
		 * @protected
		 */
		this._registered = false;


		if (props) {
			this._useTicks = props.useTicks;
			this.loop = props.loop;
			this.ignoreGlobalPause = props.ignoreGlobalPause;
			props.onChange&&this.addEventListener("change", props.onChange);
		}
		if (tweens) { this.addTween.apply(this, tweens); }
		this.setLabels(labels);
		if (props&&props.paused) { this._paused=true; }
		else { createjs.Tween._register(this,true); }
		if (props&&props.position!=null) { this.setPosition(props.position, createjs.Tween.NONE); }
		
	};
	
	var p = createjs.extend(Timeline, createjs.EventDispatcher);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.

	
// events:
	/**
	 * Called whenever the timeline's position changes.
	 * @event change
	 * @since 0.5.0
	 **/


// public methods:
	/**
	 * Adds one or more tweens (or timelines) to this timeline. The tweens will be paused (to remove them from the
	 * normal ticking system) and managed by this timeline. Adding a tween to multiple timelines will result in
	 * unexpected behaviour.
	 * @method addTween
	 * @param {Tween} ...tween The tween(s) to add. Accepts multiple arguments.
	 * @return {Tween} The first tween that was passed in.
	 **/
	p.addTween = function(tween) {
		var l = arguments.length;
		if (l > 1) {
			for (var i=0; i<l; i++) { this.addTween(arguments[i]); }
			return arguments[0];
		} else if (l == 0) { return null; }
		this.removeTween(tween);
		this._tweens.push(tween);
		tween.setPaused(true);
		tween._paused = false;
		tween._useTicks = this._useTicks;
		if (tween.duration > this.duration) { this.duration = tween.duration; }
		if (this._prevPos >= 0) { tween.setPosition(this._prevPos, createjs.Tween.NONE); }
		return tween;
	};

	/**
	 * Removes one or more tweens from this timeline.
	 * @method removeTween
	 * @param {Tween} ...tween The tween(s) to remove. Accepts multiple arguments.
	 * @return Boolean Returns `true` if all of the tweens were successfully removed.
	 **/
	p.removeTween = function(tween) {
		var l = arguments.length;
		if (l > 1) {
			var good = true;
			for (var i=0; i<l; i++) { good = good && this.removeTween(arguments[i]); }
			return good;
		} else if (l == 0) { return false; }

		var tweens = this._tweens;
		var i = tweens.length;
		while (i--) {
			if (tweens[i] == tween) {
				tweens.splice(i, 1);
				if (tween.duration >= this.duration) { this.updateDuration(); }
				return true;
			}
		}
		return false;
	};

	/**
	 * Adds a label that can be used with {{#crossLink "Timeline/gotoAndPlay"}}{{/crossLink}}/{{#crossLink "Timeline/gotoAndStop"}}{{/crossLink}}.
	 * @method addLabel
	 * @param {String} label The label name.
	 * @param {Number} position The position this label represents.
	 **/
	p.addLabel = function(label, position) {
		this._labels[label] = position;
		var list = this._labelList;
		if (list) {
			for (var i= 0,l=list.length; i<l; i++) { if (position < list[i].position) { break; } }
			list.splice(i, 0, {label:label, position:position});
		}
	};

	/**
	 * Defines labels for use with gotoAndPlay/Stop. Overwrites any previously set labels.
	 * @method setLabels
	 * @param {Object} o An object defining labels for using {{#crossLink "Timeline/gotoAndPlay"}}{{/crossLink}}/{{#crossLink "Timeline/gotoAndStop"}}{{/crossLink}}
	 * in the form `{labelName:time}` where time is in milliseconds (or ticks if `useTicks` is `true`).
	 **/
	p.setLabels = function(o) {
		this._labels = o ?  o : {};
	};

	/**
	 * Returns a sorted list of the labels defined on this timeline.
	 * @method getLabels
	 * @return {Array[Object]} A sorted array of objects with label and position properties.
	 **/
	p.getLabels = function() {
		var list = this._labelList;
		if (!list) {
			list = this._labelList = [];
			var labels = this._labels;
			for (var n in labels) {
				list.push({label:n, position:labels[n]});
			}
			list.sort(function (a,b) { return a.position- b.position; });
		}
		return list;
	};

	/**
	 * Returns the name of the label on or immediately before the current position. For example, given a timeline with
	 * two labels, "first" on frame index 4, and "second" on frame 8, getCurrentLabel would return:
	 * <UL>
	 * 		<LI>null if the current position is 2.</LI>
	 * 		<LI>"first" if the current position is 4.</LI>
	 * 		<LI>"first" if the current position is 7.</LI>
	 * 		<LI>"second" if the current position is 15.</LI>
	 * </UL>
	 * @method getCurrentLabel
	 * @return {String} The name of the current label or null if there is no label
	 **/
	p.getCurrentLabel = function() {
		var labels = this.getLabels();
		var pos = this.position;
		var l = labels.length;
		if (l) {
			for (var i = 0; i<l; i++) { if (pos < labels[i].position) { break; } }
			return (i==0) ? null : labels[i-1].label;
		}
		return null;
	};

	/**
	 * Unpauses this timeline and jumps to the specified position or label.
	 * @method gotoAndPlay
	 * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`)
	 * or label to jump to.
	 **/
	p.gotoAndPlay = function(positionOrLabel) {
		this.setPaused(false);
		this._goto(positionOrLabel);
	};

	/**
	 * Pauses this timeline and jumps to the specified position or label.
	 * @method gotoAndStop
	 * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`) or label
	 * to jump to.
	 **/
	p.gotoAndStop = function(positionOrLabel) {
		this.setPaused(true);
		this._goto(positionOrLabel);
	};

	/**
	 * Advances the timeline to the specified position.
	 * @method setPosition
	 * @param {Number} value The position to seek to in milliseconds (or ticks if `useTicks` is `true`).
	 * @param {Number} [actionsMode] parameter specifying how actions are handled. See the Tween {{#crossLink "Tween/setPosition"}}{{/crossLink}}
	 * method for more details.
	 * @return {Boolean} Returns `true` if the timeline is complete (ie. the full timeline has run & {{#crossLink "Timeline/loop:property"}}{{/crossLink}}
	 * is `false`).
	 **/
	p.setPosition = function(value, actionsMode) {
		var t = this._calcPosition(value);
		var end = !this.loop && value >= this.duration;
		if (t == this._prevPos) { return end; }
		this._prevPosition = value;
		this.position = this._prevPos = t; // in case an action changes the current frame.
		for (var i=0, l=this._tweens.length; i<l; i++) {
			this._tweens[i].setPosition(t, actionsMode);
			if (t != this._prevPos) { return false; } // an action changed this timeline's position.
		}
		if (end) { this.setPaused(true); }
		this.dispatchEvent("change");
		return end;
	};

	/**
	 * Pauses or plays this timeline.
	 * @method setPaused
	 * @param {Boolean} value Indicates whether the tween should be paused (`true`) or played (`false`).
	 **/
	p.setPaused = function(value) {
		this._paused = !!value; 
		createjs.Tween._register(this, !value);
	};

	/**
	 * Recalculates the duration of the timeline. The duration is automatically updated when tweens are added or removed,
	 * but this method is useful if you modify a tween after it was added to the timeline.
	 * @method updateDuration
	 **/
	p.updateDuration = function() {
		this.duration = 0;
		for (var i=0,l=this._tweens.length; i<l; i++) {
			var tween = this._tweens[i];
			if (tween.duration > this.duration) { this.duration = tween.duration; }
		}
	};

	/**
	 * Advances this timeline by the specified amount of time in milliseconds (or ticks if `useTicks` is `true`).
	 * This is normally called automatically by the Tween engine (via the {{#crossLink "Tween/tick:event"}}{{/crossLink}}
	 * event), but is exposed for advanced uses.
	 * @method tick
	 * @param {Number} delta The time to advance in milliseconds (or ticks if useTicks is true).
	 **/
	p.tick = function(delta) {
		this.setPosition(this._prevPosition+delta);
	};

	/**
	 * If a numeric position is passed, it is returned unchanged. If a string is passed, the position of the
	 * corresponding frame label will be returned, or `null` if a matching label is not defined.
	 * @method resolve
	 * @param {String|Number} positionOrLabel A numeric position value or label string.
	 **/
	p.resolve = function(positionOrLabel) {
		var pos = Number(positionOrLabel);
		if (isNaN(pos)) { pos = this._labels[positionOrLabel]; }
		return pos;
	};

	/**
	* Returns a string representation of this object.
	* @method toString
	* @return {String} a string representation of the instance.
	**/
	p.toString = function() {
		return "[Timeline]";
	};

	/**
	 * @method clone
	 * @protected
	 **/
	p.clone = function() {
		throw("Timeline can not be cloned.")
	};

// private methods:
	/**
	 * @method _goto
	 * @param {String | Number} positionOrLabel
	 * @protected
	 **/
	p._goto = function(positionOrLabel) {
		var pos = this.resolve(positionOrLabel);
		if (pos != null) { this.setPosition(pos); }
	};
	
	/**
	 * @method _calcPosition
	 * @param {Number} value
	 * @return {Number}
	 * @protected
	 **/
	p._calcPosition = function(value) {
		if (value < 0) { return 0; }
		if (value < this.duration) { return value; }
		return this.loop ? value%this.duration : this.duration;
	};

	createjs.Timeline = createjs.promote(Timeline, "EventDispatcher");

}());

//##############################################################################
// Ease.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

	/**
	 * The Ease class provides a collection of easing functions for use with TweenJS. It does not use the standard 4 param
	 * easing signature. Instead it uses a single param which indicates the current linear ratio (0 to 1) of the tween.
	 *
	 * Most methods on Ease can be passed directly as easing functions:
	 *
	 *      Tween.get(target).to({x:100}, 500, Ease.linear);
	 *
	 * However, methods beginning with "get" will return an easing function based on parameter values:
	 *
	 *      Tween.get(target).to({y:200}, 500, Ease.getPowIn(2.2));
	 *
	 * Please see the <a href="http://www.createjs.com/Demos/TweenJS/Tween_SparkTable">spark table demo</a> for an
	 * overview of the different ease types on <a href="http://tweenjs.com">TweenJS.com</a>.
	 *
	 * <em>Equations derived from work by Robert Penner.</em>
	 * @class Ease
	 * @static
	 **/
	function Ease() {
		throw "Ease cannot be instantiated.";
	}


// static methods and properties
	/**
	 * @method linear
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.linear = function(t) { return t; };

	/**
	 * Identical to linear.
	 * @method none
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.none = Ease.linear;

	/**
	 * Mimics the simple -100 to 100 easing in Flash Pro.
	 * @method get
	 * @param {Number} amount A value from -1 (ease in) to 1 (ease out) indicating the strength and direction of the ease.
	 * @static
	 * @return {Function}
	 **/
	Ease.get = function(amount) {
		if (amount < -1) { amount = -1; }
		if (amount > 1) { amount = 1; }
		return function(t) {
			if (amount==0) { return t; }
			if (amount<0) { return t*(t*-amount+1+amount); }
			return t*((2-t)*amount+(1-amount));
		};
	};

	/**
	 * Configurable exponential ease.
	 * @method getPowIn
	 * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
	 * @static
	 * @return {Function}
	 **/
	Ease.getPowIn = function(pow) {
		return function(t) {
			return Math.pow(t,pow);
		};
	};

	/**
	 * Configurable exponential ease.
	 * @method getPowOut
	 * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
	 * @static
	 * @return {Function}
	 **/
	Ease.getPowOut = function(pow) {
		return function(t) {
			return 1-Math.pow(1-t,pow);
		};
	};

	/**
	 * Configurable exponential ease.
	 * @method getPowInOut
	 * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
	 * @static
	 * @return {Function}
	 **/
	Ease.getPowInOut = function(pow) {
		return function(t) {
			if ((t*=2)<1) return 0.5*Math.pow(t,pow);
			return 1-0.5*Math.abs(Math.pow(2-t,pow));
		};
	};

	/**
	 * @method quadIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quadIn = Ease.getPowIn(2);
	/**
	 * @method quadOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quadOut = Ease.getPowOut(2);
	/**
	 * @method quadInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quadInOut = Ease.getPowInOut(2);

	/**
	 * @method cubicIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.cubicIn = Ease.getPowIn(3);
	/**
	 * @method cubicOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.cubicOut = Ease.getPowOut(3);
	/**
	 * @method cubicInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.cubicInOut = Ease.getPowInOut(3);

	/**
	 * @method quartIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quartIn = Ease.getPowIn(4);
	/**
	 * @method quartOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quartOut = Ease.getPowOut(4);
	/**
	 * @method quartInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quartInOut = Ease.getPowInOut(4);

	/**
	 * @method quintIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quintIn = Ease.getPowIn(5);
	/**
	 * @method quintOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quintOut = Ease.getPowOut(5);
	/**
	 * @method quintInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quintInOut = Ease.getPowInOut(5);

	/**
	 * @method sineIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.sineIn = function(t) {
		return 1-Math.cos(t*Math.PI/2);
	};

	/**
	 * @method sineOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.sineOut = function(t) {
		return Math.sin(t*Math.PI/2);
	};

	/**
	 * @method sineInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.sineInOut = function(t) {
		return -0.5*(Math.cos(Math.PI*t) - 1);
	};

	/**
	 * Configurable "back in" ease.
	 * @method getBackIn
	 * @param {Number} amount The strength of the ease.
	 * @static
	 * @return {Function}
	 **/
	Ease.getBackIn = function(amount) {
		return function(t) {
			return t*t*((amount+1)*t-amount);
		};
	};
	/**
	 * @method backIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.backIn = Ease.getBackIn(1.7);

	/**
	 * Configurable "back out" ease.
	 * @method getBackOut
	 * @param {Number} amount The strength of the ease.
	 * @static
	 * @return {Function}
	 **/
	Ease.getBackOut = function(amount) {
		return function(t) {
			return (--t*t*((amount+1)*t + amount) + 1);
		};
	};
	/**
	 * @method backOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.backOut = Ease.getBackOut(1.7);

	/**
	 * Configurable "back in out" ease.
	 * @method getBackInOut
	 * @param {Number} amount The strength of the ease.
	 * @static
	 * @return {Function}
	 **/
	Ease.getBackInOut = function(amount) {
		amount*=1.525;
		return function(t) {
			if ((t*=2)<1) return 0.5*(t*t*((amount+1)*t-amount));
			return 0.5*((t-=2)*t*((amount+1)*t+amount)+2);
		};
	};
	/**
	 * @method backInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.backInOut = Ease.getBackInOut(1.7);

	/**
	 * @method circIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.circIn = function(t) {
		return -(Math.sqrt(1-t*t)- 1);
	};

	/**
	 * @method circOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.circOut = function(t) {
		return Math.sqrt(1-(--t)*t);
	};

	/**
	 * @method circInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.circInOut = function(t) {
		if ((t*=2) < 1) return -0.5*(Math.sqrt(1-t*t)-1);
		return 0.5*(Math.sqrt(1-(t-=2)*t)+1);
	};

	/**
	 * @method bounceIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.bounceIn = function(t) {
		return 1-Ease.bounceOut(1-t);
	};

	/**
	 * @method bounceOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.bounceOut = function(t) {
		if (t < 1/2.75) {
			return (7.5625*t*t);
		} else if (t < 2/2.75) {
			return (7.5625*(t-=1.5/2.75)*t+0.75);
		} else if (t < 2.5/2.75) {
			return (7.5625*(t-=2.25/2.75)*t+0.9375);
		} else {
			return (7.5625*(t-=2.625/2.75)*t +0.984375);
		}
	};

	/**
	 * @method bounceInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.bounceInOut = function(t) {
		if (t<0.5) return Ease.bounceIn (t*2) * .5;
		return Ease.bounceOut(t*2-1)*0.5+0.5;
	};

	/**
	 * Configurable elastic ease.
	 * @method getElasticIn
	 * @param {Number} amplitude
	 * @param {Number} period
	 * @static
	 * @return {Function}
	 **/
	Ease.getElasticIn = function(amplitude,period) {
		var pi2 = Math.PI*2;
		return function(t) {
			if (t==0 || t==1) return t;
			var s = period/pi2*Math.asin(1/amplitude);
			return -(amplitude*Math.pow(2,10*(t-=1))*Math.sin((t-s)*pi2/period));
		};
	};
	/**
	 * @method elasticIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.elasticIn = Ease.getElasticIn(1,0.3);

	/**
	 * Configurable elastic ease.
	 * @method getElasticOut
	 * @param {Number} amplitude
	 * @param {Number} period
	 * @static
	 * @return {Function}
	 **/
	Ease.getElasticOut = function(amplitude,period) {
		var pi2 = Math.PI*2;
		return function(t) {
			if (t==0 || t==1) return t;
			var s = period/pi2 * Math.asin(1/amplitude);
			return (amplitude*Math.pow(2,-10*t)*Math.sin((t-s)*pi2/period )+1);
		};
	};
	/**
	 * @method elasticOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.elasticOut = Ease.getElasticOut(1,0.3);

	/**
	 * Configurable elastic ease.
	 * @method getElasticInOut
	 * @param {Number} amplitude
	 * @param {Number} period
	 * @static
	 * @return {Function}
	 **/
	Ease.getElasticInOut = function(amplitude,period) {
		var pi2 = Math.PI*2;
		return function(t) {
			var s = period/pi2 * Math.asin(1/amplitude);
			if ((t*=2)<1) return -0.5*(amplitude*Math.pow(2,10*(t-=1))*Math.sin( (t-s)*pi2/period ));
			return amplitude*Math.pow(2,-10*(t-=1))*Math.sin((t-s)*pi2/period)*0.5+1;
		};
	};
	/**
	 * @method elasticInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.elasticInOut = Ease.getElasticInOut(1,0.3*1.5);

	createjs.Ease = Ease;

}());

//##############################################################################
// MotionGuidePlugin.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

	/**
	 * A TweenJS plugin for working with motion guides.
	 *
	 * To use, install the plugin after TweenJS has loaded. Next tween the 'guide' property with an object as detailed below.
	 *
	 *       createjs.MotionGuidePlugin.install();
	 *
	 * <h4>Example</h4>
	 *
	 *      // Using a Motion Guide
	 *	    createjs.Tween.get(target).to({guide:{ path:[0,0, 0,200,200,200, 200,0,0,0] }},7000);
	 *	    // Visualizing the line
	 *	    graphics.moveTo(0,0).curveTo(0,200,200,200).curveTo(200,0,0,0);
	 *
	 * Each path needs pre-computation to ensure there's fast performance. Because of the pre-computation there's no
	 * built in support for path changes mid tween. These are the Guide Object's properties:<UL>
	 *      <LI> path: Required, Array : The x/y points used to draw the path with a moveTo and 1 to n curveTo calls.</LI>
	 *      <LI> start: Optional, 0-1 : Initial position, default 0 except for when continuing along the same path.</LI>
	 *      <LI> end: Optional, 0-1 : Final position, default 1 if not specified.</LI>
	 *      <LI> orient: Optional, string : "fixed"/"auto"/"cw"/"ccw"<UL>
	 *				<LI>"fixed" forces the object to face down the path all movement (relative to start rotation),</LI>
	 *      		<LI>"auto" rotates the object along the path relative to the line.</LI>
	 *      		<LI>"cw"/"ccw" force clockwise or counter clockwise rotations including flash like behaviour</LI>
	 * 		</UL></LI>
	 * </UL>
	 * Guide objects should not be shared between tweens even if all properties are identical, the library stores
	 * information on these objects in the background and sharing them can cause unexpected behaviour. Values
	 * outside 0-1 range of tweens will be a "best guess" from the appropriate part of the defined curve.
	 *
	 * @class MotionGuidePlugin
	 * @constructor
	 **/
	function MotionGuidePlugin() {
		throw("MotionGuidePlugin cannot be instantiated.")
	};


// static properties:
	/**
	 * @property priority
	 * @protected
	 * @static
	 **/
	MotionGuidePlugin.priority = 0; // high priority, should run sooner

	/**
	 * @property temporary variable storage
	 * @private
	 * @static
	 */
	MotionGuidePlugin._rotOffS;
	/**
	 * @property temporary variable storage
	 * @private
	 * @static
	 */
	MotionGuidePlugin._rotOffE;
	/**
	 * @property temporary variable storage
	 * @private
	 * @static
	 */
	MotionGuidePlugin._rotNormS;
	/**
	 * @property temporary variable storage
	 * @private
	 * @static
	 */
	MotionGuidePlugin._rotNormE;


// static methods
	/**
	 * Installs this plugin for use with TweenJS. Call this once after TweenJS is loaded to enable this plugin.
	 * @method install
	 * @static
	 **/
	MotionGuidePlugin.install = function() {
		createjs.Tween.installPlugin(MotionGuidePlugin, ["guide", "x", "y", "rotation"]);
		return createjs.Tween.IGNORE;
	};

	/**
	 * @method init
	 * @protected
	 * @static
	 **/
	MotionGuidePlugin.init = function(tween, prop, value) {
		var target = tween.target;
		if(!target.hasOwnProperty("x")){ target.x = 0; }
		if(!target.hasOwnProperty("y")){ target.y = 0; }
		if(!target.hasOwnProperty("rotation")){ target.rotation = 0; }

		if(prop=="rotation"){ tween.__needsRot = true; }
		return prop=="guide"?null:value;
	};

	/**
	 * @method step
	 * @protected
	 * @static
	 **/
	MotionGuidePlugin.step = function(tween, prop, startValue, endValue, injectProps) {
		// other props
		if(prop == "rotation"){
			tween.__rotGlobalS = startValue;
			tween.__rotGlobalE = endValue;
			MotionGuidePlugin.testRotData(tween, injectProps);
		}
		if(prop != "guide"){ return endValue; }

		// guide only information - Start -
		var temp, data = endValue;
		if(!data.hasOwnProperty("path")){ data.path = []; }
		var path = data.path;
		if(!data.hasOwnProperty("end")){ data.end = 1; }
		if(!data.hasOwnProperty("start")){
			data.start = (startValue&&startValue.hasOwnProperty("end")&&startValue.path===path)?startValue.end:0;
		}

		// Figure out subline information
		if(data.hasOwnProperty("_segments") && data._length){ return endValue; }
		var l = path.length;
		var accuracy = 10;		// Adjust to improve line following precision but sacrifice performance (# of seg)
		if(l >= 6 && (l-2) % 4 == 0){	// Enough points && contains correct number per entry ignoring start
			data._segments = [];
			data._length = 0;
			for(var i=2; i<l; i+=4){
				var sx = path[i-2], sy = path[i-1];
				var cx = path[i+0], cy = path[i+1];
				var ex = path[i+2], ey = path[i+3];
				var oldX = sx, oldY = sy;
				var tempX, tempY, total = 0;
				var sublines = [];
				for(var j=1; j<=accuracy; j++){
					var t = j/accuracy;
					var inv = 1 - t;
					tempX = inv*inv * sx + 2 * inv * t * cx + t*t * ex;
					tempY = inv*inv * sy + 2 * inv * t * cy + t*t * ey;
					total += sublines[sublines.push(Math.sqrt((temp=tempX-oldX)*temp + (temp=tempY-oldY)*temp))-1];
					oldX = tempX;
					oldY = tempY;
				}
				data._segments.push(total);
				data._segments.push(sublines);
				data._length += total;
			}
		} else {
			throw("invalid 'path' data, please see documentation for valid paths");
		}

		// Setup x/y tweens
		temp = data.orient;
		data.orient = true;
		var o = {};
		MotionGuidePlugin.calc(data, data.start, o);
		tween.__rotPathS = Number(o.rotation.toFixed(5));
		MotionGuidePlugin.calc(data, data.end, o);
		tween.__rotPathE = Number(o.rotation.toFixed(5));
		data.orient = false;	//here and now we don't know if we need to
		MotionGuidePlugin.calc(data, data.end, injectProps);
		data.orient = temp;

		// Setup rotation properties
		if(!data.orient){ return endValue; }
		tween.__guideData = data;
		MotionGuidePlugin.testRotData(tween, injectProps);
		return endValue;
	};

	/**
	 * @method testRotData
	 * @protected
	 * @static
	 **/
	MotionGuidePlugin.testRotData = function(tween, injectProps){

		// no rotation informat? if we need it come back, if we don't use 0 & ensure we have guide data
		if(tween.__rotGlobalS === undefined || tween.__rotGlobalE === undefined){
			if(tween.__needsRot){ return; }
			if(tween._curQueueProps.rotation !== undefined){
				tween.__rotGlobalS = tween.__rotGlobalE = tween._curQueueProps.rotation;
			} else {
				tween.__rotGlobalS = tween.__rotGlobalE = injectProps.rotation = tween.target.rotation || 0;
			}
		}
		if(tween.__guideData === undefined){ return; }

		// Process rotation properties
		var data = tween.__guideData;
		var rotGlobalD = tween.__rotGlobalE - tween.__rotGlobalS;
		var rotPathD = tween.__rotPathE - tween.__rotPathS;
		var rot = rotGlobalD - rotPathD;

		if(data.orient == "auto"){
			if(rot > 180){			rot -= 360; }
			else if(rot < -180){	rot += 360; }

		} else if(data.orient == "cw"){
			while(rot < 0){ rot += 360; }
			if(rot == 0 && rotGlobalD > 0 && rotGlobalD != 180){ rot += 360; }

		} else if(data.orient == "ccw"){
			rot = rotGlobalD - ((rotPathD > 180)?(360-rotPathD):(rotPathD));	// sign flipping on path
			while(rot > 0){ rot -= 360; }
			if(rot == 0 && rotGlobalD < 0 && rotGlobalD != -180){ rot -= 360; }
		}

		data.rotDelta = rot;
		data.rotOffS = tween.__rotGlobalS - tween.__rotPathS;

		// reset
		tween.__rotGlobalS = tween.__rotGlobalE = tween.__guideData = tween.__needsRot = undefined;
	};

	/**
	 * @method tween
	 * @protected
	 * @static
	 **/
	MotionGuidePlugin.tween = function(tween, prop, value, startValues, endValues, ratio, wait, end) {
		var data = endValues.guide;
		if(data == undefined || data === startValues.guide){ return value; }
		if(data.lastRatio != ratio){
			// first time through so calculate what I need to
			var t = ((data.end-data.start)*(wait?data.end:ratio)+data.start);
			MotionGuidePlugin.calc(data, t, tween.target);
			switch(data.orient){
				case "cw":		// mix in the original rotation
				case "ccw":
				case "auto": tween.target.rotation += data.rotOffS + data.rotDelta*ratio; break;
				case "fixed":	// follow fixed behaviour to solve potential issues
				default: tween.target.rotation += data.rotOffS; break;
			}
			data.lastRatio = ratio;
		}
		if(prop == "rotation" && ((!data.orient) || data.orient == "false")){ return value; }
		return tween.target[prop];
	};

	/**
	 * Determine the appropriate x/y/rotation information about a path for a given ratio along the path.
	 * Assumes a path object with all optional parameters specified.
	 * @param data Data object you would pass to the "guide:" property in a Tween
	 * @param ratio 0-1 Distance along path, values outside 0-1 are "best guess"
	 * @param target Object to copy the results onto, will use a new object if not supplied.
	 * @return {Object} The target object or a new object w/ the tweened properties
	 * @static
	 */
	MotionGuidePlugin.calc = function(data, ratio, target) {
		if(data._segments == undefined){ MotionGuidePlugin.validate(data); }
		if(target == undefined){ target = {x:0, y:0, rotation:0}; }
		var seg = data._segments;
		var path = data.path;

		// find segment
		var pos = data._length * ratio;
		var cap = seg.length - 2;
		var n = 0;
		while(pos > seg[n] && n < cap){
			pos -= seg[n];
			n+=2;
		}

		// find subline
		var sublines = seg[n+1];
		var i = 0;
		cap = sublines.length-1;
		while(pos > sublines[i] && i < cap){
			pos -= sublines[i];
			i++;
		}
		var t = (i/++cap)+(pos/(cap*sublines[i]));

		// find x/y
		n = (n*2)+2;
		var inv = 1 - t;
		target.x = inv*inv * path[n-2] + 2 * inv * t * path[n+0] + t*t * path[n+2];
		target.y = inv*inv * path[n-1] + 2 * inv * t * path[n+1] + t*t * path[n+3];

		// orientation
		if(data.orient){
			target.rotation = 57.2957795 * Math.atan2(
				(path[n+1]-path[n-1])*inv + (path[n+3]-path[n+1])*t,
				(path[n+0]-path[n-2])*inv + (path[n+2]-path[n+0])*t);
		}

		return target;
	};

	createjs.MotionGuidePlugin = MotionGuidePlugin;

}());

//##############################################################################
// version.js
//##############################################################################

this.createjs = this.createjs || {};

(function() {
	"use strict";

	/**
	 * Static class holding library specific information such as the version and buildDate of
	 * the library.
	 * @class TweenJS
	 **/
	var s = createjs.TweenJS = createjs.TweenJS || {};

	/**
	 * The version string for this release.
	 * @property version
	 * @type String
	 * @static
	 **/
	s.version = /*=version*/"0.6.1"; // injected by build process

	/**
	 * The build date for this release in UTC format.
	 * @property buildDate
	 * @type String
	 * @static
	 **/
	s.buildDate = /*=date*/"Thu, 21 May 2015 16:17:37 GMT"; // injected by build process

})();
if(typeof module !== "undefined" && typeof module.exports !== "undefined") module.exports = this.createjs;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
'use strict'

module.exports = function(stage, resized) {

	var createjs = require('createjs-collection');

	var squareWidth, squareHeight, xOffset, yOffset, spacing;

	setStageSize();
	getSquareDimensions();
	getOffsets();

	for (var i = 0; i < 4; i++) {
		if (!resized)
			addSquare();
		else
			redrawSquare(i);
	}

	stage.update();

	function setStageSize() {

		var gameSection = document.getElementById('gameSection');

		// resize canvas to be responsive with section element
		var width = gameSection.offsetWidth,
			height = gameSection.offsetHeight;

		// this ensures the squares are always squares and fit within the screen
		if (width > height) {
			stage.canvas.width = height;
			stage.canvas.height = height;
		} else {
			stage.canvas.width = width;
			stage.canvas.height = width;
		}

	};

	function getSquareDimensions() {

		// square dimensions
		squareWidth = stage.canvas.width * 0.4;
		squareHeight = stage.canvas.height * 0.4;

	};

	function getOffsets() {

		// x and y offsets from center for square positioning
		xOffset = (stage.canvas.width / 2) - squareWidth - 5;
		yOffset = (stage.canvas.height / 2) - squareHeight - 5;

		// spacing between the squares
		spacing = 10;

	};

	function addSquare() {

		var square = new createjs.Shape();
		square.graphics.beginFill(getSquareColor(square.id)).drawRect(0, 0, squareWidth, squareHeight);
		square.shadow = new createjs.Shadow("#000", 5, 5, 10);
		square.x = getXPosition(square.id);
		square.y = getYPosition(square.id);
		stage.addChild(square);

	};

	function redrawSquare(squareIndex) {

		var square = stage.getChildAt(squareIndex);
		square.graphics.clear();
		square.graphics.beginFill(getSquareColor(square.id)).drawRect(0, 0, squareWidth, squareHeight);
		square.shadow = new createjs.Shadow("#000", 5, 5, 10);
		square.x = getXPosition(square.id);
		square.y = getYPosition(square.id);

	};

	function getSquareColor(squareId) {

		if (squareId === 1) 
			return "red";
		else if (squareId === 2) 
			return "green";
		else if (squareId === 3)
			return "blue";
		else
			return "yellow";

	}

	function getXPosition(squareId) {

		if (squareId === 1 || squareId === 3) 
			return xOffset;
		else 
			return xOffset + squareWidth + spacing;

	};

	function getYPosition(squareId) {

		if (squareId === 1 || squareId === 2) 
			return yOffset;
		else 
			return yOffset + squareHeight + spacing;

	};

	/*
		Draw Function Uses:
		- drawRect
		- apply shadow
		- add the rectangle to the canvas

	/* 
		-Changing x moves the shape horizonatally
		-Changing y moves the shape vertically
		-Changing alpha will fade the shape in and out
	*/

	/*
		createjs.Tween.get(circle, { loop: true })
			.to({ x: 400 }, 1000, createjs.Ease.getPowInOut(4))
			.to({ alpha: 0, y: 175 }, 500, createjs.Ease.getPowInOut(2))
			.to({ alpha: 0, y: 225 }, 100)
			.to({ alpha: 1, y: 200 }, 500, createjs.Ease.getPowInOut(2))
			.to({ x: 100 }, 800, createjs.Ease.getPowInOut(2));

		createjs.Ticker.setFPS(60);
		createjs.Ticker.addEventListener("tick", stage);
	*/

};
},{"createjs-collection":1}],3:[function(require,module,exports){
module.exports = function() {

	var createjs = require('createjs-collection');

	var canvas, stage;
		
	canvas = document.getElementById('gameCanvas');
	stage = new createjs.Stage(canvas);

	createjs.Touch.enable(stage);

	stage.enableMouseOver(10);
	stage.mouseMoveOutside = true;

	return stage;

};
},{"createjs-collection":1}],4:[function(require,module,exports){
(function() {

	'use strict'

	var init = require('./init'),
		draw = require('./drawSquares');

	// Polling for the sake of my intern tests
	var interval = setInterval(function() {
	    if(document.readyState === 'complete') {
	        clearInterval(interval);
	        done();
	    }    
	}, 100);

	function done() {

		window.addEventListener('resize', resize, false);

		var stage = init();
		draw(stage, false);
		console.log('complete');

		function resize() {

			draw(stage, true);

		}

	}

	

	var randomInt = require('./randomIntFromInterval');

	var randomSquare = randomInt(1, 4);

})();
},{"./drawSquares":2,"./init":3,"./randomIntFromInterval":5}],5:[function(require,module,exports){
'use strict'

module.exports = function (min, max) {

	return Math.floor(Math.random() * (max-min+1) + min);

}
},{}]},{},[4])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvY3JlYXRlanMtY29sbGVjdGlvbi9jcmVhdGVqcy5qcyIsInB1YmxpYy9qcy9kcmF3U3F1YXJlcy5qcyIsInB1YmxpYy9qcy9pbml0LmpzIiwicHVibGljL2pzL21haW4uanMiLCJwdWJsaWMvanMvcmFuZG9tSW50RnJvbUludGVydmFsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcHJ0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwidmFyIGNyZWF0ZWpzID0gKHRoaXMuY3JlYXRlanMgPSAodGhpcy5jcmVhdGVqcyB8fCB7fSkpO1xuLyohXG4qIEVhc2VsSlNcbiogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgZ3NraW5uZXIuY29tLCBpbmMuXG4qXG4qIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4qIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4qIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4qIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4qIGNvbmRpdGlvbnM6XG4qXG4qIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4qIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuKlxuKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4qIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4qIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIGV4dGVuZC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuXG4vKipcbiAqIFNldHMgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiBhbmQgY29uc3RydWN0b3IgcHJvcGVydHkgZm9yIGEgbmV3IGNsYXNzLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCByaWdodCBhZnRlciBjcmVhdGluZyB0aGUgY2xhc3MgY29uc3RydWN0b3IuXG4gKlxuICogXHRmdW5jdGlvbiBNeVN1YkNsYXNzKCkge31cbiAqIFx0Y3JlYXRlanMuZXh0ZW5kKE15U3ViQ2xhc3MsIE15U3VwZXJDbGFzcyk7XG4gKiBcdENsYXNzQi5wcm90b3R5cGUuZG9Tb21ldGhpbmcgPSBmdW5jdGlvbigpIHsgfVxuICpcbiAqIFx0dmFyIGZvbyA9IG5ldyBNeVN1YkNsYXNzKCk7XG4gKiBcdGNvbnNvbGUubG9nKGZvbyBpbnN0YW5jZW9mIE15U3VwZXJDbGFzcyk7IC8vIHRydWVcbiAqIFx0Y29uc29sZS5sb2coZm9vLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9PT0gTXlTdWJDbGFzcyk7IC8vIHRydWVcbiAqXG4gKiBAbWV0aG9kIGV4dGVuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ViY2xhc3MgVGhlIHN1YmNsYXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJjbGFzcyBUaGUgc3VwZXJjbGFzcyB0byBleHRlbmQuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgc3ViY2xhc3MncyBuZXcgcHJvdG90eXBlLlxuICovXG5jcmVhdGVqcy5leHRlbmQgPSBmdW5jdGlvbihzdWJjbGFzcywgc3VwZXJjbGFzcykge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRmdW5jdGlvbiBvKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gc3ViY2xhc3M7IH1cblx0by5wcm90b3R5cGUgPSBzdXBlcmNsYXNzLnByb3RvdHlwZTtcblx0cmV0dXJuIChzdWJjbGFzcy5wcm90b3R5cGUgPSBuZXcgbygpKTtcbn07XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBwcm9tb3RlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbi8qKlxuICogUHJvbW90ZXMgYW55IG1ldGhvZHMgb24gdGhlIHN1cGVyIGNsYXNzIHRoYXQgd2VyZSBvdmVycmlkZGVuLCBieSBjcmVhdGluZyBhbiBhbGlhcyBpbiB0aGUgZm9ybWF0IGBwcmVmaXhfbWV0aG9kTmFtZWAuXG4gKiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgdGhlIHN1cGVyIGNsYXNzJ3MgbmFtZSBhcyB0aGUgcHJlZml4LlxuICogQW4gYWxpYXMgdG8gdGhlIHN1cGVyIGNsYXNzJ3MgY29uc3RydWN0b3IgaXMgYWx3YXlzIGFkZGVkIGluIHRoZSBmb3JtYXQgYHByZWZpeF9jb25zdHJ1Y3RvcmAuXG4gKiBUaGlzIGFsbG93cyB0aGUgc3ViY2xhc3MgdG8gY2FsbCBzdXBlciBjbGFzcyBtZXRob2RzIHdpdGhvdXQgdXNpbmcgYGZ1bmN0aW9uLmNhbGxgLCBwcm92aWRpbmcgYmV0dGVyIHBlcmZvcm1hbmNlLlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiBgTXlTdWJDbGFzc2AgZXh0ZW5kcyBgTXlTdXBlckNsYXNzYCwgYW5kIGJvdGggZGVmaW5lIGEgYGRyYXdgIG1ldGhvZCwgdGhlbiBjYWxsaW5nIGBwcm9tb3RlKE15U3ViQ2xhc3MsIFwiTXlTdXBlckNsYXNzXCIpYFxuICogd291bGQgYWRkIGEgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAgbWV0aG9kIHRvIE15U3ViQ2xhc3MgYW5kIHByb21vdGUgdGhlIGBkcmF3YCBtZXRob2Qgb24gYE15U3VwZXJDbGFzc2AgdG8gdGhlXG4gKiBwcm90b3R5cGUgb2YgYE15U3ViQ2xhc3NgIGFzIGBNeVN1cGVyQ2xhc3NfZHJhd2AuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoZSBjbGFzcydzIHByb3RvdHlwZSBpcyBmdWxseSBkZWZpbmVkLlxuICpcbiAqIFx0ZnVuY3Rpb24gQ2xhc3NBKG5hbWUpIHtcbiAqIFx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuICogXHR9XG4gKiBcdENsYXNzQS5wcm90b3R5cGUuZ3JlZXQgPSBmdW5jdGlvbigpIHtcbiAqIFx0XHRyZXR1cm4gXCJIZWxsbyBcIit0aGlzLm5hbWU7XG4gKiBcdH1cbiAqXG4gKiBcdGZ1bmN0aW9uIENsYXNzQihuYW1lLCBwdW5jdHVhdGlvbikge1xuICogXHRcdHRoaXMuQ2xhc3NBX2NvbnN0cnVjdG9yKG5hbWUpO1xuICogXHRcdHRoaXMucHVuY3R1YXRpb24gPSBwdW5jdHVhdGlvbjtcbiAqIFx0fVxuICogXHRjcmVhdGVqcy5leHRlbmQoQ2xhc3NCLCBDbGFzc0EpO1xuICogXHRDbGFzc0IucHJvdG90eXBlLmdyZWV0ID0gZnVuY3Rpb24oKSB7XG4gKiBcdFx0cmV0dXJuIHRoaXMuQ2xhc3NBX2dyZWV0KCkrdGhpcy5wdW5jdHVhdGlvbjtcbiAqIFx0fVxuICogXHRjcmVhdGVqcy5wcm9tb3RlKENsYXNzQiwgXCJDbGFzc0FcIik7XG4gKlxuICogXHR2YXIgZm9vID0gbmV3IENsYXNzQihcIldvcmxkXCIsIFwiIT8hXCIpO1xuICogXHRjb25zb2xlLmxvZyhmb28uZ3JlZXQoKSk7IC8vIEhlbGxvIFdvcmxkIT8hXG4gKlxuICogQG1ldGhvZCBwcm9tb3RlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJjbGFzcyBUaGUgY2xhc3MgdG8gcHJvbW90ZSBzdXBlciBjbGFzcyBtZXRob2RzIG9uLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBUaGUgcHJlZml4IHRvIGFkZCB0byB0aGUgcHJvbW90ZWQgbWV0aG9kIG5hbWVzLiBVc3VhbGx5IHRoZSBuYW1lIG9mIHRoZSBzdXBlcmNsYXNzLlxuICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgdGhlIHN1YmNsYXNzLlxuICovXG5jcmVhdGVqcy5wcm9tb3RlID0gZnVuY3Rpb24oc3ViY2xhc3MsIHByZWZpeCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHR2YXIgc3ViUCA9IHN1YmNsYXNzLnByb3RvdHlwZSwgc3VwUCA9IChPYmplY3QuZ2V0UHJvdG90eXBlT2YmJk9iamVjdC5nZXRQcm90b3R5cGVPZihzdWJQKSl8fHN1YlAuX19wcm90b19fO1xuXHRpZiAoc3VwUCkge1xuXHRcdHN1YlBbKHByZWZpeCs9XCJfXCIpICsgXCJjb25zdHJ1Y3RvclwiXSA9IHN1cFAuY29uc3RydWN0b3I7IC8vIGNvbnN0cnVjdG9yIGlzIG5vdCBhbHdheXMgaW5udW1lcmFibGVcblx0XHRmb3IgKHZhciBuIGluIHN1cFApIHtcblx0XHRcdGlmIChzdWJQLmhhc093blByb3BlcnR5KG4pICYmICh0eXBlb2Ygc3VwUFtuXSA9PSBcImZ1bmN0aW9uXCIpKSB7IHN1YlBbcHJlZml4ICsgbl0gPSBzdXBQW25dOyB9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBzdWJjbGFzcztcbn07XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBpbmRleE9mLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBzcGVjaWZpZWQgdmFsdWUgc2VhcmNoRWxlbWVudCBpbiB0aGUgcGFzc2VkIGluIGFycmF5LCBhbmQgcmV0dXJucyB0aGUgaW5kZXggb2ZcbiAqIHRoYXQgdmFsdWUuICBSZXR1cm5zIC0xIGlmIHZhbHVlIGlzIG5vdCBmb3VuZC5cbiAqXG4gKiAgICAgIHZhciBpID0gY3JlYXRlanMuaW5kZXhPZihteUFycmF5LCBteUVsZW1lbnRUb0ZpbmQpO1xuICpcbiAqIEBtZXRob2QgaW5kZXhPZlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgQXJyYXkgdG8gc2VhcmNoIGZvciBzZWFyY2hFbGVtZW50XG4gKiBAcGFyYW0gc2VhcmNoRWxlbWVudCBFbGVtZW50IHRvIGZpbmQgaW4gYXJyYXkuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBmaXJzdCBpbmRleCBvZiBzZWFyY2hFbGVtZW50IGluIGFycmF5LlxuICovXG5jcmVhdGVqcy5pbmRleE9mID0gZnVuY3Rpb24gKGFycmF5LCBzZWFyY2hFbGVtZW50KXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Zm9yICh2YXIgaSA9IDAsbD1hcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRpZiAoc2VhcmNoRWxlbWVudCA9PT0gYXJyYXlbaV0pIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59O1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRXZlbnQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBDb250YWlucyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHNoYXJlZCBieSBhbGwgZXZlbnRzIGZvciB1c2Ugd2l0aFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFxuXHQgKiBOb3RlIHRoYXQgRXZlbnQgb2JqZWN0cyBhcmUgb2Z0ZW4gcmV1c2VkLCBzbyB5b3Ugc2hvdWxkIG5ldmVyXG5cdCAqIHJlbHkgb24gYW4gZXZlbnQgb2JqZWN0J3Mgc3RhdGUgb3V0c2lkZSBvZiB0aGUgY2FsbCBzdGFjayBpdCB3YXMgcmVjZWl2ZWQgaW4uXG5cdCAqIEBjbGFzcyBFdmVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBidWJibGVzIEluZGljYXRlcyB3aGV0aGVyIHRoZSBldmVudCB3aWxsIGJ1YmJsZSB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FuY2VsYWJsZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdGhpcyBldmVudCBjYW4gYmUgY2FuY2VsbGVkLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBFdmVudCh0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlKSB7XG5cdFx0XG5cdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgdHlwZSBvZiBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgdHlwZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqKi9cblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgb2JqZWN0IHRoYXQgZ2VuZXJhdGVkIGFuIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSB0YXJnZXRcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLnRhcmdldCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IHRhcmdldCB0aGF0IGEgYnViYmxpbmcgZXZlbnQgaXMgYmVpbmcgZGlzcGF0Y2hlZCBmcm9tLiBGb3Igbm9uLWJ1YmJsaW5nIGV2ZW50cywgdGhpcyB3aWxsXG5cdFx0ICogYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHRhcmdldC4gRm9yIGV4YW1wbGUsIGlmIGNoaWxkT2JqLnBhcmVudCA9IHBhcmVudE9iaiwgYW5kIGEgYnViYmxpbmcgZXZlbnRcblx0XHQgKiBpcyBnZW5lcmF0ZWQgZnJvbSBjaGlsZE9iaiwgdGhlbiBhIGxpc3RlbmVyIG9uIHBhcmVudE9iaiB3b3VsZCByZWNlaXZlIHRoZSBldmVudCB3aXRoXG5cdFx0ICogdGFyZ2V0PWNoaWxkT2JqICh0aGUgb3JpZ2luYWwgdGFyZ2V0KSBhbmQgY3VycmVudFRhcmdldD1wYXJlbnRPYmogKHdoZXJlIHRoZSBsaXN0ZW5lciB3YXMgYWRkZWQpLlxuXHRcdCAqIEBwcm9wZXJ0eSBjdXJyZW50VGFyZ2V0XG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogRm9yIGJ1YmJsaW5nIGV2ZW50cywgdGhpcyBpbmRpY2F0ZXMgdGhlIGN1cnJlbnQgZXZlbnQgcGhhc2U6PE9MPlxuXHRcdCAqIFx0PExJPiBjYXB0dXJlIHBoYXNlOiBzdGFydGluZyBmcm9tIHRoZSB0b3AgcGFyZW50IHRvIHRoZSB0YXJnZXQ8L0xJPlxuXHRcdCAqIFx0PExJPiBhdCB0YXJnZXQgcGhhc2U6IGN1cnJlbnRseSBiZWluZyBkaXNwYXRjaGVkIGZyb20gdGhlIHRhcmdldDwvTEk+XG5cdFx0ICogXHQ8TEk+IGJ1YmJsaW5nIHBoYXNlOiBmcm9tIHRoZSB0YXJnZXQgdG8gdGhlIHRvcCBwYXJlbnQ8L0xJPlxuXHRcdCAqIDwvT0w+XG5cdFx0ICogQHByb3BlcnR5IGV2ZW50UGhhc2Vcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmV2ZW50UGhhc2UgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZXZlbnQgd2lsbCBidWJibGUgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBidWJibGVzXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmJ1YmJsZXMgPSAhIWJ1YmJsZXM7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiB0aGlzIGV2ZW50IGNhbiBiZSBjYW5jZWxsZWQgdmlhXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcHJldmVudERlZmF1bHRcIn19e3svY3Jvc3NMaW5rfX0uIFRoaXMgaXMgc2V0IHZpYSB0aGUgRXZlbnQgY29uc3RydWN0b3IuXG5cdFx0ICogQHByb3BlcnR5IGNhbmNlbGFibGVcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuY2FuY2VsYWJsZSA9ICEhY2FuY2VsYWJsZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGVwb2NoIHRpbWUgYXQgd2hpY2ggdGhpcyBldmVudCB3YXMgY3JlYXRlZC5cblx0XHQgKiBAcHJvcGVydHkgdGltZVN0YW1wXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy50aW1lU3RhbXAgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcHJldmVudERlZmF1bHRcIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkXG5cdFx0ICogb24gdGhpcyBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgZGVmYXVsdFByZXZlbnRlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9zdG9wUHJvcGFnYXRpb25cIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudC9zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkIG9uIHRoaXMgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IHByb3BhZ2F0aW9uU3RvcHBlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHt7I2Nyb3NzTGluayBcIkV2ZW50L3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwifX17ey9jcm9zc0xpbmt9fSBoYXMgYmVlbiBjYWxsZWRcblx0XHQgKiBvbiB0aGlzIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBpbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHt7I2Nyb3NzTGluayBcIkV2ZW50L3JlbW92ZVwifX17ey9jcm9zc0xpbmt9fSBoYXMgYmVlbiBjYWxsZWQgb24gdGhpcyBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgcmVtb3ZlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5yZW1vdmVkID0gZmFsc2U7XG5cdH1cblx0dmFyIHAgPSBFdmVudC5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFNldHMge3sjY3Jvc3NMaW5rIFwiRXZlbnQvZGVmYXVsdFByZXZlbnRlZFwifX17ey9jcm9zc0xpbmt9fSB0byB0cnVlIGlmIHRoZSBldmVudCBpcyBjYW5jZWxhYmxlLlxuXHQgKiBNaXJyb3JzIHRoZSBET00gbGV2ZWwgMiBldmVudCBzdGFuZGFyZC4gSW4gZ2VuZXJhbCwgY2FuY2VsYWJsZSBldmVudHMgdGhhdCBoYXZlIGBwcmV2ZW50RGVmYXVsdCgpYCBjYWxsZWQgd2lsbFxuXHQgKiBjYW5jZWwgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXG5cdCAqIEBtZXRob2QgcHJldmVudERlZmF1bHRcblx0ICoqL1xuXHRwLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5kZWZhdWx0UHJldmVudGVkID0gdGhpcy5jYW5jZWxhYmxlJiZ0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHt7I2Nyb3NzTGluayBcIkV2ZW50L3Byb3BhZ2F0aW9uU3RvcHBlZFwifX17ey9jcm9zc0xpbmt9fSB0byB0cnVlLlxuXHQgKiBNaXJyb3JzIHRoZSBET00gZXZlbnQgc3RhbmRhcmQuXG5cdCAqIEBtZXRob2Qgc3RvcFByb3BhZ2F0aW9uXG5cdCAqKi9cblx0cC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcHJvcGFnYXRpb25TdG9wcGVkXCJ9fXt7L2Nyb3NzTGlua319IGFuZFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudC9pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWRcIn19e3svY3Jvc3NMaW5rfX0gdG8gdHJ1ZS5cblx0ICogTWlycm9ycyB0aGUgRE9NIGV2ZW50IHN0YW5kYXJkLlxuXHQgKiBAbWV0aG9kIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblxuXHQgKiovXG5cdHAuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQ2F1c2VzIHRoZSBhY3RpdmUgbGlzdGVuZXIgdG8gYmUgcmVtb3ZlZCB2aWEgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuXHQgKiBcblx0ICogXHRcdG15QnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihldnQpIHtcblx0ICogXHRcdFx0Ly8gZG8gc3R1ZmYuLi5cblx0ICogXHRcdFx0ZXZ0LnJlbW92ZSgpOyAvLyByZW1vdmVzIHRoaXMgbGlzdGVuZXIuXG5cdCAqIFx0XHR9KTtcblx0ICogXG5cdCAqIEBtZXRob2QgcmVtb3ZlXG5cdCAqKi9cblx0cC5yZW1vdmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlbW92ZWQgPSB0cnVlO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgRXZlbnQgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7RXZlbnR9IGEgY2xvbmUgb2YgdGhlIEV2ZW50IGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEV2ZW50KHRoaXMudHlwZSwgdGhpcy5idWJibGVzLCB0aGlzLmNhbmNlbGFibGUpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFByb3ZpZGVzIGEgY2hhaW5hYmxlIHNob3J0Y3V0IG1ldGhvZCBmb3Igc2V0dGluZyBhIG51bWJlciBvZiBwcm9wZXJ0aWVzIG9uIHRoZSBpbnN0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBzZXRcblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEEgZ2VuZXJpYyBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRvIGNvcHkgdG8gdGhlIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtFdmVudH0gUmV0dXJucyB0aGUgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAuc2V0ID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRmb3IgKHZhciBuIGluIHByb3BzKSB7IHRoaXNbbl0gPSBwcm9wc1tuXTsgfVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbRXZlbnQgKHR5cGU9XCIrdGhpcy50eXBlK1wiKV1cIjtcblx0fTtcblxuXHRjcmVhdGVqcy5FdmVudCA9IEV2ZW50O1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEV2ZW50RGlzcGF0Y2hlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbi8vIGNvbnN0cnVjdG9yOlxyXG5cdC8qKlxyXG5cdCAqIEV2ZW50RGlzcGF0Y2hlciBwcm92aWRlcyBtZXRob2RzIGZvciBtYW5hZ2luZyBxdWV1ZXMgb2YgZXZlbnQgbGlzdGVuZXJzIGFuZCBkaXNwYXRjaGluZyBldmVudHMuXHJcblx0ICpcclxuXHQgKiBZb3UgY2FuIGVpdGhlciBleHRlbmQgRXZlbnREaXNwYXRjaGVyIG9yIG1peCBpdHMgbWV0aG9kcyBpbnRvIGFuIGV4aXN0aW5nIHByb3RvdHlwZSBvciBpbnN0YW5jZSBieSB1c2luZyB0aGVcclxuXHQgKiBFdmVudERpc3BhdGNoZXIge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL2luaXRpYWxpemVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxyXG5cdCAqIFxyXG5cdCAqIFRvZ2V0aGVyIHdpdGggdGhlIENyZWF0ZUpTIEV2ZW50IGNsYXNzLCBFdmVudERpc3BhdGNoZXIgcHJvdmlkZXMgYW4gZXh0ZW5kZWQgZXZlbnQgbW9kZWwgdGhhdCBpcyBiYXNlZCBvbiB0aGVcclxuXHQgKiBET00gTGV2ZWwgMiBldmVudCBtb2RlbCwgaW5jbHVkaW5nIGFkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXIsIGFuZCBkaXNwYXRjaEV2ZW50LiBJdCBzdXBwb3J0c1xyXG5cdCAqIGJ1YmJsaW5nIC8gY2FwdHVyZSwgcHJldmVudERlZmF1bHQsIHN0b3BQcm9wYWdhdGlvbiwgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uLCBhbmQgaGFuZGxlRXZlbnQuXHJcblx0ICogXHJcblx0ICogRXZlbnREaXNwYXRjaGVyIGFsc28gZXhwb3NlcyBhIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9vblwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QsIHdoaWNoIG1ha2VzIGl0IGVhc2llclxyXG5cdCAqIHRvIGNyZWF0ZSBzY29wZWQgbGlzdGVuZXJzLCBsaXN0ZW5lcnMgdGhhdCBvbmx5IHJ1biBvbmNlLCBhbmQgbGlzdGVuZXJzIHdpdGggYXNzb2NpYXRlZCBhcmJpdHJhcnkgZGF0YS4gVGhlIFxyXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9vZmZcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGlzIG1lcmVseSBhbiBhbGlhcyB0b1xyXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9yZW1vdmVFdmVudExpc3RlbmVyXCJ9fXt7L2Nyb3NzTGlua319LlxyXG5cdCAqIFxyXG5cdCAqIEFub3RoZXIgYWRkaXRpb24gdG8gdGhlIERPTSBMZXZlbCAyIG1vZGVsIGlzIHRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnNcIn19e3svY3Jvc3NMaW5rfX1cclxuXHQgKiBtZXRob2QsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGxpc3RlbmVycyBmb3IgYWxsIGV2ZW50cywgb3IgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmljIGV2ZW50LiBUaGUgRXZlbnQgb2JqZWN0IGFsc28gXHJcblx0ICogaW5jbHVkZXMgYSB7eyNjcm9zc0xpbmsgXCJFdmVudC9yZW1vdmVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIHdoaWNoIHJlbW92ZXMgdGhlIGFjdGl2ZSBsaXN0ZW5lci5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKiBBZGQgRXZlbnREaXNwYXRjaGVyIGNhcGFiaWxpdGllcyB0byB0aGUgXCJNeUNsYXNzXCIgY2xhc3MuXHJcblx0ICpcclxuXHQgKiAgICAgIEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplKE15Q2xhc3MucHJvdG90eXBlKTtcclxuXHQgKlxyXG5cdCAqIEFkZCBhbiBldmVudCAoc2VlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9hZGRFdmVudExpc3RlbmVyXCJ9fXt7L2Nyb3NzTGlua319KS5cclxuXHQgKlxyXG5cdCAqICAgICAgaW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcihcImV2ZW50TmFtZVwiLCBoYW5kbGVyTWV0aG9kKTtcclxuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZXJNZXRob2QoZXZlbnQpIHtcclxuXHQgKiAgICAgICAgICBjb25zb2xlLmxvZyhldmVudC50YXJnZXQgKyBcIiBXYXMgQ2xpY2tlZFwiKTtcclxuXHQgKiAgICAgIH1cclxuXHQgKlxyXG5cdCAqIDxiPk1haW50YWluaW5nIHByb3BlciBzY29wZTwvYj48YnIgLz5cclxuXHQgKiBTY29wZSAoaWUuIFwidGhpc1wiKSBjYW4gYmUgYmUgYSBjaGFsbGVuZ2Ugd2l0aCBldmVudHMuIFVzaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvb25cIn19e3svY3Jvc3NMaW5rfX1cclxuXHQgKiBtZXRob2QgdG8gc3Vic2NyaWJlIHRvIGV2ZW50cyBzaW1wbGlmaWVzIHRoaXMuXHJcblx0ICpcclxuXHQgKiAgICAgIGluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCkge1xyXG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKGluc3RhbmNlID09IHRoaXMpOyAvLyBmYWxzZSwgc2NvcGUgaXMgYW1iaWd1b3VzLlxyXG5cdCAqICAgICAgfSk7XHJcblx0ICogICAgICBcclxuXHQgKiAgICAgIGluc3RhbmNlLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuXHQgKiAgICAgICAgICBjb25zb2xlLmxvZyhpbnN0YW5jZSA9PSB0aGlzKTsgLy8gdHJ1ZSwgXCJvblwiIHVzZXMgZGlzcGF0Y2hlciBzY29wZSBieSBkZWZhdWx0LlxyXG5cdCAqICAgICAgfSk7XHJcblx0ICogXHJcblx0ICogSWYgeW91IHdhbnQgdG8gdXNlIGFkZEV2ZW50TGlzdGVuZXIgaW5zdGVhZCwgeW91IG1heSB3YW50IHRvIHVzZSBmdW5jdGlvbi5iaW5kKCkgb3IgYSBzaW1pbGFyIHByb3h5IHRvIG1hbmFnZSBzY29wZS5cclxuXHQgKiAgICAgIFxyXG5cdCAqXHJcblx0ICogQGNsYXNzIEV2ZW50RGlzcGF0Y2hlclxyXG5cdCAqIEBjb25zdHJ1Y3RvclxyXG5cdCAqKi9cclxuXHRmdW5jdGlvbiBFdmVudERpc3BhdGNoZXIoKSB7XHJcblx0XHJcblx0XHJcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAcHJvcGVydHkgX2xpc3RlbmVyc1xyXG5cdFx0ICogQHR5cGUgT2JqZWN0XHJcblx0XHQgKiovXHJcblx0XHR0aGlzLl9saXN0ZW5lcnMgPSBudWxsO1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIEBwcm90ZWN0ZWRcclxuXHRcdCAqIEBwcm9wZXJ0eSBfY2FwdHVyZUxpc3RlbmVyc1xyXG5cdFx0ICogQHR5cGUgT2JqZWN0XHJcblx0XHQgKiovXHJcblx0XHR0aGlzLl9jYXB0dXJlTGlzdGVuZXJzID0gbnVsbDtcclxuXHR9XHJcblx0dmFyIHAgPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlO1xyXG5cclxuXHQvKipcclxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXHJcblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XHJcblx0ICogZm9yIGRldGFpbHMuXHJcblx0ICpcclxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiBAZGVwcmVjYXRlZFxyXG5cdCAqL1xyXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxyXG5cclxuXHJcbi8vIHN0YXRpYyBwdWJsaWMgbWV0aG9kczpcclxuXHQvKipcclxuXHQgKiBTdGF0aWMgaW5pdGlhbGl6ZXIgdG8gbWl4IEV2ZW50RGlzcGF0Y2hlciBtZXRob2RzIGludG8gYSB0YXJnZXQgb2JqZWN0IG9yIHByb3RvdHlwZS5cclxuXHQgKiBcclxuXHQgKiBcdFx0RXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUoTXlDbGFzcy5wcm90b3R5cGUpOyAvLyBhZGQgdG8gdGhlIHByb3RvdHlwZSBvZiB0aGUgY2xhc3NcclxuXHQgKiBcdFx0RXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUobXlPYmplY3QpOyAvLyBhZGQgdG8gYSBzcGVjaWZpYyBpbnN0YW5jZVxyXG5cdCAqIFxyXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxyXG5cdCAqIEBzdGF0aWNcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IHRvIGluamVjdCBFdmVudERpc3BhdGNoZXIgbWV0aG9kcyBpbnRvLiBUaGlzIGNhbiBiZSBhbiBpbnN0YW5jZSBvciBhXHJcblx0ICogcHJvdG90eXBlLlxyXG5cdCAqKi9cclxuXHRFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKHRhcmdldCkge1xyXG5cdFx0dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgPSBwLmFkZEV2ZW50TGlzdGVuZXI7XHJcblx0XHR0YXJnZXQub24gPSBwLm9uO1xyXG5cdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIgPSB0YXJnZXQub2ZmID0gIHAucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcclxuXHRcdHRhcmdldC5yZW1vdmVBbGxFdmVudExpc3RlbmVycyA9IHAucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnM7XHJcblx0XHR0YXJnZXQuaGFzRXZlbnRMaXN0ZW5lciA9IHAuaGFzRXZlbnRMaXN0ZW5lcjtcclxuXHRcdHRhcmdldC5kaXNwYXRjaEV2ZW50ID0gcC5kaXNwYXRjaEV2ZW50O1xyXG5cdFx0dGFyZ2V0Ll9kaXNwYXRjaEV2ZW50ID0gcC5fZGlzcGF0Y2hFdmVudDtcclxuXHRcdHRhcmdldC53aWxsVHJpZ2dlciA9IHAud2lsbFRyaWdnZXI7XHJcblx0fTtcclxuXHRcclxuXHJcbi8vIHB1YmxpYyBtZXRob2RzOlxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgdGhlIHNwZWNpZmllZCBldmVudCBsaXN0ZW5lci4gTm90ZSB0aGF0IGFkZGluZyBtdWx0aXBsZSBsaXN0ZW5lcnMgdG8gdGhlIHNhbWUgZnVuY3Rpb24gd2lsbCByZXN1bHQgaW5cclxuXHQgKiBtdWx0aXBsZSBjYWxsYmFja3MgZ2V0dGluZyBmaXJlZC5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spO1xyXG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcclxuXHQgKiAgICAgICAgIC8vIENsaWNrIGhhcHBlbmVkLlxyXG5cdCAqICAgICAgfVxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBBbiBvYmplY3Qgd2l0aCBhIGhhbmRsZUV2ZW50IG1ldGhvZCwgb3IgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5cclxuXHQgKiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXHJcblx0ICogQHJldHVybiB7RnVuY3Rpb24gfCBPYmplY3R9IFJldHVybnMgdGhlIGxpc3RlbmVyIGZvciBjaGFpbmluZyBvciBhc3NpZ25tZW50LlxyXG5cdCAqKi9cclxuXHRwLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xyXG5cdFx0dmFyIGxpc3RlbmVycztcclxuXHRcdGlmICh1c2VDYXB0dXJlKSB7XHJcblx0XHRcdGxpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgPSB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzfHx7fTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc3x8e307XHJcblx0XHR9XHJcblx0XHR2YXIgYXJyID0gbGlzdGVuZXJzW3R5cGVdO1xyXG5cdFx0aWYgKGFycikgeyB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpOyB9XHJcblx0XHRhcnIgPSBsaXN0ZW5lcnNbdHlwZV07IC8vIHJlbW92ZSBtYXkgaGF2ZSBkZWxldGVkIHRoZSBhcnJheVxyXG5cdFx0aWYgKCFhcnIpIHsgbGlzdGVuZXJzW3R5cGVdID0gW2xpc3RlbmVyXTsgIH1cclxuXHRcdGVsc2UgeyBhcnIucHVzaChsaXN0ZW5lcik7IH1cclxuXHRcdHJldHVybiBsaXN0ZW5lcjtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEEgc2hvcnRjdXQgbWV0aG9kIGZvciB1c2luZyBhZGRFdmVudExpc3RlbmVyIHRoYXQgbWFrZXMgaXQgZWFzaWVyIHRvIHNwZWNpZnkgYW4gZXhlY3V0aW9uIHNjb3BlLCBoYXZlIGEgbGlzdGVuZXJcclxuXHQgKiBvbmx5IHJ1biBvbmNlLCBhc3NvY2lhdGUgYXJiaXRyYXJ5IGRhdGEgd2l0aCB0aGUgbGlzdGVuZXIsIGFuZCByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG5cdCAqIFxyXG5cdCAqIFRoaXMgbWV0aG9kIHdvcmtzIGJ5IGNyZWF0aW5nIGFuIGFub255bW91cyB3cmFwcGVyIGZ1bmN0aW9uIGFuZCBzdWJzY3JpYmluZyBpdCB3aXRoIGFkZEV2ZW50TGlzdGVuZXIuXHJcblx0ICogVGhlIHdyYXBwZXIgZnVuY3Rpb24gaXMgcmV0dXJuZWQgZm9yIHVzZSB3aXRoIGByZW1vdmVFdmVudExpc3RlbmVyYCAob3IgYG9mZmApLlxyXG5cdCAqIFxyXG5cdCAqIDxiPklNUE9SVEFOVDo8L2I+IFRvIHJlbW92ZSBhIGxpc3RlbmVyIGFkZGVkIHdpdGggYG9uYCwgeW91IG11c3QgcGFzcyBpbiB0aGUgcmV0dXJuZWQgd3JhcHBlciBmdW5jdGlvbiBhcyB0aGUgbGlzdGVuZXIsIG9yIHVzZVxyXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50L3JlbW92ZVwifX17ey9jcm9zc0xpbmt9fS4gTGlrZXdpc2UsIGVhY2ggdGltZSB5b3UgY2FsbCBgb25gIGEgTkVXIHdyYXBwZXIgZnVuY3Rpb24gaXMgc3Vic2NyaWJlZCwgc28gbXVsdGlwbGUgY2FsbHNcclxuXHQgKiB0byBgb25gIHdpdGggdGhlIHNhbWUgcGFyYW1zIHdpbGwgY3JlYXRlIG11bHRpcGxlIGxpc3RlbmVycy5cclxuXHQgKiBcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICogXHJcblx0ICogXHRcdHZhciBsaXN0ZW5lciA9IG15QnRuLm9uKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2ssIG51bGwsIGZhbHNlLCB7Y291bnQ6M30pO1xyXG5cdCAqIFx0XHRmdW5jdGlvbiBoYW5kbGVDbGljayhldnQsIGRhdGEpIHtcclxuXHQgKiBcdFx0XHRkYXRhLmNvdW50IC09IDE7XHJcblx0ICogXHRcdFx0Y29uc29sZS5sb2codGhpcyA9PSBteUJ0bik7IC8vIHRydWUgLSBzY29wZSBkZWZhdWx0cyB0byB0aGUgZGlzcGF0Y2hlclxyXG5cdCAqIFx0XHRcdGlmIChkYXRhLmNvdW50ID09IDApIHtcclxuXHQgKiBcdFx0XHRcdGFsZXJ0KFwiY2xpY2tlZCAzIHRpbWVzIVwiKTtcclxuXHQgKiBcdFx0XHRcdG15QnRuLm9mZihcImNsaWNrXCIsIGxpc3RlbmVyKTtcclxuXHQgKiBcdFx0XHRcdC8vIGFsdGVybmF0ZWx5OiBldnQucmVtb3ZlKCk7XHJcblx0ICogXHRcdFx0fVxyXG5cdCAqIFx0XHR9XHJcblx0ICogXHJcblx0ICogQG1ldGhvZCBvblxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbiB8IE9iamVjdH0gbGlzdGVuZXIgQW4gb2JqZWN0IHdpdGggYSBoYW5kbGVFdmVudCBtZXRob2QsIG9yIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuXHJcblx0ICogdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gVGhlIHNjb3BlIHRvIGV4ZWN1dGUgdGhlIGxpc3RlbmVyIGluLiBEZWZhdWx0cyB0byB0aGUgZGlzcGF0Y2hlci9jdXJyZW50VGFyZ2V0IGZvciBmdW5jdGlvbiBsaXN0ZW5lcnMsIGFuZCB0byB0aGUgbGlzdGVuZXIgaXRzZWxmIGZvciBvYmplY3QgbGlzdGVuZXJzIChpZS4gdXNpbmcgaGFuZGxlRXZlbnQpLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIElmIHRydWUsIHRoZSBsaXN0ZW5lciB3aWxsIHJlbW92ZSBpdHNlbGYgYWZ0ZXIgdGhlIGZpcnN0IHRpbWUgaXQgaXMgdHJpZ2dlcmVkLlxyXG5cdCAqIEBwYXJhbSB7Kn0gW2RhdGFdIEFyYml0cmFyeSBkYXRhIHRoYXQgd2lsbCBiZSBpbmNsdWRlZCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciB3aGVuIHRoZSBsaXN0ZW5lciBpcyBjYWxsZWQuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZT1mYWxzZV0gRm9yIGV2ZW50cyB0aGF0IGJ1YmJsZSwgaW5kaWNhdGVzIHdoZXRoZXIgdG8gbGlzdGVuIGZvciB0aGUgZXZlbnQgaW4gdGhlIGNhcHR1cmUgb3IgYnViYmxpbmcvdGFyZ2V0IHBoYXNlLlxyXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBhbm9ueW1vdXMgZnVuY3Rpb24gdGhhdCB3YXMgY3JlYXRlZCBhbmQgYXNzaWduZWQgYXMgdGhlIGxpc3RlbmVyLiBUaGlzIGlzIG5lZWRlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGxhdGVyIHVzaW5nIC5yZW1vdmVFdmVudExpc3RlbmVyLlxyXG5cdCAqKi9cclxuXHRwLm9uID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIHNjb3BlLCBvbmNlLCBkYXRhLCB1c2VDYXB0dXJlKSB7XHJcblx0XHRpZiAobGlzdGVuZXIuaGFuZGxlRXZlbnQpIHtcclxuXHRcdFx0c2NvcGUgPSBzY29wZXx8bGlzdGVuZXI7XHJcblx0XHRcdGxpc3RlbmVyID0gbGlzdGVuZXIuaGFuZGxlRXZlbnQ7XHJcblx0XHR9XHJcblx0XHRzY29wZSA9IHNjb3BlfHx0aGlzO1xyXG5cdFx0cmV0dXJuIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jdGlvbihldnQpIHtcclxuXHRcdFx0XHRsaXN0ZW5lci5jYWxsKHNjb3BlLCBldnQsIGRhdGEpO1xyXG5cdFx0XHRcdG9uY2UmJmV2dC5yZW1vdmUoKTtcclxuXHRcdFx0fSwgdXNlQ2FwdHVyZSk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGV2ZW50IGxpc3RlbmVyLlxyXG5cdCAqXHJcblx0ICogPGI+SW1wb3J0YW50IE5vdGU6PC9iPiB0aGF0IHlvdSBtdXN0IHBhc3MgdGhlIGV4YWN0IGZ1bmN0aW9uIHJlZmVyZW5jZSB1c2VkIHdoZW4gdGhlIGV2ZW50IHdhcyBhZGRlZC4gSWYgYSBwcm94eVxyXG5cdCAqIGZ1bmN0aW9uLCBvciBmdW5jdGlvbiBjbG9zdXJlIGlzIHVzZWQgYXMgdGhlIGNhbGxiYWNrLCB0aGUgcHJveHkvY2xvc3VyZSByZWZlcmVuY2UgbXVzdCBiZSB1c2VkIC0gYSBuZXcgcHJveHkgb3JcclxuXHQgKiBjbG9zdXJlIHdpbGwgbm90IHdvcmsuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrKTtcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lclxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbiB8IE9iamVjdH0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIG9yIG9iamVjdC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXHJcblx0ICoqL1xyXG5cdHAucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdXNlQ2FwdHVyZSA/IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgOiB0aGlzLl9saXN0ZW5lcnM7XHJcblx0XHRpZiAoIWxpc3RlbmVycykgeyByZXR1cm47IH1cclxuXHRcdHZhciBhcnIgPSBsaXN0ZW5lcnNbdHlwZV07XHJcblx0XHRpZiAoIWFycikgeyByZXR1cm47IH1cclxuXHRcdGZvciAodmFyIGk9MCxsPWFyci5sZW5ndGg7IGk8bDsgaSsrKSB7XHJcblx0XHRcdGlmIChhcnJbaV0gPT0gbGlzdGVuZXIpIHtcclxuXHRcdFx0XHRpZiAobD09MSkgeyBkZWxldGUobGlzdGVuZXJzW3R5cGVdKTsgfSAvLyBhbGxvd3MgZm9yIGZhc3RlciBjaGVja3MuXHJcblx0XHRcdFx0ZWxzZSB7IGFyci5zcGxpY2UoaSwxKTsgfVxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBBIHNob3J0Y3V0IHRvIHRoZSByZW1vdmVFdmVudExpc3RlbmVyIG1ldGhvZCwgd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFuZCByZXR1cm4gdmFsdWUuIFRoaXMgaXMgYSBjb21wYW5pb24gdG8gdGhlXHJcblx0ICogLm9uIG1ldGhvZC5cclxuXHQgKiBcclxuXHQgKiA8Yj5JTVBPUlRBTlQ6PC9iPiBUbyByZW1vdmUgYSBsaXN0ZW5lciBhZGRlZCB3aXRoIGBvbmAsIHlvdSBtdXN0IHBhc3MgaW4gdGhlIHJldHVybmVkIHdyYXBwZXIgZnVuY3Rpb24gYXMgdGhlIGxpc3RlbmVyLiBTZWUgXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL29uXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhbiBleGFtcGxlLlxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBvZmZcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb24gfCBPYmplY3R9IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiBvciBvYmplY3QuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZV0gRm9yIGV2ZW50cyB0aGF0IGJ1YmJsZSwgaW5kaWNhdGVzIHdoZXRoZXIgdG8gbGlzdGVuIGZvciB0aGUgZXZlbnQgaW4gdGhlIGNhcHR1cmUgb3IgYnViYmxpbmcvdGFyZ2V0IHBoYXNlLlxyXG5cdCAqKi9cclxuXHRwLm9mZiA9IHAucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgc3BlY2lmaWVkIHR5cGUsIG9yIGFsbCBsaXN0ZW5lcnMgb2YgYWxsIHR5cGVzLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVyc1xyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5yZW1vdmVBbGxFdmVudExpc3RlbmVycygpO1xyXG5cdCAqXHJcblx0ICogICAgICAvLyBSZW1vdmUgYWxsIGNsaWNrIGxpc3RlbmVyc1xyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5yZW1vdmVBbGxFdmVudExpc3RlbmVycyhcImNsaWNrXCIpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCByZW1vdmVBbGxFdmVudExpc3RlbmVyc1xyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC4gSWYgb21pdHRlZCwgYWxsIGxpc3RlbmVycyBmb3IgYWxsIHR5cGVzIHdpbGwgYmUgcmVtb3ZlZC5cclxuXHQgKiovXHJcblx0cC5yZW1vdmVBbGxFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdGlmICghdHlwZSkgeyB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzID0gbnVsbDsgfVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGlmICh0aGlzLl9saXN0ZW5lcnMpIHsgZGVsZXRlKHRoaXMuX2xpc3RlbmVyc1t0eXBlXSk7IH1cclxuXHRcdFx0aWYgKHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMpIHsgZGVsZXRlKHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnNbdHlwZV0pOyB9XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogRGlzcGF0Y2hlcyB0aGUgc3BlY2lmaWVkIGV2ZW50IHRvIGFsbCBsaXN0ZW5lcnMuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIC8vIFVzZSBhIHN0cmluZyBldmVudFxyXG5cdCAqICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiY29tcGxldGVcIik7XHJcblx0ICpcclxuXHQgKiAgICAgIC8vIFVzZSBhbiBFdmVudCBpbnN0YW5jZVxyXG5cdCAqICAgICAgdmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwicHJvZ3Jlc3NcIik7XHJcblx0ICogICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBkaXNwYXRjaEV2ZW50XHJcblx0ICogQHBhcmFtIHtPYmplY3QgfCBTdHJpbmcgfCBFdmVudH0gZXZlbnRPYmogQW4gb2JqZWN0IHdpdGggYSBcInR5cGVcIiBwcm9wZXJ0eSwgb3IgYSBzdHJpbmcgdHlwZS5cclxuXHQgKiBXaGlsZSBhIGdlbmVyaWMgb2JqZWN0IHdpbGwgd29yaywgaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIGEgQ3JlYXRlSlMgRXZlbnQgaW5zdGFuY2UuIElmIGEgc3RyaW5nIGlzIHVzZWQsXHJcblx0ICogZGlzcGF0Y2hFdmVudCB3aWxsIGNvbnN0cnVjdCBhbiBFdmVudCBpbnN0YW5jZSBpZiBuZWNlc3Nhcnkgd2l0aCB0aGUgc3BlY2lmaWVkIHR5cGUuIFRoaXMgbGF0dGVyIGFwcHJvYWNoIGNhblxyXG5cdCAqIGJlIHVzZWQgdG8gYXZvaWQgZXZlbnQgb2JqZWN0IGluc3RhbnRpYXRpb24gZm9yIG5vbi1idWJibGluZyBldmVudHMgdGhhdCBtYXkgbm90IGhhdmUgYW55IGxpc3RlbmVycy5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtidWJibGVzXSBTcGVjaWZpZXMgdGhlIGBidWJibGVzYCB2YWx1ZSB3aGVuIGEgc3RyaW5nIHdhcyBwYXNzZWQgdG8gZXZlbnRPYmouXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbY2FuY2VsYWJsZV0gU3BlY2lmaWVzIHRoZSBgY2FuY2VsYWJsZWAgdmFsdWUgd2hlbiBhIHN0cmluZyB3YXMgcGFzc2VkIHRvIGV2ZW50T2JqLlxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgZmFsc2UgaWYgYHByZXZlbnREZWZhdWx0KClgIHdhcyBjYWxsZWQgb24gYSBjYW5jZWxhYmxlIGV2ZW50LCB0cnVlIG90aGVyd2lzZS5cclxuXHQgKiovXHJcblx0cC5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnRPYmosIGJ1YmJsZXMsIGNhbmNlbGFibGUpIHtcclxuXHRcdGlmICh0eXBlb2YgZXZlbnRPYmogPT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHQvLyBza2lwIGV2ZXJ5dGhpbmcgaWYgdGhlcmUncyBubyBsaXN0ZW5lcnMgYW5kIGl0IGRvZXNuJ3QgYnViYmxlOlxyXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG5cdFx0XHRpZiAoIWJ1YmJsZXMgJiYgKCFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVyc1tldmVudE9ial0pKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcdGV2ZW50T2JqID0gbmV3IGNyZWF0ZWpzLkV2ZW50KGV2ZW50T2JqLCBidWJibGVzLCBjYW5jZWxhYmxlKTtcclxuXHRcdH0gZWxzZSBpZiAoZXZlbnRPYmoudGFyZ2V0ICYmIGV2ZW50T2JqLmNsb25lKSB7XHJcblx0XHRcdC8vIHJlZGlzcGF0Y2hpbmcgYW4gYWN0aXZlIGV2ZW50IG9iamVjdCwgc28gY2xvbmUgaXQ6XHJcblx0XHRcdGV2ZW50T2JqID0gZXZlbnRPYmouY2xvbmUoKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Ly8gVE9ETzogaXQgd291bGQgYmUgbmljZSB0byBlbGltaW5hdGUgdGhpcy4gTWF5YmUgaW4gZmF2b3VyIG9mIGV2dE9iaiBpbnN0YW5jZW9mIEV2ZW50PyBPciAhIWV2dE9iai5jcmVhdGVFdmVudFxyXG5cdFx0dHJ5IHsgZXZlbnRPYmoudGFyZ2V0ID0gdGhpczsgfSBjYXRjaCAoZSkge30gLy8gdHJ5L2NhdGNoIGFsbG93cyByZWRpc3BhdGNoaW5nIG9mIG5hdGl2ZSBldmVudHNcclxuXHJcblx0XHRpZiAoIWV2ZW50T2JqLmJ1YmJsZXMgfHwgIXRoaXMucGFyZW50KSB7XHJcblx0XHRcdHRoaXMuX2Rpc3BhdGNoRXZlbnQoZXZlbnRPYmosIDIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHRvcD10aGlzLCBsaXN0PVt0b3BdO1xyXG5cdFx0XHR3aGlsZSAodG9wLnBhcmVudCkgeyBsaXN0LnB1c2godG9wID0gdG9wLnBhcmVudCk7IH1cclxuXHRcdFx0dmFyIGksIGw9bGlzdC5sZW5ndGg7XHJcblxyXG5cdFx0XHQvLyBjYXB0dXJlICYgYXRUYXJnZXRcclxuXHRcdFx0Zm9yIChpPWwtMTsgaT49MCAmJiAhZXZlbnRPYmoucHJvcGFnYXRpb25TdG9wcGVkOyBpLS0pIHtcclxuXHRcdFx0XHRsaXN0W2ldLl9kaXNwYXRjaEV2ZW50KGV2ZW50T2JqLCAxKyhpPT0wKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gYnViYmxpbmdcclxuXHRcdFx0Zm9yIChpPTE7IGk8bCAmJiAhZXZlbnRPYmoucHJvcGFnYXRpb25TdG9wcGVkOyBpKyspIHtcclxuXHRcdFx0XHRsaXN0W2ldLl9kaXNwYXRjaEV2ZW50KGV2ZW50T2JqLCAzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuICFldmVudE9iai5kZWZhdWx0UHJldmVudGVkO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudCB0eXBlLlxyXG5cdCAqIEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lclxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cclxuXHQgKiovXHJcblx0cC5oYXNFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycywgY2FwdHVyZUxpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnM7XHJcblx0XHRyZXR1cm4gISEoKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnNbdHlwZV0pIHx8IChjYXB0dXJlTGlzdGVuZXJzICYmIGNhcHR1cmVMaXN0ZW5lcnNbdHlwZV0pKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudCB0eXBlIG9uIHRoaXMgb2JqZWN0IG9yIGFueSBvZiBpdHNcclxuXHQgKiBhbmNlc3RvcnMgKHBhcmVudCwgcGFyZW50J3MgcGFyZW50LCBldGMpLiBBIHJldHVybiB2YWx1ZSBvZiB0cnVlIGluZGljYXRlcyB0aGF0IGlmIGEgYnViYmxpbmcgZXZlbnQgb2YgdGhlXHJcblx0ICogc3BlY2lmaWVkIHR5cGUgaXMgZGlzcGF0Y2hlZCBmcm9tIHRoaXMgb2JqZWN0LCBpdCB3aWxsIHRyaWdnZXIgYXQgbGVhc3Qgb25lIGxpc3RlbmVyLlxyXG5cdCAqIFxyXG5cdCAqIFRoaXMgaXMgc2ltaWxhciB0byB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvaGFzRXZlbnRMaXN0ZW5lclwifX17ey9jcm9zc0xpbmt9fSwgYnV0IGl0IHNlYXJjaGVzIHRoZSBlbnRpcmVcclxuXHQgKiBldmVudCBmbG93IGZvciBhIGxpc3RlbmVyLCBub3QganVzdCB0aGlzIG9iamVjdC5cclxuXHQgKiBAbWV0aG9kIHdpbGxUcmlnZ2VyXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXHJcblx0ICoqL1xyXG5cdHAud2lsbFRyaWdnZXIgPSBmdW5jdGlvbih0eXBlKSB7XHJcblx0XHR2YXIgbyA9IHRoaXM7XHJcblx0XHR3aGlsZSAobykge1xyXG5cdFx0XHRpZiAoby5oYXNFdmVudExpc3RlbmVyKHR5cGUpKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcdG8gPSBvLnBhcmVudDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXHJcblx0ICoqL1xyXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBcIltFdmVudERpc3BhdGNoZXJdXCI7XHJcblx0fTtcclxuXHJcblxyXG4vLyBwcml2YXRlIG1ldGhvZHM6XHJcblx0LyoqXHJcblx0ICogQG1ldGhvZCBfZGlzcGF0Y2hFdmVudFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0IHwgU3RyaW5nIHwgRXZlbnR9IGV2ZW50T2JqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50UGhhc2VcclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICoqL1xyXG5cdHAuX2Rpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudE9iaiwgZXZlbnRQaGFzZSkge1xyXG5cdFx0dmFyIGwsIGxpc3RlbmVycyA9IChldmVudFBoYXNlPT0xKSA/IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgOiB0aGlzLl9saXN0ZW5lcnM7XHJcblx0XHRpZiAoZXZlbnRPYmogJiYgbGlzdGVuZXJzKSB7XHJcblx0XHRcdHZhciBhcnIgPSBsaXN0ZW5lcnNbZXZlbnRPYmoudHlwZV07XHJcblx0XHRcdGlmICghYXJyfHwhKGw9YXJyLmxlbmd0aCkpIHsgcmV0dXJuOyB9XHJcblx0XHRcdHRyeSB7IGV2ZW50T2JqLmN1cnJlbnRUYXJnZXQgPSB0aGlzOyB9IGNhdGNoIChlKSB7fVxyXG5cdFx0XHR0cnkgeyBldmVudE9iai5ldmVudFBoYXNlID0gZXZlbnRQaGFzZTsgfSBjYXRjaCAoZSkge31cclxuXHRcdFx0ZXZlbnRPYmoucmVtb3ZlZCA9IGZhbHNlO1xyXG5cdFx0XHRcclxuXHRcdFx0YXJyID0gYXJyLnNsaWNlKCk7IC8vIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGl0ZW1zIGJlaW5nIHJlbW92ZWQgb3IgYWRkZWQgZHVyaW5nIHRoZSBkaXNwYXRjaFxyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bCAmJiAhZXZlbnRPYmouaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgbyA9IGFycltpXTtcclxuXHRcdFx0XHRpZiAoby5oYW5kbGVFdmVudCkgeyBvLmhhbmRsZUV2ZW50KGV2ZW50T2JqKTsgfVxyXG5cdFx0XHRcdGVsc2UgeyBvKGV2ZW50T2JqKTsgfVxyXG5cdFx0XHRcdGlmIChldmVudE9iai5yZW1vdmVkKSB7XHJcblx0XHRcdFx0XHR0aGlzLm9mZihldmVudE9iai50eXBlLCBvLCBldmVudFBoYXNlPT0xKTtcclxuXHRcdFx0XHRcdGV2ZW50T2JqLnJlbW92ZWQgPSBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHJcblx0Y3JlYXRlanMuRXZlbnREaXNwYXRjaGVyID0gRXZlbnREaXNwYXRjaGVyO1xyXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVGlja2VyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBUaGUgVGlja2VyIHByb3ZpZGVzIGEgY2VudHJhbGl6ZWQgdGljayBvciBoZWFydGJlYXQgYnJvYWRjYXN0IGF0IGEgc2V0IGludGVydmFsLiBMaXN0ZW5lcnMgY2FuIHN1YnNjcmliZSB0byB0aGUgdGlja1xuXHQgKiBldmVudCB0byBiZSBub3RpZmllZCB3aGVuIGEgc2V0IHRpbWUgaW50ZXJ2YWwgaGFzIGVsYXBzZWQuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgaW50ZXJ2YWwgdGhhdCB0aGUgdGljayBldmVudCBpcyBjYWxsZWQgaXMgYSB0YXJnZXQgaW50ZXJ2YWwsIGFuZCBtYXkgYmUgYnJvYWRjYXN0IGF0IGEgc2xvd2VyIGludGVydmFsXG5cdCAqIHdoZW4gdW5kZXIgaGlnaCBDUFUgbG9hZC4gVGhlIFRpY2tlciBjbGFzcyB1c2VzIGEgc3RhdGljIGludGVyZmFjZSAoZXguIGBUaWNrZXIuZnJhbWVyYXRlID0gMzA7YCkgYW5kXG5cdCAqIGNhbiBub3QgYmUgaW5zdGFudGlhdGVkLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIGhhbmRsZVRpY2spO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZVRpY2soZXZlbnQpIHtcblx0ICogICAgICAgICAgLy8gQWN0aW9ucyBjYXJyaWVkIG91dCBlYWNoIHRpY2sgKGFrYSBmcmFtZSlcblx0ICogICAgICAgICAgaWYgKCFldmVudC5wYXVzZWQpIHtcblx0ICogICAgICAgICAgICAgIC8vIEFjdGlvbnMgY2FycmllZCBvdXQgd2hlbiB0aGUgVGlja2VyIGlzIG5vdCBwYXVzZWQuXG5cdCAqICAgICAgICAgIH1cblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBjbGFzcyBUaWNrZXJcblx0ICogQHVzZXMgRXZlbnREaXNwYXRjaGVyXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRmdW5jdGlvbiBUaWNrZXIoKSB7XG5cdFx0dGhyb3cgXCJUaWNrZXIgY2Fubm90IGJlIGluc3RhbnRpYXRlZC5cIjtcblx0fVxuXG5cbi8vIGNvbnN0YW50czpcblx0LyoqXG5cdCAqIEluIHRoaXMgbW9kZSwgVGlja2VyIHVzZXMgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBBUEksIGJ1dCBhdHRlbXB0cyB0byBzeW5jaCB0aGUgdGlja3MgdG8gdGFyZ2V0IGZyYW1lcmF0ZS4gSXRcblx0ICogdXNlcyBhIHNpbXBsZSBoZXVyaXN0aWMgdGhhdCBjb21wYXJlcyB0aGUgdGltZSBvZiB0aGUgUkFGIHJldHVybiB0byB0aGUgdGFyZ2V0IHRpbWUgZm9yIHRoZSBjdXJyZW50IGZyYW1lIGFuZFxuXHQgKiBkaXNwYXRjaGVzIHRoZSB0aWNrIHdoZW4gdGhlIHRpbWUgaXMgd2l0aGluIGEgY2VydGFpbiB0aHJlc2hvbGQuXG5cdCAqXG5cdCAqIFRoaXMgbW9kZSBoYXMgYSBoaWdoZXIgdmFyaWFuY2UgZm9yIHRpbWUgYmV0d2VlbiBmcmFtZXMgdGhhbiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvVElNRU9VVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogYnV0IGRvZXMgbm90IHJlcXVpcmUgdGhhdCBjb250ZW50IGJlIHRpbWUgYmFzZWQgYXMgd2l0aCB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvUkFGOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHdoaWxlXG5cdCAqIGdhaW5pbmcgdGhlIGJlbmVmaXRzIG9mIHRoYXQgQVBJIChzY3JlZW4gc3luY2gsIGJhY2tncm91bmQgdGhyb3R0bGluZykuXG5cdCAqXG5cdCAqIFZhcmlhbmNlIGlzIHVzdWFsbHkgbG93ZXN0IGZvciBmcmFtZXJhdGVzIHRoYXQgYXJlIGEgZGl2aXNvciBvZiB0aGUgUkFGIGZyZXF1ZW5jeS4gVGhpcyBpcyB1c3VhbGx5IDYwLCBzb1xuXHQgKiBmcmFtZXJhdGVzIG9mIDEwLCAxMiwgMTUsIDIwLCBhbmQgMzAgd29yayB3ZWxsLlxuXHQgKlxuXHQgKiBGYWxscyBiYWNrIHRvIHt7I2Nyb3NzTGluayBcIlRpY2tlci9USU1FT1VUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlmIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgQVBJIGlzIG5vdFxuXHQgKiBzdXBwb3J0ZWQuXG5cdCAqIEBwcm9wZXJ0eSBSQUZfU1lOQ0hFRFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IFwic3luY2hlZFwiXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdFRpY2tlci5SQUZfU1lOQ0hFRCA9IFwic3luY2hlZFwiO1xuXG5cdC8qKlxuXHQgKiBJbiB0aGlzIG1vZGUsIFRpY2tlciBwYXNzZXMgdGhyb3VnaCB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGhlYXJ0YmVhdCwgaWdub3JpbmcgdGhlIHRhcmdldCBmcmFtZXJhdGUgY29tcGxldGVseS5cblx0ICogQmVjYXVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZnJlcXVlbmN5IGlzIG5vdCBkZXRlcm1pbmlzdGljLCBhbnkgY29udGVudCB1c2luZyB0aGlzIG1vZGUgc2hvdWxkIGJlIHRpbWUgYmFzZWQuXG5cdCAqIFlvdSBjYW4gbGV2ZXJhZ2Uge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2dldFRpbWVcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBvYmplY3QncyBcImRlbHRhXCIgcHJvcGVydGllcyB0byBtYWtlIHRoaXMgZWFzaWVyLlxuXHQgKlxuXHQgKiBGYWxscyBiYWNrIG9uIHt7I2Nyb3NzTGluayBcIlRpY2tlci9USU1FT1VUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlmIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgQVBJIGlzIG5vdFxuXHQgKiBzdXBwb3J0ZWQuXG5cdCAqIEBwcm9wZXJ0eSBSQUZcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBcInJhZlwiXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdFRpY2tlci5SQUYgPSBcInJhZlwiO1xuXG5cdC8qKlxuXHQgKiBJbiB0aGlzIG1vZGUsIFRpY2tlciB1c2VzIHRoZSBzZXRUaW1lb3V0IEFQSS4gVGhpcyBwcm92aWRlcyBwcmVkaWN0YWJsZSwgYWRhcHRpdmUgZnJhbWUgdGltaW5nLCBidXQgZG9lcyBub3Rcblx0ICogcHJvdmlkZSB0aGUgYmVuZWZpdHMgb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIChzY3JlZW4gc3luY2gsIGJhY2tncm91bmQgdGhyb3R0bGluZykuXG5cdCAqIEBwcm9wZXJ0eSBUSU1FT1VUXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgXCJ0aW1lb3V0XCJcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0VGlja2VyLlRJTUVPVVQgPSBcInRpbWVvdXRcIjtcblxuXG4vLyBzdGF0aWMgZXZlbnRzOlxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCBlYWNoIHRpY2suIFRoZSBldmVudCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gZWFjaCBsaXN0ZW5lciBldmVuIHdoZW4gdGhlIFRpY2tlciBoYXMgYmVlbiBwYXVzZWQgdXNpbmdcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3NldFBhdXNlZFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLlRpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBoYW5kbGVUaWNrKTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVUaWNrKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKFwiUGF1c2VkOlwiLCBldmVudC5wYXVzZWQsIGV2ZW50LmRlbHRhKTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBldmVudCB0aWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBwYXVzZWQgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRpY2tlciBpcyBjdXJyZW50bHkgcGF1c2VkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgVGhlIHRpbWUgZWxhcHNlZCBpbiBtcyBzaW5jZSB0aGUgbGFzdCB0aWNrLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgdG90YWwgdGltZSBpbiBtcyBzaW5jZSBUaWNrZXIgd2FzIGluaXRpYWxpemVkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcnVuVGltZSBUaGUgdG90YWwgdGltZSBpbiBtcyB0aGF0IFRpY2tlciB3YXMgbm90IHBhdXNlZCBzaW5jZSBpdCB3YXMgaW5pdGlhbGl6ZWQuIEZvciBleGFtcGxlLFxuXHQgKiBcdHlvdSBjb3VsZCBkZXRlcm1pbmUgdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgdGhlIFRpY2tlciBoYXMgYmVlbiBwYXVzZWQgc2luY2UgaW5pdGlhbGl6YXRpb24gd2l0aCBgdGltZS1ydW5UaW1lYC5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cbi8vIHB1YmxpYyBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIERlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aW1pbmdNb2RlXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uIElmIHRydWUsIHRpbWluZ01vZGUgd2lsbFxuXHQgKiB1c2Uge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1JBRl9TWU5DSEVEXCJ9fXt7L2Nyb3NzTGlua319IGJ5IGRlZmF1bHQuXG5cdCAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aW1pbmdNb2RlXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAcHJvcGVydHkgdXNlUkFGXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqKi9cblx0VGlja2VyLnVzZVJBRiA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpZXMgdGhlIHRpbWluZyBhcGkgKHNldFRpbWVvdXQgb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSBhbmQgbW9kZSB0byB1c2UuIFNlZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvVElNRU9VVFwifX17ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1JBRlwifX17ey9jcm9zc0xpbmt9fSwgYW5kXG5cdCAqIHt7I2Nyb3NzTGluayBcIlRpY2tlci9SQUZfU1lOQ0hFRFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9kZSBkZXRhaWxzLlxuXHQgKiBAcHJvcGVydHkgdGltaW5nTW9kZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IFRpY2tlci5USU1FT1VUXG5cdCAqKi9cblx0VGlja2VyLnRpbWluZ01vZGUgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpZXMgYSBtYXhpbXVtIHZhbHVlIGZvciB0aGUgZGVsdGEgcHJvcGVydHkgaW4gdGhlIHRpY2sgZXZlbnQgb2JqZWN0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGJ1aWxkaW5nIHRpbWVcblx0ICogYmFzZWQgYW5pbWF0aW9ucyBhbmQgc3lzdGVtcyB0byBwcmV2ZW50IGlzc3VlcyBjYXVzZWQgYnkgbGFyZ2UgdGltZSBnYXBzIGNhdXNlZCBieSBiYWNrZ3JvdW5kIHRhYnMsIHN5c3RlbSBzbGVlcCxcblx0ICogYWxlcnQgZGlhbG9ncywgb3Igb3RoZXIgYmxvY2tpbmcgcm91dGluZXMuIERvdWJsZSB0aGUgZXhwZWN0ZWQgZnJhbWUgZHVyYXRpb24gaXMgb2Z0ZW4gYW4gZWZmZWN0aXZlIHZhbHVlXG5cdCAqIChleC4gbWF4RGVsdGE9NTAgd2hlbiBydW5uaW5nIGF0IDQwZnBzKS5cblx0ICogXG5cdCAqIFRoaXMgZG9lcyBub3QgaW1wYWN0IGFueSBvdGhlciB2YWx1ZXMgKGV4LiB0aW1lLCBydW5UaW1lLCBldGMpLCBzbyB5b3UgbWF5IGV4cGVyaWVuY2UgaXNzdWVzIGlmIHlvdSBlbmFibGUgbWF4RGVsdGFcblx0ICogd2hlbiB1c2luZyBib3RoIGRlbHRhIGFuZCBvdGhlciB2YWx1ZXMuXG5cdCAqIFxuXHQgKiBJZiAwLCB0aGVyZSBpcyBubyBtYXhpbXVtLlxuXHQgKiBAcHJvcGVydHkgbWF4RGVsdGFcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAwXG5cdCAqL1xuXHRUaWNrZXIubWF4RGVsdGEgPSAwO1xuXHRcblx0LyoqXG5cdCAqIFdoZW4gdGhlIHRpY2tlciBpcyBwYXVzZWQsIGFsbCBsaXN0ZW5lcnMgd2lsbCBzdGlsbCByZWNlaXZlIGEgdGljayBldmVudCwgYnV0IHRoZSA8Y29kZT5wYXVzZWQ8L2NvZGU+IHByb3BlcnR5XG5cdCAqIG9mIHRoZSBldmVudCB3aWxsIGJlIGB0cnVlYC4gQWxzbywgd2hpbGUgcGF1c2VkIHRoZSBgcnVuVGltZWAgd2lsbCBub3QgaW5jcmVhc2UuIFNlZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fSxcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2dldFRpbWVcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvZ2V0RXZlbnRUaW1lXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlXG5cdCAqIGluZm8uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgaGFuZGxlVGljayk7XG5cdCAqICAgICAgY3JlYXRlanMuVGlja2VyLnBhdXNlZCA9IHRydWU7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlVGljayhldmVudCkge1xuXHQgKiAgICAgICAgICBjb25zb2xlLmxvZyhldmVudC5wYXVzZWQsXG5cdCAqICAgICAgICAgIFx0Y3JlYXRlanMuVGlja2VyLmdldFRpbWUoZmFsc2UpLFxuXHQgKiAgICAgICAgICBcdGNyZWF0ZWpzLlRpY2tlci5nZXRUaW1lKHRydWUpKTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBwYXVzZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICoqL1xuXHRUaWNrZXIucGF1c2VkID0gZmFsc2U7XG5cblxuLy8gbWl4LWluczpcblx0Ly8gRXZlbnREaXNwYXRjaGVyIG1ldGhvZHM6XG5cdFRpY2tlci5yZW1vdmVFdmVudExpc3RlbmVyID0gbnVsbDtcblx0VGlja2VyLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gbnVsbDtcblx0VGlja2VyLmRpc3BhdGNoRXZlbnQgPSBudWxsO1xuXHRUaWNrZXIuaGFzRXZlbnRMaXN0ZW5lciA9IG51bGw7XG5cdFRpY2tlci5fbGlzdGVuZXJzID0gbnVsbDtcblx0Y3JlYXRlanMuRXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUoVGlja2VyKTsgLy8gaW5qZWN0IEV2ZW50RGlzcGF0Y2hlciBtZXRob2RzLlxuXHRUaWNrZXIuX2FkZEV2ZW50TGlzdGVuZXIgPSBUaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcjtcblx0VGlja2VyLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcblx0XHQhVGlja2VyLl9pbml0ZWQmJlRpY2tlci5pbml0KCk7XG5cdFx0cmV0dXJuIFRpY2tlci5fYWRkRXZlbnRMaXN0ZW5lci5hcHBseShUaWNrZXIsIGFyZ3VtZW50cyk7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfaW5pdGVkXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX2luaXRlZCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3N0YXJ0VGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3N0YXJ0VGltZSA9IDA7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfcGF1c2VkVGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3BhdXNlZFRpbWU9MDtcblxuXHQvKipcblx0ICogVGhlIG51bWJlciBvZiB0aWNrcyB0aGF0IGhhdmUgcGFzc2VkXG5cdCAqIEBwcm9wZXJ0eSBfdGlja3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aWNrcyA9IDA7XG5cblx0LyoqXG5cdCAqIFRoZSBudW1iZXIgb2YgdGlja3MgdGhhdCBoYXZlIHBhc3NlZCB3aGlsZSBUaWNrZXIgaGFzIGJlZW4gcGF1c2VkXG5cdCAqIEBwcm9wZXJ0eSBfcGF1c2VkVGlja3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9wYXVzZWRUaWNrcyA9IDA7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfaW50ZXJ2YWxcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9pbnRlcnZhbCA9IDUwO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX2xhc3RUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fbGFzdFRpbWUgPSAwO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3RpbWVzXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aW1lcyA9IG51bGw7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfdGlja1RpbWVzXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aWNrVGltZXMgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBTdG9yZXMgdGhlIHRpbWVvdXQgb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGlkLlxuXHQgKiBAcHJvcGVydHkgX3RpbWVySWRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aW1lcklkID0gbnVsbDtcblx0XG5cdC8qKlxuXHQgKiBUcnVlIGlmIGN1cnJlbnRseSB1c2luZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGZhbHNlIGlmIHVzaW5nIHNldFRpbWVvdXQuIFRoaXMgbWF5IGJlIGRpZmZlcmVudCB0aGFuIHRpbWluZ01vZGVcblx0ICogaWYgdGhhdCBwcm9wZXJ0eSBjaGFuZ2VkIGFuZCBhIHRpY2sgaGFzbid0IGZpcmVkLlxuXHQgKiBAcHJvcGVydHkgX3JhZlxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9yYWYgPSB0cnVlO1xuXHRcblxuLy8gc3RhdGljIGdldHRlciAvIHNldHRlcnM6XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9pbnRlcnZhbDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIHNldEludGVydmFsXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGludGVydmFsXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLnNldEludGVydmFsID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcblx0XHRUaWNrZXIuX2ludGVydmFsID0gaW50ZXJ2YWw7XG5cdFx0aWYgKCFUaWNrZXIuX2luaXRlZCkgeyByZXR1cm47IH1cblx0XHRUaWNrZXIuX3NldHVwVGljaygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9pbnRlcnZhbDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldEludGVydmFsXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdFRpY2tlci5nZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBUaWNrZXIuX2ludGVydmFsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9mcmFtZXJhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBzZXRGUFNcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuc2V0RlBTID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRUaWNrZXIuc2V0SW50ZXJ2YWwoMTAwMC92YWx1ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2ZyYW1lcmF0ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldEZQU1xuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuZ2V0RlBTID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIDEwMDAvVGlja2VyLl9pbnRlcnZhbDtcblx0fTtcblxuXHQvKipcblx0ICogSW5kaWNhdGVzIHRoZSB0YXJnZXQgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSBiZXR3ZWVuIHRpY2tzLiBEZWZhdWx0IGlzIDUwICgyMCBGUFMpLlxuXHQgKiBOb3RlIHRoYXQgYWN0dWFsIHRpbWUgYmV0d2VlbiB0aWNrcyBtYXkgYmUgbW9yZSB0aGFuIHNwZWNpZmllZCBkZXBlbmRpbmcgb24gQ1BVIGxvYWQuXG5cdCAqIFRoaXMgcHJvcGVydHkgaXMgaWdub3JlZCBpZiB0aGUgdGlja2VyIGlzIHVzaW5nIHRoZSBgUkFGYCB0aW1pbmcgbW9kZS5cblx0ICogQHByb3BlcnR5IGludGVydmFsXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICoqL1xuXHQgXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgdGhlIHRhcmdldCBmcmFtZSByYXRlIGluIGZyYW1lcyBwZXIgc2Vjb25kIChGUFMpLiBFZmZlY3RpdmVseSBqdXN0IGEgc2hvcnRjdXQgdG8gYGludGVydmFsYCwgd2hlcmVcblx0ICogYGZyYW1lcmF0ZSA9PSAxMDAwL2ludGVydmFsYC5cblx0ICogQHByb3BlcnR5IGZyYW1lcmF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqKi9cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhUaWNrZXIsIHtcblx0XHRcdGludGVydmFsOiB7IGdldDogVGlja2VyLmdldEludGVydmFsLCBzZXQ6IFRpY2tlci5zZXRJbnRlcnZhbCB9LFxuXHRcdFx0ZnJhbWVyYXRlOiB7IGdldDogVGlja2VyLmdldEZQUywgc2V0OiBUaWNrZXIuc2V0RlBTIH1cblx0XHR9KTtcblx0fSBjYXRjaCAoZSkgeyBjb25zb2xlLmxvZyhlKTsgfVxuXG5cbi8vIHB1YmxpYyBzdGF0aWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFN0YXJ0cyB0aGUgdGljay4gVGhpcyBpcyBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBmaXJzdCBsaXN0ZW5lciBpcyBhZGRlZC5cblx0ICogQG1ldGhvZCBpbml0XG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUaWNrZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChUaWNrZXIuX2luaXRlZCkgeyByZXR1cm47IH1cblx0XHRUaWNrZXIuX2luaXRlZCA9IHRydWU7XG5cdFx0VGlja2VyLl90aW1lcyA9IFtdO1xuXHRcdFRpY2tlci5fdGlja1RpbWVzID0gW107XG5cdFx0VGlja2VyLl9zdGFydFRpbWUgPSBUaWNrZXIuX2dldFRpbWUoKTtcblx0XHRUaWNrZXIuX3RpbWVzLnB1c2goVGlja2VyLl9sYXN0VGltZSA9IDApO1xuXHRcdFRpY2tlci5pbnRlcnZhbCA9IFRpY2tlci5faW50ZXJ2YWw7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU3RvcHMgdGhlIFRpY2tlciBhbmQgcmVtb3ZlcyBhbGwgbGlzdGVuZXJzLiBVc2UgaW5pdCgpIHRvIHJlc3RhcnQgdGhlIFRpY2tlci5cblx0ICogQG1ldGhvZCByZXNldFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VGlja2VyLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKFRpY2tlci5fcmFmKSB7XG5cdFx0XHR2YXIgZiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5vQ2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cdFx0XHRmJiZmKFRpY2tlci5fdGltZXJJZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNsZWFyVGltZW91dChUaWNrZXIuX3RpbWVySWQpO1xuXHRcdH1cblx0XHRUaWNrZXIucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoXCJ0aWNrXCIpO1xuXHRcdFRpY2tlci5fdGltZXJJZCA9IFRpY2tlci5fdGltZXMgPSBUaWNrZXIuX3RpY2tUaW1lcyA9IG51bGw7XG5cdFx0VGlja2VyLl9zdGFydFRpbWUgPSBUaWNrZXIuX2xhc3RUaW1lID0gVGlja2VyLl90aWNrcyA9IDA7XG5cdFx0VGlja2VyLl9pbml0ZWQgPSBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYXZlcmFnZSB0aW1lIHNwZW50IHdpdGhpbiBhIHRpY2suIFRoaXMgY2FuIHZhcnkgc2lnbmlmaWNhbnRseSBmcm9tIHRoZSB2YWx1ZSBwcm92aWRlZCBieSBnZXRNZWFzdXJlZEZQU1xuXHQgKiBiZWNhdXNlIGl0IG9ubHkgbWVhc3VyZXMgdGhlIHRpbWUgc3BlbnQgd2l0aGluIHRoZSB0aWNrIGV4ZWN1dGlvbiBzdGFjay4gXG5cdCAqIFxuXHQgKiBFeGFtcGxlIDE6IFdpdGggYSB0YXJnZXQgRlBTIG9mIDIwLCBnZXRNZWFzdXJlZEZQUygpIHJldHVybnMgMjBmcHMsIHdoaWNoIGluZGljYXRlcyBhbiBhdmVyYWdlIG9mIDUwbXMgYmV0d2VlbiBcblx0ICogdGhlIGVuZCBvZiBvbmUgdGljayBhbmQgdGhlIGVuZCBvZiB0aGUgbmV4dC4gSG93ZXZlciwgZ2V0TWVhc3VyZWRUaWNrVGltZSgpIHJldHVybnMgMTVtcy4gVGhpcyBpbmRpY2F0ZXMgdGhhdCBcblx0ICogdGhlcmUgbWF5IGJlIHVwIHRvIDM1bXMgb2YgXCJpZGxlXCIgdGltZSBiZXR3ZWVuIHRoZSBlbmQgb2Ygb25lIHRpY2sgYW5kIHRoZSBzdGFydCBvZiB0aGUgbmV4dC5cblx0ICpcblx0ICogRXhhbXBsZSAyOiBXaXRoIGEgdGFyZ2V0IEZQUyBvZiAzMCwgZ2V0RlBTKCkgcmV0dXJucyAxMGZwcywgd2hpY2ggaW5kaWNhdGVzIGFuIGF2ZXJhZ2Ugb2YgMTAwbXMgYmV0d2VlbiB0aGUgZW5kIG9mXG5cdCAqIG9uZSB0aWNrIGFuZCB0aGUgZW5kIG9mIHRoZSBuZXh0LiBIb3dldmVyLCBnZXRNZWFzdXJlZFRpY2tUaW1lKCkgcmV0dXJucyAyMG1zLiBUaGlzIHdvdWxkIGluZGljYXRlIHRoYXQgc29tZXRoaW5nXG5cdCAqIG90aGVyIHRoYW4gdGhlIHRpY2sgaXMgdXNpbmcgfjgwbXMgKGFub3RoZXIgc2NyaXB0LCBET00gcmVuZGVyaW5nLCBldGMpLlxuXHQgKiBAbWV0aG9kIGdldE1lYXN1cmVkVGlja1RpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RpY2tzXSBUaGUgbnVtYmVyIG9mIHByZXZpb3VzIHRpY2tzIG92ZXIgd2hpY2ggdG8gbWVhc3VyZSB0aGUgYXZlcmFnZSB0aW1lIHNwZW50IGluIGEgdGljay5cblx0ICogRGVmYXVsdHMgdG8gdGhlIG51bWJlciBvZiB0aWNrcyBwZXIgc2Vjb25kLiBUbyBnZXQgb25seSB0aGUgbGFzdCB0aWNrJ3MgdGltZSwgcGFzcyBpbiAxLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBhdmVyYWdlIHRpbWUgc3BlbnQgaW4gYSB0aWNrIGluIG1pbGxpc2Vjb25kcy5cblx0ICoqL1xuXHRUaWNrZXIuZ2V0TWVhc3VyZWRUaWNrVGltZSA9IGZ1bmN0aW9uKHRpY2tzKSB7XG5cdFx0dmFyIHR0bD0wLCB0aW1lcz1UaWNrZXIuX3RpY2tUaW1lcztcblx0XHRpZiAoIXRpbWVzIHx8IHRpbWVzLmxlbmd0aCA8IDEpIHsgcmV0dXJuIC0xOyB9XG5cblx0XHQvLyBieSBkZWZhdWx0LCBjYWxjdWxhdGUgYXZlcmFnZSBmb3IgdGhlIHBhc3QgfjEgc2Vjb25kOlxuXHRcdHRpY2tzID0gTWF0aC5taW4odGltZXMubGVuZ3RoLCB0aWNrc3x8KFRpY2tlci5nZXRGUFMoKXwwKSk7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPHRpY2tzOyBpKyspIHsgdHRsICs9IHRpbWVzW2ldOyB9XG5cdFx0cmV0dXJuIHR0bC90aWNrcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYWN0dWFsIGZyYW1lcyAvIHRpY2tzIHBlciBzZWNvbmQuXG5cdCAqIEBtZXRob2QgZ2V0TWVhc3VyZWRGUFNcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RpY2tzXSBUaGUgbnVtYmVyIG9mIHByZXZpb3VzIHRpY2tzIG92ZXIgd2hpY2ggdG8gbWVhc3VyZSB0aGUgYWN0dWFsIGZyYW1lcyAvIHRpY2tzIHBlciBzZWNvbmQuXG5cdCAqIERlZmF1bHRzIHRvIHRoZSBudW1iZXIgb2YgdGlja3MgcGVyIHNlY29uZC5cblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgYWN0dWFsIGZyYW1lcyAvIHRpY2tzIHBlciBzZWNvbmQuIERlcGVuZGluZyBvbiBwZXJmb3JtYW5jZSwgdGhpcyBtYXkgZGlmZmVyXG5cdCAqIGZyb20gdGhlIHRhcmdldCBmcmFtZXMgcGVyIHNlY29uZC5cblx0ICoqL1xuXHRUaWNrZXIuZ2V0TWVhc3VyZWRGUFMgPSBmdW5jdGlvbih0aWNrcykge1xuXHRcdHZhciB0aW1lcyA9IFRpY2tlci5fdGltZXM7XG5cdFx0aWYgKCF0aW1lcyB8fCB0aW1lcy5sZW5ndGggPCAyKSB7IHJldHVybiAtMTsgfVxuXG5cdFx0Ly8gYnkgZGVmYXVsdCwgY2FsY3VsYXRlIGZwcyBmb3IgdGhlIHBhc3QgfjEgc2Vjb25kOlxuXHRcdHRpY2tzID0gTWF0aC5taW4odGltZXMubGVuZ3RoLTEsIHRpY2tzfHwoVGlja2VyLmdldEZQUygpfDApKTtcblx0XHRyZXR1cm4gMTAwMC8oKHRpbWVzWzBdLXRpbWVzW3RpY2tzXSkvdGlja3MpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9wYXVzZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBzZXRQYXVzZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLnNldFBhdXNlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0Ly8gVE9ETzogZGVwcmVjYXRlZC5cblx0XHRUaWNrZXIucGF1c2VkID0gdmFsdWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3BhdXNlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldFBhdXNlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLmdldFBhdXNlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFRPRE86IGRlcHJlY2F0ZWQuXG5cdFx0cmV0dXJuIFRpY2tlci5wYXVzZWQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2UgVGlja2VyIHdhcyBpbml0aWFsaXplZCB2aWEge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2luaXRcIn19LlxuXHQgKiBSZXR1cm5zIC0xIGlmIFRpY2tlciBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQuIEZvciBleGFtcGxlLCB5b3UgY291bGQgdXNlXG5cdCAqIHRoaXMgaW4gYSB0aW1lIHN5bmNocm9uaXplZCBhbmltYXRpb24gdG8gZGV0ZXJtaW5lIHRoZSBleGFjdCBhbW91bnQgb2YgdGltZSB0aGF0IGhhcyBlbGFwc2VkLlxuXHQgKiBAbWV0aG9kIGdldFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtydW5UaW1lPWZhbHNlXSBJZiB0cnVlIG9ubHkgdGltZSBlbGFwc2VkIHdoaWxlIFRpY2tlciB3YXMgbm90IHBhdXNlZCB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBJZiBmYWxzZSwgdGhlIHZhbHVlIHJldHVybmVkIHdpbGwgYmUgdG90YWwgdGltZSBlbGFwc2VkIHNpbmNlIHRoZSBmaXJzdCB0aWNrIGV2ZW50IGxpc3RlbmVyIHdhcyBhZGRlZC5cblx0ICogQHJldHVybiB7TnVtYmVyfSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlIFRpY2tlciB3YXMgaW5pdGlhbGl6ZWQgb3IgLTEuXG5cdCAqKi9cblx0VGlja2VyLmdldFRpbWUgPSBmdW5jdGlvbihydW5UaW1lKSB7XG5cdFx0cmV0dXJuIFRpY2tlci5fc3RhcnRUaW1lID8gVGlja2VyLl9nZXRUaW1lKCkgLSAocnVuVGltZSA/IFRpY2tlci5fcGF1c2VkVGltZSA6IDApIDogLTE7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNpbWlsYXIgdG8gdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9nZXRUaW1lXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCwgYnV0IHJldHVybnMgdGhlIHRpbWUgb24gdGhlIG1vc3QgcmVjZW50IHt7I2Nyb3NzTGluayBcIlRpY2tlci90aWNrOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IG9iamVjdC5cblx0ICogQG1ldGhvZCBnZXRFdmVudFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0gcnVuVGltZSB7Qm9vbGVhbn0gW3J1blRpbWU9ZmFsc2VdIElmIHRydWUsIHRoZSBydW5UaW1lIHByb3BlcnR5IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiB0aW1lLlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgdGltZSBvciBydW5UaW1lIHByb3BlcnR5IGZyb20gdGhlIG1vc3QgcmVjZW50IHRpY2sgZXZlbnQgb3IgLTEuXG5cdCAqL1xuXHRUaWNrZXIuZ2V0RXZlbnRUaW1lID0gZnVuY3Rpb24ocnVuVGltZSkge1xuXHRcdHJldHVybiBUaWNrZXIuX3N0YXJ0VGltZSA/IChUaWNrZXIuX2xhc3RUaW1lIHx8IFRpY2tlci5fc3RhcnRUaW1lKSAtIChydW5UaW1lID8gVGlja2VyLl9wYXVzZWRUaW1lIDogMCkgOiAtMTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGlja3MgdGhhdCBoYXZlIGJlZW4gYnJvYWRjYXN0IGJ5IFRpY2tlci5cblx0ICogQG1ldGhvZCBnZXRUaWNrc1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcGF1c2VhYmxlIEluZGljYXRlcyB3aGV0aGVyIHRvIGluY2x1ZGUgdGlja3MgdGhhdCB3b3VsZCBoYXZlIGJlZW4gYnJvYWRjYXN0XG5cdCAqIHdoaWxlIFRpY2tlciB3YXMgcGF1c2VkLiBJZiB0cnVlIG9ubHkgdGljayBldmVudHMgYnJvYWRjYXN0IHdoaWxlIFRpY2tlciBpcyBub3QgcGF1c2VkIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIElmIGZhbHNlLCB0aWNrIGV2ZW50cyB0aGF0IHdvdWxkIGhhdmUgYmVlbiBicm9hZGNhc3Qgd2hpbGUgVGlja2VyIHdhcyBwYXVzZWQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcmV0dXJuXG5cdCAqIHZhbHVlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBmYWxzZS5cblx0ICogQHJldHVybiB7TnVtYmVyfSBvZiB0aWNrcyB0aGF0IGhhdmUgYmVlbiBicm9hZGNhc3QuXG5cdCAqKi9cblx0VGlja2VyLmdldFRpY2tzID0gZnVuY3Rpb24ocGF1c2VhYmxlKSB7XG5cdFx0cmV0dXJuICBUaWNrZXIuX3RpY2tzIC0gKHBhdXNlYWJsZSA/IFRpY2tlci5fcGF1c2VkVGlja3MgOiAwKTtcblx0fTtcblxuXG4vLyBwcml2YXRlIHN0YXRpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlU3luY2hcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9oYW5kbGVTeW5jaCA9IGZ1bmN0aW9uKCkge1xuXHRcdFRpY2tlci5fdGltZXJJZCA9IG51bGw7XG5cdFx0VGlja2VyLl9zZXR1cFRpY2soKTtcblxuXHRcdC8vIHJ1biBpZiBlbm91Z2ggdGltZSBoYXMgZWxhcHNlZCwgd2l0aCBhIGxpdHRsZSBiaXQgb2YgZmxleGliaWxpdHkgdG8gYmUgZWFybHk6XG5cdFx0aWYgKFRpY2tlci5fZ2V0VGltZSgpIC0gVGlja2VyLl9sYXN0VGltZSA+PSAoVGlja2VyLl9pbnRlcnZhbC0xKSowLjk3KSB7XG5cdFx0XHRUaWNrZXIuX3RpY2soKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVJBRlxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX2hhbmRsZVJBRiA9IGZ1bmN0aW9uKCkge1xuXHRcdFRpY2tlci5fdGltZXJJZCA9IG51bGw7XG5cdFx0VGlja2VyLl9zZXR1cFRpY2soKTtcblx0XHRUaWNrZXIuX3RpY2soKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlVGltZW91dFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX2hhbmRsZVRpbWVvdXQgPSBmdW5jdGlvbigpIHtcblx0XHRUaWNrZXIuX3RpbWVySWQgPSBudWxsO1xuXHRcdFRpY2tlci5fc2V0dXBUaWNrKCk7XG5cdFx0VGlja2VyLl90aWNrKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3NldHVwVGlja1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3NldHVwVGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChUaWNrZXIuX3RpbWVySWQgIT0gbnVsbCkgeyByZXR1cm47IH0gLy8gYXZvaWQgZHVwbGljYXRlc1xuXG5cdFx0dmFyIG1vZGUgPSBUaWNrZXIudGltaW5nTW9kZXx8KFRpY2tlci51c2VSQUYmJlRpY2tlci5SQUZfU1lOQ0hFRCk7XG5cdFx0aWYgKG1vZGUgPT0gVGlja2VyLlJBRl9TWU5DSEVEIHx8IG1vZGUgPT0gVGlja2VyLlJBRikge1xuXHRcdFx0dmFyIGYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0XHRpZiAoZikge1xuXHRcdFx0XHRUaWNrZXIuX3RpbWVySWQgPSBmKG1vZGUgPT0gVGlja2VyLlJBRiA/IFRpY2tlci5faGFuZGxlUkFGIDogVGlja2VyLl9oYW5kbGVTeW5jaCk7XG5cdFx0XHRcdFRpY2tlci5fcmFmID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRUaWNrZXIuX3JhZiA9IGZhbHNlO1xuXHRcdFRpY2tlci5fdGltZXJJZCA9IHNldFRpbWVvdXQoVGlja2VyLl9oYW5kbGVUaW1lb3V0LCBUaWNrZXIuX2ludGVydmFsKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfdGlja1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3RpY2sgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGF1c2VkID0gVGlja2VyLnBhdXNlZDtcblx0XHR2YXIgdGltZSA9IFRpY2tlci5fZ2V0VGltZSgpO1xuXHRcdHZhciBlbGFwc2VkVGltZSA9IHRpbWUtVGlja2VyLl9sYXN0VGltZTtcblx0XHRUaWNrZXIuX2xhc3RUaW1lID0gdGltZTtcblx0XHRUaWNrZXIuX3RpY2tzKys7XG5cdFx0XG5cdFx0aWYgKHBhdXNlZCkge1xuXHRcdFx0VGlja2VyLl9wYXVzZWRUaWNrcysrO1xuXHRcdFx0VGlja2VyLl9wYXVzZWRUaW1lICs9IGVsYXBzZWRUaW1lO1xuXHRcdH1cblx0XHRcblx0XHRpZiAoVGlja2VyLmhhc0V2ZW50TGlzdGVuZXIoXCJ0aWNrXCIpKSB7XG5cdFx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJ0aWNrXCIpO1xuXHRcdFx0dmFyIG1heERlbHRhID0gVGlja2VyLm1heERlbHRhO1xuXHRcdFx0ZXZlbnQuZGVsdGEgPSAobWF4RGVsdGEgJiYgZWxhcHNlZFRpbWUgPiBtYXhEZWx0YSkgPyBtYXhEZWx0YSA6IGVsYXBzZWRUaW1lO1xuXHRcdFx0ZXZlbnQucGF1c2VkID0gcGF1c2VkO1xuXHRcdFx0ZXZlbnQudGltZSA9IHRpbWU7XG5cdFx0XHRldmVudC5ydW5UaW1lID0gdGltZS1UaWNrZXIuX3BhdXNlZFRpbWU7XG5cdFx0XHRUaWNrZXIuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdFx0fVxuXHRcdFxuXHRcdFRpY2tlci5fdGlja1RpbWVzLnVuc2hpZnQoVGlja2VyLl9nZXRUaW1lKCktdGltZSk7XG5cdFx0d2hpbGUgKFRpY2tlci5fdGlja1RpbWVzLmxlbmd0aCA+IDEwMCkgeyBUaWNrZXIuX3RpY2tUaW1lcy5wb3AoKTsgfVxuXG5cdFx0VGlja2VyLl90aW1lcy51bnNoaWZ0KHRpbWUpO1xuXHRcdHdoaWxlIChUaWNrZXIuX3RpbWVzLmxlbmd0aCA+IDEwMCkgeyBUaWNrZXIuX3RpbWVzLnBvcCgpOyB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0dmFyIG5vdyA9IHdpbmRvdy5wZXJmb3JtYW5jZSAmJiAocGVyZm9ybWFuY2Uubm93IHx8IHBlcmZvcm1hbmNlLm1vek5vdyB8fCBwZXJmb3JtYW5jZS5tc05vdyB8fCBwZXJmb3JtYW5jZS5vTm93IHx8IHBlcmZvcm1hbmNlLndlYmtpdE5vdyk7XG5cdFRpY2tlci5fZ2V0VGltZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAoKG5vdyYmbm93LmNhbGwocGVyZm9ybWFuY2UpKXx8KG5ldyBEYXRlKCkuZ2V0VGltZSgpKSkgLSBUaWNrZXIuX3N0YXJ0VGltZTtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLlRpY2tlciA9IFRpY2tlcjtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBVSUQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEdsb2JhbCB1dGlsaXR5IGZvciBnZW5lcmF0aW5nIHNlcXVlbnRpYWwgdW5pcXVlIElEIG51bWJlcnMuIFRoZSBVSUQgY2xhc3MgdXNlcyBhIHN0YXRpYyBpbnRlcmZhY2UgKGV4LiA8Y29kZT5VSUQuZ2V0KCk8L2NvZGU+KVxuXHQgKiBhbmQgc2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQuXG5cdCAqIEBjbGFzcyBVSURcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdGZ1bmN0aW9uIFVJRCgpIHtcblx0XHR0aHJvdyBcIlVJRCBjYW5ub3QgYmUgaW5zdGFudGlhdGVkXCI7XG5cdH1cblxuXG4vLyBwcml2YXRlIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQHByb3BlcnR5IF9uZXh0SURcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRVSUQuX25leHRJRCA9IDA7XG5cblxuLy8gcHVibGljIHN0YXRpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbmV4dCB1bmlxdWUgaWQuXG5cdCAqIEBtZXRob2QgZ2V0XG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIG5leHQgdW5pcXVlIGlkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRVSUQuZ2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFVJRC5fbmV4dElEKys7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5VSUQgPSBVSUQ7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gTW91c2VFdmVudC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogUGFzc2VkIGFzIHRoZSBwYXJhbWV0ZXIgdG8gYWxsIG1vdXNlL3BvaW50ZXIvdG91Y2ggcmVsYXRlZCBldmVudHMuIEZvciBhIGxpc3Rpbmcgb2YgbW91c2UgZXZlbnRzIGFuZCB0aGVpciBwcm9wZXJ0aWVzLFxuXHQgKiBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3RcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGxpc3RpbmdzLlxuXHQgKiBAY2xhc3MgTW91c2VFdmVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBidWJibGVzIEluZGljYXRlcyB3aGV0aGVyIHRoZSBldmVudCB3aWxsIGJ1YmJsZSB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FuY2VsYWJsZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdGhpcyBldmVudCBjYW4gYmUgY2FuY2VsbGVkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhZ2VYIFRoZSBub3JtYWxpemVkIHggcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHN0YWdlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhZ2VZIFRoZSBub3JtYWxpemVkIHkgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHN0YWdlLlxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IG5hdGl2ZUV2ZW50IFRoZSBuYXRpdmUgRE9NIGV2ZW50IHJlbGF0ZWQgdG8gdGhpcyBtb3VzZSBldmVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50ZXJJRCBUaGUgdW5pcXVlIGlkIGZvciB0aGUgcG9pbnRlci5cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmltYXJ5IEluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgdGhlIHByaW1hcnkgcG9pbnRlciBpbiBhIG11bHRpdG91Y2ggZW52aXJvbm1lbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYXdYIFRoZSByYXcgeCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhZ2UuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYXdZIFRoZSByYXcgeSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhZ2UuXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gcmVsYXRlZFRhcmdldCBUaGUgc2Vjb25kYXJ5IHRhcmdldCBmb3IgdGhlIGV2ZW50LlxuXHQgKiBAZXh0ZW5kcyBFdmVudFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBNb3VzZUV2ZW50KHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUsIHN0YWdlWCwgc3RhZ2VZLCBuYXRpdmVFdmVudCwgcG9pbnRlcklELCBwcmltYXJ5LCByYXdYLCByYXdZLCByZWxhdGVkVGFyZ2V0KSB7XG5cdFx0dGhpcy5FdmVudF9jb25zdHJ1Y3Rvcih0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlKTtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIG5vcm1hbGl6ZWQgeCBwb3NpdGlvbiBvbiB0aGUgc3RhZ2UuIFRoaXMgd2lsbCBhbHdheXMgYmUgd2l0aGluIHRoZSByYW5nZSAwIHRvIHN0YWdlIHdpZHRoLlxuXHRcdCAqIEBwcm9wZXJ0eSBzdGFnZVhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQqL1xuXHRcdHRoaXMuc3RhZ2VYID0gc3RhZ2VYO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgbm9ybWFsaXplZCB5IHBvc2l0aW9uIG9uIHRoZSBzdGFnZS4gVGhpcyB3aWxsIGFsd2F5cyBiZSB3aXRoaW4gdGhlIHJhbmdlIDAgdG8gc3RhZ2UgaGVpZ2h0LlxuXHRcdCAqIEBwcm9wZXJ0eSBzdGFnZVlcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5zdGFnZVkgPSBzdGFnZVk7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSByYXcgeCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhZ2UuIE5vcm1hbGx5IHRoaXMgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgc3RhZ2VYIHZhbHVlLCB1bmxlc3Ncblx0XHQgKiBzdGFnZS5tb3VzZU1vdmVPdXRzaWRlIGlzIHRydWUgYW5kIHRoZSBwb2ludGVyIGlzIG91dHNpZGUgb2YgdGhlIHN0YWdlIGJvdW5kcy5cblx0XHQgKiBAcHJvcGVydHkgcmF3WFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCovXG5cdFx0dGhpcy5yYXdYID0gKHJhd1g9PW51bGwpP3N0YWdlWDpyYXdYO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgcmF3IHkgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHN0YWdlLiBOb3JtYWxseSB0aGlzIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIHN0YWdlWSB2YWx1ZSwgdW5sZXNzXG5cdFx0ICogc3RhZ2UubW91c2VNb3ZlT3V0c2lkZSBpcyB0cnVlIGFuZCB0aGUgcG9pbnRlciBpcyBvdXRzaWRlIG9mIHRoZSBzdGFnZSBib3VuZHMuXG5cdFx0ICogQHByb3BlcnR5IHJhd1lcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQqL1xuXHRcdHRoaXMucmF3WSA9IChyYXdZPT1udWxsKT9zdGFnZVk6cmF3WTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIG5hdGl2ZSBNb3VzZUV2ZW50IGdlbmVyYXRlZCBieSB0aGUgYnJvd3Nlci4gVGhlIHByb3BlcnRpZXMgYW5kIEFQSSBmb3IgdGhpc1xuXHRcdCAqIGV2ZW50IG1heSBkaWZmZXIgYmV0d2VlbiBicm93c2Vycy4gVGhpcyBwcm9wZXJ0eSB3aWxsIGJlIG51bGwgaWYgdGhlXG5cdFx0ICogRWFzZWxKUyBwcm9wZXJ0eSB3YXMgbm90IGRpcmVjdGx5IGdlbmVyYXRlZCBmcm9tIGEgbmF0aXZlIE1vdXNlRXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IG5hdGl2ZUV2ZW50XG5cdFx0ICogQHR5cGUgSHRtbE1vdXNlRXZlbnRcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHVuaXF1ZSBpZCBmb3IgdGhlIHBvaW50ZXIgKHRvdWNoIHBvaW50IG9yIGN1cnNvcikuIFRoaXMgd2lsbCBiZSBlaXRoZXIgLTEgZm9yIHRoZSBtb3VzZSwgb3IgdGhlIHN5c3RlbVxuXHRcdCAqIHN1cHBsaWVkIGlkIHZhbHVlLlxuXHRcdCAqIEBwcm9wZXJ0eSBwb2ludGVySURcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMucG9pbnRlcklEID0gcG9pbnRlcklEO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIHRoZSBwcmltYXJ5IHBvaW50ZXIgaW4gYSBtdWx0aXRvdWNoIGVudmlyb25tZW50LiBUaGlzIHdpbGwgYWx3YXlzIGJlIHRydWUgZm9yIHRoZSBtb3VzZS5cblx0XHQgKiBGb3IgdG91Y2ggcG9pbnRlcnMsIHRoZSBmaXJzdCBwb2ludGVyIGluIHRoZSBjdXJyZW50IHN0YWNrIHdpbGwgYmUgY29uc2lkZXJlZCB0aGUgcHJpbWFyeSBwb2ludGVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBwcmltYXJ5XG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICovXG5cdFx0dGhpcy5wcmltYXJ5ID0gISFwcmltYXJ5O1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBzZWNvbmRhcnkgdGFyZ2V0IGZvciB0aGUgZXZlbnQsIGlmIGFwcGxpY2FibGUuIFRoaXMgaXMgdXNlZCBmb3IgbW91c2VvdXQvcm9sbG91dFxuXHRcdCAqIGV2ZW50cyB0byBpbmRpY2F0ZSB0aGUgb2JqZWN0IHRoYXQgdGhlIG1vdXNlIGVudGVyZWQgZnJvbSwgbW91c2VvdmVyL3JvbGxvdmVyIGZvciB0aGUgb2JqZWN0IHRoZSBtb3VzZSBleGl0ZWQsXG5cdFx0ICogYW5kIHN0YWdlbW91c2Vkb3duL3N0YWdlbW91c2V1cCBldmVudHMgZm9yIHRoZSBvYmplY3QgdGhhdCB3YXMgdGhlIHVuZGVyIHRoZSBjdXJzb3IsIGlmIGFueS5cblx0XHQgKiBcblx0XHQgKiBPbmx5IHZhbGlkIGludGVyYWN0aW9uIHRhcmdldHMgd2lsbCBiZSByZXR1cm5lZCAoaWUuIG9iamVjdHMgd2l0aCBtb3VzZSBsaXN0ZW5lcnMgb3IgYSBjdXJzb3Igc2V0KS5cblx0XHQgKiBAcHJvcGVydHkgcmVsYXRlZFRhcmdldFxuXHRcdCAqIEB0eXBlIHtEaXNwbGF5T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHJlbGF0ZWRUYXJnZXQ7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoTW91c2VFdmVudCwgY3JlYXRlanMuRXZlbnQpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXHRcblx0XG4vLyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgeCBwb3NpdGlvbiBvZiB0aGUgbW91c2UgaW4gdGhlIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtIG9mIHRoZSBjdXJyZW50IHRhcmdldCAoaWUuIHRoZSBkaXNwYXRjaGVyKS5cblx0ICogQHByb3BlcnR5IGxvY2FsWFxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcmVhZG9ubHlcblx0ICovXG5cdHAuX2dldF9sb2NhbFggPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jdXJyZW50VGFyZ2V0Lmdsb2JhbFRvTG9jYWwodGhpcy5yYXdYLCB0aGlzLnJhd1kpLng7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgeSBwb3NpdGlvbiBvZiB0aGUgbW91c2UgaW4gdGhlIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtIG9mIHRoZSBjdXJyZW50IHRhcmdldCAoaWUuIHRoZSBkaXNwYXRjaGVyKS5cblx0ICogQHByb3BlcnR5IGxvY2FsWVxuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcmVhZG9ubHlcblx0ICovXG5cdHAuX2dldF9sb2NhbFkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jdXJyZW50VGFyZ2V0Lmdsb2JhbFRvTG9jYWwodGhpcy5yYXdYLCB0aGlzLnJhd1kpLnk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IHdhcyBnZW5lcmF0ZWQgYnkgYSB0b3VjaCBpbnB1dCAodmVyc3VzIGEgbW91c2UgaW5wdXQpLlxuXHQgKiBAcHJvcGVydHkgaXNUb3VjaFxuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQHJlYWRvbmx5XG5cdCAqL1xuXHRwLl9nZXRfaXNUb3VjaCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnBvaW50ZXJJRCAhPT0gLTE7XG5cdH07XG5cdFxuXHRcblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cdFx0XHRsb2NhbFg6IHsgZ2V0OiBwLl9nZXRfbG9jYWxYIH0sXG5cdFx0XHRsb2NhbFk6IHsgZ2V0OiBwLl9nZXRfbG9jYWxZIH0sXG5cdFx0XHRpc1RvdWNoOiB7IGdldDogcC5fZ2V0X2lzVG91Y2ggfVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlKSB7fSAvLyBUT0RPOiB1c2UgTG9nXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIE1vdXNlRXZlbnQgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7TW91c2VFdmVudH0gYSBjbG9uZSBvZiB0aGUgTW91c2VFdmVudCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBNb3VzZUV2ZW50KHRoaXMudHlwZSwgdGhpcy5idWJibGVzLCB0aGlzLmNhbmNlbGFibGUsIHRoaXMuc3RhZ2VYLCB0aGlzLnN0YWdlWSwgdGhpcy5uYXRpdmVFdmVudCwgdGhpcy5wb2ludGVySUQsIHRoaXMucHJpbWFyeSwgdGhpcy5yYXdYLCB0aGlzLnJhd1kpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbTW91c2VFdmVudCAodHlwZT1cIit0aGlzLnR5cGUrXCIgc3RhZ2VYPVwiK3RoaXMuc3RhZ2VYK1wiIHN0YWdlWT1cIit0aGlzLnN0YWdlWStcIildXCI7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5Nb3VzZUV2ZW50ID0gY3JlYXRlanMucHJvbW90ZShNb3VzZUV2ZW50LCBcIkV2ZW50XCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIE1hdHJpeDJELmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBSZXByZXNlbnRzIGFuIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXgsIGFuZCBwcm92aWRlcyB0b29scyBmb3IgY29uc3RydWN0aW5nIGFuZCBjb25jYXRlbmF0aW5nIG1hdHJpY2VzLlxuXHQgKlxuXHQgKiBUaGlzIG1hdHJpeCBjYW4gYmUgdmlzdWFsaXplZCBhczpcblx0ICpcblx0ICogXHRbIGEgIGMgIHR4XG5cdCAqIFx0ICBiICBkICB0eVxuXHQgKiBcdCAgMCAgMCAgMSAgXVxuXHQgKlxuXHQgKiBOb3RlIHRoZSBsb2NhdGlvbnMgb2YgYiBhbmQgYy5cblx0ICpcblx0ICogQGNsYXNzIE1hdHJpeDJEXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYT0xXSBTcGVjaWZpZXMgdGhlIGEgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2I9MF0gU3BlY2lmaWVzIHRoZSBiIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtjPTBdIFNwZWNpZmllcyB0aGUgYyBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZD0xXSBTcGVjaWZpZXMgdGhlIGQgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3R4PTBdIFNwZWNpZmllcyB0aGUgdHggcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3R5PTBdIFNwZWNpZmllcyB0aGUgdHkgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBNYXRyaXgyRChhLCBiLCBjLCBkLCB0eCwgdHkpIHtcblx0XHR0aGlzLnNldFZhbHVlcyhhLGIsYyxkLHR4LHR5KTtcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0Ly8gYXNzaWduZWQgaW4gdGhlIHNldFZhbHVlcyBtZXRob2QuXG5cdFx0LyoqXG5cdFx0ICogUG9zaXRpb24gKDAsIDApIGluIGEgM3gzIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG5cdFx0ICogQHByb3BlcnR5IGFcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uICgwLCAxKSBpbiBhIDN4MyBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuXHRcdCAqIEBwcm9wZXJ0eSBiXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBQb3NpdGlvbiAoMSwgMCkgaW4gYSAzeDMgYWZmaW5lIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0XHQgKiBAcHJvcGVydHkgY1xuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogUG9zaXRpb24gKDEsIDEpIGluIGEgM3gzIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG5cdFx0ICogQHByb3BlcnR5IGRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uICgyLCAwKSBpbiBhIDN4MyBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuXHRcdCAqIEBwcm9wZXJ0eSB0eFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogUG9zaXRpb24gKDIsIDEpIGluIGEgM3gzIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG5cdFx0ICogQHByb3BlcnR5IHR5XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHR9XG5cdHZhciBwID0gTWF0cml4MkQucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBjb25zdGFudHM6XG5cdC8qKlxuXHQgKiBNdWx0aXBsaWVyIGZvciBjb252ZXJ0aW5nIGRlZ3JlZXMgdG8gcmFkaWFucy4gVXNlZCBpbnRlcm5hbGx5IGJ5IE1hdHJpeDJELlxuXHQgKiBAcHJvcGVydHkgREVHX1RPX1JBRFxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0TWF0cml4MkQuREVHX1RPX1JBRCA9IE1hdGguUEkvMTgwO1xuXG5cbi8vIHN0YXRpYyBwdWJsaWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIEFuIGlkZW50aXR5IG1hdHJpeCwgcmVwcmVzZW50aW5nIGEgbnVsbCB0cmFuc2Zvcm1hdGlvbi5cblx0ICogQHByb3BlcnR5IGlkZW50aXR5XG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUgTWF0cml4MkRcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0TWF0cml4MkQuaWRlbnRpdHkgPSBudWxsOyAvLyBzZXQgYXQgYm90dG9tIG9mIGNsYXNzIGRlZmluaXRpb24uXG5cdFxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFNldHMgdGhlIHNwZWNpZmllZCB2YWx1ZXMgb24gdGhpcyBpbnN0YW5jZS4gXG5cdCAqIEBtZXRob2Qgc2V0VmFsdWVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYT0xXSBTcGVjaWZpZXMgdGhlIGEgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2I9MF0gU3BlY2lmaWVzIHRoZSBiIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtjPTBdIFNwZWNpZmllcyB0aGUgYyBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZD0xXSBTcGVjaWZpZXMgdGhlIGQgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3R4PTBdIFNwZWNpZmllcyB0aGUgdHggcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3R5PTBdIFNwZWNpZmllcyB0aGUgdHkgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCovXG5cdHAuc2V0VmFsdWVzID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgdHgsIHR5KSB7XG5cdFx0Ly8gZG9uJ3QgZm9yZ2V0IHRvIHVwZGF0ZSBkb2NzIGluIHRoZSBjb25zdHJ1Y3RvciBpZiB0aGVzZSBjaGFuZ2U6XG5cdFx0dGhpcy5hID0gKGEgPT0gbnVsbCkgPyAxIDogYTtcblx0XHR0aGlzLmIgPSBiIHx8IDA7XG5cdFx0dGhpcy5jID0gYyB8fCAwO1xuXHRcdHRoaXMuZCA9IChkID09IG51bGwpID8gMSA6IGQ7XG5cdFx0dGhpcy50eCA9IHR4IHx8IDA7XG5cdFx0dGhpcy50eSA9IHR5IHx8IDA7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFwcGVuZHMgdGhlIHNwZWNpZmllZCBtYXRyaXggcHJvcGVydGllcyB0byB0aGlzIG1hdHJpeC4gQWxsIHBhcmFtZXRlcnMgYXJlIHJlcXVpcmVkLlxuXHQgKiBUaGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIG11bHRpcGx5aW5nIGAodGhpcyBtYXRyaXgpICogKHNwZWNpZmllZCBtYXRyaXgpYC5cblx0ICogQG1ldGhvZCBhcHBlbmRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHR4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0eVxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAuYXBwZW5kID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgdHgsIHR5KSB7XG5cdFx0dmFyIGExID0gdGhpcy5hO1xuXHRcdHZhciBiMSA9IHRoaXMuYjtcblx0XHR2YXIgYzEgPSB0aGlzLmM7XG5cdFx0dmFyIGQxID0gdGhpcy5kO1xuXHRcdGlmIChhICE9IDEgfHwgYiAhPSAwIHx8IGMgIT0gMCB8fCBkICE9IDEpIHtcblx0XHRcdHRoaXMuYSAgPSBhMSphK2MxKmI7XG5cdFx0XHR0aGlzLmIgID0gYjEqYStkMSpiO1xuXHRcdFx0dGhpcy5jICA9IGExKmMrYzEqZDtcblx0XHRcdHRoaXMuZCAgPSBiMSpjK2QxKmQ7XG5cdFx0fVxuXHRcdHRoaXMudHggPSBhMSp0eCtjMSp0eSt0aGlzLnR4O1xuXHRcdHRoaXMudHkgPSBiMSp0eCtkMSp0eSt0aGlzLnR5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcmVwZW5kcyB0aGUgc3BlY2lmaWVkIG1hdHJpeCBwcm9wZXJ0aWVzIHRvIHRoaXMgbWF0cml4LlxuXHQgKiBUaGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIG11bHRpcGx5aW5nIGAoc3BlY2lmaWVkIG1hdHJpeCkgKiAodGhpcyBtYXRyaXgpYC5cblx0ICogQWxsIHBhcmFtZXRlcnMgYXJlIHJlcXVpcmVkLlxuXHQgKiBAbWV0aG9kIHByZXBlbmRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHR4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0eVxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAucHJlcGVuZCA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuXHRcdHZhciBhMSA9IHRoaXMuYTtcblx0XHR2YXIgYzEgPSB0aGlzLmM7XG5cdFx0dmFyIHR4MSA9IHRoaXMudHg7XG5cblx0XHR0aGlzLmEgID0gYSphMStjKnRoaXMuYjtcblx0XHR0aGlzLmIgID0gYiphMStkKnRoaXMuYjtcblx0XHR0aGlzLmMgID0gYSpjMStjKnRoaXMuZDtcblx0XHR0aGlzLmQgID0gYipjMStkKnRoaXMuZDtcblx0XHR0aGlzLnR4ID0gYSp0eDErYyp0aGlzLnR5K3R4O1xuXHRcdHRoaXMudHkgPSBiKnR4MStkKnRoaXMudHkrdHk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFwcGVuZHMgdGhlIHNwZWNpZmllZCBtYXRyaXggdG8gdGhpcyBtYXRyaXguXG5cdCAqIFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgbXVsdGlwbHlpbmcgYCh0aGlzIG1hdHJpeCkgKiAoc3BlY2lmaWVkIG1hdHJpeClgLlxuXHQgKiBAbWV0aG9kIGFwcGVuZE1hdHJpeFxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXhcblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLmFwcGVuZE1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChtYXRyaXguYSwgbWF0cml4LmIsIG1hdHJpeC5jLCBtYXRyaXguZCwgbWF0cml4LnR4LCBtYXRyaXgudHkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcmVwZW5kcyB0aGUgc3BlY2lmaWVkIG1hdHJpeCB0byB0aGlzIG1hdHJpeC5cblx0ICogVGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiBtdWx0aXBseWluZyBgKHNwZWNpZmllZCBtYXRyaXgpICogKHRoaXMgbWF0cml4KWAuXG5cdCAqIEZvciBleGFtcGxlLCB5b3UgY291bGQgY2FsY3VsYXRlIHRoZSBjb21iaW5lZCB0cmFuc2Zvcm1hdGlvbiBmb3IgYSBjaGlsZCBvYmplY3QgdXNpbmc6XG5cdCAqIFxuXHQgKiBcdHZhciBvID0gbXlEaXNwbGF5T2JqZWN0O1xuXHQgKiBcdHZhciBtdHggPSBvLmdldE1hdHJpeCgpO1xuXHQgKiBcdHdoaWxlIChvID0gby5wYXJlbnQpIHtcblx0ICogXHRcdC8vIHByZXBlbmQgZWFjaCBwYXJlbnQncyB0cmFuc2Zvcm1hdGlvbiBpbiB0dXJuOlxuXHQgKiBcdFx0by5wcmVwZW5kTWF0cml4KG8uZ2V0TWF0cml4KCkpO1xuXHQgKiBcdH1cblx0ICogQG1ldGhvZCBwcmVwZW5kTWF0cml4XG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeFxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAucHJlcGVuZE1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHJldHVybiB0aGlzLnByZXBlbmQobWF0cml4LmEsIG1hdHJpeC5iLCBtYXRyaXguYywgbWF0cml4LmQsIG1hdHJpeC50eCwgbWF0cml4LnR5KTtcblx0fTtcblxuXHQvKipcblx0ICogR2VuZXJhdGVzIG1hdHJpeCBwcm9wZXJ0aWVzIGZyb20gdGhlIHNwZWNpZmllZCBkaXNwbGF5IG9iamVjdCB0cmFuc2Zvcm0gcHJvcGVydGllcywgYW5kIGFwcGVuZHMgdGhlbSB0byB0aGlzIG1hdHJpeC5cblx0ICogRm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlIHRoaXMgdG8gZ2VuZXJhdGUgYSBtYXRyaXggcmVwcmVzZW50aW5nIHRoZSB0cmFuc2Zvcm1hdGlvbnMgb2YgYSBkaXNwbGF5IG9iamVjdDpcblx0ICogXG5cdCAqIFx0dmFyIG10eCA9IG5ldyBNYXRyaXgyRCgpO1xuXHQgKiBcdG10eC5hcHBlbmRUcmFuc2Zvcm0oby54LCBvLnksIG8uc2NhbGVYLCBvLnNjYWxlWSwgby5yb3RhdGlvbik7XG5cdCAqIEBtZXRob2QgYXBwZW5kVHJhbnNmb3JtXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcm90YXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNrZXdYXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBza2V3WVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmVnWCBPcHRpb25hbC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJlZ1kgT3B0aW9uYWwuXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5hcHBlbmRUcmFuc2Zvcm0gPSBmdW5jdGlvbih4LCB5LCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHNrZXdYLCBza2V3WSwgcmVnWCwgcmVnWSkge1xuXHRcdGlmIChyb3RhdGlvbiUzNjApIHtcblx0XHRcdHZhciByID0gcm90YXRpb24qTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdHZhciBjb3MgPSBNYXRoLmNvcyhyKTtcblx0XHRcdHZhciBzaW4gPSBNYXRoLnNpbihyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29zID0gMTtcblx0XHRcdHNpbiA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKHNrZXdYIHx8IHNrZXdZKSB7XG5cdFx0XHQvLyBUT0RPOiBjYW4gdGhpcyBiZSBjb21iaW5lZCBpbnRvIGEgc2luZ2xlIGFwcGVuZCBvcGVyYXRpb24/XG5cdFx0XHRza2V3WCAqPSBNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0c2tld1kgKj0gTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdHRoaXMuYXBwZW5kKE1hdGguY29zKHNrZXdZKSwgTWF0aC5zaW4oc2tld1kpLCAtTWF0aC5zaW4oc2tld1gpLCBNYXRoLmNvcyhza2V3WCksIHgsIHkpO1xuXHRcdFx0dGhpcy5hcHBlbmQoY29zKnNjYWxlWCwgc2luKnNjYWxlWCwgLXNpbipzY2FsZVksIGNvcypzY2FsZVksIDAsIDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmFwcGVuZChjb3Mqc2NhbGVYLCBzaW4qc2NhbGVYLCAtc2luKnNjYWxlWSwgY29zKnNjYWxlWSwgeCwgeSk7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChyZWdYIHx8IHJlZ1kpIHtcblx0XHRcdC8vIGFwcGVuZCB0aGUgcmVnaXN0cmF0aW9uIG9mZnNldDpcblx0XHRcdHRoaXMudHggLT0gcmVnWCp0aGlzLmErcmVnWSp0aGlzLmM7IFxuXHRcdFx0dGhpcy50eSAtPSByZWdYKnRoaXMuYityZWdZKnRoaXMuZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlcyBtYXRyaXggcHJvcGVydGllcyBmcm9tIHRoZSBzcGVjaWZpZWQgZGlzcGxheSBvYmplY3QgdHJhbnNmb3JtIHByb3BlcnRpZXMsIGFuZCBwcmVwZW5kcyB0aGVtIHRvIHRoaXMgbWF0cml4LlxuXHQgKiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIGNhbGN1bGF0ZSB0aGUgY29tYmluZWQgdHJhbnNmb3JtYXRpb24gZm9yIGEgY2hpbGQgb2JqZWN0IHVzaW5nOlxuXHQgKiBcblx0ICogXHR2YXIgbyA9IG15RGlzcGxheU9iamVjdDtcblx0ICogXHR2YXIgbXR4ID0gbmV3IGNyZWF0ZWpzLk1hdHJpeDJEKCk7XG5cdCAqIFx0ZG8gIHtcblx0ICogXHRcdC8vIHByZXBlbmQgZWFjaCBwYXJlbnQncyB0cmFuc2Zvcm1hdGlvbiBpbiB0dXJuOlxuXHQgKiBcdFx0bXR4LnByZXBlbmRUcmFuc2Zvcm0oby54LCBvLnksIG8uc2NhbGVYLCBvLnNjYWxlWSwgby5yb3RhdGlvbiwgby5za2V3WCwgby5za2V3WSwgby5yZWdYLCBvLnJlZ1kpO1xuXHQgKiBcdH0gd2hpbGUgKG8gPSBvLnBhcmVudCk7XG5cdCAqIFx0XG5cdCAqIFx0Tm90ZSB0aGF0IHRoZSBhYm92ZSBleGFtcGxlIHdvdWxkIG5vdCBhY2NvdW50IGZvciB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3RyYW5zZm9ybU1hdHJpeDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBcdHZhbHVlcy4gU2VlIHt7I2Nyb3NzTGluayBcIk1hdHJpeDJEL3ByZXBlbmRNYXRyaXhcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGFuIGV4YW1wbGUgdGhhdCBkb2VzLlxuXHQgKiBAbWV0aG9kIHByZXBlbmRUcmFuc2Zvcm1cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVZXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByb3RhdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2tld1hcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNrZXdZXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByZWdYIE9wdGlvbmFsLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmVnWSBPcHRpb25hbC5cblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLnByZXBlbmRUcmFuc2Zvcm0gPSBmdW5jdGlvbih4LCB5LCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHNrZXdYLCBza2V3WSwgcmVnWCwgcmVnWSkge1xuXHRcdGlmIChyb3RhdGlvbiUzNjApIHtcblx0XHRcdHZhciByID0gcm90YXRpb24qTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdHZhciBjb3MgPSBNYXRoLmNvcyhyKTtcblx0XHRcdHZhciBzaW4gPSBNYXRoLnNpbihyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29zID0gMTtcblx0XHRcdHNpbiA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKHJlZ1ggfHwgcmVnWSkge1xuXHRcdFx0Ly8gcHJlcGVuZCB0aGUgcmVnaXN0cmF0aW9uIG9mZnNldDpcblx0XHRcdHRoaXMudHggLT0gcmVnWDsgdGhpcy50eSAtPSByZWdZO1xuXHRcdH1cblx0XHRpZiAoc2tld1ggfHwgc2tld1kpIHtcblx0XHRcdC8vIFRPRE86IGNhbiB0aGlzIGJlIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgcHJlcGVuZCBvcGVyYXRpb24/XG5cdFx0XHRza2V3WCAqPSBNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0c2tld1kgKj0gTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdHRoaXMucHJlcGVuZChjb3Mqc2NhbGVYLCBzaW4qc2NhbGVYLCAtc2luKnNjYWxlWSwgY29zKnNjYWxlWSwgMCwgMCk7XG5cdFx0XHR0aGlzLnByZXBlbmQoTWF0aC5jb3Moc2tld1kpLCBNYXRoLnNpbihza2V3WSksIC1NYXRoLnNpbihza2V3WCksIE1hdGguY29zKHNrZXdYKSwgeCwgeSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucHJlcGVuZChjb3Mqc2NhbGVYLCBzaW4qc2NhbGVYLCAtc2luKnNjYWxlWSwgY29zKnNjYWxlWSwgeCwgeSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIGEgY2xvY2t3aXNlIHJvdGF0aW9uIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBtYXRyaXguXG5cdCAqIEBtZXRob2Qgcm90YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSBUaGUgYW5nbGUgdG8gcm90YXRlIGJ5LCBpbiBkZWdyZWVzLiBUbyB1c2UgYSB2YWx1ZSBpbiByYWRpYW5zLCBtdWx0aXBseSBpdCBieSBgMTgwL01hdGguUElgLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAucm90YXRlID0gZnVuY3Rpb24oYW5nbGUpIHtcblx0XHRhbmdsZSA9IGFuZ2xlKk1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0dmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHR2YXIgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuXG5cdFx0dmFyIGExID0gdGhpcy5hO1xuXHRcdHZhciBiMSA9IHRoaXMuYjtcblxuXHRcdHRoaXMuYSA9IGExKmNvcyt0aGlzLmMqc2luO1xuXHRcdHRoaXMuYiA9IGIxKmNvcyt0aGlzLmQqc2luO1xuXHRcdHRoaXMuYyA9IC1hMSpzaW4rdGhpcy5jKmNvcztcblx0XHR0aGlzLmQgPSAtYjEqc2luK3RoaXMuZCpjb3M7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgYSBza2V3IHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBtYXRyaXguXG5cdCAqIEBtZXRob2Qgc2tld1xuXHQgKiBAcGFyYW0ge051bWJlcn0gc2tld1ggVGhlIGFtb3VudCB0byBza2V3IGhvcml6b250YWxseSBpbiBkZWdyZWVzLiBUbyB1c2UgYSB2YWx1ZSBpbiByYWRpYW5zLCBtdWx0aXBseSBpdCBieSBgMTgwL01hdGguUElgLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2tld1kgVGhlIGFtb3VudCB0byBza2V3IHZlcnRpY2FsbHkgaW4gZGVncmVlcy5cblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0Ki9cblx0cC5za2V3ID0gZnVuY3Rpb24oc2tld1gsIHNrZXdZKSB7XG5cdFx0c2tld1ggPSBza2V3WCpNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdHNrZXdZID0gc2tld1kqTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHR0aGlzLmFwcGVuZChNYXRoLmNvcyhza2V3WSksIE1hdGguc2luKHNrZXdZKSwgLU1hdGguc2luKHNrZXdYKSwgTWF0aC5jb3Moc2tld1gpLCAwLCAwKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQXBwbGllcyBhIHNjYWxlIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBtYXRyaXguXG5cdCAqIEBtZXRob2Qgc2NhbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGFtb3VudCB0byBzY2FsZSBob3Jpem9udGFsbHkuIEUuRy4gYSB2YWx1ZSBvZiAyIHdpbGwgZG91YmxlIHRoZSBzaXplIGluIHRoZSBYIGRpcmVjdGlvbiwgYW5kIDAuNSB3aWxsIGhhbHZlIGl0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgYW1vdW50IHRvIHNjYWxlIHZlcnRpY2FsbHkuXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5zY2FsZSA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLmEgKj0geDtcblx0XHR0aGlzLmIgKj0geDtcblx0XHR0aGlzLmMgKj0geTtcblx0XHR0aGlzLmQgKj0geTtcblx0XHQvL3RoaXMudHggKj0geDtcblx0XHQvL3RoaXMudHkgKj0geTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogVHJhbnNsYXRlcyB0aGUgbWF0cml4IG9uIHRoZSB4IGFuZCB5IGF4ZXMuXG5cdCAqIEBtZXRob2QgdHJhbnNsYXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC50cmFuc2xhdGUgPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0dGhpcy50eCArPSB0aGlzLmEqeCArIHRoaXMuYyp5O1xuXHRcdHRoaXMudHkgKz0gdGhpcy5iKnggKyB0aGlzLmQqeTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgcHJvcGVydGllcyBvZiB0aGUgbWF0cml4IHRvIHRob3NlIG9mIGFuIGlkZW50aXR5IG1hdHJpeCAob25lIHRoYXQgYXBwbGllcyBhIG51bGwgdHJhbnNmb3JtYXRpb24pLlxuXHQgKiBAbWV0aG9kIGlkZW50aXR5XG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5pZGVudGl0eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuYSA9IHRoaXMuZCA9IDE7XG5cdFx0dGhpcy5iID0gdGhpcy5jID0gdGhpcy50eCA9IHRoaXMudHkgPSAwO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnZlcnRzIHRoZSBtYXRyaXgsIGNhdXNpbmcgaXQgdG8gcGVyZm9ybSB0aGUgb3Bwb3NpdGUgdHJhbnNmb3JtYXRpb24uXG5cdCAqIEBtZXRob2QgaW52ZXJ0XG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5pbnZlcnQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgYTEgPSB0aGlzLmE7XG5cdFx0dmFyIGIxID0gdGhpcy5iO1xuXHRcdHZhciBjMSA9IHRoaXMuYztcblx0XHR2YXIgZDEgPSB0aGlzLmQ7XG5cdFx0dmFyIHR4MSA9IHRoaXMudHg7XG5cdFx0dmFyIG4gPSBhMSpkMS1iMSpjMTtcblxuXHRcdHRoaXMuYSA9IGQxL247XG5cdFx0dGhpcy5iID0gLWIxL247XG5cdFx0dGhpcy5jID0gLWMxL247XG5cdFx0dGhpcy5kID0gYTEvbjtcblx0XHR0aGlzLnR4ID0gKGMxKnRoaXMudHktZDEqdHgxKS9uO1xuXHRcdHRoaXMudHkgPSAtKGExKnRoaXMudHktYjEqdHgxKS9uO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1hdHJpeCBpcyBhbiBpZGVudGl0eSBtYXRyaXguXG5cdCAqIEBtZXRob2QgaXNJZGVudGl0eVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiovXG5cdHAuaXNJZGVudGl0eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnR4ID09PSAwICYmIHRoaXMudHkgPT09IDAgJiYgdGhpcy5hID09PSAxICYmIHRoaXMuYiA9PT0gMCAmJiB0aGlzLmMgPT09IDAgJiYgdGhpcy5kID09PSAxO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIG1hdHJpeCBpcyBlcXVhbCB0byB0aGUgc3BlY2lmaWVkIG1hdHJpeCAoYWxsIHByb3BlcnR5IHZhbHVlcyBhcmUgZXF1YWwpLlxuXHQgKiBAbWV0aG9kIGVxdWFsc1xuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXggVGhlIG1hdHJpeCB0byBjb21wYXJlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiovXG5cdHAuZXF1YWxzID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0cmV0dXJuIHRoaXMudHggPT09IG1hdHJpeC50eCAmJiB0aGlzLnR5ID09PSBtYXRyaXgudHkgJiYgdGhpcy5hID09PSBtYXRyaXguYSAmJiB0aGlzLmIgPT09IG1hdHJpeC5iICYmIHRoaXMuYyA9PT0gbWF0cml4LmMgJiYgdGhpcy5kID09PSBtYXRyaXguZDtcblx0fTtcblxuXHQvKipcblx0ICogVHJhbnNmb3JtcyBhIHBvaW50IGFjY29yZGluZyB0byB0aGlzIG1hdHJpeC5cblx0ICogQG1ldGhvZCB0cmFuc2Zvcm1Qb2ludFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb21wb25lbnQgb2YgdGhlIHBvaW50IHRvIHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29tcG9uZW50IG9mIHRoZSBwb2ludCB0byB0cmFuc2Zvcm0uXG5cdCAqIEBwYXJhbSB7UG9pbnQgfCBPYmplY3R9IFtwdF0gQW4gb2JqZWN0IHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvLiBJZiBvbWl0dGVkIGEgZ2VuZXJpYyBvYmplY3Qgd2l0aCB4L3kgcHJvcGVydGllcyB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHtQb2ludH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAudHJhbnNmb3JtUG9pbnQgPSBmdW5jdGlvbih4LCB5LCBwdCkge1xuXHRcdHB0ID0gcHR8fHt9O1xuXHRcdHB0LnggPSB4KnRoaXMuYSt5KnRoaXMuYyt0aGlzLnR4O1xuXHRcdHB0LnkgPSB4KnRoaXMuYit5KnRoaXMuZCt0aGlzLnR5O1xuXHRcdHJldHVybiBwdDtcblx0fTtcblxuXHQvKipcblx0ICogRGVjb21wb3NlcyB0aGUgbWF0cml4IGludG8gdHJhbnNmb3JtIHByb3BlcnRpZXMgKHgsIHksIHNjYWxlWCwgc2NhbGVZLCBhbmQgcm90YXRpb24pLiBOb3RlIHRoYXQgdGhlc2UgdmFsdWVzXG5cdCAqIG1heSBub3QgbWF0Y2ggdGhlIHRyYW5zZm9ybSBwcm9wZXJ0aWVzIHlvdSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBtYXRyaXgsIHRob3VnaCB0aGV5IHdpbGwgcHJvZHVjZSB0aGUgc2FtZSB2aXN1YWxcblx0ICogcmVzdWx0cy5cblx0ICogQG1ldGhvZCBkZWNvbXBvc2Vcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRvIGFwcGx5IHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyB0by4gSWYgbnVsbCwgdGhlbiBhIG5ldyBvYmplY3Qgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgdGFyZ2V0LCBvciBhIG5ldyBnZW5lcmljIG9iamVjdCB3aXRoIHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyBhcHBsaWVkLlxuXHQqL1xuXHRwLmRlY29tcG9zZSA9IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdC8vIFRPRE86IGl0IHdvdWxkIGJlIG5pY2UgdG8gYmUgYWJsZSB0byBzb2x2ZSBmb3Igd2hldGhlciB0aGUgbWF0cml4IGNhbiBiZSBkZWNvbXBvc2VkIGludG8gb25seSBzY2FsZS9yb3RhdGlvbiBldmVuIHdoZW4gc2NhbGUgaXMgbmVnYXRpdmVcblx0XHRpZiAodGFyZ2V0ID09IG51bGwpIHsgdGFyZ2V0ID0ge307IH1cblx0XHR0YXJnZXQueCA9IHRoaXMudHg7XG5cdFx0dGFyZ2V0LnkgPSB0aGlzLnR5O1xuXHRcdHRhcmdldC5zY2FsZVggPSBNYXRoLnNxcnQodGhpcy5hICogdGhpcy5hICsgdGhpcy5iICogdGhpcy5iKTtcblx0XHR0YXJnZXQuc2NhbGVZID0gTWF0aC5zcXJ0KHRoaXMuYyAqIHRoaXMuYyArIHRoaXMuZCAqIHRoaXMuZCk7XG5cblx0XHR2YXIgc2tld1ggPSBNYXRoLmF0YW4yKC10aGlzLmMsIHRoaXMuZCk7XG5cdFx0dmFyIHNrZXdZID0gTWF0aC5hdGFuMih0aGlzLmIsIHRoaXMuYSk7XG5cblx0XHR2YXIgZGVsdGEgPSBNYXRoLmFicygxLXNrZXdYL3NrZXdZKTtcblx0XHRpZiAoZGVsdGEgPCAwLjAwMDAxKSB7IC8vIGVmZmVjdGl2ZWx5IGlkZW50aWNhbCwgY2FuIHVzZSByb3RhdGlvbjpcblx0XHRcdHRhcmdldC5yb3RhdGlvbiA9IHNrZXdZL01hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0XHRpZiAodGhpcy5hIDwgMCAmJiB0aGlzLmQgPj0gMCkge1xuXHRcdFx0XHR0YXJnZXQucm90YXRpb24gKz0gKHRhcmdldC5yb3RhdGlvbiA8PSAwKSA/IDE4MCA6IC0xODA7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXQuc2tld1ggPSB0YXJnZXQuc2tld1kgPSAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuc2tld1ggPSBza2V3WC9NYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0dGFyZ2V0LnNrZXdZID0gc2tld1kvTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDb3BpZXMgYWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgc3BlY2lmaWVkIG1hdHJpeCB0byB0aGlzIG1hdHJpeC5cblx0ICogQG1ldGhvZCBjb3B5XG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeCBUaGUgbWF0cml4IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQqL1xuXHRwLmNvcHkgPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRWYWx1ZXMobWF0cml4LmEsIG1hdHJpeC5iLCBtYXRyaXguYywgbWF0cml4LmQsIG1hdHJpeC50eCwgbWF0cml4LnR5KTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBNYXRyaXgyRCBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gYSBjbG9uZSBvZiB0aGUgTWF0cml4MkQgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgTWF0cml4MkQodGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdGhpcy5kLCB0aGlzLnR4LCB0aGlzLnR5KTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW01hdHJpeDJEIChhPVwiK3RoaXMuYStcIiBiPVwiK3RoaXMuYitcIiBjPVwiK3RoaXMuYytcIiBkPVwiK3RoaXMuZCtcIiB0eD1cIit0aGlzLnR4K1wiIHR5PVwiK3RoaXMudHkrXCIpXVwiO1xuXHR9O1xuXG5cdC8vIHRoaXMgaGFzIHRvIGJlIHBvcHVsYXRlZCBhZnRlciB0aGUgY2xhc3MgaXMgZGVmaW5lZDpcblx0TWF0cml4MkQuaWRlbnRpdHkgPSBuZXcgTWF0cml4MkQoKTtcblxuXG5cdGNyZWF0ZWpzLk1hdHJpeDJEID0gTWF0cml4MkQ7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRGlzcGxheVByb3BzLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIFVzZWQgZm9yIGNhbGN1bGF0aW5nIGFuZCBlbmNhcHN1bGF0aW5nIGRpc3BsYXkgcmVsYXRlZCBwcm9wZXJ0aWVzLlxuXHQgKiBAY2xhc3MgRGlzcGxheVByb3BzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdmlzaWJsZT10cnVlXSBWaXNpYmxlIHZhbHVlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2FscGhhPTBdIEFscGhhIHZhbHVlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NoYWRvdz1udWxsXSBBIFNoYWRvdyBpbnN0YW5jZSBvciBudWxsLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2NvbXBvc2l0ZU9wZXJhdGlvbj1udWxsXSBBIGNvbXBvc2l0ZU9wZXJhdGlvbiB2YWx1ZSBvciBudWxsLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW21hdHJpeF0gQSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguIERlZmF1bHRzIHRvIGEgbmV3IGlkZW50aXR5IG1hdHJpeC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gRGlzcGxheVByb3BzKHZpc2libGUsIGFscGhhLCBzaGFkb3csIGNvbXBvc2l0ZU9wZXJhdGlvbiwgbWF0cml4KSB7XG5cdFx0dGhpcy5zZXRWYWx1ZXModmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgY29tcG9zaXRlT3BlcmF0aW9uLCBtYXRyaXgpO1xuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvLyBhc3NpZ25lZCBpbiB0aGUgc2V0VmFsdWVzIG1ldGhvZC5cblx0XHQvKipcblx0XHQgKiBQcm9wZXJ0eSByZXByZXNlbnRpbmcgdGhlIGFscGhhIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGEgZGlzcGxheSBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IGFscGhhXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBQcm9wZXJ0eSByZXByZXNlbnRpbmcgdGhlIHNoYWRvdyB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBhIGRpc3BsYXkgb2JqZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBzaGFkb3dcblx0XHQgKiBAdHlwZSBTaGFkb3dcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFByb3BlcnR5IHJlcHJlc2VudGluZyB0aGUgY29tcG9zaXRlT3BlcmF0aW9uIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGEgZGlzcGxheSBvYmplY3QuXG5cdFx0ICogWW91IGNhbiBmaW5kIGEgbGlzdCBvZiB2YWxpZCBjb21wb3NpdGUgb3BlcmF0aW9ucyBhdDpcblx0XHQgKiA8YSBocmVmPVwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ2FudmFzX3R1dG9yaWFsL0NvbXBvc2l0aW5nXCI+aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vQ2FudmFzX3R1dG9yaWFsL0NvbXBvc2l0aW5nPC9hPlxuXHRcdCAqIEBwcm9wZXJ0eSBjb21wb3NpdGVPcGVyYXRpb25cblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiovXG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUHJvcGVydHkgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBmb3IgdmlzaWJsZSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBhIGRpc3BsYXkgb2JqZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSB2aXNpYmxlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqKi9cblx0XHRcblx0XHQvKipcblx0XHQgKiBUaGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGEgZGlzcGxheSBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IG1hdHJpeFxuXHRcdCAqIEB0eXBlIE1hdHJpeDJEXG5cdFx0ICoqL1xuXHR9XG5cdHZhciBwID0gRGlzcGxheVByb3BzLnByb3RvdHlwZTtcblxuLy8gaW5pdGlhbGl6YXRpb246XG5cdC8qKlxuXHQgKiBSZWluaXRpYWxpemVzIHRoZSBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVzLlxuXHQgKiBAbWV0aG9kIHNldFZhbHVlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3Zpc2libGU9dHJ1ZV0gVmlzaWJsZSB2YWx1ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthbHBoYT0xXSBBbHBoYSB2YWx1ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzaGFkb3c9bnVsbF0gQSBTaGFkb3cgaW5zdGFuY2Ugb3IgbnVsbC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtjb21wb3NpdGVPcGVyYXRpb249bnVsbF0gQSBjb21wb3NpdGVPcGVyYXRpb24gdmFsdWUgb3IgbnVsbC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttYXRyaXhdIEEgdHJhbnNmb3JtYXRpb24gbWF0cml4LiBEZWZhdWx0cyB0byBhbiBpZGVudGl0eSBtYXRyaXguXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlQcm9wc30gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5zZXRWYWx1ZXMgPSBmdW5jdGlvbiAodmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgY29tcG9zaXRlT3BlcmF0aW9uLCBtYXRyaXgpIHtcblx0XHR0aGlzLnZpc2libGUgPSB2aXNpYmxlID09IG51bGwgPyB0cnVlIDogISF2aXNpYmxlO1xuXHRcdHRoaXMuYWxwaGEgPSBhbHBoYSA9PSBudWxsID8gMSA6IGFscGhhO1xuXHRcdHRoaXMuc2hhZG93ID0gc2hhZG93O1xuXHRcdHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uID0gc2hhZG93O1xuXHRcdHRoaXMubWF0cml4ID0gbWF0cml4IHx8ICh0aGlzLm1hdHJpeCYmdGhpcy5tYXRyaXguaWRlbnRpdHkoKSkgfHwgbmV3IGNyZWF0ZWpzLk1hdHJpeDJEKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQXBwZW5kcyB0aGUgc3BlY2lmaWVkIGRpc3BsYXkgcHJvcGVydGllcy4gVGhpcyBpcyBnZW5lcmFsbHkgdXNlZCB0byBhcHBseSBhIGNoaWxkJ3MgcHJvcGVydGllcyBpdHMgcGFyZW50J3MuXG5cdCAqIEBtZXRob2QgYXBwZW5kXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSBkZXNpcmVkIHZpc2libGUgdmFsdWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFscGhhIGRlc2lyZWQgYWxwaGEgdmFsdWVcblx0ICogQHBhcmFtIHtTaGFkb3d9IHNoYWRvdyBkZXNpcmVkIHNoYWRvdyB2YWx1ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9zaXRlT3BlcmF0aW9uIGRlc2lyZWQgY29tcG9zaXRlIG9wZXJhdGlvbiB2YWx1ZVxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBbbWF0cml4XSBhIE1hdHJpeDJEIGluc3RhbmNlXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlQcm9wc30gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5hcHBlbmQgPSBmdW5jdGlvbih2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBjb21wb3NpdGVPcGVyYXRpb24sIG1hdHJpeCkge1xuXHRcdHRoaXMuYWxwaGEgKj0gYWxwaGE7XG5cdFx0dGhpcy5zaGFkb3cgPSBzaGFkb3cgfHwgdGhpcy5zaGFkb3c7XG5cdFx0dGhpcy5jb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGVPcGVyYXRpb24gfHwgdGhpcy5jb21wb3NpdGVPcGVyYXRpb247XG5cdFx0dGhpcy52aXNpYmxlID0gdGhpcy52aXNpYmxlICYmIHZpc2libGU7XG5cdFx0bWF0cml4JiZ0aGlzLm1hdHJpeC5hcHBlbmRNYXRyaXgobWF0cml4KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBQcmVwZW5kcyB0aGUgc3BlY2lmaWVkIGRpc3BsYXkgcHJvcGVydGllcy4gVGhpcyBpcyBnZW5lcmFsbHkgdXNlZCB0byBhcHBseSBhIHBhcmVudCdzIHByb3BlcnRpZXMgdG8gYSBjaGlsZCdzLlxuXHQgKiBGb3IgZXhhbXBsZSwgdG8gZ2V0IHRoZSBjb21iaW5lZCBkaXNwbGF5IHByb3BlcnRpZXMgdGhhdCB3b3VsZCBiZSBhcHBsaWVkIHRvIGEgY2hpbGQsIHlvdSBjb3VsZCB1c2U6XG5cdCAqIFxuXHQgKiBcdHZhciBvID0gbXlEaXNwbGF5T2JqZWN0O1xuXHQgKiBcdHZhciBwcm9wcyA9IG5ldyBjcmVhdGVqcy5EaXNwbGF5UHJvcHMoKTtcblx0ICogXHRkbyB7XG5cdCAqIFx0XHQvLyBwcmVwZW5kIGVhY2ggcGFyZW50J3MgcHJvcHMgaW4gdHVybjpcblx0ICogXHRcdHByb3BzLnByZXBlbmQoby52aXNpYmxlLCBvLmFscGhhLCBvLnNoYWRvdywgby5jb21wb3NpdGVPcGVyYXRpb24sIG8uZ2V0TWF0cml4KCkpO1xuXHQgKiBcdH0gd2hpbGUgKG8gPSBvLnBhcmVudCk7XG5cdCAqIFx0XG5cdCAqIEBtZXRob2QgcHJlcGVuZFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGUgZGVzaXJlZCB2aXNpYmxlIHZhbHVlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbHBoYSBkZXNpcmVkIGFscGhhIHZhbHVlXG5cdCAqIEBwYXJhbSB7U2hhZG93fSBzaGFkb3cgZGVzaXJlZCBzaGFkb3cgdmFsdWVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvc2l0ZU9wZXJhdGlvbiBkZXNpcmVkIGNvbXBvc2l0ZSBvcGVyYXRpb24gdmFsdWVcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gW21hdHJpeF0gYSBNYXRyaXgyRCBpbnN0YW5jZVxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5UHJvcHN9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAucHJlcGVuZCA9IGZ1bmN0aW9uKHZpc2libGUsIGFscGhhLCBzaGFkb3csIGNvbXBvc2l0ZU9wZXJhdGlvbiwgbWF0cml4KSB7XG5cdFx0dGhpcy5hbHBoYSAqPSBhbHBoYTtcblx0XHR0aGlzLnNoYWRvdyA9IHRoaXMuc2hhZG93IHx8IHNoYWRvdztcblx0XHR0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uIHx8IGNvbXBvc2l0ZU9wZXJhdGlvbjtcblx0XHR0aGlzLnZpc2libGUgPSB0aGlzLnZpc2libGUgJiYgdmlzaWJsZTtcblx0XHRtYXRyaXgmJnRoaXMubWF0cml4LnByZXBlbmRNYXRyaXgobWF0cml4KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXNldHMgdGhpcyBpbnN0YW5jZSBhbmQgaXRzIG1hdHJpeCB0byBkZWZhdWx0IHZhbHVlcy5cblx0ICogQG1ldGhvZCBpZGVudGl0eVxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5UHJvcHN9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAuaWRlbnRpdHkgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXHRcdHRoaXMuYWxwaGEgPSAxO1xuXHRcdHRoaXMuc2hhZG93ID0gdGhpcy5jb21wb3NpdGVPcGVyYXRpb24gPSBudWxsO1xuXHRcdHRoaXMubWF0cml4LmlkZW50aXR5KCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBEaXNwbGF5UHJvcHMgaW5zdGFuY2UuIENsb25lcyB0aGUgYXNzb2NpYXRlZCBtYXRyaXguXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7RGlzcGxheVByb3BzfSBhIGNsb25lIG9mIHRoZSBEaXNwbGF5UHJvcHMgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgRGlzcGxheVByb3BzKHRoaXMuYWxwaGEsIHRoaXMuc2hhZG93LCB0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbiwgdGhpcy52aXNpYmxlLCB0aGlzLm1hdHJpeC5jbG9uZSgpKTtcblx0fTtcblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXG5cdGNyZWF0ZWpzLkRpc3BsYXlQcm9wcyA9IERpc3BsYXlQcm9wcztcbn0pKCk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBQb2ludC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogUmVwcmVzZW50cyBhIHBvaW50IG9uIGEgMiBkaW1lbnNpb25hbCB4IC8geSBjb29yZGluYXRlIHN5c3RlbS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBcblx0ICogICAgICB2YXIgcG9pbnQgPSBuZXcgY3JlYXRlanMuUG9pbnQoMCwgMTAwKTtcblx0ICogXG5cdCAqIEBjbGFzcyBQb2ludFxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gWCBwb3NpdGlvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIFkgcG9zaXRpb24uXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcblx0IFx0dGhpcy5zZXRWYWx1ZXMoeCwgeSk7XG5cdCBcdFxuXHQgXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0Ly8gYXNzaWduZWQgaW4gdGhlIHNldFZhbHVlcyBtZXRob2QuXG5cdFx0LyoqXG5cdFx0ICogWCBwb3NpdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgeFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogWSBwb3NpdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgeVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0fVxuXHR2YXIgcCA9IFBvaW50LnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblx0XG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqIFxuXHQgKiBTZXRzIHRoZSBzcGVjaWZpZWQgdmFsdWVzIG9uIHRoaXMgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2Qgc2V0VmFsdWVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSBYIHBvc2l0aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gWSBwb3NpdGlvbi5cblx0ICogQHJldHVybiB7UG9pbnR9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAuc2V0VmFsdWVzID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMueCA9IHh8fDA7XG5cdFx0dGhpcy55ID0geXx8MDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDb3BpZXMgYWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgc3BlY2lmaWVkIHBvaW50IHRvIHRoaXMgcG9pbnQuXG5cdCAqIEBtZXRob2QgY29weVxuXHQgKiBAcGFyYW0ge1BvaW50fSBwb2ludCBUaGUgcG9pbnQgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG5cdCAqIEByZXR1cm4ge1BvaW50fSBUaGlzIHBvaW50LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLmNvcHkgPSBmdW5jdGlvbihwb2ludCkge1xuXHRcdHRoaXMueCA9IHBvaW50Lng7XG5cdFx0dGhpcy55ID0gcG9pbnQueTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFBvaW50IGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge1BvaW50fSBhIGNsb25lIG9mIHRoZSBQb2ludCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltQb2ludCAoeD1cIit0aGlzLngrXCIgeT1cIit0aGlzLnkrXCIpXVwiO1xuXHR9O1xuXHRcblx0XG5cdGNyZWF0ZWpzLlBvaW50ID0gUG9pbnQ7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gUmVjdGFuZ2xlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBSZXByZXNlbnRzIGEgcmVjdGFuZ2xlIGFzIGRlZmluZWQgYnkgdGhlIHBvaW50cyAoeCwgeSkgYW5kICh4K3dpZHRoLCB5K2hlaWdodCkuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgcmVjdCA9IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoMCwgMCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiBAY2xhc3MgUmVjdGFuZ2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSBYIHBvc2l0aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gWSBwb3NpdGlvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aD0wXSBUaGUgd2lkdGggb2YgdGhlIFJlY3RhbmdsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQ9MF0gVGhlIGhlaWdodCBvZiB0aGUgUmVjdGFuZ2xlLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdHRoaXMuc2V0VmFsdWVzKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvLyBhc3NpZ25lZCBpbiB0aGUgc2V0VmFsdWVzIG1ldGhvZC5cblx0XHQvKipcblx0XHQgKiBYIHBvc2l0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSB4XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBZIHBvc2l0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSB5XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBXaWR0aC5cblx0XHQgKiBAcHJvcGVydHkgd2lkdGhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIEhlaWdodC5cblx0XHQgKiBAcHJvcGVydHkgaGVpZ2h0XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHR9XG5cdHZhciBwID0gUmVjdGFuZ2xlLnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKiBcblx0ICogU2V0cyB0aGUgc3BlY2lmaWVkIHZhbHVlcyBvbiB0aGlzIGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIHNldFZhbHVlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gWCBwb3NpdGlvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIFkgcG9zaXRpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGg9MF0gVGhlIHdpZHRoIG9mIHRoZSBSZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0PTBdIFRoZSBoZWlnaHQgb2YgdGhlIFJlY3RhbmdsZS5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLnNldFZhbHVlcyA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHQvLyBkb24ndCBmb3JnZXQgdG8gdXBkYXRlIGRvY3MgaW4gdGhlIGNvbnN0cnVjdG9yIGlmIHRoZXNlIGNoYW5nZTpcblx0XHR0aGlzLnggPSB4fHwwO1xuXHRcdHRoaXMueSA9IHl8fDA7XG5cdFx0dGhpcy53aWR0aCA9IHdpZHRofHwwO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0fHwwO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqIFxuXHQgKiBFeHRlbmRzIHRoZSByZWN0YW5nbGUncyBib3VuZHMgdG8gaW5jbHVkZSB0aGUgZGVzY3JpYmVkIHBvaW50IG9yIHJlY3RhbmdsZS5cblx0ICogQG1ldGhvZCBleHRlbmRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggWCBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb3IgcmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBZIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvciByZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGg9MF0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0PTBdIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZS5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLmV4dGVuZCA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR3aWR0aCA9IHdpZHRofHwwO1xuXHRcdGhlaWdodCA9IGhlaWdodHx8MDtcblx0XHRpZiAoeCt3aWR0aCA+IHRoaXMueCt0aGlzLndpZHRoKSB7IHRoaXMud2lkdGggPSB4K3dpZHRoLXRoaXMueDsgfVxuXHRcdGlmICh5K2hlaWdodCA+IHRoaXMueSt0aGlzLmhlaWdodCkgeyB0aGlzLmhlaWdodCA9IHkraGVpZ2h0LXRoaXMueTsgfVxuXHRcdGlmICh4IDwgdGhpcy54KSB7IHRoaXMud2lkdGggKz0gdGhpcy54LXg7IHRoaXMueCA9IHg7IH1cblx0XHRpZiAoeSA8IHRoaXMueSkgeyB0aGlzLmhlaWdodCArPSB0aGlzLnkteTsgdGhpcy55ID0geTsgfVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqIFxuXHQgKiBBZGRzIHRoZSBzcGVjaWZpZWQgcGFkZGluZyB0byB0aGUgcmVjdGFuZ2xlJ3MgYm91bmRzLlxuXHQgKiBAbWV0aG9kIGV4dGVuZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RvcD0wXVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2xlZnQ9MF1cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtyaWdodD0wXVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2JvdHRvbT0wXVxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAucGFkID0gZnVuY3Rpb24odG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0KSB7XG5cdFx0dGhpcy54IC09IGxlZnQ7XG5cdFx0dGhpcy55IC09IHRvcDtcblx0XHR0aGlzLndpZHRoICs9IGxlZnQrcmlnaHQ7XG5cdFx0dGhpcy5oZWlnaHQgKz0gdG9wK2JvdHRvbTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDb3BpZXMgYWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgc3BlY2lmaWVkIHJlY3RhbmdsZSB0byB0aGlzIHJlY3RhbmdsZS5cblx0ICogQG1ldGhvZCBjb3B5XG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0YW5nbGUgVGhlIHJlY3RhbmdsZSB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBUaGlzIHJlY3RhbmdsZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5jb3B5ID0gZnVuY3Rpb24ocmVjdGFuZ2xlKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0VmFsdWVzKHJlY3RhbmdsZS54LCByZWN0YW5nbGUueSwgcmVjdGFuZ2xlLndpZHRoLCByZWN0YW5nbGUuaGVpZ2h0KTtcblx0fTtcblx0XG5cdC8qKiBcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgcmVjdGFuZ2xlIGZ1bGx5IGVuY2xvc2VzIHRoZSBkZXNjcmliZWQgcG9pbnQgb3IgcmVjdGFuZ2xlLlxuXHQgKiBAbWV0aG9kIGNvbnRhaW5zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFggcG9zaXRpb24gb2YgdGhlIHBvaW50IG9yIHJlY3RhbmdsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb3IgcmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTBdIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodD0wXSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIGRlc2NyaWJlZCBwb2ludCBvciByZWN0YW5nbGUgaXMgY29udGFpbmVkIHdpdGhpbiB0aGlzIHJlY3RhbmdsZS5cblx0Ki9cblx0cC5jb250YWlucyA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR3aWR0aCA9IHdpZHRofHwwO1xuXHRcdGhlaWdodCA9IGhlaWdodHx8MDtcblx0XHRyZXR1cm4gKHggPj0gdGhpcy54ICYmIHgrd2lkdGggPD0gdGhpcy54K3RoaXMud2lkdGggJiYgeSA+PSB0aGlzLnkgJiYgeStoZWlnaHQgPD0gdGhpcy55K3RoaXMuaGVpZ2h0KTtcblx0fTtcblx0XG5cdC8qKiBcblx0ICogUmV0dXJucyBhIG5ldyByZWN0YW5nbGUgd2hpY2ggY29udGFpbnMgdGhpcyByZWN0YW5nbGUgYW5kIHRoZSBzcGVjaWZpZWQgcmVjdGFuZ2xlLlxuXHQgKiBAbWV0aG9kIHVuaW9uXG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IFRoZSByZWN0YW5nbGUgdG8gY2FsY3VsYXRlIGEgdW5pb24gd2l0aC5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBBIG5ldyByZWN0YW5nbGUgZGVzY3JpYmluZyB0aGUgdW5pb24uXG5cdCovXG5cdHAudW5pb24gPSBmdW5jdGlvbihyZWN0KSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5leHRlbmQocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcblx0fTtcblx0XG5cdC8qKiBcblx0ICogUmV0dXJucyBhIG5ldyByZWN0YW5nbGUgd2hpY2ggZGVzY3JpYmVzIHRoZSBpbnRlcnNlY3Rpb24gKG92ZXJsYXApIG9mIHRoaXMgcmVjdGFuZ2xlIGFuZCB0aGUgc3BlY2lmaWVkIHJlY3RhbmdsZSxcblx0ICogb3IgbnVsbCBpZiB0aGV5IGRvIG5vdCBpbnRlcnNlY3QuXG5cdCAqIEBtZXRob2QgaW50ZXJzZWN0aW9uXG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IFRoZSByZWN0YW5nbGUgdG8gY2FsY3VsYXRlIGFuIGludGVyc2VjdGlvbiB3aXRoLlxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IEEgbmV3IHJlY3RhbmdsZSBkZXNjcmliaW5nIHRoZSBpbnRlcnNlY3Rpb24gb3IgbnVsbC5cblx0Ki9cblx0cC5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihyZWN0KSB7XG5cdFx0dmFyIHgxID0gcmVjdC54LCB5MSA9IHJlY3QueSwgeDIgPSB4MStyZWN0LndpZHRoLCB5MiA9IHkxK3JlY3QuaGVpZ2h0O1xuXHRcdGlmICh0aGlzLnggPiB4MSkgeyB4MSA9IHRoaXMueDsgfVxuXHRcdGlmICh0aGlzLnkgPiB5MSkgeyB5MSA9IHRoaXMueTsgfVxuXHRcdGlmICh0aGlzLnggKyB0aGlzLndpZHRoIDwgeDIpIHsgeDIgPSB0aGlzLnggKyB0aGlzLndpZHRoOyB9XG5cdFx0aWYgKHRoaXMueSArIHRoaXMuaGVpZ2h0IDwgeTIpIHsgeTIgPSB0aGlzLnkgKyB0aGlzLmhlaWdodDsgfVxuXHRcdHJldHVybiAoeDIgPD0geDEgfHwgeTIgPD0geTEpID8gbnVsbCA6IG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4Mi14MSwgeTIteTEpO1xuXHR9O1xuXHRcblx0LyoqIFxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCByZWN0YW5nbGUgaW50ZXJzZWN0cyAoaGFzIGFueSBvdmVybGFwKSB3aXRoIHRoaXMgcmVjdGFuZ2xlLlxuXHQgKiBAbWV0aG9kIGludGVyc2VjdHNcblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QgVGhlIHJlY3RhbmdsZSB0byBjb21wYXJlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSByZWN0YW5nbGVzIGludGVyc2VjdC5cblx0Ki9cblx0cC5pbnRlcnNlY3RzID0gZnVuY3Rpb24ocmVjdCkge1xuXHRcdHJldHVybiAocmVjdC54IDw9IHRoaXMueCt0aGlzLndpZHRoICYmIHRoaXMueCA8PSByZWN0LngrcmVjdC53aWR0aCAmJiByZWN0LnkgPD0gdGhpcy55K3RoaXMuaGVpZ2h0ICYmIHRoaXMueSA8PSByZWN0LnkgKyByZWN0LmhlaWdodCk7XG5cdH07XG5cdFxuXHQvKiogXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgd2lkdGggb3IgaGVpZ2h0IGFyZSBlcXVhbCBvciBsZXNzIHRoYW4gMC5cblx0ICogQG1ldGhvZCBpc0VtcHR5XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHJlY3RhbmdsZSBpcyBlbXB0eS5cblx0Ki9cblx0cC5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgUmVjdGFuZ2xlIGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gYSBjbG9uZSBvZiB0aGUgUmVjdGFuZ2xlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbUmVjdGFuZ2xlICh4PVwiK3RoaXMueCtcIiB5PVwiK3RoaXMueStcIiB3aWR0aD1cIit0aGlzLndpZHRoK1wiIGhlaWdodD1cIit0aGlzLmhlaWdodCtcIildXCI7XG5cdH07XG5cdFxuXHRcblx0Y3JlYXRlanMuUmVjdGFuZ2xlID0gUmVjdGFuZ2xlO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEJ1dHRvbkhlbHBlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogVGhlIEJ1dHRvbkhlbHBlciBpcyBhIGhlbHBlciBjbGFzcyB0byBjcmVhdGUgaW50ZXJhY3RpdmUgYnV0dG9ucyBmcm9tIHt7I2Nyb3NzTGluayBcIk1vdmllQ2xpcFwifX17ey9jcm9zc0xpbmt9fSBvclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTcHJpdGVcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2VzLiBUaGlzIGNsYXNzIHdpbGwgaW50ZXJjZXB0IG1vdXNlIGV2ZW50cyBmcm9tIGFuIG9iamVjdCwgYW5kXG5cdCAqIGF1dG9tYXRpY2FsbHkgY2FsbCB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFN0b3BcIn19e3svY3Jvc3NMaW5rfX0gb3Ige3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiB0byB0aGUgcmVzcGVjdGl2ZSBhbmltYXRpb24gbGFiZWxzLCBhZGQgYSBwb2ludGVyIGN1cnNvciwgYW5kIGFsbG93cyB0aGUgdXNlciB0byBkZWZpbmUgYSBoaXQgc3RhdGUgZnJhbWUuXG5cdCAqXG5cdCAqIFRoZSBCdXR0b25IZWxwZXIgaW5zdGFuY2UgZG9lcyBub3QgbmVlZCB0byBiZSBhZGRlZCB0byB0aGUgc3RhZ2UsIGJ1dCBhIHJlZmVyZW5jZSBzaG91bGQgYmUgbWFpbnRhaW5lZCB0byBwcmV2ZW50XG5cdCAqIGdhcmJhZ2UgY29sbGVjdGlvbi5cblx0ICogXG5cdCAqIE5vdGUgdGhhdCBvdmVyIHN0YXRlcyB3aWxsIG5vdCB3b3JrIHVubGVzcyB5b3UgY2FsbCB7eyNjcm9zc0xpbmsgXCJTdGFnZS9lbmFibGVNb3VzZU92ZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgaGVscGVyID0gbmV3IGNyZWF0ZWpzLkJ1dHRvbkhlbHBlcihteUluc3RhbmNlLCBcIm91dFwiLCBcIm92ZXJcIiwgXCJkb3duXCIsIGZhbHNlLCBteUluc3RhbmNlLCBcImhpdFwiKTtcblx0ICogICAgICBteUluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljayk7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcblx0ICogICAgICAgICAgLy8gQ2xpY2sgSGFwcGVuZWQuXG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBAY2xhc3MgQnV0dG9uSGVscGVyXG5cdCAqIEBwYXJhbSB7U3ByaXRlfE1vdmllQ2xpcH0gdGFyZ2V0IFRoZSBpbnN0YW5jZSB0byBtYW5hZ2UuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbb3V0TGFiZWw9XCJvdXRcIl0gVGhlIGxhYmVsIG9yIGFuaW1hdGlvbiB0byBnbyB0byB3aGVuIHRoZSB1c2VyIHJvbGxzIG91dCBvZiB0aGUgYnV0dG9uLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW292ZXJMYWJlbD1cIm92ZXJcIl0gVGhlIGxhYmVsIG9yIGFuaW1hdGlvbiB0byBnbyB0byB3aGVuIHRoZSB1c2VyIHJvbGxzIG92ZXIgdGhlIGJ1dHRvbi5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtkb3duTGFiZWw9XCJkb3duXCJdIFRoZSBsYWJlbCBvciBhbmltYXRpb24gdG8gZ28gdG8gd2hlbiB0aGUgdXNlciBwcmVzc2VzIHRoZSBidXR0b24uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BsYXk9ZmFsc2VdIElmIHRoZSBoZWxwZXIgc2hvdWxkIGNhbGwgXCJnb3RvQW5kUGxheVwiIG9yIFwiZ290b0FuZFN0b3BcIiBvbiB0aGUgYnV0dG9uIHdoZW4gY2hhbmdpbmdcblx0ICogc3RhdGVzLlxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IFtoaXRBcmVhXSBBbiBvcHRpb25hbCBpdGVtIHRvIHVzZSBhcyB0aGUgaGl0IHN0YXRlIGZvciB0aGUgYnV0dG9uLiBJZiB0aGlzIGlzIG5vdCBkZWZpbmVkLFxuXHQgKiB0aGVuIHRoZSBidXR0b24ncyB2aXNpYmxlIHN0YXRlcyB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gTm90ZSB0aGF0IHRoZSBzYW1lIGluc3RhbmNlIGFzIHRoZSBcInRhcmdldFwiIGFyZ3VtZW50IGNhbiBiZVxuXHQgKiB1c2VkIGZvciB0aGUgaGl0U3RhdGUuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbaGl0TGFiZWxdIFRoZSBsYWJlbCBvciBhbmltYXRpb24gb24gdGhlIGhpdEFyZWEgaW5zdGFuY2UgdGhhdCBkZWZpbmVzIHRoZSBoaXRBcmVhIGJvdW5kcy4gSWYgdGhpcyBpc1xuXHQgKiBudWxsLCB0aGVuIHRoZSBkZWZhdWx0IHN0YXRlIG9mIHRoZSBoaXRBcmVhIHdpbGwgYmUgdXNlZC4gKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEJ1dHRvbkhlbHBlcih0YXJnZXQsIG91dExhYmVsLCBvdmVyTGFiZWwsIGRvd25MYWJlbCwgcGxheSwgaGl0QXJlYSwgaGl0TGFiZWwpIHtcblx0XHRpZiAoIXRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7IHJldHVybjsgfVxuXHRcblx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0YXJnZXQgZm9yIHRoaXMgYnV0dG9uIGhlbHBlci5cblx0XHQgKiBAcHJvcGVydHkgdGFyZ2V0XG5cdFx0ICogQHR5cGUgTW92aWVDbGlwIHwgU3ByaXRlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgbGFiZWwgbmFtZSBvciBmcmFtZSBudW1iZXIgdG8gZGlzcGxheSB3aGVuIHRoZSB1c2VyIG1vdXNlcyBvdXQgb2YgdGhlIHRhcmdldC4gRGVmYXVsdHMgdG8gXCJvdmVyXCIuXG5cdFx0ICogQHByb3BlcnR5IG92ZXJMYWJlbFxuXHRcdCAqIEB0eXBlIFN0cmluZyB8IE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLm92ZXJMYWJlbCA9IG92ZXJMYWJlbCA9PSBudWxsID8gXCJvdmVyXCIgOiBvdmVyTGFiZWw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsYWJlbCBuYW1lIG9yIGZyYW1lIG51bWJlciB0byBkaXNwbGF5IHdoZW4gdGhlIHVzZXIgbW91c2VzIG92ZXIgdGhlIHRhcmdldC4gRGVmYXVsdHMgdG8gXCJvdXRcIi5cblx0XHQgKiBAcHJvcGVydHkgb3V0TGFiZWxcblx0XHQgKiBAdHlwZSBTdHJpbmcgfCBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5vdXRMYWJlbCA9IG91dExhYmVsID09IG51bGwgPyBcIm91dFwiIDogb3V0TGFiZWw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsYWJlbCBuYW1lIG9yIGZyYW1lIG51bWJlciB0byBkaXNwbGF5IHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBvbiB0aGUgdGFyZ2V0LiBEZWZhdWx0cyB0byBcImRvd25cIi5cblx0XHQgKiBAcHJvcGVydHkgZG93bkxhYmVsXG5cdFx0ICogQHR5cGUgU3RyaW5nIHwgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuZG93bkxhYmVsID0gZG93bkxhYmVsID09IG51bGwgPyBcImRvd25cIiA6IGRvd25MYWJlbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgdHJ1ZSwgdGhlbiBCdXR0b25IZWxwZXIgd2lsbCBjYWxsIGdvdG9BbmRQbGF5LCBpZiBmYWxzZSwgaXQgd2lsbCB1c2UgZ290b0FuZFN0b3AuIERlZmF1bHQgaXMgZmFsc2UuXG5cdFx0ICogQHByb3BlcnR5IHBsYXlcblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiovXG5cdFx0dGhpcy5wbGF5ID0gcGxheTtcblx0XHRcblx0XHRcblx0Ly8gIHByaXZhdGUgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfaXNQcmVzc2VkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5faXNQcmVzc2VkID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfaXNPdmVyXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5faXNPdmVyID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfZW5hYmxlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcblx0XHRcblx0Ly8gc2V0dXA6XG5cdFx0dGFyZ2V0Lm1vdXNlQ2hpbGRyZW4gPSBmYWxzZTsgLy8gcHJldmVudHMgaXNzdWVzIHdoZW4gY2hpbGRyZW4gYXJlIHJlbW92ZWQgZnJvbSB0aGUgZGlzcGxheSBsaXN0IHdoZW4gc3RhdGUgY2hhbmdlcy5cblx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXHRcdHRoaXMuaGFuZGxlRXZlbnQoe30pO1xuXHRcdGlmIChoaXRBcmVhKSB7XG5cdFx0XHRpZiAoaGl0TGFiZWwpIHtcblx0XHRcdFx0aGl0QXJlYS5hY3Rpb25zRW5hYmxlZCA9IGZhbHNlO1xuXHRcdFx0XHRoaXRBcmVhLmdvdG9BbmRTdG9wJiZoaXRBcmVhLmdvdG9BbmRTdG9wKGhpdExhYmVsKTtcblx0XHRcdH1cblx0XHRcdHRhcmdldC5oaXRBcmVhID0gaGl0QXJlYTtcblx0XHR9XG5cdH1cblx0dmFyIHAgPSBCdXR0b25IZWxwZXIucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXHRcbi8vIGdldHRlciAvIHNldHRlcnM6XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIkJ1dHRvbkhlbHBlci9lbmFibGVkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2Qgc2V0RW5hYmxlZFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0cC5zZXRFbmFibGVkID0gZnVuY3Rpb24odmFsdWUpIHsgLy8gVE9ETzogZGVwcmVjYXRlZC5cblx0XHRpZiAodmFsdWUgPT0gdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cblx0XHR2YXIgbyA9IHRoaXMudGFyZ2V0O1xuXHRcdHRoaXMuX2VuYWJsZWQgPSB2YWx1ZTtcblx0XHRpZiAodmFsdWUpIHtcblx0XHRcdG8uY3Vyc29yID0gXCJwb2ludGVyXCI7XG5cdFx0XHRvLmFkZEV2ZW50TGlzdGVuZXIoXCJyb2xsb3ZlclwiLCB0aGlzKTtcblx0XHRcdG8uYWRkRXZlbnRMaXN0ZW5lcihcInJvbGxvdXRcIiwgdGhpcyk7XG5cdFx0XHRvLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcyk7XG5cdFx0XHRvLmFkZEV2ZW50TGlzdGVuZXIoXCJwcmVzc3VwXCIsIHRoaXMpO1xuXHRcdFx0aWYgKG8uX3Jlc2V0KSB7IG8uX19yZXNldCA9IG8uX3Jlc2V0OyBvLl9yZXNldCA9IHRoaXMuX3Jlc2V0O31cblx0XHR9IGVsc2Uge1xuXHRcdFx0by5jdXJzb3IgPSBudWxsO1xuXHRcdFx0by5yZW1vdmVFdmVudExpc3RlbmVyKFwicm9sbG92ZXJcIiwgdGhpcyk7XG5cdFx0XHRvLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyb2xsb3V0XCIsIHRoaXMpO1xuXHRcdFx0by5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMpO1xuXHRcdFx0by5yZW1vdmVFdmVudExpc3RlbmVyKFwicHJlc3N1cFwiLCB0aGlzKTtcblx0XHRcdGlmIChvLl9fcmVzZXQpIHsgby5fcmVzZXQgPSBvLl9fcmVzZXQ7IGRlbGV0ZShvLl9fcmVzZXQpOyB9XG5cdFx0fVxuXHR9O1xuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJCdXR0b25IZWxwZXIvZW5hYmxlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldEVuYWJsZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRwLmdldEVuYWJsZWQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZW5hYmxlZDtcblx0fTtcblxuXHQvKipcblx0ICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgYnV0dG9uIGZ1bmN0aW9uYWxpdHkgb24gdGhlIHRhcmdldC5cblx0ICogQHByb3BlcnR5IGVuYWJsZWRcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqKi9cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cdFx0XHRlbmFibGVkOiB7IGdldDogcC5nZXRFbmFibGVkLCBzZXQ6IHAuc2V0RW5hYmxlZCB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHt9IC8vIFRPRE86IHVzZSBMb2dcblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltCdXR0b25IZWxwZXJdXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBoYW5kbGVFdmVudFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZ0IFRoZSBtb3VzZSBldmVudCB0byBoYW5kbGUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24oZXZ0KSB7XG5cdFx0dmFyIGxhYmVsLCB0ID0gdGhpcy50YXJnZXQsIHR5cGUgPSBldnQudHlwZTtcblx0XHRpZiAodHlwZSA9PSBcIm1vdXNlZG93blwiKSB7XG5cdFx0XHR0aGlzLl9pc1ByZXNzZWQgPSB0cnVlO1xuXHRcdFx0bGFiZWwgPSB0aGlzLmRvd25MYWJlbDtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT0gXCJwcmVzc3VwXCIpIHtcblx0XHRcdHRoaXMuX2lzUHJlc3NlZCA9IGZhbHNlO1xuXHRcdFx0bGFiZWwgPSB0aGlzLl9pc092ZXIgPyB0aGlzLm92ZXJMYWJlbCA6IHRoaXMub3V0TGFiZWw7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09IFwicm9sbG92ZXJcIikge1xuXHRcdFx0dGhpcy5faXNPdmVyID0gdHJ1ZTtcblx0XHRcdGxhYmVsID0gdGhpcy5faXNQcmVzc2VkID8gdGhpcy5kb3duTGFiZWwgOiB0aGlzLm92ZXJMYWJlbDtcblx0XHR9IGVsc2UgeyAvLyByb2xsb3V0IGFuZCBkZWZhdWx0XG5cdFx0XHR0aGlzLl9pc092ZXIgPSBmYWxzZTtcblx0XHRcdGxhYmVsID0gdGhpcy5faXNQcmVzc2VkID8gdGhpcy5vdmVyTGFiZWwgOiB0aGlzLm91dExhYmVsO1xuXHRcdH1cblx0XHRpZiAodGhpcy5wbGF5KSB7XG5cdFx0XHR0LmdvdG9BbmRQbGF5JiZ0LmdvdG9BbmRQbGF5KGxhYmVsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dC5nb3RvQW5kU3RvcCYmdC5nb3RvQW5kU3RvcChsYWJlbCk7XG5cdFx0fVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEluamVjdGVkIGludG8gdGFyZ2V0LiBQcmVzZXJ2ZXMgdGhlIHBhdXNlZCBzdGF0ZSB0aHJvdWdoIGEgcmVzZXQuXG5cdCAqIEBtZXRob2QgX3Jlc2V0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFRPRE86IGV4cGxvcmUgYmV0dGVyIHdheXMgdG8gaGFuZGxlIHRoaXMgaXNzdWUuIFRoaXMgaXMgaGFja3kgJiBkaXNydXB0cyBvYmplY3Qgc2lnbmF0dXJlcy5cblx0XHR2YXIgcCA9IHRoaXMucGF1c2VkO1xuXHRcdHRoaXMuX19yZXNldCgpO1xuXHRcdHRoaXMucGF1c2VkID0gcDtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLkJ1dHRvbkhlbHBlciA9IEJ1dHRvbkhlbHBlcjtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTaGFkb3cuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFRoaXMgY2xhc3MgZW5jYXBzdWxhdGVzIHRoZSBwcm9wZXJ0aWVzIHJlcXVpcmVkIHRvIGRlZmluZSBhIHNoYWRvdyB0byBhcHBseSB0byBhIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3RcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogdmlhIGl0cyA8Y29kZT5zaGFkb3c8L2NvZGU+IHByb3BlcnR5LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgbXlJbWFnZS5zaGFkb3cgPSBuZXcgY3JlYXRlanMuU2hhZG93KFwiIzAwMDAwMFwiLCA1LCA1LCAxMCk7XG5cdCAqXG5cdCAqIEBjbGFzcyBTaGFkb3dcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBUaGUgY29sb3Igb2YgdGhlIHNoYWRvdy4gVGhpcyBjYW4gYmUgYW55IHZhbGlkIENTUyBjb2xvciB2YWx1ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFggVGhlIHggb2Zmc2V0IG9mIHRoZSBzaGFkb3cgaW4gcGl4ZWxzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0WSBUaGUgeSBvZmZzZXQgb2YgdGhlIHNoYWRvdyBpbiBwaXhlbHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBibHVyIFRoZSBzaXplIG9mIHRoZSBibHVycmluZyBlZmZlY3QuXG5cdCAqKi9cblx0ZnVuY3Rpb24gU2hhZG93KGNvbG9yLCBvZmZzZXRYLCBvZmZzZXRZLCBibHVyKSB7XG5cdFx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKiBcblx0XHQgKiBUaGUgY29sb3Igb2YgdGhlIHNoYWRvdy4gVGhpcyBjYW4gYmUgYW55IHZhbGlkIENTUyBjb2xvciB2YWx1ZS5cblx0XHQgKiBAcHJvcGVydHkgY29sb3Jcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5jb2xvciA9IGNvbG9yfHxcImJsYWNrXCI7XG5cdFxuXHRcdC8qKiBUaGUgeCBvZmZzZXQgb2YgdGhlIHNoYWRvdy5cblx0XHQgKiBAcHJvcGVydHkgb2Zmc2V0WFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLm9mZnNldFggPSBvZmZzZXRYfHwwO1xuXHRcblx0XHQvKiogVGhlIHkgb2Zmc2V0IG9mIHRoZSBzaGFkb3cuXG5cdFx0ICogQHByb3BlcnR5IG9mZnNldFlcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5vZmZzZXRZID0gb2Zmc2V0WXx8MDtcblx0XG5cdFx0LyoqIFRoZSBibHVyIG9mIHRoZSBzaGFkb3cuXG5cdFx0ICogQHByb3BlcnR5IGJsdXJcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5ibHVyID0gYmx1cnx8MDtcblx0fVxuXHR2YXIgcCA9IFNoYWRvdy5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cbi8vIHN0YXRpYyBwdWJsaWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIEFuIGlkZW50aXR5IHNoYWRvdyBvYmplY3QgKGFsbCBwcm9wZXJ0aWVzIGFyZSBzZXQgdG8gMCkuXG5cdCAqIEBwcm9wZXJ0eSBpZGVudGl0eVxuXHQgKiBAdHlwZSBTaGFkb3dcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0U2hhZG93LmlkZW50aXR5ID0gbmV3IFNoYWRvdyhcInRyYW5zcGFyZW50XCIsIDAsIDAsIDApO1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1NoYWRvd11cIjtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgU2hhZG93IGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge1NoYWRvd30gQSBjbG9uZSBvZiB0aGUgY3VycmVudCBTaGFkb3cgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2hhZG93KHRoaXMuY29sb3IsIHRoaXMub2Zmc2V0WCwgdGhpcy5vZmZzZXRZLCB0aGlzLmJsdXIpO1xuXHR9O1xuXHRcblxuXHRjcmVhdGVqcy5TaGFkb3cgPSBTaGFkb3c7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU3ByaXRlU2hlZXQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEVuY2Fwc3VsYXRlcyB0aGUgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBhc3NvY2lhdGVkIHdpdGggYSBzcHJpdGUgc2hlZXQuIEEgc3ByaXRlIHNoZWV0IGlzIGEgc2VyaWVzIG9mIGltYWdlcyAodXN1YWxseVxuXHQgKiBhbmltYXRpb24gZnJhbWVzKSBjb21iaW5lZCBpbnRvIGEgbGFyZ2VyIGltYWdlIChvciBpbWFnZXMpLiBGb3IgZXhhbXBsZSwgYW4gYW5pbWF0aW9uIGNvbnNpc3Rpbmcgb2YgZWlnaHQgMTAweDEwMFxuXHQgKiBpbWFnZXMgY291bGQgYmUgY29tYmluZWQgaW50byBhIHNpbmdsZSA0MDB4MjAwIHNwcml0ZSBzaGVldCAoNCBmcmFtZXMgYWNyb3NzIGJ5IDIgaGlnaCkuXG5cdCAqXG5cdCAqIFRoZSBkYXRhIHBhc3NlZCB0byB0aGUgU3ByaXRlU2hlZXQgY29uc3RydWN0b3IgZGVmaW5lczo8b2w+XG5cdCAqIFx0PGxpPiBUaGUgc291cmNlIGltYWdlIG9yIGltYWdlcyB0byB1c2UuPC9saT5cblx0ICogXHQ8bGk+IFRoZSBwb3NpdGlvbnMgb2YgaW5kaXZpZHVhbCBpbWFnZSBmcmFtZXMuPC9saT5cblx0ICogXHQ8bGk+IFNlcXVlbmNlcyBvZiBmcmFtZXMgdGhhdCBmb3JtIG5hbWVkIGFuaW1hdGlvbnMuIE9wdGlvbmFsLjwvbGk+XG5cdCAqIFx0PGxpPiBUaGUgdGFyZ2V0IHBsYXliYWNrIGZyYW1lcmF0ZS4gT3B0aW9uYWwuPC9saT5cblx0ICogPC9PTD5cblx0ICpcblx0ICogPGgzPlNwcml0ZVNoZWV0IEZvcm1hdDwvaDM+XG5cdCAqXG5cdCAqIFNwcml0ZVNoZWV0cyBhcmUgYW4gb2JqZWN0IHdpdGggdHdvIHJlcXVpcmVkIHByb3BlcnRpZXMgKGBpbWFnZXNgIGFuZCBgZnJhbWVzYCksIGFuZCB0d28gb3B0aW9uYWwgcHJvcGVydGllc1xuXHQgKiAoYGZyYW1lcmF0ZWAgYW5kIGBhbmltYXRpb25zYCkuIFRoaXMgbWFrZXMgdGhlbSBlYXN5IHRvIGRlZmluZSBpbiBqYXZhc2NyaXB0IGNvZGUsIG9yIGluIEpTT04uXG5cdCAqXG5cdCAqIDxoND5pbWFnZXM8L2g0PlxuXHQgKiBBbiBhcnJheSBvZiBzb3VyY2UgaW1hZ2VzLiBJbWFnZXMgY2FuIGJlIGVpdGhlciBhbiBIVE1MSW1hZ2Vcblx0ICogaW5zdGFuY2UsIG9yIGEgdXJpIHRvIGFuIGltYWdlLiBUaGUgZm9ybWVyIGlzIHJlY29tbWVuZGVkIHRvIGNvbnRyb2wgcHJlbG9hZGluZy5cblx0ICpcblx0ICogXHRpbWFnZXM6IFtpbWFnZTEsIFwicGF0aC90by9pbWFnZTIucG5nXCJdLFxuXHQgKlxuXHQgKiA8aDQ+ZnJhbWVzPC9oND5cblx0ICogRGVmaW5lcyB0aGUgaW5kaXZpZHVhbCBmcmFtZXMuIFRoZXJlIGFyZSB0d28gc3VwcG9ydGVkIGZvcm1hdHMgZm9yIGZyYW1lIGRhdGE6PE9MPlxuXHQgKiA8TEk+IHdoZW4gYWxsIG9mIHRoZSBmcmFtZXMgYXJlIHRoZSBzYW1lIHNpemUgKGluIGEgZ3JpZCksIHVzZSBhbiBvYmplY3Qgd2l0aCBgd2lkdGhgLCBgaGVpZ2h0YCwgYHJlZ1hgLCBgcmVnWWAsIGFuZCBgY291bnRgIHByb3BlcnRpZXMuXG5cdCAqIGB3aWR0aGAgJiBgaGVpZ2h0YCBhcmUgcmVxdWlyZWQgYW5kIHNwZWNpZnkgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGZyYW1lcy5cblx0ICogYHJlZ1hgICYgYHJlZ1lgIGluZGljYXRlIHRoZSByZWdpc3RyYXRpb24gcG9pbnQgb3IgXCJvcmlnaW5cIiBvZiB0aGUgZnJhbWVzLlxuXHQgKiBgc3BhY2luZ2AgaW5kaWNhdGUgdGhlIHNwYWNpbmcgYmV0d2VlbiBmcmFtZXMuXG5cdCAqIGBtYXJnaW5gIHNwZWNpZnkgdGhlIG1hcmdpbiBhcm91bmQgdGhlIGltYWdlKHMpLlxuXHQgKiBgY291bnRgIGFsbG93cyB5b3UgdG8gc3BlY2lmeSB0aGUgdG90YWwgbnVtYmVyIG9mIGZyYW1lcyBpbiB0aGUgc3ByaXRlc2hlZXQ7IGlmIG9taXR0ZWQsIHRoaXMgd2lsbCBiZSBjYWxjdWxhdGVkXG5cdCAqIGJhc2VkIG9uIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBzb3VyY2UgaW1hZ2VzIGFuZCB0aGUgZnJhbWVzLiBGcmFtZXMgd2lsbCBiZSBhc3NpZ25lZCBpbmRleGVzIGJhc2VkIG9uIHRoZWlyIHBvc2l0aW9uXG5cdCAqIGluIHRoZSBzb3VyY2UgaW1hZ2VzIChsZWZ0IHRvIHJpZ2h0LCB0b3AgdG8gYm90dG9tKS5cblx0ICpcblx0ICogXHRmcmFtZXM6IHt3aWR0aDo2NCwgaGVpZ2h0OjY0LCBjb3VudDoyMCwgcmVnWDogMzIsIHJlZ1k6NjQsIHNwYWNpbmc6MCwgbWFyZ2luOjB9XG5cdCAqXG5cdCAqIDxMST4gaWYgdGhlIGZyYW1lcyBhcmUgb2YgZGlmZmVyZW50IHNpemVzLCB1c2UgYW4gYXJyYXkgb2YgZnJhbWUgZGVmaW5pdGlvbnMuIEVhY2ggZGVmaW5pdGlvbiBpcyBpdHNlbGYgYW4gYXJyYXlcblx0ICogd2l0aCA0IHJlcXVpcmVkIGFuZCAzIG9wdGlvbmFsIGVudHJpZXMsIGluIHRoZSBvcmRlcjogYHhgLCBgeWAsIGB3aWR0aGAsIGBoZWlnaHRgLCBgaW1hZ2VJbmRleGAsIGByZWdYYCwgYHJlZ1lgLiBUaGUgZmlyc3Rcblx0ICogZm91ciBlbnRyaWVzIGFyZSByZXF1aXJlZCBhbmQgZGVmaW5lIHRoZSBmcmFtZSByZWN0YW5nbGUuIFRoZSBmaWZ0aCBzcGVjaWZpZXMgdGhlIGluZGV4IG9mIHRoZSBzb3VyY2UgaW1hZ2UgKGRlZmF1bHRzIHRvIDApLiBUaGVcblx0ICogbGFzdCB0d28gc3BlY2lmeSB0aGUgcmVnaXN0cmF0aW9uIHBvaW50IG9mIHRoZSBmcmFtZS5cblx0ICpcblx0ICogXHRmcmFtZXM6IFtcblx0ICogXHRcdC8vIHgsIHksIHdpZHRoLCBoZWlnaHQsIGltYWdlSW5kZXgqLCByZWdYKiwgcmVnWSpcblx0ICogXHRcdFs2NCwgMCwgOTYsIDY0XSxcblx0ICogXHRcdFswLCAwLCA2NCwgNjQsIDEsIDMyLCAzMl1cblx0ICogXHRcdC8vIGV0Yy5cblx0ICogXHRdXG5cdCAqXG5cdCAqIDwvT0w+XG5cdCAqXG5cdCAqIDxoND5hbmltYXRpb25zPC9oND5cblx0ICogT3B0aW9uYWwuIEFuIG9iamVjdCBkZWZpbmluZyBzZXF1ZW5jZXMgb2YgZnJhbWVzIHRvIHBsYXkgYXMgbmFtZWQgYW5pbWF0aW9ucy4gRWFjaCBwcm9wZXJ0eSBjb3JyZXNwb25kcyB0byBhblxuXHQgKiBhbmltYXRpb24gb2YgdGhlIHNhbWUgbmFtZS4gRWFjaCBhbmltYXRpb24gbXVzdCBzcGVjaWZ5IHRoZSBmcmFtZXMgdG8gcGxheSwgYW5kIG1heVxuXHQgKiBhbHNvIGluY2x1ZGUgYSByZWxhdGl2ZSBwbGF5YmFjayBgc3BlZWRgIChleC4gMiB3b3VsZCBwbGF5YmFjayBhdCBkb3VibGUgc3BlZWQsIDAuNSBhdCBoYWxmKSwgYW5kXG5cdCAqIHRoZSBuYW1lIG9mIHRoZSBgbmV4dGAgYW5pbWF0aW9uIHRvIHNlcXVlbmNlIHRvIGFmdGVyIGl0IGNvbXBsZXRlcy5cblx0ICpcblx0ICogVGhlcmUgYXJlIHRocmVlIGZvcm1hdHMgc3VwcG9ydGVkIGZvciBkZWZpbmluZyB0aGUgZnJhbWVzIGluIGFuIGFuaW1hdGlvbiwgd2hpY2ggY2FuIGJlIG1peGVkIGFuZCBtYXRjaGVkIGFzIGFwcHJvcHJpYXRlOjxPTD5cblx0ICogPExJPiBmb3IgYSBzaW5nbGUgZnJhbWUgYW5pbWF0aW9uLCB5b3UgY2FuIHNpbXBseSBzcGVjaWZ5IHRoZSBmcmFtZSBpbmRleFxuXHQgKlxuXHQgKiBcdGFuaW1hdGlvbnM6IHtcblx0ICogXHRcdHNpdDogN1xuXHQgKiBcdH1cblx0ICpcblx0ICogPExJPiBmb3IgYW4gYW5pbWF0aW9uIG9mIGNvbnNlY3V0aXZlIGZyYW1lcywgeW91IGNhbiB1c2UgYW4gYXJyYXkgd2l0aCB0d28gcmVxdWlyZWQsIGFuZCB0d28gb3B0aW9uYWwgZW50cmllc1xuXHQgKiBpbiB0aGUgb3JkZXI6IGBzdGFydGAsIGBlbmRgLCBgbmV4dGAsIGFuZCBgc3BlZWRgLiBUaGlzIHdpbGwgcGxheSB0aGUgZnJhbWVzIGZyb20gc3RhcnQgdG8gZW5kIGluY2x1c2l2ZS5cblx0ICpcblx0ICogXHRhbmltYXRpb25zOiB7XG5cdCAqIFx0XHQvLyBzdGFydCwgZW5kLCBuZXh0Kiwgc3BlZWQqXG5cdCAqIFx0XHRydW46IFswLCA4XSxcblx0ICogXHRcdGp1bXA6IFs5LCAxMiwgXCJydW5cIiwgMl1cblx0ICogXHR9XG5cdCAqXG5cdCAqIDxMST4gZm9yIG5vbi1jb25zZWN1dGl2ZSBmcmFtZXMsIHlvdSBjYW4gdXNlIGFuIG9iamVjdCB3aXRoIGEgYGZyYW1lc2AgcHJvcGVydHkgZGVmaW5pbmcgYW4gYXJyYXkgb2YgZnJhbWUgaW5kZXhlcyB0b1xuXHQgKiBwbGF5IGluIG9yZGVyLiBUaGUgb2JqZWN0IGNhbiBhbHNvIHNwZWNpZnkgYG5leHRgIGFuZCBgc3BlZWRgIHByb3BlcnRpZXMuXG5cdCAqXG5cdCAqIFx0YW5pbWF0aW9uczoge1xuXHQgKiBcdFx0d2Fsazoge1xuXHQgKiBcdFx0XHRmcmFtZXM6IFsxLDIsMywzLDIsMV1cblx0ICogXHRcdH0sXG5cdCAqIFx0XHRzaG9vdDoge1xuXHQgKiBcdFx0XHRmcmFtZXM6IFsxLDQsNSw2XSxcblx0ICogXHRcdFx0bmV4dDogXCJ3YWxrXCIsXG5cdCAqIFx0XHRcdHNwZWVkOiAwLjVcblx0ICogXHRcdH1cblx0ICogXHR9XG5cdCAqXG5cdCAqIDwvT0w+XG5cdCAqIDxzdHJvbmc+Tm90ZTo8L3N0cm9uZz4gdGhlIGBzcGVlZGAgcHJvcGVydHkgd2FzIGFkZGVkIGluIEVhc2VsSlMgMC43LjAuIEVhcmxpZXIgdmVyc2lvbnMgaGFkIGEgYGZyZXF1ZW5jeWBcblx0ICogcHJvcGVydHkgaW5zdGVhZCwgd2hpY2ggd2FzIHRoZSBpbnZlcnNlIG9mIGBzcGVlZGAuIEZvciBleGFtcGxlLCBhIHZhbHVlIG9mIFwiNFwiIHdvdWxkIGJlIDEvNCBub3JtYWwgc3BlZWQgaW4gZWFybGllclxuXHQgKiB2ZXJzaW9ucywgYnV0IGlzIDR4IG5vcm1hbCBzcGVlZCBpbiAwLjcuMCsuXG5cdCAqXG5cdCAqIDxoND5mcmFtZXJhdGU8L2g0PlxuXHQgKiBPcHRpb25hbC4gSW5kaWNhdGVzIHRoZSBkZWZhdWx0IGZyYW1lcmF0ZSB0byBwbGF5IHRoaXMgc3ByaXRlc2hlZXQgYXQgaW4gZnJhbWVzIHBlciBzZWNvbmQuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldC9mcmFtZXJhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqXG5cdCAqIFx0ZnJhbWVyYXRlOiAyMFxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIFRvIGRlZmluZSBhIHNpbXBsZSBzcHJpdGUgc2hlZXQsIHdpdGggYSBzaW5nbGUgaW1hZ2UgXCJzcHJpdGVzLmpwZ1wiIGFycmFuZ2VkIGluIGEgcmVndWxhciA1MHg1MCBncmlkIHdpdGggdGhyZWVcblx0ICogYW5pbWF0aW9uczogXCJzdGFuZFwiIHNob3dpbmcgdGhlIGZpcnN0IGZyYW1lLCBcInJ1blwiIGxvb3BpbmcgZnJhbWUgMS01IGluY2x1c2l2ZSwgYW5kIFwianVtcFwiIHBsYXlpbmcgIGZyYW1lIDYtOCBhbmQgc2VxdWVuY2luZyBiYWNrIHRvIHJ1bi5cblx0ICpcblx0ICogXHR2YXIgZGF0YSA9IHtcblx0ICogXHRcdGltYWdlczogW1wic3ByaXRlcy5qcGdcIl0sXG5cdCAqIFx0XHRmcmFtZXM6IHt3aWR0aDo1MCwgaGVpZ2h0OjUwfSxcblx0ICogXHRcdGFuaW1hdGlvbnM6IHtcblx0ICogXHRcdFx0c3RhbmQ6MCxcblx0ICogXHRcdFx0cnVuOlsxLDVdLFxuXHQgKiBcdFx0XHRqdW1wOls2LDgsXCJydW5cIl1cblx0ICogXHRcdH1cblx0ICogXHR9O1xuXHQgKiBcdHZhciBzcHJpdGVTaGVldCA9IG5ldyBjcmVhdGVqcy5TcHJpdGVTaGVldChkYXRhKTtcblx0ICogXHR2YXIgYW5pbWF0aW9uID0gbmV3IGNyZWF0ZWpzLlNwcml0ZShzcHJpdGVTaGVldCwgXCJydW5cIik7XG5cdCAqXG5cdCAqXG5cdCAqIDxzdHJvbmc+V2FybmluZzo8L3N0cm9uZz4gSW1hZ2VzIGxvYWRlZCBjcm9zcy1vcmlnaW4gd2lsbCB0aHJvdyBjcm9zcy1vcmlnaW4gc2VjdXJpdHkgZXJyb3JzIHdoZW4gaW50ZXJhY3RlZCB3aXRoXG5cdCAqIHVzaW5nIGEgbW91c2UsIHVzaW5nIG1ldGhvZHMgc3VjaCBhcyBgZ2V0T2JqZWN0VW5kZXJQb2ludGAsIHVzaW5nIGZpbHRlcnMsIG9yIGNhY2hpbmcuIFlvdSBjYW4gZ2V0IGFyb3VuZCB0aGlzIGJ5XG5cdCAqIHNldHRpbmcgYGNyb3NzT3JpZ2luYCBmbGFncyBvbiB5b3VyIGltYWdlcyBiZWZvcmUgcGFzc2luZyB0aGVtIHRvIEVhc2VsSlMsIGVnOiBgaW1nLmNyb3NzT3JpZ2luPVwiQW5vbnltb3VzXCI7YFxuXHQgKlxuXHQgKiBAY2xhc3MgU3ByaXRlU2hlZXRcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEFuIG9iamVjdCBkZXNjcmliaW5nIHRoZSBTcHJpdGVTaGVldCBkYXRhLlxuXHQgKiBAZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJcblx0ICoqL1xuXHRmdW5jdGlvbiBTcHJpdGVTaGVldChkYXRhKSB7XG5cdFx0dGhpcy5FdmVudERpc3BhdGNoZXJfY29uc3RydWN0b3IoKTtcblxuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgYWxsIGltYWdlcyBhcmUgZmluaXNoZWQgbG9hZGluZy5cblx0XHQgKiBAcHJvcGVydHkgY29tcGxldGVcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMuY29tcGxldGUgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogU3BlY2lmaWVzIHRoZSBmcmFtZXJhdGUgdG8gdXNlIGJ5IGRlZmF1bHQgZm9yIFNwcml0ZSBpbnN0YW5jZXMgdXNpbmcgdGhlIFNwcml0ZVNoZWV0LiBTZWVcblx0XHQgKiBTcHJpdGUuZnJhbWVyYXRlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBmcmFtZXJhdGVcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5mcmFtZXJhdGUgPSAwO1xuXG5cblx0XHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9hbmltYXRpb25zXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIEFycmF5XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2FuaW1hdGlvbnMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9mcmFtZXNcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgQXJyYXlcblx0XHQgKiovXG5cdFx0dGhpcy5fZnJhbWVzID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfaW1hZ2VzXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIEFycmF5XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2ltYWdlcyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2RhdGFcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2RhdGEgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkQ291bnRcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2xvYWRDb3VudCA9IDA7XG5cblx0XHQvLyBvbmx5IHVzZWQgZm9yIHNpbXBsZSBmcmFtZSBkZWZzOlxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfZnJhbWVIZWlnaHRcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2ZyYW1lSGVpZ2h0ID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfZnJhbWVXaWR0aFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fZnJhbWVXaWR0aCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX251bUZyYW1lc1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fbnVtRnJhbWVzID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmVnWFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fcmVnWCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3JlZ1lcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3JlZ1kgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9zcGFjaW5nXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9zcGFjaW5nID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbWFyZ2luXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9tYXJnaW4gPSAwO1xuXG5cdFx0Ly8gc2V0dXA6XG5cdFx0dGhpcy5fcGFyc2VEYXRhKGRhdGEpO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFNwcml0ZVNoZWV0LCBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cbi8vIGV2ZW50czpcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiBhbGwgaW1hZ2VzIGFyZSBsb2FkZWQuICBOb3RlIHRoYXQgdGhpcyBvbmx5IGZpcmVzIGlmIHRoZSBpbWFnZXNcblx0ICogd2VyZSBub3QgZnVsbHkgbG9hZGVkIHdoZW4gdGhlIHNwcml0ZSBzaGVldCB3YXMgaW5pdGlhbGl6ZWQuIFlvdSBzaG91bGQgY2hlY2sgdGhlIGNvbXBsZXRlIHByb3BlcnR5XG5cdCAqIHRvIHByaW9yIHRvIGFkZGluZyBhIGxpc3RlbmVyLiBFeC5cblx0ICpcblx0ICogXHR2YXIgc2hlZXQgPSBuZXcgU3ByaXRlU2hlZXQoZGF0YSk7XG5cdCAqIFx0aWYgKCFzaGVldC5jb21wbGV0ZSkge1xuXHQgKiBcdFx0Ly8gbm90IHByZWxvYWRlZCwgbGlzdGVuIGZvciB0aGUgY29tcGxldGUgZXZlbnQ6XG5cdCAqIFx0XHRzaGVldC5hZGRFdmVudExpc3RlbmVyKFwiY29tcGxldGVcIiwgaGFuZGxlcik7XG5cdCAqIFx0fVxuXHQgKlxuXHQgKiBAZXZlbnQgY29tcGxldGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiBnZXRGcmFtZSBpcyBjYWxsZWQgd2l0aCBhIHZhbGlkIGZyYW1lIGluZGV4LiBUaGlzIGlzIHByaW1hcmlseSBpbnRlbmRlZCBmb3IgdXNlIGJ5IHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0QnVpbGRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aGVuIGRvaW5nIG9uLWRlbWFuZCByZW5kZXJpbmcuXG5cdCAqIEBldmVudCBnZXRmcmFtZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGZyYW1lIGluZGV4LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZnJhbWUgVGhlIGZyYW1lIG9iamVjdCB0aGF0IGdldEZyYW1lIHdpbGwgcmV0dXJuLlxuXHQgKi9cblxuXG4vLyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldC9hbmltYXRpb25zOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgZ2V0QW5pbWF0aW9uc1xuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRwLmdldEFuaW1hdGlvbnMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYW5pbWF0aW9ucy5zbGljZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBhdmFpbGFibGUgYW5pbWF0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGlzIHNwcml0ZSBzaGVldCBhcyBzdHJpbmdzLlxuXHQgKiBAcHJvcGVydHkgYW5pbWF0aW9uc1xuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMocCwge1xuXHRcdFx0YW5pbWF0aW9uczogeyBnZXQ6IHAuZ2V0QW5pbWF0aW9ucyB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHt9XG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uLCBvciBpbiB0aGUgd2hvbGUgc3ByaXRlXG5cdCAqIHNoZWV0IGlmIHRoZSBhbmltYXRpb24gcGFyYW0gaXMgb21pdHRlZC4gUmV0dXJucyAwIGlmIHRoZSBzcHJpdGVzaGVldCByZWxpZXMgb24gY2FsY3VsYXRlZCBmcmFtZSBjb3VudHMsIGFuZFxuXHQgKiB0aGUgaW1hZ2VzIGhhdmUgbm90IGJlZW4gZnVsbHkgbG9hZGVkLlxuXHQgKiBAbWV0aG9kIGdldE51bUZyYW1lc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gYW5pbWF0aW9uIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gZ2V0IGEgZnJhbWUgY291bnQgZm9yLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBhbmltYXRpb24sIG9yIGluIHRoZSBlbnRpcmUgc3ByaXRlIHNoZWV0IGlmIHRoZSBhbmltYXRpb24gcGFyYW0gaXMgb21pdHRlZC5cblx0ICovXG5cdHAuZ2V0TnVtRnJhbWVzID0gZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG5cdFx0aWYgKGFuaW1hdGlvbiA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZnJhbWVzID8gdGhpcy5fZnJhbWVzLmxlbmd0aCA6IHRoaXMuX251bUZyYW1lcyB8fCAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgZGF0YSA9IHRoaXMuX2RhdGFbYW5pbWF0aW9uXTtcblx0XHRcdGlmIChkYXRhID09IG51bGwpIHsgcmV0dXJuIDA7IH1cblx0XHRcdGVsc2UgeyByZXR1cm4gZGF0YS5mcmFtZXMubGVuZ3RoOyB9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIG9iamVjdCBkZWZpbmluZyB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbi4gVGhlIHJldHVybmVkIG9iamVjdCBjb250YWluczo8VUw+XG5cdCAqIFx0PExJPmZyYW1lczogYW4gYXJyYXkgb2YgdGhlIGZyYW1lIGlkcyBpbiB0aGUgYW5pbWF0aW9uPC9MST5cblx0ICogXHQ8TEk+c3BlZWQ6IHRoZSBwbGF5YmFjayBzcGVlZCBmb3IgdGhpcyBhbmltYXRpb248L0xJPlxuXHQgKiBcdDxMST5uYW1lOiB0aGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uPC9MST5cblx0ICogXHQ8TEk+bmV4dDogdGhlIGRlZmF1bHQgYW5pbWF0aW9uIHRvIHBsYXkgbmV4dC4gSWYgdGhlIGFuaW1hdGlvbiBsb29wcywgdGhlIG5hbWUgYW5kIG5leHQgcHJvcGVydHkgd2lsbCBiZSB0aGVcblx0ICogXHRzYW1lLjwvTEk+XG5cdCAqIDwvVUw+XG5cdCAqIEBtZXRob2QgZ2V0QW5pbWF0aW9uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gZ2V0LlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IGEgZ2VuZXJpYyBvYmplY3Qgd2l0aCBmcmFtZXMsIHNwZWVkLCBuYW1lLCBhbmQgbmV4dCBwcm9wZXJ0aWVzLlxuXHQgKiovXG5cdHAuZ2V0QW5pbWF0aW9uID0gZnVuY3Rpb24obmFtZSkge1xuXHRcdHJldHVybiB0aGlzLl9kYXRhW25hbWVdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIG9iamVjdCBzcGVjaWZ5aW5nIHRoZSBpbWFnZSBhbmQgc291cmNlIHJlY3Qgb2YgdGhlIHNwZWNpZmllZCBmcmFtZS4gVGhlIHJldHVybmVkIG9iamVjdCBoYXM6PFVMPlxuXHQgKiBcdDxMST5hbiBpbWFnZSBwcm9wZXJ0eSBob2xkaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBpbWFnZSBvYmplY3QgaW4gd2hpY2ggdGhlIGZyYW1lIGlzIGZvdW5kPC9MST5cblx0ICogXHQ8TEk+YSByZWN0IHByb3BlcnR5IGNvbnRhaW5pbmcgYSBSZWN0YW5nbGUgaW5zdGFuY2Ugd2hpY2ggZGVmaW5lcyB0aGUgYm91bmRhcmllcyBmb3IgdGhlIGZyYW1lIHdpdGhpbiB0aGF0XG5cdCAqIFx0aW1hZ2UuPC9MST5cblx0ICogXHQ8TEk+IEEgcmVnWCBhbmQgcmVnWSBwcm9wZXJ0eSBjb3JyZXNwb25kaW5nIHRvIHRoZSByZWdYL1kgdmFsdWVzIGZvciB0aGUgZnJhbWUuXG5cdCAqIDwvVUw+XG5cdCAqIEBtZXRob2QgZ2V0RnJhbWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lSW5kZXggVGhlIGluZGV4IG9mIHRoZSBmcmFtZS5cblx0ICogQHJldHVybiB7T2JqZWN0fSBhIGdlbmVyaWMgb2JqZWN0IHdpdGggaW1hZ2UgYW5kIHJlY3QgcHJvcGVydGllcy4gUmV0dXJucyBudWxsIGlmIHRoZSBmcmFtZSBkb2VzIG5vdCBleGlzdC5cblx0ICoqL1xuXHRwLmdldEZyYW1lID0gZnVuY3Rpb24oZnJhbWVJbmRleCkge1xuXHRcdHZhciBmcmFtZTtcblx0XHRpZiAodGhpcy5fZnJhbWVzICYmIChmcmFtZT10aGlzLl9mcmFtZXNbZnJhbWVJbmRleF0pKSB7IHJldHVybiBmcmFtZTsgfVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge3sjY3Jvc3NMaW5rIFwiUmVjdGFuZ2xlXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlIGRlZmluaW5nIHRoZSBib3VuZHMgb2YgdGhlIHNwZWNpZmllZCBmcmFtZSByZWxhdGl2ZVxuXHQgKiB0byB0aGUgb3JpZ2luLiBGb3IgZXhhbXBsZSwgYSA5MCB4IDcwIGZyYW1lIHdpdGggYSByZWdYIG9mIDUwIGFuZCBhIHJlZ1kgb2YgNDAgd291bGQgcmV0dXJuOlxuXHQgKlxuXHQgKiBcdFt4PS01MCwgeT0tNDAsIHdpZHRoPTkwLCBoZWlnaHQ9NzBdXG5cdCAqXG5cdCAqIEBtZXRob2QgZ2V0RnJhbWVCb3VuZHNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lSW5kZXggVGhlIGluZGV4IG9mIHRoZSBmcmFtZS5cblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IFtyZWN0YW5nbGVdIEEgUmVjdGFuZ2xlIGluc3RhbmNlIHRvIGNvcHkgdGhlIHZhbHVlcyBpbnRvLiBCeSBkZWZhdWx0IGEgbmV3IGluc3RhbmNlIGlzIGNyZWF0ZWQuXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gQSBSZWN0YW5nbGUgaW5zdGFuY2UuIFJldHVybnMgbnVsbCBpZiB0aGUgZnJhbWUgZG9lcyBub3QgZXhpc3QsIG9yIHRoZSBpbWFnZSBpcyBub3QgZnVsbHkgbG9hZGVkLlxuXHQgKiovXG5cdHAuZ2V0RnJhbWVCb3VuZHMgPSBmdW5jdGlvbihmcmFtZUluZGV4LCByZWN0YW5nbGUpIHtcblx0XHR2YXIgZnJhbWUgPSB0aGlzLmdldEZyYW1lKGZyYW1lSW5kZXgpO1xuXHRcdHJldHVybiBmcmFtZSA/IChyZWN0YW5nbGV8fG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoKSkuc2V0VmFsdWVzKC1mcmFtZS5yZWdYLCAtZnJhbWUucmVnWSwgZnJhbWUucmVjdC53aWR0aCwgZnJhbWUucmVjdC5oZWlnaHQpIDogbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1Nwcml0ZVNoZWV0XVwiO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcHJpdGVTaGVldCBjYW5ub3QgYmUgY2xvbmVkLiBBIFNwcml0ZVNoZWV0IGNhbiBiZSBzaGFyZWQgYnkgbXVsdGlwbGUgU3ByaXRlIGluc3RhbmNlcyB3aXRob3V0IGNsb25pbmcgaXQuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3coXCJTcHJpdGVTaGVldCBjYW5ub3QgYmUgY2xvbmVkLlwiKVxuXHR9O1xuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9wYXJzZURhdGFcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIFNwcml0ZVNoZWV0IGRhdGEuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9wYXJzZURhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG5cdFx0dmFyIGksbCxvLGE7XG5cdFx0aWYgKGRhdGEgPT0gbnVsbCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuZnJhbWVyYXRlID0gZGF0YS5mcmFtZXJhdGV8fDA7XG5cblx0XHQvLyBwYXJzZSBpbWFnZXM6XG5cdFx0aWYgKGRhdGEuaW1hZ2VzICYmIChsPWRhdGEuaW1hZ2VzLmxlbmd0aCkgPiAwKSB7XG5cdFx0XHRhID0gdGhpcy5faW1hZ2VzID0gW107XG5cdFx0XHRmb3IgKGk9MDsgaTxsOyBpKyspIHtcblx0XHRcdFx0dmFyIGltZyA9IGRhdGEuaW1hZ2VzW2ldO1xuXHRcdFx0XHRpZiAodHlwZW9mIGltZyA9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdFx0dmFyIHNyYyA9IGltZztcblx0XHRcdFx0XHRpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuXHRcdFx0XHRcdGltZy5zcmMgPSBzcmM7XG5cdFx0XHRcdH1cblx0XHRcdFx0YS5wdXNoKGltZyk7XG5cdFx0XHRcdGlmICghaW1nLmdldENvbnRleHQgJiYgIWltZy5uYXR1cmFsV2lkdGgpIHtcblx0XHRcdFx0XHR0aGlzLl9sb2FkQ291bnQrKztcblx0XHRcdFx0XHR0aGlzLmNvbXBsZXRlID0gZmFsc2U7XG5cdFx0XHRcdFx0KGZ1bmN0aW9uKG8pIHsgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyBvLl9oYW5kbGVJbWFnZUxvYWQoKTsgfSB9KSh0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHBhcnNlIGZyYW1lczpcblx0XHRpZiAoZGF0YS5mcmFtZXMgPT0gbnVsbCkgeyAvLyBub3RoaW5nXG5cdFx0fSBlbHNlIGlmIChkYXRhLmZyYW1lcyBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHR0aGlzLl9mcmFtZXMgPSBbXTtcblx0XHRcdGEgPSBkYXRhLmZyYW1lcztcblx0XHRcdGZvciAoaT0wLGw9YS5sZW5ndGg7aTxsO2krKykge1xuXHRcdFx0XHR2YXIgYXJyID0gYVtpXTtcblx0XHRcdFx0dGhpcy5fZnJhbWVzLnB1c2goe2ltYWdlOnRoaXMuX2ltYWdlc1thcnJbNF0/YXJyWzRdOjBdLCByZWN0Om5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoYXJyWzBdLGFyclsxXSxhcnJbMl0sYXJyWzNdKSwgcmVnWDphcnJbNV18fDAsIHJlZ1k6YXJyWzZdfHwwIH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvID0gZGF0YS5mcmFtZXM7XG5cdFx0XHR0aGlzLl9mcmFtZVdpZHRoID0gby53aWR0aDtcblx0XHRcdHRoaXMuX2ZyYW1lSGVpZ2h0ID0gby5oZWlnaHQ7XG5cdFx0XHR0aGlzLl9yZWdYID0gby5yZWdYfHwwO1xuXHRcdFx0dGhpcy5fcmVnWSA9IG8ucmVnWXx8MDtcblx0XHRcdHRoaXMuX3NwYWNpbmcgPSBvLnNwYWNpbmd8fDA7XG5cdFx0XHR0aGlzLl9tYXJnaW4gPSBvLm1hcmdpbnx8MDtcblx0XHRcdHRoaXMuX251bUZyYW1lcyA9IG8uY291bnQ7XG5cdFx0XHRpZiAodGhpcy5fbG9hZENvdW50ID09IDApIHsgdGhpcy5fY2FsY3VsYXRlRnJhbWVzKCk7IH1cblx0XHR9XG5cblx0XHQvLyBwYXJzZSBhbmltYXRpb25zOlxuXHRcdHRoaXMuX2FuaW1hdGlvbnMgPSBbXTtcblx0XHRpZiAoKG89ZGF0YS5hbmltYXRpb25zKSAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl9kYXRhID0ge307XG5cdFx0XHR2YXIgbmFtZTtcblx0XHRcdGZvciAobmFtZSBpbiBvKSB7XG5cdFx0XHRcdHZhciBhbmltID0ge25hbWU6bmFtZX07XG5cdFx0XHRcdHZhciBvYmogPSBvW25hbWVdO1xuXHRcdFx0XHRpZiAodHlwZW9mIG9iaiA9PSBcIm51bWJlclwiKSB7IC8vIHNpbmdsZSBmcmFtZVxuXHRcdFx0XHRcdGEgPSBhbmltLmZyYW1lcyA9IFtvYmpdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5KSB7IC8vIHNpbXBsZVxuXHRcdFx0XHRcdGlmIChvYmoubGVuZ3RoID09IDEpIHsgYW5pbS5mcmFtZXMgPSBbb2JqWzBdXTsgfVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0YW5pbS5zcGVlZCA9IG9ialszXTtcblx0XHRcdFx0XHRcdGFuaW0ubmV4dCA9IG9ialsyXTtcblx0XHRcdFx0XHRcdGEgPSBhbmltLmZyYW1lcyA9IFtdO1xuXHRcdFx0XHRcdFx0Zm9yIChpPW9ialswXTtpPD1vYmpbMV07aSsrKSB7XG5cdFx0XHRcdFx0XHRcdGEucHVzaChpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7IC8vIGNvbXBsZXhcblx0XHRcdFx0XHRhbmltLnNwZWVkID0gb2JqLnNwZWVkO1xuXHRcdFx0XHRcdGFuaW0ubmV4dCA9IG9iai5uZXh0O1xuXHRcdFx0XHRcdHZhciBmcmFtZXMgPSBvYmouZnJhbWVzO1xuXHRcdFx0XHRcdGEgPSBhbmltLmZyYW1lcyA9ICh0eXBlb2YgZnJhbWVzID09IFwibnVtYmVyXCIpID8gW2ZyYW1lc10gOiBmcmFtZXMuc2xpY2UoMCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGFuaW0ubmV4dCA9PT0gdHJ1ZSB8fCBhbmltLm5leHQgPT09IHVuZGVmaW5lZCkgeyBhbmltLm5leHQgPSBuYW1lOyB9IC8vIGxvb3Bcblx0XHRcdFx0aWYgKGFuaW0ubmV4dCA9PT0gZmFsc2UgfHwgKGEubGVuZ3RoIDwgMiAmJiBhbmltLm5leHQgPT0gbmFtZSkpIHsgYW5pbS5uZXh0ID0gbnVsbDsgfSAvLyBzdG9wXG5cdFx0XHRcdGlmICghYW5pbS5zcGVlZCkgeyBhbmltLnNwZWVkID0gMTsgfVxuXHRcdFx0XHR0aGlzLl9hbmltYXRpb25zLnB1c2gobmFtZSk7XG5cdFx0XHRcdHRoaXMuX2RhdGFbbmFtZV0gPSBhbmltO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlSW1hZ2VMb2FkXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9oYW5kbGVJbWFnZUxvYWQgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoLS10aGlzLl9sb2FkQ291bnQgPT0gMCkge1xuXHRcdFx0dGhpcy5fY2FsY3VsYXRlRnJhbWVzKCk7XG5cdFx0XHR0aGlzLmNvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfY2FsY3VsYXRlRnJhbWVzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9jYWxjdWxhdGVGcmFtZXMgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fZnJhbWVzIHx8IHRoaXMuX2ZyYW1lV2lkdGggPT0gMCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2ZyYW1lcyA9IFtdO1xuXG5cdFx0dmFyIG1heEZyYW1lcyA9IHRoaXMuX251bUZyYW1lcyB8fCAxMDAwMDA7IC8vIGlmIHdlIGdvIG92ZXIgdGhpcywgc29tZXRoaW5nIGlzIHdyb25nLlxuXHRcdHZhciBmcmFtZUNvdW50ID0gMCwgZnJhbWVXaWR0aCA9IHRoaXMuX2ZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0ID0gdGhpcy5fZnJhbWVIZWlnaHQ7XG5cdFx0dmFyIHNwYWNpbmcgPSB0aGlzLl9zcGFjaW5nLCBtYXJnaW4gPSB0aGlzLl9tYXJnaW47XG5cdFx0XG5cdFx0aW1nTG9vcDpcblx0XHRmb3IgKHZhciBpPTAsIGltZ3M9dGhpcy5faW1hZ2VzOyBpPGltZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpbWcgPSBpbWdzW2ldLCBpbWdXID0gaW1nLndpZHRoLCBpbWdIID0gaW1nLmhlaWdodDtcblxuXHRcdFx0dmFyIHkgPSBtYXJnaW47XG5cdFx0XHR3aGlsZSAoeSA8PSBpbWdILW1hcmdpbi1mcmFtZUhlaWdodCkge1xuXHRcdFx0XHR2YXIgeCA9IG1hcmdpbjtcblx0XHRcdFx0d2hpbGUgKHggPD0gaW1nVy1tYXJnaW4tZnJhbWVXaWR0aCkge1xuXHRcdFx0XHRcdGlmIChmcmFtZUNvdW50ID49IG1heEZyYW1lcykgeyBicmVhayBpbWdMb29wOyB9XG5cdFx0XHRcdFx0ZnJhbWVDb3VudCsrO1xuXHRcdFx0XHRcdHRoaXMuX2ZyYW1lcy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0aW1hZ2U6IGltZyxcblx0XHRcdFx0XHRcdFx0cmVjdDogbmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSh4LCB5LCBmcmFtZVdpZHRoLCBmcmFtZUhlaWdodCksXG5cdFx0XHRcdFx0XHRcdHJlZ1g6IHRoaXMuX3JlZ1gsXG5cdFx0XHRcdFx0XHRcdHJlZ1k6IHRoaXMuX3JlZ1lcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHggKz0gZnJhbWVXaWR0aCtzcGFjaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHkgKz0gZnJhbWVIZWlnaHQrc3BhY2luZztcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fbnVtRnJhbWVzID0gZnJhbWVDb3VudDtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLlNwcml0ZVNoZWV0ID0gY3JlYXRlanMucHJvbW90ZShTcHJpdGVTaGVldCwgXCJFdmVudERpc3BhdGNoZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gR3JhcGhpY3MuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFRoZSBHcmFwaGljcyBjbGFzcyBleHBvc2VzIGFuIGVhc3kgdG8gdXNlIEFQSSBmb3IgZ2VuZXJhdGluZyB2ZWN0b3IgZHJhd2luZyBpbnN0cnVjdGlvbnMgYW5kIGRyYXdpbmcgdGhlbSB0byBhXG5cdCAqIHNwZWNpZmllZCBjb250ZXh0LiBOb3RlIHRoYXQgeW91IGNhbiB1c2UgR3JhcGhpY3Mgd2l0aG91dCBhbnkgZGVwZW5kZW5jeSBvbiB0aGUgRWFzZWxKUyBmcmFtZXdvcmsgYnkgY2FsbGluZyB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGRpcmVjdGx5LCBvciBpdCBjYW4gYmUgdXNlZCB3aXRoIHRoZSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSBvYmplY3QgdG8gZHJhdyB2ZWN0b3IgZ3JhcGhpY3Mgd2l0aGluIHRoZVxuXHQgKiBjb250ZXh0IG9mIGFuIEVhc2VsSlMgZGlzcGxheSBsaXN0LlxuXHQgKlxuXHQgKiBUaGVyZSBhcmUgdHdvIGFwcHJvYWNoZXMgdG8gd29ya2luZyB3aXRoIEdyYXBoaWNzIG9iamVjdDogY2FsbGluZyBtZXRob2RzIG9uIGEgR3JhcGhpY3MgaW5zdGFuY2UgKHRoZSBcIkdyYXBoaWNzIEFQSVwiKSwgb3Jcblx0ICogaW5zdGFudGlhdGluZyBHcmFwaGljcyBjb21tYW5kIG9iamVjdHMgYW5kIGFkZGluZyB0aGVtIHRvIHRoZSBncmFwaGljcyBxdWV1ZSB2aWEge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBUaGUgZm9ybWVyIGFic3RyYWN0cyB0aGUgbGF0dGVyLCBzaW1wbGlmeWluZyBiZWdpbm5pbmcgYW5kIGVuZGluZyBwYXRocywgZmlsbHMsIGFuZCBzdHJva2VzLlxuXHQgKlxuXHQgKiAgICAgIHZhciBnID0gbmV3IGNyZWF0ZWpzLkdyYXBoaWNzKCk7XG5cdCAqICAgICAgZy5zZXRTdHJva2VTdHlsZSgxKTtcblx0ICogICAgICBnLmJlZ2luU3Ryb2tlKFwiIzAwMDAwMFwiKTtcblx0ICogICAgICBnLmJlZ2luRmlsbChcInJlZFwiKTtcblx0ICogICAgICBnLmRyYXdDaXJjbGUoMCwwLDMwKTtcblx0ICpcblx0ICogQWxsIGRyYXdpbmcgbWV0aG9kcyBpbiBHcmFwaGljcyByZXR1cm4gdGhlIEdyYXBoaWNzIGluc3RhbmNlLCBzbyB0aGV5IGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLiBGb3IgZXhhbXBsZSxcblx0ICogdGhlIGZvbGxvd2luZyBsaW5lIG9mIGNvZGUgd291bGQgZ2VuZXJhdGUgdGhlIGluc3RydWN0aW9ucyB0byBkcmF3IGEgcmVjdGFuZ2xlIHdpdGggYSByZWQgc3Ryb2tlIGFuZCBibHVlIGZpbGw6XG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5iZWdpblN0cm9rZShcInJlZFwiKS5iZWdpbkZpbGwoXCJibHVlXCIpLmRyYXdSZWN0KDIwLCAyMCwgMTAwLCA1MCk7XG5cdCAqXG5cdCAqIEVhY2ggZ3JhcGhpY3MgQVBJIGNhbGwgZ2VuZXJhdGVzIGEgY29tbWFuZCBvYmplY3QgKHNlZSBiZWxvdykuIFRoZSBsYXN0IGNvbW1hbmQgdG8gYmUgY3JlYXRlZCBjYW4gYmUgYWNjZXNzZWQgdmlhXG5cdCAqIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2NvbW1hbmQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06XG5cdCAqXG5cdCAqICAgICAgdmFyIGZpbGxDb21tYW5kID0gbXlHcmFwaGljcy5iZWdpbkZpbGwoXCJyZWRcIikuY29tbWFuZDtcblx0ICogICAgICAvLyAuLi4gbGF0ZXIsIHVwZGF0ZSB0aGUgZmlsbCBzdHlsZS9jb2xvcjpcblx0ICogICAgICBmaWxsQ29tbWFuZC5zdHlsZSA9IFwiYmx1ZVwiO1xuXHQgKiAgICAgIC8vIG9yIGNoYW5nZSBpdCB0byBhIGJpdG1hcCBmaWxsOlxuXHQgKiAgICAgIGZpbGxDb21tYW5kLmJpdG1hcChteUltYWdlKTtcblx0ICpcblx0ICogRm9yIG1vcmUgZGlyZWN0IGNvbnRyb2wgb2YgcmVuZGVyaW5nLCB5b3UgY2FuIGluc3RhbnRpYXRlIGFuZCBhcHBlbmQgY29tbWFuZCBvYmplY3RzIHRvIHRoZSBncmFwaGljcyBxdWV1ZSBkaXJlY3RseS4gSW4gdGhpcyBjYXNlLCB5b3Vcblx0ICogbmVlZCB0byBtYW5hZ2UgcGF0aCBjcmVhdGlvbiBtYW51YWxseSwgYW5kIGVuc3VyZSB0aGF0IGZpbGwvc3Ryb2tlIGlzIGFwcGxpZWQgdG8gYSBkZWZpbmVkIHBhdGg6XG5cdCAqXG5cdCAqICAgICAgLy8gc3RhcnQgYSBuZXcgcGF0aC4gR3JhcGhpY3MuYmVnaW5DbWQgaXMgYSByZXVzYWJsZSBCZWdpblBhdGggaW5zdGFuY2U6XG5cdCAqICAgICAgbXlHcmFwaGljcy5hcHBlbmQoY3JlYXRlanMuR3JhcGhpY3MuYmVnaW5DbWQpO1xuXHQgKiAgICAgIC8vIHdlIG5lZWQgdG8gZGVmaW5lIHRoZSBwYXRoIGJlZm9yZSBhcHBseWluZyB0aGUgZmlsbDpcblx0ICogICAgICB2YXIgY2lyY2xlID0gbmV3IGNyZWF0ZWpzLkdyYXBoaWNzLkNpcmNsZSgwLDAsMzApO1xuXHQgKiAgICAgIG15R3JhcGhpY3MuYXBwZW5kKGNpcmNsZSk7XG5cdCAqICAgICAgLy8gZmlsbCB0aGUgcGF0aCB3ZSBqdXN0IGRlZmluZWQ6XG5cdCAqICAgICAgdmFyIGZpbGwgPSBuZXcgY3JlYXRlanMuR3JhcGhpY3MuRmlsbChcInJlZFwiKTtcblx0ICogICAgICBteUdyYXBoaWNzLmFwcGVuZChmaWxsKTtcblx0ICpcblx0ICogVGhlc2UgYXBwcm9hY2hlcyBjYW4gYmUgdXNlZCB0b2dldGhlciwgZm9yIGV4YW1wbGUgdG8gaW5zZXJ0IGEgY3VzdG9tIGNvbW1hbmQ6XG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5iZWdpbkZpbGwoXCJyZWRcIik7XG5cdCAqICAgICAgdmFyIGN1c3RvbUNvbW1hbmQgPSBuZXcgQ3VzdG9tU3BpcmFsQ29tbWFuZChldGMpO1xuXHQgKiAgICAgIG15R3JhcGhpY3MuYXBwZW5kKGN1c3RvbUNvbW1hbmQpO1xuXHQgKiAgICAgIG15R3JhcGhpY3MuYmVnaW5GaWxsKFwiYmx1ZVwiKTtcblx0ICogICAgICBteUdyYXBoaWNzLmRyYXdDaXJjbGUoMCwgMCwgMzApO1xuXHQgKlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm8gb24gY3JlYXRpbmcgY3VzdG9tIGNvbW1hbmRzLlxuXHQgKlxuXHQgKiA8aDQ+VGlueSBBUEk8L2g0PlxuXHQgKiBUaGUgR3JhcGhpY3MgY2xhc3MgYWxzbyBpbmNsdWRlcyBhIFwidGlueSBBUElcIiwgd2hpY2ggaXMgb25lIG9yIHR3by1sZXR0ZXIgbWV0aG9kcyB0aGF0IGFyZSBzaG9ydGN1dHMgZm9yIGFsbCBvZiB0aGVcblx0ICogR3JhcGhpY3MgbWV0aG9kcy4gVGhlc2UgbWV0aG9kcyBhcmUgZ3JlYXQgZm9yIGNyZWF0aW5nIGNvbXBhY3QgaW5zdHJ1Y3Rpb25zLCBhbmQgaXMgdXNlZCBieSB0aGUgVG9vbGtpdCBmb3IgQ3JlYXRlSlNcblx0ICogdG8gZ2VuZXJhdGUgcmVhZGFibGUgY29kZS4gQWxsIHRpbnkgbWV0aG9kcyBhcmUgbWFya2VkIGFzIHByb3RlY3RlZCwgc28geW91IGNhbiB2aWV3IHRoZW0gYnkgZW5hYmxpbmcgcHJvdGVjdGVkXG5cdCAqIGRlc2NyaXB0aW9ucyBpbiB0aGUgZG9jcy5cblx0ICpcblx0ICogPHRhYmxlPlxuXHQgKiAgICAgPHRyPjx0ZD48Yj5UaW55PC9iPjwvdGQ+PHRkPjxiPk1ldGhvZDwvYj48L3RkPjx0ZD48Yj5UaW55PC9iPjwvdGQ+PHRkPjxiPk1ldGhvZDwvYj48L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPm10PC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvbW92ZVRvXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+bHQ8L3RkPiA8dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvbGluZVRvXCJ9fXt7L2Nyb3NzTGlua319PC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5hL2F0PC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXJjXCJ9fXt7L2Nyb3NzTGlua319IC8ge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXJjVG9cIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5idDwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlemllckN1cnZlVG9cIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5xdDwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3F1YWRyYXRpY0N1cnZlVG9cIn19e3svY3Jvc3NMaW5rfX0gKGFsc28gY3VydmVUbyk8L3RkPlxuXHQgKiAgICAgPHRkPnI8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9yZWN0XCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+Y3A8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9jbG9zZVBhdGhcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5jPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvY2xlYXJcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5mPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5GaWxsXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+bGY8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkxpbmVhckdyYWRpZW50RmlsbFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPnJmPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5SYWRpYWxHcmFkaWVudEZpbGxcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5iZjwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luQml0bWFwRmlsbFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPmVmPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZW5kRmlsbFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPnNzIC8gc2Q8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9zZXRTdHJva2VTdHlsZVwifX17ey9jcm9zc0xpbmt9fSAvIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3NldFN0cm9rZURhc2hcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5zPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5TdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5sczwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luTGluZWFyR3JhZGllbnRTdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5yczwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luUmFkaWFsR3JhZGllbnRTdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5iczwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luQml0bWFwU3Ryb2tlXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+ZXM8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9lbmRTdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5kcjwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdSZWN0XCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+cnI8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Um91bmRSZWN0XCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+cmM8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Um91bmRSZWN0Q29tcGxleFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPmRjPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd0NpcmNsZVwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPmRlPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd0VsbGlwc2VcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5kcDwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdQb2x5U3RhclwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPnA8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kZWNvZGVQYXRoXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogPC90YWJsZT5cblx0ICpcblx0ICogSGVyZSBpcyB0aGUgYWJvdmUgZXhhbXBsZSwgdXNpbmcgdGhlIHRpbnkgQVBJIGluc3RlYWQuXG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5zKFwicmVkXCIpLmYoXCJibHVlXCIpLnIoMjAsIDIwLCAxMDAsIDUwKTtcblx0ICpcblx0ICogQGNsYXNzIEdyYXBoaWNzXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIEdyYXBoaWNzKCkge1xuXG5cblx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBIb2xkcyBhIHJlZmVyZW5jZSB0byB0aGUgbGFzdCBjb21tYW5kIHRoYXQgd2FzIGNyZWF0ZWQgb3IgYXBwZW5kZWQuIEZvciBleGFtcGxlLCB5b3UgY291bGQgcmV0YWluIGEgcmVmZXJlbmNlXG5cdFx0ICogdG8gYSBGaWxsIGNvbW1hbmQgaW4gb3JkZXIgdG8gZHluYW1pY2FsbHkgdXBkYXRlIHRoZSBjb2xvciBsYXRlciBieSB1c2luZzpcblx0XHQgKiBcdFx0bXlGaWxsID0gbXlHcmFwaGljcy5iZWdpbkZpbGwoXCJyZWRcIikuY29tbWFuZDtcblx0XHQgKiBcdFx0Ly8gdXBkYXRlIGNvbG9yIGxhdGVyOlxuXHRcdCAqIFx0XHRteUZpbGwuc3R5bGUgPSBcInllbGxvd1wiO1xuXHRcdCAqIEBwcm9wZXJ0eSBjb21tYW5kXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICoqL1xuXHRcdHRoaXMuY29tbWFuZCA9IG51bGw7XG5cblxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3N0cm9rZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7U3Ryb2tlfVxuXHRcdCAqKi9cblx0XHR0aGlzLl9zdHJva2UgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9zdHJva2VTdHlsZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7U3Ryb2tlU3R5bGV9XG5cdFx0ICoqL1xuXHRcdHRoaXMuX3N0cm9rZVN0eWxlID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX29sZFN0cm9rZVN0eWxlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtTdHJva2VTdHlsZX1cblx0XHQgKiovXG5cdFx0dGhpcy5fb2xkU3Ryb2tlU3R5bGUgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfc3Ryb2tlRGFzaFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7U3Ryb2tlRGFzaH1cblx0XHQgKiovXG5cdFx0dGhpcy5fc3Ryb2tlRGFzaCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9vbGRTdHJva2VEYXNoXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtTdHJva2VEYXNofVxuXHRcdCAqKi9cblx0XHR0aGlzLl9vbGRTdHJva2VEYXNoID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfc3Ryb2tlSWdub3JlU2NhbGVcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqKi9cblx0XHR0aGlzLl9zdHJva2VJZ25vcmVTY2FsZSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9maWxsXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtGaWxsfVxuXHRcdCAqKi9cblx0XHR0aGlzLl9maWxsID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfaW5zdHJ1Y3Rpb25zXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiovXG5cdFx0dGhpcy5faW5zdHJ1Y3Rpb25zID0gW107XG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgdGhlIGxhc3QgaW5zdHJ1Y3Rpb24gaW5kZXggdGhhdCB3YXMgY29tbWl0dGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfY29tbWl0SW5kZXhcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiovXG5cdFx0dGhpcy5fY29tbWl0SW5kZXggPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVW5jb21taXR0ZWQgaW5zdHJ1Y3Rpb25zLlxuXHRcdCAqIEBwcm9wZXJ0eSBfYWN0aXZlSW5zdHJ1Y3Rpb25zXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiovXG5cdFx0dGhpcy5fYWN0aXZlSW5zdHJ1Y3Rpb25zID0gW107XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGluZGljYXRlcyB0aGF0IHRoZXJlIGhhdmUgYmVlbiBjaGFuZ2VzIHRvIHRoZSBhY3RpdmVJbnN0cnVjdGlvbiBsaXN0IHNpbmNlIHRoZSBsYXN0IHVwZGF0ZUluc3RydWN0aW9ucyBjYWxsLlxuXHRcdCAqIEBwcm9wZXJ0eSBfZGlydHlcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiovXG5cdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEluZGV4IHRvIGRyYXcgZnJvbSBpZiBhIHN0b3JlIG9wZXJhdGlvbiBoYXMgaGFwcGVuZWQuXG5cdFx0ICogQHByb3BlcnR5IF9zdG9yZUluZGV4XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLl9zdG9yZUluZGV4ID0gMDtcblxuXHQvLyBzZXR1cDpcblx0XHR0aGlzLmNsZWFyKCk7XG5cdH1cblx0dmFyIHAgPSBHcmFwaGljcy5wcm90b3R5cGU7XG5cdHZhciBHID0gR3JhcGhpY3M7IC8vIHNob3J0Y3V0XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cbi8vIHN0YXRpYyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgYSBDU1MgY29tcGF0aWJsZSBjb2xvciBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBSR0IgbnVtZXJpYyBjb2xvciB2YWx1ZXMgaW4gdGhlIGZvcm1hdFxuXHQgKiBcInJnYmEoMjU1LDI1NSwyNTUsMS4wKVwiLCBvciBpZiBhbHBoYSBpcyBudWxsIHRoZW4gaW4gdGhlIGZvcm1hdCBcInJnYigyNTUsMjU1LDI1NSlcIi4gRm9yIGV4YW1wbGUsXG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuR3JhcGhpY3MuZ2V0UkdCKDUwLCAxMDAsIDE1MCwgMC41KTtcblx0ICogICAgICAvLyBSZXR1cm5zIFwicmdiYSg1MCwxMDAsMTUwLDAuNSlcIlxuXHQgKlxuXHQgKiBJdCBhbHNvIHN1cHBvcnRzIHBhc3NpbmcgYSBzaW5nbGUgaGV4IGNvbG9yIHZhbHVlIGFzIHRoZSBmaXJzdCBwYXJhbSwgYW5kIGFuIG9wdGlvbmFsIGFscGhhIHZhbHVlIGFzIHRoZSBzZWNvbmRcblx0ICogcGFyYW0uIEZvciBleGFtcGxlLFxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLkdyYXBoaWNzLmdldFJHQigweEZGMDBGRiwgMC4yKTtcblx0ICogICAgICAvLyBSZXR1cm5zIFwicmdiYSgyNTUsMCwyNTUsMC4yKVwiXG5cdCAqXG5cdCAqIEBtZXRob2QgZ2V0UkdCXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIgVGhlIHJlZCBjb21wb25lbnQgZm9yIHRoZSBjb2xvciwgYmV0d2VlbiAwIGFuZCAweEZGICgyNTUpLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZyBUaGUgZ3JlZW4gY29tcG9uZW50IGZvciB0aGUgY29sb3IsIGJldHdlZW4gMCBhbmQgMHhGRiAoMjU1KS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIGJsdWUgY29tcG9uZW50IGZvciB0aGUgY29sb3IsIGJldHdlZW4gMCBhbmQgMHhGRiAoMjU1KS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthbHBoYV0gVGhlIGFscGhhIGNvbXBvbmVudCBmb3IgdGhlIGNvbG9yIHdoZXJlIDAgaXMgZnVsbHkgdHJhbnNwYXJlbnQgYW5kIDEgaXMgZnVsbHkgb3BhcXVlLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IEEgQ1NTIGNvbXBhdGlibGUgY29sb3Igc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgUkdCIG51bWVyaWMgY29sb3IgdmFsdWVzIGluIHRoZSBmb3JtYXRcblx0ICogXCJyZ2JhKDI1NSwyNTUsMjU1LDEuMClcIiwgb3IgaWYgYWxwaGEgaXMgbnVsbCB0aGVuIGluIHRoZSBmb3JtYXQgXCJyZ2IoMjU1LDI1NSwyNTUpXCIuXG5cdCAqKi9cblx0R3JhcGhpY3MuZ2V0UkdCID0gZnVuY3Rpb24ociwgZywgYiwgYWxwaGEpIHtcblx0XHRpZiAociAhPSBudWxsICYmIGIgPT0gbnVsbCkge1xuXHRcdFx0YWxwaGEgPSBnO1xuXHRcdFx0YiA9IHImMHhGRjtcblx0XHRcdGcgPSByPj44JjB4RkY7XG5cdFx0XHRyID0gcj4+MTYmMHhGRjtcblx0XHR9XG5cdFx0aWYgKGFscGhhID09IG51bGwpIHtcblx0XHRcdHJldHVybiBcInJnYihcIityK1wiLFwiK2crXCIsXCIrYitcIilcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFwicmdiYShcIityK1wiLFwiK2crXCIsXCIrYitcIixcIithbHBoYStcIilcIjtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBDU1MgY29tcGF0aWJsZSBjb2xvciBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBIU0wgbnVtZXJpYyBjb2xvciB2YWx1ZXMgaW4gdGhlIGZvcm1hdCBcImhzbGEoMzYwLDEwMCwxMDAsMS4wKVwiLFxuXHQgKiBvciBpZiBhbHBoYSBpcyBudWxsIHRoZW4gaW4gdGhlIGZvcm1hdCBcImhzbCgzNjAsMTAwLDEwMClcIi5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5HcmFwaGljcy5nZXRIU0woMTUwLCAxMDAsIDcwKTtcblx0ICogICAgICAvLyBSZXR1cm5zIFwiaHNsKDE1MCwxMDAsNzApXCJcblx0ICpcblx0ICogQG1ldGhvZCBnZXRIU0xcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaHVlIFRoZSBodWUgY29tcG9uZW50IGZvciB0aGUgY29sb3IsIGJldHdlZW4gMCBhbmQgMzYwLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvbiBUaGUgc2F0dXJhdGlvbiBjb21wb25lbnQgZm9yIHRoZSBjb2xvciwgYmV0d2VlbiAwIGFuZCAxMDAuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsaWdodG5lc3MgVGhlIGxpZ2h0bmVzcyBjb21wb25lbnQgZm9yIHRoZSBjb2xvciwgYmV0d2VlbiAwIGFuZCAxMDAuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYWxwaGFdIFRoZSBhbHBoYSBjb21wb25lbnQgZm9yIHRoZSBjb2xvciB3aGVyZSAwIGlzIGZ1bGx5IHRyYW5zcGFyZW50IGFuZCAxIGlzIGZ1bGx5IG9wYXF1ZS5cblx0ICogQHJldHVybiB7U3RyaW5nfSBBIENTUyBjb21wYXRpYmxlIGNvbG9yIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIEhTTCBudW1lcmljIGNvbG9yIHZhbHVlcyBpbiB0aGUgZm9ybWF0XG5cdCAqIFwiaHNsYSgzNjAsMTAwLDEwMCwxLjApXCIsIG9yIGlmIGFscGhhIGlzIG51bGwgdGhlbiBpbiB0aGUgZm9ybWF0IFwiaHNsKDM2MCwxMDAsMTAwKVwiLlxuXHQgKiovXG5cdEdyYXBoaWNzLmdldEhTTCA9IGZ1bmN0aW9uKGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBhbHBoYSkge1xuXHRcdGlmIChhbHBoYSA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gXCJoc2woXCIrKGh1ZSUzNjApK1wiLFwiK3NhdHVyYXRpb24rXCIlLFwiK2xpZ2h0bmVzcytcIiUpXCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBcImhzbGEoXCIrKGh1ZSUzNjApK1wiLFwiK3NhdHVyYXRpb24rXCIlLFwiK2xpZ2h0bmVzcytcIiUsXCIrYWxwaGErXCIpXCI7XG5cdFx0fVxuXHR9O1xuXG5cbi8vIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQSByZXVzYWJsZSBpbnN0YW5jZSBvZiB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9CZWdpblBhdGhcIn19e3svY3Jvc3NMaW5rfX0gdG8gYXZvaWRcblx0ICogdW5uZWNlc3NhcnkgaW5zdGFudGlhdGlvbi5cblx0ICogQHByb3BlcnR5IGJlZ2luQ21kXG5cdCAqIEB0eXBlIHtHcmFwaGljcy5CZWdpblBhdGh9XG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHQgLy8gZGVmaW5lZCBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cblxuXHQvKipcblx0ICogTWFwIG9mIEJhc2U2NCBjaGFyYWN0ZXJzIHRvIHZhbHVlcy4gVXNlZCBieSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kZWNvZGVQYXRoXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAcHJvcGVydHkgQkFTRV82NFxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHR5cGUge09iamVjdH1cblx0ICoqL1xuXHRHcmFwaGljcy5CQVNFXzY0ID0ge1wiQVwiOjAsXCJCXCI6MSxcIkNcIjoyLFwiRFwiOjMsXCJFXCI6NCxcIkZcIjo1LFwiR1wiOjYsXCJIXCI6NyxcIklcIjo4LFwiSlwiOjksXCJLXCI6MTAsXCJMXCI6MTEsXCJNXCI6MTIsXCJOXCI6MTMsXCJPXCI6MTQsXCJQXCI6MTUsXCJRXCI6MTYsXCJSXCI6MTcsXCJTXCI6MTgsXCJUXCI6MTksXCJVXCI6MjAsXCJWXCI6MjEsXCJXXCI6MjIsXCJYXCI6MjMsXCJZXCI6MjQsXCJaXCI6MjUsXCJhXCI6MjYsXCJiXCI6MjcsXCJjXCI6MjgsXCJkXCI6MjksXCJlXCI6MzAsXCJmXCI6MzEsXCJnXCI6MzIsXCJoXCI6MzMsXCJpXCI6MzQsXCJqXCI6MzUsXCJrXCI6MzYsXCJsXCI6MzcsXCJtXCI6MzgsXCJuXCI6MzksXCJvXCI6NDAsXCJwXCI6NDEsXCJxXCI6NDIsXCJyXCI6NDMsXCJzXCI6NDQsXCJ0XCI6NDUsXCJ1XCI6NDYsXCJ2XCI6NDcsXCJ3XCI6NDgsXCJ4XCI6NDksXCJ5XCI6NTAsXCJ6XCI6NTEsXCIwXCI6NTIsXCIxXCI6NTMsXCIyXCI6NTQsXCIzXCI6NTUsXCI0XCI6NTYsXCI1XCI6NTcsXCI2XCI6NTgsXCI3XCI6NTksXCI4XCI6NjAsXCI5XCI6NjEsXCIrXCI6NjIsXCIvXCI6NjN9O1xuXG5cdC8qKlxuXHQgKiBNYXBzIG51bWVyaWMgdmFsdWVzIGZvciB0aGUgY2FwcyBwYXJhbWV0ZXIgb2Yge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3Mvc2V0U3Ryb2tlU3R5bGVcIn19e3svY3Jvc3NMaW5rfX0gdG9cblx0ICogY29ycmVzcG9uZGluZyBzdHJpbmcgdmFsdWVzLiBUaGlzIGlzIHByaW1hcmlseSBmb3IgdXNlIHdpdGggdGhlIHRpbnkgQVBJLiBUaGUgbWFwcGluZ3MgYXJlIGFzIGZvbGxvd3M6IDAgdG9cblx0ICogXCJidXR0XCIsIDEgdG8gXCJyb3VuZFwiLCBhbmQgMiB0byBcInNxdWFyZVwiLlxuXHQgKiBGb3IgZXhhbXBsZSwgdG8gc2V0IHRoZSBsaW5lIGNhcHMgdG8gXCJzcXVhcmVcIjpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLnNzKDE2LCAyKTtcblx0ICpcblx0ICogQHByb3BlcnR5IFNUUk9LRV9DQVBTX01BUFxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiovXG5cdEdyYXBoaWNzLlNUUk9LRV9DQVBTX01BUCA9IFtcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiXTtcblxuXHQvKipcblx0ICogTWFwcyBudW1lcmljIHZhbHVlcyBmb3IgdGhlIGpvaW50cyBwYXJhbWV0ZXIgb2Yge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3Mvc2V0U3Ryb2tlU3R5bGVcIn19e3svY3Jvc3NMaW5rfX0gdG9cblx0ICogY29ycmVzcG9uZGluZyBzdHJpbmcgdmFsdWVzLiBUaGlzIGlzIHByaW1hcmlseSBmb3IgdXNlIHdpdGggdGhlIHRpbnkgQVBJLiBUaGUgbWFwcGluZ3MgYXJlIGFzIGZvbGxvd3M6IDAgdG9cblx0ICogXCJtaXRlclwiLCAxIHRvIFwicm91bmRcIiwgYW5kIDIgdG8gXCJiZXZlbFwiLlxuXHQgKiBGb3IgZXhhbXBsZSwgdG8gc2V0IHRoZSBsaW5lIGpvaW50cyB0byBcImJldmVsXCI6XG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5zcygxNiwgMCwgMik7XG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBTVFJPS0VfSk9JTlRTX01BUFxuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKiBAcmVhZG9ubHlcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiovXG5cdEdyYXBoaWNzLlNUUk9LRV9KT0lOVFNfTUFQID0gW1wibWl0ZXJcIiwgXCJyb3VuZFwiLCBcImJldmVsXCJdO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX2N0eFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cblx0ICoqL1xuXHR2YXIgY2FudmFzID0gKGNyZWF0ZWpzLmNyZWF0ZUNhbnZhcz9jcmVhdGVqcy5jcmVhdGVDYW52YXMoKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpKTtcblx0aWYgKGNhbnZhcy5nZXRDb250ZXh0KSB7XG5cdFx0R3JhcGhpY3MuX2N0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDE7XG5cdH1cblxuXG4vLyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9pbnN0cnVjdGlvbnM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXRJbnN0cnVjdGlvbnNcblx0ICogQHJldHVybiB7QXJyYXl9XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0cC5nZXRJbnN0cnVjdGlvbnMgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnMoKTtcblx0XHRyZXR1cm4gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBncmFwaGljcyBpbnN0cnVjdGlvbnMgYXJyYXkuIEVhY2ggZW50cnkgaXMgYSBncmFwaGljcyBjb21tYW5kIG9iamVjdCAoZXguIEdyYXBoaWNzLkZpbGwsIEdyYXBoaWNzLlJlY3QpXG5cdCAqIE1vZGlmeWluZyB0aGUgcmV0dXJuZWQgYXJyYXkgZGlyZWN0bHkgaXMgbm90IHJlY29tbWVuZGVkLCBhbmQgaXMgbGlrZWx5IHRvIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW91ci5cblx0ICpcblx0ICogVGhpcyBwcm9wZXJ0eSBpcyBtYWlubHkgaW50ZW5kZWQgZm9yIGludHJvc3BlY3Rpb24gb2YgdGhlIGluc3RydWN0aW9ucyAoZXguIGZvciBncmFwaGljcyBleHBvcnQpLlxuXHQgKiBAcHJvcGVydHkgaW5zdHJ1Y3Rpb25zXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cdFx0XHRpbnN0cnVjdGlvbnM6IHsgZ2V0OiBwLmdldEluc3RydWN0aW9ucyB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHt9XG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBHcmFwaGljcyBpbnN0YW5jZSBoYXMgbm8gZHJhd2luZyBjb21tYW5kcy5cblx0ICogQG1ldGhvZCBpc0VtcHR5XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGlzIEdyYXBoaWNzIGluc3RhbmNlIGhhcyBubyBkcmF3aW5nIGNvbW1hbmRzLlxuXHQgKiovXG5cdHAuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhKHRoaXMuX2luc3RydWN0aW9ucy5sZW5ndGggfHwgdGhpcy5fYWN0aXZlSW5zdHJ1Y3Rpb25zLmxlbmd0aCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBkcmF3IHdhcyBoYW5kbGVkICh1c2VmdWwgZm9yIG92ZXJyaWRpbmcgZnVuY3Rpb25hbGl0eSkuXG5cdCAqXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBkcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIE9wdGlvbmFsIGRhdGEgdGhhdCBpcyBwYXNzZWQgdG8gZ3JhcGhpY3MgY29tbWFuZCBleGVjIG1ldGhvZHMuIFdoZW4gY2FsbGVkIGZyb20gYSBTaGFwZSBpbnN0YW5jZSwgdGhlIHNoYXBlIHBhc3NlcyBpdHNlbGYgYXMgdGhlIGRhdGEgcGFyYW1ldGVyLiBUaGlzIGNhbiBiZSB1c2VkIGJ5IGN1c3RvbSBncmFwaGljIGNvbW1hbmRzIHRvIGluc2VydCBjb250ZXh0dWFsIGRhdGEuXG5cdCAqKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBkYXRhKSB7XG5cdFx0dGhpcy5fdXBkYXRlSW5zdHJ1Y3Rpb25zKCk7XG5cdFx0dmFyIGluc3RyID0gdGhpcy5faW5zdHJ1Y3Rpb25zO1xuXHRcdGZvciAodmFyIGk9dGhpcy5fc3RvcmVJbmRleCwgbD1pbnN0ci5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRpbnN0cltpXS5leGVjKGN0eCwgZGF0YSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBvbmx5IHRoZSBwYXRoIGRlc2NyaWJlZCBmb3IgdGhpcyBHcmFwaGljcyBpbnN0YW5jZSwgc2tpcHBpbmcgYW55IG5vbi1wYXRoIGluc3RydWN0aW9ucywgaW5jbHVkaW5nIGZpbGwgYW5kXG5cdCAqIHN0cm9rZSBkZXNjcmlwdGlvbnMuIFVzZWQgZm9yIDxjb2RlPkRpc3BsYXlPYmplY3QubWFzazwvY29kZT4gdG8gZHJhdyB0aGUgY2xpcHBpbmcgcGF0aCwgZm9yIGV4YW1wbGUuXG5cdCAqXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBkcmF3QXNQYXRoXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqKi9cblx0cC5kcmF3QXNQYXRoID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0dGhpcy5fdXBkYXRlSW5zdHJ1Y3Rpb25zKCk7XG5cdFx0dmFyIGluc3RyLCBpbnN0cnMgPSB0aGlzLl9pbnN0cnVjdGlvbnM7XG5cdFx0Zm9yICh2YXIgaT10aGlzLl9zdG9yZUluZGV4LCBsPWluc3Rycy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHQvLyB0aGUgZmlyc3QgY29tbWFuZCBpcyBhbHdheXMgYSBiZWdpblBhdGggY29tbWFuZC5cblx0XHRcdGlmICgoaW5zdHIgPSBpbnN0cnNbaV0pLnBhdGggIT09IGZhbHNlKSB7IGluc3RyLmV4ZWMoY3R4KTsgfVxuXHRcdH1cblx0fTtcblxuXG4vLyBwdWJsaWMgbWV0aG9kcyB0aGF0IG1hcCBkaXJlY3RseSB0byBjb250ZXh0IDJEIGNhbGxzOlxuXHQvKipcblx0ICogTW92ZXMgdGhlIGRyYXdpbmcgcG9pbnQgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbi4gQSB0aW55IEFQSSBtZXRob2QgXCJtdFwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIG1vdmVUb1xuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBtb3ZlIHRvLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBtb3ZlIHRvLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAubW92ZVRvID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5Nb3ZlVG8oeCx5KSwgdHJ1ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgbGluZSBmcm9tIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9pbnQgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbiwgd2hpY2ggYmVjb21lIHRoZSBuZXcgY3VycmVudCBkcmF3aW5nXG5cdCAqIHBvaW50LiBBIHRpbnkgQVBJIG1ldGhvZCBcImx0XCIgYWxzbyBleGlzdHMuXG5cdCAqXG5cdCAqIEZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiwgcmVhZCB0aGVcblx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2NvbXBsZXgtc2hhcGVzLShwYXRocylcIj5cblx0ICogd2hhdHdnIHNwZWM8L2E+LlxuXHQgKiBAbWV0aG9kIGxpbmVUb1xuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBkcmF3IHRvLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBkcmF3IHRvLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAubGluZVRvID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5MaW5lVG8oeCx5KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGFuIGFyYyB3aXRoIHRoZSBzcGVjaWZpZWQgY29udHJvbCBwb2ludHMgYW5kIHJhZGl1cy4gIEZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiwgcmVhZCB0aGVcblx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2RvbS1jb250ZXh0LTJkLWFyY3RvXCI+XG5cdCAqIHdoYXR3ZyBzcGVjPC9hPi4gQSB0aW55IEFQSSBtZXRob2QgXCJhdFwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGFyY1RvXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geTFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hcmNUbyA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuQXJjVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBhbiBhcmMgZGVmaW5lZCBieSB0aGUgcmFkaXVzLCBzdGFydEFuZ2xlIGFuZCBlbmRBbmdsZSBhcmd1bWVudHMsIGNlbnRlcmVkIGF0IHRoZSBwb3NpdGlvbiAoeCwgeSkuIEZvclxuXHQgKiBleGFtcGxlLCB0byBkcmF3IGEgZnVsbCBjaXJjbGUgd2l0aCBhIHJhZGl1cyBvZiAyMCBjZW50ZXJlZCBhdCAoMTAwLCAxMDApOlxuXHQgKlxuXHQgKiAgICAgIGFyYygxMDAsIDEwMCwgMjAsIDAsIE1hdGguUEkqMik7XG5cdCAqXG5cdCAqIEZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiwgcmVhZCB0aGVcblx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2RvbS1jb250ZXh0LTJkLWFyY1wiPndoYXR3ZyBzcGVjPC9hPi5cblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJhXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYXJjXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0QW5nbGUgTWVhc3VyZWQgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGVuZEFuZ2xlIE1lYXN1cmVkIGluIHJhZGlhbnMuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYW50aWNsb2Nrd2lzZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYXJjID0gZnVuY3Rpb24oeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5BcmMoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIHF1YWRyYXRpYyBjdXJ2ZSBmcm9tIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9pbnQgdG8gKHgsIHkpIHVzaW5nIHRoZSBjb250cm9sIHBvaW50IChjcHgsIGNweSkuIEZvciBkZXRhaWxlZFxuXHQgKiBpbmZvcm1hdGlvbiwgcmVhZCB0aGUgPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2RvbS1jb250ZXh0LTJkLXF1YWRyYXRpY2N1cnZldG9cIj5cblx0ICogd2hhdHdnIHNwZWM8L2E+LiBBIHRpbnkgQVBJIG1ldGhvZCBcInF0XCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgcXVhZHJhdGljQ3VydmVUb1xuXHQgKiBAcGFyYW0ge051bWJlcn0gY3B4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbihjcHgsIGNweSwgeCwgeSkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5RdWFkcmF0aWNDdXJ2ZVRvKGNweCwgY3B5LCB4LCB5KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgYmV6aWVyIGN1cnZlIGZyb20gdGhlIGN1cnJlbnQgZHJhd2luZyBwb2ludCB0byAoeCwgeSkgdXNpbmcgdGhlIGNvbnRyb2wgcG9pbnRzIChjcDF4LCBjcDF5KSBhbmQgKGNwMngsXG5cdCAqIGNwMnkpLiBGb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24sIHJlYWQgdGhlXG5cdCAqIDxhIGhyZWY9XCJodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCNkb20tY29udGV4dC0yZC1iZXppZXJjdXJ2ZXRvXCI+XG5cdCAqIHdoYXR3ZyBzcGVjPC9hPi4gQSB0aW55IEFQSSBtZXRob2QgXCJidFwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlemllckN1cnZlVG9cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMXhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMXlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMnhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMnlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlemllckN1cnZlVG8gPSBmdW5jdGlvbihjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLkJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIHJlY3RhbmdsZSBhdCAoeCwgeSkgd2l0aCB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQgdXNpbmcgdGhlIGN1cnJlbnQgZmlsbCBhbmQvb3Igc3Ryb2tlLlxuXHQgKiBGb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24sIHJlYWQgdGhlXG5cdCAqIDxhIGhyZWY9XCJodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCNkb20tY29udGV4dC0yZC1yZWN0XCI+XG5cdCAqIHdoYXR3ZyBzcGVjPC9hPi4gQSB0aW55IEFQSSBtZXRob2QgXCJyXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgcmVjdFxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdyBXaWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoIEhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5yZWN0ID0gZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5SZWN0KHgsIHksIHcsIGgpKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2xvc2VzIHRoZSBjdXJyZW50IHBhdGgsIGVmZmVjdGl2ZWx5IGRyYXdpbmcgYSBsaW5lIGZyb20gdGhlIGN1cnJlbnQgZHJhd2luZyBwb2ludCB0byB0aGUgZmlyc3QgZHJhd2luZyBwb2ludCBzcGVjaWZpZWRcblx0ICogc2luY2UgdGhlIGZpbGwgb3Igc3Ryb2tlIHdhcyBsYXN0IHNldC4gQSB0aW55IEFQSSBtZXRob2QgXCJjcFwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGNsb3NlUGF0aFxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuY2xvc2VQYXRoID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FjdGl2ZUluc3RydWN0aW9ucy5sZW5ndGggPyB0aGlzLmFwcGVuZChuZXcgRy5DbG9zZVBhdGgoKSkgOiB0aGlzO1xuXHR9O1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzIHRoYXQgcm91Z2hseSBtYXAgdG8gRmxhc2ggZ3JhcGhpY3MgQVBJczpcblx0LyoqXG5cdCAqIENsZWFycyBhbGwgZHJhd2luZyBpbnN0cnVjdGlvbnMsIGVmZmVjdGl2ZWx5IHJlc2V0dGluZyB0aGlzIEdyYXBoaWNzIGluc3RhbmNlLiBBbnkgbGluZSBhbmQgZmlsbCBzdHlsZXMgd2lsbCBuZWVkXG5cdCAqIHRvIGJlIHJlZGVmaW5lZCB0byBkcmF3IHNoYXBlcyBmb2xsb3dpbmcgYSBjbGVhciBjYWxsLiBBIHRpbnkgQVBJIG1ldGhvZCBcImNcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBjbGVhclxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9pbnN0cnVjdGlvbnMubGVuZ3RoID0gdGhpcy5fYWN0aXZlSW5zdHJ1Y3Rpb25zLmxlbmd0aCA9IHRoaXMuX2NvbW1pdEluZGV4ID0gMDtcblx0XHR0aGlzLl9zdHJva2VTdHlsZSA9IHRoaXMuX29sZFN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlID0gdGhpcy5fZmlsbCA9IHRoaXMuX3N0cm9rZURhc2ggPSB0aGlzLl9vbGRTdHJva2VEYXNoID0gbnVsbDtcblx0XHR0aGlzLl9kaXJ0eSA9IHRoaXMuX3N0cm9rZUlnbm9yZVNjYWxlID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2lucyBhIGZpbGwgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbG9yLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguIEEgdGlueSBBUEkgbWV0aG9kIFwiZlwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luRmlsbFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQSBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZSAoZXguIFwicmVkXCIsIFwiI0ZGMDAwMFwiLCBvciBcInJnYmEoMjU1LDAsMCwwLjUpXCIpLiBTZXR0aW5nIHRvXG5cdCAqIG51bGwgd2lsbCByZXN1bHQgaW4gbm8gZmlsbC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlZ2luRmlsbCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldEZpbGwoY29sb3IgPyBuZXcgRy5GaWxsKGNvbG9yKSA6IG51bGwpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSBsaW5lYXIgZ3JhZGllbnQgZmlsbCBkZWZpbmVkIGJ5IHRoZSBsaW5lICh4MCwgeTApIHRvICh4MSwgeTEpLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguIEZvclxuXHQgKiBleGFtcGxlLCB0aGUgZm9sbG93aW5nIGNvZGUgZGVmaW5lcyBhIGJsYWNrIHRvIHdoaXRlIHZlcnRpY2FsIGdyYWRpZW50IHJhbmdpbmcgZnJvbSAyMHB4IHRvIDEyMHB4LCBhbmQgZHJhd3MgYVxuXHQgKiBzcXVhcmUgdG8gZGlzcGxheSBpdDpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLmJlZ2luTGluZWFyR3JhZGllbnRGaWxsKFtcIiMwMDBcIixcIiNGRkZcIl0sIFswLCAxXSwgMCwgMjAsIDAsIDEyMCkuZHJhd1JlY3QoMjAsIDIwLCAxMjAsIDEyMCk7XG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwibGZcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBiZWdpbkxpbmVhckdyYWRpZW50RmlsbFxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnMgQW4gYXJyYXkgb2YgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWVzLiBGb3IgZXhhbXBsZSwgW1wiI0YwMFwiLFwiIzAwRlwiXSB3b3VsZCBkZWZpbmUgYSBncmFkaWVudFxuXHQgKiBkcmF3aW5nIGZyb20gcmVkIHRvIGJsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvcyBBbiBhcnJheSBvZiBncmFkaWVudCBwb3NpdGlvbnMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgY29sb3JzLiBGb3IgZXhhbXBsZSwgWzAuMSwgMC45XSB3b3VsZCBkcmF3XG5cdCAqIHRoZSBmaXJzdCBjb2xvciB0byAxMCUgdGhlbiBpbnRlcnBvbGF0aW5nIHRvIHRoZSBzZWNvbmQgY29sb3IgYXQgOTAlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDAgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwIFRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MSBUaGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmVnaW5MaW5lYXJHcmFkaWVudEZpbGwgPSBmdW5jdGlvbihjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCB4MSwgeTEpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0RmlsbChuZXcgRy5GaWxsKCkubGluZWFyR3JhZGllbnQoY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgeDEsIHkxKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2lucyBhIHJhZGlhbCBncmFkaWVudCBmaWxsLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIGNvZGUgZGVmaW5lcyBhIHJlZCB0b1xuXHQgKiBibHVlIHJhZGlhbCBncmFkaWVudCBjZW50ZXJlZCBhdCAoMTAwLCAxMDApLCB3aXRoIGEgcmFkaXVzIG9mIDUwLCBhbmQgZHJhd3MgYSBjaXJjbGUgdG8gZGlzcGxheSBpdDpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLmJlZ2luUmFkaWFsR3JhZGllbnRGaWxsKFtcIiNGMDBcIixcIiMwMEZcIl0sIFswLCAxXSwgMTAwLCAxMDAsIDAsIDEwMCwgMTAwLCA1MCkuZHJhd0NpcmNsZSgxMDAsIDEwMCwgNTApO1xuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcInJmXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYmVnaW5SYWRpYWxHcmFkaWVudEZpbGxcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzIEFuIGFycmF5IG9mIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlcy4gRm9yIGV4YW1wbGUsIFtcIiNGMDBcIixcIiMwMEZcIl0gd291bGQgZGVmaW5lXG5cdCAqIGEgZ3JhZGllbnQgZHJhd2luZyBmcm9tIHJlZCB0byBibHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3MgQW4gYXJyYXkgb2YgZ3JhZGllbnQgcG9zaXRpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNvbG9ycy4gRm9yIGV4YW1wbGUsIFswLjEsXG5cdCAqIDAuOV0gd291bGQgZHJhdyB0aGUgZmlyc3QgY29sb3IgdG8gMTAlIHRoZW4gaW50ZXJwb2xhdGluZyB0byB0aGUgc2Vjb25kIGNvbG9yIGF0IDkwJS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjAgUmFkaXVzIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjEgUmFkaXVzIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlZ2luUmFkaWFsR3JhZGllbnRGaWxsID0gZnVuY3Rpb24oY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0RmlsbChuZXcgRy5GaWxsKCkucmFkaWFsR3JhZGllbnQoY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpKTtcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW5zIGEgcGF0dGVybiBmaWxsIHVzaW5nIHRoZSBzcGVjaWZpZWQgaW1hZ2UuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC4gQSB0aW55IEFQSSBtZXRob2QgXCJiZlwiIGFsc29cblx0ICogZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luQml0bWFwRmlsbFxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnR9IGltYWdlIFRoZSBJbWFnZSwgQ2FudmFzLCBvciBWaWRlbyBvYmplY3QgdG8gdXNlXG5cdCAqIGFzIHRoZSBwYXR0ZXJuLiBNdXN0IGJlIGxvYWRlZCBwcmlvciB0byBjcmVhdGluZyBhIGJpdG1hcCBmaWxsLCBvciB0aGUgZmlsbCB3aWxsIGJlIGVtcHR5LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcmVwZXRpdGlvbiBPcHRpb25hbC4gSW5kaWNhdGVzIHdoZXRoZXIgdG8gcmVwZWF0IHRoZSBpbWFnZSBpbiB0aGUgZmlsbCBhcmVhLiBPbmUgb2YgXCJyZXBlYXRcIixcblx0ICogXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuIERlZmF1bHRzIHRvIFwicmVwZWF0XCIuIE5vdGUgdGhhdCBGaXJlZm94IGRvZXMgbm90IHN1cHBvcnQgXCJyZXBlYXQteFwiIG9yXG5cdCAqIFwicmVwZWF0LXlcIiAobGF0ZXN0IHRlc3RzIHdlcmUgaW4gRkYgMjAuMCksIGFuZCB3aWxsIGRlZmF1bHQgdG8gXCJyZXBlYXRcIi5cblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4IE9wdGlvbmFsLiBTcGVjaWZpZXMgYSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZm9yIHRoZSBiaXRtYXAgZmlsbC4gVGhpcyB0cmFuc2Zvcm1hdGlvblxuXHQgKiB3aWxsIGJlIGFwcGxpZWQgcmVsYXRpdmUgdG8gdGhlIHBhcmVudCB0cmFuc2Zvcm0uXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5iZWdpbkJpdG1hcEZpbGwgPSBmdW5jdGlvbihpbWFnZSwgcmVwZXRpdGlvbiwgbWF0cml4KSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldEZpbGwobmV3IEcuRmlsbChudWxsLG1hdHJpeCkuYml0bWFwKGltYWdlLCByZXBldGl0aW9uKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGgsIGFuZCBiZWdpbnMgYSBuZXcgb25lIHdpdGggbm8gZmlsbC4gRnVuY3Rpb25hbGx5IGlkZW50aWNhbCB0byA8Y29kZT5iZWdpbkZpbGwobnVsbCk8L2NvZGU+LlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImVmXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgZW5kRmlsbFxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuZW5kRmlsbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmJlZ2luRmlsbCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBzdHJva2Ugc3R5bGUuIExpa2UgYWxsIGRyYXdpbmcgbWV0aG9kcywgdGhpcyBjYW4gYmUgY2hhaW5lZCwgc28geW91IGNhbiBkZWZpbmVcblx0ICogdGhlIHN0cm9rZSBzdHlsZSBhbmQgY29sb3IgaW4gYSBzaW5nbGUgbGluZSBvZiBjb2RlIGxpa2Ugc286XG5cdCAqXG5cdCAqIFx0bXlHcmFwaGljcy5zZXRTdHJva2VTdHlsZSg4LFwicm91bmRcIikuYmVnaW5TdHJva2UoXCIjRjAwXCIpO1xuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcInNzXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2Qgc2V0U3Ryb2tlU3R5bGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRoaWNrbmVzcyBUaGUgd2lkdGggb2YgdGhlIHN0cm9rZS5cblx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IFtjYXBzPTBdIEluZGljYXRlcyB0aGUgdHlwZSBvZiBjYXBzIHRvIHVzZSBhdCB0aGUgZW5kIG9mIGxpbmVzLiBPbmUgb2YgYnV0dCxcblx0ICogcm91bmQsIG9yIHNxdWFyZS4gRGVmYXVsdHMgdG8gXCJidXR0XCIuIEFsc28gYWNjZXB0cyB0aGUgdmFsdWVzIDAgKGJ1dHQpLCAxIChyb3VuZCksIGFuZCAyIChzcXVhcmUpIGZvciB1c2Ugd2l0aFxuXHQgKiB0aGUgdGlueSBBUEkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBbam9pbnRzPTBdIFNwZWNpZmllcyB0aGUgdHlwZSBvZiBqb2ludHMgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVyZSB0d28gbGluZXMgbWVldC5cblx0ICogT25lIG9mIGJldmVsLCByb3VuZCwgb3IgbWl0ZXIuIERlZmF1bHRzIHRvIFwibWl0ZXJcIi4gQWxzbyBhY2NlcHRzIHRoZSB2YWx1ZXMgMCAobWl0ZXIpLCAxIChyb3VuZCksIGFuZCAyIChiZXZlbClcblx0ICogZm9yIHVzZSB3aXRoIHRoZSB0aW55IEFQSS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttaXRlckxpbWl0PTEwXSBJZiBqb2ludHMgaXMgc2V0IHRvIFwibWl0ZXJcIiwgdGhlbiB5b3UgY2FuIHNwZWNpZnkgYSBtaXRlciBsaW1pdCByYXRpbyB3aGljaFxuXHQgKiBjb250cm9scyBhdCB3aGF0IHBvaW50IGEgbWl0ZXJlZCBqb2ludCB3aWxsIGJlIGNsaXBwZWQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZVNjYWxlPWZhbHNlXSBJZiB0cnVlLCB0aGUgc3Ryb2tlIHdpbGwgYmUgZHJhd24gYXQgdGhlIHNwZWNpZmllZCB0aGlja25lc3MgcmVnYXJkbGVzc1xuXHQgKiBvZiBhY3RpdmUgdHJhbnNmb3JtYXRpb25zLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuc2V0U3Ryb2tlU3R5bGUgPSBmdW5jdGlvbih0aGlja25lc3MsIGNhcHMsIGpvaW50cywgbWl0ZXJMaW1pdCwgaWdub3JlU2NhbGUpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnModHJ1ZSk7XG5cdFx0dGhpcy5fc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbW1hbmQgPSBuZXcgRy5TdHJva2VTdHlsZSh0aGlja25lc3MsIGNhcHMsIGpvaW50cywgbWl0ZXJMaW1pdCwgaWdub3JlU2NhbGUpO1xuXG5cdFx0Ly8gaWdub3JlU2NhbGUgbGl2ZXMgb24gU3Ryb2tlLCBub3QgU3Ryb2tlU3R5bGUsIHNvIHdlIGRvIGEgbGl0dGxlIHRyaWNrZXJ5OlxuXHRcdGlmICh0aGlzLl9zdHJva2UpIHsgdGhpcy5fc3Ryb2tlLmlnbm9yZVNjYWxlID0gaWdub3JlU2NhbGU7IH1cblx0XHR0aGlzLl9zdHJva2VJZ25vcmVTY2FsZSA9IGlnbm9yZVNjYWxlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFNldHMgb3IgY2xlYXJzIHRoZSBzdHJva2UgZGFzaCBwYXR0ZXJuLlxuXHQgKlxuXHQgKiBcdG15R3JhcGhpY3Muc2V0U3Ryb2tlRGFzaChbMjAsIDEwXSwgMCk7XG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIGBzZGAgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2Qgc2V0U3Ryb2tlRGFzaFxuXHQgKiBAcGFyYW0ge0FycmF5fSBbc2VnbWVudHNdIEFuIGFycmF5IHNwZWNpZnlpbmcgdGhlIGRhc2ggcGF0dGVybiwgYWx0ZXJuYXRpbmcgYmV0d2VlbiBsaW5lIGFuZCBnYXAuXG5cdCAqIEZvciBleGFtcGxlLCBgWzIwLDEwXWAgd291bGQgY3JlYXRlIGEgcGF0dGVybiBvZiAyMCBwaXhlbCBsaW5lcyB3aXRoIDEwIHBpeGVsIGdhcHMgYmV0d2VlbiB0aGVtLlxuXHQgKiBQYXNzaW5nIG51bGwgb3IgYW4gZW1wdHkgYXJyYXkgd2lsbCBjbGVhciB0aGUgZXhpc3Rpbmcgc3Ryb2tlIGRhc2guXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0PTBdIFRoZSBvZmZzZXQgb2YgdGhlIGRhc2ggcGF0dGVybi4gRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCBpbmNyZW1lbnQgdGhpcyB2YWx1ZSB0byBjcmVhdGUgYSBcIm1hcmNoaW5nIGFudHNcIiBlZmZlY3QuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5zZXRTdHJva2VEYXNoID0gZnVuY3Rpb24oc2VnbWVudHMsIG9mZnNldCkge1xuXHRcdHRoaXMuX3VwZGF0ZUluc3RydWN0aW9ucyh0cnVlKTtcblx0XHR0aGlzLl9zdHJva2VEYXNoID0gdGhpcy5jb21tYW5kID0gbmV3IEcuU3Ryb2tlRGFzaChzZWdtZW50cywgb2Zmc2V0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW5zIGEgc3Ryb2tlIHdpdGggdGhlIHNwZWNpZmllZCBjb2xvci4gVGhpcyBlbmRzIHRoZSBjdXJyZW50IHN1Yi1wYXRoLiBBIHRpbnkgQVBJIG1ldGhvZCBcInNcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBiZWdpblN0cm9rZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQSBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZSAoZXguIFwiI0ZGMDAwMFwiLCBcInJlZFwiLCBvciBcInJnYmEoMjU1LDAsMCwwLjUpXCIpLiBTZXR0aW5nIHRvXG5cdCAqIG51bGwgd2lsbCByZXN1bHQgaW4gbm8gc3Ryb2tlLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmVnaW5TdHJva2UgPSBmdW5jdGlvbihjb2xvcikge1xuXHRcdHJldHVybiB0aGlzLl9zZXRTdHJva2UoY29sb3IgPyBuZXcgRy5TdHJva2UoY29sb3IpIDogbnVsbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2lucyBhIGxpbmVhciBncmFkaWVudCBzdHJva2UgZGVmaW5lZCBieSB0aGUgbGluZSAoeDAsIHkwKSB0byAoeDEsIHkxKS4gVGhpcyBlbmRzIHRoZSBjdXJyZW50IHN1Yi1wYXRoLiBGb3Jcblx0ICogZXhhbXBsZSwgdGhlIGZvbGxvd2luZyBjb2RlIGRlZmluZXMgYSBibGFjayB0byB3aGl0ZSB2ZXJ0aWNhbCBncmFkaWVudCByYW5naW5nIGZyb20gMjBweCB0byAxMjBweCwgYW5kIGRyYXdzIGFcblx0ICogc3F1YXJlIHRvIGRpc3BsYXkgaXQ6XG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5zZXRTdHJva2VTdHlsZSgxMCkuXG5cdCAqICAgICAgICAgIGJlZ2luTGluZWFyR3JhZGllbnRTdHJva2UoW1wiIzAwMFwiLFwiI0ZGRlwiXSwgWzAsIDFdLCAwLCAyMCwgMCwgMTIwKS5kcmF3UmVjdCgyMCwgMjAsIDEyMCwgMTIwKTtcblx0ICpcblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJsc1wiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luTGluZWFyR3JhZGllbnRTdHJva2Vcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzIEFuIGFycmF5IG9mIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlcy4gRm9yIGV4YW1wbGUsIFtcIiNGMDBcIixcIiMwMEZcIl0gd291bGQgZGVmaW5lXG5cdCAqIGEgZ3JhZGllbnQgZHJhd2luZyBmcm9tIHJlZCB0byBibHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3MgQW4gYXJyYXkgb2YgZ3JhZGllbnQgcG9zaXRpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNvbG9ycy4gRm9yIGV4YW1wbGUsIFswLjEsXG5cdCAqIDAuOV0gd291bGQgZHJhdyB0aGUgZmlyc3QgY29sb3IgdG8gMTAlIHRoZW4gaW50ZXJwb2xhdGluZyB0byB0aGUgc2Vjb25kIGNvbG9yIGF0IDkwJS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwIFRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDEgVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MSBUaGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlZ2luTGluZWFyR3JhZGllbnRTdHJva2UgPSBmdW5jdGlvbihjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCB4MSwgeTEpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0U3Ryb2tlKG5ldyBHLlN0cm9rZSgpLmxpbmVhckdyYWRpZW50KGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHgxLCB5MSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSByYWRpYWwgZ3JhZGllbnQgc3Ryb2tlLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIGNvZGUgZGVmaW5lcyBhIHJlZCB0b1xuXHQgKiBibHVlIHJhZGlhbCBncmFkaWVudCBjZW50ZXJlZCBhdCAoMTAwLCAxMDApLCB3aXRoIGEgcmFkaXVzIG9mIDUwLCBhbmQgZHJhd3MgYSByZWN0YW5nbGUgdG8gZGlzcGxheSBpdDpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLnNldFN0cm9rZVN0eWxlKDEwKVxuXHQgKiAgICAgICAgICAuYmVnaW5SYWRpYWxHcmFkaWVudFN0cm9rZShbXCIjRjAwXCIsXCIjMDBGXCJdLCBbMCwgMV0sIDEwMCwgMTAwLCAwLCAxMDAsIDEwMCwgNTApXG5cdCAqICAgICAgICAgIC5kcmF3UmVjdCg1MCwgOTAsIDE1MCwgMTEwKTtcblx0ICpcblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJyc1wiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luUmFkaWFsR3JhZGllbnRTdHJva2Vcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzIEFuIGFycmF5IG9mIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlcy4gRm9yIGV4YW1wbGUsIFtcIiNGMDBcIixcIiMwMEZcIl0gd291bGQgZGVmaW5lXG5cdCAqIGEgZ3JhZGllbnQgZHJhd2luZyBmcm9tIHJlZCB0byBibHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3MgQW4gYXJyYXkgb2YgZ3JhZGllbnQgcG9zaXRpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNvbG9ycy4gRm9yIGV4YW1wbGUsIFswLjEsXG5cdCAqIDAuOV0gd291bGQgZHJhdyB0aGUgZmlyc3QgY29sb3IgdG8gMTAlIHRoZW4gaW50ZXJwb2xhdGluZyB0byB0aGUgc2Vjb25kIGNvbG9yIGF0IDkwJSwgdGhlbiBkcmF3IHRoZSBzZWNvbmQgY29sb3Jcblx0ICogdG8gMTAwJS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjAgUmFkaXVzIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjEgUmFkaXVzIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlZ2luUmFkaWFsR3JhZGllbnRTdHJva2UgPSBmdW5jdGlvbihjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCByMCwgeDEsIHkxLCByMSkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRTdHJva2UobmV3IEcuU3Ryb2tlKCkucmFkaWFsR3JhZGllbnQoY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpKTtcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW5zIGEgcGF0dGVybiBmaWxsIHVzaW5nIHRoZSBzcGVjaWZpZWQgaW1hZ2UuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC4gTm90ZSB0aGF0IHVubGlrZSBiaXRtYXAgZmlsbHMsXG5cdCAqIHN0cm9rZXMgZG8gbm90IGN1cnJlbnRseSBzdXBwb3J0IGEgbWF0cml4IHBhcmFtZXRlciBkdWUgdG8gbGltaXRhdGlvbnMgaW4gdGhlIGNhbnZhcyBBUEkuIEEgdGlueSBBUEkgbWV0aG9kIFwiYnNcIlxuXHQgKiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBiZWdpbkJpdG1hcFN0cm9rZVxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnR9IGltYWdlIFRoZSBJbWFnZSwgQ2FudmFzLCBvciBWaWRlbyBvYmplY3QgdG8gdXNlXG5cdCAqIGFzIHRoZSBwYXR0ZXJuLiBNdXN0IGJlIGxvYWRlZCBwcmlvciB0byBjcmVhdGluZyBhIGJpdG1hcCBmaWxsLCBvciB0aGUgZmlsbCB3aWxsIGJlIGVtcHR5LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3JlcGV0aXRpb249cmVwZWF0XSBPcHRpb25hbC4gSW5kaWNhdGVzIHdoZXRoZXIgdG8gcmVwZWF0IHRoZSBpbWFnZSBpbiB0aGUgZmlsbCBhcmVhLiBPbmUgb2Zcblx0ICogXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuIERlZmF1bHRzIHRvIFwicmVwZWF0XCIuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5iZWdpbkJpdG1hcFN0cm9rZSA9IGZ1bmN0aW9uKGltYWdlLCByZXBldGl0aW9uKSB7XG5cdFx0Ly8gTk9URTogbWF0cml4IGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHN0cm9rZSBiZWNhdXNlIHRyYW5zZm9ybXMgb24gc3Ryb2tlcyBhbHNvIGFmZmVjdCB0aGUgZHJhd24gc3Ryb2tlIHdpZHRoLlxuXHRcdHJldHVybiB0aGlzLl9zZXRTdHJva2UobmV3IEcuU3Ryb2tlKCkuYml0bWFwKGltYWdlLCByZXBldGl0aW9uKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGgsIGFuZCBiZWdpbnMgYSBuZXcgb25lIHdpdGggbm8gc3Ryb2tlLiBGdW5jdGlvbmFsbHkgaWRlbnRpY2FsIHRvIDxjb2RlPmJlZ2luU3Ryb2tlKG51bGwpPC9jb2RlPi5cblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJlc1wiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGVuZFN0cm9rZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuZW5kU3Ryb2tlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYmVnaW5TdHJva2UoKTtcblx0fTtcblxuXHQvKipcblx0ICogTWFwcyB0aGUgZmFtaWxpYXIgQWN0aW9uU2NyaXB0IDxjb2RlPmN1cnZlVG8oKTwvY29kZT4gbWV0aG9kIHRvIHRoZSBmdW5jdGlvbmFsbHkgc2ltaWxhciB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9xdWFkcmF0aWNDdXJ2ZVRvXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC5cblx0ICogQG1ldGhvZCBxdWFkcmF0aWNDdXJ2ZVRvXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNweVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuY3VydmVUbyA9IHAucXVhZHJhdGljQ3VydmVUbztcblxuXHQvKipcblx0ICpcblx0ICogTWFwcyB0aGUgZmFtaWxpYXIgQWN0aW9uU2NyaXB0IDxjb2RlPmRyYXdSZWN0KCk8L2NvZGU+IG1ldGhvZCB0byB0aGUgZnVuY3Rpb25hbGx5IHNpbWlsYXIge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvcmVjdFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuXG5cdCAqIEBtZXRob2QgZHJhd1JlY3Rcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHcgV2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaCBIZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuZHJhd1JlY3QgPSBwLnJlY3Q7XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgcm91bmRlZCByZWN0YW5nbGUgd2l0aCBhbGwgY29ybmVycyB3aXRoIHRoZSBzcGVjaWZpZWQgcmFkaXVzLlxuXHQgKiBAbWV0aG9kIGRyYXdSb3VuZFJlY3Rcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBDb3JuZXIgcmFkaXVzLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuZHJhd1JvdW5kUmVjdCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgsIHJhZGl1cykge1xuXHRcdHJldHVybiB0aGlzLmRyYXdSb3VuZFJlY3RDb21wbGV4KHgsIHksIHcsIGgsIHJhZGl1cywgcmFkaXVzLCByYWRpdXMsIHJhZGl1cyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgcm91bmRlZCByZWN0YW5nbGUgd2l0aCBkaWZmZXJlbnQgY29ybmVyIHJhZGlpLiBTdXBwb3J0cyBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgY29ybmVyIHJhZGlpLiBBIHRpbnkgQVBJXG5cdCAqIG1ldGhvZCBcInJjXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgZHJhd1JvdW5kUmVjdENvbXBsZXhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZSB0byBkcmF3IHRoZSByb3VuZCByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgdmVydGljYWwgY29vcmRpbmF0ZSB0byBkcmF3IHRoZSByb3VuZCByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdyBUaGUgd2lkdGggb2YgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoIFRoZSBoZWlnaHQgb2YgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUTCBUb3AgbGVmdCBjb3JuZXIgcmFkaXVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzVFIgVG9wIHJpZ2h0IGNvcm5lciByYWRpdXMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCUiBCb3R0b20gcmlnaHQgY29ybmVyIHJhZGl1cy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c0JMIEJvdHRvbSBsZWZ0IGNvcm5lciByYWRpdXMuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5kcmF3Um91bmRSZWN0Q29tcGxleCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgsIHJhZGl1c1RMLCByYWRpdXNUUiwgcmFkaXVzQlIsIHJhZGl1c0JMKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLlJvdW5kUmVjdCh4LCB5LCB3LCBoLCByYWRpdXNUTCwgcmFkaXVzVFIsIHJhZGl1c0JSLCByYWRpdXNCTCkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBhIGNpcmNsZSB3aXRoIHRoZSBzcGVjaWZpZWQgcmFkaXVzIGF0ICh4LCB5KS5cblx0ICpcblx0ICogICAgICB2YXIgZyA9IG5ldyBjcmVhdGVqcy5HcmFwaGljcygpO1xuXHQgKlx0ICAgIGcuc2V0U3Ryb2tlU3R5bGUoMSk7XG5cdCAqXHQgICAgZy5iZWdpblN0cm9rZShjcmVhdGVqcy5HcmFwaGljcy5nZXRSR0IoMCwwLDApKTtcblx0ICpcdCAgICBnLmJlZ2luRmlsbChjcmVhdGVqcy5HcmFwaGljcy5nZXRSR0IoMjU1LDAsMCkpO1xuXHQgKlx0ICAgIGcuZHJhd0NpcmNsZSgwLDAsMyk7XG5cdCAqXG5cdCAqXHQgICAgdmFyIHMgPSBuZXcgY3JlYXRlanMuU2hhcGUoZyk7XG5cdCAqXHRcdHMueCA9IDEwMDtcblx0ICpcdFx0cy55ID0gMTAwO1xuXHQgKlxuXHQgKlx0ICAgIHN0YWdlLmFkZENoaWxkKHMpO1xuXHQgKlx0ICAgIHN0YWdlLnVwZGF0ZSgpO1xuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImRjXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgZHJhd0NpcmNsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0geCB4IGNvb3JkaW5hdGUgY2VudGVyIHBvaW50IG9mIGNpcmNsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgeSBjb29yZGluYXRlIGNlbnRlciBwb2ludCBvZiBjaXJjbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIGNpcmNsZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmRyYXdDaXJjbGUgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuQ2lyY2xlKHgsIHksIHJhZGl1cykpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBhbiBlbGxpcHNlIChvdmFsKSB3aXRoIGEgc3BlY2lmaWVkIHdpZHRoICh3KSBhbmQgaGVpZ2h0IChoKS4gU2ltaWxhciB0byB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Q2lyY2xlXCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBleGNlcHQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgY2FuIGJlIGRpZmZlcmVudC4gQSB0aW55IEFQSSBtZXRob2QgXCJkZVwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGRyYXdFbGxpcHNlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBsZWZ0IGNvb3JkaW5hdGUgcG9pbnQgb2YgdGhlIGVsbGlwc2UuIE5vdGUgdGhhdCB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdDaXJjbGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2hpY2ggZHJhd3MgZnJvbSBjZW50ZXIuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB0b3AgY29vcmRpbmF0ZSBwb2ludCBvZiB0aGUgZWxsaXBzZS4gTm90ZSB0aGF0IHRoaXMgaXMgZGlmZmVyZW50IGZyb20ge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd0NpcmNsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aGljaCBkcmF3cyBmcm9tIHRoZSBjZW50ZXIuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFRoZSBoZWlnaHQgKGhvcml6b250YWwgZGlhbWV0ZXIpIG9mIHRoZSBlbGxpcHNlLiBUaGUgaG9yaXpvbnRhbCByYWRpdXMgd2lsbCBiZSBoYWxmIG9mIHRoaXNcblx0ICogbnVtYmVyLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaCBUaGUgd2lkdGggKHZlcnRpY2FsIGRpYW1ldGVyKSBvZiB0aGUgZWxsaXBzZS4gVGhlIHZlcnRpY2FsIHJhZGl1cyB3aWxsIGJlIGhhbGYgb2YgdGhpcyBudW1iZXIuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5kcmF3RWxsaXBzZSA9IGZ1bmN0aW9uKHgsIHksIHcsIGgpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuRWxsaXBzZSh4LCB5LCB3LCBoKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgc3RhciBpZiBwb2ludFNpemUgaXMgZ3JlYXRlciB0aGFuIDAsIG9yIGEgcmVndWxhciBwb2x5Z29uIGlmIHBvaW50U2l6ZSBpcyAwIHdpdGggdGhlIHNwZWNpZmllZCBudW1iZXIgb2Zcblx0ICogcG9pbnRzLiBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyBjb2RlIHdpbGwgZHJhdyBhIGZhbWlsaWFyIDUgcG9pbnRlZCBzdGFyIHNoYXBlIGNlbnRlcmVkIGF0IDEwMCwgMTAwIGFuZCB3aXRoIGFcblx0ICogcmFkaXVzIG9mIDUwOlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3MuYmVnaW5GaWxsKFwiI0ZGMFwiKS5kcmF3UG9seVN0YXIoMTAwLCAxMDAsIDUwLCA1LCAwLjYsIC05MCk7XG5cdCAqICAgICAgLy8gTm90ZTogLTkwIG1ha2VzIHRoZSBmaXJzdCBwb2ludCB2ZXJ0aWNhbFxuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImRwXCIgYWxzbyBleGlzdHMuXG5cdCAqXG5cdCAqIEBtZXRob2QgZHJhd1BvbHlTdGFyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHNoYXBlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBQb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoZSBzaGFwZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBzaGFwZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNpZGVzIFRoZSBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBzdGFyIG9yIHNpZGVzIG9uIHRoZSBwb2x5Z29uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9pbnRTaXplIFRoZSBkZXB0aCBvciBcInBvaW50eS1uZXNzXCIgb2YgdGhlIHN0YXIgcG9pbnRzLiBBIHBvaW50U2l6ZSBvZiAwIHdpbGwgZHJhdyBhIHJlZ3VsYXJcblx0ICogcG9seWdvbiAobm8gcG9pbnRzKSwgYSBwb2ludFNpemUgb2YgMSB3aWxsIGRyYXcgbm90aGluZyBiZWNhdXNlIHRoZSBwb2ludHMgYXJlIGluZmluaXRlbHkgcG9pbnR5LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgVGhlIGFuZ2xlIG9mIHRoZSBmaXJzdCBwb2ludCAvIGNvcm5lci4gRm9yIGV4YW1wbGUgYSB2YWx1ZSBvZiAwIHdpbGwgZHJhdyB0aGUgZmlyc3QgcG9pbnRcblx0ICogZGlyZWN0bHkgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjZW50ZXIuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5kcmF3UG9seVN0YXIgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHNpZGVzLCBwb2ludFNpemUsIGFuZ2xlKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLlBvbHlTdGFyKHgsIHksIHJhZGl1cywgc2lkZXMsIHBvaW50U2l6ZSwgYW5nbGUpKTtcblx0fTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkLlxuXHQvKipcblx0ICogUmVtb3ZlZCBpbiBmYXZvdXIgb2YgdXNpbmcgY3VzdG9tIGNvbW1hbmQgb2JqZWN0cyB3aXRoIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBpbmplY3Rcblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXG5cdC8qKlxuXHQgKiBBcHBlbmRzIGEgZ3JhcGhpY3MgY29tbWFuZCBvYmplY3QgdG8gdGhlIGdyYXBoaWNzIHF1ZXVlLiBDb21tYW5kIG9iamVjdHMgZXhwb3NlIGFuIFwiZXhlY1wiIG1ldGhvZFxuXHQgKiB0aGF0IGFjY2VwdHMgdHdvIHBhcmFtZXRlcnM6IHRoZSBDb250ZXh0MkQgdG8gb3BlcmF0ZSBvbiwgYW5kIGFuIGFyYml0cmFyeSBkYXRhIG9iamVjdCBwYXNzZWQgaW50b1xuXHQgKiB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3XCJ9fXt7L2Nyb3NzTGlua319LiBUaGUgbGF0dGVyIHdpbGwgdXN1YWxseSBiZSB0aGUgU2hhcGUgaW5zdGFuY2UgdGhhdCBjYWxsZWQgZHJhdy5cblx0ICpcblx0ICogVGhpcyBtZXRob2QgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEdyYXBoaWNzIG1ldGhvZHMsIHN1Y2ggYXMgZHJhd0NpcmNsZSwgYnV0IGNhbiBhbHNvIGJlIHVzZWQgZGlyZWN0bHkgdG8gaW5zZXJ0XG5cdCAqIGJ1aWx0LWluIG9yIGN1c3RvbSBncmFwaGljcyBjb21tYW5kcy4gRm9yIGV4YW1wbGU6XG5cdCAqXG5cdCAqIFx0XHQvLyBhdHRhY2ggZGF0YSB0byBvdXIgc2hhcGUsIHNvIHdlIGNhbiBhY2Nlc3MgaXQgZHVyaW5nIHRoZSBkcmF3OlxuXHQgKiBcdFx0bXlTaGFwZS5jb2xvciA9IFwicmVkXCI7XG5cdCAqXG5cdCAqIFx0XHQvLyBhcHBlbmQgYSBDaXJjbGUgY29tbWFuZCBvYmplY3Q6XG5cdCAqIFx0XHRteVNoYXBlLmdyYXBoaWNzLmFwcGVuZChuZXcgR3JhcGhpY3MuQ2lyY2xlKDUwLCA1MCwgMzApKTtcblx0ICpcblx0ICogXHRcdC8vIGFwcGVuZCBhIGN1c3RvbSBjb21tYW5kIG9iamVjdCB3aXRoIGFuIGV4ZWMgbWV0aG9kIHRoYXQgc2V0cyB0aGUgZmlsbCBzdHlsZVxuXHQgKiBcdFx0Ly8gYmFzZWQgb24gdGhlIHNoYXBlJ3MgZGF0YSwgYW5kIHRoZW4gZmlsbHMgdGhlIGNpcmNsZS5cblx0ICogXHRcdG15U2hhcGUuZ3JhcGhpY3MuYXBwZW5kKHtleGVjOmZ1bmN0aW9uKGN0eCwgc2hhcGUpIHtcblx0ICogXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHNoYXBlLmNvbG9yO1xuXHQgKiBcdFx0XHRjdHguZmlsbCgpO1xuXHQgKiBcdFx0fX0pO1xuXHQgKlxuXHQgKiBAbWV0aG9kIGFwcGVuZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29tbWFuZCBBIGdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0IGV4cG9zaW5nIGFuIFwiZXhlY1wiIG1ldGhvZC5cblx0ICogQHBhcmFtIHtib29sZWFufSBjbGVhbiBUaGUgY2xlYW4gcGFyYW0gaXMgcHJpbWFyaWx5IGZvciBpbnRlcm5hbCB1c2UuIEEgdmFsdWUgb2YgdHJ1ZSBpbmRpY2F0ZXMgdGhhdCBhIGNvbW1hbmQgZG9lcyBub3QgZ2VuZXJhdGUgYSBwYXRoIHRoYXQgc2hvdWxkIGJlIHN0cm9rZWQgb3IgZmlsbGVkLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYXBwZW5kID0gZnVuY3Rpb24oY29tbWFuZCwgY2xlYW4pIHtcblx0XHR0aGlzLl9hY3RpdmVJbnN0cnVjdGlvbnMucHVzaChjb21tYW5kKTtcblx0XHR0aGlzLmNvbW1hbmQgPSBjb21tYW5kO1xuXHRcdGlmICghY2xlYW4pIHsgdGhpcy5fZGlydHkgPSB0cnVlOyB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlY29kZXMgYSBjb21wYWN0IGVuY29kZWQgcGF0aCBzdHJpbmcgaW50byBhIHNlcmllcyBvZiBkcmF3IGluc3RydWN0aW9ucy5cblx0ICogVGhpcyBmb3JtYXQgaXMgbm90IGludGVuZGVkIHRvIGJlIGh1bWFuIHJlYWRhYmxlLCBhbmQgaXMgbWVhbnQgZm9yIHVzZSBieSBhdXRob3JpbmcgdG9vbHMuXG5cdCAqIFRoZSBmb3JtYXQgdXNlcyBhIGJhc2U2NCBjaGFyYWN0ZXIgc2V0LCB3aXRoIGVhY2ggY2hhcmFjdGVyIHJlcHJlc2VudGluZyA2IGJpdHMsIHRvIGRlZmluZSBhIHNlcmllcyBvZiBkcmF3XG5cdCAqIGNvbW1hbmRzLlxuXHQgKlxuXHQgKiBFYWNoIGNvbW1hbmQgaXMgY29tcHJpc2VkIG9mIGEgc2luZ2xlIFwiaGVhZGVyXCIgY2hhcmFjdGVyIGZvbGxvd2VkIGJ5IGEgdmFyaWFibGUgbnVtYmVyIG9mIGFsdGVybmF0aW5nIHggYW5kIHlcblx0ICogcG9zaXRpb24gdmFsdWVzLiBSZWFkaW5nIHRoZSBoZWFkZXIgYml0cyBmcm9tIGxlZnQgdG8gcmlnaHQgKG1vc3QgdG8gbGVhc3Qgc2lnbmlmaWNhbnQpOiBiaXRzIDEgdG8gMyBzcGVjaWZ5IHRoZVxuXHQgKiB0eXBlIG9mIG9wZXJhdGlvbiAoMC1tb3ZlVG8sIDEtbGluZVRvLCAyLXF1YWRyYXRpY0N1cnZlVG8sIDMtYmV6aWVyQ3VydmVUbywgNC1jbG9zZVBhdGgsIDUtNyB1bnVzZWQpLiBCaXQgNFxuXHQgKiBpbmRpY2F0ZXMgd2hldGhlciBwb3NpdGlvbiB2YWx1ZXMgdXNlIDEyIGJpdHMgKDIgY2hhcmFjdGVycykgb3IgMTggYml0cyAoMyBjaGFyYWN0ZXJzKSwgd2l0aCBhIG9uZSBpbmRpY2F0aW5nIHRoZVxuXHQgKiBsYXR0ZXIuIEJpdHMgNSBhbmQgNiBhcmUgY3VycmVudGx5IHVudXNlZC5cblx0ICpcblx0ICogRm9sbG93aW5nIHRoZSBoZWFkZXIgaXMgYSBzZXJpZXMgb2YgMCAoY2xvc2VQYXRoKSwgMiAobW92ZVRvLCBsaW5lVG8pLCA0IChxdWFkcmF0aWNDdXJ2ZVRvKSwgb3IgNiAoYmV6aWVyQ3VydmVUbylcblx0ICogcGFyYW1ldGVycy4gVGhlc2UgcGFyYW1ldGVycyBhcmUgYWx0ZXJuYXRpbmcgeC95IHBvc2l0aW9ucyByZXByZXNlbnRlZCBieSAyIG9yIDMgY2hhcmFjdGVycyAoYXMgaW5kaWNhdGVkIGJ5IHRoZVxuXHQgKiA0dGggYml0IGluIHRoZSBjb21tYW5kIGNoYXIpLiBUaGVzZSBjaGFyYWN0ZXJzIGNvbnNpc3Qgb2YgYSAxIGJpdCBzaWduICgxIGlzIG5lZ2F0aXZlLCAwIGlzIHBvc2l0aXZlKSwgZm9sbG93ZWRcblx0ICogYnkgYW4gMTEgKDIgY2hhcikgb3IgMTcgKDMgY2hhcikgYml0IGludGVnZXIgdmFsdWUuIEFsbCBwb3NpdGlvbiB2YWx1ZXMgYXJlIGluIHRlbnRocyBvZiBhIHBpeGVsLiBFeGNlcHQgaW4gdGhlXG5cdCAqIGNhc2Ugb2YgbW92ZSBvcGVyYXRpb25zIHdoaWNoIGFyZSBhYnNvbHV0ZSwgdGhpcyB2YWx1ZSBpcyBhIGRlbHRhIGZyb20gdGhlIHByZXZpb3VzIHggb3IgeSBwb3NpdGlvbiAoYXNcblx0ICogYXBwcm9wcmlhdGUpLlxuXHQgKlxuXHQgKiBGb3IgZXhhbXBsZSwgdGhlIHN0cmluZyBcIkEzY0FBTUF1NEFBQVwiIHJlcHJlc2VudHMgYSBsaW5lIHN0YXJ0aW5nIGF0IC0xNTAsMCBhbmQgZW5kaW5nIGF0IDE1MCwwLlxuXHQgKiA8YnIgLz5BIC0gYml0cyAwMDAwMDAuIEZpcnN0IDMgYml0cyAoMDAwKSBpbmRpY2F0ZSBhIG1vdmVUbyBvcGVyYXRpb24uIDR0aCBiaXQgKDApIGluZGljYXRlcyAyIGNoYXJzIHBlclxuXHQgKiBwYXJhbWV0ZXIuXG5cdCAqIDxiciAvPm4wIC0gMTEwMTExMDExMTAwLiBBYnNvbHV0ZSB4IHBvc2l0aW9uIG9mIC0xNTAuMHB4LiBGaXJzdCBiaXQgaW5kaWNhdGVzIGEgbmVnYXRpdmUgdmFsdWUsIHJlbWFpbmluZyBiaXRzXG5cdCAqIGluZGljYXRlIDE1MDAgdGVudGhzIG9mIGEgcGl4ZWwuXG5cdCAqIDxiciAvPkFBIC0gMDAwMDAwMDAwMDAwLiBBYnNvbHV0ZSB5IHBvc2l0aW9uIG9mIDAuXG5cdCAqIDxiciAvPkkgLSAwMDExMDAuIEZpcnN0IDMgYml0cyAoMDAxKSBpbmRpY2F0ZSBhIGxpbmVUbyBvcGVyYXRpb24uIDR0aCBiaXQgKDEpIGluZGljYXRlcyAzIGNoYXJzIHBlciBwYXJhbWV0ZXIuXG5cdCAqIDxiciAvPkF1NCAtIDAwMDAwMDEwMTExMDExMTAwMC4gQW4geCBkZWx0YSBvZiAzMDAuMHB4LCB3aGljaCBpcyBhZGRlZCB0byB0aGUgcHJldmlvdXMgeCB2YWx1ZSBvZiAtMTUwLjBweCB0b1xuXHQgKiBwcm92aWRlIGFuIGFic29sdXRlIHBvc2l0aW9uIG9mICsxNTAuMHB4LlxuXHQgKiA8YnIgLz5BQUEgLSAwMDAwMDAwMDAwMDAwMDAwMDAuIEEgeSBkZWx0YSB2YWx1ZSBvZiAwLlxuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcInBcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBkZWNvZGVQYXRoXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHBhdGggc3RyaW5nIHRvIGRlY29kZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmRlY29kZVBhdGggPSBmdW5jdGlvbihzdHIpIHtcblx0XHR2YXIgaW5zdHJ1Y3Rpb25zID0gW3RoaXMubW92ZVRvLCB0aGlzLmxpbmVUbywgdGhpcy5xdWFkcmF0aWNDdXJ2ZVRvLCB0aGlzLmJlemllckN1cnZlVG8sIHRoaXMuY2xvc2VQYXRoXTtcblx0XHR2YXIgcGFyYW1Db3VudCA9IFsyLCAyLCA0LCA2LCAwXTtcblx0XHR2YXIgaT0wLCBsPXN0ci5sZW5ndGg7XG5cdFx0dmFyIHBhcmFtcyA9IFtdO1xuXHRcdHZhciB4PTAsIHk9MDtcblx0XHR2YXIgYmFzZTY0ID0gR3JhcGhpY3MuQkFTRV82NDtcblxuXHRcdHdoaWxlIChpPGwpIHtcblx0XHRcdHZhciBjID0gc3RyLmNoYXJBdChpKTtcblx0XHRcdHZhciBuID0gYmFzZTY0W2NdO1xuXHRcdFx0dmFyIGZpID0gbj4+MzsgLy8gaGlnaGVzdCBvcmRlciBiaXRzIDEtMyBjb2RlIGZvciBvcGVyYXRpb24uXG5cdFx0XHR2YXIgZiA9IGluc3RydWN0aW9uc1tmaV07XG5cdFx0XHQvLyBjaGVjayB0aGF0IHdlIGhhdmUgYSB2YWxpZCBpbnN0cnVjdGlvbiAmIHRoYXQgdGhlIHVudXNlZCBiaXRzIGFyZSBlbXB0eTpcblx0XHRcdGlmICghZiB8fCAobiYzKSkgeyB0aHJvdyhcImJhZCBwYXRoIGRhdGEgKEBcIitpK1wiKTogXCIrYyk7IH1cblx0XHRcdHZhciBwbCA9IHBhcmFtQ291bnRbZmldO1xuXHRcdFx0aWYgKCFmaSkgeyB4PXk9MDsgfSAvLyBtb3ZlIG9wZXJhdGlvbnMgcmVzZXQgdGhlIHBvc2l0aW9uLlxuXHRcdFx0cGFyYW1zLmxlbmd0aCA9IDA7XG5cdFx0XHRpKys7XG5cdFx0XHR2YXIgY2hhckNvdW50ID0gKG4+PjImMSkrMjsgIC8vIDR0aCBoZWFkZXIgYml0IGluZGljYXRlcyBudW1iZXIgc2l6ZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdFx0XHRmb3IgKHZhciBwPTA7IHA8cGw7IHArKykge1xuXHRcdFx0XHR2YXIgbnVtID0gYmFzZTY0W3N0ci5jaGFyQXQoaSldO1xuXHRcdFx0XHR2YXIgc2lnbiA9IChudW0+PjUpID8gLTEgOiAxO1xuXHRcdFx0XHRudW0gPSAoKG51bSYzMSk8PDYpfChiYXNlNjRbc3RyLmNoYXJBdChpKzEpXSk7XG5cdFx0XHRcdGlmIChjaGFyQ291bnQgPT0gMykgeyBudW0gPSAobnVtPDw2KXwoYmFzZTY0W3N0ci5jaGFyQXQoaSsyKV0pOyB9XG5cdFx0XHRcdG51bSA9IHNpZ24qbnVtLzEwO1xuXHRcdFx0XHRpZiAocCUyKSB7IHggPSAobnVtICs9IHgpOyB9XG5cdFx0XHRcdGVsc2UgeyB5ID0gKG51bSArPSB5KTsgfVxuXHRcdFx0XHRwYXJhbXNbcF0gPSBudW07XG5cdFx0XHRcdGkgKz0gY2hhckNvdW50O1xuXHRcdFx0fVxuXHRcdFx0Zi5hcHBseSh0aGlzLHBhcmFtcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9yZXMgYWxsIGdyYXBoaWNzIGNvbW1hbmRzIHNvIHRoZXkgd29uJ3QgYmUgZXhlY3V0ZWQgaW4gZnV0dXJlIGRyYXdzLiBDYWxsaW5nIHN0b3JlKCkgYSBzZWNvbmQgdGltZSBhZGRzIHRvXG5cdCAqIHRoZSBleGlzdGluZyBzdG9yZS4gVGhpcyBhbHNvIGFmZmVjdHMgYGRyYXdBc1BhdGgoKWAuXG5cdCAqXG5cdCAqIFRoaXMgaXMgdXNlZnVsIGluIGNhc2VzIHdoZXJlIHlvdSBhcmUgY3JlYXRpbmcgdmVjdG9yIGdyYXBoaWNzIGluIGFuIGl0ZXJhdGl2ZSBtYW5uZXIgKGV4LiBnZW5lcmF0aXZlIGFydCksIHNvXG5cdCAqIHRoYXQgb25seSBuZXcgZ3JhcGhpY3MgbmVlZCB0byBiZSBkcmF3biAod2hpY2ggY2FuIHByb3ZpZGUgaHVnZSBwZXJmb3JtYW5jZSBiZW5lZml0cyksIGJ1dCB5b3Ugd2lzaCB0byByZXRhaW4gYWxsXG5cdCAqIG9mIHRoZSB2ZWN0b3IgaW5zdHJ1Y3Rpb25zIGZvciBsYXRlciB1c2UgKGV4LiBzY2FsaW5nLCBtb2RpZnlpbmcsIG9yIGV4cG9ydGluZykuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBjYWxsaW5nIHN0b3JlKCkgd2lsbCBmb3JjZSB0aGUgYWN0aXZlIHBhdGggKGlmIGFueSkgdG8gYmUgZW5kZWQgaW4gYSBtYW5uZXIgc2ltaWxhciB0byBjaGFuZ2luZ1xuXHQgKiB0aGUgZmlsbCBvciBzdHJva2UuXG5cdCAqXG5cdCAqIEZvciBleGFtcGxlLCBjb25zaWRlciBhIGFwcGxpY2F0aW9uIHdoZXJlIHRoZSB1c2VyIGRyYXdzIGxpbmVzIHdpdGggdGhlIG1vdXNlLiBBcyBlYWNoIGxpbmUgc2VnbWVudCAob3IgY29sbGVjdGlvbiBvZlxuXHQgKiBzZWdtZW50cykgYXJlIGFkZGVkIHRvIGEgU2hhcGUsIGl0IGNhbiBiZSByYXN0ZXJpemVkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvdXBkYXRlQ2FjaGVcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIGFuZCB0aGVuIHN0b3JlZCwgc28gdGhhdCBpdCBjYW4gYmUgcmVkcmF3biBhdCBhIGRpZmZlcmVudCBzY2FsZSB3aGVuIHRoZSBhcHBsaWNhdGlvbiBpcyByZXNpemVkLCBvciBleHBvcnRlZCB0byBTVkcuXG5cdCAqXG5cdCAqIFx0Ly8gc2V0IHVwIGNhY2hlOlxuXHQgKiBcdG15U2hhcGUuY2FjaGUoMCwwLDUwMCw1MDAsc2NhbGUpO1xuXHQgKlxuXHQgKiBcdC8vIHdoZW4gdGhlIHVzZXIgZHJhZ3MsIGRyYXcgYSBuZXcgbGluZTpcblx0ICogXHRteVNoYXBlLmdyYXBoaWNzLm1vdmVUbyhvbGRYLG9sZFkpLmxpbmVUbyhuZXdYLG5ld1kpO1xuXHQgKiBcdC8vIHRoZW4gZHJhdyBpdCBpbnRvIHRoZSBleGlzdGluZyBjYWNoZTpcblx0ICogXHRteVNoYXBlLnVwZGF0ZUNhY2hlKFwic291cmNlLW92ZXJcIik7XG5cdCAqIFx0Ly8gc3RvcmUgdGhlIG5ldyBsaW5lLCBzbyBpdCBpc24ndCByZWRyYXduIG5leHQgdGltZTpcblx0ICogXHRteVNoYXBlLnN0b3JlKCk7XG5cdCAqXG5cdCAqIFx0Ly8gdGhlbiwgd2hlbiB0aGUgd2luZG93IHJlc2l6ZXMsIHdlIGNhbiByZS1yZW5kZXIgYXQgYSBkaWZmZXJlbnQgc2NhbGU6XG5cdCAqIFx0Ly8gZmlyc3QsIHVuc3RvcmUgYWxsIG91ciBsaW5lczpcblx0ICogXHRteVNoYXBlLnVuc3RvcmUoKTtcblx0ICogXHQvLyB0aGVuIGNhY2hlIHVzaW5nIHRoZSBuZXcgc2NhbGU6XG5cdCAqIFx0bXlTaGFwZS5jYWNoZSgwLDAsNTAwLDUwMCxuZXdTY2FsZSk7XG5cdCAqIFx0Ly8gZmluYWxseSwgc3RvcmUgdGhlIGV4aXN0aW5nIGNvbW1hbmRzIGFnYWluOlxuXHQgKiBcdG15U2hhcGUuc3RvcmUoKTtcblx0ICpcblx0ICogQG1ldGhvZCBzdG9yZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuc3RvcmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnModHJ1ZSk7XG5cdFx0dGhpcy5fc3RvcmVJbmRleCA9IHRoaXMuX2luc3RydWN0aW9ucy5sZW5ndGg7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVuc3RvcmVzIGFueSBncmFwaGljcyBjb21tYW5kcyB0aGF0IHdlcmUgcHJldmlvdXNseSBzdG9yZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3Mvc3RvcmVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogc28gdGhhdCB0aGV5IHdpbGwgYmUgZXhlY3V0ZWQgaW4gc3Vic2VxdWVudCBkcmF3IGNhbGxzLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHVuc3RvcmVcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLnVuc3RvcmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9zdG9yZUluZGV4ID0gMDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgR3JhcGhpY3MgaW5zdGFuY2UuIE5vdGUgdGhhdCB0aGUgaW5kaXZpZHVhbCBjb21tYW5kIG9iamVjdHMgYXJlIG5vdCBjbG9uZWQuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IEEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgR3JhcGhpY3MgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvID0gbmV3IEdyYXBoaWNzKCk7XG5cdFx0by5jb21tYW5kID0gdGhpcy5jb21tYW5kO1xuXHRcdG8uX3N0cm9rZSA9IHRoaXMuX3N0cm9rZTtcblx0XHRvLl9zdHJva2VTdHlsZSA9IHRoaXMuX3N0cm9rZVN0eWxlO1xuXHRcdG8uX3N0cm9rZURhc2ggPSB0aGlzLl9zdHJva2VEYXNoO1xuXHRcdG8uX3N0cm9rZUlnbm9yZVNjYWxlID0gdGhpcy5fc3Ryb2tlSWdub3JlU2NhbGU7XG5cdFx0by5fZmlsbCA9IHRoaXMuX2ZpbGw7XG5cdFx0by5faW5zdHJ1Y3Rpb25zID0gdGhpcy5faW5zdHJ1Y3Rpb25zLnNsaWNlKCk7XG5cdFx0by5fY29tbWl0SW5kZXggPSB0aGlzLl9jb21taXRJbmRleDtcblx0XHRvLl9hY3RpdmVJbnN0cnVjdGlvbnMgPSB0aGlzLl9hY3RpdmVJbnN0cnVjdGlvbnMuc2xpY2UoKTtcblx0XHRvLl9kaXJ0eSA9IHRoaXMuX2RpcnR5O1xuXHRcdG8uX3N0b3JlSW5kZXggPSB0aGlzLl9zdG9yZUluZGV4O1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbR3JhcGhpY3NdXCI7XG5cdH07XG5cblxuLy8gdGlueSBBUEk6XG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBtb3ZlVG8uXG5cdCAqIEBtZXRob2QgbXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggY29vcmRpbmF0ZSB0aGUgZHJhd2luZyBwb2ludCBzaG91bGQgbW92ZSB0by5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZSB0aGUgZHJhd2luZyBwb2ludCBzaG91bGQgbW92ZSB0by5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscykuXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAubXQgPSBwLm1vdmVUbztcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gbGluZVRvLlxuXHQgKiBAbWV0aG9kIGx0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgdGhlIGRyYXdpbmcgcG9pbnQgc2hvdWxkIGRyYXcgdG8uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgdGhlIGRyYXdpbmcgcG9pbnQgc2hvdWxkIGRyYXcgdG8uXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmx0ID0gcC5saW5lVG87XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGFyY1RvLlxuXHQgKiBAbWV0aG9kIGF0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geTFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmF0ID0gcC5hcmNUbztcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYmV6aWVyQ3VydmVUby5cblx0ICogQG1ldGhvZCBidFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AxeFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AxeVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AyeFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AyeVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5idCA9IHAuYmV6aWVyQ3VydmVUbztcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gcXVhZHJhdGljQ3VydmVUbyAvIGN1cnZlVG8uXG5cdCAqIEBtZXRob2QgcXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNweFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3B5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAucXQgPSBwLnF1YWRyYXRpY0N1cnZlVG87XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGFyYy5cblx0ICogQG1ldGhvZCBhXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0QW5nbGUgTWVhc3VyZWQgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGVuZEFuZ2xlIE1lYXN1cmVkIGluIHJhZGlhbnMuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYW50aWNsb2Nrd2lzZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hID0gcC5hcmM7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIHJlY3QuXG5cdCAqIEBtZXRob2QgclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdyBXaWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoIEhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnIgPSBwLnJlY3Q7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGNsb3NlUGF0aC5cblx0ICogQG1ldGhvZCBjcFxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5jcCA9IHAuY2xvc2VQYXRoO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBjbGVhci5cblx0ICogQG1ldGhvZCBjXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmMgPSBwLmNsZWFyO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpbkZpbGwuXG5cdCAqIEBtZXRob2QgZlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQSBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZSAoZXguIFwicmVkXCIsIFwiI0ZGMDAwMFwiLCBvciBcInJnYmEoMjU1LDAsMCwwLjUpXCIpLiBTZXR0aW5nIHRvXG5cdCAqIG51bGwgd2lsbCByZXN1bHQgaW4gbm8gZmlsbC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuZiA9IHAuYmVnaW5GaWxsO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpbkxpbmVhckdyYWRpZW50RmlsbC5cblx0ICogQG1ldGhvZCBsZlxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnMgQW4gYXJyYXkgb2YgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWVzLiBGb3IgZXhhbXBsZSwgW1wiI0YwMFwiLFwiIzAwRlwiXSB3b3VsZCBkZWZpbmUgYSBncmFkaWVudFxuXHQgKiBkcmF3aW5nIGZyb20gcmVkIHRvIGJsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvcyBBbiBhcnJheSBvZiBncmFkaWVudCBwb3NpdGlvbnMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgY29sb3JzLiBGb3IgZXhhbXBsZSwgWzAuMSwgMC45XSB3b3VsZCBkcmF3XG5cdCAqIHRoZSBmaXJzdCBjb2xvciB0byAxMCUgdGhlbiBpbnRlcnBvbGF0aW5nIHRvIHRoZSBzZWNvbmQgY29sb3IgYXQgOTAlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDAgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwIFRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MSBUaGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5sZiA9IHAuYmVnaW5MaW5lYXJHcmFkaWVudEZpbGw7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luUmFkaWFsR3JhZGllbnRGaWxsLlxuXHQgKiBAbWV0aG9kIHJmXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBBbiBhcnJheSBvZiBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZXMuIEZvciBleGFtcGxlLCBbXCIjRjAwXCIsXCIjMDBGXCJdIHdvdWxkIGRlZmluZVxuXHQgKiBhIGdyYWRpZW50IGRyYXdpbmcgZnJvbSByZWQgdG8gYmx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zIEFuIGFycmF5IG9mIGdyYWRpZW50IHBvc2l0aW9ucyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjb2xvcnMuIEZvciBleGFtcGxlLCBbMC4xLFxuXHQgKiAwLjldIHdvdWxkIGRyYXcgdGhlIGZpcnN0IGNvbG9yIHRvIDEwJSB0aGVuIGludGVycG9sYXRpbmcgdG8gdGhlIHNlY29uZCBjb2xvciBhdCA5MCUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTAgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIwIFJhZGl1cyBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTEgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIxIFJhZGl1cyBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnJmID0gcC5iZWdpblJhZGlhbEdyYWRpZW50RmlsbDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYmVnaW5CaXRtYXBGaWxsLlxuXHQgKiBAbWV0aG9kIGJmXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgVGhlIEltYWdlLCBDYW52YXMsIG9yIFZpZGVvIG9iamVjdCB0byB1c2Vcblx0ICogYXMgdGhlIHBhdHRlcm4uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSByZXBldGl0aW9uIE9wdGlvbmFsLiBJbmRpY2F0ZXMgd2hldGhlciB0byByZXBlYXQgdGhlIGltYWdlIGluIHRoZSBmaWxsIGFyZWEuIE9uZSBvZiBcInJlcGVhdFwiLFxuXHQgKiBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gRGVmYXVsdHMgdG8gXCJyZXBlYXRcIi4gTm90ZSB0aGF0IEZpcmVmb3ggZG9lcyBub3Qgc3VwcG9ydCBcInJlcGVhdC14XCIgb3Jcblx0ICogXCJyZXBlYXQteVwiIChsYXRlc3QgdGVzdHMgd2VyZSBpbiBGRiAyMC4wKSwgYW5kIHdpbGwgZGVmYXVsdCB0byBcInJlcGVhdFwiLlxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXggT3B0aW9uYWwuIFNwZWNpZmllcyBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBmb3IgdGhlIGJpdG1hcCBmaWxsLiBUaGlzIHRyYW5zZm9ybWF0aW9uXG5cdCAqIHdpbGwgYmUgYXBwbGllZCByZWxhdGl2ZSB0byB0aGUgcGFyZW50IHRyYW5zZm9ybS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuYmYgPSBwLmJlZ2luQml0bWFwRmlsbDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gZW5kRmlsbC5cblx0ICogQG1ldGhvZCBlZlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5lZiA9IHAuZW5kRmlsbDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gc2V0U3Ryb2tlU3R5bGUuXG5cdCAqIEBtZXRob2Qgc3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRoaWNrbmVzcyBUaGUgd2lkdGggb2YgdGhlIHN0cm9rZS5cblx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IFtjYXBzPTBdIEluZGljYXRlcyB0aGUgdHlwZSBvZiBjYXBzIHRvIHVzZSBhdCB0aGUgZW5kIG9mIGxpbmVzLiBPbmUgb2YgYnV0dCxcblx0ICogcm91bmQsIG9yIHNxdWFyZS4gRGVmYXVsdHMgdG8gXCJidXR0XCIuIEFsc28gYWNjZXB0cyB0aGUgdmFsdWVzIDAgKGJ1dHQpLCAxIChyb3VuZCksIGFuZCAyIChzcXVhcmUpIGZvciB1c2Ugd2l0aFxuXHQgKiB0aGUgdGlueSBBUEkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBbam9pbnRzPTBdIFNwZWNpZmllcyB0aGUgdHlwZSBvZiBqb2ludHMgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVyZSB0d28gbGluZXMgbWVldC5cblx0ICogT25lIG9mIGJldmVsLCByb3VuZCwgb3IgbWl0ZXIuIERlZmF1bHRzIHRvIFwibWl0ZXJcIi4gQWxzbyBhY2NlcHRzIHRoZSB2YWx1ZXMgMCAobWl0ZXIpLCAxIChyb3VuZCksIGFuZCAyIChiZXZlbClcblx0ICogZm9yIHVzZSB3aXRoIHRoZSB0aW55IEFQSS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttaXRlckxpbWl0PTEwXSBJZiBqb2ludHMgaXMgc2V0IHRvIFwibWl0ZXJcIiwgdGhlbiB5b3UgY2FuIHNwZWNpZnkgYSBtaXRlciBsaW1pdCByYXRpbyB3aGljaFxuXHQgKiBjb250cm9scyBhdCB3aGF0IHBvaW50IGEgbWl0ZXJlZCBqb2ludCB3aWxsIGJlIGNsaXBwZWQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZVNjYWxlPWZhbHNlXSBJZiB0cnVlLCB0aGUgc3Ryb2tlIHdpbGwgYmUgZHJhd24gYXQgdGhlIHNwZWNpZmllZCB0aGlja25lc3MgcmVnYXJkbGVzc1xuXHQgKiBvZiBhY3RpdmUgdHJhbnNmb3JtYXRpb25zLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5zcyA9IHAuc2V0U3Ryb2tlU3R5bGU7XG5cdFxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gc2V0U3Ryb2tlRGFzaC5cblx0ICogQG1ldGhvZCBzZFxuXHQgKiBAcGFyYW0ge0FycmF5fSBbc2VnbWVudHNdIEFuIGFycmF5IHNwZWNpZnlpbmcgdGhlIGRhc2ggcGF0dGVybiwgYWx0ZXJuYXRpbmcgYmV0d2VlbiBsaW5lIGFuZCBnYXAuXG5cdCAqIEZvciBleGFtcGxlLCBbMjAsMTBdIHdvdWxkIGNyZWF0ZSBhIHBhdHRlcm4gb2YgMjAgcGl4ZWwgbGluZXMgd2l0aCAxMCBwaXhlbCBnYXBzIGJldHdlZW4gdGhlbS5cblx0ICogUGFzc2luZyBudWxsIG9yIGFuIGVtcHR5IGFycmF5IHdpbGwgY2xlYXIgYW55IGV4aXN0aW5nIGRhc2guXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0PTBdIFRoZSBvZmZzZXQgb2YgdGhlIGRhc2ggcGF0dGVybi4gRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCBpbmNyZW1lbnQgdGhpcyB2YWx1ZSB0byBjcmVhdGUgYSBcIm1hcmNoaW5nIGFudHNcIiBlZmZlY3QuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnNkID0gcC5zZXRTdHJva2VEYXNoO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpblN0cm9rZS5cblx0ICogQG1ldGhvZCBzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBBIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlIChleC4gXCIjRkYwMDAwXCIsIFwicmVkXCIsIG9yIFwicmdiYSgyNTUsMCwwLDAuNSlcIikuIFNldHRpbmcgdG9cblx0ICogbnVsbCB3aWxsIHJlc3VsdCBpbiBubyBzdHJva2UuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnMgPSBwLmJlZ2luU3Ryb2tlO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpbkxpbmVhckdyYWRpZW50U3Ryb2tlLlxuXHQgKiBAbWV0aG9kIGxzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBBbiBhcnJheSBvZiBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZXMuIEZvciBleGFtcGxlLCBbXCIjRjAwXCIsXCIjMDBGXCJdIHdvdWxkIGRlZmluZVxuXHQgKiBhIGdyYWRpZW50IGRyYXdpbmcgZnJvbSByZWQgdG8gYmx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zIEFuIGFycmF5IG9mIGdyYWRpZW50IHBvc2l0aW9ucyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjb2xvcnMuIEZvciBleGFtcGxlLCBbMC4xLFxuXHQgKiAwLjldIHdvdWxkIGRyYXcgdGhlIGZpcnN0IGNvbG9yIHRvIDEwJSB0aGVuIGludGVycG9sYXRpbmcgdG8gdGhlIHNlY29uZCBjb2xvciBhdCA5MCUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTAgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTEgVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmxzID0gcC5iZWdpbkxpbmVhckdyYWRpZW50U3Ryb2tlO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpblJhZGlhbEdyYWRpZW50U3Ryb2tlLlxuXHQgKiBAbWV0aG9kIHJzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBBbiBhcnJheSBvZiBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZXMuIEZvciBleGFtcGxlLCBbXCIjRjAwXCIsXCIjMDBGXCJdIHdvdWxkIGRlZmluZVxuXHQgKiBhIGdyYWRpZW50IGRyYXdpbmcgZnJvbSByZWQgdG8gYmx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zIEFuIGFycmF5IG9mIGdyYWRpZW50IHBvc2l0aW9ucyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjb2xvcnMuIEZvciBleGFtcGxlLCBbMC4xLFxuXHQgKiAwLjldIHdvdWxkIGRyYXcgdGhlIGZpcnN0IGNvbG9yIHRvIDEwJSB0aGVuIGludGVycG9sYXRpbmcgdG8gdGhlIHNlY29uZCBjb2xvciBhdCA5MCUsIHRoZW4gZHJhdyB0aGUgc2Vjb25kIGNvbG9yXG5cdCAqIHRvIDEwMCUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTAgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIwIFJhZGl1cyBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTEgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIxIFJhZGl1cyBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnJzID0gcC5iZWdpblJhZGlhbEdyYWRpZW50U3Ryb2tlO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpbkJpdG1hcFN0cm9rZS5cblx0ICogQG1ldGhvZCBic1xuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnR9IGltYWdlIFRoZSBJbWFnZSwgQ2FudmFzLCBvciBWaWRlbyBvYmplY3QgdG8gdXNlXG5cdCAqIGFzIHRoZSBwYXR0ZXJuLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3JlcGV0aXRpb249cmVwZWF0XSBPcHRpb25hbC4gSW5kaWNhdGVzIHdoZXRoZXIgdG8gcmVwZWF0IHRoZSBpbWFnZSBpbiB0aGUgZmlsbCBhcmVhLiBPbmUgb2Zcblx0ICogXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuIERlZmF1bHRzIHRvIFwicmVwZWF0XCIuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmJzID0gcC5iZWdpbkJpdG1hcFN0cm9rZTtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gZW5kU3Ryb2tlLlxuXHQgKiBAbWV0aG9kIGVzXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmVzID0gcC5lbmRTdHJva2U7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGRyYXdSZWN0LlxuXHQgKiBAbWV0aG9kIGRyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFdpZHRoIG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGggSGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuZHIgPSBwLmRyYXdSZWN0O1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBkcmF3Um91bmRSZWN0LlxuXHQgKiBAbWV0aG9kIHJyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgQ29ybmVyIHJhZGl1cy5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAucnIgPSBwLmRyYXdSb3VuZFJlY3Q7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGRyYXdSb3VuZFJlY3RDb21wbGV4LlxuXHQgKiBAbWV0aG9kIHJjXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUgdG8gZHJhdyB0aGUgcm91bmQgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUgdG8gZHJhdyB0aGUgcm91bmQgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHcgVGhlIHdpZHRoIG9mIHRoZSByb3VuZCByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaCBUaGUgaGVpZ2h0IG9mIHRoZSByb3VuZCByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzVEwgVG9wIGxlZnQgY29ybmVyIHJhZGl1cy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1RSIFRvcCByaWdodCBjb3JuZXIgcmFkaXVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzQlIgQm90dG9tIHJpZ2h0IGNvcm5lciByYWRpdXMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCTCBCb3R0b20gbGVmdCBjb3JuZXIgcmFkaXVzLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5yYyA9IHAuZHJhd1JvdW5kUmVjdENvbXBsZXg7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGRyYXdDaXJjbGUuXG5cdCAqIEBtZXRob2QgZGNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggeCBjb29yZGluYXRlIGNlbnRlciBwb2ludCBvZiBjaXJjbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IHkgY29vcmRpbmF0ZSBjZW50ZXIgcG9pbnQgb2YgY2lyY2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIFJhZGl1cyBvZiBjaXJjbGUuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmRjID0gcC5kcmF3Q2lyY2xlO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBkcmF3RWxsaXBzZS5cblx0ICogQG1ldGhvZCBkZVxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgbGVmdCBjb29yZGluYXRlIHBvaW50IG9mIHRoZSBlbGxpcHNlLiBOb3RlIHRoYXQgdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Q2lyY2xlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdoaWNoIGRyYXdzIGZyb20gY2VudGVyLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgdG9wIGNvb3JkaW5hdGUgcG9pbnQgb2YgdGhlIGVsbGlwc2UuIE5vdGUgdGhhdCB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdDaXJjbGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2hpY2ggZHJhd3MgZnJvbSB0aGUgY2VudGVyLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdyBUaGUgaGVpZ2h0IChob3Jpem9udGFsIGRpYW1ldGVyKSBvZiB0aGUgZWxsaXBzZS4gVGhlIGhvcml6b250YWwgcmFkaXVzIHdpbGwgYmUgaGFsZiBvZiB0aGlzXG5cdCAqIG51bWJlci5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGggVGhlIHdpZHRoICh2ZXJ0aWNhbCBkaWFtZXRlcikgb2YgdGhlIGVsbGlwc2UuIFRoZSB2ZXJ0aWNhbCByYWRpdXMgd2lsbCBiZSBoYWxmIG9mIHRoaXMgbnVtYmVyLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5kZSA9IHAuZHJhd0VsbGlwc2U7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGRyYXdQb2x5U3Rhci5cblx0ICogQG1ldGhvZCBkcFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBQb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoZSBzaGFwZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgUG9zaXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGUgc2hhcGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgc2hhcGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzaWRlcyBUaGUgbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgc3RhciBvciBzaWRlcyBvbiB0aGUgcG9seWdvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50U2l6ZSBUaGUgZGVwdGggb3IgXCJwb2ludHktbmVzc1wiIG9mIHRoZSBzdGFyIHBvaW50cy4gQSBwb2ludFNpemUgb2YgMCB3aWxsIGRyYXcgYSByZWd1bGFyXG5cdCAqIHBvbHlnb24gKG5vIHBvaW50cyksIGEgcG9pbnRTaXplIG9mIDEgd2lsbCBkcmF3IG5vdGhpbmcgYmVjYXVzZSB0aGUgcG9pbnRzIGFyZSBpbmZpbml0ZWx5IHBvaW50eS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIFRoZSBhbmdsZSBvZiB0aGUgZmlyc3QgcG9pbnQgLyBjb3JuZXIuIEZvciBleGFtcGxlIGEgdmFsdWUgb2YgMCB3aWxsIGRyYXcgdGhlIGZpcnN0IHBvaW50XG5cdCAqIGRpcmVjdGx5IHRvIHRoZSByaWdodCBvZiB0aGUgY2VudGVyLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5kcCA9IHAuZHJhd1BvbHlTdGFyO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBkZWNvZGVQYXRoLlxuXHQgKiBAbWV0aG9kIHBcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgcGF0aCBzdHJpbmcgdG8gZGVjb2RlLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5wID0gcC5kZWNvZGVQYXRoO1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX3VwZGF0ZUluc3RydWN0aW9uc1xuXHQgKiBAcGFyYW0gY29tbWl0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl91cGRhdGVJbnN0cnVjdGlvbnMgPSBmdW5jdGlvbihjb21taXQpIHtcblx0XHR2YXIgaW5zdHIgPSB0aGlzLl9pbnN0cnVjdGlvbnMsIGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZUluc3RydWN0aW9ucywgY29tbWl0SW5kZXggPSB0aGlzLl9jb21taXRJbmRleDtcblxuXHRcdGlmICh0aGlzLl9kaXJ0eSAmJiBhY3RpdmUubGVuZ3RoKSB7XG5cdFx0XHRpbnN0ci5sZW5ndGggPSBjb21taXRJbmRleDsgLy8gcmVtb3ZlIG9sZCwgdW5jb21taXR0ZWQgY29tbWFuZHNcblx0XHRcdGluc3RyLnB1c2goR3JhcGhpY3MuYmVnaW5DbWQpO1xuXG5cdFx0XHR2YXIgbCA9IGFjdGl2ZS5sZW5ndGgsIGxsID0gaW5zdHIubGVuZ3RoO1xuXHRcdFx0aW5zdHIubGVuZ3RoID0gbGwrbDtcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKyspIHsgaW5zdHJbaStsbF0gPSBhY3RpdmVbaV07IH1cblxuXHRcdFx0aWYgKHRoaXMuX2ZpbGwpIHsgaW5zdHIucHVzaCh0aGlzLl9maWxsKTsgfVxuXHRcdFx0aWYgKHRoaXMuX3N0cm9rZSkge1xuXHRcdFx0XHQvLyBkb2Vzbid0IG5lZWQgdG8gYmUgcmUtYXBwbGllZCBpZiBpdCBoYXNuJ3QgY2hhbmdlZC5cblx0XHRcdFx0aWYgKHRoaXMuX3N0cm9rZURhc2ggIT09IHRoaXMuX29sZFN0cm9rZURhc2gpIHtcblx0XHRcdFx0XHR0aGlzLl9vbGRTdHJva2VEYXNoID0gdGhpcy5fc3Ryb2tlRGFzaDtcblx0XHRcdFx0XHRpbnN0ci5wdXNoKHRoaXMuX3N0cm9rZURhc2gpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl9zdHJva2VTdHlsZSAhPT0gdGhpcy5fb2xkU3Ryb2tlU3R5bGUpIHtcblx0XHRcdFx0XHR0aGlzLl9vbGRTdHJva2VTdHlsZSA9IHRoaXMuX3N0cm9rZVN0eWxlO1xuXHRcdFx0XHRcdGluc3RyLnB1c2godGhpcy5fc3Ryb2tlU3R5bGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluc3RyLnB1c2godGhpcy5fc3Ryb2tlKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoY29tbWl0KSB7XG5cdFx0XHRhY3RpdmUubGVuZ3RoID0gMDtcblx0XHRcdHRoaXMuX2NvbW1pdEluZGV4ID0gaW5zdHIubGVuZ3RoO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfc2V0RmlsbFxuXHQgKiBAcGFyYW0gZmlsbFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fc2V0RmlsbCA9IGZ1bmN0aW9uKGZpbGwpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnModHJ1ZSk7XG5cdFx0dGhpcy5jb21tYW5kID0gdGhpcy5fZmlsbCA9IGZpbGw7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3NldFN0cm9rZVxuXHQgKiBAcGFyYW0gc3Ryb2tlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9zZXRTdHJva2UgPSBmdW5jdGlvbihzdHJva2UpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnModHJ1ZSk7XG5cdFx0aWYgKHRoaXMuY29tbWFuZCA9IHRoaXMuX3N0cm9rZSA9IHN0cm9rZSkge1xuXHRcdFx0c3Ryb2tlLmlnbm9yZVNjYWxlID0gdGhpcy5fc3Ryb2tlSWdub3JlU2NhbGU7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG4vLyBDb21tYW5kIE9iamVjdHM6XG5cdC8qKlxuXHQgKiBAbmFtZXNwYWNlIEdyYXBoaWNzXG5cdCAqL1xuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9saW5lVG9cIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBMaW5lVG9cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqL1xuXHQoRy5MaW5lVG8gPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LmxpbmVUbyh0aGlzLngsdGhpcy55KTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9tb3ZlVG9cIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIE1vdmVUb1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdChHLk1vdmVUbyA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHgubW92ZVRvKHRoaXMueCwgdGhpcy55KTsgfTtcblxuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FyY1RvXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBBcmNUb1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geDJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHgxXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5MVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeDJcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHkyXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSByYWRpdXNcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdChHLkFyY1RvID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuXHRcdHRoaXMueDEgPSB4MTsgdGhpcy55MSA9IHkxO1xuXHRcdHRoaXMueDIgPSB4MjsgdGhpcy55MiA9IHkyO1xuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHguYXJjVG8odGhpcy54MSwgdGhpcy55MSwgdGhpcy54MiwgdGhpcy55MiwgdGhpcy5yYWRpdXMpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FyY1wifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgQXJjXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEFuZ2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBlbmRBbmdsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW50aWNsb2Nrd2lzZVxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcmFkaXVzXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBzdGFydEFuZ2xlXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBlbmRBbmdsZVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgYW50aWNsb2Nrd2lzZVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKi9cblx0KEcuQXJjID0gZnVuY3Rpb24oeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdFx0dGhpcy5zdGFydEFuZ2xlID0gc3RhcnRBbmdsZTsgdGhpcy5lbmRBbmdsZSA9IGVuZEFuZ2xlO1xuXHRcdHRoaXMuYW50aWNsb2Nrd2lzZSA9ICEhYW50aWNsb2Nrd2lzZTtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LmFyYyh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMsIHRoaXMuc3RhcnRBbmdsZSwgdGhpcy5lbmRBbmdsZSwgdGhpcy5hbnRpY2xvY2t3aXNlKTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9xdWFkcmF0aWNDdXJ2ZVRvXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBRdWFkcmF0aWNDdXJ2ZVRvXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3B4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGNweFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgY3B5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqL1xuXHQoRy5RdWFkcmF0aWNDdXJ2ZVRvID0gZnVuY3Rpb24oY3B4LCBjcHksIHgsIHkpIHtcblx0XHR0aGlzLmNweCA9IGNweDsgdGhpcy5jcHkgPSBjcHk7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LnF1YWRyYXRpY0N1cnZlVG8odGhpcy5jcHgsIHRoaXMuY3B5LCB0aGlzLngsIHRoaXMueSk7IH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmV6aWVyQ3VydmVUb1wifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgQmV6aWVyQ3VydmVUb1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMXhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMXlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMnhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNwMnlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGNwMXhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGNwMXlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGNwMnhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGNwMnlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdChHLkJlemllckN1cnZlVG8gPSBmdW5jdGlvbihjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSB7XG5cdFx0dGhpcy5jcDF4ID0gY3AxeDsgdGhpcy5jcDF5ID0gY3AxeTtcblx0XHR0aGlzLmNwMnggPSBjcDJ4OyB0aGlzLmNwMnkgPSBjcDJ5O1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7IGN0eC5iZXppZXJDdXJ2ZVRvKHRoaXMuY3AxeCwgdGhpcy5jcDF5LCB0aGlzLmNwMngsIHRoaXMuY3AyeSwgdGhpcy54LCB0aGlzLnkpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3JlY3RcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIFJlY3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB3XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBoXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqL1xuXHQoRy5SZWN0ID0gZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdFx0dGhpcy53ID0gdzsgdGhpcy5oID0gaDtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LnJlY3QodGhpcy54LCB0aGlzLnksIHRoaXMudywgdGhpcy5oKTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9jbG9zZVBhdGhcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIENsb3NlUGF0aFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdChHLkNsb3NlUGF0aCA9IGZ1bmN0aW9uKCkge1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHguY2xvc2VQYXRoKCk7IH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0IHRvIGJlZ2luIGEgbmV3IHBhdGguIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljc1wifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgQmVnaW5QYXRoXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKi9cblx0KEcuQmVnaW5QYXRoID0gZnVuY3Rpb24oKSB7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7IGN0eC5iZWdpblBhdGgoKTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkZpbGxcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIEZpbGxcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSBBIHZhbGlkIENvbnRleHQyRCBmaWxsU3R5bGUuXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeFxuXHQgKiovXG5cdC8qKlxuXHQgKiBBIHZhbGlkIENvbnRleHQyRCBmaWxsU3R5bGUuXG5cdCAqIEBwcm9wZXJ0eSBzdHlsZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgbWF0cml4XG5cdCAqIEB0eXBlIE1hdHJpeDJEXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdHAgPSAoRy5GaWxsID0gZnVuY3Rpb24oc3R5bGUsIG1hdHJpeCkge1xuXHRcdHRoaXMuc3R5bGUgPSBzdHlsZTtcblx0XHR0aGlzLm1hdHJpeCA9IG1hdHJpeDtcblx0fSkucHJvdG90eXBlO1xuXHRwLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHtcblx0XHRpZiAoIXRoaXMuc3R5bGUpIHsgcmV0dXJuOyB9XG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHRoaXMuc3R5bGU7XG5cdFx0dmFyIG10eCA9IHRoaXMubWF0cml4O1xuXHRcdGlmIChtdHgpIHsgY3R4LnNhdmUoKTsgY3R4LnRyYW5zZm9ybShtdHguYSwgbXR4LmIsIG10eC5jLCBtdHguZCwgbXR4LnR4LCBtdHgudHkpOyB9XG5cdFx0Y3R4LmZpbGwoKTtcblx0XHRpZiAobXR4KSB7IGN0eC5yZXN0b3JlKCk7IH1cblx0fTtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBsaW5lYXIgZ3JhZGllbnQgc3R5bGUgYW5kIGFzc2lnbnMgaXQgdG8ge3sjY3Jvc3NMaW5rIFwiRmlsbC9zdHlsZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luTGluZWFyR3JhZGllbnRGaWxsXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIGxpbmVhckdyYWRpZW50XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9yc1xuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MFxuXHQgKiBAcGFyYW0ge051bWJlcn0geDFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxXG5cdCAqIEByZXR1cm4ge0ZpbGx9IFJldHVybnMgdGhpcyBGaWxsIG9iamVjdCBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cblx0ICovXG5cdHAubGluZWFyR3JhZGllbnQgPSBmdW5jdGlvbihjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCB4MSwgeTEpIHtcblx0XHR2YXIgbyA9IHRoaXMuc3R5bGUgPSAgR3JhcGhpY3MuX2N0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4MCwgeTAsIHgxLCB5MSk7XG5cdFx0Zm9yICh2YXIgaT0wLCBsPWNvbG9ycy5sZW5ndGg7IGk8bDsgaSsrKSB7IG8uYWRkQ29sb3JTdG9wKHJhdGlvc1tpXSwgY29sb3JzW2ldKTsgfVxuXHRcdG8ucHJvcHMgPSB7Y29sb3JzOmNvbG9ycywgcmF0aW9zOnJhdGlvcywgeDA6eDAsIHkwOnkwLCB4MTp4MSwgeTE6eTEsIHR5cGU6XCJsaW5lYXJcIn07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgcmFkaWFsIGdyYWRpZW50IHN0eWxlIGFuZCBhc3NpZ25zIGl0IHRvIHt7I2Nyb3NzTGluayBcIkZpbGwvc3R5bGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpblJhZGlhbEdyYWRpZW50RmlsbFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQG1ldGhvZCByYWRpYWxHcmFkaWVudFxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnNcblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MFxuXHQgKiBAcGFyYW0ge051bWJlcn0geTBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geTFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHIxXG5cdCAqIEByZXR1cm4ge0ZpbGx9IFJldHVybnMgdGhpcyBGaWxsIG9iamVjdCBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cblx0ICovXG5cdHAucmFkaWFsR3JhZGllbnQgPSBmdW5jdGlvbihjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCByMCwgeDEsIHkxLCByMSkge1xuXHRcdHZhciBvID0gdGhpcy5zdHlsZSA9ICBHcmFwaGljcy5fY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHgwLCB5MCwgcjAsIHgxLCB5MSwgcjEpO1xuXHRcdGZvciAodmFyIGk9MCwgbD1jb2xvcnMubGVuZ3RoOyBpPGw7IGkrKykgeyBvLmFkZENvbG9yU3RvcChyYXRpb3NbaV0sIGNvbG9yc1tpXSk7IH1cblx0XHRvLnByb3BzID0ge2NvbG9yczpjb2xvcnMsIHJhdGlvczpyYXRpb3MsIHgwOngwLCB5MDp5MCwgcjA6cjAsIHgxOngxLCB5MTp5MSwgcjE6cjEsIHR5cGU6XCJyYWRpYWxcIn07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgYml0bWFwIGZpbGwgc3R5bGUgYW5kIGFzc2lnbnMgaXQgdG8gdGhlIHt7I2Nyb3NzTGluayBcIkZpbGwvc3R5bGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkJpdG1hcEZpbGxcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBtZXRob2QgYml0bWFwXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgIE11c3QgYmUgbG9hZGVkIHByaW9yIHRvIGNyZWF0aW5nIGEgYml0bWFwIGZpbGwsIG9yIHRoZSBmaWxsIHdpbGwgYmUgZW1wdHkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcmVwZXRpdGlvbl0gT25lIG9mOiByZXBlYXQsIHJlcGVhdC14LCByZXBlYXQteSwgb3Igbm8tcmVwZWF0LlxuXHQgKiBAcmV0dXJuIHtGaWxsfSBSZXR1cm5zIHRoaXMgRmlsbCBvYmplY3QgZm9yIGNoYWluaW5nIG9yIGFzc2lnbm1lbnQuXG5cdCAqL1xuXHRwLmJpdG1hcCA9IGZ1bmN0aW9uKGltYWdlLCByZXBldGl0aW9uKSB7XG5cdFx0aWYgKGltYWdlLm5hdHVyYWxXaWR0aCB8fCBpbWFnZS5nZXRDb250ZXh0IHx8IGltYWdlLnJlYWR5U3RhdGUgPj0gMikge1xuXHRcdFx0dmFyIG8gPSB0aGlzLnN0eWxlID0gR3JhcGhpY3MuX2N0eC5jcmVhdGVQYXR0ZXJuKGltYWdlLCByZXBldGl0aW9uIHx8IFwiXCIpO1xuXHRcdFx0by5wcm9wcyA9IHtpbWFnZTogaW1hZ2UsIHJlcGV0aXRpb246IHJlcGV0aXRpb24sIHR5cGU6IFwiYml0bWFwXCJ9O1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0cC5wYXRoID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5TdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIFN0cm9rZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIEEgdmFsaWQgQ29udGV4dDJEIGZpbGxTdHlsZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVTY2FsZVxuXHQgKiovXG5cdC8qKlxuXHQgKiBBIHZhbGlkIENvbnRleHQyRCBzdHJva2VTdHlsZS5cblx0ICogQHByb3BlcnR5IHN0eWxlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBpZ25vcmVTY2FsZVxuXHQgKiBAdHlwZSBCb29sZWFuXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdHAgPSAoRy5TdHJva2UgPSBmdW5jdGlvbihzdHlsZSwgaWdub3JlU2NhbGUpIHtcblx0XHR0aGlzLnN0eWxlID0gc3R5bGU7XG5cdFx0dGhpcy5pZ25vcmVTY2FsZSA9IGlnbm9yZVNjYWxlO1xuXHR9KS5wcm90b3R5cGU7XG5cdHAuZXhlYyA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGlmICghdGhpcy5zdHlsZSkgeyByZXR1cm47IH1cblx0XHRjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnN0eWxlO1xuXHRcdGlmICh0aGlzLmlnbm9yZVNjYWxlKSB7IGN0eC5zYXZlKCk7IGN0eC5zZXRUcmFuc2Zvcm0oMSwwLDAsMSwwLDApOyB9XG5cdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdGlmICh0aGlzLmlnbm9yZVNjYWxlKSB7IGN0eC5yZXN0b3JlKCk7IH1cblx0fTtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBsaW5lYXIgZ3JhZGllbnQgc3R5bGUgYW5kIGFzc2lnbnMgaXQgdG8ge3sjY3Jvc3NMaW5rIFwiU3Ryb2tlL3N0eWxlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5MaW5lYXJHcmFkaWVudFN0cm9rZVwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQG1ldGhvZCBsaW5lYXJHcmFkaWVudFxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnNcblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MFxuXHQgKiBAcGFyYW0ge051bWJlcn0geTBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuXHQgKiBAcmV0dXJuIHtGaWxsfSBSZXR1cm5zIHRoaXMgU3Ryb2tlIG9iamVjdCBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cblx0ICovXG5cdHAubGluZWFyR3JhZGllbnQgPSBHLkZpbGwucHJvdG90eXBlLmxpbmVhckdyYWRpZW50O1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIHJhZGlhbCBncmFkaWVudCBzdHlsZSBhbmQgYXNzaWducyBpdCB0byB7eyNjcm9zc0xpbmsgXCJTdHJva2Uvc3R5bGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpblJhZGlhbEdyYWRpZW50U3Ryb2tlXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIHJhZGlhbEdyYWRpZW50XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9yc1xuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjFcblx0ICogQHJldHVybiB7RmlsbH0gUmV0dXJucyB0aGlzIFN0cm9rZSBvYmplY3QgZm9yIGNoYWluaW5nIG9yIGFzc2lnbm1lbnQuXG5cdCAqL1xuXHRwLnJhZGlhbEdyYWRpZW50ID0gRy5GaWxsLnByb3RvdHlwZS5yYWRpYWxHcmFkaWVudDtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBiaXRtYXAgZmlsbCBzdHlsZSBhbmQgYXNzaWducyBpdCB0byB7eyNjcm9zc0xpbmsgXCJTdHJva2Uvc3R5bGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkJpdG1hcFN0cm9rZVwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQG1ldGhvZCBiaXRtYXBcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBpbWFnZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3JlcGV0aXRpb25dIE9uZSBvZjogcmVwZWF0LCByZXBlYXQteCwgcmVwZWF0LXksIG9yIG5vLXJlcGVhdC5cblx0ICogQHJldHVybiB7RmlsbH0gUmV0dXJucyB0aGlzIFN0cm9rZSBvYmplY3QgZm9yIGNoYWluaW5nIG9yIGFzc2lnbm1lbnQuXG5cdCAqL1xuXHRwLmJpdG1hcCA9IEcuRmlsbC5wcm90b3R5cGUuYml0bWFwO1xuXHRwLnBhdGggPSBmYWxzZTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9zZXRTdHJva2VTdHlsZVwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgU3Ryb2tlU3R5bGVcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2NhcHNdXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbam9pbnRzXVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW21pdGVyTGltaXRdXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB3aWR0aFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBPbmUgb2Y6IGJ1dHQsIHJvdW5kLCBzcXVhcmVcblx0ICogQHByb3BlcnR5IGNhcHNcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqL1xuXHQvKipcblx0ICogT25lIG9mOiByb3VuZCwgYmV2ZWwsIG1pdGVyXG5cdCAqIEBwcm9wZXJ0eSBqb2ludHNcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IG1pdGVyTGltaXRcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdHAgPSAoRy5TdHJva2VTdHlsZSA9IGZ1bmN0aW9uKHdpZHRoLCBjYXBzLCBqb2ludHMsIG1pdGVyTGltaXQpIHtcblx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5jYXBzID0gY2Fwcztcblx0XHR0aGlzLmpvaW50cyA9IGpvaW50cztcblx0XHR0aGlzLm1pdGVyTGltaXQgPSBtaXRlckxpbWl0O1xuXHR9KS5wcm90b3R5cGU7XG5cdHAuZXhlYyA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGN0eC5saW5lV2lkdGggPSAodGhpcy53aWR0aCA9PSBudWxsID8gXCIxXCIgOiB0aGlzLndpZHRoKTtcblx0XHRjdHgubGluZUNhcCA9ICh0aGlzLmNhcHMgPT0gbnVsbCA/IFwiYnV0dFwiIDogKGlzTmFOKHRoaXMuY2FwcykgPyB0aGlzLmNhcHMgOiBHcmFwaGljcy5TVFJPS0VfQ0FQU19NQVBbdGhpcy5jYXBzXSkpO1xuXHRcdGN0eC5saW5lSm9pbiA9ICh0aGlzLmpvaW50cyA9PSBudWxsID8gXCJtaXRlclwiIDogKGlzTmFOKHRoaXMuam9pbnRzKSA/IHRoaXMuam9pbnRzIDogR3JhcGhpY3MuU1RST0tFX0pPSU5UU19NQVBbdGhpcy5qb2ludHNdKSk7XG5cdFx0Y3R4Lm1pdGVyTGltaXQgPSAodGhpcy5taXRlckxpbWl0ID09IG51bGwgPyBcIjEwXCIgOiB0aGlzLm1pdGVyTGltaXQpO1xuXHR9O1xuXHRwLnBhdGggPSBmYWxzZTtcblx0XG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3NldFN0cm9rZURhc2hcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIFN0cm9rZURhc2hcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtzZWdtZW50c11cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXQ9MF1cblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHNlZ21lbnRzXG5cdCAqIEB0eXBlIEFycmF5XG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IG9mZnNldFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKi9cblx0KEcuU3Ryb2tlRGFzaCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBvZmZzZXQpIHtcblx0XHR0aGlzLnNlZ21lbnRzID0gc2VnbWVudHM7XG5cdFx0dGhpcy5vZmZzZXQgPSBvZmZzZXR8fDA7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkgeyAvLyBmZWF0dXJlIGRldGVjdGlvbi5cblx0XHRcdGN0eC5zZXRMaW5lRGFzaCh0aGlzLnNlZ21lbnRzfHwgRy5TdHJva2VEYXNoLkVNUFRZX1NFR01FTlRTKTsgLy8gaW5zdGVhZCBvZiBbXSB0byByZWR1Y2UgY2h1cm4uXG5cdFx0XHRjdHgubGluZURhc2hPZmZzZXQgPSB0aGlzLm9mZnNldHx8MDtcblx0XHR9XG5cdH07XG5cdC8qKlxuXHQgKiBUaGUgZGVmYXVsdCB2YWx1ZSBmb3Igc2VnbWVudHMgKGllLiBubyBkYXNoKS5cblx0ICogQHByb3BlcnR5IEVNUFRZX1NFR01FTlRTXG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqIEByZWFkb25seVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICoqL1xuXHRHLlN0cm9rZURhc2guRU1QVFlfU0VHTUVOVFMgPSBbXTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Um91bmRSZWN0Q29tcGxleFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgUm91bmRSZWN0XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gd1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzVExcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1RSXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCUlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzQkxcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHdcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHJhZGl1c1RMXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSByYWRpdXNUUlxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcmFkaXVzQlJcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHJhZGl1c0JMXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqL1xuXHQoRy5Sb3VuZFJlY3QgPSBmdW5jdGlvbih4LCB5LCB3LCBoLCByYWRpdXNUTCwgcmFkaXVzVFIsIHJhZGl1c0JSLCByYWRpdXNCTCkge1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdFx0dGhpcy53ID0gdzsgdGhpcy5oID0gaDtcblx0XHR0aGlzLnJhZGl1c1RMID0gcmFkaXVzVEw7IHRoaXMucmFkaXVzVFIgPSByYWRpdXNUUjtcblx0XHR0aGlzLnJhZGl1c0JSID0gcmFkaXVzQlI7IHRoaXMucmFkaXVzQkwgPSByYWRpdXNCTDtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHtcblx0XHR2YXIgbWF4ID0gKHc8aD93OmgpLzI7XG5cdFx0dmFyIG1UTD0wLCBtVFI9MCwgbUJSPTAsIG1CTD0wO1xuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB3ID0gdGhpcy53LCBoID0gdGhpcy5oO1xuXHRcdHZhciByVEwgPSB0aGlzLnJhZGl1c1RMLCByVFIgPSB0aGlzLnJhZGl1c1RSLCByQlIgPSB0aGlzLnJhZGl1c0JSLCByQkwgPSB0aGlzLnJhZGl1c0JMO1xuXG5cdFx0aWYgKHJUTCA8IDApIHsgclRMICo9IChtVEw9LTEpOyB9XG5cdFx0aWYgKHJUTCA+IG1heCkgeyByVEwgPSBtYXg7IH1cblx0XHRpZiAoclRSIDwgMCkgeyByVFIgKj0gKG1UUj0tMSk7IH1cblx0XHRpZiAoclRSID4gbWF4KSB7IHJUUiA9IG1heDsgfVxuXHRcdGlmIChyQlIgPCAwKSB7IHJCUiAqPSAobUJSPS0xKTsgfVxuXHRcdGlmIChyQlIgPiBtYXgpIHsgckJSID0gbWF4OyB9XG5cdFx0aWYgKHJCTCA8IDApIHsgckJMICo9IChtQkw9LTEpOyB9XG5cdFx0aWYgKHJCTCA+IG1heCkgeyByQkwgPSBtYXg7IH1cblxuXHRcdGN0eC5tb3ZlVG8oeCt3LXJUUiwgeSk7XG5cdFx0Y3R4LmFyY1RvKHgrdytyVFIqbVRSLCB5LXJUUiptVFIsIHgrdywgeStyVFIsIHJUUik7XG5cdFx0Y3R4LmxpbmVUbyh4K3csIHkraC1yQlIpO1xuXHRcdGN0eC5hcmNUbyh4K3crckJSKm1CUiwgeStoK3JCUiptQlIsIHgrdy1yQlIsIHkraCwgckJSKTtcblx0XHRjdHgubGluZVRvKHgrckJMLCB5K2gpO1xuXHRcdGN0eC5hcmNUbyh4LXJCTCptQkwsIHkraCtyQkwqbUJMLCB4LCB5K2gtckJMLCByQkwpO1xuXHRcdGN0eC5saW5lVG8oeCwgeStyVEwpO1xuXHRcdGN0eC5hcmNUbyh4LXJUTCptVEwsIHktclRMKm1UTCwgeCtyVEwsIHksIHJUTCk7XG5cdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdDaXJjbGVcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIENpcmNsZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcmFkaXVzXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqL1xuXHQoRy5DaXJjbGUgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMpIHtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHguYXJjKHRoaXMueCwgdGhpcy55LCB0aGlzLnJhZGl1cywgMCwgTWF0aC5QSSoyKTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3RWxsaXBzZVwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgRWxsaXBzZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHdcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdChHLkVsbGlwc2UgPSBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0XHR0aGlzLncgPSB3OyB0aGlzLmggPSBoO1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xuXHRcdHZhciB3ID0gdGhpcy53LCBoID0gdGhpcy5oO1xuXG5cdFx0dmFyIGsgPSAwLjU1MjI4NDg7XG5cdFx0dmFyIG94ID0gKHcgLyAyKSAqIGs7XG5cdFx0dmFyIG95ID0gKGggLyAyKSAqIGs7XG5cdFx0dmFyIHhlID0geCArIHc7XG5cdFx0dmFyIHllID0geSArIGg7XG5cdFx0dmFyIHhtID0geCArIHcgLyAyO1xuXHRcdHZhciB5bSA9IHkgKyBoIC8gMjtcblxuXHRcdGN0eC5tb3ZlVG8oeCwgeW0pO1xuXHRcdGN0eC5iZXppZXJDdXJ2ZVRvKHgsIHltLW95LCB4bS1veCwgeSwgeG0sIHkpO1xuXHRcdGN0eC5iZXppZXJDdXJ2ZVRvKHhtK294LCB5LCB4ZSwgeW0tb3ksIHhlLCB5bSk7XG5cdFx0Y3R4LmJlemllckN1cnZlVG8oeGUsIHltK295LCB4bStveCwgeWUsIHhtLCB5ZSk7XG5cdFx0Y3R4LmJlemllckN1cnZlVG8oeG0tb3gsIHllLCB4LCB5bStveSwgeCwgeW0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdQb2x5U3RhclwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgUG9seVN0YXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNpZGVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludFNpemVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSByYWRpdXNcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHNpZGVzXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBwb2ludFNpemVcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGFuZ2xlXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqL1xuXHQoRy5Qb2x5U3RhciA9IGZ1bmN0aW9uKHgsIHksIHJhZGl1cywgc2lkZXMsIHBvaW50U2l6ZSwgYW5nbGUpIHtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuXHRcdHRoaXMuc2lkZXMgPSBzaWRlcztcblx0XHR0aGlzLnBvaW50U2l6ZSA9IHBvaW50U2l6ZTtcblx0XHR0aGlzLmFuZ2xlID0gYW5nbGU7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG5cdFx0dmFyIHJhZGl1cyA9IHRoaXMucmFkaXVzO1xuXHRcdHZhciBhbmdsZSA9ICh0aGlzLmFuZ2xlfHwwKS8xODAqTWF0aC5QSTtcblx0XHR2YXIgc2lkZXMgPSB0aGlzLnNpZGVzO1xuXHRcdHZhciBwcyA9IDEtKHRoaXMucG9pbnRTaXplfHwwKTtcblx0XHR2YXIgYSA9IE1hdGguUEkvc2lkZXM7XG5cblx0XHRjdHgubW92ZVRvKHgrTWF0aC5jb3MoYW5nbGUpKnJhZGl1cywgeStNYXRoLnNpbihhbmdsZSkqcmFkaXVzKTtcblx0XHRmb3IgKHZhciBpPTA7IGk8c2lkZXM7IGkrKykge1xuXHRcdFx0YW5nbGUgKz0gYTtcblx0XHRcdGlmIChwcyAhPSAxKSB7XG5cdFx0XHRcdGN0eC5saW5lVG8oeCtNYXRoLmNvcyhhbmdsZSkqcmFkaXVzKnBzLCB5K01hdGguc2luKGFuZ2xlKSpyYWRpdXMqcHMpO1xuXHRcdFx0fVxuXHRcdFx0YW5nbGUgKz0gYTtcblx0XHRcdGN0eC5saW5lVG8oeCtNYXRoLmNvcyhhbmdsZSkqcmFkaXVzLCB5K01hdGguc2luKGFuZ2xlKSpyYWRpdXMpO1xuXHRcdH1cblx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdH07XG5cblx0Ly8gZG9jY2VkIGFib3ZlLlxuXHRHcmFwaGljcy5iZWdpbkNtZCA9IG5ldyBHLkJlZ2luUGF0aCgpOyAvLyBzbyB3ZSBkb24ndCBoYXZlIHRvIGluc3RhbnRpYXRlIG11bHRpcGxlIGluc3RhbmNlcy5cblxuXG5cdGNyZWF0ZWpzLkdyYXBoaWNzID0gR3JhcGhpY3M7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRGlzcGxheU9iamVjdC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbi8vIGNvbnN0cnVjdG9yOlxyXG5cdC8qKlxyXG5cdCAqIERpc3BsYXlPYmplY3QgaXMgYW4gYWJzdHJhY3QgY2xhc3MgdGhhdCBzaG91bGQgbm90IGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5LiBJbnN0ZWFkIGNvbnN0cnVjdCBzdWJjbGFzc2VzIHN1Y2ggYXNcclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIkJpdG1hcFwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHt7I2Nyb3NzTGluayBcIlNoYXBlXCJ9fXt7L2Nyb3NzTGlua319LlxyXG5cdCAqIERpc3BsYXlPYmplY3QgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBkaXNwbGF5IGNsYXNzZXMgaW4gdGhlIEVhc2VsSlMgbGlicmFyeS4gSXQgZGVmaW5lcyB0aGUgY29yZSBwcm9wZXJ0aWVzIGFuZFxyXG5cdCAqIG1ldGhvZHMgdGhhdCBhcmUgc2hhcmVkIGJldHdlZW4gYWxsIGRpc3BsYXkgb2JqZWN0cywgc3VjaCBhcyB0cmFuc2Zvcm1hdGlvbiBwcm9wZXJ0aWVzICh4LCB5LCBzY2FsZVgsIHNjYWxlWSwgZXRjKSxcclxuXHQgKiBjYWNoaW5nLCBhbmQgbW91c2UgaGFuZGxlcnMuXHJcblx0ICogQGNsYXNzIERpc3BsYXlPYmplY3RcclxuXHQgKiBAZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJcclxuXHQgKiBAY29uc3RydWN0b3JcclxuXHQgKiovXHJcblx0ZnVuY3Rpb24gRGlzcGxheU9iamVjdCgpIHtcclxuXHRcdHRoaXMuRXZlbnREaXNwYXRjaGVyX2NvbnN0cnVjdG9yKCk7XHJcblx0XHRcclxuXHRcdFxyXG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgYWxwaGEgKHRyYW5zcGFyZW5jeSkgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QuIDAgaXMgZnVsbHkgdHJhbnNwYXJlbnQsIDEgaXMgZnVsbHkgb3BhcXVlLlxyXG5cdFx0ICogQHByb3BlcnR5IGFscGhhXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMVxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5hbHBoYSA9IDE7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIElmIGEgY2FjaGUgaXMgYWN0aXZlLCB0aGlzIHJldHVybnMgdGhlIGNhbnZhcyB0aGF0IGhvbGRzIHRoZSBjYWNoZWQgdmVyc2lvbiBvZiB0aGlzIGRpc3BsYXkgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiY2FjaGVcIn19e3svY3Jvc3NMaW5rfX1cclxuXHRcdCAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG5cdFx0ICogQHByb3BlcnR5IGNhY2hlQ2FudmFzXHJcblx0XHQgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnQgfCBPYmplY3R9XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKiBAcmVhZG9ubHlcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuY2FjaGVDYW52YXMgPSBudWxsO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXR1cm5zIGFuIElEIG51bWJlciB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgdGhlIGN1cnJlbnQgY2FjaGUgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWQgdG9cclxuXHRcdCAqIGRldGVybWluZSBpZiB0aGUgY2FjaGUgaGFzIGNoYW5nZWQgc2luY2UgYSBwcmV2aW91cyBjaGVjay5cclxuXHRcdCAqIEBwcm9wZXJ0eSBjYWNoZUlEXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmNhY2hlSUQgPSAwO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBVbmlxdWUgSUQgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QuIE1ha2VzIGRpc3BsYXkgb2JqZWN0cyBlYXNpZXIgZm9yIHNvbWUgdXNlcy5cclxuXHRcdCAqIEBwcm9wZXJ0eSBpZFxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IC0xXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLmlkID0gY3JlYXRlanMuVUlELmdldCgpO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0byBpbmNsdWRlIHRoaXMgb2JqZWN0IHdoZW4gcnVubmluZyBtb3VzZSBpbnRlcmFjdGlvbnMuIFNldHRpbmcgdGhpcyB0byBgZmFsc2VgIGZvciBjaGlsZHJlblxyXG5cdFx0ICogb2YgYSB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX0gd2lsbCBjYXVzZSBldmVudHMgb24gdGhlIENvbnRhaW5lciB0byBub3QgZmlyZSB3aGVuIHRoYXQgY2hpbGQgaXNcclxuXHRcdCAqIGNsaWNrZWQuIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSB0byBgZmFsc2VgIGRvZXMgbm90IHByZXZlbnQgdGhlIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lci9nZXRPYmplY3RzVW5kZXJQb2ludFwifX17ey9jcm9zc0xpbmt9fVxyXG5cdFx0ICogbWV0aG9kIGZyb20gcmV0dXJuaW5nIHRoZSBjaGlsZC5cclxuXHRcdCAqXHJcblx0XHQgKiA8c3Ryb25nPk5vdGU6PC9zdHJvbmc+IEluIEVhc2VsSlMgMC43LjAsIHRoZSBtb3VzZUVuYWJsZWQgcHJvcGVydHkgd2lsbCBub3Qgd29yayBwcm9wZXJseSB3aXRoIG5lc3RlZCBDb250YWluZXJzLiBQbGVhc2VcclxuXHRcdCAqIGNoZWNrIG91dCB0aGUgbGF0ZXN0IE5FWFQgdmVyc2lvbiBpbiA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL0NyZWF0ZUpTL0Vhc2VsSlMvdHJlZS9tYXN0ZXIvbGliXCI+R2l0SHViPC9hPiBmb3IgYW4gdXBkYXRlZCB2ZXJzaW9uIHdpdGggdGhpcyBpc3N1ZSByZXNvbHZlZC4gVGhlIGZpeCB3aWxsIGJlXHJcblx0XHQgKiBwcm92aWRlZCBpbiB0aGUgbmV4dCByZWxlYXNlIG9mIEVhc2VsSlMuXHJcblx0XHQgKiBAcHJvcGVydHkgbW91c2VFbmFibGVkXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMubW91c2VFbmFibGVkID0gdHJ1ZTtcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBJZiBmYWxzZSwgdGhlIHRpY2sgd2lsbCBub3QgcnVuIG9uIHRoaXMgZGlzcGxheSBvYmplY3QgKG9yIGl0cyBjaGlsZHJlbikuIFRoaXMgY2FuIHByb3ZpZGUgc29tZSBwZXJmb3JtYW5jZSBiZW5lZml0cy5cclxuXHRcdCAqIEluIGFkZGl0aW9uIHRvIHByZXZlbnRpbmcgdGhlIFwidGlja1wiIGV2ZW50IGZyb20gYmVpbmcgZGlzcGF0Y2hlZCwgaXQgd2lsbCBhbHNvIHByZXZlbnQgdGljayByZWxhdGVkIHVwZGF0ZXNcclxuXHRcdCAqIG9uIHNvbWUgZGlzcGxheSBvYmplY3RzIChleC4gU3ByaXRlICYgTW92aWVDbGlwIGZyYW1lIGFkdmFuY2luZywgRE9NRWxlbWVudCB2aXNpYmlsaXR5IGhhbmRsaW5nKS5cclxuXHRcdCAqIEBwcm9wZXJ0eSB0aWNrRW5hYmxlZFxyXG5cdFx0ICogQHR5cGUgQm9vbGVhblxyXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy50aWNrRW5hYmxlZCA9IHRydWU7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIEFuIG9wdGlvbmFsIG5hbWUgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QuIEluY2x1ZGVkIGluIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvdG9TdHJpbmdcIn19e3svY3Jvc3NMaW5rfX0gLiBVc2VmdWwgZm9yXHJcblx0XHQgKiBkZWJ1Z2dpbmcuXHJcblx0XHQgKiBAcHJvcGVydHkgbmFtZVxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMubmFtZSA9IG51bGw7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIEEgcmVmZXJlbmNlIHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX0gb3Ige3sjY3Jvc3NMaW5rIFwiU3RhZ2VcIn19e3svY3Jvc3NMaW5rfX0gb2JqZWN0IHRoYXRcclxuXHRcdCAqIGNvbnRhaW5zIHRoaXMgZGlzcGxheSBvYmplY3QsIG9yIG51bGwgaWYgaXQgaGFzIG5vdCBiZWVuIGFkZGVkXHJcblx0XHQgKiB0byBvbmUuXHJcblx0XHQgKiBAcHJvcGVydHkgcGFyZW50XHJcblx0XHQgKiBAZmluYWxcclxuXHRcdCAqIEB0eXBlIHtDb250YWluZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKiBAcmVhZG9ubHlcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMucGFyZW50ID0gbnVsbDtcclxuXHRcclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGxlZnQgb2Zmc2V0IGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0J3MgcmVnaXN0cmF0aW9uIHBvaW50LiBGb3IgZXhhbXBsZSwgdG8gbWFrZSBhIDEwMHgxMDBweCBCaXRtYXAgcm90YXRlXHJcblx0XHQgKiBhcm91bmQgaXRzIGNlbnRlciwgeW91IHdvdWxkIHNldCByZWdYIGFuZCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3JlZ1k6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gdG8gNTAuXHJcblx0XHQgKiBAcHJvcGVydHkgcmVnWFxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IDBcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMucmVnWCA9IDA7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSB5IG9mZnNldCBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdCdzIHJlZ2lzdHJhdGlvbiBwb2ludC4gRm9yIGV4YW1wbGUsIHRvIG1ha2UgYSAxMDB4MTAwcHggQml0bWFwIHJvdGF0ZSBhcm91bmRcclxuXHRcdCAqIGl0cyBjZW50ZXIsIHlvdSB3b3VsZCBzZXQge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9yZWdYOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGFuZCByZWdZIHRvIDUwLlxyXG5cdFx0ICogQHByb3BlcnR5IHJlZ1lcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAwXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLnJlZ1kgPSAwO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgcm90YXRpb24gaW4gZGVncmVlcyBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdC5cclxuXHRcdCAqIEBwcm9wZXJ0eSByb3RhdGlvblxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IDBcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMucm90YXRpb24gPSAwO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgZmFjdG9yIHRvIHN0cmV0Y2ggdGhpcyBkaXNwbGF5IG9iamVjdCBob3Jpem9udGFsbHkuIEZvciBleGFtcGxlLCBzZXR0aW5nIHNjYWxlWCB0byAyIHdpbGwgc3RyZXRjaCB0aGUgZGlzcGxheVxyXG5cdFx0ICogb2JqZWN0IHRvIHR3aWNlIGl0cyBub21pbmFsIHdpZHRoLiBUbyBob3Jpem9udGFsbHkgZmxpcCBhbiBvYmplY3QsIHNldCB0aGUgc2NhbGUgdG8gYSBuZWdhdGl2ZSBudW1iZXIuXHJcblx0XHQgKiBAcHJvcGVydHkgc2NhbGVYXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMVxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5zY2FsZVggPSAxO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgZmFjdG9yIHRvIHN0cmV0Y2ggdGhpcyBkaXNwbGF5IG9iamVjdCB2ZXJ0aWNhbGx5LiBGb3IgZXhhbXBsZSwgc2V0dGluZyBzY2FsZVkgdG8gMC41IHdpbGwgc3RyZXRjaCB0aGUgZGlzcGxheVxyXG5cdFx0ICogb2JqZWN0IHRvIGhhbGYgaXRzIG5vbWluYWwgaGVpZ2h0LiBUbyB2ZXJ0aWNhbGx5IGZsaXAgYW4gb2JqZWN0LCBzZXQgdGhlIHNjYWxlIHRvIGEgbmVnYXRpdmUgbnVtYmVyLlxyXG5cdFx0ICogQHByb3BlcnR5IHNjYWxlWVxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IDFcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuc2NhbGVZID0gMTtcclxuXHRcclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGZhY3RvciB0byBza2V3IHRoaXMgZGlzcGxheSBvYmplY3QgaG9yaXpvbnRhbGx5LlxyXG5cdFx0ICogQHByb3BlcnR5IHNrZXdYXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5za2V3WCA9IDA7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBmYWN0b3IgdG8gc2tldyB0aGlzIGRpc3BsYXkgb2JqZWN0IHZlcnRpY2FsbHkuXHJcblx0XHQgKiBAcHJvcGVydHkgc2tld1lcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAwXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLnNrZXdZID0gMDtcclxuXHRcclxuXHRcdC8qKlxyXG5cdFx0ICogQSBzaGFkb3cgb2JqZWN0IHRoYXQgZGVmaW5lcyB0aGUgc2hhZG93IHRvIHJlbmRlciBvbiB0aGlzIGRpc3BsYXkgb2JqZWN0LiBTZXQgdG8gYG51bGxgIHRvIHJlbW92ZSBhIHNoYWRvdy4gSWZcclxuXHRcdCAqIG51bGwsIHRoaXMgcHJvcGVydHkgaXMgaW5oZXJpdGVkIGZyb20gdGhlIHBhcmVudCBjb250YWluZXIuXHJcblx0XHQgKiBAcHJvcGVydHkgc2hhZG93XHJcblx0XHQgKiBAdHlwZSB7U2hhZG93fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5zaGFkb3cgPSBudWxsO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIGRpc3BsYXkgb2JqZWN0IHNob3VsZCBiZSByZW5kZXJlZCB0byB0aGUgY2FudmFzIGFuZCBpbmNsdWRlZCB3aGVuIHJ1bm5pbmcgdGhlIFN0YWdlXHJcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJTdGFnZS9nZXRPYmplY3RzVW5kZXJQb2ludFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXHJcblx0XHQgKiBAcHJvcGVydHkgdmlzaWJsZVxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLnZpc2libGUgPSB0cnVlO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgeCAoaG9yaXpvbnRhbCkgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0LCByZWxhdGl2ZSB0byBpdHMgcGFyZW50LlxyXG5cdFx0ICogQHByb3BlcnR5IHhcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAwXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLnggPSAwO1xyXG5cdFxyXG5cdFx0LyoqIFRoZSB5ICh2ZXJ0aWNhbCkgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0LCByZWxhdGl2ZSB0byBpdHMgcGFyZW50LlxyXG5cdFx0ICogQHByb3BlcnR5IHlcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAwXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLnkgPSAwO1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIElmIHNldCwgZGVmaW5lcyB0aGUgdHJhbnNmb3JtYXRpb24gZm9yIHRoaXMgZGlzcGxheSBvYmplY3QsIG92ZXJyaWRpbmcgYWxsIG90aGVyIHRyYW5zZm9ybWF0aW9uIHByb3BlcnRpZXNcclxuXHRcdCAqICh4LCB5LCByb3RhdGlvbiwgc2NhbGUsIHNrZXcpLlxyXG5cdFx0ICogQHByb3BlcnR5IHRyYW5zZm9ybU1hdHJpeFxyXG5cdFx0ICogQHR5cGUge01hdHJpeDJEfVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy50cmFuc2Zvcm1NYXRyaXggPSBudWxsO1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBjb21wb3NpdGUgb3BlcmF0aW9uIGluZGljYXRlcyBob3cgdGhlIHBpeGVscyBvZiB0aGlzIGRpc3BsYXkgb2JqZWN0IHdpbGwgYmUgY29tcG9zaXRlZCB3aXRoIHRoZSBlbGVtZW50c1xyXG5cdFx0ICogYmVoaW5kIGl0LiBJZiBgbnVsbGAsIHRoaXMgcHJvcGVydHkgaXMgaW5oZXJpdGVkIGZyb20gdGhlIHBhcmVudCBjb250YWluZXIuIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWFkIHRoZVxyXG5cdFx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2NvbXBvc2l0aW5nXCI+XHJcblx0XHQgKiB3aGF0d2cgc3BlYyBvbiBjb21wb3NpdGluZzwvYT4uXHJcblx0XHQgKiBAcHJvcGVydHkgY29tcG9zaXRlT3BlcmF0aW9uXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5jb21wb3NpdGVPcGVyYXRpb24gPSBudWxsO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgc2hvdWxkIGJlIGRyYXduIHRvIGEgd2hvbGUgcGl4ZWwgd2hlblxyXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiU3RhZ2Uvc25hcFRvUGl4ZWxFbmFibGVkXCJ9fXt7L2Nyb3NzTGlua319IGlzIHRydWUuIFRvIGVuYWJsZS9kaXNhYmxlIHNuYXBwaW5nIG9uIHdob2xlXHJcblx0XHQgKiBjYXRlZ29yaWVzIG9mIGRpc3BsYXkgb2JqZWN0cywgc2V0IHRoaXMgdmFsdWUgb24gdGhlIHByb3RvdHlwZSAoRXguIFRleHQucHJvdG90eXBlLnNuYXBUb1BpeGVsID0gdHJ1ZSkuXHJcblx0XHQgKiBAcHJvcGVydHkgc25hcFRvUGl4ZWxcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5zbmFwVG9QaXhlbCA9IHRydWU7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIEFuIGFycmF5IG9mIEZpbHRlciBvYmplY3RzIHRvIGFwcGx5IHRvIHRoaXMgZGlzcGxheSBvYmplY3QuIEZpbHRlcnMgYXJlIG9ubHkgYXBwbGllZCAvIHVwZGF0ZWQgd2hlbiB7eyNjcm9zc0xpbmsgXCJjYWNoZVwifX17ey9jcm9zc0xpbmt9fVxyXG5cdFx0ICogb3Ige3sjY3Jvc3NMaW5rIFwidXBkYXRlQ2FjaGVcIn19e3svY3Jvc3NMaW5rfX0gaXMgY2FsbGVkIG9uIHRoZSBkaXNwbGF5IG9iamVjdCwgYW5kIG9ubHkgYXBwbHkgdG8gdGhlIGFyZWEgdGhhdCBpc1xyXG5cdFx0ICogY2FjaGVkLlxyXG5cdFx0ICogQHByb3BlcnR5IGZpbHRlcnNcclxuXHRcdCAqIEB0eXBlIHtBcnJheX1cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuZmlsdGVycyA9IG51bGw7XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogQSBTaGFwZSBpbnN0YW5jZSB0aGF0IGRlZmluZXMgYSB2ZWN0b3IgbWFzayAoY2xpcHBpbmcgcGF0aCkgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QuICBUaGUgc2hhcGUncyB0cmFuc2Zvcm1hdGlvblxyXG5cdFx0ICogd2lsbCBiZSBhcHBsaWVkIHJlbGF0aXZlIHRvIHRoZSBkaXNwbGF5IG9iamVjdCdzIHBhcmVudCBjb29yZGluYXRlcyAoYXMgaWYgaXQgd2VyZSBhIGNoaWxkIG9mIHRoZSBwYXJlbnQpLlxyXG5cdFx0ICogQHByb3BlcnR5IG1hc2tcclxuXHRcdCAqIEB0eXBlIHtTaGFwZX1cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5tYXNrID0gbnVsbDtcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGRpc3BsYXkgb2JqZWN0IHRoYXQgd2lsbCBiZSB0ZXN0ZWQgd2hlbiBjaGVja2luZyBtb3VzZSBpbnRlcmFjdGlvbnMgb3IgdGVzdGluZyB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvZ2V0T2JqZWN0c1VuZGVyUG9pbnRcIn19e3svY3Jvc3NMaW5rfX0uXHJcblx0XHQgKiBUaGUgaGl0IGFyZWEgd2lsbCBoYXZlIGl0cyB0cmFuc2Zvcm1hdGlvbiBhcHBsaWVkIHJlbGF0aXZlIHRvIHRoaXMgZGlzcGxheSBvYmplY3QncyBjb29yZGluYXRlIHNwYWNlIChhcyB0aG91Z2hcclxuXHRcdCAqIHRoZSBoaXQgdGVzdCBvYmplY3Qgd2VyZSBhIGNoaWxkIG9mIHRoaXMgZGlzcGxheSBvYmplY3QgYW5kIHJlbGF0aXZlIHRvIGl0cyByZWdYL1kpLiBUaGUgaGl0QXJlYSB3aWxsIGJlIHRlc3RlZFxyXG5cdFx0ICogdXNpbmcgb25seSBpdHMgb3duIGBhbHBoYWAgdmFsdWUgcmVnYXJkbGVzcyBvZiB0aGUgYWxwaGEgdmFsdWUgb24gdGhlIHRhcmdldCBkaXNwbGF5IG9iamVjdCwgb3IgdGhlIHRhcmdldCdzXHJcblx0XHQgKiBhbmNlc3RvcnMgKHBhcmVudHMpLlxyXG5cdFx0ICogXHJcblx0XHQgKiBJZiBzZXQgb24gYSB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX0sIGNoaWxkcmVuIG9mIHRoZSBDb250YWluZXIgd2lsbCBub3QgcmVjZWl2ZSBtb3VzZSBldmVudHMuXHJcblx0XHQgKiBUaGlzIGlzIHNpbWlsYXIgdG8gc2V0dGluZyB7eyNjcm9zc0xpbmsgXCJtb3VzZUNoaWxkcmVuXCJ9fXt7L2Nyb3NzTGlua319IHRvIGZhbHNlLlxyXG5cdFx0ICpcclxuXHRcdCAqIE5vdGUgdGhhdCBoaXRBcmVhIGlzIE5PVCBjdXJyZW50bHkgdXNlZCBieSB0aGUgYGhpdFRlc3QoKWAgbWV0aG9kLCBub3IgaXMgaXQgc3VwcG9ydGVkIGZvciB7eyNjcm9zc0xpbmsgXCJTdGFnZVwifX17ey9jcm9zc0xpbmt9fS5cclxuXHRcdCAqIEBwcm9wZXJ0eSBoaXRBcmVhXHJcblx0XHQgKiBAdHlwZSB7RGlzcGxheU9iamVjdH1cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5oaXRBcmVhID0gbnVsbDtcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIENTUyBjdXJzb3IgKGV4LiBcInBvaW50ZXJcIiwgXCJoZWxwXCIsIFwidGV4dFwiLCBldGMpIHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQgd2hlbiB0aGUgdXNlciBob3ZlcnMgb3ZlciB0aGlzIGRpc3BsYXlcclxuXHRcdCAqIG9iamVjdC4gWW91IG11c3QgZW5hYmxlIG1vdXNlb3ZlciBldmVudHMgdXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcIlN0YWdlL2VuYWJsZU1vdXNlT3ZlclwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgdG9cclxuXHRcdCAqIHVzZSB0aGlzIHByb3BlcnR5LiBTZXR0aW5nIGEgbm9uLW51bGwgY3Vyc29yIG9uIGEgQ29udGFpbmVyIHdpbGwgb3ZlcnJpZGUgdGhlIGN1cnNvciBzZXQgb24gaXRzIGRlc2NlbmRhbnRzLlxyXG5cdFx0ICogQHByb3BlcnR5IGN1cnNvclxyXG5cdFx0ICogQHR5cGUge1N0cmluZ31cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5jdXJzb3IgPSBudWxsO1xyXG5cdFxyXG5cdFxyXG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcclxuXHRcdC8qKlxyXG5cdFx0ICogQHByb3BlcnR5IF9jYWNoZU9mZnNldFhcclxuXHRcdCAqIEBwcm90ZWN0ZWRcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAwXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLl9jYWNoZU9mZnNldFggPSAwO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJvcGVydHkgX2NhY2hlT2Zmc2V0WVxyXG5cdFx0ICogQHByb3RlY3RlZFxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IDBcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuX2NhY2hlT2Zmc2V0WSA9IDA7XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogQHByb3BlcnR5IF9maWx0ZXJPZmZzZXRYXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5fZmlsdGVyT2Zmc2V0WCA9IDA7XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogQHByb3BlcnR5IF9maWx0ZXJPZmZzZXRZXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5fZmlsdGVyT2Zmc2V0WSA9IDA7XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogQHByb3BlcnR5IF9jYWNoZVNjYWxlXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMVxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5fY2FjaGVTY2FsZSA9IDE7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCogQHByb3BlcnR5IF9jYWNoZURhdGFVUkxJRFxyXG5cdFx0KiBAcHJvdGVjdGVkXHJcblx0XHQqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQqIEBkZWZhdWx0IDBcclxuXHRcdCovXHJcblx0XHR0aGlzLl9jYWNoZURhdGFVUkxJRCA9IDA7XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0KiBAcHJvcGVydHkgX2NhY2hlRGF0YVVSTFxyXG5cdFx0KiBAcHJvdGVjdGVkXHJcblx0XHQqIEB0eXBlIHtTdHJpbmd9XHJcblx0XHQqIEBkZWZhdWx0IG51bGxcclxuXHRcdCovXHJcblx0XHR0aGlzLl9jYWNoZURhdGFVUkwgPSBudWxsO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJvcGVydHkgX3Byb3BzXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAdHlwZSB7RGlzcGxheU9iamVjdH1cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuX3Byb3BzID0gbmV3IGNyZWF0ZWpzLkRpc3BsYXlQcm9wcygpO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJvcGVydHkgX3JlY3RhbmdsZVxyXG5cdFx0ICogQHByb3RlY3RlZFxyXG5cdFx0ICogQHR5cGUge1JlY3RhbmdsZX1cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuX3JlY3RhbmdsZSA9IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoKTtcclxuXHRcclxuXHRcdC8qKlxyXG5cdFx0ICogQHByb3BlcnR5IF9ib3VuZHNcclxuXHRcdCAqIEBwcm90ZWN0ZWRcclxuXHRcdCAqIEB0eXBlIHtSZWN0YW5nbGV9XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLl9ib3VuZHMgPSBudWxsO1xyXG5cdH1cclxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChEaXNwbGF5T2JqZWN0LCBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIpO1xyXG5cclxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXHJcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxyXG5cdFxyXG4vLyBzdGF0aWMgcHJvcGVydGllczpcclxuXHQvKipcclxuXHQgKiBMaXN0aW5nIG9mIG1vdXNlIGV2ZW50IG5hbWVzLiBVc2VkIGluIF9oYXNNb3VzZUV2ZW50TGlzdGVuZXIuXHJcblx0ICogQHByb3BlcnR5IF9NT1VTRV9FVkVOVFNcclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICogQHN0YXRpY1xyXG5cdCAqIEB0eXBlIHtBcnJheX1cclxuXHQgKiovXHJcblx0RGlzcGxheU9iamVjdC5fTU9VU0VfRVZFTlRTID0gW1wiY2xpY2tcIixcImRibGNsaWNrXCIsXCJtb3VzZWRvd25cIixcIm1vdXNlb3V0XCIsXCJtb3VzZW92ZXJcIixcInByZXNzbW92ZVwiLFwicHJlc3N1cFwiLFwicm9sbG91dFwiLFwicm9sbG92ZXJcIl07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFN1cHByZXNzZXMgZXJyb3JzIGdlbmVyYXRlZCB3aGVuIHVzaW5nIGZlYXR1cmVzIGxpa2UgaGl0VGVzdCwgbW91c2UgZXZlbnRzLCBhbmQge3sjY3Jvc3NMaW5rIFwiZ2V0T2JqZWN0c1VuZGVyUG9pbnRcIn19e3svY3Jvc3NMaW5rfX1cclxuXHQgKiB3aXRoIGNyb3NzIGRvbWFpbiBjb250ZW50LlxyXG5cdCAqIEBwcm9wZXJ0eSBzdXBwcmVzc0Nyb3NzRG9tYWluRXJyb3JzXHJcblx0ICogQHN0YXRpY1xyXG5cdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0ICoqL1xyXG5cdERpc3BsYXlPYmplY3Quc3VwcHJlc3NDcm9zc0RvbWFpbkVycm9ycyA9IGZhbHNlO1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEBwcm9wZXJ0eSBfc25hcFRvUGl4ZWxFbmFibGVkXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqIEBzdGF0aWNcclxuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdCAqKi9cclxuXHREaXNwbGF5T2JqZWN0Ll9zbmFwVG9QaXhlbEVuYWJsZWQgPSBmYWxzZTsgLy8gc3RhZ2Uuc25hcFRvUGl4ZWxFbmFibGVkIGlzIHRlbXBvcmFyaWx5IGNvcGllZCBoZXJlIGR1cmluZyBhIGRyYXcgdG8gcHJvdmlkZSBnbG9iYWwgYWNjZXNzLlxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJvcGVydHkgX2hpdFRlc3RDYW52YXNcclxuXHQgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnQgfCBPYmplY3R9XHJcblx0ICogQHN0YXRpY1xyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiovXHJcblx0LyoqXHJcblx0ICogQHByb3BlcnR5IF9oaXRUZXN0Q29udGV4dFxyXG5cdCAqIEB0eXBlIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XHJcblx0ICogQHN0YXRpY1xyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiovXHJcblx0dmFyIGNhbnZhcyA9IGNyZWF0ZWpzLmNyZWF0ZUNhbnZhcz9jcmVhdGVqcy5jcmVhdGVDYW52YXMoKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpOyAvLyBwcmV2ZW50IGVycm9ycyBvbiBsb2FkIGluIGJyb3dzZXJzIHdpdGhvdXQgY2FudmFzLlxyXG5cdGlmIChjYW52YXMuZ2V0Q29udGV4dCkge1xyXG5cdFx0RGlzcGxheU9iamVjdC5faGl0VGVzdENhbnZhcyA9IGNhbnZhcztcclxuXHRcdERpc3BsYXlPYmplY3QuX2hpdFRlc3RDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHRcdGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAxO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQHByb3BlcnR5IF9uZXh0Q2FjaGVJRFxyXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0ICogQHN0YXRpY1xyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiovXHJcblx0RGlzcGxheU9iamVjdC5fbmV4dENhY2hlSUQgPSAxO1xyXG5cclxuXHJcbi8vIGV2ZW50czpcclxuXHQvKipcclxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyB0aGVpciBsZWZ0IG1vdXNlIGJ1dHRvbiBvdmVyIHRoZSBkaXNwbGF5IG9iamVjdC4gU2VlIHRoZSBcclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cclxuXHQgKiBAZXZlbnQgbW91c2Vkb3duXHJcblx0ICogQHNpbmNlIDAuNi4wXHJcblx0ICovXHJcblx0IFxyXG5cdC8qKlxyXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIHRoZWlyIGxlZnQgbW91c2UgYnV0dG9uIGFuZCB0aGVuIHJlbGVhc2VzIGl0IHdoaWxlIG92ZXIgdGhlIGRpc3BsYXkgb2JqZWN0LlxyXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXHJcblx0ICogQGV2ZW50IGNsaWNrXHJcblx0ICogQHNpbmNlIDAuNi4wXHJcblx0ICovXHJcblx0IFxyXG5cdC8qKlxyXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgdXNlciBkb3VibGUgY2xpY2tzIHRoZWlyIGxlZnQgbW91c2UgYnV0dG9uIG92ZXIgdGhpcyBkaXNwbGF5IG9iamVjdC5cclxuXHQgKiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxyXG5cdCAqIEBldmVudCBkYmxjbGlja1xyXG5cdCAqIEBzaW5jZSAwLjYuMFxyXG5cdCAqL1xyXG5cdCBcclxuXHQvKipcclxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIncyBtb3VzZSBlbnRlcnMgdGhpcyBkaXNwbGF5IG9iamVjdC4gVGhpcyBldmVudCBtdXN0IGJlIGVuYWJsZWQgdXNpbmcgXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvZW5hYmxlTW91c2VPdmVyXCJ9fXt7L2Nyb3NzTGlua319LiBTZWUgYWxzbyB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3JvbGxvdmVyOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LlxyXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXHJcblx0ICogQGV2ZW50IG1vdXNlb3ZlclxyXG5cdCAqIEBzaW5jZSAwLjYuMFxyXG5cdCAqL1xyXG5cclxuXHQvKipcclxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIncyBtb3VzZSBsZWF2ZXMgdGhpcyBkaXNwbGF5IG9iamVjdC4gVGhpcyBldmVudCBtdXN0IGJlIGVuYWJsZWQgdXNpbmcgXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvZW5hYmxlTW91c2VPdmVyXCJ9fXt7L2Nyb3NzTGlua319LiBTZWUgYWxzbyB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3JvbGxvdXQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uXHJcblx0ICogU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cclxuXHQgKiBAZXZlbnQgbW91c2VvdXRcclxuXHQgKiBAc2luY2UgMC42LjBcclxuXHQgKi9cclxuXHQgXHJcblx0LyoqXHJcblx0ICogVGhpcyBldmVudCBpcyBzaW1pbGFyIHRvIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2VvdmVyOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LCB3aXRoIHRoZSBmb2xsb3dpbmdcclxuXHQgKiBkaWZmZXJlbmNlczogaXQgZG9lcyBub3QgYnViYmxlLCBhbmQgaXQgY29uc2lkZXJzIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZXMgYXMgYW5cclxuXHQgKiBhZ2dyZWdhdGUgb2YgdGhlaXIgY29udGVudC5cclxuXHQgKiBcclxuXHQgKiBGb3IgZXhhbXBsZSwgbXlDb250YWluZXIgY29udGFpbnMgdHdvIG92ZXJsYXBwaW5nIGNoaWxkcmVuOiBzaGFwZUEgYW5kIHNoYXBlQi4gVGhlIHVzZXIgbW92ZXMgdGhlaXIgbW91c2Ugb3ZlclxyXG5cdCAqIHNoYXBlQSBhbmQgdGhlbiBkaXJlY3RseSBvbiB0byBzaGFwZUIuIFdpdGggYSBsaXN0ZW5lciBmb3Ige3sjY3Jvc3NMaW5rIFwibW91c2VvdmVyOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IG9uXHJcblx0ICogbXlDb250YWluZXIsIHR3byBldmVudHMgd291bGQgYmUgcmVjZWl2ZWQsIGVhY2ggdGFyZ2V0aW5nIGEgY2hpbGQgZWxlbWVudDo8T0w+XHJcblx0ICogPExJPndoZW4gdGhlIG1vdXNlIGVudGVycyBzaGFwZUEgKHRhcmdldD1zaGFwZUEpPC9MST5cclxuXHQgKiA8TEk+d2hlbiB0aGUgbW91c2UgZW50ZXJzIHNoYXBlQiAodGFyZ2V0PXNoYXBlQik8L0xJPlxyXG5cdCAqIDwvT0w+XHJcblx0ICogSG93ZXZlciwgd2l0aCBhIGxpc3RlbmVyIGZvciBcInJvbGxvdmVyXCIgaW5zdGVhZCwgb25seSBhIHNpbmdsZSBldmVudCBpcyByZWNlaXZlZCB3aGVuIHRoZSBtb3VzZSBmaXJzdCBlbnRlcnNcclxuXHQgKiB0aGUgYWdncmVnYXRlIG15Q29udGFpbmVyIGNvbnRlbnQgKHRhcmdldD1teUNvbnRhaW5lcikuXHJcblx0ICogXHJcblx0ICogVGhpcyBldmVudCBtdXN0IGJlIGVuYWJsZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvZW5hYmxlTW91c2VPdmVyXCJ9fXt7L2Nyb3NzTGlua319LlxyXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXHJcblx0ICogQGV2ZW50IHJvbGxvdmVyXHJcblx0ICogQHNpbmNlIDAuNy4wXHJcblx0ICovXHJcblx0IFxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgZXZlbnQgaXMgc2ltaWxhciB0byB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlb3V0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LCB3aXRoIHRoZSBmb2xsb3dpbmdcclxuXHQgKiBkaWZmZXJlbmNlczogaXQgZG9lcyBub3QgYnViYmxlLCBhbmQgaXQgY29uc2lkZXJzIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZXMgYXMgYW5cclxuXHQgKiBhZ2dyZWdhdGUgb2YgdGhlaXIgY29udGVudC5cclxuXHQgKiBcclxuXHQgKiBGb3IgZXhhbXBsZSwgbXlDb250YWluZXIgY29udGFpbnMgdHdvIG92ZXJsYXBwaW5nIGNoaWxkcmVuOiBzaGFwZUEgYW5kIHNoYXBlQi4gVGhlIHVzZXIgbW92ZXMgdGhlaXIgbW91c2Ugb3ZlclxyXG5cdCAqIHNoYXBlQSwgdGhlbiBkaXJlY3RseSBvbiB0byBzaGFwZUIsIHRoZW4gb2ZmIGJvdGguIFdpdGggYSBsaXN0ZW5lciBmb3Ige3sjY3Jvc3NMaW5rIFwibW91c2VvdXQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cclxuXHQgKiBvbiBteUNvbnRhaW5lciwgdHdvIGV2ZW50cyB3b3VsZCBiZSByZWNlaXZlZCwgZWFjaCB0YXJnZXRpbmcgYSBjaGlsZCBlbGVtZW50OjxPTD5cclxuXHQgKiA8TEk+d2hlbiB0aGUgbW91c2UgbGVhdmVzIHNoYXBlQSAodGFyZ2V0PXNoYXBlQSk8L0xJPlxyXG5cdCAqIDxMST53aGVuIHRoZSBtb3VzZSBsZWF2ZXMgc2hhcGVCICh0YXJnZXQ9c2hhcGVCKTwvTEk+XHJcblx0ICogPC9PTD5cclxuXHQgKiBIb3dldmVyLCB3aXRoIGEgbGlzdGVuZXIgZm9yIFwicm9sbG91dFwiIGluc3RlYWQsIG9ubHkgYSBzaW5nbGUgZXZlbnQgaXMgcmVjZWl2ZWQgd2hlbiB0aGUgbW91c2UgbGVhdmVzXHJcblx0ICogdGhlIGFnZ3JlZ2F0ZSBteUNvbnRhaW5lciBjb250ZW50ICh0YXJnZXQ9bXlDb250YWluZXIpLlxyXG5cdCAqIFxyXG5cdCAqIFRoaXMgZXZlbnQgbXVzdCBiZSBlbmFibGVkIHVzaW5nIHt7I2Nyb3NzTGluayBcIlN0YWdlL2VuYWJsZU1vdXNlT3ZlclwifX17ey9jcm9zc0xpbmt9fS5cclxuXHQgKiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxyXG5cdCAqIEBldmVudCByb2xsb3V0XHJcblx0ICogQHNpbmNlIDAuNy4wXHJcblx0ICovXHJcblx0IFxyXG5cdC8qKlxyXG5cdCAqIEFmdGVyIGEge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9tb3VzZWRvd246ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gb2NjdXJzIG9uIGEgZGlzcGxheSBvYmplY3QsIGEgcHJlc3Ntb3ZlXHJcblx0ICogZXZlbnQgd2lsbCBiZSBnZW5lcmF0ZWQgb24gdGhhdCBvYmplY3Qgd2hlbmV2ZXIgdGhlIG1vdXNlIG1vdmVzIHVudGlsIHRoZSBtb3VzZSBwcmVzcyBpcyByZWxlYXNlZC4gVGhpcyBjYW4gYmVcclxuXHQgKiB1c2VmdWwgZm9yIGRyYWdnaW5nIGFuZCBzaW1pbGFyIG9wZXJhdGlvbnMuXHJcblx0ICogQGV2ZW50IHByZXNzbW92ZVxyXG5cdCAqIEBzaW5jZSAwLjcuMFxyXG5cdCAqL1xyXG5cdCBcclxuXHQvKipcclxuXHQgKiBBZnRlciBhIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2Vkb3duOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IG9jY3VycyBvbiBhIGRpc3BsYXkgb2JqZWN0LCBhIHByZXNzdXAgZXZlbnRcclxuXHQgKiB3aWxsIGJlIGdlbmVyYXRlZCBvbiB0aGF0IG9iamVjdCB3aGVuIHRoYXQgbW91c2UgcHJlc3MgaXMgcmVsZWFzZWQuIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3IgZHJhZ2dpbmcgYW5kIHNpbWlsYXJcclxuXHQgKiBvcGVyYXRpb25zLlxyXG5cdCAqIEBldmVudCBwcmVzc3VwXHJcblx0ICogQHNpbmNlIDAuNy4wXHJcblx0ICovXHJcblx0IFxyXG5cdC8qKlxyXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgZGlzcGxheSBvYmplY3QgaXMgYWRkZWQgdG8gYSBwYXJlbnQgY29udGFpbmVyLlxyXG5cdCAqIEBldmVudCBhZGRlZFxyXG5cdCAqL1xyXG5cdCBcclxuXHQvKipcclxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIGRpc3BsYXkgb2JqZWN0IGlzIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50IGNvbnRhaW5lci5cclxuXHQgKiBAZXZlbnQgcmVtb3ZlZFxyXG5cdCAqL1xyXG5cdCBcclxuXHQvKipcclxuXHQgKiBEaXNwYXRjaGVkIG9uIGVhY2ggZGlzcGxheSBvYmplY3Qgb24gYSBzdGFnZSB3aGVuZXZlciB0aGUgc3RhZ2UgdXBkYXRlcy4gVGhpcyBvY2N1cnMgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZVxyXG5cdCAqIHJlbmRlcmluZyAoZHJhdykgcGFzcy4gV2hlbiB7eyNjcm9zc0xpbmsgXCJTdGFnZS91cGRhdGVcIn19e3svY3Jvc3NMaW5rfX0gaXMgY2FsbGVkLCBmaXJzdCBhbGwgZGlzcGxheSBvYmplY3RzIG9uXHJcblx0ICogdGhlIHN0YWdlIGRpc3BhdGNoIHRoZSB0aWNrIGV2ZW50LCB0aGVuIGFsbCBvZiB0aGUgZGlzcGxheSBvYmplY3RzIGFyZSBkcmF3biB0byBzdGFnZS4gQ2hpbGRyZW4gd2lsbCBoYXZlIHRoZWlyXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwidGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBkaXNwYXRjaGVkIGluIG9yZGVyIG9mIHRoZWlyIGRlcHRoIHByaW9yIHRvIHRoZSBldmVudCBiZWluZ1xyXG5cdCAqIGRpc3BhdGNoZWQgb24gdGhlaXIgcGFyZW50LlxyXG5cdCAqIEBldmVudCB0aWNrXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXHJcblx0ICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIEFuIGFycmF5IGNvbnRhaW5pbmcgYW55IGFyZ3VtZW50cyB0aGF0IHdlcmUgcGFzc2VkIHRvIHRoZSBTdGFnZS51cGRhdGUoKSBtZXRob2QuIEZvclxyXG5cdCAqICAgICAgZXhhbXBsZSBpZiB5b3UgY2FsbGVkIHN0YWdlLnVwZGF0ZShcImhlbGxvXCIpLCB0aGVuIHRoZSBwYXJhbXMgd291bGQgYmUgW1wiaGVsbG9cIl0uXHJcblx0ICogQHNpbmNlIDAuNi4wXHJcblx0ICovXHJcblx0XHJcblx0XHJcbi8vIGdldHRlciAvIHNldHRlcnM6XHJcblx0LyoqXHJcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3N0YWdlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXHJcblx0ICogQG1ldGhvZCBnZXRTdGFnZVxyXG5cdCAqIEByZXR1cm4ge1N0YWdlfVxyXG5cdCAqIEBkZXByZWNhdGVkXHJcblx0ICoqL1xyXG5cdHAuZ2V0U3RhZ2UgPSBmdW5jdGlvbigpIHtcclxuXHRcdC8vIHVzZXMgZHluYW1pYyBhY2Nlc3MgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzO1xyXG5cdFx0dmFyIG8gPSB0aGlzLCBfU3RhZ2UgPSBjcmVhdGVqc1tcIlN0YWdlXCJdO1xyXG5cdFx0d2hpbGUgKG8ucGFyZW50KSB7IG8gPSBvLnBhcmVudDsgfVxyXG5cdFx0aWYgKG8gaW5zdGFuY2VvZiBfU3RhZ2UpIHsgcmV0dXJuIG87IH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIFN0YWdlIGluc3RhbmNlIHRoYXQgdGhpcyBkaXNwbGF5IG9iamVjdCB3aWxsIGJlIHJlbmRlcmVkIG9uLCBvciBudWxsIGlmIGl0IGhhcyBub3QgYmVlbiBhZGRlZCB0byBvbmUuXHJcblx0ICogQHByb3BlcnR5IHN0YWdlXHJcblx0ICogQHR5cGUge1N0YWdlfVxyXG5cdCAqIEByZWFkb25seVxyXG5cdCAqKi9cclxuXHR0cnkge1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMocCwge1xyXG5cdFx0XHRzdGFnZTogeyBnZXQ6IHAuZ2V0U3RhZ2UgfVxyXG5cdFx0fSk7XHJcblx0fSBjYXRjaCAoZSkge31cclxuXHJcblxyXG4vLyBwdWJsaWMgbWV0aG9kczpcclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxyXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXHJcblx0ICpcclxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXHJcblx0ICogQG1ldGhvZCBpc1Zpc2libGVcclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhc1xyXG5cdCAqKi9cclxuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPSAwICYmIHRoaXMuc2NhbGVZICE9IDApO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cclxuXHQgKiBSZXR1cm5zIDxjb2RlPnRydWU8L2NvZGU+IGlmIHRoZSBkcmF3IHdhcyBoYW5kbGVkICh1c2VmdWwgZm9yIG92ZXJyaWRpbmcgZnVuY3Rpb25hbGl0eSkuXHJcblx0ICpcclxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXHJcblx0ICogQG1ldGhvZCBkcmF3XHJcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtpZ25vcmVDYWNoZT1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRyYXcgb3BlcmF0aW9uIHNob3VsZCBpZ25vcmUgYW55IGN1cnJlbnQgY2FjaGUuIEZvciBleGFtcGxlLFxyXG5cdCAqIHVzZWQgZm9yIGRyYXdpbmcgdGhlIGNhY2hlICh0byBwcmV2ZW50IGl0IGZyb20gc2ltcGx5IGRyYXdpbmcgYW4gZXhpc3RpbmcgY2FjaGUgYmFjayBpbnRvIGl0c2VsZikuXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cclxuXHQgKiovXHJcblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBpZ25vcmVDYWNoZSkge1xyXG5cdFx0dmFyIGNhY2hlQ2FudmFzID0gdGhpcy5jYWNoZUNhbnZhcztcclxuXHRcdGlmIChpZ25vcmVDYWNoZSB8fCAhY2FjaGVDYW52YXMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9jYWNoZVNjYWxlO1xyXG5cdFx0Y3R4LmRyYXdJbWFnZShjYWNoZUNhbnZhcywgdGhpcy5fY2FjaGVPZmZzZXRYK3RoaXMuX2ZpbHRlck9mZnNldFgsIHRoaXMuX2NhY2hlT2Zmc2V0WSt0aGlzLl9maWx0ZXJPZmZzZXRZLCBjYWNoZUNhbnZhcy53aWR0aC9zY2FsZSwgY2FjaGVDYW52YXMuaGVpZ2h0L3NjYWxlKTtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogQXBwbGllcyB0aGlzIGRpc3BsYXkgb2JqZWN0J3MgdHJhbnNmb3JtYXRpb24sIGFscGhhLCBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24sIGNsaXBwaW5nIHBhdGggKG1hc2spLCBhbmQgc2hhZG93XHJcblx0ICogdG8gdGhlIHNwZWNpZmllZCBjb250ZXh0LiBUaGlzIGlzIHR5cGljYWxseSBjYWxsZWQgcHJpb3IgdG8ge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9kcmF3XCJ9fXt7L2Nyb3NzTGlua319LlxyXG5cdCAqIEBtZXRob2QgdXBkYXRlQ29udGV4dFxyXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCB0byB1cGRhdGUuXHJcblx0ICoqL1xyXG5cdHAudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0dmFyIG89dGhpcywgbWFzaz1vLm1hc2ssIG10eD0gby5fcHJvcHMubWF0cml4O1xyXG5cdFx0XHJcblx0XHRpZiAobWFzayAmJiBtYXNrLmdyYXBoaWNzICYmICFtYXNrLmdyYXBoaWNzLmlzRW1wdHkoKSkge1xyXG5cdFx0XHRtYXNrLmdldE1hdHJpeChtdHgpO1xyXG5cdFx0XHRjdHgudHJhbnNmb3JtKG10eC5hLCAgbXR4LmIsIG10eC5jLCBtdHguZCwgbXR4LnR4LCBtdHgudHkpO1xyXG5cdFx0XHRcclxuXHRcdFx0bWFzay5ncmFwaGljcy5kcmF3QXNQYXRoKGN0eCk7XHJcblx0XHRcdGN0eC5jbGlwKCk7XHJcblx0XHRcdFxyXG5cdFx0XHRtdHguaW52ZXJ0KCk7XHJcblx0XHRcdGN0eC50cmFuc2Zvcm0obXR4LmEsICBtdHguYiwgbXR4LmMsIG10eC5kLCBtdHgudHgsIG10eC50eSk7XHJcblx0XHR9XHJcblx0XHRcclxuXHRcdHRoaXMuZ2V0TWF0cml4KG10eCk7XHJcblx0XHR2YXIgdHggPSBtdHgudHgsIHR5ID0gbXR4LnR5O1xyXG5cdFx0aWYgKERpc3BsYXlPYmplY3QuX3NuYXBUb1BpeGVsRW5hYmxlZCAmJiBvLnNuYXBUb1BpeGVsKSB7XHJcblx0XHRcdHR4ID0gdHggKyAodHggPCAwID8gLTAuNSA6IDAuNSkgfCAwO1xyXG5cdFx0XHR0eSA9IHR5ICsgKHR5IDwgMCA/IC0wLjUgOiAwLjUpIHwgMDtcclxuXHRcdH1cclxuXHRcdGN0eC50cmFuc2Zvcm0obXR4LmEsICBtdHguYiwgbXR4LmMsIG10eC5kLCB0eCwgdHkpO1xyXG5cdFx0Y3R4Lmdsb2JhbEFscGhhICo9IG8uYWxwaGE7XHJcblx0XHRpZiAoby5jb21wb3NpdGVPcGVyYXRpb24pIHsgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IG8uY29tcG9zaXRlT3BlcmF0aW9uOyB9XHJcblx0XHRpZiAoby5zaGFkb3cpIHsgdGhpcy5fYXBwbHlTaGFkb3coY3R4LCBvLnNoYWRvdyk7IH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBEcmF3cyB0aGUgZGlzcGxheSBvYmplY3QgaW50byBhIG5ldyBjYW52YXMsIHdoaWNoIGlzIHRoZW4gdXNlZCBmb3Igc3Vic2VxdWVudCBkcmF3cy4gRm9yIGNvbXBsZXggY29udGVudFxyXG5cdCAqIHRoYXQgZG9lcyBub3QgY2hhbmdlIGZyZXF1ZW50bHkgKGV4LiBhIENvbnRhaW5lciB3aXRoIG1hbnkgY2hpbGRyZW4gdGhhdCBkbyBub3QgbW92ZSwgb3IgYSBjb21wbGV4IHZlY3RvciBTaGFwZSksXHJcblx0ICogdGhpcyBjYW4gcHJvdmlkZSBmb3IgbXVjaCBmYXN0ZXIgcmVuZGVyaW5nIGJlY2F1c2UgdGhlIGNvbnRlbnQgZG9lcyBub3QgbmVlZCB0byBiZSByZS1yZW5kZXJlZCBlYWNoIHRpY2suIFRoZVxyXG5cdCAqIGNhY2hlZCBkaXNwbGF5IG9iamVjdCBjYW4gYmUgbW92ZWQsIHJvdGF0ZWQsIGZhZGVkLCBldGMgZnJlZWx5LCBob3dldmVyIGlmIGl0cyBjb250ZW50IGNoYW5nZXMsIHlvdSBtdXN0XHJcblx0ICogbWFudWFsbHkgdXBkYXRlIHRoZSBjYWNoZSBieSBjYWxsaW5nIDxjb2RlPnVwZGF0ZUNhY2hlKCk8L2NvZGU+IG9yIDxjb2RlPmNhY2hlKCk8L2NvZGU+IGFnYWluLiBZb3UgbXVzdCBzcGVjaWZ5XHJcblx0ICogdGhlIGNhY2hlIGFyZWEgdmlhIHRoZSB4LCB5LCB3LCBhbmQgaCBwYXJhbWV0ZXJzLiBUaGlzIGRlZmluZXMgdGhlIHJlY3RhbmdsZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgYW5kIGNhY2hlZFxyXG5cdCAqIHVzaW5nIHRoaXMgZGlzcGxheSBvYmplY3QncyBjb29yZGluYXRlcy5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKiBGb3IgZXhhbXBsZSBpZiB5b3UgZGVmaW5lZCBhIFNoYXBlIHRoYXQgZHJldyBhIGNpcmNsZSBhdCAwLCAwIHdpdGggYSByYWRpdXMgb2YgMjU6XHJcblx0ICpcclxuXHQgKiAgICAgIHZhciBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xyXG5cdCAqICAgICAgc2hhcGUuZ3JhcGhpY3MuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3Q2lyY2xlKDAsIDAsIDI1KTtcclxuXHQgKiAgICAgIG15U2hhcGUuY2FjaGUoLTI1LCAtMjUsIDUwLCA1MCk7XHJcblx0ICpcclxuXHQgKiBOb3RlIHRoYXQgZmlsdGVycyBuZWVkIHRvIGJlIGRlZmluZWQgPGVtPmJlZm9yZTwvZW0+IHRoZSBjYWNoZSBpcyBhcHBsaWVkLiBDaGVjayBvdXQgdGhlIHt7I2Nyb3NzTGluayBcIkZpbHRlclwifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIGNsYXNzIGZvciBtb3JlIGluZm9ybWF0aW9uLiBTb21lIGZpbHRlcnMgKGV4LiBCbHVyRmlsdGVyKSB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIHNjYWxlIHBhcmFtLlxyXG5cdCAqIFxyXG5cdCAqIFVzdWFsbHksIHRoZSByZXN1bHRpbmcgY2FjaGVDYW52YXMgd2lsbCBoYXZlIHRoZSBkaW1lbnNpb25zIHdpZHRoKnNjYWxlIGJ5IGhlaWdodCpzY2FsZSwgaG93ZXZlciBzb21lIGZpbHRlcnMgKGV4LiBCbHVyRmlsdGVyKVxyXG5cdCAqIHdpbGwgYWRkIHBhZGRpbmcgdG8gdGhlIGNhbnZhcyBkaW1lbnNpb25zLlxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBjYWNoZVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgb3JpZ2luIGZvciB0aGUgY2FjaGUgcmVnaW9uLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgb3JpZ2luIGZvciB0aGUgY2FjaGUgcmVnaW9uLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIGNhY2hlIHJlZ2lvbi5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGNhY2hlIHJlZ2lvbi5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlPTFdIFRoZSBzY2FsZSBhdCB3aGljaCB0aGUgY2FjaGUgd2lsbCBiZSBjcmVhdGVkLiBGb3IgZXhhbXBsZSwgaWYgeW91IGNhY2hlIGEgdmVjdG9yIHNoYXBlIHVzaW5nXHJcblx0ICogXHRteVNoYXBlLmNhY2hlKDAsMCwxMDAsMTAwLDIpIHRoZW4gdGhlIHJlc3VsdGluZyBjYWNoZUNhbnZhcyB3aWxsIGJlIDIwMHgyMDAgcHguIFRoaXMgbGV0cyB5b3Ugc2NhbGUgYW5kIHJvdGF0ZVxyXG5cdCAqIFx0Y2FjaGVkIGVsZW1lbnRzIHdpdGggZ3JlYXRlciBmaWRlbGl0eS4gRGVmYXVsdCBpcyAxLlxyXG5cdCAqKi9cclxuXHRwLmNhY2hlID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCwgc2NhbGUpIHtcclxuXHRcdC8vIGRyYXcgdG8gY2FudmFzLlxyXG5cdFx0c2NhbGUgPSBzY2FsZXx8MTtcclxuXHRcdGlmICghdGhpcy5jYWNoZUNhbnZhcykgeyB0aGlzLmNhY2hlQ2FudmFzID0gY3JlYXRlanMuY3JlYXRlQ2FudmFzP2NyZWF0ZWpzLmNyZWF0ZUNhbnZhcygpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7IH1cclxuXHRcdHRoaXMuX2NhY2hlV2lkdGggPSB3aWR0aDtcclxuXHRcdHRoaXMuX2NhY2hlSGVpZ2h0ID0gaGVpZ2h0O1xyXG5cdFx0dGhpcy5fY2FjaGVPZmZzZXRYID0geDtcclxuXHRcdHRoaXMuX2NhY2hlT2Zmc2V0WSA9IHk7XHJcblx0XHR0aGlzLl9jYWNoZVNjYWxlID0gc2NhbGU7XHJcblx0XHR0aGlzLnVwZGF0ZUNhY2hlKCk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmVkcmF3cyB0aGUgZGlzcGxheSBvYmplY3QgdG8gaXRzIGNhY2hlLiBDYWxsaW5nIHVwZGF0ZUNhY2hlIHdpdGhvdXQgYW4gYWN0aXZlIGNhY2hlIHdpbGwgdGhyb3cgYW4gZXJyb3IuXHJcblx0ICogSWYgY29tcG9zaXRlT3BlcmF0aW9uIGlzIG51bGwgdGhlIGN1cnJlbnQgY2FjaGUgd2lsbCBiZSBjbGVhcmVkIHByaW9yIHRvIGRyYXdpbmcuIE90aGVyd2lzZSB0aGUgZGlzcGxheSBvYmplY3RcclxuXHQgKiB3aWxsIGJlIGRyYXduIG92ZXIgdGhlIGV4aXN0aW5nIGNhY2hlIHVzaW5nIHRoZSBzcGVjaWZpZWQgY29tcG9zaXRlT3BlcmF0aW9uLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqIENsZWFyIHRoZSBjdXJyZW50IGdyYXBoaWNzIG9mIGEgY2FjaGVkIHNoYXBlLCBkcmF3IHNvbWUgbmV3IGluc3RydWN0aW9ucywgYW5kIHRoZW4gdXBkYXRlIHRoZSBjYWNoZS4gVGhlIG5ldyBsaW5lXHJcblx0ICogd2lsbCBiZSBkcmF3biBvbiB0b3Agb2YgdGhlIG9sZCBvbmUuXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIE5vdCBzaG93bjogQ3JlYXRpbmcgdGhlIHNoYXBlLCBhbmQgY2FjaGluZyBpdC5cclxuXHQgKiAgICAgIHNoYXBlSW5zdGFuY2UuY2xlYXIoKTtcclxuXHQgKiAgICAgIHNoYXBlSW5zdGFuY2Uuc2V0U3Ryb2tlU3R5bGUoMykuYmVnaW5TdHJva2UoXCIjZmYwMDAwXCIpLm1vdmVUbygxMDAsIDEwMCkubGluZVRvKDIwMCwyMDApO1xyXG5cdCAqICAgICAgc2hhcGVJbnN0YW5jZS51cGRhdGVDYWNoZSgpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCB1cGRhdGVDYWNoZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb3NpdGVPcGVyYXRpb24gVGhlIGNvbXBvc2l0ZU9wZXJhdGlvbiB0byB1c2UsIG9yIG51bGwgdG8gY2xlYXIgdGhlIGNhY2hlIGFuZCByZWRyYXcgaXQuXHJcblx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2NvbXBvc2l0aW5nXCI+XHJcblx0ICogd2hhdHdnIHNwZWMgb24gY29tcG9zaXRpbmc8L2E+LlxyXG5cdCAqKi9cclxuXHRwLnVwZGF0ZUNhY2hlID0gZnVuY3Rpb24oY29tcG9zaXRlT3BlcmF0aW9uKSB7XHJcblx0XHR2YXIgY2FjaGVDYW52YXMgPSB0aGlzLmNhY2hlQ2FudmFzO1xyXG5cdFx0aWYgKCFjYWNoZUNhbnZhcykgeyB0aHJvdyBcImNhY2hlKCkgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHVwZGF0ZUNhY2hlKClcIjsgfVxyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5fY2FjaGVTY2FsZSwgb2ZmWCA9IHRoaXMuX2NhY2hlT2Zmc2V0WCpzY2FsZSwgb2ZmWSA9IHRoaXMuX2NhY2hlT2Zmc2V0WSpzY2FsZTtcclxuXHRcdHZhciB3ID0gdGhpcy5fY2FjaGVXaWR0aCwgaCA9IHRoaXMuX2NhY2hlSGVpZ2h0LCBjdHggPSBjYWNoZUNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblx0XHRcclxuXHRcdHZhciBmQm91bmRzID0gdGhpcy5fZ2V0RmlsdGVyQm91bmRzKCk7XHJcblx0XHRvZmZYICs9ICh0aGlzLl9maWx0ZXJPZmZzZXRYID0gZkJvdW5kcy54KTtcclxuXHRcdG9mZlkgKz0gKHRoaXMuX2ZpbHRlck9mZnNldFkgPSBmQm91bmRzLnkpO1xyXG5cdFx0XHJcblx0XHR3ID0gTWF0aC5jZWlsKHcqc2NhbGUpICsgZkJvdW5kcy53aWR0aDtcclxuXHRcdGggPSBNYXRoLmNlaWwoaCpzY2FsZSkgKyBmQm91bmRzLmhlaWdodDtcclxuXHRcdGlmICh3ICE9IGNhY2hlQ2FudmFzLndpZHRoIHx8IGggIT0gY2FjaGVDYW52YXMuaGVpZ2h0KSB7XHJcblx0XHRcdC8vIFRPRE86IGl0IHdvdWxkIGJlIG5pY2UgdG8gcHJlc2VydmUgdGhlIGNvbnRlbnQgaWYgdGhlcmUgaXMgYSBjb21wb3NpdGVPcGVyYXRpb24uXHJcblx0XHRcdGNhY2hlQ2FudmFzLndpZHRoID0gdztcclxuXHRcdFx0Y2FjaGVDYW52YXMuaGVpZ2h0ID0gaDtcclxuXHRcdH0gZWxzZSBpZiAoIWNvbXBvc2l0ZU9wZXJhdGlvbikge1xyXG5cdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHcrMSwgaCsxKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0Y3R4LnNhdmUoKTtcclxuXHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGVPcGVyYXRpb247XHJcblx0XHRjdHguc2V0VHJhbnNmb3JtKHNjYWxlLCAwLCAwLCBzY2FsZSwgLW9mZlgsIC1vZmZZKTtcclxuXHRcdHRoaXMuZHJhdyhjdHgsIHRydWUpO1xyXG5cdFx0Ly8gVE9ETzogZmlsdGVycyBhbmQgY2FjaGUgc2NhbGUgZG9uJ3QgcGxheSB3ZWxsIHRvZ2V0aGVyIGF0IHByZXNlbnQuXHJcblx0XHR0aGlzLl9hcHBseUZpbHRlcnMoKTtcclxuXHRcdGN0eC5yZXN0b3JlKCk7XHJcblx0XHR0aGlzLmNhY2hlSUQgPSBEaXNwbGF5T2JqZWN0Ll9uZXh0Q2FjaGVJRCsrO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIENsZWFycyB0aGUgY3VycmVudCBjYWNoZS4gU2VlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvY2FjaGVcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcblx0ICogQG1ldGhvZCB1bmNhY2hlXHJcblx0ICoqL1xyXG5cdHAudW5jYWNoZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5fY2FjaGVEYXRhVVJMID0gdGhpcy5jYWNoZUNhbnZhcyA9IG51bGw7XHJcblx0XHR0aGlzLmNhY2hlSUQgPSB0aGlzLl9jYWNoZU9mZnNldFggPSB0aGlzLl9jYWNoZU9mZnNldFkgPSB0aGlzLl9maWx0ZXJPZmZzZXRYID0gdGhpcy5fZmlsdGVyT2Zmc2V0WSA9IDA7XHJcblx0XHR0aGlzLl9jYWNoZVNjYWxlID0gMTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBkYXRhIFVSTCBmb3IgdGhlIGNhY2hlLCBvciBudWxsIGlmIHRoaXMgZGlzcGxheSBvYmplY3QgaXMgbm90IGNhY2hlZC5cclxuXHQgKiBVc2VzIGNhY2hlSUQgdG8gZW5zdXJlIGEgbmV3IGRhdGEgVVJMIGlzIG5vdCBnZW5lcmF0ZWQgaWYgdGhlIGNhY2hlIGhhcyBub3QgY2hhbmdlZC5cclxuXHQgKiBAbWV0aG9kIGdldENhY2hlRGF0YVVSTFxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGltYWdlIGRhdGEgdXJsIGZvciB0aGUgY2FjaGUuXHJcblx0ICoqL1xyXG5cdHAuZ2V0Q2FjaGVEYXRhVVJMID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZiAoIXRoaXMuY2FjaGVDYW52YXMpIHsgcmV0dXJuIG51bGw7IH1cclxuXHRcdGlmICh0aGlzLmNhY2hlSUQgIT0gdGhpcy5fY2FjaGVEYXRhVVJMSUQpIHsgdGhpcy5fY2FjaGVEYXRhVVJMID0gdGhpcy5jYWNoZUNhbnZhcy50b0RhdGFVUkwoKTsgfVxyXG5cdFx0cmV0dXJuIHRoaXMuX2NhY2hlRGF0YVVSTDtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBUcmFuc2Zvcm1zIHRoZSBzcGVjaWZpZWQgeCBhbmQgeSBwb3NpdGlvbiBmcm9tIHRoZSBjb29yZGluYXRlIHNwYWNlIG9mIHRoZSBkaXNwbGF5IG9iamVjdFxyXG5cdCAqIHRvIHRoZSBnbG9iYWwgKHN0YWdlKSBjb29yZGluYXRlIHNwYWNlLiBGb3IgZXhhbXBsZSwgdGhpcyBjb3VsZCBiZSB1c2VkIHRvIHBvc2l0aW9uIGFuIEhUTUwgbGFiZWxcclxuXHQgKiBvdmVyIGEgc3BlY2lmaWMgcG9pbnQgb24gYSBuZXN0ZWQgZGlzcGxheSBvYmplY3QuIFJldHVybnMgYSBQb2ludCBpbnN0YW5jZSB3aXRoIHggYW5kIHkgcHJvcGVydGllc1xyXG5cdCAqIGNvcnJlbGF0aW5nIHRvIHRoZSB0cmFuc2Zvcm1lZCBjb29yZGluYXRlcyBvbiB0aGUgc3RhZ2UuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QueCA9IDMwMDtcclxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QueSA9IDIwMDtcclxuXHQgKiAgICAgIHN0YWdlLmFkZENoaWxkKGRpc3BsYXlPYmplY3QpO1xyXG5cdCAqICAgICAgdmFyIHBvaW50ID0gbXlEaXNwbGF5T2JqZWN0LmxvY2FsVG9HbG9iYWwoMTAwLCAxMDApO1xyXG5cdCAqICAgICAgLy8gUmVzdWx0cyBpbiB4PTQwMCwgeT0zMDBcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgbG9jYWxUb0dsb2JhbFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIGluIHRoZSBzb3VyY2UgZGlzcGxheSBvYmplY3QgdG8gdHJhbnNmb3JtLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uIGluIHRoZSBzb3VyY2UgZGlzcGxheSBvYmplY3QgdG8gdHJhbnNmb3JtLlxyXG5cdCAqIEBwYXJhbSB7UG9pbnQgfCBPYmplY3R9IFtwdF0gQW4gb2JqZWN0IHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvLiBJZiBvbWl0dGVkIGEgbmV3IFBvaW50IG9iamVjdCB3aXRoIHgveSBwcm9wZXJ0aWVzIHdpbGwgYmUgcmV0dXJuZWQuIFxyXG5cdCAqIEByZXR1cm4ge1BvaW50fSBBIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzIGNvcnJlbGF0aW5nIHRvIHRoZSB0cmFuc2Zvcm1lZCBjb29yZGluYXRlc1xyXG5cdCAqIG9uIHRoZSBzdGFnZS5cclxuXHQgKiovXHJcblx0cC5sb2NhbFRvR2xvYmFsID0gZnVuY3Rpb24oeCwgeSwgcHQpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldENvbmNhdGVuYXRlZE1hdHJpeCh0aGlzLl9wcm9wcy5tYXRyaXgpLnRyYW5zZm9ybVBvaW50KHgseSwgcHR8fG5ldyBjcmVhdGVqcy5Qb2ludCgpKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBUcmFuc2Zvcm1zIHRoZSBzcGVjaWZpZWQgeCBhbmQgeSBwb3NpdGlvbiBmcm9tIHRoZSBnbG9iYWwgKHN0YWdlKSBjb29yZGluYXRlIHNwYWNlIHRvIHRoZVxyXG5cdCAqIGNvb3JkaW5hdGUgc3BhY2Ugb2YgdGhlIGRpc3BsYXkgb2JqZWN0LiBGb3IgZXhhbXBsZSwgdGhpcyBjb3VsZCBiZSB1c2VkIHRvIGRldGVybWluZVxyXG5cdCAqIHRoZSBjdXJyZW50IG1vdXNlIHBvc2l0aW9uIHdpdGhpbiB0aGUgZGlzcGxheSBvYmplY3QuIFJldHVybnMgYSBQb2ludCBpbnN0YW5jZSB3aXRoIHggYW5kIHkgcHJvcGVydGllc1xyXG5cdCAqIGNvcnJlbGF0aW5nIHRvIHRoZSB0cmFuc2Zvcm1lZCBwb3NpdGlvbiBpbiB0aGUgZGlzcGxheSBvYmplY3QncyBjb29yZGluYXRlIHNwYWNlLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnggPSAzMDA7XHJcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnkgPSAyMDA7XHJcblx0ICogICAgICBzdGFnZS5hZGRDaGlsZChkaXNwbGF5T2JqZWN0KTtcclxuXHQgKiAgICAgIHZhciBwb2ludCA9IG15RGlzcGxheU9iamVjdC5nbG9iYWxUb0xvY2FsKDEwMCwgMTAwKTtcclxuXHQgKiAgICAgIC8vIFJlc3VsdHMgaW4geD0tMjAwLCB5PS0xMDBcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgZ2xvYmFsVG9Mb2NhbFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIG9uIHRoZSBzdGFnZSB0byB0cmFuc2Zvcm0uXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gb24gdGhlIHN0YWdlIHRvIHRyYW5zZm9ybS5cclxuXHQgKiBAcGFyYW0ge1BvaW50IHwgT2JqZWN0fSBbcHRdIEFuIG9iamVjdCB0byBjb3B5IHRoZSByZXN1bHQgaW50by4gSWYgb21pdHRlZCBhIG5ldyBQb2ludCBvYmplY3Qgd2l0aCB4L3kgcHJvcGVydGllcyB3aWxsIGJlIHJldHVybmVkLiBcclxuXHQgKiBAcmV0dXJuIHtQb2ludH0gQSBQb2ludCBpbnN0YW5jZSB3aXRoIHggYW5kIHkgcHJvcGVydGllcyBjb3JyZWxhdGluZyB0byB0aGUgdHJhbnNmb3JtZWQgcG9zaXRpb24gaW4gdGhlXHJcblx0ICogZGlzcGxheSBvYmplY3QncyBjb29yZGluYXRlIHNwYWNlLlxyXG5cdCAqKi9cclxuXHRwLmdsb2JhbFRvTG9jYWwgPSBmdW5jdGlvbih4LCB5LCBwdCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29uY2F0ZW5hdGVkTWF0cml4KHRoaXMuX3Byb3BzLm1hdHJpeCkuaW52ZXJ0KCkudHJhbnNmb3JtUG9pbnQoeCx5LCBwdHx8bmV3IGNyZWF0ZWpzLlBvaW50KCkpO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRyYW5zZm9ybXMgdGhlIHNwZWNpZmllZCB4IGFuZCB5IHBvc2l0aW9uIGZyb20gdGhlIGNvb3JkaW5hdGUgc3BhY2Ugb2YgdGhpcyBkaXNwbGF5IG9iamVjdCB0byB0aGUgY29vcmRpbmF0ZVxyXG5cdCAqIHNwYWNlIG9mIHRoZSB0YXJnZXQgZGlzcGxheSBvYmplY3QuIFJldHVybnMgYSBQb2ludCBpbnN0YW5jZSB3aXRoIHggYW5kIHkgcHJvcGVydGllcyBjb3JyZWxhdGluZyB0byB0aGVcclxuXHQgKiB0cmFuc2Zvcm1lZCBwb3NpdGlvbiBpbiB0aGUgdGFyZ2V0J3MgY29vcmRpbmF0ZSBzcGFjZS4gRWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgdXNpbmcgdGhlIGZvbGxvd2luZyBjb2RlIHdpdGhcclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2xvY2FsVG9HbG9iYWxcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvZ2xvYmFsVG9Mb2NhbFwifX17ey9jcm9zc0xpbmt9fS5cclxuXHQgKlxyXG5cdCAqICAgICAgdmFyIHB0ID0gdGhpcy5sb2NhbFRvR2xvYmFsKHgsIHkpO1xyXG5cdCAqICAgICAgcHQgPSB0YXJnZXQuZ2xvYmFsVG9Mb2NhbChwdC54LCBwdC55KTtcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgbG9jYWxUb0xvY2FsXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gaW4gdGhlIHNvdXJjZSBkaXNwbGF5IG9iamVjdCB0byB0cmFuc2Zvcm0uXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gb24gdGhlIHNvdXJjZSBkaXNwbGF5IG9iamVjdCB0byB0cmFuc2Zvcm0uXHJcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBkaXNwbGF5IG9iamVjdCB0byB3aGljaCB0aGUgY29vcmRpbmF0ZXMgd2lsbCBiZSB0cmFuc2Zvcm1lZC5cclxuXHQgKiBAcGFyYW0ge1BvaW50IHwgT2JqZWN0fSBbcHRdIEFuIG9iamVjdCB0byBjb3B5IHRoZSByZXN1bHQgaW50by4gSWYgb21pdHRlZCBhIG5ldyBQb2ludCBvYmplY3Qgd2l0aCB4L3kgcHJvcGVydGllcyB3aWxsIGJlIHJldHVybmVkLiBcclxuXHQgKiBAcmV0dXJuIHtQb2ludH0gUmV0dXJucyBhIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzIGNvcnJlbGF0aW5nIHRvIHRoZSB0cmFuc2Zvcm1lZCBwb3NpdGlvblxyXG5cdCAqIGluIHRoZSB0YXJnZXQncyBjb29yZGluYXRlIHNwYWNlLlxyXG5cdCAqKi9cclxuXHRwLmxvY2FsVG9Mb2NhbCA9IGZ1bmN0aW9uKHgsIHksIHRhcmdldCwgcHQpIHtcclxuXHRcdHB0ID0gdGhpcy5sb2NhbFRvR2xvYmFsKHgsIHksIHB0KTtcclxuXHRcdHJldHVybiB0YXJnZXQuZ2xvYmFsVG9Mb2NhbChwdC54LCBwdC55LCBwdCk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogU2hvcnRjdXQgbWV0aG9kIHRvIHF1aWNrbHkgc2V0IHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyBvbiB0aGUgZGlzcGxheSBvYmplY3QuIEFsbCBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbC5cclxuXHQgKiBPbWl0dGVkIHBhcmFtZXRlcnMgd2lsbCBoYXZlIHRoZSBkZWZhdWx0IHZhbHVlIHNldC5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5zZXRUcmFuc2Zvcm0oMTAwLCAxMDAsIDIsIDIpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBzZXRUcmFuc2Zvcm1cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gVGhlIGhvcml6b250YWwgdHJhbnNsYXRpb24gKHggcG9zaXRpb24pIGluIHBpeGVsc1xyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSBUaGUgdmVydGljYWwgdHJhbnNsYXRpb24gKHkgcG9zaXRpb24pIGluIHBpeGVsc1xyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVYPTFdIFRoZSBob3Jpem9udGFsIHNjYWxlLCBhcyBhIHBlcmNlbnRhZ2Ugb2YgMVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVZPTFdIHRoZSB2ZXJ0aWNhbCBzY2FsZSwgYXMgYSBwZXJjZW50YWdlIG9mIDFcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3JvdGF0aW9uPTBdIFRoZSByb3RhdGlvbiwgaW4gZGVncmVlc1xyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2tld1g9MF0gVGhlIGhvcml6b250YWwgc2tldyBmYWN0b3JcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NrZXdZPTBdIFRoZSB2ZXJ0aWNhbCBza2V3IGZhY3RvclxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcmVnWD0wXSBUaGUgaG9yaXpvbnRhbCByZWdpc3RyYXRpb24gcG9pbnQgaW4gcGl4ZWxzXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtyZWdZPTBdIFRoZSB2ZXJ0aWNhbCByZWdpc3RyYXRpb24gcG9pbnQgaW4gcGl4ZWxzXHJcblx0ICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gUmV0dXJucyB0aGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIGNvbW1hbmRzLlxyXG5cdCAqIEBjaGFpbmFibGVcclxuXHQqL1xyXG5cdHAuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24oeCwgeSwgc2NhbGVYLCBzY2FsZVksIHJvdGF0aW9uLCBza2V3WCwgc2tld1ksIHJlZ1gsIHJlZ1kpIHtcclxuXHRcdHRoaXMueCA9IHggfHwgMDtcclxuXHRcdHRoaXMueSA9IHkgfHwgMDtcclxuXHRcdHRoaXMuc2NhbGVYID0gc2NhbGVYID09IG51bGwgPyAxIDogc2NhbGVYO1xyXG5cdFx0dGhpcy5zY2FsZVkgPSBzY2FsZVkgPT0gbnVsbCA/IDEgOiBzY2FsZVk7XHJcblx0XHR0aGlzLnJvdGF0aW9uID0gcm90YXRpb24gfHwgMDtcclxuXHRcdHRoaXMuc2tld1ggPSBza2V3WCB8fCAwO1xyXG5cdFx0dGhpcy5za2V3WSA9IHNrZXdZIHx8IDA7XHJcblx0XHR0aGlzLnJlZ1ggPSByZWdYIHx8IDA7XHJcblx0XHR0aGlzLnJlZ1kgPSByZWdZIHx8IDA7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBtYXRyaXggYmFzZWQgb24gdGhpcyBvYmplY3QncyBjdXJyZW50IHRyYW5zZm9ybS5cclxuXHQgKiBAbWV0aG9kIGdldE1hdHJpeFxyXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeCBPcHRpb25hbC4gQSBNYXRyaXgyRCBvYmplY3QgdG8gcG9wdWxhdGUgd2l0aCB0aGUgY2FsY3VsYXRlZCB2YWx1ZXMuIElmIG51bGwsIGEgbmV3XHJcblx0ICogTWF0cml4IG9iamVjdCBpcyByZXR1cm5lZC5cclxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gQSBtYXRyaXggcmVwcmVzZW50aW5nIHRoaXMgZGlzcGxheSBvYmplY3QncyB0cmFuc2Zvcm0uXHJcblx0ICoqL1xyXG5cdHAuZ2V0TWF0cml4ID0gZnVuY3Rpb24obWF0cml4KSB7XHJcblx0XHR2YXIgbyA9IHRoaXMsIG10eCA9IG1hdHJpeCYmbWF0cml4LmlkZW50aXR5KCkgfHwgbmV3IGNyZWF0ZWpzLk1hdHJpeDJEKCk7XHJcblx0XHRyZXR1cm4gby50cmFuc2Zvcm1NYXRyaXggPyAgbXR4LmNvcHkoby50cmFuc2Zvcm1NYXRyaXgpIDogbXR4LmFwcGVuZFRyYW5zZm9ybShvLngsIG8ueSwgby5zY2FsZVgsIG8uc2NhbGVZLCBvLnJvdGF0aW9uLCBvLnNrZXdYLCBvLnNrZXdZLCBvLnJlZ1gsIG8ucmVnWSk7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZXMgYSBNYXRyaXgyRCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjb21iaW5lZCB0cmFuc2Zvcm0gb2YgdGhlIGRpc3BsYXkgb2JqZWN0IGFuZCBhbGwgb2YgaXRzXHJcblx0ICogcGFyZW50IENvbnRhaW5lcnMgdXAgdG8gdGhlIGhpZ2hlc3QgbGV2ZWwgYW5jZXN0b3IgKHVzdWFsbHkgdGhlIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319KS4gVGhpcyBjYW5cclxuXHQgKiBiZSB1c2VkIHRvIHRyYW5zZm9ybSBwb3NpdGlvbnMgYmV0d2VlbiBjb29yZGluYXRlIHNwYWNlcywgc3VjaCBhcyB3aXRoIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbG9jYWxUb0dsb2JhbFwifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIGFuZCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2dsb2JhbFRvTG9jYWxcIn19e3svY3Jvc3NMaW5rfX0uXHJcblx0ICogQG1ldGhvZCBnZXRDb25jYXRlbmF0ZWRNYXRyaXhcclxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBbbWF0cml4XSBBIHt7I2Nyb3NzTGluayBcIk1hdHJpeDJEXCJ9fXt7L2Nyb3NzTGlua319IG9iamVjdCB0byBwb3B1bGF0ZSB3aXRoIHRoZSBjYWxjdWxhdGVkIHZhbHVlcy5cclxuXHQgKiBJZiBudWxsLCBhIG5ldyBNYXRyaXgyRCBvYmplY3QgaXMgcmV0dXJuZWQuXHJcblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoZSBjb21iaW5lZCBtYXRyaXguXHJcblx0ICoqL1xyXG5cdHAuZ2V0Q29uY2F0ZW5hdGVkTWF0cml4ID0gZnVuY3Rpb24obWF0cml4KSB7XHJcblx0XHR2YXIgbyA9IHRoaXMsIG10eCA9IHRoaXMuZ2V0TWF0cml4KG1hdHJpeCk7XHJcblx0XHR3aGlsZSAobyA9IG8ucGFyZW50KSB7XHJcblx0XHRcdG10eC5wcmVwZW5kTWF0cml4KG8uZ2V0TWF0cml4KG8uX3Byb3BzLm1hdHJpeCkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG10eDtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlcyBhIERpc3BsYXlQcm9wcyBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjb21iaW5lZCBkaXNwbGF5IHByb3BlcnRpZXMgb2YgdGhlICBvYmplY3QgYW5kIGFsbCBvZiBpdHNcclxuXHQgKiBwYXJlbnQgQ29udGFpbmVycyB1cCB0byB0aGUgaGlnaGVzdCBsZXZlbCBhbmNlc3RvciAodXN1YWxseSB0aGUge3sjY3Jvc3NMaW5rIFwiU3RhZ2VcIn19e3svY3Jvc3NMaW5rfX0pLlxyXG5cdCAqIEBtZXRob2QgZ2V0Q29uY2F0ZW5hdGVkRGlzcGxheVByb3BzXHJcblx0ICogQHBhcmFtIHtEaXNwbGF5UHJvcHN9IFtwcm9wc10gQSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5UHJvcHNcIn19e3svY3Jvc3NMaW5rfX0gb2JqZWN0IHRvIHBvcHVsYXRlIHdpdGggdGhlIGNhbGN1bGF0ZWQgdmFsdWVzLlxyXG5cdCAqIElmIG51bGwsIGEgbmV3IERpc3BsYXlQcm9wcyBvYmplY3QgaXMgcmV0dXJuZWQuXHJcblx0ICogQHJldHVybiB7RGlzcGxheVByb3BzfSBUaGUgY29tYmluZWQgZGlzcGxheSBwcm9wZXJ0aWVzLlxyXG5cdCAqKi9cclxuXHRwLmdldENvbmNhdGVuYXRlZERpc3BsYXlQcm9wcyA9IGZ1bmN0aW9uKHByb3BzKSB7XHJcblx0XHRwcm9wcyA9IHByb3BzID8gcHJvcHMuaWRlbnRpdHkoKSA6IG5ldyBjcmVhdGVqcy5EaXNwbGF5UHJvcHMoKTtcclxuXHRcdHZhciBvID0gdGhpcywgbXR4ID0gby5nZXRNYXRyaXgocHJvcHMubWF0cml4KTsgXHJcblx0XHRkbyB7XHJcblx0XHRcdHByb3BzLnByZXBlbmQoby52aXNpYmxlLCBvLmFscGhhLCBvLnNoYWRvdywgby5jb21wb3NpdGVPcGVyYXRpb24pO1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gd2UgZG8gdGhpcyB0byBhdm9pZCBwcm9ibGVtcyB3aXRoIHRoZSBtYXRyaXggYmVpbmcgdXNlZCBmb3IgYm90aCBvcGVyYXRpb25zIHdoZW4gby5fcHJvcHMubWF0cml4IGlzIHBhc3NlZCBpbiBhcyB0aGUgcHJvcHMgcGFyYW0uXHJcblx0XHRcdC8vIHRoaXMgY291bGQgYmUgc2ltcGxpZmllZCAoaWUuIGp1c3QgZG9uZSBhcyBwYXJ0IG9mIHRoZSBwcmVwZW5kIGFib3ZlKSBpZiB3ZSBzd2l0Y2hlZCB0byB1c2luZyBhIHBvb2wuXHJcblx0XHRcdGlmIChvICE9IHRoaXMpIHsgbXR4LnByZXBlbmRNYXRyaXgoby5nZXRNYXRyaXgoby5fcHJvcHMubWF0cml4KSk7IH1cclxuXHRcdH0gd2hpbGUgKG8gPSBvLnBhcmVudCk7XHJcblx0XHRyZXR1cm4gcHJvcHM7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogVGVzdHMgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3QgaW50ZXJzZWN0cyB0aGUgc3BlY2lmaWVkIHBvaW50IGluIGxvY2FsIGNvb3JkaW5hdGVzIChpZS4gZHJhd3MgYSBwaXhlbCB3aXRoIGFscGhhID4gMCBhdFxyXG5cdCAqIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24pLiBUaGlzIGlnbm9yZXMgdGhlIGFscGhhLCBzaGFkb3csIGhpdEFyZWEsIG1hc2ssIGFuZCBjb21wb3NpdGVPcGVyYXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0LlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICBzdGFnZS5hZGRFdmVudExpc3RlbmVyKFwic3RhZ2Vtb3VzZWRvd25cIiwgaGFuZGxlTW91c2VEb3duKTtcclxuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xyXG5cdCAqICAgICAgICAgIHZhciBoaXQgPSBteVNoYXBlLmhpdFRlc3QoZXZlbnQuc3RhZ2VYLCBldmVudC5zdGFnZVkpO1xyXG5cdCAqICAgICAgfVxyXG5cdCAqXHJcblx0ICogUGxlYXNlIG5vdGUgdGhhdCBzaGFwZS10by1zaGFwZSBjb2xsaXNpb24gaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgRWFzZWxKUy5cclxuXHQgKiBAbWV0aG9kIGhpdFRlc3RcclxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvbiB0byBjaGVjayBpbiB0aGUgZGlzcGxheSBvYmplY3QncyBsb2NhbCBjb29yZGluYXRlcy5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiB0byBjaGVjayBpbiB0aGUgZGlzcGxheSBvYmplY3QncyBsb2NhbCBjb29yZGluYXRlcy5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGEgdmlzaWJsZSBwb3J0aW9uIG9mIHRoZSBEaXNwbGF5T2JqZWN0IGludGVyc2VjdCB0aGUgc3BlY2lmaWVkXHJcblx0ICogbG9jYWwgUG9pbnQuXHJcblx0Ki9cclxuXHRwLmhpdFRlc3QgPSBmdW5jdGlvbih4LCB5KSB7XHJcblx0XHR2YXIgY3R4ID0gRGlzcGxheU9iamVjdC5faGl0VGVzdENvbnRleHQ7XHJcblx0XHRjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIC14LCAteSk7XHJcblx0XHR0aGlzLmRyYXcoY3R4KTtcclxuXHJcblx0XHR2YXIgaGl0ID0gdGhpcy5fdGVzdEhpdChjdHgpO1xyXG5cdFx0Y3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcclxuXHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgMiwgMik7XHJcblx0XHRyZXR1cm4gaGl0O1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogUHJvdmlkZXMgYSBjaGFpbmFibGUgc2hvcnRjdXQgbWV0aG9kIGZvciBzZXR0aW5nIGEgbnVtYmVyIG9mIHByb3BlcnRpZXMgb24gdGhlIGluc3RhbmNlLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICB2YXIgbXlHcmFwaGljcyA9IG5ldyBjcmVhdGVqcy5HcmFwaGljcygpLmJlZ2luRmlsbChcIiNmZjAwMDBcIikuZHJhd0NpcmNsZSgwLCAwLCAyNSk7XHJcblx0ICogICAgICB2YXIgc2hhcGUgPSBzdGFnZS5hZGRDaGlsZChuZXcgU2hhcGUoKSkuc2V0KHtncmFwaGljczpteUdyYXBoaWNzLCB4OjEwMCwgeToxMDAsIGFscGhhOjAuNX0pO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBzZXRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQSBnZW5lcmljIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gY29weSB0byB0aGUgRGlzcGxheU9iamVjdCBpbnN0YW5jZS5cclxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBSZXR1cm5zIHRoZSBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXHJcblx0ICogQGNoYWluYWJsZVxyXG5cdCovXHJcblx0cC5zZXQgPSBmdW5jdGlvbihwcm9wcykge1xyXG5cdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykgeyB0aGlzW25dID0gcHJvcHNbbl07IH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHJlY3RhbmdsZSByZXByZXNlbnRpbmcgdGhpcyBvYmplY3QncyBib3VuZHMgaW4gaXRzIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtIChpZS4gd2l0aCBubyB0cmFuc2Zvcm1hdGlvbikuXHJcblx0ICogT2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBjYWNoZWQgd2lsbCByZXR1cm4gdGhlIGJvdW5kcyBvZiB0aGUgY2FjaGUuXHJcblx0ICogXHJcblx0ICogTm90IGFsbCBkaXNwbGF5IG9iamVjdHMgY2FuIGNhbGN1bGF0ZSB0aGVpciBvd24gYm91bmRzIChleC4gU2hhcGUpLiBGb3IgdGhlc2Ugb2JqZWN0cywgeW91IGNhbiB1c2UgXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9zZXRCb3VuZHNcIn19e3svY3Jvc3NMaW5rfX0gc28gdGhhdCB0aGV5IGFyZSBpbmNsdWRlZCB3aGVuIGNhbGN1bGF0aW5nIENvbnRhaW5lclxyXG5cdCAqIGJvdW5kcy5cclxuXHQgKiBcclxuXHQgKiA8dGFibGU+XHJcblx0ICogXHQ8dHI+PHRkPjxiPkFsbDwvYj48L3RkPjx0ZD5cclxuXHQgKiBcdFx0QWxsIGRpc3BsYXkgb2JqZWN0cyBzdXBwb3J0IHNldHRpbmcgYm91bmRzIG1hbnVhbGx5IHVzaW5nIHNldEJvdW5kcygpLiBMaWtld2lzZSwgZGlzcGxheSBvYmplY3RzIHRoYXRcclxuXHQgKiBcdFx0aGF2ZSBiZWVuIGNhY2hlZCB1c2luZyBjYWNoZSgpIHdpbGwgcmV0dXJuIHRoZSBib3VuZHMgb2YgdGhlaXIgY2FjaGUuIE1hbnVhbCBhbmQgY2FjaGUgYm91bmRzIHdpbGwgb3ZlcnJpZGVcclxuXHQgKiBcdFx0dGhlIGF1dG9tYXRpYyBjYWxjdWxhdGlvbnMgbGlzdGVkIGJlbG93LlxyXG5cdCAqIFx0PC90ZD48L3RyPlxyXG5cdCAqIFx0PHRyPjx0ZD48Yj5CaXRtYXA8L2I+PC90ZD48dGQ+XHJcblx0ICogXHRcdFJldHVybnMgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHNvdXJjZVJlY3QgKGlmIHNwZWNpZmllZCkgb3IgaW1hZ2UsIGV4dGVuZGluZyBmcm9tICh4PTAseT0wKS5cclxuXHQgKiBcdDwvdGQ+PC90cj5cclxuXHQgKiBcdDx0cj48dGQ+PGI+U3ByaXRlPC9iPjwvdGQ+PHRkPlxyXG5cdCAqIFx0XHRSZXR1cm5zIHRoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnQgZnJhbWUuIE1heSBoYXZlIG5vbi16ZXJvIHgveSBpZiBhIGZyYW1lIHJlZ2lzdHJhdGlvbiBwb2ludCB3YXMgc3BlY2lmaWVkXHJcblx0ICogXHRcdGluIHRoZSBzcHJpdGVzaGVldCBkYXRhLiBTZWUgYWxzbyB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldC9nZXRGcmFtZUJvdW5kc1wifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIFx0PC90ZD48L3RyPlxyXG5cdCAqIFx0PHRyPjx0ZD48Yj5Db250YWluZXI8L2I+PC90ZD48dGQ+XHJcblx0ICogXHRcdFJldHVybnMgdGhlIGFnZ3JlZ2F0ZSAoY29tYmluZWQpIGJvdW5kcyBvZiBhbGwgY2hpbGRyZW4gdGhhdCByZXR1cm4gYSBub24tbnVsbCB2YWx1ZSBmcm9tIGdldEJvdW5kcygpLlxyXG5cdCAqIFx0PC90ZD48L3RyPlxyXG5cdCAqIFx0PHRyPjx0ZD48Yj5TaGFwZTwvYj48L3RkPjx0ZD5cclxuXHQgKiBcdFx0RG9lcyBub3QgY3VycmVudGx5IHN1cHBvcnQgYXV0b21hdGljIGJvdW5kcyBjYWxjdWxhdGlvbnMuIFVzZSBzZXRCb3VuZHMoKSB0byBtYW51YWxseSBkZWZpbmUgYm91bmRzLlxyXG5cdCAqIFx0PC90ZD48L3RyPlxyXG5cdCAqIFx0PHRyPjx0ZD48Yj5UZXh0PC9iPjwvdGQ+PHRkPlxyXG5cdCAqIFx0XHRSZXR1cm5zIGFwcHJveGltYXRlIGJvdW5kcy4gSG9yaXpvbnRhbCB2YWx1ZXMgKHgvd2lkdGgpIGFyZSBxdWl0ZSBhY2N1cmF0ZSwgYnV0IHZlcnRpY2FsIHZhbHVlcyAoeS9oZWlnaHQpIGFyZVxyXG5cdCAqIFx0XHRub3QsIGVzcGVjaWFsbHkgd2hlbiB1c2luZyB0ZXh0QmFzZWxpbmUgdmFsdWVzIG90aGVyIHRoYW4gXCJ0b3BcIi5cclxuXHQgKiBcdDwvdGQ+PC90cj5cclxuXHQgKiBcdDx0cj48dGQ+PGI+Qml0bWFwVGV4dDwvYj48L3RkPjx0ZD5cclxuXHQgKiBcdFx0UmV0dXJucyBhcHByb3hpbWF0ZSBib3VuZHMuIFZhbHVlcyB3aWxsIGJlIG1vcmUgYWNjdXJhdGUgaWYgc3ByaXRlc2hlZXQgZnJhbWUgcmVnaXN0cmF0aW9uIHBvaW50cyBhcmUgY2xvc2VcclxuXHQgKiBcdFx0dG8gKHg9MCx5PTApLlxyXG5cdCAqIFx0PC90ZD48L3RyPlxyXG5cdCogPC90YWJsZT5cclxuXHQgKiBcclxuXHQgKiBCb3VuZHMgY2FuIGJlIGV4cGVuc2l2ZSB0byBjYWxjdWxhdGUgZm9yIHNvbWUgb2JqZWN0cyAoZXguIHRleHQsIG9yIGNvbnRhaW5lcnMgd2l0aCBtYW55IGNoaWxkcmVuKSwgYW5kXHJcblx0ICogYXJlIHJlY2FsY3VsYXRlZCBlYWNoIHRpbWUgeW91IGNhbGwgZ2V0Qm91bmRzKCkuIFlvdSBjYW4gcHJldmVudCByZWNhbGN1bGF0aW9uIG9uIHN0YXRpYyBvYmplY3RzIGJ5IHNldHRpbmcgdGhlXHJcblx0ICogYm91bmRzIGV4cGxpY2l0bHk6XHJcblx0ICogXHJcblx0ICogXHR2YXIgYm91bmRzID0gb2JqLmdldEJvdW5kcygpO1xyXG5cdCAqIFx0b2JqLnNldEJvdW5kcyhib3VuZHMueCwgYm91bmRzLnksIGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCk7XHJcblx0ICogXHQvLyBnZXRCb3VuZHMgd2lsbCBub3cgdXNlIHRoZSBzZXQgdmFsdWVzLCBpbnN0ZWFkIG9mIHJlY2FsY3VsYXRpbmdcclxuXHQgKiBcclxuXHQgKiBUbyByZWR1Y2UgbWVtb3J5IGltcGFjdCwgdGhlIHJldHVybmVkIFJlY3RhbmdsZSBpbnN0YW5jZSBtYXkgYmUgcmV1c2VkIGludGVybmFsbHk7IGNsb25lIHRoZSBpbnN0YW5jZSBvciBjb3B5IGl0c1xyXG5cdCAqIHZhbHVlcyBpZiB5b3UgbmVlZCB0byByZXRhaW4gaXQuXHJcblx0ICogXHJcblx0ICogXHR2YXIgbXlCb3VuZHMgPSBvYmouZ2V0Qm91bmRzKCkuY2xvbmUoKTtcclxuXHQgKiBcdC8vIE9SOlxyXG5cdCAqIFx0bXlSZWN0LmNvcHkob2JqLmdldEJvdW5kcygpKTtcclxuXHQgKiBcclxuXHQgKiBAbWV0aG9kIGdldEJvdW5kc1xyXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gQSBSZWN0YW5nbGUgaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoZSBib3VuZHMsIG9yIG51bGwgaWYgYm91bmRzIGFyZSBub3QgYXZhaWxhYmxlIGZvciB0aGlzXHJcblx0ICogb2JqZWN0LlxyXG5cdCAqKi9cclxuXHRwLmdldEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYgKHRoaXMuX2JvdW5kcykgeyByZXR1cm4gdGhpcy5fcmVjdGFuZ2xlLmNvcHkodGhpcy5fYm91bmRzKTsgfVxyXG5cdFx0dmFyIGNhY2hlQ2FudmFzID0gdGhpcy5jYWNoZUNhbnZhcztcclxuXHRcdGlmIChjYWNoZUNhbnZhcykge1xyXG5cdFx0XHR2YXIgc2NhbGUgPSB0aGlzLl9jYWNoZVNjYWxlO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVjdGFuZ2xlLnNldFZhbHVlcyh0aGlzLl9jYWNoZU9mZnNldFgsIHRoaXMuX2NhY2hlT2Zmc2V0WSwgY2FjaGVDYW52YXMud2lkdGgvc2NhbGUsIGNhY2hlQ2FudmFzLmhlaWdodC9zY2FsZSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSByZWN0YW5nbGUgcmVwcmVzZW50aW5nIHRoaXMgb2JqZWN0J3MgYm91bmRzIGluIGl0cyBwYXJlbnQncyBjb29yZGluYXRlIHN5c3RlbSAoaWUuIHdpdGggdHJhbnNmb3JtYXRpb25zIGFwcGxpZWQpLlxyXG5cdCAqIE9iamVjdHMgdGhhdCBoYXZlIGJlZW4gY2FjaGVkIHdpbGwgcmV0dXJuIHRoZSB0cmFuc2Zvcm1lZCBib3VuZHMgb2YgdGhlIGNhY2hlLlxyXG5cdCAqIFxyXG5cdCAqIE5vdCBhbGwgZGlzcGxheSBvYmplY3RzIGNhbiBjYWxjdWxhdGUgdGhlaXIgb3duIGJvdW5kcyAoZXguIFNoYXBlKS4gRm9yIHRoZXNlIG9iamVjdHMsIHlvdSBjYW4gdXNlIFxyXG5cdCAqIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3Qvc2V0Qm91bmRzXCJ9fXt7L2Nyb3NzTGlua319IHNvIHRoYXQgdGhleSBhcmUgaW5jbHVkZWQgd2hlbiBjYWxjdWxhdGluZyBDb250YWluZXJcclxuXHQgKiBib3VuZHMuXHJcblx0ICogXHJcblx0ICogVG8gcmVkdWNlIG1lbW9yeSBpbXBhY3QsIHRoZSByZXR1cm5lZCBSZWN0YW5nbGUgaW5zdGFuY2UgbWF5IGJlIHJldXNlZCBpbnRlcm5hbGx5OyBjbG9uZSB0aGUgaW5zdGFuY2Ugb3IgY29weSBpdHNcclxuXHQgKiB2YWx1ZXMgaWYgeW91IG5lZWQgdG8gcmV0YWluIGl0LlxyXG5cdCAqIFxyXG5cdCAqIENvbnRhaW5lciBpbnN0YW5jZXMgY2FsY3VsYXRlIGFnZ3JlZ2F0ZSBib3VuZHMgZm9yIGFsbCBjaGlsZHJlbiB0aGF0IHJldHVybiBib3VuZHMgdmlhIGdldEJvdW5kcy5cclxuXHQgKiBAbWV0aG9kIGdldFRyYW5zZm9ybWVkQm91bmRzXHJcblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBBIFJlY3RhbmdsZSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlIGJvdW5kcywgb3IgbnVsbCBpZiBib3VuZHMgYXJlIG5vdCBhdmFpbGFibGUgZm9yIHRoaXMgb2JqZWN0LlxyXG5cdCAqKi9cclxuXHRwLmdldFRyYW5zZm9ybWVkQm91bmRzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fZ2V0Qm91bmRzKCk7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBBbGxvd3MgeW91IHRvIG1hbnVhbGx5IHNwZWNpZnkgdGhlIGJvdW5kcyBvZiBhbiBvYmplY3QgdGhhdCBlaXRoZXIgY2Fubm90IGNhbGN1bGF0ZSB0aGVpciBvd24gYm91bmRzIChleC4gU2hhcGUgJlxyXG5cdCAqIFRleHQpIGZvciBmdXR1cmUgcmVmZXJlbmNlLCBvciBzbyB0aGUgb2JqZWN0IGNhbiBiZSBpbmNsdWRlZCBpbiBDb250YWluZXIgYm91bmRzLiBNYW51YWxseSBzZXQgYm91bmRzIHdpbGwgYWx3YXlzXHJcblx0ICogb3ZlcnJpZGUgY2FsY3VsYXRlZCBib3VuZHMuXHJcblx0ICogXHJcblx0ICogVGhlIGJvdW5kcyBzaG91bGQgYmUgc3BlY2lmaWVkIGluIHRoZSBvYmplY3QncyBsb2NhbCAodW50cmFuc2Zvcm1lZCkgY29vcmRpbmF0ZXMuIEZvciBleGFtcGxlLCBhIFNoYXBlIGluc3RhbmNlXHJcblx0ICogd2l0aCBhIDI1cHggcmFkaXVzIGNpcmNsZSBjZW50ZXJlZCBhdCAwLDAgd291bGQgaGF2ZSBib3VuZHMgb2YgKC0yNSwgLTI1LCA1MCwgNTApLlxyXG5cdCAqIEBtZXRob2Qgc2V0Qm91bmRzXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggb3JpZ2luIG9mIHRoZSBib3VuZHMuIFBhc3MgbnVsbCB0byByZW1vdmUgdGhlIG1hbnVhbCBib3VuZHMuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgb3JpZ2luIG9mIHRoZSBib3VuZHMuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgYm91bmRzLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgYm91bmRzLlxyXG5cdCAqKi9cclxuXHRwLnNldEJvdW5kcyA9IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuXHRcdGlmICh4ID09IG51bGwpIHsgdGhpcy5fYm91bmRzID0geDsgfVxyXG5cdFx0dGhpcy5fYm91bmRzID0gKHRoaXMuX2JvdW5kcyB8fCBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKCkpLnNldFZhbHVlcyh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBEaXNwbGF5T2JqZWN0LiBTb21lIHByb3BlcnRpZXMgdGhhdCBhcmUgc3BlY2lmaWMgdG8gdGhpcyBpbnN0YW5jZSdzIGN1cnJlbnQgY29udGV4dCBhcmVcclxuXHQgKiByZXZlcnRlZCB0byB0aGVpciBkZWZhdWx0cyAoZm9yIGV4YW1wbGUgLnBhcmVudCkuIENhY2hlcyBhcmUgbm90IG1haW50YWluZWQgYWNyb3NzIGNsb25lcywgYW5kIHNvbWUgZWxlbWVudHNcclxuXHQgKiBhcmUgY29waWVkIGJ5IHJlZmVyZW5jZSAobWFza3MsIGluZGl2aWR1YWwgZmlsdGVyIGluc3RhbmNlcywgaGl0IGFyZWEpXHJcblx0ICogQG1ldGhvZCBjbG9uZVxyXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IEEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgRGlzcGxheU9iamVjdCBpbnN0YW5jZS5cclxuXHQgKiovXHJcblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lUHJvcHMobmV3IERpc3BsYXlPYmplY3QoKSk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cclxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXHJcblx0ICoqL1xyXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBcIltEaXNwbGF5T2JqZWN0IChuYW1lPVwiKyAgdGhpcy5uYW1lICtcIildXCI7XHJcblx0fTtcclxuXHJcblxyXG4vLyBwcml2YXRlIG1ldGhvZHM6XHJcblx0Ly8gc2VwYXJhdGVkIHNvIGl0IGNhbiBiZSB1c2VkIG1vcmUgZWFzaWx5IGluIHN1YmNsYXNzZXM6XHJcblx0LyoqXHJcblx0ICogQG1ldGhvZCBfY2xvbmVQcm9wc1xyXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gbyBUaGUgRGlzcGxheU9iamVjdCBpbnN0YW5jZSB3aGljaCB3aWxsIGhhdmUgcHJvcGVydGllcyBmcm9tIHRoZSBjdXJyZW50IERpc3BsYXlPYmplY3RcclxuXHQgKiBpbnN0YW5jZSBjb3BpZWQgaW50by5cclxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBvXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqKi9cclxuXHRwLl9jbG9uZVByb3BzID0gZnVuY3Rpb24obykge1xyXG5cdFx0by5hbHBoYSA9IHRoaXMuYWxwaGE7XHJcblx0XHRvLm1vdXNlRW5hYmxlZCA9IHRoaXMubW91c2VFbmFibGVkO1xyXG5cdFx0by50aWNrRW5hYmxlZCA9IHRoaXMudGlja0VuYWJsZWQ7XHJcblx0XHRvLm5hbWUgPSB0aGlzLm5hbWU7XHJcblx0XHRvLnJlZ1ggPSB0aGlzLnJlZ1g7XHJcblx0XHRvLnJlZ1kgPSB0aGlzLnJlZ1k7XHJcblx0XHRvLnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcclxuXHRcdG8uc2NhbGVYID0gdGhpcy5zY2FsZVg7XHJcblx0XHRvLnNjYWxlWSA9IHRoaXMuc2NhbGVZO1xyXG5cdFx0by5zaGFkb3cgPSB0aGlzLnNoYWRvdztcclxuXHRcdG8uc2tld1ggPSB0aGlzLnNrZXdYO1xyXG5cdFx0by5za2V3WSA9IHRoaXMuc2tld1k7XHJcblx0XHRvLnZpc2libGUgPSB0aGlzLnZpc2libGU7XHJcblx0XHRvLnggID0gdGhpcy54O1xyXG5cdFx0by55ID0gdGhpcy55O1xyXG5cdFx0by5jb21wb3NpdGVPcGVyYXRpb24gPSB0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbjtcclxuXHRcdG8uc25hcFRvUGl4ZWwgPSB0aGlzLnNuYXBUb1BpeGVsO1xyXG5cdFx0by5maWx0ZXJzID0gdGhpcy5maWx0ZXJzPT1udWxsP251bGw6dGhpcy5maWx0ZXJzLnNsaWNlKDApO1xyXG5cdFx0by5tYXNrID0gdGhpcy5tYXNrO1xyXG5cdFx0by5oaXRBcmVhID0gdGhpcy5oaXRBcmVhO1xyXG5cdFx0by5jdXJzb3IgPSB0aGlzLmN1cnNvcjtcclxuXHRcdG8uX2JvdW5kcyA9IHRoaXMuX2JvdW5kcztcclxuXHRcdHJldHVybiBvO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBtZXRob2QgX2FwcGx5U2hhZG93XHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcclxuXHQgKiBAcGFyYW0ge1NoYWRvd30gc2hhZG93XHJcblx0ICoqL1xyXG5cdHAuX2FwcGx5U2hhZG93ID0gZnVuY3Rpb24oY3R4LCBzaGFkb3cpIHtcclxuXHRcdHNoYWRvdyA9IHNoYWRvdyB8fCBTaGFkb3cuaWRlbnRpdHk7XHJcblx0XHRjdHguc2hhZG93Q29sb3IgPSBzaGFkb3cuY29sb3I7XHJcblx0XHRjdHguc2hhZG93T2Zmc2V0WCA9IHNoYWRvdy5vZmZzZXRYO1xyXG5cdFx0Y3R4LnNoYWRvd09mZnNldFkgPSBzaGFkb3cub2Zmc2V0WTtcclxuXHRcdGN0eC5zaGFkb3dCbHVyID0gc2hhZG93LmJsdXI7XHJcblx0fTtcclxuXHRcclxuXHRcclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIF90aWNrXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2dE9iaiBBbiBldmVudCBvYmplY3QgdGhhdCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gYWxsIHRpY2sgbGlzdGVuZXJzLiBUaGlzIG9iamVjdCBpcyByZXVzZWQgYmV0d2VlbiBkaXNwYXRjaGVycyB0byByZWR1Y2UgY29uc3RydWN0aW9uICYgR0MgY29zdHMuXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqKi9cclxuXHRwLl90aWNrID0gZnVuY3Rpb24oZXZ0T2JqKSB7XHJcblx0XHQvLyBiZWNhdXNlIHRpY2sgY2FuIGJlIHJlYWxseSBwZXJmb3JtYW5jZSBzZW5zaXRpdmUsIGNoZWNrIGZvciBsaXN0ZW5lcnMgYmVmb3JlIGNhbGxpbmcgZGlzcGF0Y2hFdmVudC5cclxuXHRcdHZhciBscyA9IHRoaXMuX2xpc3RlbmVycztcclxuXHRcdGlmIChscyAmJiBsc1tcInRpY2tcIl0pIHtcclxuXHRcdFx0Ly8gcmVzZXQgJiByZXVzZSB0aGUgZXZlbnQgb2JqZWN0IHRvIGF2b2lkIGNvbnN0cnVjdGlvbiAvIEdDIGNvc3RzOlxyXG5cdFx0XHRldnRPYmoudGFyZ2V0ID0gbnVsbDtcclxuXHRcdFx0ZXZ0T2JqLnByb3BhZ2F0aW9uU3RvcHBlZCA9IGV2dE9iai5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2dE9iaik7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQG1ldGhvZCBfdGVzdEhpdFxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cclxuXHQgKiovXHJcblx0cC5fdGVzdEhpdCA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0dmFyIGhpdCA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YVszXSA+IDE7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdGlmICghRGlzcGxheU9iamVjdC5zdXBwcmVzc0Nyb3NzRG9tYWluRXJyb3JzKSB7XHJcblx0XHRcdFx0dGhyb3cgXCJBbiBlcnJvciBoYXMgb2NjdXJyZWQuIFRoaXMgaXMgbW9zdCBsaWtlbHkgZHVlIHRvIHNlY3VyaXR5IHJlc3RyaWN0aW9ucyBvbiByZWFkaW5nIGNhbnZhcyBwaXhlbCBkYXRhIHdpdGggbG9jYWwgb3IgY3Jvc3MtZG9tYWluIGltYWdlcy5cIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGhpdDtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIF9hcHBseUZpbHRlcnNcclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICoqL1xyXG5cdHAuX2FwcGx5RmlsdGVycyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYgKCF0aGlzLmZpbHRlcnMgfHwgdGhpcy5maWx0ZXJzLmxlbmd0aCA9PSAwIHx8ICF0aGlzLmNhY2hlQ2FudmFzKSB7IHJldHVybjsgfVxyXG5cdFx0dmFyIGwgPSB0aGlzLmZpbHRlcnMubGVuZ3RoO1xyXG5cdFx0dmFyIGN0eCA9IHRoaXMuY2FjaGVDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cdFx0dmFyIHcgPSB0aGlzLmNhY2hlQ2FudmFzLndpZHRoO1xyXG5cdFx0dmFyIGggPSB0aGlzLmNhY2hlQ2FudmFzLmhlaWdodDtcclxuXHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKyspIHtcclxuXHRcdFx0dGhpcy5maWx0ZXJzW2ldLmFwcGx5RmlsdGVyKGN0eCwgMCwgMCwgdywgaCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIF9nZXRGaWx0ZXJCb3VuZHNcclxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9XHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqKi9cclxuXHRwLl9nZXRGaWx0ZXJCb3VuZHMgPSBmdW5jdGlvbihyZWN0KSB7XHJcblx0XHR2YXIgbCwgZmlsdGVycyA9IHRoaXMuZmlsdGVycywgYm91bmRzID0gdGhpcy5fcmVjdGFuZ2xlLnNldFZhbHVlcygwLDAsMCwwKTtcclxuXHRcdGlmICghZmlsdGVycyB8fCAhKGw9ZmlsdGVycy5sZW5ndGgpKSB7IHJldHVybiBib3VuZHM7IH1cclxuXHRcdFxyXG5cdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykge1xyXG5cdFx0XHR2YXIgZiA9IHRoaXMuZmlsdGVyc1tpXTtcclxuXHRcdFx0Zi5nZXRCb3VuZHMmJmYuZ2V0Qm91bmRzKGJvdW5kcyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogQG1ldGhvZCBfZ2V0Qm91bmRzXHJcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4XHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVUcmFuc2Zvcm0gSWYgdHJ1ZSwgZG9lcyBub3QgYXBwbHkgdGhpcyBvYmplY3QncyB0cmFuc2Zvcm0uXHJcblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfVxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiovXHJcblx0cC5fZ2V0Qm91bmRzID0gZnVuY3Rpb24obWF0cml4LCBpZ25vcmVUcmFuc2Zvcm0pe1xyXG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybUJvdW5kcyh0aGlzLmdldEJvdW5kcygpLCBtYXRyaXgsIGlnbm9yZVRyYW5zZm9ybSk7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIF90cmFuc2Zvcm1Cb3VuZHNcclxuXHQgKiBAcGFyYW0ge1JlY3RhbmdsZX0gYm91bmRzXHJcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4XHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVUcmFuc2Zvcm1cclxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9XHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqKi9cclxuXHRwLl90cmFuc2Zvcm1Cb3VuZHMgPSBmdW5jdGlvbihib3VuZHMsIG1hdHJpeCwgaWdub3JlVHJhbnNmb3JtKSB7XHJcblx0XHRpZiAoIWJvdW5kcykgeyByZXR1cm4gYm91bmRzOyB9XHJcblx0XHR2YXIgeCA9IGJvdW5kcy54LCB5ID0gYm91bmRzLnksIHdpZHRoID0gYm91bmRzLndpZHRoLCBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0LCBtdHggPSB0aGlzLl9wcm9wcy5tYXRyaXg7XHJcblx0XHRtdHggPSBpZ25vcmVUcmFuc2Zvcm0gPyBtdHguaWRlbnRpdHkoKSA6IHRoaXMuZ2V0TWF0cml4KG10eCk7XHJcblx0XHRcclxuXHRcdGlmICh4IHx8IHkpIHsgbXR4LmFwcGVuZFRyYW5zZm9ybSgwLDAsMSwxLDAsMCwwLC14LC15KTsgfSAvLyBUT0RPOiBzaW1wbGlmeSB0aGlzLlxyXG5cdFx0aWYgKG1hdHJpeCkgeyBtdHgucHJlcGVuZE1hdHJpeChtYXRyaXgpOyB9XHJcblx0XHRcclxuXHRcdHZhciB4X2EgPSB3aWR0aCptdHguYSwgeF9iID0gd2lkdGgqbXR4LmI7XHJcblx0XHR2YXIgeV9jID0gaGVpZ2h0Km10eC5jLCB5X2QgPSBoZWlnaHQqbXR4LmQ7XHJcblx0XHR2YXIgdHggPSBtdHgudHgsIHR5ID0gbXR4LnR5O1xyXG5cdFx0XHJcblx0XHR2YXIgbWluWCA9IHR4LCBtYXhYID0gdHgsIG1pblkgPSB0eSwgbWF4WSA9IHR5O1xyXG5cclxuXHRcdGlmICgoeCA9IHhfYSArIHR4KSA8IG1pblgpIHsgbWluWCA9IHg7IH0gZWxzZSBpZiAoeCA+IG1heFgpIHsgbWF4WCA9IHg7IH1cclxuXHRcdGlmICgoeCA9IHhfYSArIHlfYyArIHR4KSA8IG1pblgpIHsgbWluWCA9IHg7IH0gZWxzZSBpZiAoeCA+IG1heFgpIHsgbWF4WCA9IHg7IH1cclxuXHRcdGlmICgoeCA9IHlfYyArIHR4KSA8IG1pblgpIHsgbWluWCA9IHg7IH0gZWxzZSBpZiAoeCA+IG1heFgpIHsgbWF4WCA9IHg7IH1cclxuXHRcdFxyXG5cdFx0aWYgKCh5ID0geF9iICsgdHkpIDwgbWluWSkgeyBtaW5ZID0geTsgfSBlbHNlIGlmICh5ID4gbWF4WSkgeyBtYXhZID0geTsgfVxyXG5cdFx0aWYgKCh5ID0geF9iICsgeV9kICsgdHkpIDwgbWluWSkgeyBtaW5ZID0geTsgfSBlbHNlIGlmICh5ID4gbWF4WSkgeyBtYXhZID0geTsgfVxyXG5cdFx0aWYgKCh5ID0geV9kICsgdHkpIDwgbWluWSkgeyBtaW5ZID0geTsgfSBlbHNlIGlmICh5ID4gbWF4WSkgeyBtYXhZID0geTsgfVxyXG5cdFx0XHJcblx0XHRyZXR1cm4gYm91bmRzLnNldFZhbHVlcyhtaW5YLCBtaW5ZLCBtYXhYLW1pblgsIG1heFktbWluWSk7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3QgaGFzIGFueSBtb3VzZSBldmVudCBsaXN0ZW5lcnMgb3IgYSBjdXJzb3IuXHJcblx0ICogQG1ldGhvZCBfaXNNb3VzZU9wYXF1ZVxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqKi9cclxuXHRwLl9oYXNNb3VzZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBldnRzID0gRGlzcGxheU9iamVjdC5fTU9VU0VfRVZFTlRTO1xyXG5cdFx0Zm9yICh2YXIgaT0gMCwgbD1ldnRzLmxlbmd0aDsgaTxsOyBpKyspIHtcclxuXHRcdFx0aWYgKHRoaXMuaGFzRXZlbnRMaXN0ZW5lcihldnRzW2ldKSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuICEhdGhpcy5jdXJzb3I7XHJcblx0fTtcclxuXHJcblx0Y3JlYXRlanMuRGlzcGxheU9iamVjdCA9IGNyZWF0ZWpzLnByb21vdGUoRGlzcGxheU9iamVjdCwgXCJFdmVudERpc3BhdGNoZXJcIik7XHJcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBDb250YWluZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHRcclxuXHJcbi8vIGNvbnN0cnVjdG9yOlxyXG4vKipcclxuICogQSBDb250YWluZXIgaXMgYSBuZXN0YWJsZSBkaXNwbGF5IGxpc3QgdGhhdCBhbGxvd3MgeW91IHRvIHdvcmsgd2l0aCBjb21wb3VuZCBkaXNwbGF5IGVsZW1lbnRzLiBGb3IgIGV4YW1wbGUgeW91IGNvdWxkXHJcbiAqIGdyb3VwIGFybSwgbGVnLCB0b3JzbyBhbmQgaGVhZCB7eyNjcm9zc0xpbmsgXCJCaXRtYXBcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2VzIHRvZ2V0aGVyIGludG8gYSBQZXJzb24gQ29udGFpbmVyLCBhbmRcclxuICogdHJhbnNmb3JtIHRoZW0gYXMgYSBncm91cCwgd2hpbGUgc3RpbGwgYmVpbmcgYWJsZSB0byBtb3ZlIHRoZSBpbmRpdmlkdWFsIHBhcnRzIHJlbGF0aXZlIHRvIGVhY2ggb3RoZXIuIENoaWxkcmVuIG9mXHJcbiAqIGNvbnRhaW5lcnMgaGF2ZSB0aGVpciA8Y29kZT50cmFuc2Zvcm08L2NvZGU+IGFuZCA8Y29kZT5hbHBoYTwvY29kZT4gcHJvcGVydGllcyBjb25jYXRlbmF0ZWQgd2l0aCB0aGVpciBwYXJlbnRcclxuICogQ29udGFpbmVyLlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZSwgYSB7eyNjcm9zc0xpbmsgXCJTaGFwZVwifX17ey9jcm9zc0xpbmt9fSB3aXRoIHg9MTAwIGFuZCBhbHBoYT0wLjUsIHBsYWNlZCBpbiBhIENvbnRhaW5lciB3aXRoIDxjb2RlPng9NTA8L2NvZGU+XHJcbiAqIGFuZCA8Y29kZT5hbHBoYT0wLjc8L2NvZGU+IHdpbGwgYmUgcmVuZGVyZWQgdG8gdGhlIGNhbnZhcyBhdCA8Y29kZT54PTE1MDwvY29kZT4gYW5kIDxjb2RlPmFscGhhPTAuMzU8L2NvZGU+LlxyXG4gKiBDb250YWluZXJzIGhhdmUgc29tZSBvdmVyaGVhZCwgc28geW91IGdlbmVyYWxseSBzaG91bGRuJ3QgY3JlYXRlIGEgQ29udGFpbmVyIHRvIGhvbGQgYSBzaW5nbGUgY2hpbGQuXHJcbiAqXHJcbiAqIDxoND5FeGFtcGxlPC9oND5cclxuICpcclxuICogICAgICB2YXIgY29udGFpbmVyID0gbmV3IGNyZWF0ZWpzLkNvbnRhaW5lcigpO1xyXG4gKiAgICAgIGNvbnRhaW5lci5hZGRDaGlsZChiaXRtYXBJbnN0YW5jZSwgc2hhcGVJbnN0YW5jZSk7XHJcbiAqICAgICAgY29udGFpbmVyLnggPSAxMDA7XHJcbiAqXHJcbiAqIEBjbGFzcyBDb250YWluZXJcclxuICogQGV4dGVuZHMgRGlzcGxheU9iamVjdFxyXG4gKiBAY29uc3RydWN0b3JcclxuICoqL1xyXG5cdGZ1bmN0aW9uIENvbnRhaW5lcigpIHtcclxuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9jb25zdHJ1Y3RvcigpO1xyXG5cdFx0XHJcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBhcnJheSBvZiBjaGlsZHJlbiBpbiB0aGUgZGlzcGxheSBsaXN0LiBZb3Ugc2hvdWxkIHVzdWFsbHkgdXNlIHRoZSBjaGlsZCBtYW5hZ2VtZW50IG1ldGhvZHMgc3VjaCBhc1xyXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyL2FkZENoaWxkXCJ9fXt7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvcmVtb3ZlQ2hpbGRcIn19e3svY3Jvc3NMaW5rfX0sXHJcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvc3dhcENoaWxkcmVuXCJ9fXt7L2Nyb3NzTGlua319LCBldGMsIHJhdGhlciB0aGFuIGFjY2Vzc2luZyB0aGlzIGRpcmVjdGx5LCBidXQgaXQgaXNcclxuXHRcdCAqIGluY2x1ZGVkIGZvciBhZHZhbmNlZCB1c2VzLlxyXG5cdFx0ICogQHByb3BlcnR5IGNoaWxkcmVuXHJcblx0XHQgKiBAdHlwZSBBcnJheVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjaGlsZHJlbiBvZiB0aGlzIGNvbnRhaW5lciBhcmUgaW5kZXBlbmRlbnRseSBlbmFibGVkIGZvciBtb3VzZS9wb2ludGVyIGludGVyYWN0aW9uLlxyXG5cdFx0ICogSWYgZmFsc2UsIHRoZSBjaGlsZHJlbiB3aWxsIGJlIGFnZ3JlZ2F0ZWQgdW5kZXIgdGhlIGNvbnRhaW5lciAtIGZvciBleGFtcGxlLCBhIGNsaWNrIG9uIGEgY2hpbGQgc2hhcGUgd291bGRcclxuXHRcdCAqIHRyaWdnZXIgYSBjbGljayBldmVudCBvbiB0aGUgY29udGFpbmVyLlxyXG5cdFx0ICogQHByb3BlcnR5IG1vdXNlQ2hpbGRyZW5cclxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMubW91c2VDaGlsZHJlbiA9IHRydWU7XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogSWYgZmFsc2UsIHRoZSB0aWNrIHdpbGwgbm90IGJlIHByb3BhZ2F0ZWQgdG8gY2hpbGRyZW4gb2YgdGhpcyBDb250YWluZXIuIFRoaXMgY2FuIHByb3ZpZGUgc29tZSBwZXJmb3JtYW5jZSBiZW5lZml0cy5cclxuXHRcdCAqIEluIGFkZGl0aW9uIHRvIHByZXZlbnRpbmcgdGhlIFwidGlja1wiIGV2ZW50IGZyb20gYmVpbmcgZGlzcGF0Y2hlZCwgaXQgd2lsbCBhbHNvIHByZXZlbnQgdGljayByZWxhdGVkIHVwZGF0ZXNcclxuXHRcdCAqIG9uIHNvbWUgZGlzcGxheSBvYmplY3RzIChleC4gU3ByaXRlICYgTW92aWVDbGlwIGZyYW1lIGFkdmFuY2luZywgRE9NRWxlbWVudCB2aXNpYmlsaXR5IGhhbmRsaW5nKS5cclxuXHRcdCAqIEBwcm9wZXJ0eSB0aWNrQ2hpbGRyZW5cclxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMudGlja0NoaWxkcmVuID0gdHJ1ZTtcclxuXHR9XHJcblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQ29udGFpbmVyLCBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0KTtcclxuXHRcclxuXHRcclxuLy8gZ2V0dGVyIC8gc2V0dGVyczpcclxuXHQvKipcclxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lci9udW1DaGlsZHJlbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxyXG5cdCAqIEBtZXRob2QgZ2V0TnVtQ2hpbGRyZW5cclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcblx0ICogQGRlcHJlY2F0ZWRcclxuXHQgKiovXHJcblx0cC5nZXROdW1DaGlsZHJlbiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGUgY29udGFpbmVyLlxyXG5cdCAqIEBwcm9wZXJ0eSBudW1DaGlsZHJlblxyXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0ICogQHJlYWRvbmx5XHJcblx0ICoqL1xyXG5cdHRyeSB7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XHJcblx0XHRcdG51bUNoaWxkcmVuOiB7IGdldDogcC5nZXROdW1DaGlsZHJlbiB9XHJcblx0XHR9KTtcclxuXHR9IGNhdGNoIChlKSB7fVxyXG5cdFxyXG5cclxuLy8gcHVibGljIG1ldGhvZHM6XHJcblx0LyoqXHJcblx0ICogQ29uc3RydWN0b3IgYWxpYXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBUaGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zLlxyXG5cdCAqIFN1YmNsYXNzZXMgc2hvdWxkIGJlIHVwZGF0ZWQgdG8gdXNlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRzXCJ9fXt7L2Nyb3NzTGlua319LlxyXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxyXG5cdCAqIEBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBgY3JlYXRlanMucHJvbW90ZSgpYFxyXG5cdCAqKi9cclxuXHRwLmluaXRpYWxpemUgPSBDb250YWluZXI7IC8vIFRPRE86IGRlcHJlY2F0ZWQuXHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhcy5cclxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxyXG5cdCAqXHJcblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxyXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcclxuXHQgKiovXHJcblx0cC5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBoYXNDb250ZW50ID0gdGhpcy5jYWNoZUNhbnZhcyB8fCB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcclxuXHRcdHJldHVybiAhISh0aGlzLnZpc2libGUgJiYgdGhpcy5hbHBoYSA+IDAgJiYgdGhpcy5zY2FsZVggIT0gMCAmJiB0aGlzLnNjYWxlWSAhPSAwICYmIGhhc0NvbnRlbnQpO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cclxuXHQgKlxyXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cclxuXHQgKiBAbWV0aG9kIGRyYXdcclxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZUNhY2hlPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZHJhdyBvcGVyYXRpb24gc2hvdWxkIGlnbm9yZSBhbnkgY3VycmVudCBjYWNoZS5cclxuXHQgKiBGb3IgZXhhbXBsZSwgdXNlZCBmb3IgZHJhd2luZyB0aGUgY2FjaGUgKHRvIHByZXZlbnQgaXQgZnJvbSBzaW1wbHkgZHJhd2luZyBhbiBleGlzdGluZyBjYWNoZSBiYWNrXHJcblx0ICogaW50byBpdHNlbGYpLlxyXG5cdCAqKi9cclxuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGlnbm9yZUNhY2hlKSB7XHJcblx0XHRpZiAodGhpcy5EaXNwbGF5T2JqZWN0X2RyYXcoY3R4LCBpZ25vcmVDYWNoZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFxyXG5cdFx0Ly8gdGhpcyBlbnN1cmVzIHdlIGRvbid0IGhhdmUgaXNzdWVzIHdpdGggZGlzcGxheSBsaXN0IGNoYW5nZXMgdGhhdCBvY2N1ciBkdXJpbmcgYSBkcmF3OlxyXG5cdFx0dmFyIGxpc3QgPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XHJcblx0XHRmb3IgKHZhciBpPTAsbD1saXN0Lmxlbmd0aDsgaTxsOyBpKyspIHtcclxuXHRcdFx0dmFyIGNoaWxkID0gbGlzdFtpXTtcclxuXHRcdFx0aWYgKCFjaGlsZC5pc1Zpc2libGUoKSkgeyBjb250aW51ZTsgfVxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gZHJhdyB0aGUgY2hpbGQ6XHJcblx0XHRcdGN0eC5zYXZlKCk7XHJcblx0XHRcdGNoaWxkLnVwZGF0ZUNvbnRleHQoY3R4KTtcclxuXHRcdFx0Y2hpbGQuZHJhdyhjdHgpO1xyXG5cdFx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBBZGRzIGEgY2hpbGQgdG8gdGhlIHRvcCBvZiB0aGUgZGlzcGxheSBsaXN0LlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogXHRcdGNvbnRhaW5lci5hZGRDaGlsZChiaXRtYXBJbnN0YW5jZSk7XHJcblx0ICpcclxuXHQgKiBZb3UgY2FuIGFsc28gYWRkIG11bHRpcGxlIGNoaWxkcmVuIGF0IG9uY2U6XHJcblx0ICpcclxuXHQgKiBcdFx0Y29udGFpbmVyLmFkZENoaWxkKGJpdG1hcEluc3RhbmNlLCBzaGFwZUluc3RhbmNlLCB0ZXh0SW5zdGFuY2UpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBhZGRDaGlsZFxyXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gY2hpbGQgVGhlIGRpc3BsYXkgb2JqZWN0IHRvIGFkZC5cclxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgdGhhdCB3YXMgYWRkZWQsIG9yIHRoZSBsYXN0IGNoaWxkIGlmIG11bHRpcGxlIGNoaWxkcmVuIHdlcmUgYWRkZWQuXHJcblx0ICoqL1xyXG5cdHAuYWRkQ2hpbGQgPSBmdW5jdGlvbihjaGlsZCkge1xyXG5cdFx0aWYgKGNoaWxkID09IG51bGwpIHsgcmV0dXJuIGNoaWxkOyB9XHJcblx0XHR2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcblx0XHRpZiAobCA+IDEpIHtcclxuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykgeyB0aGlzLmFkZENoaWxkKGFyZ3VtZW50c1tpXSk7IH1cclxuXHRcdFx0cmV0dXJuIGFyZ3VtZW50c1tsLTFdO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNoaWxkLnBhcmVudCkgeyBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpOyB9XHJcblx0XHRjaGlsZC5wYXJlbnQgPSB0aGlzO1xyXG5cdFx0dGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuXHRcdGNoaWxkLmRpc3BhdGNoRXZlbnQoXCJhZGRlZFwiKTtcclxuXHRcdHJldHVybiBjaGlsZDtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBBZGRzIGEgY2hpbGQgdG8gdGhlIGRpc3BsYXkgbGlzdCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LCBidW1waW5nIGNoaWxkcmVuIGF0IGVxdWFsIG9yIGdyZWF0ZXIgaW5kZXhlcyB1cCBvbmUsIGFuZFxyXG5cdCAqIHNldHRpbmcgaXRzIHBhcmVudCB0byB0aGlzIENvbnRhaW5lci5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgYWRkQ2hpbGRBdChjaGlsZDEsIGluZGV4KTtcclxuXHQgKlxyXG5cdCAqIFlvdSBjYW4gYWxzbyBhZGQgbXVsdGlwbGUgY2hpbGRyZW4sIHN1Y2ggYXM6XHJcblx0ICpcclxuXHQgKiAgICAgIGFkZENoaWxkQXQoY2hpbGQxLCBjaGlsZDIsIC4uLiwgaW5kZXgpO1xyXG5cdCAqXHJcblx0ICogVGhlIGluZGV4IG11c3QgYmUgYmV0d2VlbiAwIGFuZCBudW1DaGlsZHJlbi4gRm9yIGV4YW1wbGUsIHRvIGFkZCBteVNoYXBlIHVuZGVyIG90aGVyU2hhcGUgaW4gdGhlIGRpc3BsYXkgbGlzdCxcclxuXHQgKiB5b3UgY291bGQgdXNlOlxyXG5cdCAqXHJcblx0ICogICAgICBjb250YWluZXIuYWRkQ2hpbGRBdChteVNoYXBlLCBjb250YWluZXIuZ2V0Q2hpbGRJbmRleChvdGhlclNoYXBlKSk7XHJcblx0ICpcclxuXHQgKiBUaGlzIHdvdWxkIGFsc28gYnVtcCBvdGhlclNoYXBlJ3MgaW5kZXggdXAgYnkgb25lLiBGYWlscyBzaWxlbnRseSBpZiB0aGUgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBhZGRDaGlsZEF0XHJcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBjaGlsZCBUaGUgZGlzcGxheSBvYmplY3QgdG8gYWRkLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gYWRkIHRoZSBjaGlsZCBhdC5cclxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBSZXR1cm5zIHRoZSBsYXN0IGNoaWxkIHRoYXQgd2FzIGFkZGVkLCBvciB0aGUgbGFzdCBjaGlsZCBpZiBtdWx0aXBsZSBjaGlsZHJlbiB3ZXJlIGFkZGVkLlxyXG5cdCAqKi9cclxuXHRwLmFkZENoaWxkQXQgPSBmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcclxuXHRcdHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcclxuXHRcdHZhciBpbmR4ID0gYXJndW1lbnRzW2wtMV07IC8vIGNhbid0IHVzZSB0aGUgc2FtZSBuYW1lIGFzIHRoZSBpbmRleCBwYXJhbSBvciBpdCByZXBsYWNlcyBhcmd1bWVudHNbMV1cclxuXHRcdGlmIChpbmR4IDwgMCB8fCBpbmR4ID4gdGhpcy5jaGlsZHJlbi5sZW5ndGgpIHsgcmV0dXJuIGFyZ3VtZW50c1tsLTJdOyB9XHJcblx0XHRpZiAobCA+IDIpIHtcclxuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGwtMTsgaSsrKSB7IHRoaXMuYWRkQ2hpbGRBdChhcmd1bWVudHNbaV0sIGluZHgraSk7IH1cclxuXHRcdFx0cmV0dXJuIGFyZ3VtZW50c1tsLTJdO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNoaWxkLnBhcmVudCkgeyBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpOyB9XHJcblx0XHRjaGlsZC5wYXJlbnQgPSB0aGlzO1xyXG5cdFx0dGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcclxuXHRcdGNoaWxkLmRpc3BhdGNoRXZlbnQoXCJhZGRlZFwiKTtcclxuXHRcdHJldHVybiBjaGlsZDtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgY2hpbGQgZnJvbSB0aGUgZGlzcGxheSBsaXN0LiBOb3RlIHRoYXQgaXQgaXMgZmFzdGVyIHRvIHVzZSByZW1vdmVDaGlsZEF0KCkgaWYgdGhlIGluZGV4IGlzXHJcblx0ICogYWxyZWFkeSBrbm93bi5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcclxuXHQgKlxyXG5cdCAqIFlvdSBjYW4gYWxzbyByZW1vdmUgbXVsdGlwbGUgY2hpbGRyZW46XHJcblx0ICpcclxuXHQgKiAgICAgIHJlbW92ZUNoaWxkKGNoaWxkMSwgY2hpbGQyLCAuLi4pO1xyXG5cdCAqXHJcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBjaGlsZCAob3IgY2hpbGRyZW4pIHdhcyByZW1vdmVkLCBvciBmYWxzZSBpZiBpdCB3YXMgbm90IGluIHRoZSBkaXNwbGF5IGxpc3QuXHJcblx0ICogQG1ldGhvZCByZW1vdmVDaGlsZFxyXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gY2hpbGQgVGhlIGNoaWxkIHRvIHJlbW92ZS5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBjaGlsZCAob3IgY2hpbGRyZW4pIHdhcyByZW1vdmVkLCBvciBmYWxzZSBpZiBpdCB3YXMgbm90IGluIHRoZSBkaXNwbGF5IGxpc3QuXHJcblx0ICoqL1xyXG5cdHAucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbihjaGlsZCkge1xyXG5cdFx0dmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xyXG5cdFx0aWYgKGwgPiAxKSB7XHJcblx0XHRcdHZhciBnb29kID0gdHJ1ZTtcclxuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykgeyBnb29kID0gZ29vZCAmJiB0aGlzLnJlbW92ZUNoaWxkKGFyZ3VtZW50c1tpXSk7IH1cclxuXHRcdFx0cmV0dXJuIGdvb2Q7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVDaGlsZEF0KGNyZWF0ZWpzLmluZGV4T2YodGhpcy5jaGlsZHJlbiwgY2hpbGQpKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIHRoZSBjaGlsZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IGZyb20gdGhlIGRpc3BsYXkgbGlzdCwgYW5kIHNldHMgaXRzIHBhcmVudCB0byBudWxsLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGRBdCgyKTtcclxuXHQgKlxyXG5cdCAqIFlvdSBjYW4gYWxzbyByZW1vdmUgbXVsdGlwbGUgY2hpbGRyZW46XHJcblx0ICpcclxuXHQgKiAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZCgyLCA3LCAuLi4pXHJcblx0ICpcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNoaWxkIChvciBjaGlsZHJlbikgd2FzIHJlbW92ZWQsIG9yIGZhbHNlIGlmIGFueSBpbmRleCB3YXMgb3V0IG9mIHJhbmdlLlxyXG5cdCAqIEBtZXRob2QgcmVtb3ZlQ2hpbGRBdFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGNoaWxkIHRvIHJlbW92ZS5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBjaGlsZCAob3IgY2hpbGRyZW4pIHdhcyByZW1vdmVkLCBvciBmYWxzZSBpZiBhbnkgaW5kZXggd2FzIG91dCBvZiByYW5nZS5cclxuXHQgKiovXHJcblx0cC5yZW1vdmVDaGlsZEF0ID0gZnVuY3Rpb24oaW5kZXgpIHtcclxuXHRcdHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcclxuXHRcdGlmIChsID4gMSkge1xyXG5cdFx0XHR2YXIgYSA9IFtdO1xyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7IGFbaV0gPSBhcmd1bWVudHNbaV07IH1cclxuXHRcdFx0YS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGItYTsgfSk7XHJcblx0XHRcdHZhciBnb29kID0gdHJ1ZTtcclxuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykgeyBnb29kID0gZ29vZCAmJiB0aGlzLnJlbW92ZUNoaWxkQXQoYVtpXSk7IH1cclxuXHRcdFx0cmV0dXJuIGdvb2Q7XHJcblx0XHR9XHJcblx0XHRpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGhpcy5jaGlsZHJlbi5sZW5ndGgtMSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baW5kZXhdO1xyXG5cdFx0aWYgKGNoaWxkKSB7IGNoaWxkLnBhcmVudCA9IG51bGw7IH1cclxuXHRcdHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcclxuXHRcdGNoaWxkLmRpc3BhdGNoRXZlbnQoXCJyZW1vdmVkXCIpO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyBhbGwgY2hpbGRyZW4gZnJvbSB0aGUgZGlzcGxheSBsaXN0LlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogXHRjb250YWluZXIucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgcmVtb3ZlQWxsQ2hpbGRyZW5cclxuXHQgKiovXHJcblx0cC5yZW1vdmVBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGtpZHMgPSB0aGlzLmNoaWxkcmVuO1xyXG5cdFx0d2hpbGUgKGtpZHMubGVuZ3RoKSB7IHRoaXMucmVtb3ZlQ2hpbGRBdCgwKTsgfVxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIGNoaWxkIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIGNvbnRhaW5lci5nZXRDaGlsZEF0KDIpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBnZXRDaGlsZEF0XHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgY2hpbGQgdG8gcmV0dXJuLlxyXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LiBSZXR1cm5zIG51bGwgaWYgdGhlcmUgaXMgbm8gY2hpbGQgYXQgdGhlIGluZGV4LlxyXG5cdCAqKi9cclxuXHRwLmdldENoaWxkQXQgPSBmdW5jdGlvbihpbmRleCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2hpbGRyZW5baW5kZXhdO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY2hpbGQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcblx0ICogQG1ldGhvZCBnZXRDaGlsZEJ5TmFtZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjaGlsZCB0byByZXR1cm4uXHJcblx0ICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG5cdCAqKi9cclxuXHRwLmdldENoaWxkQnlOYW1lID0gZnVuY3Rpb24obmFtZSkge1xyXG5cdFx0dmFyIGtpZHMgPSB0aGlzLmNoaWxkcmVuO1xyXG5cdFx0Zm9yICh2YXIgaT0wLGw9a2lkcy5sZW5ndGg7aTxsO2krKykge1xyXG5cdFx0XHRpZihraWRzW2ldLm5hbWUgPT0gbmFtZSkgeyByZXR1cm4ga2lkc1tpXTsgfVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUGVyZm9ybXMgYW4gYXJyYXkgc29ydCBvcGVyYXRpb24gb24gdGhlIGNoaWxkIGxpc3QuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTogRGlzcGxheSBjaGlsZHJlbiB3aXRoIGEgaGlnaGVyIHkgaW4gZnJvbnQuPC9oND5cclxuXHQgKiBcclxuXHQgKiAgICAgIHZhciBzb3J0RnVuY3Rpb24gPSBmdW5jdGlvbihvYmoxLCBvYmoyLCBvcHRpb25zKSB7XHJcblx0ICogICAgICAgICAgaWYgKG9iajEueSA+IG9iajIueSkgeyByZXR1cm4gMTsgfVxyXG5cdCAqICAgICAgICAgIGlmIChvYmoxLnkgPCBvYmoyLnkpIHsgcmV0dXJuIC0xOyB9XHJcblx0ICogICAgICAgICAgcmV0dXJuIDA7XHJcblx0ICogICAgICB9XHJcblx0ICogICAgICBjb250YWluZXIuc29ydENoaWxkcmVuKHNvcnRGdW5jdGlvbik7XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIHNvcnRDaGlsZHJlblxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHNvcnRGdW5jdGlvbiB0aGUgZnVuY3Rpb24gdG8gdXNlIHRvIHNvcnQgdGhlIGNoaWxkIGxpc3QuIFNlZSBKYXZhU2NyaXB0J3MgPGNvZGU+QXJyYXkuc29ydDwvY29kZT5cclxuXHQgKiBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLlxyXG5cdCAqKi9cclxuXHRwLnNvcnRDaGlsZHJlbiA9IGZ1bmN0aW9uKHNvcnRGdW5jdGlvbikge1xyXG5cdFx0dGhpcy5jaGlsZHJlbi5zb3J0KHNvcnRGdW5jdGlvbik7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIHNwZWNpZmllZCBjaGlsZCBpbiB0aGUgZGlzcGxheSBsaXN0LCBvciAtMSBpZiBpdCBpcyBub3QgaW4gdGhlIGRpc3BsYXkgbGlzdC5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgdmFyIGluZGV4ID0gY29udGFpbmVyLmdldENoaWxkSW5kZXgoY2hpbGQpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBnZXRDaGlsZEluZGV4XHJcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBjaGlsZCBUaGUgY2hpbGQgdG8gcmV0dXJuIHRoZSBpbmRleCBvZi5cclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgc3BlY2lmaWVkIGNoaWxkLiAtMSBpZiB0aGUgY2hpbGQgaXMgbm90IGZvdW5kLlxyXG5cdCAqKi9cclxuXHRwLmdldENoaWxkSW5kZXggPSBmdW5jdGlvbihjaGlsZCkge1xyXG5cdFx0cmV0dXJuIGNyZWF0ZWpzLmluZGV4T2YodGhpcy5jaGlsZHJlbiwgY2hpbGQpO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogU3dhcHMgdGhlIGNoaWxkcmVuIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlcy4gRmFpbHMgc2lsZW50bHkgaWYgZWl0aGVyIGluZGV4IGlzIG91dCBvZiByYW5nZS5cclxuXHQgKiBAbWV0aG9kIHN3YXBDaGlsZHJlbkF0XHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4MVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleDJcclxuXHQgKiovXHJcblx0cC5zd2FwQ2hpbGRyZW5BdCA9IGZ1bmN0aW9uKGluZGV4MSwgaW5kZXgyKSB7XHJcblx0XHR2YXIga2lkcyA9IHRoaXMuY2hpbGRyZW47XHJcblx0XHR2YXIgbzEgPSBraWRzW2luZGV4MV07XHJcblx0XHR2YXIgbzIgPSBraWRzW2luZGV4Ml07XHJcblx0XHRpZiAoIW8xIHx8ICFvMikgeyByZXR1cm47IH1cclxuXHRcdGtpZHNbaW5kZXgxXSA9IG8yO1xyXG5cdFx0a2lkc1tpbmRleDJdID0gbzE7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBTd2FwcyB0aGUgc3BlY2lmaWVkIGNoaWxkcmVuJ3MgZGVwdGggaW4gdGhlIGRpc3BsYXkgbGlzdC4gRmFpbHMgc2lsZW50bHkgaWYgZWl0aGVyIGNoaWxkIGlzIG5vdCBhIGNoaWxkIG9mIHRoaXNcclxuXHQgKiBDb250YWluZXIuXHJcblx0ICogQG1ldGhvZCBzd2FwQ2hpbGRyZW5cclxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IGNoaWxkMVxyXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gY2hpbGQyXHJcblx0ICoqL1xyXG5cdHAuc3dhcENoaWxkcmVuID0gZnVuY3Rpb24oY2hpbGQxLCBjaGlsZDIpIHtcclxuXHRcdHZhciBraWRzID0gdGhpcy5jaGlsZHJlbjtcclxuXHRcdHZhciBpbmRleDEsaW5kZXgyO1xyXG5cdFx0Zm9yICh2YXIgaT0wLGw9a2lkcy5sZW5ndGg7aTxsO2krKykge1xyXG5cdFx0XHRpZiAoa2lkc1tpXSA9PSBjaGlsZDEpIHsgaW5kZXgxID0gaTsgfVxyXG5cdFx0XHRpZiAoa2lkc1tpXSA9PSBjaGlsZDIpIHsgaW5kZXgyID0gaTsgfVxyXG5cdFx0XHRpZiAoaW5kZXgxICE9IG51bGwgJiYgaW5kZXgyICE9IG51bGwpIHsgYnJlYWs7IH1cclxuXHRcdH1cclxuXHRcdGlmIChpPT1sKSB7IHJldHVybjsgfSAvLyBUT0RPOiB0aHJvdyBlcnJvcj9cclxuXHRcdGtpZHNbaW5kZXgxXSA9IGNoaWxkMjtcclxuXHRcdGtpZHNbaW5kZXgyXSA9IGNoaWxkMTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIENoYW5nZXMgdGhlIGRlcHRoIG9mIHRoZSBzcGVjaWZpZWQgY2hpbGQuIEZhaWxzIHNpbGVudGx5IGlmIHRoZSBjaGlsZCBpcyBub3QgYSBjaGlsZCBvZiB0aGlzIGNvbnRhaW5lciwgb3IgdGhlIGluZGV4IGlzIG91dCBvZiByYW5nZS5cclxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IGNoaWxkXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4ICBcclxuXHQgKiBAbWV0aG9kIHNldENoaWxkSW5kZXhcclxuXHQgKiovXHJcblx0cC5zZXRDaGlsZEluZGV4ID0gZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XHJcblx0XHR2YXIga2lkcyA9IHRoaXMuY2hpbGRyZW4sIGw9a2lkcy5sZW5ndGg7XHJcblx0XHRpZiAoY2hpbGQucGFyZW50ICE9IHRoaXMgfHwgaW5kZXggPCAwIHx8IGluZGV4ID49IGwpIHsgcmV0dXJuOyB9XHJcblx0XHRmb3IgKHZhciBpPTA7aTxsO2krKykge1xyXG5cdFx0XHRpZiAoa2lkc1tpXSA9PSBjaGlsZCkgeyBicmVhazsgfVxyXG5cdFx0fVxyXG5cdFx0aWYgKGk9PWwgfHwgaSA9PSBpbmRleCkgeyByZXR1cm47IH1cclxuXHRcdGtpZHMuc3BsaWNlKGksMSk7XHJcblx0XHRraWRzLnNwbGljZShpbmRleCwwLGNoaWxkKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBkaXNwbGF5IG9iamVjdCBlaXRoZXIgaXMgdGhpcyBjb250YWluZXIgb3IgaXMgYSBkZXNjZW5kZW50IChjaGlsZCwgZ3JhbmRjaGlsZCwgZXRjKVxyXG5cdCAqIG9mIHRoaXMgY29udGFpbmVyLlxyXG5cdCAqIEBtZXRob2QgY29udGFpbnNcclxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IGNoaWxkIFRoZSBEaXNwbGF5T2JqZWN0IHRvIGJlIGNoZWNrZWQuXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGRpc3BsYXkgb2JqZWN0IGVpdGhlciBpcyB0aGlzIGNvbnRhaW5lciBvciBpcyBhIGRlc2NlbmRlbnQuXHJcblx0ICoqL1xyXG5cdHAuY29udGFpbnMgPSBmdW5jdGlvbihjaGlsZCkge1xyXG5cdFx0d2hpbGUgKGNoaWxkKSB7XHJcblx0XHRcdGlmIChjaGlsZCA9PSB0aGlzKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcdGNoaWxkID0gY2hpbGQucGFyZW50O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRlc3RzIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IGludGVyc2VjdHMgdGhlIHNwZWNpZmllZCBsb2NhbCBwb2ludCAoaWUuIGRyYXdzIGEgcGl4ZWwgd2l0aCBhbHBoYSA+IDAgYXQgdGhlXHJcblx0ICogc3BlY2lmaWVkIHBvc2l0aW9uKS4gVGhpcyBpZ25vcmVzIHRoZSBhbHBoYSwgc2hhZG93IGFuZCBjb21wb3NpdGVPcGVyYXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0LCBhbmQgYWxsXHJcblx0ICogdHJhbnNmb3JtIHByb3BlcnRpZXMgaW5jbHVkaW5nIHJlZ1gvWS5cclxuXHQgKiBAbWV0aG9kIGhpdFRlc3RcclxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvbiB0byBjaGVjayBpbiB0aGUgZGlzcGxheSBvYmplY3QncyBsb2NhbCBjb29yZGluYXRlcy5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiB0byBjaGVjayBpbiB0aGUgZGlzcGxheSBvYmplY3QncyBsb2NhbCBjb29yZGluYXRlcy5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZXJlIGlzIGEgdmlzaWJsZSBzZWN0aW9uIG9mIGEgRGlzcGxheU9iamVjdCB0aGF0IG92ZXJsYXBzIHRoZSBzcGVjaWZpZWRcclxuXHQgKiBjb29yZGluYXRlcy5cclxuXHQgKiovXHJcblx0cC5oaXRUZXN0ID0gZnVuY3Rpb24oeCwgeSkge1xyXG5cdFx0Ly8gVE9ETzogb3B0aW1pemUgdG8gdXNlIHRoZSBmYXN0IGNhY2hlIGNoZWNrIHdoZXJlIHBvc3NpYmxlLlxyXG5cdFx0cmV0dXJuICh0aGlzLmdldE9iamVjdFVuZGVyUG9pbnQoeCwgeSkgIT0gbnVsbCk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgZGlzcGxheSBvYmplY3RzIHVuZGVyIHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZXMgdGhhdCBhcmUgaW4gdGhpcyBjb250YWluZXIncyBkaXNwbGF5XHJcblx0ICogbGlzdC4gVGhpcyByb3V0aW5lIGlnbm9yZXMgYW55IGRpc3BsYXkgb2JqZWN0cyB3aXRoIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2VFbmFibGVkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XHJcblx0ICogc2V0IHRvIGBmYWxzZWAuIFRoZSBhcnJheSB3aWxsIGJlIHNvcnRlZCBpbiBvcmRlciBvZiB2aXN1YWwgZGVwdGgsIHdpdGggdGhlIHRvcC1tb3N0IGRpc3BsYXkgb2JqZWN0IGF0IGluZGV4IDAuXHJcblx0ICogVGhpcyB1c2VzIHNoYXBlIGJhc2VkIGhpdCBkZXRlY3Rpb24sIGFuZCBjYW4gYmUgYW4gZXhwZW5zaXZlIG9wZXJhdGlvbiB0byBydW4sIHNvIGl0IGlzIGJlc3QgdG8gdXNlIGl0IGNhcmVmdWxseS5cclxuXHQgKiBGb3IgZXhhbXBsZSwgaWYgdGVzdGluZyBmb3Igb2JqZWN0cyB1bmRlciB0aGUgbW91c2UsIHRlc3Qgb24gdGljayAoaW5zdGVhZCBvZiBvbiB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlbW92ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fSksXHJcblx0ICogYW5kIG9ubHkgaWYgdGhlIG1vdXNlJ3MgcG9zaXRpb24gaGFzIGNoYW5nZWQuXHJcblx0ICogXHJcblx0ICogPHVsPlxyXG5cdCAqICAgICA8bGk+QnkgZGVmYXVsdCAobW9kZT0wKSB0aGlzIG1ldGhvZCBldmFsdWF0ZXMgYWxsIGRpc3BsYXkgb2JqZWN0cy48L2xpPlxyXG5cdCAqICAgICA8bGk+Qnkgc2V0dGluZyB0aGUgYG1vZGVgIHBhcmFtZXRlciB0byBgMWAsIHRoZSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlRW5hYmxlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIFx0XHRhbmQge3sjY3Jvc3NMaW5rIFwibW91c2VDaGlsZHJlbjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0aWVzIHdpbGwgYmUgcmVzcGVjdGVkLjwvbGk+XHJcblx0ICogXHQgICA8bGk+U2V0dGluZyB0aGUgYG1vZGVgIHRvIGAyYCBhZGRpdGlvbmFsbHkgZXhjbHVkZXMgZGlzcGxheSBvYmplY3RzIHRoYXQgZG8gbm90IGhhdmUgYWN0aXZlIG1vdXNlIGV2ZW50XHJcblx0ICogXHQgICBcdGxpc3RlbmVycyBvciBhIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3Q6Y3Vyc29yOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5LiBUaGF0IGlzLCBvbmx5IG9iamVjdHNcclxuXHQgKiBcdCAgIFx0dGhhdCB3b3VsZCBub3JtYWxseSBpbnRlcmNlcHQgbW91c2UgaW50ZXJhY3Rpb24gd2lsbCBiZSBpbmNsdWRlZC4gVGhpcyBjYW4gc2lnbmlmaWNhbnRseSBpbXByb3ZlIHBlcmZvcm1hbmNlXHJcblx0ICogXHQgICBcdGluIHNvbWUgY2FzZXMgYnkgcmVkdWNpbmcgdGhlIG51bWJlciBvZiBkaXNwbGF5IG9iamVjdHMgdGhhdCBuZWVkIHRvIGJlIHRlc3RlZC48L2xpPlxyXG5cdCAqIDwvbGk+XHJcblx0ICogXHJcblx0ICogVGhpcyBtZXRob2QgYWNjb3VudHMgZm9yIGJvdGgge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9oaXRBcmVhOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21hc2s6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXHJcblx0ICogQG1ldGhvZCBnZXRPYmplY3RzVW5kZXJQb2ludFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIGluIHRoZSBjb250YWluZXIgdG8gdGVzdC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiBpbiB0aGUgY29udGFpbmVyIHRvIHRlc3QuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttb2RlPTBdIFRoZSBtb2RlIHRvIHVzZSB0byBkZXRlcm1pbmUgd2hpY2ggZGlzcGxheSBvYmplY3RzIHRvIGluY2x1ZGUuIDAtYWxsLCAxLXJlc3BlY3QgbW91c2VFbmFibGVkL21vdXNlQ2hpbGRyZW4sIDItb25seSBtb3VzZSBvcGFxdWUgb2JqZWN0cy5cclxuXHQgKiBAcmV0dXJuIHtBcnJheX0gQW4gQXJyYXkgb2YgRGlzcGxheU9iamVjdHMgdW5kZXIgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlcy5cclxuXHQgKiovXHJcblx0cC5nZXRPYmplY3RzVW5kZXJQb2ludCA9IGZ1bmN0aW9uKHgsIHksIG1vZGUpIHtcclxuXHRcdHZhciBhcnIgPSBbXTtcclxuXHRcdHZhciBwdCA9IHRoaXMubG9jYWxUb0dsb2JhbCh4LCB5KTtcclxuXHRcdHRoaXMuX2dldE9iamVjdHNVbmRlclBvaW50KHB0LngsIHB0LnksIGFyciwgbW9kZT4wLCBtb2RlPT0xKTtcclxuXHRcdHJldHVybiBhcnI7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogU2ltaWxhciB0byB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvZ2V0T2JqZWN0c1VuZGVyUG9pbnRcIn19e3svY3Jvc3NMaW5rfX0sIGJ1dCByZXR1cm5zIG9ubHkgdGhlIHRvcC1tb3N0IGRpc3BsYXlcclxuXHQgKiBvYmplY3QuIFRoaXMgcnVucyBzaWduaWZpY2FudGx5IGZhc3RlciB0aGFuIDxjb2RlPmdldE9iamVjdHNVbmRlclBvaW50KCk8L2NvZGU+LCBidXQgaXMgc3RpbGwgcG90ZW50aWFsbHkgYW4gZXhwZW5zaXZlXHJcblx0ICogb3BlcmF0aW9uLiBTZWUge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyL2dldE9iamVjdHNVbmRlclBvaW50XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG5cdCAqIEBtZXRob2QgZ2V0T2JqZWN0VW5kZXJQb2ludFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIGluIHRoZSBjb250YWluZXIgdG8gdGVzdC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiBpbiB0aGUgY29udGFpbmVyIHRvIHRlc3QuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1vZGUgVGhlIG1vZGUgdG8gdXNlIHRvIGRldGVybWluZSB3aGljaCBkaXNwbGF5IG9iamVjdHMgdG8gaW5jbHVkZS4gIDAtYWxsLCAxLXJlc3BlY3QgbW91c2VFbmFibGVkL21vdXNlQ2hpbGRyZW4sIDItb25seSBtb3VzZSBvcGFxdWUgb2JqZWN0cy5cclxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBUaGUgdG9wLW1vc3QgZGlzcGxheSBvYmplY3QgdW5kZXIgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlcy5cclxuXHQgKiovXHJcblx0cC5nZXRPYmplY3RVbmRlclBvaW50ID0gZnVuY3Rpb24oeCwgeSwgbW9kZSkge1xyXG5cdFx0dmFyIHB0ID0gdGhpcy5sb2NhbFRvR2xvYmFsKHgsIHkpO1xyXG5cdFx0cmV0dXJuIHRoaXMuX2dldE9iamVjdHNVbmRlclBvaW50KHB0LngsIHB0LnksIG51bGwsIG1vZGU+MCwgbW9kZT09MSk7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBEb2NjZWQgaW4gc3VwZXJjbGFzcy5cclxuXHQgKi9cclxuXHRwLmdldEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2dldEJvdW5kcyhudWxsLCB0cnVlKTtcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIERvY2NlZCBpbiBzdXBlcmNsYXNzLlxyXG5cdCAqL1xyXG5cdHAuZ2V0VHJhbnNmb3JtZWRCb3VuZHMgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLl9nZXRCb3VuZHMoKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBDb250YWluZXIuIFNvbWUgcHJvcGVydGllcyB0aGF0IGFyZSBzcGVjaWZpYyB0byB0aGlzIGluc3RhbmNlJ3MgY3VycmVudCBjb250ZXh0IGFyZVxyXG5cdCAqIHJldmVydGVkIHRvIHRoZWlyIGRlZmF1bHRzIChmb3IgZXhhbXBsZSAucGFyZW50KS5cclxuXHQgKiBAbWV0aG9kIGNsb25lXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbcmVjdXJzaXZlPWZhbHNlXSBJZiB0cnVlLCBhbGwgb2YgdGhlIGRlc2NlbmRhbnRzIG9mIHRoaXMgY29udGFpbmVyIHdpbGwgYmUgY2xvbmVkIHJlY3Vyc2l2ZWx5LiBJZiBmYWxzZSwgdGhlXHJcblx0ICogcHJvcGVydGllcyBvZiB0aGUgY29udGFpbmVyIHdpbGwgYmUgY2xvbmVkLCBidXQgdGhlIG5ldyBpbnN0YW5jZSB3aWxsIG5vdCBoYXZlIGFueSBjaGlsZHJlbi5cclxuXHQgKiBAcmV0dXJuIHtDb250YWluZXJ9IEEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgQ29udGFpbmVyIGluc3RhbmNlLlxyXG5cdCAqKi9cclxuXHRwLmNsb25lID0gZnVuY3Rpb24ocmVjdXJzaXZlKSB7XHJcblx0XHR2YXIgbyA9IHRoaXMuX2Nsb25lUHJvcHMobmV3IENvbnRhaW5lcigpKTtcclxuXHRcdGlmIChyZWN1cnNpdmUpIHsgdGhpcy5fY2xvbmVDaGlsZHJlbihvKTsgfVxyXG5cdFx0cmV0dXJuIG87XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cclxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXHJcblx0ICoqL1xyXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBcIltDb250YWluZXIgKG5hbWU9XCIrICB0aGlzLm5hbWUgK1wiKV1cIjtcclxuXHR9O1xyXG5cclxuXHJcbi8vIHByaXZhdGUgbWV0aG9kczpcclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIF90aWNrXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2dE9iaiBBbiBldmVudCBvYmplY3QgdGhhdCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gYWxsIHRpY2sgbGlzdGVuZXJzLiBUaGlzIG9iamVjdCBpcyByZXVzZWQgYmV0d2VlbiBkaXNwYXRjaGVycyB0byByZWR1Y2UgY29uc3RydWN0aW9uICYgR0MgY29zdHMuXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqKi9cclxuXHRwLl90aWNrID0gZnVuY3Rpb24oZXZ0T2JqKSB7XHJcblx0XHRpZiAodGhpcy50aWNrQ2hpbGRyZW4pIHtcclxuXHRcdFx0Zm9yICh2YXIgaT10aGlzLmNoaWxkcmVuLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcclxuXHRcdFx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xyXG5cdFx0XHRcdGlmIChjaGlsZC50aWNrRW5hYmxlZCAmJiBjaGlsZC5fdGljaykgeyBjaGlsZC5fdGljayhldnRPYmopOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9fdGljayhldnRPYmopO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmVjdXJzaXZlbHkgY2xvbmVzIGFsbCBjaGlsZHJlbiBvZiB0aGlzIGNvbnRhaW5lciwgYW5kIGFkZHMgdGhlbSB0byB0aGUgdGFyZ2V0IGNvbnRhaW5lci5cclxuXHQgKiBAbWV0aG9kIGNsb25lQ2hpbGRyZW5cclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICogQHBhcmFtIHtDb250YWluZXJ9IG8gVGhlIHRhcmdldCBjb250YWluZXIuXHJcblx0ICoqL1xyXG5cdHAuX2Nsb25lQ2hpbGRyZW4gPSBmdW5jdGlvbihvKSB7XHJcblx0XHRpZiAoby5jaGlsZHJlbi5sZW5ndGgpIHsgby5yZW1vdmVBbGxDaGlsZHJlbigpOyB9XHJcblx0XHR2YXIgYXJyID0gby5jaGlsZHJlbjtcclxuXHRcdGZvciAodmFyIGk9MCwgbD10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxsOyBpKyspIHtcclxuXHRcdFx0dmFyIGNsb25lID0gdGhpcy5jaGlsZHJlbltpXS5jbG9uZSh0cnVlKTtcclxuXHRcdFx0Y2xvbmUucGFyZW50ID0gbztcclxuXHRcdFx0YXJyLnB1c2goY2xvbmUpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBtZXRob2QgX2dldE9iamVjdHNVbmRlclBvaW50XHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFyclxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gbW91c2UgSWYgdHJ1ZSwgaXQgd2lsbCByZXNwZWN0IG1vdXNlIGludGVyYWN0aW9uIHByb3BlcnRpZXMgbGlrZSBtb3VzZUVuYWJsZWQsIG1vdXNlQ2hpbGRyZW4sIGFuZCBhY3RpdmUgbGlzdGVuZXJzLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYWN0aXZlTGlzdGVuZXIgSWYgdHJ1ZSwgdGhlcmUgaXMgYW4gYWN0aXZlIG1vdXNlIGV2ZW50IGxpc3RlbmVyIG9uIGEgcGFyZW50IG9iamVjdC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3VycmVudERlcHRoIEluZGljYXRlcyB0aGUgY3VycmVudCBkZXB0aCBvZiB0aGUgc2VhcmNoLlxyXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9XHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqKi9cclxuXHRwLl9nZXRPYmplY3RzVW5kZXJQb2ludCA9IGZ1bmN0aW9uKHgsIHksIGFyciwgbW91c2UsIGFjdGl2ZUxpc3RlbmVyLCBjdXJyZW50RGVwdGgpIHtcclxuXHRcdGN1cnJlbnREZXB0aCA9IGN1cnJlbnREZXB0aCB8fCAwO1xyXG5cdFx0aWYgKCFjdXJyZW50RGVwdGggJiYgIXRoaXMuX3Rlc3RNYXNrKHRoaXMsIHgsIHkpKSB7IHJldHVybiBudWxsOyB9XHJcblx0XHR2YXIgbXR4LCBjdHggPSBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0Ll9oaXRUZXN0Q29udGV4dDtcclxuXHRcdGFjdGl2ZUxpc3RlbmVyID0gYWN0aXZlTGlzdGVuZXIgfHwgKG1vdXNlJiZ0aGlzLl9oYXNNb3VzZUV2ZW50TGlzdGVuZXIoKSk7XHJcblxyXG5cdFx0Ly8gZHJhdyBjaGlsZHJlbiBvbmUgYXQgYSB0aW1lLCBhbmQgY2hlY2sgaWYgd2UgZ2V0IGEgaGl0OlxyXG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiwgbCA9IGNoaWxkcmVuLmxlbmd0aDtcclxuXHRcdGZvciAodmFyIGk9bC0xOyBpPj0wOyBpLS0pIHtcclxuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV07XHJcblx0XHRcdHZhciBoaXRBcmVhID0gY2hpbGQuaGl0QXJlYTtcclxuXHRcdFx0aWYgKCFjaGlsZC52aXNpYmxlIHx8ICghaGl0QXJlYSAmJiAhY2hpbGQuaXNWaXNpYmxlKCkpIHx8IChtb3VzZSAmJiAhY2hpbGQubW91c2VFbmFibGVkKSkgeyBjb250aW51ZTsgfVxyXG5cdFx0XHRpZiAoIWhpdEFyZWEgJiYgIXRoaXMuX3Rlc3RNYXNrKGNoaWxkLCB4LCB5KSkgeyBjb250aW51ZTsgfVxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gaWYgYSBjaGlsZCBjb250YWluZXIgaGFzIGEgaGl0QXJlYSB0aGVuIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpdHMgaGl0QXJlYSwgc28gd2UgY2FuIHRyZWF0IGl0IGFzIGEgbm9ybWFsIERPOlxyXG5cdFx0XHRpZiAoIWhpdEFyZWEgJiYgY2hpbGQgaW5zdGFuY2VvZiBDb250YWluZXIpIHtcclxuXHRcdFx0XHR2YXIgcmVzdWx0ID0gY2hpbGQuX2dldE9iamVjdHNVbmRlclBvaW50KHgsIHksIGFyciwgbW91c2UsIGFjdGl2ZUxpc3RlbmVyLCBjdXJyZW50RGVwdGgrMSk7XHJcblx0XHRcdFx0aWYgKCFhcnIgJiYgcmVzdWx0KSB7IHJldHVybiAobW91c2UgJiYgIXRoaXMubW91c2VDaGlsZHJlbikgPyB0aGlzIDogcmVzdWx0OyB9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKG1vdXNlICYmICFhY3RpdmVMaXN0ZW5lciAmJiAhY2hpbGQuX2hhc01vdXNlRXZlbnRMaXN0ZW5lcigpKSB7IGNvbnRpbnVlOyB9XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gVE9ETzogY2FuIHdlIHBhc3MgZGlzcGxheVByb3BzIGZvcndhcmQsIHRvIGF2b2lkIGhhdmluZyB0byBjYWxjdWxhdGUgdGhpcyBiYWNrd2FyZHMgZXZlcnkgdGltZT8gSXQncyBraW5kIG9mIGEgbWl4ZWQgYmFnLiBXaGVuIHdlJ3JlIG9ubHkgaHVudGluZyBmb3IgRE9zIHdpdGggZXZlbnQgbGlzdGVuZXJzLCBpdCBtYXkgbm90IG1ha2Ugc2Vuc2UuXHJcblx0XHRcdFx0dmFyIHByb3BzID0gY2hpbGQuZ2V0Q29uY2F0ZW5hdGVkRGlzcGxheVByb3BzKGNoaWxkLl9wcm9wcyk7XHJcblx0XHRcdFx0bXR4ID0gcHJvcHMubWF0cml4O1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGlmIChoaXRBcmVhKSB7XHJcblx0XHRcdFx0XHRtdHguYXBwZW5kTWF0cml4KGhpdEFyZWEuZ2V0TWF0cml4KGhpdEFyZWEuX3Byb3BzLm1hdHJpeCkpO1xyXG5cdFx0XHRcdFx0cHJvcHMuYWxwaGEgPSBoaXRBcmVhLmFscGhhO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRcclxuXHRcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBwcm9wcy5hbHBoYTtcclxuXHRcdFx0XHRjdHguc2V0VHJhbnNmb3JtKG10eC5hLCAgbXR4LmIsIG10eC5jLCBtdHguZCwgbXR4LnR4LXgsIG10eC50eS15KTtcclxuXHRcdFx0XHQoaGl0QXJlYXx8Y2hpbGQpLmRyYXcoY3R4KTtcclxuXHRcdFx0XHRpZiAoIXRoaXMuX3Rlc3RIaXQoY3R4KSkgeyBjb250aW51ZTsgfVxyXG5cdFx0XHRcdGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XHJcblx0XHRcdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCAyLCAyKTtcclxuXHRcdFx0XHRpZiAoYXJyKSB7IGFyci5wdXNoKGNoaWxkKTsgfVxyXG5cdFx0XHRcdGVsc2UgeyByZXR1cm4gKG1vdXNlICYmICF0aGlzLm1vdXNlQ2hpbGRyZW4pID8gdGhpcyA6IGNoaWxkOyB9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogQG1ldGhvZCBfdGVzdE1hc2tcclxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IHRhcmdldFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgeC95IGlzIHdpdGhpbiB0aGUgbWFza2VkIHJlZ2lvbi5cclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICoqL1xyXG5cdHAuX3Rlc3RNYXNrID0gZnVuY3Rpb24odGFyZ2V0LCB4LCB5KSB7XHJcblx0XHR2YXIgbWFzayA9IHRhcmdldC5tYXNrO1xyXG5cdFx0aWYgKCFtYXNrIHx8ICFtYXNrLmdyYXBoaWNzIHx8IG1hc2suZ3JhcGhpY3MuaXNFbXB0eSgpKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcclxuXHRcdHZhciBtdHggPSB0aGlzLl9wcm9wcy5tYXRyaXgsIHBhcmVudCA9IHRhcmdldC5wYXJlbnQ7XHJcblx0XHRtdHggPSBwYXJlbnQgPyBwYXJlbnQuZ2V0Q29uY2F0ZW5hdGVkTWF0cml4KG10eCkgOiBtdHguaWRlbnRpdHkoKTtcclxuXHRcdG10eCA9IG1hc2suZ2V0TWF0cml4KG1hc2suX3Byb3BzLm1hdHJpeCkucHJlcGVuZE1hdHJpeChtdHgpO1xyXG5cdFx0XHJcblx0XHR2YXIgY3R4ID0gY3JlYXRlanMuRGlzcGxheU9iamVjdC5faGl0VGVzdENvbnRleHQ7XHJcblx0XHRjdHguc2V0VHJhbnNmb3JtKG10eC5hLCAgbXR4LmIsIG10eC5jLCBtdHguZCwgbXR4LnR4LXgsIG10eC50eS15KTtcclxuXHRcdFxyXG5cdFx0Ly8gZHJhdyB0aGUgbWFzayBhcyBhIHNvbGlkIGZpbGw6XHJcblx0XHRtYXNrLmdyYXBoaWNzLmRyYXdBc1BhdGgoY3R4KTtcclxuXHRcdGN0eC5maWxsU3R5bGUgPSBcIiMwMDBcIjtcclxuXHRcdGN0eC5maWxsKCk7XHJcblx0XHRcclxuXHRcdGlmICghdGhpcy5fdGVzdEhpdChjdHgpKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0Y3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcclxuXHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgMiwgMik7XHJcblx0XHRcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogQG1ldGhvZCBfZ2V0Qm91bmRzXHJcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4XHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVUcmFuc2Zvcm0gSWYgdHJ1ZSwgZG9lcyBub3QgYXBwbHkgdGhpcyBvYmplY3QncyB0cmFuc2Zvcm0uXHJcblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfVxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiovXHJcblx0cC5fZ2V0Qm91bmRzID0gZnVuY3Rpb24obWF0cml4LCBpZ25vcmVUcmFuc2Zvcm0pIHtcclxuXHRcdHZhciBib3VuZHMgPSB0aGlzLkRpc3BsYXlPYmplY3RfZ2V0Qm91bmRzKCk7XHJcblx0XHRpZiAoYm91bmRzKSB7IHJldHVybiB0aGlzLl90cmFuc2Zvcm1Cb3VuZHMoYm91bmRzLCBtYXRyaXgsIGlnbm9yZVRyYW5zZm9ybSk7IH1cclxuXHRcdFxyXG5cdFx0dmFyIG10eCA9IHRoaXMuX3Byb3BzLm1hdHJpeDtcclxuXHRcdG10eCA9IGlnbm9yZVRyYW5zZm9ybSA/IG10eC5pZGVudGl0eSgpIDogdGhpcy5nZXRNYXRyaXgobXR4KTtcclxuXHRcdGlmIChtYXRyaXgpIHsgbXR4LnByZXBlbmRNYXRyaXgobWF0cml4KTsgfVxyXG5cdFx0XHJcblx0XHR2YXIgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoLCByZWN0PW51bGw7XHJcblx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7XHJcblx0XHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XHJcblx0XHRcdGlmICghY2hpbGQudmlzaWJsZSB8fCAhKGJvdW5kcyA9IGNoaWxkLl9nZXRCb3VuZHMobXR4KSkpIHsgY29udGludWU7IH1cclxuXHRcdFx0aWYgKHJlY3QpIHsgcmVjdC5leHRlbmQoYm91bmRzLngsIGJvdW5kcy55LCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpOyB9XHJcblx0XHRcdGVsc2UgeyByZWN0ID0gYm91bmRzLmNsb25lKCk7IH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZWN0O1xyXG5cdH07XHJcblxyXG5cclxuXHRjcmVhdGVqcy5Db250YWluZXIgPSBjcmVhdGVqcy5wcm9tb3RlKENvbnRhaW5lciwgXCJEaXNwbGF5T2JqZWN0XCIpO1xyXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU3RhZ2UuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEEgc3RhZ2UgaXMgdGhlIHJvb3QgbGV2ZWwge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhIGRpc3BsYXkgbGlzdC4gRWFjaCB0aW1lIGl0cyB7eyNjcm9zc0xpbmsgXCJTdGFnZS90aWNrXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZCBpcyBjYWxsZWQsIGl0IHdpbGwgcmVuZGVyIGl0cyBkaXNwbGF5IGxpc3QgdG8gaXRzIHRhcmdldCBjYW52YXMuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogVGhpcyBleGFtcGxlIGNyZWF0ZXMgYSBzdGFnZSwgYWRkcyBhIGNoaWxkIHRvIGl0LCB0aGVuIHVzZXMge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319IHRvIHVwZGF0ZSB0aGUgY2hpbGRcblx0ICogYW5kIHJlZHJhdyB0aGUgc3RhZ2UgdXNpbmcge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdXBkYXRlXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiAgICAgIHZhciBzdGFnZSA9IG5ldyBjcmVhdGVqcy5TdGFnZShcImNhbnZhc0VsZW1lbnRJZFwiKTtcblx0ICogICAgICB2YXIgaW1hZ2UgPSBuZXcgY3JlYXRlanMuQml0bWFwKFwiaW1hZ2VQYXRoLnBuZ1wiKTtcblx0ICogICAgICBzdGFnZS5hZGRDaGlsZChpbWFnZSk7XG5cdCAqICAgICAgY3JlYXRlanMuVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIGhhbmRsZVRpY2spO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZVRpY2soZXZlbnQpIHtcblx0ICogICAgICAgICAgaW1hZ2UueCArPSAxMDtcblx0ICogICAgICAgICAgc3RhZ2UudXBkYXRlKCk7XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBAY2xhc3MgU3RhZ2Vcblx0ICogQGV4dGVuZHMgQ29udGFpbmVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50IHwgU3RyaW5nIHwgT2JqZWN0fSBjYW52YXMgQSBjYW52YXMgb2JqZWN0IHRoYXQgdGhlIFN0YWdlIHdpbGwgcmVuZGVyIHRvLCBvciB0aGUgc3RyaW5nIGlkXG5cdCAqIG9mIGEgY2FudmFzIG9iamVjdCBpbiB0aGUgY3VycmVudCBkb2N1bWVudC5cblx0ICoqL1xuXHRmdW5jdGlvbiBTdGFnZShjYW52YXMpIHtcblx0XHR0aGlzLkNvbnRhaW5lcl9jb25zdHJ1Y3RvcigpO1xuXHRcblx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdGFnZSBzaG91bGQgYXV0b21hdGljYWxseSBjbGVhciB0aGUgY2FudmFzIGJlZm9yZSBlYWNoIHJlbmRlci4gWW91IGNhbiBzZXQgdGhpcyB0byA8Y29kZT5mYWxzZTwvY29kZT5cblx0XHQgKiB0byBtYW51YWxseSBjb250cm9sIGNsZWFyaW5nIChmb3IgZ2VuZXJhdGl2ZSBhcnQsIG9yIHdoZW4gcG9pbnRpbmcgbXVsdGlwbGUgc3RhZ2VzIGF0IHRoZSBzYW1lIGNhbnZhcyBmb3Jcblx0XHQgKiBleGFtcGxlKS5cblx0XHQgKlxuXHRcdCAqIDxoND5FeGFtcGxlPC9oND5cblx0XHQgKlxuXHRcdCAqICAgICAgdmFyIHN0YWdlID0gbmV3IGNyZWF0ZWpzLlN0YWdlKFwiY2FudmFzSWRcIik7XG5cdFx0ICogICAgICBzdGFnZS5hdXRvQ2xlYXIgPSBmYWxzZTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBhdXRvQ2xlYXJcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqKi9cblx0XHR0aGlzLmF1dG9DbGVhciA9IHRydWU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjYW52YXMgdGhlIHN0YWdlIHdpbGwgcmVuZGVyIHRvLiBNdWx0aXBsZSBzdGFnZXMgY2FuIHNoYXJlIGEgc2luZ2xlIGNhbnZhcywgYnV0IHlvdSBtdXN0IGRpc2FibGUgYXV0b0NsZWFyIGZvciBhbGwgYnV0IHRoZVxuXHRcdCAqIGZpcnN0IHN0YWdlIHRoYXQgd2lsbCBiZSB0aWNrZWQgKG9yIHRoZXkgd2lsbCBjbGVhciBlYWNoIG90aGVyJ3MgcmVuZGVyKS5cblx0XHQgKlxuXHRcdCAqIFdoZW4gY2hhbmdpbmcgdGhlIGNhbnZhcyBwcm9wZXJ0eSB5b3UgbXVzdCBkaXNhYmxlIHRoZSBldmVudHMgb24gdGhlIG9sZCBjYW52YXMsIGFuZCBlbmFibGUgZXZlbnRzIG9uIHRoZVxuXHRcdCAqIG5ldyBjYW52YXMgb3IgbW91c2UgZXZlbnRzIHdpbGwgbm90IHdvcmsgYXMgZXhwZWN0ZWQuIEZvciBleGFtcGxlOlxuXHRcdCAqXG5cdFx0ICogICAgICBteVN0YWdlLmVuYWJsZURPTUV2ZW50cyhmYWxzZSk7XG5cdFx0ICogICAgICBteVN0YWdlLmNhbnZhcyA9IGFub3RoZXJDYW52YXM7XG5cdFx0ICogICAgICBteVN0YWdlLmVuYWJsZURPTUV2ZW50cyh0cnVlKTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBjYW52YXNcblx0XHQgKiBAdHlwZSBIVE1MQ2FudmFzRWxlbWVudCB8IE9iamVjdFxuXHRcdCAqKi9cblx0XHR0aGlzLmNhbnZhcyA9ICh0eXBlb2YgY2FudmFzID09IFwic3RyaW5nXCIpID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzKSA6IGNhbnZhcztcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgbW91c2UgWCBwb3NpdGlvbiBvbiB0aGUgY2FudmFzLiBJZiB0aGUgbW91c2UgbGVhdmVzIHRoZSBjYW52YXMsIHRoaXMgd2lsbCBpbmRpY2F0ZSB0aGUgbW9zdCByZWNlbnRcblx0XHQgKiBwb3NpdGlvbiBvdmVyIHRoZSBjYW52YXMsIGFuZCBtb3VzZUluQm91bmRzIHdpbGwgYmUgc2V0IHRvIGZhbHNlLlxuXHRcdCAqIEBwcm9wZXJ0eSBtb3VzZVhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5tb3VzZVggPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY3VycmVudCBtb3VzZSBZIHBvc2l0aW9uIG9uIHRoZSBjYW52YXMuIElmIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIGNhbnZhcywgdGhpcyB3aWxsIGluZGljYXRlIHRoZSBtb3N0IHJlY2VudFxuXHRcdCAqIHBvc2l0aW9uIG92ZXIgdGhlIGNhbnZhcywgYW5kIG1vdXNlSW5Cb3VuZHMgd2lsbCBiZSBzZXQgdG8gZmFsc2UuXG5cdFx0ICogQHByb3BlcnR5IG1vdXNlWVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLm1vdXNlWSA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNwZWNpZmllcyB0aGUgYXJlYSBvZiB0aGUgc3RhZ2UgdG8gYWZmZWN0IHdoZW4gY2FsbGluZyB1cGRhdGUuIFRoaXMgY2FuIGJlIHVzZSB0byBzZWxlY3RpdmVseVxuXHRcdCAqIHJlLWRyYXcgc3BlY2lmaWMgcmVnaW9ucyBvZiB0aGUgY2FudmFzLiBJZiBudWxsLCB0aGUgd2hvbGUgY2FudmFzIGFyZWEgaXMgZHJhd24uXG5cdFx0ICogQHByb3BlcnR5IGRyYXdSZWN0XG5cdFx0ICogQHR5cGUge1JlY3RhbmdsZX1cblx0XHQgKi9cblx0XHR0aGlzLmRyYXdSZWN0ID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgZGlzcGxheSBvYmplY3RzIHNob3VsZCBiZSByZW5kZXJlZCBvbiB3aG9sZSBwaXhlbHMuIFlvdSBjYW4gc2V0IHRoZVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3Qvc25hcFRvUGl4ZWxcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgb2Zcblx0XHQgKiBkaXNwbGF5IG9iamVjdHMgdG8gZmFsc2UgdG8gZW5hYmxlL2Rpc2FibGUgdGhpcyBiZWhhdmlvdXIgb24gYSBwZXIgaW5zdGFuY2UgYmFzaXMuXG5cdFx0ICogQHByb3BlcnR5IHNuYXBUb1BpeGVsRW5hYmxlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqKi9cblx0XHR0aGlzLnNuYXBUb1BpeGVsRW5hYmxlZCA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbW91c2UgaXMgY3VycmVudGx5IHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoZSBjYW52YXMuXG5cdFx0ICogQHByb3BlcnR5IG1vdXNlSW5Cb3VuZHNcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiovXG5cdFx0dGhpcy5tb3VzZUluQm91bmRzID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIHRydWUsIHRpY2sgY2FsbGJhY2tzIHdpbGwgYmUgY2FsbGVkIG9uIGFsbCBkaXNwbGF5IG9iamVjdHMgb24gdGhlIHN0YWdlIHByaW9yIHRvIHJlbmRlcmluZyB0byB0aGUgY2FudmFzLlxuXHRcdCAqIEBwcm9wZXJ0eSB0aWNrT25VcGRhdGVcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqKi9cblx0XHR0aGlzLnRpY2tPblVwZGF0ZSA9IHRydWU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIHRydWUsIG1vdXNlIG1vdmUgZXZlbnRzIHdpbGwgY29udGludWUgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgdGFyZ2V0IGNhbnZhcy4gU2VlXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvbW91c2VJbkJvdW5kczpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiB4L3kvcmF3WC9yYXdZLlxuXHRcdCAqIEBwcm9wZXJ0eSBtb3VzZU1vdmVPdXRzaWRlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICoqL1xuXHRcdHRoaXMubW91c2VNb3ZlT3V0c2lkZSA9IGZhbHNlO1xuXHRcdFxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFByZXZlbnRzIHNlbGVjdGlvbiBvZiBvdGhlciBlbGVtZW50cyBpbiB0aGUgaHRtbCBwYWdlIGlmIHRoZSB1c2VyIGNsaWNrcyBhbmQgZHJhZ3MsIG9yIGRvdWJsZSBjbGlja3Mgb24gdGhlIGNhbnZhcy5cblx0XHQgKiBUaGlzIHdvcmtzIGJ5IGNhbGxpbmcgYHByZXZlbnREZWZhdWx0KClgIG9uIGFueSBtb3VzZWRvd24gZXZlbnRzIChvciB0b3VjaCBlcXVpdmFsZW50KSBvcmlnaW5hdGluZyBvbiB0aGUgY2FudmFzLlxuXHRcdCAqIEBwcm9wZXJ0eSBwcmV2ZW50U2VsZWN0aW9uXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKiovXG5cdFx0dGhpcy5wcmV2ZW50U2VsZWN0aW9uID0gdHJ1ZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGhpdEFyZWEgcHJvcGVydHkgaXMgbm90IHN1cHBvcnRlZCBmb3IgU3RhZ2UuXG5cdFx0ICogQHByb3BlcnR5IGhpdEFyZWFcblx0XHQgKiBAdHlwZSB7RGlzcGxheU9iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0IFxuXHRcdCBcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIG9iamVjdHMgd2l0aCBkYXRhIGZvciBlYWNoIGFjdGl2ZSBwb2ludGVyIGlkLiBFYWNoIG9iamVjdCBoYXMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXHRcdCAqIHgsIHksIGV2ZW50LCB0YXJnZXQsIG92ZXJUYXJnZXQsIG92ZXJYLCBvdmVyWSwgaW5Cb3VuZHMsIHBvc0V2dE9iaiAobmF0aXZlIGV2ZW50IHRoYXQgbGFzdCB1cGRhdGVkIHBvc2l0aW9uKVxuXHRcdCAqIEBwcm9wZXJ0eSBfcG9pbnRlckRhdGFcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcG9pbnRlckRhdGEgPSB7fTtcblx0XG5cdFx0LyoqXG5cdFx0ICogTnVtYmVyIG9mIGFjdGl2ZSBwb2ludGVycy5cblx0XHQgKiBAcHJvcGVydHkgX3BvaW50ZXJDb3VudFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9wb2ludGVyQ291bnQgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgSUQgb2YgdGhlIHByaW1hcnkgcG9pbnRlci5cblx0XHQgKiBAcHJvcGVydHkgX3ByaW1hcnlQb2ludGVySURcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcHJpbWFyeVBvaW50ZXJJRCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbW91c2VPdmVySW50ZXJ2YWxJRFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fbW91c2VPdmVySW50ZXJ2YWxJRCA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9uZXh0U3RhZ2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgU3RhZ2Vcblx0XHQgKiovXG5cdFx0dGhpcy5fbmV4dFN0YWdlID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3ByZXZTdGFnZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBTdGFnZVxuXHRcdCAqKi9cblx0XHR0aGlzLl9wcmV2U3RhZ2UgPSBudWxsO1xuXHRcdFxuXHRcdFxuXHQvLyBpbml0aWFsaXplOlxuXHRcdHRoaXMuZW5hYmxlRE9NRXZlbnRzKHRydWUpO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFN0YWdlLCBjcmVhdGVqcy5Db250YWluZXIpO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBldmVudHM6XG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIgbW92ZXMgdGhlIG1vdXNlIG92ZXIgdGhlIGNhbnZhcy5cblx0ICogU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cblx0ICogQGV2ZW50IHN0YWdlbW91c2Vtb3ZlXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgdGhlaXIgbGVmdCBtb3VzZSBidXR0b24gb24gdGhlIGNhbnZhcy4gU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cblx0ICogQGV2ZW50IHN0YWdlbW91c2Vkb3duXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB1c2VyIHRoZSB1c2VyIHByZXNzZXMgc29tZXdoZXJlIG9uIHRoZSBzdGFnZSwgdGhlbiByZWxlYXNlcyB0aGUgbW91c2UgYnV0dG9uIGFueXdoZXJlIHRoYXQgdGhlIHBhZ2UgY2FuIGRldGVjdCBpdCAodGhpcyB2YXJpZXMgc2xpZ2h0bHkgYmV0d2VlbiBicm93c2VycykuXG5cdCAqIFlvdSBjYW4gdXNlIHt7I2Nyb3NzTGluayBcIlN0YWdlL21vdXNlSW5Cb3VuZHM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gdG8gY2hlY2sgd2hldGhlciB0aGUgbW91c2UgaXMgY3VycmVudGx5IHdpdGhpbiB0aGUgc3RhZ2UgYm91bmRzLlxuXHQgKiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxuXHQgKiBAZXZlbnQgc3RhZ2Vtb3VzZXVwXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBmcm9tIHdpdGhpbiB0aGUgY2FudmFzIGFyZWEgKG1vdXNlSW5Cb3VuZHMgPT0gdHJ1ZSkgdG8gb3V0c2lkZSBpdCAobW91c2VJbkJvdW5kcyA9PSBmYWxzZSkuXG5cdCAqIFRoaXMgaXMgY3VycmVudGx5IG9ubHkgZGlzcGF0Y2hlZCBmb3IgbW91c2UgaW5wdXQgKG5vdCB0b3VjaCkuIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXG5cdCAqIEBldmVudCBtb3VzZWxlYXZlXG5cdCAqIEBzaW5jZSAwLjcuMFxuXHQgKi9cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBpbnRvIHRoZSBjYW52YXMgYXJlYSAobW91c2VJbkJvdW5kcyA9PSBmYWxzZSkgZnJvbSBvdXRzaWRlIGl0IChtb3VzZUluQm91bmRzID09IHRydWUpLlxuXHQgKiBUaGlzIGlzIGN1cnJlbnRseSBvbmx5IGRpc3BhdGNoZWQgZm9yIG1vdXNlIGlucHV0IChub3QgdG91Y2gpLiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxuXHQgKiBAZXZlbnQgbW91c2VlbnRlclxuXHQgKiBAc2luY2UgMC43LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgZWFjaCB1cGRhdGUgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSB0aWNrIGV2ZW50IGlzIHByb3BhZ2F0ZWQgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKiBZb3UgY2FuIGNhbGwgcHJldmVudERlZmF1bHQgb24gdGhlIGV2ZW50IG9iamVjdCB0byBjYW5jZWwgcHJvcGFnYXRpbmcgdGhlIHRpY2sgZXZlbnQuXG5cdCAqIEBldmVudCB0aWNrc3RhcnRcblx0ICogQHNpbmNlIDAuNy4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIGVhY2ggdXBkYXRlIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSB0aWNrIGV2ZW50IGlzIHByb3BhZ2F0ZWQgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LiBEb2VzIG5vdCBmaXJlIGlmXG5cdCAqIHRpY2tPblVwZGF0ZSBpcyBmYWxzZS4gUHJlY2VkZXMgdGhlIFwiZHJhd3N0YXJ0XCIgZXZlbnQuXG5cdCAqIEBldmVudCB0aWNrZW5kXG5cdCAqIEBzaW5jZSAwLjcuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCBlYWNoIHVwZGF0ZSBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNhbnZhcyBpcyBjbGVhcmVkIGFuZCB0aGUgZGlzcGxheSBsaXN0IGlzIGRyYXduIHRvIGl0LlxuXHQgKiBZb3UgY2FuIGNhbGwgcHJldmVudERlZmF1bHQgb24gdGhlIGV2ZW50IG9iamVjdCB0byBjYW5jZWwgdGhlIGRyYXcuXG5cdCAqIEBldmVudCBkcmF3c3RhcnRcblx0ICogQHNpbmNlIDAuNy4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIGVhY2ggdXBkYXRlIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBkaXNwbGF5IGxpc3QgaXMgZHJhd24gdG8gdGhlIGNhbnZhcyBhbmQgdGhlIGNhbnZhcyBjb250ZXh0IGlzIHJlc3RvcmVkLlxuXHQgKiBAZXZlbnQgZHJhd2VuZFxuXHQgKiBAc2luY2UgMC43LjBcblx0ICovXG5cblx0IFxuLy8gZ2V0dGVyIC8gc2V0dGVyczpcblx0LyoqXG5cdCAqIFNwZWNpZmllcyBhIHRhcmdldCBzdGFnZSB0aGF0IHdpbGwgaGF2ZSBtb3VzZSAvIHRvdWNoIGludGVyYWN0aW9ucyByZWxheWVkIHRvIGl0IGFmdGVyIHRoaXMgc3RhZ2UgaGFuZGxlcyB0aGVtLlxuXHQgKiBUaGlzIGNhbiBiZSB1c2VmdWwgaW4gY2FzZXMgd2hlcmUgeW91IGhhdmUgbXVsdGlwbGUgbGF5ZXJlZCBjYW52YXNlcyBhbmQgd2FudCB1c2VyIGludGVyYWN0aW9uc1xuXHQgKiBldmVudHMgdG8gcGFzcyB0aHJvdWdoLiBGb3IgZXhhbXBsZSwgdGhpcyB3b3VsZCByZWxheSBtb3VzZSBldmVudHMgZnJvbSB0b3BTdGFnZSB0byBib3R0b21TdGFnZTpcblx0ICpcblx0ICogICAgICB0b3BTdGFnZS5uZXh0U3RhZ2UgPSBib3R0b21TdGFnZTtcblx0ICpcblx0ICogVG8gZGlzYWJsZSByZWxheWluZywgc2V0IG5leHRTdGFnZSB0byBudWxsLlxuXHQgKiBcblx0ICogTW91c2VPdmVyLCBNb3VzZU91dCwgUm9sbE92ZXIsIGFuZCBSb2xsT3V0IGludGVyYWN0aW9ucyBhcmUgYWxzbyBwYXNzZWQgdGhyb3VnaCB1c2luZyB0aGUgbW91c2Ugb3ZlciBzZXR0aW5nc1xuXHQgKiBvZiB0aGUgdG9wLW1vc3Qgc3RhZ2UsIGJ1dCBhcmUgb25seSBwcm9jZXNzZWQgaWYgdGhlIHRhcmdldCBzdGFnZSBoYXMgbW91c2Ugb3ZlciBpbnRlcmFjdGlvbnMgZW5hYmxlZC5cblx0ICogQ29uc2lkZXJhdGlvbnMgd2hlbiB1c2luZyByb2xsIG92ZXIgaW4gcmVsYXkgdGFyZ2V0czo8T0w+XG5cdCAqIDxMST4gVGhlIHRvcC1tb3N0IChmaXJzdCkgc3RhZ2UgbXVzdCBoYXZlIG1vdXNlIG92ZXIgaW50ZXJhY3Rpb25zIGVuYWJsZWQgKHZpYSBlbmFibGVNb3VzZU92ZXIpPC9MST5cblx0ICogPExJPiBBbGwgc3RhZ2VzIHRoYXQgd2lzaCB0byBwYXJ0aWNpcGF0ZSBpbiBtb3VzZSBvdmVyIGludGVyYWN0aW9uIG11c3QgZW5hYmxlIHRoZW0gdmlhIGVuYWJsZU1vdXNlT3ZlcjwvTEk+XG5cdCAqIDxMST4gQWxsIHJlbGF5IHRhcmdldHMgd2lsbCBzaGFyZSB0aGUgZnJlcXVlbmN5IHZhbHVlIG9mIHRoZSB0b3AtbW9zdCBzdGFnZTwvTEk+XG5cdCAqIDwvT0w+XG5cdCAqIFRvIGlsbHVzdHJhdGUsIGluIHRoaXMgZXhhbXBsZSB0aGUgdGFyZ2V0U3RhZ2Ugd291bGQgcHJvY2VzcyBtb3VzZSBvdmVyIGludGVyYWN0aW9ucyBhdCAxMGh6IChkZXNwaXRlIHBhc3Npbmdcblx0ICogMzAgYXMgaXQncyBkZXNpcmVkIGZyZXF1ZW5jeSk6XG5cdCAqIFx0dG9wU3RhZ2UubmV4dFN0YWdlID0gdGFyZ2V0U3RhZ2U7XG5cdCAqIFx0dG9wU3RhZ2UuZW5hYmxlTW91c2VPdmVyKDEwKTtcblx0ICogXHR0YXJnZXRTdGFnZS5lbmFibGVNb3VzZU92ZXIoMzApO1xuXHQgKiBcblx0ICogSWYgdGhlIHRhcmdldCBzdGFnZSdzIGNhbnZhcyBpcyBjb21wbGV0ZWx5IGNvdmVyZWQgYnkgdGhpcyBzdGFnZSdzIGNhbnZhcywgeW91IG1heSBhbHNvIHdhbnQgdG8gZGlzYWJsZSBpdHNcblx0ICogRE9NIGV2ZW50cyB1c2luZzpcblx0ICogXG5cdCAqXHR0YXJnZXRTdGFnZS5lbmFibGVET01FdmVudHMoZmFsc2UpO1xuXHQgKiBcblx0ICogQHByb3BlcnR5IG5leHRTdGFnZVxuXHQgKiBAdHlwZSB7U3RhZ2V9XG5cdCAqKi9cblx0cC5fZ2V0X25leHRTdGFnZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9uZXh0U3RhZ2U7XG5cdH07XG5cdHAuX3NldF9uZXh0U3RhZ2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh0aGlzLl9uZXh0U3RhZ2UpIHsgdGhpcy5fbmV4dFN0YWdlLl9wcmV2U3RhZ2UgPSBudWxsOyB9XG5cdFx0aWYgKHZhbHVlKSB7IHZhbHVlLl9wcmV2U3RhZ2UgPSB0aGlzOyB9XG5cdFx0dGhpcy5fbmV4dFN0YWdlID0gdmFsdWU7XG5cdH07XG5cdFxuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcblx0XHRcdG5leHRTdGFnZTogeyBnZXQ6IHAuX2dldF9uZXh0U3RhZ2UsIHNldDogcC5fc2V0X25leHRTdGFnZSB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHt9IC8vIFRPRE86IHVzZSBMb2dcblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEVhY2ggdGltZSB0aGUgdXBkYXRlIG1ldGhvZCBpcyBjYWxsZWQsIHRoZSBzdGFnZSB3aWxsIGNhbGwge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdGlja1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB1bmxlc3Mge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdGlja09uVXBkYXRlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlzIHNldCB0byBmYWxzZSxcblx0ICogYW5kIHRoZW4gcmVuZGVyIHRoZSBkaXNwbGF5IGxpc3QgdG8gdGhlIGNhbnZhcy5cblx0ICpcblx0ICogQG1ldGhvZCB1cGRhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gUHJvcHMgb2JqZWN0IHRvIHBhc3MgdG8gYHRpY2soKWAuIFNob3VsZCB1c3VhbGx5IGJlIGEge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IG9iamVjdCwgb3Igc2ltaWxhciBvYmplY3Qgd2l0aCBhIGRlbHRhIHByb3BlcnR5LlxuXHQgKiovXG5cdHAudXBkYXRlID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRpZiAoIXRoaXMuY2FudmFzKSB7IHJldHVybjsgfVxuXHRcdGlmICh0aGlzLnRpY2tPblVwZGF0ZSkgeyB0aGlzLnRpY2socHJvcHMpOyB9XG5cdFx0aWYgKHRoaXMuZGlzcGF0Y2hFdmVudChcImRyYXdzdGFydFwiLCBmYWxzZSwgdHJ1ZSkgPT09IGZhbHNlKSB7IHJldHVybjsgfVxuXHRcdGNyZWF0ZWpzLkRpc3BsYXlPYmplY3QuX3NuYXBUb1BpeGVsRW5hYmxlZCA9IHRoaXMuc25hcFRvUGl4ZWxFbmFibGVkO1xuXHRcdHZhciByID0gdGhpcy5kcmF3UmVjdCwgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0aWYgKHRoaXMuYXV0b0NsZWFyKSB7XG5cdFx0XHRpZiAocikgeyBjdHguY2xlYXJSZWN0KHIueCwgci55LCByLndpZHRoLCByLmhlaWdodCk7IH1cblx0XHRcdGVsc2UgeyBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoKzEsIHRoaXMuY2FudmFzLmhlaWdodCsxKTsgfVxuXHRcdH1cblx0XHRjdHguc2F2ZSgpO1xuXHRcdGlmICh0aGlzLmRyYXdSZWN0KSB7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHgucmVjdChyLngsIHIueSwgci53aWR0aCwgci5oZWlnaHQpO1xuXHRcdFx0Y3R4LmNsaXAoKTtcblx0XHR9XG5cdFx0dGhpcy51cGRhdGVDb250ZXh0KGN0eCk7XG5cdFx0dGhpcy5kcmF3KGN0eCwgZmFsc2UpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiZHJhd2VuZFwiKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBQcm9wYWdhdGVzIGEgdGljayBldmVudCB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuIFRoaXMgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgYnkge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdXBkYXRlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHVubGVzcyB7eyNjcm9zc0xpbmsgXCJTdGFnZS90aWNrT25VcGRhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaXMgc2V0IHRvIGZhbHNlLlxuXHQgKlxuXHQgKiBJZiBhIHByb3BzIG9iamVjdCBpcyBwYXNzZWQgdG8gYHRpY2soKWAsIHRoZW4gYWxsIG9mIGl0cyBwcm9wZXJ0aWVzIHdpbGwgYmUgY29waWVkIHRvIHRoZSBldmVudCBvYmplY3QgdGhhdCBpc1xuXHQgKiBwcm9wYWdhdGVkIHRvIGxpc3RlbmVycy5cblx0ICpcblx0ICogU29tZSB0aW1lLWJhc2VkIGZlYXR1cmVzIGluIEVhc2VsSlMgKGZvciBleGFtcGxlIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9mcmFtZXJhdGVcIn19e3svY3Jvc3NMaW5rfX0gcmVxdWlyZSB0aGF0XG5cdCAqIGEge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgb2JqZWN0IChvciBlcXVpdmFsZW50IG9iamVjdCB3aXRoIGEgZGVsdGEgcHJvcGVydHkpIGJlXG5cdCAqIHBhc3NlZCBhcyB0aGUgYHByb3BzYCBwYXJhbWV0ZXIgdG8gYHRpY2soKWAuIEZvciBleGFtcGxlOlxuXHQgKlxuXHQgKiBcdFRpY2tlci5vbihcInRpY2tcIiwgaGFuZGxlVGljayk7XG5cdCAqIFx0ZnVuY3Rpb24gaGFuZGxlVGljayhldnRPYmopIHtcblx0ICogXHRcdC8vIGNsb25lIHRoZSBldmVudCBvYmplY3QgZnJvbSBUaWNrZXIsIGFuZCBhZGQgc29tZSBjdXN0b20gZGF0YSB0byBpdDpcblx0ICogXHRcdHZhciBldnQgPSBldnRPYmouY2xvbmUoKS5zZXQoe2dyZWV0aW5nOlwiaGVsbG9cIiwgbmFtZTpcIndvcmxkXCJ9KTtcblx0ICogXHRcdFxuXHQgKiBcdFx0Ly8gcGFzcyBpdCB0byBzdGFnZS51cGRhdGUoKTpcblx0ICogXHRcdG15U3RhZ2UudXBkYXRlKGV2dCk7IC8vIHN1YnNlcXVlbnRseSBjYWxscyB0aWNrKCkgd2l0aCB0aGUgc2FtZSBwYXJhbVxuXHQgKiBcdH1cblx0ICogXHRcblx0ICogXHQvLyAuLi5cblx0ICogXHRteURpc3BsYXlPYmplY3Qub24oXCJ0aWNrXCIsIGhhbmRsZURpc3BsYXlPYmplY3RUaWNrKTtcblx0ICogXHRmdW5jdGlvbiBoYW5kbGVEaXNwbGF5T2JqZWN0VGljayhldnQpIHtcblx0ICogXHRcdGNvbnNvbGUubG9nKGV2dC5kZWx0YSk7IC8vIHRoZSBkZWx0YSBwcm9wZXJ0eSBmcm9tIHRoZSBUaWNrZXIgdGljayBldmVudCBvYmplY3Rcblx0ICogXHRcdGNvbnNvbGUubG9nKGV2dC5ncmVldGluZywgZXZ0Lm5hbWUpOyAvLyBjdXN0b20gZGF0YTogXCJoZWxsbyB3b3JsZFwiXG5cdCAqIFx0fVxuXHQgKiBcblx0ICogQG1ldGhvZCB0aWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIEFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgY29waWVkIHRvIHRoZSBldmVudCBvYmplY3QuIFNob3VsZCB1c3VhbGx5IGJlIGEgVGlja2VyIGV2ZW50IG9iamVjdCwgb3Igc2ltaWxhciBvYmplY3Qgd2l0aCBhIGRlbHRhIHByb3BlcnR5LlxuXHQgKiovXG5cdHAudGljayA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0aWYgKCF0aGlzLnRpY2tFbmFibGVkIHx8IHRoaXMuZGlzcGF0Y2hFdmVudChcInRpY2tzdGFydFwiLCBmYWxzZSwgdHJ1ZSkgPT09IGZhbHNlKSB7IHJldHVybjsgfVxuXHRcdHZhciBldnRPYmogPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJ0aWNrXCIpO1xuXHRcdGlmIChwcm9wcykge1xuXHRcdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykge1xuXHRcdFx0XHRpZiAocHJvcHMuaGFzT3duUHJvcGVydHkobikpIHsgZXZ0T2JqW25dID0gcHJvcHNbbl07IH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fdGljayhldnRPYmopO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcInRpY2tlbmRcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlZmF1bHQgZXZlbnQgaGFuZGxlciB0aGF0IGNhbGxzIHRoZSBTdGFnZSB7eyNjcm9zc0xpbmsgXCJTdGFnZS91cGRhdGVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIHdoZW4gYSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgaXMgcmVjZWl2ZWQuIFRoaXMgYWxsb3dzIHlvdSB0byByZWdpc3RlciBhIFN0YWdlIGluc3RhbmNlIGFzIGEgZXZlbnQgbGlzdGVuZXIgb24ge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGRpcmVjdGx5LCB1c2luZzpcblx0ICpcblx0ICogICAgICBUaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgbXlTdGFnZVwiKTtcblx0ICpcblx0ICogTm90ZSB0aGF0IGlmIHlvdSBzdWJzY3JpYmUgdG8gdGlja3MgdXNpbmcgdGhpcyBwYXR0ZXJuLCB0aGVuIHRoZSB0aWNrIGV2ZW50IG9iamVjdCB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHRvXG5cdCAqIGRpc3BsYXkgb2JqZWN0IHRpY2sgaGFuZGxlcnMsIGluc3RlYWQgb2YgPGNvZGU+ZGVsdGE8L2NvZGU+IGFuZCA8Y29kZT5wYXVzZWQ8L2NvZGU+IHBhcmFtZXRlcnMuXG5cdCAqIEBwcm9wZXJ0eSBoYW5kbGVFdmVudFxuXHQgKiBAdHlwZSBGdW5jdGlvblxuXHQgKiovXG5cdHAuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbihldnQpIHtcblx0XHRpZiAoZXZ0LnR5cGUgPT0gXCJ0aWNrXCIpIHsgdGhpcy51cGRhdGUoZXZ0KTsgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhcnMgdGhlIHRhcmdldCBjYW52YXMuIFVzZWZ1bCBpZiB7eyNjcm9zc0xpbmsgXCJTdGFnZS9hdXRvQ2xlYXI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaXMgc2V0IHRvIGBmYWxzZWAuXG5cdCAqIEBtZXRob2QgY2xlYXJcblx0ICoqL1xuXHRwLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmNhbnZhcykgeyByZXR1cm47IH1cblx0XHR2YXIgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCsxLCB0aGlzLmNhbnZhcy5oZWlnaHQrMSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBkYXRhIHVybCB0aGF0IGNvbnRhaW5zIGEgQmFzZTY0LWVuY29kZWQgaW1hZ2Ugb2YgdGhlIGNvbnRlbnRzIG9mIHRoZSBzdGFnZS4gVGhlIHJldHVybmVkIGRhdGEgdXJsIGNhblxuXHQgKiBiZSBzcGVjaWZpZWQgYXMgdGhlIHNyYyB2YWx1ZSBvZiBhbiBpbWFnZSBlbGVtZW50LlxuXHQgKiBAbWV0aG9kIHRvRGF0YVVSTFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2JhY2tncm91bmRDb2xvcl0gVGhlIGJhY2tncm91bmQgY29sb3IgdG8gYmUgdXNlZCBmb3IgdGhlIGdlbmVyYXRlZCBpbWFnZS4gQW55IHZhbGlkIENTUyBjb2xvclxuXHQgKiB2YWx1ZSBpcyBhbGxvd2VkLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBhIHRyYW5zcGFyZW50IGJhY2tncm91bmQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbbWltZVR5cGU9XCJpbWFnZS9wbmdcIl0gVGhlIE1JTUUgdHlwZSBvZiB0aGUgaW1hZ2UgZm9ybWF0IHRvIGJlIGNyZWF0ZS4gVGhlIGRlZmF1bHQgaXMgXCJpbWFnZS9wbmdcIi4gSWYgYW4gdW5rbm93biBNSU1FIHR5cGVcblx0ICogaXMgcGFzc2VkIGluLCBvciBpZiB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBzcGVjaWZpZWQgTUlNRSB0eXBlLCB0aGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBCYXNlNjQgZW5jb2RlZCBpbWFnZS5cblx0ICoqL1xuXHRwLnRvRGF0YVVSTCA9IGZ1bmN0aW9uKGJhY2tncm91bmRDb2xvciwgbWltZVR5cGUpIHtcblx0XHR2YXIgZGF0YSwgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKSwgdyA9IHRoaXMuY2FudmFzLndpZHRoLCBoID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuXG5cdFx0aWYgKGJhY2tncm91bmRDb2xvcikge1xuXHRcdFx0ZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdywgaCk7XG5cdFx0XHR2YXIgY29tcG9zaXRlT3BlcmF0aW9uID0gY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcblx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLW92ZXJcIjtcblx0XHRcdFxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcblx0XHRcdGN0eC5maWxsUmVjdCgwLCAwLCB3LCBoKTtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVVSTCA9IHRoaXMuY2FudmFzLnRvRGF0YVVSTChtaW1lVHlwZXx8XCJpbWFnZS9wbmdcIik7XG5cblx0XHRpZihiYWNrZ3JvdW5kQ29sb3IpIHtcblx0XHRcdGN0eC5wdXRJbWFnZURhdGEoZGF0YSwgMCwgMCk7XG5cdFx0XHRjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gY29tcG9zaXRlT3BlcmF0aW9uO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhVVJMO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbmFibGVzIG9yIGRpc2FibGVzIChieSBwYXNzaW5nIGEgZnJlcXVlbmN5IG9mIDApIG1vdXNlIG92ZXIgKHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2VvdmVyOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFuZCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlb3V0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319KSBhbmQgcm9sbCBvdmVyIGV2ZW50cyAoe3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9yb2xsb3ZlcjpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBhbmQge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9yb2xsb3V0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319KSBmb3IgdGhpcyBzdGFnZSdzIGRpc3BsYXkgbGlzdC4gVGhlc2UgZXZlbnRzIGNhblxuXHQgKiBiZSBleHBlbnNpdmUgdG8gZ2VuZXJhdGUsIHNvIHRoZXkgYXJlIGRpc2FibGVkIGJ5IGRlZmF1bHQuIFRoZSBmcmVxdWVuY3kgb2YgdGhlIGV2ZW50cyBjYW4gYmUgY29udHJvbGxlZFxuXHQgKiBpbmRlcGVuZGVudGx5IG9mIG1vdXNlIG1vdmUgZXZlbnRzIHZpYSB0aGUgb3B0aW9uYWwgYGZyZXF1ZW5jeWAgcGFyYW1ldGVyLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIHN0YWdlID0gbmV3IGNyZWF0ZWpzLlN0YWdlKFwiY2FudmFzSWRcIik7XG5cdCAqICAgICAgc3RhZ2UuZW5hYmxlTW91c2VPdmVyKDEwKTsgLy8gMTAgdXBkYXRlcyBwZXIgc2Vjb25kXG5cdCAqXG5cdCAqIEBtZXRob2QgZW5hYmxlTW91c2VPdmVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZnJlcXVlbmN5PTIwXSBPcHRpb25hbCBwYXJhbSBzcGVjaWZ5aW5nIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyBwZXIgc2Vjb25kIHRvIGJyb2FkY2FzdFxuXHQgKiBtb3VzZSBvdmVyL291dCBldmVudHMuIFNldCB0byAwIHRvIGRpc2FibGUgbW91c2Ugb3ZlciBldmVudHMgY29tcGxldGVseS4gTWF4aW11bSBpcyA1MC4gQSBsb3dlciBmcmVxdWVuY3kgaXMgbGVzc1xuXHQgKiByZXNwb25zaXZlLCBidXQgdXNlcyBsZXNzIENQVS5cblx0ICoqL1xuXHRwLmVuYWJsZU1vdXNlT3ZlciA9IGZ1bmN0aW9uKGZyZXF1ZW5jeSkge1xuXHRcdGlmICh0aGlzLl9tb3VzZU92ZXJJbnRlcnZhbElEKSB7XG5cdFx0XHRjbGVhckludGVydmFsKHRoaXMuX21vdXNlT3ZlckludGVydmFsSUQpO1xuXHRcdFx0dGhpcy5fbW91c2VPdmVySW50ZXJ2YWxJRCA9IG51bGw7XG5cdFx0XHRpZiAoZnJlcXVlbmN5ID09IDApIHtcblx0XHRcdFx0dGhpcy5fdGVzdE1vdXNlT3Zlcih0cnVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGZyZXF1ZW5jeSA9PSBudWxsKSB7IGZyZXF1ZW5jeSA9IDIwOyB9XG5cdFx0ZWxzZSBpZiAoZnJlcXVlbmN5IDw9IDApIHsgcmV0dXJuOyB9XG5cdFx0dmFyIG8gPSB0aGlzO1xuXHRcdHRoaXMuX21vdXNlT3ZlckludGVydmFsSUQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpeyBvLl90ZXN0TW91c2VPdmVyKCk7IH0sIDEwMDAvTWF0aC5taW4oNTAsZnJlcXVlbmN5KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHN0YWdlIGFkZHMgdG8gRE9NIGVsZW1lbnRzICh3aW5kb3csIGRvY3VtZW50IGFuZCBjYW52YXMpLiBJdCBpcyBnb29kXG5cdCAqIHByYWN0aWNlIHRvIGRpc2FibGUgZXZlbnRzIHdoZW4gZGlzcG9zaW5nIG9mIGEgU3RhZ2UgaW5zdGFuY2UsIG90aGVyd2lzZSB0aGUgc3RhZ2Ugd2lsbCBjb250aW51ZSB0byByZWNlaXZlXG5cdCAqIGV2ZW50cyBmcm9tIHRoZSBwYWdlLlxuXHQgKlxuXHQgKiBXaGVuIGNoYW5naW5nIHRoZSBjYW52YXMgcHJvcGVydHkgeW91IG11c3QgZGlzYWJsZSB0aGUgZXZlbnRzIG9uIHRoZSBvbGQgY2FudmFzLCBhbmQgZW5hYmxlIGV2ZW50cyBvbiB0aGVcblx0ICogbmV3IGNhbnZhcyBvciBtb3VzZSBldmVudHMgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZC4gRm9yIGV4YW1wbGU6XG5cdCAqXG5cdCAqICAgICAgbXlTdGFnZS5lbmFibGVET01FdmVudHMoZmFsc2UpO1xuXHQgKiAgICAgIG15U3RhZ2UuY2FudmFzID0gYW5vdGhlckNhbnZhcztcblx0ICogICAgICBteVN0YWdlLmVuYWJsZURPTUV2ZW50cyh0cnVlKTtcblx0ICpcblx0ICogQG1ldGhvZCBlbmFibGVET01FdmVudHNcblx0ICogQHBhcmFtIHtCb29sZWFufSBbZW5hYmxlPXRydWVdIEluZGljYXRlcyB3aGV0aGVyIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBldmVudHMuIERlZmF1bHQgaXMgdHJ1ZS5cblx0ICoqL1xuXHRwLmVuYWJsZURPTUV2ZW50cyA9IGZ1bmN0aW9uKGVuYWJsZSkge1xuXHRcdGlmIChlbmFibGUgPT0gbnVsbCkgeyBlbmFibGUgPSB0cnVlOyB9XG5cdFx0dmFyIG4sIG8sIGxzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnM7XG5cdFx0aWYgKCFlbmFibGUgJiYgbHMpIHtcblx0XHRcdGZvciAobiBpbiBscykge1xuXHRcdFx0XHRvID0gbHNbbl07XG5cdFx0XHRcdG8udC5yZW1vdmVFdmVudExpc3RlbmVyKG4sIG8uZiwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSBudWxsO1xuXHRcdH0gZWxzZSBpZiAoZW5hYmxlICYmICFscyAmJiB0aGlzLmNhbnZhcykge1xuXHRcdFx0dmFyIHQgPSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciA/IHdpbmRvdyA6IGRvY3VtZW50O1xuXHRcdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHRcdGxzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSB7fTtcblx0XHRcdGxzW1wibW91c2V1cFwiXSA9IHt0OnQsIGY6ZnVuY3Rpb24oZSkgeyBfdGhpcy5faGFuZGxlTW91c2VVcChlKX0gfTtcblx0XHRcdGxzW1wibW91c2Vtb3ZlXCJdID0ge3Q6dCwgZjpmdW5jdGlvbihlKSB7IF90aGlzLl9oYW5kbGVNb3VzZU1vdmUoZSl9IH07XG5cdFx0XHRsc1tcImRibGNsaWNrXCJdID0ge3Q6dGhpcy5jYW52YXMsIGY6ZnVuY3Rpb24oZSkgeyBfdGhpcy5faGFuZGxlRG91YmxlQ2xpY2soZSl9IH07XG5cdFx0XHRsc1tcIm1vdXNlZG93blwiXSA9IHt0OnRoaXMuY2FudmFzLCBmOmZ1bmN0aW9uKGUpIHsgX3RoaXMuX2hhbmRsZU1vdXNlRG93bihlKX0gfTtcblxuXHRcdFx0Zm9yIChuIGluIGxzKSB7XG5cdFx0XHRcdG8gPSBsc1tuXTtcblx0XHRcdFx0by50LmFkZEV2ZW50TGlzdGVuZXIobiwgby5mLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdGFnZSBpbnN0YW5jZXMgY2Fubm90IGJlIGNsb25lZC5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyhcIlN0YWdlIGNhbm5vdCBiZSBjbG9uZWQuXCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbU3RhZ2UgKG5hbWU9XCIrICB0aGlzLm5hbWUgK1wiKV1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRFbGVtZW50UmVjdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVcblx0ICoqL1xuXHRwLl9nZXRFbGVtZW50UmVjdCA9IGZ1bmN0aW9uKGUpIHtcblx0XHR2YXIgYm91bmRzO1xuXHRcdHRyeSB7IGJvdW5kcyA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IH0gLy8gdGhpcyBjYW4gZmFpbCBvbiBkaXNjb25uZWN0ZWQgRE9NIGVsZW1lbnRzIGluIElFOVxuXHRcdGNhdGNoIChlcnIpIHsgYm91bmRzID0ge3RvcDogZS5vZmZzZXRUb3AsIGxlZnQ6IGUub2Zmc2V0TGVmdCwgd2lkdGg6ZS5vZmZzZXRXaWR0aCwgaGVpZ2h0OmUub2Zmc2V0SGVpZ2h0fTsgfVxuXG5cdFx0dmFyIG9mZlggPSAod2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LnNjcm9sbExlZnQgfHwgMCkgLSAoZG9jdW1lbnQuY2xpZW50TGVmdCB8fCBkb2N1bWVudC5ib2R5LmNsaWVudExlZnQgfHwgMCk7XG5cdFx0dmFyIG9mZlkgPSAod2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LnNjcm9sbFRvcCB8fCAwKSAtIChkb2N1bWVudC5jbGllbnRUb3AgIHx8IGRvY3VtZW50LmJvZHkuY2xpZW50VG9wICB8fCAwKTtcblxuXHRcdHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA/IGdldENvbXB1dGVkU3R5bGUoZSxudWxsKSA6IGUuY3VycmVudFN0eWxlOyAvLyBJRSA8OSBjb21wYXRpYmlsaXR5LlxuXHRcdHZhciBwYWRMID0gcGFyc2VJbnQoc3R5bGVzLnBhZGRpbmdMZWZ0KStwYXJzZUludChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoKTtcblx0XHR2YXIgcGFkVCA9IHBhcnNlSW50KHN0eWxlcy5wYWRkaW5nVG9wKStwYXJzZUludChzdHlsZXMuYm9yZGVyVG9wV2lkdGgpO1xuXHRcdHZhciBwYWRSID0gcGFyc2VJbnQoc3R5bGVzLnBhZGRpbmdSaWdodCkrcGFyc2VJbnQoc3R5bGVzLmJvcmRlclJpZ2h0V2lkdGgpO1xuXHRcdHZhciBwYWRCID0gcGFyc2VJbnQoc3R5bGVzLnBhZGRpbmdCb3R0b20pK3BhcnNlSW50KHN0eWxlcy5ib3JkZXJCb3R0b21XaWR0aCk7XG5cblx0XHQvLyBub3RlOiBpbiBzb21lIGJyb3dzZXJzIGJvdW5kcyBwcm9wZXJ0aWVzIGFyZSByZWFkIG9ubHkuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGxlZnQ6IGJvdW5kcy5sZWZ0K29mZlgrcGFkTCxcblx0XHRcdHJpZ2h0OiBib3VuZHMucmlnaHQrb2ZmWC1wYWRSLFxuXHRcdFx0dG9wOiBib3VuZHMudG9wK29mZlkrcGFkVCxcblx0XHRcdGJvdHRvbTogYm91bmRzLmJvdHRvbStvZmZZLXBhZEJcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldFBvaW50ZXJEYXRhXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGlkXG5cdCAqKi9cblx0cC5fZ2V0UG9pbnRlckRhdGEgPSBmdW5jdGlvbihpZCkge1xuXHRcdHZhciBkYXRhID0gdGhpcy5fcG9pbnRlckRhdGFbaWRdO1xuXHRcdGlmICghZGF0YSkgeyBkYXRhID0gdGhpcy5fcG9pbnRlckRhdGFbaWRdID0ge3g6MCx5OjB9OyB9XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1vdXNlTW92ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuXHQgKiovXG5cdHAuX2hhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uKGUpIHtcblx0XHRpZighZSl7IGUgPSB3aW5kb3cuZXZlbnQ7IH1cblx0XHR0aGlzLl9oYW5kbGVQb2ludGVyTW92ZSgtMSwgZSwgZS5wYWdlWCwgZS5wYWdlWSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVBvaW50ZXJNb3ZlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGlkXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2VYXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlWVxuXHQgKiBAcGFyYW0ge1N0YWdlfSBvd25lciBJbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgaGFzIGFscmVhZHkgYmVlbiBjYXB0dXJlZCAmIGhhbmRsZWQgYnkgdGhlIGluZGljYXRlZCBzdGFnZS5cblx0ICoqL1xuXHRwLl9oYW5kbGVQb2ludGVyTW92ZSA9IGZ1bmN0aW9uKGlkLCBlLCBwYWdlWCwgcGFnZVksIG93bmVyKSB7XG5cdFx0aWYgKHRoaXMuX3ByZXZTdGFnZSAmJiBvd25lciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfSAvLyByZWR1bmRhbnQgbGlzdGVuZXIuXG5cdFx0aWYgKCF0aGlzLmNhbnZhcykgeyByZXR1cm47IH1cblx0XHR2YXIgbmV4dFN0YWdlPXRoaXMuX25leHRTdGFnZSwgbz10aGlzLl9nZXRQb2ludGVyRGF0YShpZCk7XG5cblx0XHR2YXIgaW5Cb3VuZHMgPSBvLmluQm91bmRzO1xuXHRcdHRoaXMuX3VwZGF0ZVBvaW50ZXJQb3NpdGlvbihpZCwgZSwgcGFnZVgsIHBhZ2VZKTtcblx0XHRpZiAoaW5Cb3VuZHMgfHwgby5pbkJvdW5kcyB8fCB0aGlzLm1vdXNlTW92ZU91dHNpZGUpIHtcblx0XHRcdGlmIChpZCA9PT0gLTEgJiYgby5pbkJvdW5kcyA9PSAhaW5Cb3VuZHMpIHtcblx0XHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRoaXMsIChpbkJvdW5kcyA/IFwibW91c2VsZWF2ZVwiIDogXCJtb3VzZWVudGVyXCIpLCBmYWxzZSwgaWQsIG8sIGUpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQodGhpcywgXCJzdGFnZW1vdXNlbW92ZVwiLCBmYWxzZSwgaWQsIG8sIGUpO1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KG8udGFyZ2V0LCBcInByZXNzbW92ZVwiLCB0cnVlLCBpZCwgbywgZSk7XG5cdFx0fVxuXHRcdFxuXHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl9oYW5kbGVQb2ludGVyTW92ZShpZCwgZSwgcGFnZVgsIHBhZ2VZLCBudWxsKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfdXBkYXRlUG9pbnRlclBvc2l0aW9uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGlkXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2VYXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlWVxuXHQgKiovXG5cdHAuX3VwZGF0ZVBvaW50ZXJQb3NpdGlvbiA9IGZ1bmN0aW9uKGlkLCBlLCBwYWdlWCwgcGFnZVkpIHtcblx0XHR2YXIgcmVjdCA9IHRoaXMuX2dldEVsZW1lbnRSZWN0KHRoaXMuY2FudmFzKTtcblx0XHRwYWdlWCAtPSByZWN0LmxlZnQ7XG5cdFx0cGFnZVkgLT0gcmVjdC50b3A7XG5cblx0XHR2YXIgdyA9IHRoaXMuY2FudmFzLndpZHRoO1xuXHRcdHZhciBoID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuXHRcdHBhZ2VYIC89IChyZWN0LnJpZ2h0LXJlY3QubGVmdCkvdztcblx0XHRwYWdlWSAvPSAocmVjdC5ib3R0b20tcmVjdC50b3ApL2g7XG5cdFx0dmFyIG8gPSB0aGlzLl9nZXRQb2ludGVyRGF0YShpZCk7XG5cdFx0aWYgKG8uaW5Cb3VuZHMgPSAocGFnZVggPj0gMCAmJiBwYWdlWSA+PSAwICYmIHBhZ2VYIDw9IHctMSAmJiBwYWdlWSA8PSBoLTEpKSB7XG5cdFx0XHRvLnggPSBwYWdlWDtcblx0XHRcdG8ueSA9IHBhZ2VZO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5tb3VzZU1vdmVPdXRzaWRlKSB7XG5cdFx0XHRvLnggPSBwYWdlWCA8IDAgPyAwIDogKHBhZ2VYID4gdy0xID8gdy0xIDogcGFnZVgpO1xuXHRcdFx0by55ID0gcGFnZVkgPCAwID8gMCA6IChwYWdlWSA+IGgtMSA/IGgtMSA6IHBhZ2VZKTtcblx0XHR9XG5cblx0XHRvLnBvc0V2dE9iaiA9IGU7XG5cdFx0by5yYXdYID0gcGFnZVg7XG5cdFx0by5yYXdZID0gcGFnZVk7XG5cblx0XHRpZiAoaWQgPT09IHRoaXMuX3ByaW1hcnlQb2ludGVySUQgfHwgaWQgPT09IC0xKSB7XG5cdFx0XHR0aGlzLm1vdXNlWCA9IG8ueDtcblx0XHRcdHRoaXMubW91c2VZID0gby55O1xuXHRcdFx0dGhpcy5tb3VzZUluQm91bmRzID0gby5pbkJvdW5kcztcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1vdXNlVXBcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcblx0ICoqL1xuXHRwLl9oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24oZSkge1xuXHRcdHRoaXMuX2hhbmRsZVBvaW50ZXJVcCgtMSwgZSwgZmFsc2UpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVQb2ludGVyVXBcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaWRcblx0ICogQHBhcmFtIHtFdmVudH0gZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNsZWFyXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IG93bmVyIEluZGljYXRlcyB0aGF0IHRoZSBldmVudCBoYXMgYWxyZWFkeSBiZWVuIGNhcHR1cmVkICYgaGFuZGxlZCBieSB0aGUgaW5kaWNhdGVkIHN0YWdlLlxuXHQgKiovXG5cdHAuX2hhbmRsZVBvaW50ZXJVcCA9IGZ1bmN0aW9uKGlkLCBlLCBjbGVhciwgb3duZXIpIHtcblx0XHR2YXIgbmV4dFN0YWdlID0gdGhpcy5fbmV4dFN0YWdlLCBvID0gdGhpcy5fZ2V0UG9pbnRlckRhdGEoaWQpO1xuXHRcdGlmICh0aGlzLl9wcmV2U3RhZ2UgJiYgb3duZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm47IH0gLy8gcmVkdW5kYW50IGxpc3RlbmVyLlxuXHRcdFxuXHRcdHZhciB0YXJnZXQ9bnVsbCwgb1RhcmdldCA9IG8udGFyZ2V0O1xuXHRcdGlmICghb3duZXIgJiYgKG9UYXJnZXQgfHwgbmV4dFN0YWdlKSkgeyB0YXJnZXQgPSB0aGlzLl9nZXRPYmplY3RzVW5kZXJQb2ludChvLngsIG8ueSwgbnVsbCwgdHJ1ZSk7IH1cblx0XHRcblx0XHRpZiAoby5kb3duKSB7IHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudCh0aGlzLCBcInN0YWdlbW91c2V1cFwiLCBmYWxzZSwgaWQsIG8sIGUsIHRhcmdldCk7IG8uZG93biA9IGZhbHNlOyB9XG5cdFx0XG5cdFx0aWYgKHRhcmdldCA9PSBvVGFyZ2V0KSB7IHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudChvVGFyZ2V0LCBcImNsaWNrXCIsIHRydWUsIGlkLCBvLCBlKTsgfVxuXHRcdHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudChvVGFyZ2V0LCBcInByZXNzdXBcIiwgdHJ1ZSwgaWQsIG8sIGUpO1xuXHRcdFxuXHRcdGlmIChjbGVhcikge1xuXHRcdFx0aWYgKGlkPT10aGlzLl9wcmltYXJ5UG9pbnRlcklEKSB7IHRoaXMuX3ByaW1hcnlQb2ludGVySUQgPSBudWxsOyB9XG5cdFx0XHRkZWxldGUodGhpcy5fcG9pbnRlckRhdGFbaWRdKTtcblx0XHR9IGVsc2UgeyBvLnRhcmdldCA9IG51bGw7IH1cblx0XHRcblx0XHRuZXh0U3RhZ2UmJm5leHRTdGFnZS5faGFuZGxlUG9pbnRlclVwKGlkLCBlLCBjbGVhciwgb3duZXIgfHwgdGFyZ2V0ICYmIHRoaXMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNb3VzZURvd25cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcblx0ICoqL1xuXHRwLl9oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbihlKSB7XG5cdFx0dGhpcy5faGFuZGxlUG9pbnRlckRvd24oLTEsIGUsIGUucGFnZVgsIGUucGFnZVkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVQb2ludGVyRG93blxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlWFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGFnZVlcblx0ICogQHBhcmFtIHtTdGFnZX0gb3duZXIgSW5kaWNhdGVzIHRoYXQgdGhlIGV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gY2FwdHVyZWQgJiBoYW5kbGVkIGJ5IHRoZSBpbmRpY2F0ZWQgc3RhZ2UuXG5cdCAqKi9cblx0cC5faGFuZGxlUG9pbnRlckRvd24gPSBmdW5jdGlvbihpZCwgZSwgcGFnZVgsIHBhZ2VZLCBvd25lcikge1xuXHRcdGlmICh0aGlzLnByZXZlbnRTZWxlY3Rpb24pIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG5cdFx0aWYgKHRoaXMuX3ByaW1hcnlQb2ludGVySUQgPT0gbnVsbCB8fCBpZCA9PT0gLTEpIHsgdGhpcy5fcHJpbWFyeVBvaW50ZXJJRCA9IGlkOyB9IC8vIG1vdXNlIGFsd2F5cyB0YWtlcyBvdmVyLlxuXHRcdFxuXHRcdGlmIChwYWdlWSAhPSBudWxsKSB7IHRoaXMuX3VwZGF0ZVBvaW50ZXJQb3NpdGlvbihpZCwgZSwgcGFnZVgsIHBhZ2VZKTsgfVxuXHRcdHZhciB0YXJnZXQgPSBudWxsLCBuZXh0U3RhZ2UgPSB0aGlzLl9uZXh0U3RhZ2UsIG8gPSB0aGlzLl9nZXRQb2ludGVyRGF0YShpZCk7XG5cdFx0aWYgKCFvd25lcikgeyB0YXJnZXQgPSBvLnRhcmdldCA9IHRoaXMuX2dldE9iamVjdHNVbmRlclBvaW50KG8ueCwgby55LCBudWxsLCB0cnVlKTsgfVxuXG5cdFx0aWYgKG8uaW5Cb3VuZHMpIHsgdGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRoaXMsIFwic3RhZ2Vtb3VzZWRvd25cIiwgZmFsc2UsIGlkLCBvLCBlLCB0YXJnZXQpOyBvLmRvd24gPSB0cnVlOyB9XG5cdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRhcmdldCwgXCJtb3VzZWRvd25cIiwgdHJ1ZSwgaWQsIG8sIGUpO1xuXHRcdFxuXHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl9oYW5kbGVQb2ludGVyRG93bihpZCwgZSwgcGFnZVgsIHBhZ2VZLCBvd25lciB8fCB0YXJnZXQgJiYgdGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3Rlc3RNb3VzZU92ZXJcblx0ICogQHBhcmFtIHtCb29sZWFufSBjbGVhciBJZiB0cnVlLCBjbGVhcnMgdGhlIG1vdXNlb3ZlciAvIHJvbGxvdmVyIChpZS4gbm8gdGFyZ2V0KVxuXHQgKiBAcGFyYW0ge1N0YWdlfSBvd25lciBJbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgaGFzIGFscmVhZHkgYmVlbiBjYXB0dXJlZCAmIGhhbmRsZWQgYnkgdGhlIGluZGljYXRlZCBzdGFnZS5cblx0ICogQHBhcmFtIHtTdGFnZX0gZXZlbnRUYXJnZXQgVGhlIHN0YWdlIHRoYXQgdGhlIGN1cnNvciBpcyBhY3RpdmVseSBvdmVyLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fdGVzdE1vdXNlT3ZlciA9IGZ1bmN0aW9uKGNsZWFyLCBvd25lciwgZXZlbnRUYXJnZXQpIHtcblx0XHRpZiAodGhpcy5fcHJldlN0YWdlICYmIG93bmVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9IC8vIHJlZHVuZGFudCBsaXN0ZW5lci5cblx0XHRcblx0XHR2YXIgbmV4dFN0YWdlID0gdGhpcy5fbmV4dFN0YWdlO1xuXHRcdGlmICghdGhpcy5fbW91c2VPdmVySW50ZXJ2YWxJRCkge1xuXHRcdFx0Ly8gbm90IGVuYWJsZWQgZm9yIG1vdXNlb3ZlciwgYnV0IHNob3VsZCBzdGlsbCByZWxheSB0aGUgZXZlbnQuXG5cdFx0XHRuZXh0U3RhZ2UmJm5leHRTdGFnZS5fdGVzdE1vdXNlT3ZlcihjbGVhciwgb3duZXIsIGV2ZW50VGFyZ2V0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIG8gPSB0aGlzLl9nZXRQb2ludGVyRGF0YSgtMSk7XG5cdFx0Ly8gb25seSB1cGRhdGUgaWYgdGhlIG1vdXNlIHBvc2l0aW9uIGhhcyBjaGFuZ2VkLiBUaGlzIHByb3ZpZGVzIGEgbG90IG9mIG9wdGltaXphdGlvbiwgYnV0IGhhcyBzb21lIHRyYWRlLW9mZnMuXG5cdFx0aWYgKCFvIHx8ICghY2xlYXIgJiYgdGhpcy5tb3VzZVggPT0gdGhpcy5fbW91c2VPdmVyWCAmJiB0aGlzLm1vdXNlWSA9PSB0aGlzLl9tb3VzZU92ZXJZICYmIHRoaXMubW91c2VJbkJvdW5kcykpIHsgcmV0dXJuOyB9XG5cdFx0XG5cdFx0dmFyIGUgPSBvLnBvc0V2dE9iajtcblx0XHR2YXIgaXNFdmVudFRhcmdldCA9IGV2ZW50VGFyZ2V0IHx8IGUmJihlLnRhcmdldCA9PSB0aGlzLmNhbnZhcyk7XG5cdFx0dmFyIHRhcmdldD1udWxsLCBjb21tb24gPSAtMSwgY3Vyc29yPVwiXCIsIHQsIGksIGw7XG5cdFx0XG5cdFx0aWYgKCFvd25lciAmJiAoY2xlYXIgfHwgdGhpcy5tb3VzZUluQm91bmRzICYmIGlzRXZlbnRUYXJnZXQpKSB7XG5cdFx0XHR0YXJnZXQgPSB0aGlzLl9nZXRPYmplY3RzVW5kZXJQb2ludCh0aGlzLm1vdXNlWCwgdGhpcy5tb3VzZVksIG51bGwsIHRydWUpO1xuXHRcdFx0dGhpcy5fbW91c2VPdmVyWCA9IHRoaXMubW91c2VYO1xuXHRcdFx0dGhpcy5fbW91c2VPdmVyWSA9IHRoaXMubW91c2VZO1xuXHRcdH1cblxuXHRcdHZhciBvbGRMaXN0ID0gdGhpcy5fbW91c2VPdmVyVGFyZ2V0fHxbXTtcblx0XHR2YXIgb2xkVGFyZ2V0ID0gb2xkTGlzdFtvbGRMaXN0Lmxlbmd0aC0xXTtcblx0XHR2YXIgbGlzdCA9IHRoaXMuX21vdXNlT3ZlclRhcmdldCA9IFtdO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgYW5jZXN0b3IgbGlzdCBhbmQgY2hlY2sgZm9yIGN1cnNvcjpcblx0XHR0ID0gdGFyZ2V0O1xuXHRcdHdoaWxlICh0KSB7XG5cdFx0XHRsaXN0LnVuc2hpZnQodCk7XG5cdFx0XHRpZiAoIWN1cnNvcikgeyBjdXJzb3IgPSB0LmN1cnNvcjsgfVxuXHRcdFx0dCA9IHQucGFyZW50O1xuXHRcdH1cblx0XHR0aGlzLmNhbnZhcy5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG5cdFx0aWYgKCFvd25lciAmJiBldmVudFRhcmdldCkgeyBldmVudFRhcmdldC5jYW52YXMuc3R5bGUuY3Vyc29yID0gY3Vyc29yOyB9XG5cblx0XHQvLyBmaW5kIGNvbW1vbiBhbmNlc3Rvcjpcblx0XHRmb3IgKGk9MCxsPWxpc3QubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0aWYgKGxpc3RbaV0gIT0gb2xkTGlzdFtpXSkgeyBicmVhazsgfVxuXHRcdFx0Y29tbW9uID0gaTtcblx0XHR9XG5cblx0XHRpZiAob2xkVGFyZ2V0ICE9IHRhcmdldCkge1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KG9sZFRhcmdldCwgXCJtb3VzZW91dFwiLCB0cnVlLCAtMSwgbywgZSwgdGFyZ2V0KTtcblx0XHR9XG5cblx0XHRmb3IgKGk9b2xkTGlzdC5sZW5ndGgtMTsgaT5jb21tb247IGktLSkge1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KG9sZExpc3RbaV0sIFwicm9sbG91dFwiLCBmYWxzZSwgLTEsIG8sIGUsIHRhcmdldCk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpPWxpc3QubGVuZ3RoLTE7IGk+Y29tbW9uOyBpLS0pIHtcblx0XHRcdHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudChsaXN0W2ldLCBcInJvbGxvdmVyXCIsIGZhbHNlLCAtMSwgbywgZSwgb2xkVGFyZ2V0KTtcblx0XHR9XG5cblx0XHRpZiAob2xkVGFyZ2V0ICE9IHRhcmdldCkge1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRhcmdldCwgXCJtb3VzZW92ZXJcIiwgdHJ1ZSwgLTEsIG8sIGUsIG9sZFRhcmdldCk7XG5cdFx0fVxuXHRcdFxuXHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl90ZXN0TW91c2VPdmVyKGNsZWFyLCBvd25lciB8fCB0YXJnZXQgJiYgdGhpcywgZXZlbnRUYXJnZXQgfHwgaXNFdmVudFRhcmdldCAmJiB0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlRG91YmxlQ2xpY2tcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcblx0ICogQHBhcmFtIHtTdGFnZX0gb3duZXIgSW5kaWNhdGVzIHRoYXQgdGhlIGV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gY2FwdHVyZWQgJiBoYW5kbGVkIGJ5IHRoZSBpbmRpY2F0ZWQgc3RhZ2UuXG5cdCAqKi9cblx0cC5faGFuZGxlRG91YmxlQ2xpY2sgPSBmdW5jdGlvbihlLCBvd25lcikge1xuXHRcdHZhciB0YXJnZXQ9bnVsbCwgbmV4dFN0YWdlPXRoaXMuX25leHRTdGFnZSwgbz10aGlzLl9nZXRQb2ludGVyRGF0YSgtMSk7XG5cdFx0aWYgKCFvd25lcikge1xuXHRcdFx0dGFyZ2V0ID0gdGhpcy5fZ2V0T2JqZWN0c1VuZGVyUG9pbnQoby54LCBvLnksIG51bGwsIHRydWUpO1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRhcmdldCwgXCJkYmxjbGlja1wiLCB0cnVlLCAtMSwgbywgZSk7XG5cdFx0fVxuXHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl9oYW5kbGVEb3VibGVDbGljayhlLCBvd25lciB8fCB0YXJnZXQgJiYgdGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2Rpc3BhdGNoTW91c2VFdmVudFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gdGFyZ2V0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYnViYmxlc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9pbnRlcklkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvXG5cdCAqIEBwYXJhbSB7TW91c2VFdmVudH0gW25hdGl2ZUV2ZW50XVxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IFtyZWxhdGVkVGFyZ2V0XVxuXHQgKiovXG5cdHAuX2Rpc3BhdGNoTW91c2VFdmVudCA9IGZ1bmN0aW9uKHRhcmdldCwgdHlwZSwgYnViYmxlcywgcG9pbnRlcklkLCBvLCBuYXRpdmVFdmVudCwgcmVsYXRlZFRhcmdldCkge1xuXHRcdC8vIFRPRE86IG1pZ2h0IGJlIHdvcnRoIGVpdGhlciByZXVzaW5nIE1vdXNlRXZlbnQgaW5zdGFuY2VzLCBvciBhZGRpbmcgYSB3aWxsVHJpZ2dlciBtZXRob2QgdG8gYXZvaWQgR0MuXG5cdFx0aWYgKCF0YXJnZXQgfHwgKCFidWJibGVzICYmICF0YXJnZXQuaGFzRXZlbnRMaXN0ZW5lcih0eXBlKSkpIHsgcmV0dXJuOyB9XG5cdFx0Lypcblx0XHQvLyBUT0RPOiBhY2NvdW50IGZvciBzdGFnZSB0cmFuc2Zvcm1hdGlvbnM/XG5cdFx0dGhpcy5fbXR4ID0gdGhpcy5nZXRDb25jYXRlbmF0ZWRNYXRyaXgodGhpcy5fbXR4KS5pbnZlcnQoKTtcblx0XHR2YXIgcHQgPSB0aGlzLl9tdHgudHJhbnNmb3JtUG9pbnQoby54LCBvLnkpO1xuXHRcdHZhciBldnQgPSBuZXcgY3JlYXRlanMuTW91c2VFdmVudCh0eXBlLCBidWJibGVzLCBmYWxzZSwgcHQueCwgcHQueSwgbmF0aXZlRXZlbnQsIHBvaW50ZXJJZCwgcG9pbnRlcklkPT10aGlzLl9wcmltYXJ5UG9pbnRlcklEIHx8IHBvaW50ZXJJZD09LTEsIG8ucmF3WCwgby5yYXdZKTtcblx0XHQqL1xuXHRcdHZhciBldnQgPSBuZXcgY3JlYXRlanMuTW91c2VFdmVudCh0eXBlLCBidWJibGVzLCBmYWxzZSwgby54LCBvLnksIG5hdGl2ZUV2ZW50LCBwb2ludGVySWQsIHBvaW50ZXJJZCA9PT0gdGhpcy5fcHJpbWFyeVBvaW50ZXJJRCB8fCBwb2ludGVySWQgPT09IC0xLCBvLnJhd1gsIG8ucmF3WSwgcmVsYXRlZFRhcmdldCk7XG5cdFx0dGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZ0KTtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLlN0YWdlID0gY3JlYXRlanMucHJvbW90ZShTdGFnZSwgXCJDb250YWluZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQml0bWFwLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XG5cdC8qKlxuXHQgKiBBIEJpdG1hcCByZXByZXNlbnRzIGFuIEltYWdlLCBDYW52YXMsIG9yIFZpZGVvIGluIHRoZSBkaXNwbGF5IGxpc3QuIEEgQml0bWFwIGNhbiBiZSBpbnN0YW50aWF0ZWQgdXNpbmcgYW4gZXhpc3Rpbmdcblx0ICogSFRNTCBlbGVtZW50LCBvciBhIHN0cmluZy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBiaXRtYXAgPSBuZXcgY3JlYXRlanMuQml0bWFwKFwiaW1hZ2VQYXRoLmpwZ1wiKTtcblx0ICpcblx0ICogPHN0cm9uZz5Ob3Rlczo8L3N0cm9uZz5cblx0ICogPG9sPlxuXHQgKiAgICAgPGxpPldoZW4gYSBzdHJpbmcgcGF0aCBvciBpbWFnZSB0YWcgdGhhdCBpcyBub3QgeWV0IGxvYWRlZCBpcyB1c2VkLCB0aGUgc3RhZ2UgbWF5IG5lZWQgdG8gYmUgcmVkcmF3biBiZWZvcmUgaXRcblx0ICogICAgICB3aWxsIGJlIGRpc3BsYXllZC48L2xpPlxuXHQgKiAgICAgPGxpPkJpdG1hcHMgd2l0aCBhbiBTVkcgc291cmNlIGN1cnJlbnRseSB3aWxsIG5vdCByZXNwZWN0IGFuIGFscGhhIHZhbHVlIG90aGVyIHRoYW4gMCBvciAxLiBUbyBnZXQgYXJvdW5kIHRoaXMsXG5cdCAqICAgICB0aGUgQml0bWFwIGNhbiBiZSBjYWNoZWQuPC9saT5cblx0ICogICAgIDxsaT5CaXRtYXBzIHdpdGggYW4gU1ZHIHNvdXJjZSB3aWxsIHRhaW50IHRoZSBjYW52YXMgd2l0aCBjcm9zcy1vcmlnaW4gZGF0YSwgd2hpY2ggcHJldmVudHMgaW50ZXJhY3Rpdml0eS4gVGhpc1xuXHQgKiAgICAgaGFwcGVucyBpbiBhbGwgYnJvd3NlcnMgZXhjZXB0IHJlY2VudCBGaXJlZm94IGJ1aWxkcy48L2xpPlxuXHQgKiAgICAgPGxpPkltYWdlcyBsb2FkZWQgY3Jvc3Mtb3JpZ2luIHdpbGwgdGhyb3cgY3Jvc3Mtb3JpZ2luIHNlY3VyaXR5IGVycm9ycyB3aGVuIGludGVyYWN0ZWQgd2l0aCB1c2luZyBhIG1vdXNlLCB1c2luZ1xuXHQgKiAgICAgbWV0aG9kcyBzdWNoIGFzIGBnZXRPYmplY3RVbmRlclBvaW50YCwgb3IgdXNpbmcgZmlsdGVycywgb3IgY2FjaGluZy4gWW91IGNhbiBnZXQgYXJvdW5kIHRoaXMgYnkgc2V0dGluZ1xuXHQgKiAgICAgYGNyb3NzT3JpZ2luYCBmbGFncyBvbiB5b3VyIGltYWdlcyBiZWZvcmUgcGFzc2luZyB0aGVtIHRvIEVhc2VsSlMsIGVnOiBgaW1nLmNyb3NzT3JpZ2luPVwiQW5vbnltb3VzXCI7YDwvbGk+XG5cdCAqIDwvb2w+XG5cdCAqXG5cdCAqIEBjbGFzcyBCaXRtYXBcblx0ICogQGV4dGVuZHMgRGlzcGxheU9iamVjdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50IHwgU3RyaW5nfSBpbWFnZU9yVXJpIFRoZSBzb3VyY2Ugb2JqZWN0IG9yIFVSSSB0byBhbiBpbWFnZSB0b1xuXHQgKiBkaXNwbGF5LiBUaGlzIGNhbiBiZSBlaXRoZXIgYW4gSW1hZ2UsIENhbnZhcywgb3IgVmlkZW8gb2JqZWN0LCBvciBhIHN0cmluZyBVUkkgdG8gYW4gaW1hZ2UgZmlsZSB0byBsb2FkIGFuZCB1c2UuXG5cdCAqIElmIGl0IGlzIGEgVVJJLCBhIG5ldyBJbWFnZSBvYmplY3Qgd2lsbCBiZSBjb25zdHJ1Y3RlZCBhbmQgYXNzaWduZWQgdG8gdGhlIC5pbWFnZSBwcm9wZXJ0eS5cblx0ICoqL1xuXHRmdW5jdGlvbiBCaXRtYXAoaW1hZ2VPclVyaSkge1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9jb25zdHJ1Y3RvcigpO1xuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgaW1hZ2UgdG8gcmVuZGVyLiBUaGlzIGNhbiBiZSBhbiBJbWFnZSwgYSBDYW52YXMsIG9yIGEgVmlkZW8uIE5vdCBhbGwgYnJvd3NlcnMgKGVzcGVjaWFsbHlcblx0XHQgKiBtb2JpbGUgYnJvd3NlcnMpIHN1cHBvcnQgZHJhd2luZyB2aWRlbyB0byBhIGNhbnZhcy5cblx0XHQgKiBAcHJvcGVydHkgaW1hZ2Vcblx0XHQgKiBAdHlwZSBIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50XG5cdFx0ICoqL1xuXHRcdGlmICh0eXBlb2YgaW1hZ2VPclVyaSA9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR0aGlzLmltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcblx0XHRcdHRoaXMuaW1hZ2Uuc3JjID0gaW1hZ2VPclVyaTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5pbWFnZSA9IGltYWdlT3JVcmk7XG5cdFx0fVxuXHRcblx0XHQvKipcblx0XHQgKiBTcGVjaWZpZXMgYW4gYXJlYSBvZiB0aGUgc291cmNlIGltYWdlIHRvIGRyYXcuIElmIG9taXR0ZWQsIHRoZSB3aG9sZSBpbWFnZSB3aWxsIGJlIGRyYXduLlxuXHRcdCAqIE5vdGUgdGhhdCB2aWRlbyBzb3VyY2VzIG11c3QgaGF2ZSBhIHdpZHRoIC8gaGVpZ2h0IHNldCB0byB3b3JrIGNvcnJlY3RseSB3aXRoIGBzb3VyY2VSZWN0YC5cblx0XHQgKiBAcHJvcGVydHkgc291cmNlUmVjdFxuXHRcdCAqIEB0eXBlIFJlY3RhbmdsZVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnNvdXJjZVJlY3QgPSBudWxsO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEJpdG1hcCwgY3JlYXRlanMuRGlzcGxheU9iamVjdCk7XG5cdFxuXHRcbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQ29uc3RydWN0b3IgYWxpYXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBUaGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zLlxuXHQgKiBTdWJjbGFzc2VzIHNob3VsZCBiZSB1cGRhdGVkIHRvIHVzZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kc1wifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBgY3JlYXRlanMucHJvbW90ZSgpYFxuXHQgKiovXG5cdHAuaW5pdGlhbGl6ZSA9IEJpdG1hcDsgLy8gVE9ETzogZGVwcmVjYXRlZC5cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhcy5cblx0ICogVGhpcyBkb2VzIG5vdCBhY2NvdW50IGZvciB3aGV0aGVyIGl0IHdvdWxkIGJlIHZpc2libGUgd2l0aGluIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBzdGFnZS5cblx0ICpcblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGlzVmlzaWJsZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhc1xuXHQgKiovXG5cdHAuaXNWaXNpYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGltYWdlID0gdGhpcy5pbWFnZTtcblx0XHR2YXIgaGFzQ29udGVudCA9IHRoaXMuY2FjaGVDYW52YXMgfHwgKGltYWdlICYmIChpbWFnZS5uYXR1cmFsV2lkdGggfHwgaW1hZ2UuZ2V0Q29udGV4dCB8fCBpbWFnZS5yZWFkeVN0YXRlID49IDIpKTtcblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9IDAgJiYgdGhpcy5zY2FsZVkgIT0gMCAmJiBoYXNDb250ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgdGhlIGRpc3BsYXkgb2JqZWN0IGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IGlnbm9yaW5nIGl0cyB2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBhbmQgdHJhbnNmb3JtLlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cblx0ICpcblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGRyYXdcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbaWdub3JlQ2FjaGU9ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkcmF3IG9wZXJhdGlvbiBzaG91bGQgaWdub3JlIGFueSBjdXJyZW50IGNhY2hlLlxuXHQgKiBGb3IgZXhhbXBsZSwgdXNlZCBmb3IgZHJhd2luZyB0aGUgY2FjaGUgKHRvIHByZXZlbnQgaXQgZnJvbSBzaW1wbHkgZHJhd2luZyBhbiBleGlzdGluZyBjYWNoZSBiYWNrXG5cdCAqIGludG8gaXRzZWxmKS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICoqL1xuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGlnbm9yZUNhY2hlKSB7XG5cdFx0aWYgKHRoaXMuRGlzcGxheU9iamVjdF9kcmF3KGN0eCwgaWdub3JlQ2FjaGUpIHx8ICF0aGlzLmltYWdlKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0dmFyIGltZyA9IHRoaXMuaW1hZ2UsIHJlY3QgPSB0aGlzLnNvdXJjZVJlY3Q7XG5cdFx0aWYgKHJlY3QpIHtcblx0XHRcdC8vIHNvbWUgYnJvd3NlcnMgY2hva2Ugb24gb3V0IG9mIGJvdW5kIHZhbHVlcywgc28gd2UnbGwgZml4IHRoZW06XG5cdFx0XHR2YXIgeDEgPSByZWN0LngsIHkxID0gcmVjdC55LCB4MiA9IHgxICsgcmVjdC53aWR0aCwgeTIgPSB5MSArIHJlY3QuaGVpZ2h0LCB4ID0gMCwgeSA9IDAsIHcgPSBpbWcud2lkdGgsIGggPSBpbWcuaGVpZ2h0O1xuXHRcdFx0aWYgKHgxIDwgMCkgeyB4IC09IHgxOyB4MSA9IDA7IH1cblx0XHRcdGlmICh4MiA+IHcpIHsgeDIgPSB3OyB9XG5cdFx0XHRpZiAoeTEgPCAwKSB7IHkgLT0geTE7IHkxID0gMDsgfVxuXHRcdFx0aWYgKHkyID4gaCkgeyB5MiA9IGg7IH1cblx0XHRcdGN0eC5kcmF3SW1hZ2UoaW1nLCB4MSwgeTEsIHgyLXgxLCB5Mi15MSwgeCwgeSwgeDIteDEsIHkyLXkxKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblx0XG5cdC8vTm90ZSwgdGhlIGRvYyBzZWN0aW9ucyBiZWxvdyBkb2N1bWVudCB1c2luZyB0aGUgc3BlY2lmaWVkIEFQSXMgKGZyb20gRGlzcGxheU9iamVjdCkgIGZyb21cblx0Ly9CaXRtYXAuIFRoaXMgaXMgd2h5IHRoZXkgaGF2ZSBubyBtZXRob2QgaW1wbGVtZW50YXRpb25zLlxuXHRcblx0LyoqXG5cdCAqIEJlY2F1c2UgdGhlIGNvbnRlbnQgb2YgYSBCaXRtYXAgaXMgYWxyZWFkeSBpbiBhIHNpbXBsZSBmb3JtYXQsIGNhY2hlIGlzIHVubmVjZXNzYXJ5IGZvciBCaXRtYXAgaW5zdGFuY2VzLlxuXHQgKiBZb3Ugc2hvdWxkIDxiPm5vdDwvYj4gY2FjaGUgQml0bWFwIGluc3RhbmNlcyBhcyBpdCBjYW4gZGVncmFkZSBwZXJmb3JtYW5jZS5cblx0ICpcblx0ICogPHN0cm9uZz5Ib3dldmVyOiBJZiB5b3Ugd2FudCB0byB1c2UgYSBmaWx0ZXIgb24gYSBCaXRtYXAsIHlvdSA8ZW0+TVVTVDwvZW0+IGNhY2hlIGl0LCBvciBpdCB3aWxsIG5vdCB3b3JrLjwvc3Ryb25nPlxuXHQgKiBUbyBzZWUgdGhlIEFQSSBmb3IgY2FjaGluZywgcGxlYXNlIHZpc2l0IHRoZSBEaXNwbGF5T2JqZWN0IHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvY2FjaGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLlxuXHQgKiBAbWV0aG9kIGNhY2hlXG5cdCAqKi9cblx0XG5cdC8qKlxuXHQgKiBCZWNhdXNlIHRoZSBjb250ZW50IG9mIGEgQml0bWFwIGlzIGFscmVhZHkgaW4gYSBzaW1wbGUgZm9ybWF0LCBjYWNoZSBpcyB1bm5lY2Vzc2FyeSBmb3IgQml0bWFwIGluc3RhbmNlcy5cblx0ICogWW91IHNob3VsZCA8Yj5ub3Q8L2I+IGNhY2hlIEJpdG1hcCBpbnN0YW5jZXMgYXMgaXQgY2FuIGRlZ3JhZGUgcGVyZm9ybWFuY2UuXG5cdCAqXG5cdCAqIDxzdHJvbmc+SG93ZXZlcjogSWYgeW91IHdhbnQgdG8gdXNlIGEgZmlsdGVyIG9uIGEgQml0bWFwLCB5b3UgPGVtPk1VU1Q8L2VtPiBjYWNoZSBpdCwgb3IgaXQgd2lsbCBub3Qgd29yay48L3N0cm9uZz5cblx0ICogVG8gc2VlIHRoZSBBUEkgZm9yIGNhY2hpbmcsIHBsZWFzZSB2aXNpdCB0aGUgRGlzcGxheU9iamVjdCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2NhY2hlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC5cblx0ICogQG1ldGhvZCB1cGRhdGVDYWNoZVxuXHQgKiovXG5cdFxuXHQvKipcblx0ICogQmVjYXVzZSB0aGUgY29udGVudCBvZiBhIEJpdG1hcCBpcyBhbHJlYWR5IGluIGEgc2ltcGxlIGZvcm1hdCwgY2FjaGUgaXMgdW5uZWNlc3NhcnkgZm9yIEJpdG1hcCBpbnN0YW5jZXMuXG5cdCAqIFlvdSBzaG91bGQgPGI+bm90PC9iPiBjYWNoZSBCaXRtYXAgaW5zdGFuY2VzIGFzIGl0IGNhbiBkZWdyYWRlIHBlcmZvcm1hbmNlLlxuXHQgKlxuXHQgKiA8c3Ryb25nPkhvd2V2ZXI6IElmIHlvdSB3YW50IHRvIHVzZSBhIGZpbHRlciBvbiBhIEJpdG1hcCwgeW91IDxlbT5NVVNUPC9lbT4gY2FjaGUgaXQsIG9yIGl0IHdpbGwgbm90IHdvcmsuPC9zdHJvbmc+XG5cdCAqIFRvIHNlZSB0aGUgQVBJIGZvciBjYWNoaW5nLCBwbGVhc2UgdmlzaXQgdGhlIERpc3BsYXlPYmplY3Qge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9jYWNoZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuXG5cdCAqIEBtZXRob2QgdW5jYWNoZVxuXHQgKiovXG5cblx0LyoqXG5cdCAqIERvY2NlZCBpbiBzdXBlcmNsYXNzLlxuXHQgKi9cblx0cC5nZXRCb3VuZHMgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IHRoaXMuRGlzcGxheU9iamVjdF9nZXRCb3VuZHMoKTtcblx0XHRpZiAocmVjdCkgeyByZXR1cm4gcmVjdDsgfVxuXHRcdHZhciBpbWFnZSA9IHRoaXMuaW1hZ2UsIG8gPSB0aGlzLnNvdXJjZVJlY3QgfHwgaW1hZ2U7XG5cdFx0dmFyIGhhc0NvbnRlbnQgPSAoaW1hZ2UgJiYgKGltYWdlLm5hdHVyYWxXaWR0aCB8fCBpbWFnZS5nZXRDb250ZXh0IHx8IGltYWdlLnJlYWR5U3RhdGUgPj0gMikpO1xuXHRcdHJldHVybiBoYXNDb250ZW50ID8gdGhpcy5fcmVjdGFuZ2xlLnNldFZhbHVlcygwLCAwLCBvLndpZHRoLCBvLmhlaWdodCkgOiBudWxsO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgQml0bWFwIGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge0JpdG1hcH0gYSBjbG9uZSBvZiB0aGUgQml0bWFwIGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbyA9IG5ldyBCaXRtYXAodGhpcy5pbWFnZSk7XG5cdFx0aWYgKHRoaXMuc291cmNlUmVjdCkgeyBvLnNvdXJjZVJlY3QgPSB0aGlzLnNvdXJjZVJlY3QuY2xvbmUoKTsgfVxuXHRcdHRoaXMuX2Nsb25lUHJvcHMobyk7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0JpdG1hcCAobmFtZT1cIisgIHRoaXMubmFtZSArXCIpXVwiO1xuXHR9O1xuXG5cdFxuXHRjcmVhdGVqcy5CaXRtYXAgPSBjcmVhdGVqcy5wcm9tb3RlKEJpdG1hcCwgXCJEaXNwbGF5T2JqZWN0XCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNwcml0ZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogRGlzcGxheXMgYSBmcmFtZSBvciBzZXF1ZW5jZSBvZiBmcmFtZXMgKGllLiBhbiBhbmltYXRpb24pIGZyb20gYSBTcHJpdGVTaGVldCBpbnN0YW5jZS4gQSBzcHJpdGUgc2hlZXQgaXMgYSBzZXJpZXMgb2Zcblx0ICogaW1hZ2VzICh1c3VhbGx5IGFuaW1hdGlvbiBmcmFtZXMpIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgaW1hZ2UuIEZvciBleGFtcGxlLCBhbiBhbmltYXRpb24gY29uc2lzdGluZyBvZiA4IDEwMHgxMDBcblx0ICogaW1hZ2VzIGNvdWxkIGJlIGNvbWJpbmVkIGludG8gYSA0MDB4MjAwIHNwcml0ZSBzaGVldCAoNCBmcmFtZXMgYWNyb3NzIGJ5IDIgaGlnaCkuIFlvdSBjYW4gZGlzcGxheSBpbmRpdmlkdWFsIGZyYW1lcyxcblx0ICogcGxheSBmcmFtZXMgYXMgYW4gYW5pbWF0aW9uLCBhbmQgZXZlbiBzZXF1ZW5jZSBhbmltYXRpb25zIHRvZ2V0aGVyLlxuXHQgKlxuXHQgKiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHNldHRpbmcgdXAgZnJhbWVzIGFuZCBhbmltYXRpb25zLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIGluc3RhbmNlID0gbmV3IGNyZWF0ZWpzLlNwcml0ZShzcHJpdGVTaGVldCk7XG5cdCAqICAgICAgaW5zdGFuY2UuZ290b0FuZFN0b3AoXCJmcmFtZU5hbWVcIik7XG5cdCAqXG5cdCAqIFVudGlsIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9nb3RvQW5kU3RvcFwifX17ey9jcm9zc0xpbmt9fSBvciB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX0gaXMgY2FsbGVkLFxuXHQgKiBvbmx5IHRoZSBmaXJzdCBkZWZpbmVkIGZyYW1lIGRlZmluZWQgaW4gdGhlIHNwcml0ZSBzaGVldCB3aWxsIGJlIGRpc3BsYXllZC5cblx0ICpcblx0ICogQGNsYXNzIFNwcml0ZVxuXHQgKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge1Nwcml0ZVNoZWV0fSBzcHJpdGVTaGVldCBUaGUgU3ByaXRlU2hlZXQgaW5zdGFuY2UgdG8gcGxheSBiYWNrLiBUaGlzIGluY2x1ZGVzIHRoZSBzb3VyY2UgaW1hZ2UocyksIGZyYW1lXG5cdCAqIGRpbWVuc2lvbnMsIGFuZCBmcmFtZSBkYXRhLiBTZWUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gW2ZyYW1lT3JBbmltYXRpb25dIFRoZSBmcmFtZSBudW1iZXIgb3IgYW5pbWF0aW9uIHRvIHBsYXkgaW5pdGlhbGx5LlxuXHQgKiovXG5cdGZ1bmN0aW9uIFNwcml0ZShzcHJpdGVTaGVldCwgZnJhbWVPckFuaW1hdGlvbikge1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9jb25zdHJ1Y3RvcigpO1xuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgZnJhbWUgaW5kZXggdGhhdCB3aWxsIGJlIGRyYXduIHdoZW4gZHJhdyBpcyBjYWxsZWQuIE5vdGUgdGhhdCB3aXRoIHNvbWUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBkZWZpbml0aW9ucywgdGhpcyB3aWxsIGFkdmFuY2Ugbm9uLXNlcXVlbnRpYWxseS4gVGhpcyB3aWxsIGFsd2F5cyBiZSBhbiBpbnRlZ2VyIHZhbHVlLlxuXHRcdCAqIEBwcm9wZXJ0eSBjdXJyZW50RnJhbWVcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5jdXJyZW50RnJhbWUgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgcGxheWluZyBhbmltYXRpb24uXG5cdFx0ICogQHByb3BlcnR5IGN1cnJlbnRBbmltYXRpb25cblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBmaW5hbFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBQcmV2ZW50cyB0aGUgYW5pbWF0aW9uIGZyb20gYWR2YW5jaW5nIGVhY2ggdGljayBhdXRvbWF0aWNhbGx5LiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIGNyZWF0ZSBhIHNwcml0ZVxuXHRcdCAqIHNoZWV0IG9mIGljb25zLCBzZXQgcGF1c2VkIHRvIHRydWUsIGFuZCBkaXNwbGF5IHRoZSBhcHByb3ByaWF0ZSBpY29uIGJ5IHNldHRpbmcgPGNvZGU+Y3VycmVudEZyYW1lPC9jb2RlPi5cblx0XHQgKiBAcHJvcGVydHkgcGF1c2VkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiovXG5cdFx0dGhpcy5wYXVzZWQgPSB0cnVlO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgU3ByaXRlU2hlZXQgaW5zdGFuY2UgdG8gcGxheSBiYWNrLiBUaGlzIGluY2x1ZGVzIHRoZSBzb3VyY2UgaW1hZ2UsIGZyYW1lIGRpbWVuc2lvbnMsIGFuZCBmcmFtZVxuXHRcdCAqIGRhdGEuIFNlZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgc3ByaXRlU2hlZXRcblx0XHQgKiBAdHlwZSB7U3ByaXRlU2hlZXR9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMuc3ByaXRlU2hlZXQgPSBzcHJpdGVTaGVldDtcblx0XG5cdFx0LyoqXG5cdFx0ICogU3BlY2lmaWVzIHRoZSBjdXJyZW50IGZyYW1lIGluZGV4IHdpdGhpbiB0aGUgY3VycmVudGx5IHBsYXlpbmcgYW5pbWF0aW9uLiBXaGVuIHBsYXlpbmcgbm9ybWFsbHksIHRoaXMgd2lsbCBpbmNyZWFzZVxuXHRcdCAqIGZyb20gMCB0byBuLTEsIHdoZXJlIG4gaXMgdGhlIG51bWJlciBvZiBmcmFtZXMgaW4gdGhlIGN1cnJlbnQgYW5pbWF0aW9uLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBjb3VsZCBiZSBhIG5vbi1pbnRlZ2VyIHZhbHVlIGlmXG5cdFx0ICogdXNpbmcgdGltZS1iYXNlZCBwbGF5YmFjayAoc2VlIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9mcmFtZXJhdGVcIn19e3svY3Jvc3NMaW5rfX0sIG9yIGlmIHRoZSBhbmltYXRpb24ncyBzcGVlZCBpc1xuXHRcdCAqIG5vdCBhbiBpbnRlZ2VyLlxuXHRcdCAqIEBwcm9wZXJ0eSBjdXJyZW50QW5pbWF0aW9uRnJhbWVcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWUgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBCeSBkZWZhdWx0IFNwcml0ZSBpbnN0YW5jZXMgYWR2YW5jZSBvbmUgZnJhbWUgcGVyIHRpY2suIFNwZWNpZnlpbmcgYSBmcmFtZXJhdGUgZm9yIHRoZSBTcHJpdGUgKG9yIGl0cyByZWxhdGVkXG5cdFx0ICogU3ByaXRlU2hlZXQpIHdpbGwgY2F1c2UgaXQgdG8gYWR2YW5jZSBiYXNlZCBvbiBlbGFwc2VkIHRpbWUgYmV0d2VlbiB0aWNrcyBhcyBhcHByb3ByaWF0ZSB0byBtYWludGFpbiB0aGUgdGFyZ2V0XG5cdFx0ICogZnJhbWVyYXRlLlxuXHRcdCAqXG5cdFx0ICogRm9yIGV4YW1wbGUsIGlmIGEgU3ByaXRlIHdpdGggYSBmcmFtZXJhdGUgb2YgMTAgaXMgcGxhY2VkIG9uIGEgU3RhZ2UgYmVpbmcgdXBkYXRlZCBhdCA0MGZwcywgdGhlbiB0aGUgU3ByaXRlIHdpbGxcblx0XHQgKiBhZHZhbmNlIHJvdWdobHkgb25lIGZyYW1lIGV2ZXJ5IDQgdGlja3MuIFRoaXMgd2lsbCBub3QgYmUgZXhhY3QsIGJlY2F1c2UgdGhlIHRpbWUgYmV0d2VlbiBlYWNoIHRpY2sgd2lsbFxuXHRcdCAqIHZhcnkgc2xpZ2h0bHkgYmV0d2VlbiBmcmFtZXMuXG5cdFx0ICpcblx0XHQgKiBUaGlzIGZlYXR1cmUgaXMgZGVwZW5kZW50IG9uIHRoZSB0aWNrIGV2ZW50IG9iamVjdCAob3IgYW4gb2JqZWN0IHdpdGggYW4gYXBwcm9wcmlhdGUgXCJkZWx0YVwiIHByb3BlcnR5KSBiZWluZ1xuXHRcdCAqIHBhc3NlZCBpbnRvIHt7I2Nyb3NzTGluayBcIlN0YWdlL3VwZGF0ZVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgZnJhbWVyYXRlXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMuZnJhbWVyYXRlID0gMDtcblx0XG5cdFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQ3VycmVudCBhbmltYXRpb24gb2JqZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBfYW5pbWF0aW9uXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLl9hbmltYXRpb24gPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBDdXJyZW50IGZyYW1lIGluZGV4LlxuXHRcdCAqIEBwcm9wZXJ0eSBfY3VycmVudEZyYW1lXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqKi9cblx0XHR0aGlzLl9jdXJyZW50RnJhbWUgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFNraXBzIHRoZSBuZXh0IGF1dG8gYWR2YW5jZS4gVXNlZCBieSBnb3RvQW5kUGxheSB0byBhdm9pZCBpbW1lZGlhdGVseSBqdW1waW5nIHRvIHRoZSBuZXh0IGZyYW1lXG5cdFx0ICogQHByb3BlcnR5IF9za2lwQWR2YW5jZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqKi9cblx0XHR0aGlzLl9za2lwQWR2YW5jZSA9IGZhbHNlO1xuXHRcdFxuXHRcdFxuXHRcdGlmIChmcmFtZU9yQW5pbWF0aW9uICE9IG51bGwpIHsgdGhpcy5nb3RvQW5kUGxheShmcmFtZU9yQW5pbWF0aW9uKTsgfVxuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFNwcml0ZSwgY3JlYXRlanMuRGlzcGxheU9iamVjdCk7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdG9yIGFsaWFzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gVGhpcyBtZXRob2Qgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucy5cblx0ICogU3ViY2xhc3NlcyBzaG91bGQgYmUgdXBkYXRlZCB0byB1c2Uge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZHNcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2YgYGNyZWF0ZWpzLnByb21vdGUoKWBcblx0ICoqL1xuXHRwLmluaXRpYWxpemUgPSBTcHJpdGU7IC8vIFRPRE86IERlcHJlY2F0ZWQuIFRoaXMgaXMgZm9yIGJhY2t3YXJkcyBzdXBwb3J0IG9mIEZsYXNoQ0Mgc3ByaXRlc2hlZXQgZXhwb3J0LlxuXG5cbi8vIGV2ZW50czpcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiBhbiBhbmltYXRpb24gcmVhY2hlcyBpdHMgZW5kcy5cblx0ICogQGV2ZW50IGFuaW1hdGlvbmVuZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdGhhdCBqdXN0IGVuZGVkLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmV4dCBUaGUgbmFtZSBvZiB0aGUgbmV4dCBhbmltYXRpb24gdGhhdCB3aWxsIGJlIHBsYXllZCwgb3IgbnVsbC4gVGhpcyB3aWxsIGJlIHRoZSBzYW1lIGFzIG5hbWUgaWYgdGhlIGFuaW1hdGlvbiBpcyBsb29waW5nLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgYW55IHRpbWUgdGhlIGN1cnJlbnQgZnJhbWUgY2hhbmdlcy4gRm9yIGV4YW1wbGUsIHRoaXMgY291bGQgYmUgZHVlIHRvIGF1dG9tYXRpYyBhZHZhbmNlbWVudCBvbiBhIHRpY2ssXG5cdCAqIG9yIGNhbGxpbmcgZ290b0FuZFBsYXkoKSBvciBnb3RvQW5kU3RvcCgpLlxuXHQgKiBAZXZlbnQgY2hhbmdlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICovXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzXG5cdCAqKi9cblx0cC5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFzQ29udGVudCA9IHRoaXMuY2FjaGVDYW52YXMgfHwgdGhpcy5zcHJpdGVTaGVldC5jb21wbGV0ZTtcblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9IDAgJiYgdGhpcy5zY2FsZVkgIT0gMCAmJiBoYXNDb250ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgdGhlIGRpc3BsYXkgb2JqZWN0IGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IGlnbm9yaW5nIGl0cyB2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBhbmQgdHJhbnNmb3JtLlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGRyYXdcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVDYWNoZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZHJhdyBvcGVyYXRpb24gc2hvdWxkIGlnbm9yZSBhbnkgY3VycmVudCBjYWNoZS5cblx0ICogRm9yIGV4YW1wbGUsIHVzZWQgZm9yIGRyYXdpbmcgdGhlIGNhY2hlICh0byBwcmV2ZW50IGl0IGZyb20gc2ltcGx5IGRyYXdpbmcgYW4gZXhpc3RpbmcgY2FjaGUgYmFja1xuXHQgKiBpbnRvIGl0c2VsZikuXG5cdCAqKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBpZ25vcmVDYWNoZSkge1xuXHRcdGlmICh0aGlzLkRpc3BsYXlPYmplY3RfZHJhdyhjdHgsIGlnbm9yZUNhY2hlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdHRoaXMuX25vcm1hbGl6ZUZyYW1lKCk7XG5cdFx0dmFyIG8gPSB0aGlzLnNwcml0ZVNoZWV0LmdldEZyYW1lKHRoaXMuX2N1cnJlbnRGcmFtZXwwKTtcblx0XHRpZiAoIW8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dmFyIHJlY3QgPSBvLnJlY3Q7XG5cdFx0aWYgKHJlY3Qud2lkdGggJiYgcmVjdC5oZWlnaHQpIHsgY3R4LmRyYXdJbWFnZShvLmltYWdlLCByZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQsIC1vLnJlZ1gsIC1vLnJlZ1ksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTsgfVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8vTm90ZSwgdGhlIGRvYyBzZWN0aW9ucyBiZWxvdyBkb2N1bWVudCB1c2luZyB0aGUgc3BlY2lmaWVkIEFQSXMgKGZyb20gRGlzcGxheU9iamVjdCkgIGZyb21cblx0Ly9CaXRtYXAuIFRoaXMgaXMgd2h5IHRoZXkgaGF2ZSBubyBtZXRob2QgaW1wbGVtZW50YXRpb25zLlxuXG5cdC8qKlxuXHQgKiBCZWNhdXNlIHRoZSBjb250ZW50IG9mIGEgU3ByaXRlIGlzIGFscmVhZHkgaW4gYSByYXN0ZXIgZm9ybWF0LCBjYWNoZSBpcyB1bm5lY2Vzc2FyeSBmb3IgU3ByaXRlIGluc3RhbmNlcy5cblx0ICogWW91IHNob3VsZCBub3QgY2FjaGUgU3ByaXRlIGluc3RhbmNlcyBhcyBpdCBjYW4gZGVncmFkZSBwZXJmb3JtYW5jZS5cblx0ICogQG1ldGhvZCBjYWNoZVxuXHQgKiovXG5cblx0LyoqXG5cdCAqIEJlY2F1c2UgdGhlIGNvbnRlbnQgb2YgYSBTcHJpdGUgaXMgYWxyZWFkeSBpbiBhIHJhc3RlciBmb3JtYXQsIGNhY2hlIGlzIHVubmVjZXNzYXJ5IGZvciBTcHJpdGUgaW5zdGFuY2VzLlxuXHQgKiBZb3Ugc2hvdWxkIG5vdCBjYWNoZSBTcHJpdGUgaW5zdGFuY2VzIGFzIGl0IGNhbiBkZWdyYWRlIHBlcmZvcm1hbmNlLlxuXHQgKiBAbWV0aG9kIHVwZGF0ZUNhY2hlXG5cdCAqKi9cblxuXHQvKipcblx0ICogQmVjYXVzZSB0aGUgY29udGVudCBvZiBhIFNwcml0ZSBpcyBhbHJlYWR5IGluIGEgcmFzdGVyIGZvcm1hdCwgY2FjaGUgaXMgdW5uZWNlc3NhcnkgZm9yIFNwcml0ZSBpbnN0YW5jZXMuXG5cdCAqIFlvdSBzaG91bGQgbm90IGNhY2hlIFNwcml0ZSBpbnN0YW5jZXMgYXMgaXQgY2FuIGRlZ3JhZGUgcGVyZm9ybWFuY2UuXG5cdCAqIEBtZXRob2QgdW5jYWNoZVxuXHQgKiovXG5cblx0LyoqXG5cdCAqIFBsYXkgKHVucGF1c2UpIHRoZSBjdXJyZW50IGFuaW1hdGlvbi4gVGhlIFNwcml0ZSB3aWxsIGJlIHBhdXNlZCBpZiBlaXRoZXIge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL3N0b3BcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogb3Ige3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319IGlzIGNhbGxlZC4gU2luZ2xlIGZyYW1lIGFuaW1hdGlvbnMgd2lsbCByZW1haW5cblx0ICogdW5jaGFuZ2VkLlxuXHQgKiBAbWV0aG9kIHBsYXlcblx0ICoqL1xuXHRwLnBsYXkgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9wIHBsYXlpbmcgYSBydW5uaW5nIGFuaW1hdGlvbi4gVGhlIFNwcml0ZSB3aWxsIGJlIHBsYXlpbmcgaWYge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGlzIGNhbGxlZC4gTm90ZSB0aGF0IGNhbGxpbmcge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319IG9yIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9wbGF5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdpbGwgcmVzdW1lIHBsYXliYWNrLlxuXHQgKiBAbWV0aG9kIHN0b3Bcblx0ICoqL1xuXHRwLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnBhdXNlZCA9IHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgcGF1c2VkIHRvIGZhbHNlIGFuZCBwbGF5cyB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbiBuYW1lLCBuYW1lZCBmcmFtZSwgb3IgZnJhbWUgbnVtYmVyLlxuXHQgKiBAbWV0aG9kIGdvdG9BbmRQbGF5XG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gZnJhbWVPckFuaW1hdGlvbiBUaGUgZnJhbWUgbnVtYmVyIG9yIGFuaW1hdGlvbiBuYW1lIHRoYXQgdGhlIHBsYXloZWFkIHNob3VsZCBtb3ZlIHRvXG5cdCAqIGFuZCBiZWdpbiBwbGF5aW5nLlxuXHQgKiovXG5cdHAuZ290b0FuZFBsYXkgPSBmdW5jdGlvbihmcmFtZU9yQW5pbWF0aW9uKSB7XG5cdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9za2lwQWR2YW5jZSA9IHRydWU7XG5cdFx0dGhpcy5fZ290byhmcmFtZU9yQW5pbWF0aW9uKTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyBwYXVzZWQgdG8gdHJ1ZSBhbmQgc2Vla3MgdG8gdGhlIHNwZWNpZmllZCBhbmltYXRpb24gbmFtZSwgbmFtZWQgZnJhbWUsIG9yIGZyYW1lIG51bWJlci5cblx0ICogQG1ldGhvZCBnb3RvQW5kU3RvcFxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGZyYW1lT3JBbmltYXRpb24gVGhlIGZyYW1lIG51bWJlciBvciBhbmltYXRpb24gbmFtZSB0aGF0IHRoZSBwbGF5aGVhZCBzaG91bGQgbW92ZSB0b1xuXHQgKiBhbmQgc3RvcC5cblx0ICoqL1xuXHRwLmdvdG9BbmRTdG9wID0gZnVuY3Rpb24oZnJhbWVPckFuaW1hdGlvbikge1xuXHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0XHR0aGlzLl9nb3RvKGZyYW1lT3JBbmltYXRpb24pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZHZhbmNlcyB0aGUgcGxheWhlYWQuIFRoaXMgb2NjdXJzIGF1dG9tYXRpY2FsbHkgZWFjaCB0aWNrIGJ5IGRlZmF1bHQuXG5cdCAqIEBwYXJhbSBbdGltZV0ge051bWJlcn0gVGhlIGFtb3VudCBvZiB0aW1lIGluIG1zIHRvIGFkdmFuY2UgYnkuIE9ubHkgYXBwbGljYWJsZSBpZiBmcmFtZXJhdGUgaXMgc2V0IG9uIHRoZSBTcHJpdGVcblx0ICogb3IgaXRzIFNwcml0ZVNoZWV0LlxuXHQgKiBAbWV0aG9kIGFkdmFuY2Vcblx0Ki9cblx0cC5hZHZhbmNlID0gZnVuY3Rpb24odGltZSkge1xuXHRcdHZhciBmcHMgPSB0aGlzLmZyYW1lcmF0ZSB8fCB0aGlzLnNwcml0ZVNoZWV0LmZyYW1lcmF0ZTtcblx0XHR2YXIgdCA9IChmcHMgJiYgdGltZSAhPSBudWxsKSA/IHRpbWUvKDEwMDAvZnBzKSA6IDE7XG5cdFx0dGhpcy5fbm9ybWFsaXplRnJhbWUodCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIHt7I2Nyb3NzTGluayBcIlJlY3RhbmdsZVwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZSBkZWZpbmluZyB0aGUgYm91bmRzIG9mIHRoZSBjdXJyZW50IGZyYW1lIHJlbGF0aXZlIHRvXG5cdCAqIHRoZSBvcmlnaW4uIEZvciBleGFtcGxlLCBhIDkwIHggNzAgZnJhbWUgd2l0aCA8Y29kZT5yZWdYPTUwPC9jb2RlPiBhbmQgPGNvZGU+cmVnWT00MDwvY29kZT4gd291bGQgcmV0dXJuIGFcblx0ICogcmVjdGFuZ2xlIHdpdGggW3g9LTUwLCB5PS00MCwgd2lkdGg9OTAsIGhlaWdodD03MF0uIFRoaXMgaWdub3JlcyB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGRpc3BsYXkgb2JqZWN0LlxuXHQgKlxuXHQgKiBBbHNvIHNlZSB0aGUgU3ByaXRlU2hlZXQge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXQvZ2V0RnJhbWVCb3VuZHNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXHQgKiBAbWV0aG9kIGdldEJvdW5kc1xuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IEEgUmVjdGFuZ2xlIGluc3RhbmNlLiBSZXR1cm5zIG51bGwgaWYgdGhlIGZyYW1lIGRvZXMgbm90IGV4aXN0LCBvciB0aGUgaW1hZ2UgaXMgbm90IGZ1bGx5XG5cdCAqIGxvYWRlZC5cblx0ICoqL1xuXHRwLmdldEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFRPRE86IHNob3VsZCB0aGlzIG5vcm1hbGl6ZUZyYW1lP1xuXHRcdHJldHVybiB0aGlzLkRpc3BsYXlPYmplY3RfZ2V0Qm91bmRzKCkgfHwgdGhpcy5zcHJpdGVTaGVldC5nZXRGcmFtZUJvdW5kcyh0aGlzLmN1cnJlbnRGcmFtZSwgdGhpcy5fcmVjdGFuZ2xlKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBTcHJpdGUgaW5zdGFuY2UuIE5vdGUgdGhhdCB0aGUgc2FtZSBTcHJpdGVTaGVldCBpcyBzaGFyZWQgYmV0d2VlbiBjbG9uZWRcblx0ICogaW5zdGFuY2VzLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge1Nwcml0ZX0gYSBjbG9uZSBvZiB0aGUgU3ByaXRlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmVQcm9wcyhuZXcgU3ByaXRlKHRoaXMuc3ByaXRlU2hlZXQpKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1Nwcml0ZSAobmFtZT1cIisgIHRoaXMubmFtZSArXCIpXVwiO1xuXHR9O1xuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9jbG9uZVByb3BzXG5cdCAqIEBwYXJhbSB7U3ByaXRlfSBvXG5cdCAqIEByZXR1cm4ge1Nwcml0ZX0gb1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fY2xvbmVQcm9wcyA9IGZ1bmN0aW9uKG8pIHtcblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfX2Nsb25lUHJvcHMobyk7XG5cdFx0by5jdXJyZW50RnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcblx0XHRvLmN1cnJlbnRBbmltYXRpb24gPSB0aGlzLmN1cnJlbnRBbmltYXRpb247XG5cdFx0by5wYXVzZWQgPSB0aGlzLnBhdXNlZDtcblx0XHRvLmN1cnJlbnRBbmltYXRpb25GcmFtZSA9IHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lO1xuXHRcdG8uZnJhbWVyYXRlID0gdGhpcy5mcmFtZXJhdGU7XG5cdFx0XG5cdFx0by5fYW5pbWF0aW9uID0gdGhpcy5fYW5pbWF0aW9uO1xuXHRcdG8uX2N1cnJlbnRGcmFtZSA9IHRoaXMuX2N1cnJlbnRGcmFtZTtcblx0XHRvLl9za2lwQWR2YW5jZSA9IHRoaXMuX3NraXBBZHZhbmNlO1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoZSA8Y29kZT5jdXJyZW50RnJhbWU8L2NvZGU+IGlmIHBhdXNlZCBpcyBub3QgdHJ1ZS4gVGhpcyBpcyBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSB7eyNjcm9zc0xpbmsgXCJTdGFnZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB0aWNrcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IGV2dE9iaiBBbiBldmVudCBvYmplY3QgdGhhdCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gYWxsIHRpY2sgbGlzdGVuZXJzLiBUaGlzIG9iamVjdCBpcyByZXVzZWQgYmV0d2VlbiBkaXNwYXRjaGVycyB0byByZWR1Y2UgY29uc3RydWN0aW9uICYgR0MgY29zdHMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQG1ldGhvZCBfdGlja1xuXHQgKiovXG5cdHAuX3RpY2sgPSBmdW5jdGlvbihldnRPYmopIHtcblx0XHRpZiAoIXRoaXMucGF1c2VkKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3NraXBBZHZhbmNlKSB7IHRoaXMuYWR2YW5jZShldnRPYmomJmV2dE9iai5kZWx0YSk7IH1cblx0XHRcdHRoaXMuX3NraXBBZHZhbmNlID0gZmFsc2U7XG5cdFx0fVxuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9fdGljayhldnRPYmopO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE5vcm1hbGl6ZXMgdGhlIGN1cnJlbnQgZnJhbWUsIGFkdmFuY2luZyBhbmltYXRpb25zIGFuZCBkaXNwYXRjaGluZyBjYWxsYmFja3MgYXMgYXBwcm9wcmlhdGUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQG1ldGhvZCBfbm9ybWFsaXplRnJhbWVcblx0ICoqL1xuXHRwLl9ub3JtYWxpemVGcmFtZSA9IGZ1bmN0aW9uKGZyYW1lRGVsdGEpIHtcblx0XHRmcmFtZURlbHRhID0gZnJhbWVEZWx0YSB8fCAwO1xuXHRcdHZhciBhbmltYXRpb24gPSB0aGlzLl9hbmltYXRpb247XG5cdFx0dmFyIHBhdXNlZCA9IHRoaXMucGF1c2VkO1xuXHRcdHZhciBmcmFtZSA9IHRoaXMuX2N1cnJlbnRGcmFtZTtcblx0XHR2YXIgbDtcblx0XHRcblx0XHRpZiAoYW5pbWF0aW9uKSB7XG5cdFx0XHR2YXIgc3BlZWQgPSBhbmltYXRpb24uc3BlZWQgfHwgMTtcblx0XHRcdHZhciBhbmltRnJhbWUgPSB0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZTtcblx0XHRcdGwgPSBhbmltYXRpb24uZnJhbWVzLmxlbmd0aDtcblx0XHRcdGlmIChhbmltRnJhbWUgKyBmcmFtZURlbHRhICogc3BlZWQgPj0gbCkge1xuXHRcdFx0XHR2YXIgbmV4dCA9IGFuaW1hdGlvbi5uZXh0O1xuXHRcdFx0XHRpZiAodGhpcy5fZGlzcGF0Y2hBbmltYXRpb25FbmQoYW5pbWF0aW9uLCBmcmFtZSwgcGF1c2VkLCBuZXh0LCBsIC0gMSkpIHtcblx0XHRcdFx0XHQvLyBzb21ldGhpbmcgY2hhbmdlZCBpbiB0aGUgZXZlbnQgc3RhY2ssIHNvIHdlIHNob3VsZG4ndCBtYWtlIGFueSBtb3JlIGNoYW5nZXMgaGVyZS5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH0gZWxzZSBpZiAobmV4dCkge1xuXHRcdFx0XHRcdC8vIHNlcXVlbmNlLiBBdXRvbWF0aWNhbGx5IGNhbGxzIF9ub3JtYWxpemVGcmFtZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgZnJhbWVzLlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9nb3RvKG5leHQsIGZyYW1lRGVsdGEgLSAobCAtIGFuaW1GcmFtZSkgLyBzcGVlZCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gZW5kLlxuXHRcdFx0XHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRhbmltRnJhbWUgPSBhbmltYXRpb24uZnJhbWVzLmxlbmd0aCAtIDE7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFuaW1GcmFtZSArPSBmcmFtZURlbHRhICogc3BlZWQ7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZSA9IGFuaW1GcmFtZTtcblx0XHRcdHRoaXMuX2N1cnJlbnRGcmFtZSA9IGFuaW1hdGlvbi5mcmFtZXNbYW5pbUZyYW1lIHwgMF1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZnJhbWUgPSAodGhpcy5fY3VycmVudEZyYW1lICs9IGZyYW1lRGVsdGEpO1xuXHRcdFx0bCA9IHRoaXMuc3ByaXRlU2hlZXQuZ2V0TnVtRnJhbWVzKCk7XG5cdFx0XHRpZiAoZnJhbWUgPj0gbCAmJiBsID4gMCkge1xuXHRcdFx0XHRpZiAoIXRoaXMuX2Rpc3BhdGNoQW5pbWF0aW9uRW5kKGFuaW1hdGlvbiwgZnJhbWUsIHBhdXNlZCwgbCAtIDEpKSB7XG5cdFx0XHRcdFx0Ly8gbG9vcGVkLlxuXHRcdFx0XHRcdGlmICgodGhpcy5fY3VycmVudEZyYW1lIC09IGwpID49IGwpIHsgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZUZyYW1lKCk7IH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRmcmFtZSA9IHRoaXMuX2N1cnJlbnRGcmFtZSB8IDA7XG5cdFx0aWYgKHRoaXMuY3VycmVudEZyYW1lICE9IGZyYW1lKSB7XG5cdFx0XHR0aGlzLmN1cnJlbnRGcmFtZSA9IGZyYW1lO1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiY2hhbmdlXCIpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRGlzcGF0Y2hlcyB0aGUgXCJhbmltYXRpb25lbmRcIiBldmVudC4gUmV0dXJucyB0cnVlIGlmIGEgaGFuZGxlciBjaGFuZ2VkIHRoZSBhbmltYXRpb24gKGV4LiBjYWxsaW5nIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9zdG9wXCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX0sIGV0Yy4pXG5cdCAqIEBwcm9wZXJ0eSBfZGlzcGF0Y2hBbmltYXRpb25FbmRcblx0ICogQHByaXZhdGVcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHQgKiovXG5cdHAuX2Rpc3BhdGNoQW5pbWF0aW9uRW5kID0gZnVuY3Rpb24oYW5pbWF0aW9uLCBmcmFtZSwgcGF1c2VkLCBuZXh0LCBlbmQpIHtcblx0XHR2YXIgbmFtZSA9IGFuaW1hdGlvbiA/IGFuaW1hdGlvbi5uYW1lIDogbnVsbDtcblx0XHRpZiAodGhpcy5oYXNFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIpKSB7XG5cdFx0XHR2YXIgZXZ0ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiYW5pbWF0aW9uZW5kXCIpO1xuXHRcdFx0ZXZ0Lm5hbWUgPSBuYW1lO1xuXHRcdFx0ZXZ0Lm5leHQgPSBuZXh0O1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cdFx0fVxuXHRcdC8vIGRpZCB0aGUgYW5pbWF0aW9uIGdldCBjaGFuZ2VkIGluIHRoZSBldmVudCBzdGFjaz86XG5cdFx0dmFyIGNoYW5nZWQgPSAodGhpcy5fYW5pbWF0aW9uICE9IGFuaW1hdGlvbiB8fCB0aGlzLl9jdXJyZW50RnJhbWUgIT0gZnJhbWUpO1xuXHRcdC8vIGlmIHRoZSBhbmltYXRpb24gaGFzbid0IGNoYW5nZWQsIGJ1dCB0aGUgc3ByaXRlIHdhcyBwYXVzZWQsIHRoZW4gd2Ugd2FudCB0byBzdGljayB0byB0aGUgbGFzdCBmcmFtZTpcblx0XHRpZiAoIWNoYW5nZWQgJiYgIXBhdXNlZCAmJiB0aGlzLnBhdXNlZCkgeyB0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZSA9IGVuZDsgY2hhbmdlZCA9IHRydWU7IH1cblx0XHRyZXR1cm4gY2hhbmdlZDtcblx0fTtcblxuXHQvKipcblx0ICogTW92ZXMgdGhlIHBsYXloZWFkIHRvIHRoZSBzcGVjaWZpZWQgZnJhbWUgbnVtYmVyIG9yIGFuaW1hdGlvbi5cblx0ICogQG1ldGhvZCBfZ290b1xuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGZyYW1lT3JBbmltYXRpb24gVGhlIGZyYW1lIG51bWJlciBvciBhbmltYXRpb24gdGhhdCB0aGUgcGxheWhlYWQgc2hvdWxkIG1vdmUgdG8uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZyYW1lXSBUaGUgZnJhbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBnbyB0by4gRGVmYXVsdHMgdG8gMC5cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dvdG8gPSBmdW5jdGlvbihmcmFtZU9yQW5pbWF0aW9uLCBmcmFtZSkge1xuXHRcdHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lID0gMDtcblx0XHRpZiAoaXNOYU4oZnJhbWVPckFuaW1hdGlvbikpIHtcblx0XHRcdHZhciBkYXRhID0gdGhpcy5zcHJpdGVTaGVldC5nZXRBbmltYXRpb24oZnJhbWVPckFuaW1hdGlvbik7XG5cdFx0XHRpZiAoZGF0YSkge1xuXHRcdFx0XHR0aGlzLl9hbmltYXRpb24gPSBkYXRhO1xuXHRcdFx0XHR0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBmcmFtZU9yQW5pbWF0aW9uO1xuXHRcdFx0XHR0aGlzLl9ub3JtYWxpemVGcmFtZShmcmFtZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IHRoaXMuX2FuaW1hdGlvbiA9IG51bGw7XG5cdFx0XHR0aGlzLl9jdXJyZW50RnJhbWUgPSBmcmFtZU9yQW5pbWF0aW9uO1xuXHRcdFx0dGhpcy5fbm9ybWFsaXplRnJhbWUoKTtcblx0XHR9XG5cdH07XG5cblxuXHRjcmVhdGVqcy5TcHJpdGUgPSBjcmVhdGVqcy5wcm9tb3RlKFNwcml0ZSwgXCJEaXNwbGF5T2JqZWN0XCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNoYXBlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBBIFNoYXBlIGFsbG93cyB5b3UgdG8gZGlzcGxheSB2ZWN0b3IgYXJ0IGluIHRoZSBkaXNwbGF5IGxpc3QuIEl0IGNvbXBvc2l0ZXMgYSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljc1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpbnN0YW5jZSB3aGljaCBleHBvc2VzIGFsbCBvZiB0aGUgdmVjdG9yIGRyYXdpbmcgbWV0aG9kcy4gVGhlIEdyYXBoaWNzIGluc3RhbmNlIGNhbiBiZSBzaGFyZWQgYmV0d2VlbiBtdWx0aXBsZSBTaGFwZVxuXHQgKiBpbnN0YW5jZXMgdG8gZGlzcGxheSB0aGUgc2FtZSB2ZWN0b3IgZ3JhcGhpY3Mgd2l0aCBkaWZmZXJlbnQgcG9zaXRpb25zIG9yIHRyYW5zZm9ybXMuXG5cdCAqXG5cdCAqIElmIHRoZSB2ZWN0b3IgYXJ0IHdpbGwgbm90XG5cdCAqIGNoYW5nZSBiZXR3ZWVuIGRyYXdzLCB5b3UgbWF5IHdhbnQgdG8gdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2NhY2hlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCB0byByZWR1Y2UgdGhlXG5cdCAqIHJlbmRlcmluZyBjb3N0LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIGdyYXBoaWNzID0gbmV3IGNyZWF0ZWpzLkdyYXBoaWNzKCkuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3UmVjdCgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqICAgICAgdmFyIHNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKGdyYXBoaWNzKTtcblx0ICpcblx0ICogICAgICAvL0FsdGVybmF0aXZlbHkgdXNlIGNhbiBhbHNvIHVzZSB0aGUgZ3JhcGhpY3MgcHJvcGVydHkgb2YgdGhlIFNoYXBlIGNsYXNzIHRvIHJlbmRlcmVyIHRoZSBzYW1lIGFzIGFib3ZlLlxuXHQgKiAgICAgIHZhciBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuXHQgKiAgICAgIHNoYXBlLmdyYXBoaWNzLmJlZ2luRmlsbChcIiNmZjAwMDBcIikuZHJhd1JlY3QoMCwgMCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiBAY2xhc3MgU2hhcGVcblx0ICogQGV4dGVuZHMgRGlzcGxheU9iamVjdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtHcmFwaGljc30gZ3JhcGhpY3MgT3B0aW9uYWwuIFRoZSBncmFwaGljcyBpbnN0YW5jZSB0byBkaXNwbGF5LiBJZiBudWxsLCBhIG5ldyBHcmFwaGljcyBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWQuXG5cdCAqKi9cblx0ZnVuY3Rpb24gU2hhcGUoZ3JhcGhpY3MpIHtcblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfY29uc3RydWN0b3IoKTtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIGdyYXBoaWNzIGluc3RhbmNlIHRvIGRpc3BsYXkuXG5cdFx0ICogQHByb3BlcnR5IGdyYXBoaWNzXG5cdFx0ICogQHR5cGUgR3JhcGhpY3Ncblx0XHQgKiovXG5cdFx0dGhpcy5ncmFwaGljcyA9IGdyYXBoaWNzID8gZ3JhcGhpY3MgOiBuZXcgY3JlYXRlanMuR3JhcGhpY3MoKTtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTaGFwZSwgY3JlYXRlanMuRGlzcGxheU9iamVjdCk7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBTaGFwZSB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBTaGFwZSB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzXG5cdCAqKi9cblx0cC5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFzQ29udGVudCA9IHRoaXMuY2FjaGVDYW52YXMgfHwgKHRoaXMuZ3JhcGhpY3MgJiYgIXRoaXMuZ3JhcGhpY3MuaXNFbXB0eSgpKTtcblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9IDAgJiYgdGhpcy5zY2FsZVkgIT0gMCAmJiBoYXNDb250ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgdGhlIFNoYXBlIGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IGlnbm9yaW5nIGl0cyB2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBhbmQgdHJhbnNmb3JtLiBSZXR1cm5zIHRydWUgaWZcblx0ICogdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cblx0ICpcblx0ICogPGk+Tk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLjwvaT5cblx0ICogQG1ldGhvZCBkcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZUNhY2hlPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZHJhdyBvcGVyYXRpb24gc2hvdWxkIGlnbm9yZSBhbnkgY3VycmVudCBjYWNoZS4gRm9yIGV4YW1wbGUsXG5cdCAqIHVzZWQgZm9yIGRyYXdpbmcgdGhlIGNhY2hlICh0byBwcmV2ZW50IGl0IGZyb20gc2ltcGx5IGRyYXdpbmcgYW4gZXhpc3RpbmcgY2FjaGUgYmFjayBpbnRvIGl0c2VsZikuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBpZ25vcmVDYWNoZSkge1xuXHRcdGlmICh0aGlzLkRpc3BsYXlPYmplY3RfZHJhdyhjdHgsIGlnbm9yZUNhY2hlKSkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdHRoaXMuZ3JhcGhpY3MuZHJhdyhjdHgsIHRoaXMpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBTaGFwZS4gU29tZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIHNwZWNpZmljIHRvIHRoaXMgaW5zdGFuY2UncyBjdXJyZW50IGNvbnRleHQgYXJlIHJldmVydGVkIHRvXG5cdCAqIHRoZWlyIGRlZmF1bHRzIChmb3IgZXhhbXBsZSAucGFyZW50KS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHJlY3Vyc2l2ZSBJZiB0cnVlLCB0aGlzIFNoYXBlJ3Mge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3NcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2Ugd2lsbCBhbHNvIGJlXG5cdCAqIGNsb25lZC4gSWYgZmFsc2UsIHRoZSBHcmFwaGljcyBpbnN0YW5jZSB3aWxsIGJlIHNoYXJlZCB3aXRoIHRoZSBuZXcgU2hhcGUuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKHJlY3Vyc2l2ZSkge1xuXHRcdHZhciBnID0gKHJlY3Vyc2l2ZSAmJiB0aGlzLmdyYXBoaWNzKSA/IHRoaXMuZ3JhcGhpY3MuY2xvbmUoKSA6IHRoaXMuZ3JhcGhpY3M7XG5cdFx0cmV0dXJuICB0aGlzLl9jbG9uZVByb3BzKG5ldyBTaGFwZShnKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltTaGFwZSAobmFtZT1cIisgIHRoaXMubmFtZSArXCIpXVwiO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuU2hhcGUgPSBjcmVhdGVqcy5wcm9tb3RlKFNoYXBlLCBcIkRpc3BsYXlPYmplY3RcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVGV4dC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogRGlzcGxheSBvbmUgb3IgbW9yZSBsaW5lcyBvZiBkeW5hbWljIHRleHQgKG5vdCB1c2VyIGVkaXRhYmxlKSBpbiB0aGUgZGlzcGxheSBsaXN0LiBMaW5lIHdyYXBwaW5nIHN1cHBvcnQgKHVzaW5nIHRoZVxuXHQgKiBsaW5lV2lkdGgpIGlzIHZlcnkgYmFzaWMsIHdyYXBwaW5nIG9uIHNwYWNlcyBhbmQgdGFicyBvbmx5LiBOb3RlIHRoYXQgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gVGV4dCwgeW91IGNhbiBwb3NpdGlvbiBIVE1MXG5cdCAqIHRleHQgYWJvdmUgb3IgYmVsb3cgdGhlIGNhbnZhcyByZWxhdGl2ZSB0byBpdGVtcyBpbiB0aGUgZGlzcGxheSBsaXN0IHVzaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2xvY2FsVG9HbG9iYWxcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLCBvciB1c2luZyB7eyNjcm9zc0xpbmsgXCJET01FbGVtZW50XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiA8Yj5QbGVhc2Ugbm90ZSB0aGF0IFRleHQgZG9lcyBub3Qgc3VwcG9ydCBIVE1MIHRleHQsIGFuZCBjYW4gb25seSBkaXNwbGF5IG9uZSBmb250IHN0eWxlIGF0IGEgdGltZS48L2I+IFRvIHVzZVxuXHQgKiBtdWx0aXBsZSBmb250IHN0eWxlcywgeW91IHdpbGwgbmVlZCB0byBjcmVhdGUgbXVsdGlwbGUgdGV4dCBpbnN0YW5jZXMsIGFuZCBwb3NpdGlvbiB0aGVtIG1hbnVhbGx5LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIHRleHQgPSBuZXcgY3JlYXRlanMuVGV4dChcIkhlbGxvIFdvcmxkXCIsIFwiMjBweCBBcmlhbFwiLCBcIiNmZjc3MDBcIik7XG5cdCAqICAgICAgdGV4dC54ID0gMTAwO1xuXHQgKiAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gXCJhbHBoYWJldGljXCI7XG5cdCAqXG5cdCAqIENyZWF0ZUpTIFRleHQgc3VwcG9ydHMgd2ViIGZvbnRzICh0aGUgc2FtZSBydWxlcyBhcyBDYW52YXMpLiBUaGUgZm9udCBtdXN0IGJlIGxvYWRlZCBhbmQgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyXG5cdCAqIGJlZm9yZSBpdCBjYW4gYmUgZGlzcGxheWVkLlxuXHQgKlxuXHQgKiA8c3Ryb25nPk5vdGU6PC9zdHJvbmc+IFRleHQgY2FuIGJlIGV4cGVuc2l2ZSB0byBnZW5lcmF0ZSwgc28gY2FjaGUgaW5zdGFuY2VzIHdoZXJlIHBvc3NpYmxlLiBCZSBhd2FyZSB0aGF0IG5vdCBhbGxcblx0ICogYnJvd3NlcnMgd2lsbCByZW5kZXIgVGV4dCBleGFjdGx5IHRoZSBzYW1lLlxuXHQgKiBAY2xhc3MgVGV4dFxuXHQgKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3RleHRdIFRoZSB0ZXh0IHRvIGRpc3BsYXkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbZm9udF0gVGhlIGZvbnQgc3R5bGUgdG8gdXNlLiBBbnkgdmFsaWQgdmFsdWUgZm9yIHRoZSBDU1MgZm9udCBhdHRyaWJ1dGUgaXMgYWNjZXB0YWJsZSAoZXguIFwiYm9sZFxuXHQgKiAzNnB4IEFyaWFsXCIpLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2NvbG9yXSBUaGUgY29sb3IgdG8gZHJhdyB0aGUgdGV4dCBpbi4gQW55IHZhbGlkIHZhbHVlIGZvciB0aGUgQ1NTIGNvbG9yIGF0dHJpYnV0ZSBpcyBhY2NlcHRhYmxlIChleC5cblx0ICogXCIjRjAwXCIsIFwicmVkXCIsIG9yIFwiI0ZGMDAwMFwiKS5cblx0ICoqL1xuXHRmdW5jdGlvbiBUZXh0KHRleHQsIGZvbnQsIGNvbG9yKSB7XG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X2NvbnN0cnVjdG9yKCk7XG5cdFx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0ZXh0IHRvIGRpc3BsYXkuXG5cdFx0ICogQHByb3BlcnR5IHRleHRcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiovXG5cdFx0dGhpcy50ZXh0ID0gdGV4dDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGZvbnQgc3R5bGUgdG8gdXNlLiBBbnkgdmFsaWQgdmFsdWUgZm9yIHRoZSBDU1MgZm9udCBhdHRyaWJ1dGUgaXMgYWNjZXB0YWJsZSAoZXguIFwiYm9sZCAzNnB4IEFyaWFsXCIpLlxuXHRcdCAqIEBwcm9wZXJ0eSBmb250XG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICoqL1xuXHRcdHRoaXMuZm9udCA9IGZvbnQ7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjb2xvciB0byBkcmF3IHRoZSB0ZXh0IGluLiBBbnkgdmFsaWQgdmFsdWUgZm9yIHRoZSBDU1MgY29sb3IgYXR0cmlidXRlIGlzIGFjY2VwdGFibGUgKGV4LiBcIiNGMDBcIikuIERlZmF1bHQgaXMgXCIjMDAwXCIuXG5cdFx0ICogSXQgd2lsbCBhbHNvIGFjY2VwdCB2YWxpZCBjYW52YXMgZmlsbFN0eWxlIHZhbHVlcy5cblx0XHQgKiBAcHJvcGVydHkgY29sb3Jcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiovXG5cdFx0dGhpcy5jb2xvciA9IGNvbG9yO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgaG9yaXpvbnRhbCB0ZXh0IGFsaWdubWVudC4gQW55IG9mIFwic3RhcnRcIiwgXCJlbmRcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIiwgYW5kIFwiY2VudGVyXCIuIEZvciBkZXRhaWxlZFxuXHRcdCAqIGluZm9ybWF0aW9uIHZpZXcgdGhlXG5cdFx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI3RleHQtc3R5bGVzXCI+XG5cdFx0ICogd2hhdHdnIHNwZWM8L2E+LiBEZWZhdWx0IGlzIFwibGVmdFwiLlxuXHRcdCAqIEBwcm9wZXJ0eSB0ZXh0QWxpZ25cblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiovXG5cdFx0dGhpcy50ZXh0QWxpZ24gPSBcImxlZnRcIjtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHZlcnRpY2FsIGFsaWdubWVudCBwb2ludCBvbiB0aGUgZm9udC4gQW55IG9mIFwidG9wXCIsIFwiaGFuZ2luZ1wiLCBcIm1pZGRsZVwiLCBcImFscGhhYmV0aWNcIiwgXCJpZGVvZ3JhcGhpY1wiLCBvclxuXHRcdCAqIFwiYm90dG9tXCIuIEZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiB2aWV3IHRoZSA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjdGV4dC1zdHlsZXNcIj5cblx0XHQgKiB3aGF0d2cgc3BlYzwvYT4uIERlZmF1bHQgaXMgXCJ0b3BcIi5cblx0XHQgKiBAcHJvcGVydHkgdGV4dEJhc2VsaW5lXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0Ki9cblx0XHR0aGlzLnRleHRCYXNlbGluZSA9IFwidG9wXCI7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBtYXhpbXVtIHdpZHRoIHRvIGRyYXcgdGhlIHRleHQuIElmIG1heFdpZHRoIGlzIHNwZWNpZmllZCAobm90IG51bGwpLCB0aGUgdGV4dCB3aWxsIGJlIGNvbmRlbnNlZCBvclxuXHRcdCAqIHNocnVuayB0byBtYWtlIGl0IGZpdCBpbiB0aGlzIHdpZHRoLiBGb3IgZGV0YWlsZWQgaW5mb3JtYXRpb24gdmlldyB0aGVcblx0XHQgKiA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjdGV4dC1zdHlsZXNcIj5cblx0XHQgKiB3aGF0d2cgc3BlYzwvYT4uXG5cdFx0ICogQHByb3BlcnR5IG1heFdpZHRoXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0Ki9cblx0XHR0aGlzLm1heFdpZHRoID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgZ3JlYXRlciB0aGFuIDAsIHRoZSB0ZXh0IHdpbGwgYmUgZHJhd24gYXMgYSBzdHJva2UgKG91dGxpbmUpIG9mIHRoZSBzcGVjaWZpZWQgd2lkdGguXG5cdFx0ICogQHByb3BlcnR5IG91dGxpbmVcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5vdXRsaW5lID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoZSBsaW5lIGhlaWdodCAodmVydGljYWwgZGlzdGFuY2UgYmV0d2VlbiBiYXNlbGluZXMpIGZvciBtdWx0aS1saW5lIHRleHQuIElmIG51bGwgb3IgMCxcblx0XHQgKiB0aGUgdmFsdWUgb2YgZ2V0TWVhc3VyZWRMaW5lSGVpZ2h0IGlzIHVzZWQuXG5cdFx0ICogQHByb3BlcnR5IGxpbmVIZWlnaHRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5saW5lSGVpZ2h0ID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoZSBtYXhpbXVtIHdpZHRoIGZvciBhIGxpbmUgb2YgdGV4dCBiZWZvcmUgaXQgaXMgd3JhcHBlZCB0byBtdWx0aXBsZSBsaW5lcy4gSWYgbnVsbCxcblx0XHQgKiB0aGUgdGV4dCB3aWxsIG5vdCBiZSB3cmFwcGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBsaW5lV2lkdGhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5saW5lV2lkdGggPSBudWxsO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFRleHQsIGNyZWF0ZWpzLkRpc3BsYXlPYmplY3QpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cdFxuLy8gc3RhdGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3dvcmtpbmdDb250ZXh0XG5cdCAqIEB0eXBlIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiovXG5cdHZhciBjYW52YXMgPSAoY3JlYXRlanMuY3JlYXRlQ2FudmFzP2NyZWF0ZWpzLmNyZWF0ZUNhbnZhcygpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikpO1xuXHRpZiAoY2FudmFzLmdldENvbnRleHQpIHsgVGV4dC5fd29ya2luZ0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpOyBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMTsgfVxuXHRcblx0XG4vLyBjb25zdGFudHM6XG5cdC8qKlxuXHQgKiBMb29rdXAgdGFibGUgZm9yIHRoZSByYXRpbyB0byBvZmZzZXQgYm91bmRzIHggY2FsY3VsYXRpb25zIGJhc2VkIG9uIHRoZSB0ZXh0QWxpZ24gcHJvcGVydHkuXG5cdCAqIEBwcm9wZXJ0eSBIX09GRlNFVFNcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRleHQuSF9PRkZTRVRTID0ge3N0YXJ0OiAwLCBsZWZ0OiAwLCBjZW50ZXI6IC0wLjUsIGVuZDogLTEsIHJpZ2h0OiAtMX07XG5cdFxuXHQvKipcblx0ICogTG9va3VwIHRhYmxlIGZvciB0aGUgcmF0aW8gdG8gb2Zmc2V0IGJvdW5kcyB5IGNhbGN1bGF0aW9ucyBiYXNlZCBvbiB0aGUgdGV4dEJhc2VsaW5lIHByb3BlcnR5LlxuXHQgKiBAcHJvcGVydHkgSF9PRkZTRVRTXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUZXh0LlZfT0ZGU0VUUyA9IHt0b3A6IDAsIGhhbmdpbmc6IC0wLjAxLCBtaWRkbGU6IC0wLjQsIGFscGhhYmV0aWM6IC0wLjgsIGlkZW9ncmFwaGljOiAtMC44NSwgYm90dG9tOiAtMX07XG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcblx0ICoqL1xuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYXNDb250ZW50ID0gdGhpcy5jYWNoZUNhbnZhcyB8fCAodGhpcy50ZXh0ICE9IG51bGwgJiYgdGhpcy50ZXh0ICE9PSBcIlwiKTtcblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9IDAgJiYgdGhpcy5zY2FsZVkgIT0gMCAmJiBoYXNDb250ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgdGhlIFRleHQgaW50byB0aGUgc3BlY2lmaWVkIGNvbnRleHQgaWdub3JpbmcgaXRzIHZpc2libGUsIGFscGhhLCBzaGFkb3csIGFuZCB0cmFuc2Zvcm0uXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZHJhdyB3YXMgaGFuZGxlZCAodXNlZnVsIGZvciBvdmVycmlkaW5nIGZ1bmN0aW9uYWxpdHkpLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgZHJhd1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZUNhY2hlIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkcmF3IG9wZXJhdGlvbiBzaG91bGQgaWdub3JlIGFueSBjdXJyZW50IGNhY2hlLlxuXHQgKiBGb3IgZXhhbXBsZSwgdXNlZCBmb3IgZHJhd2luZyB0aGUgY2FjaGUgKHRvIHByZXZlbnQgaXQgZnJvbSBzaW1wbHkgZHJhd2luZyBhbiBleGlzdGluZyBjYWNoZSBiYWNrXG5cdCAqIGludG8gaXRzZWxmKS5cblx0ICoqL1xuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGlnbm9yZUNhY2hlKSB7XG5cdFx0aWYgKHRoaXMuRGlzcGxheU9iamVjdF9kcmF3KGN0eCwgaWdub3JlQ2FjaGUpKSB7IHJldHVybiB0cnVlOyB9XG5cblx0XHR2YXIgY29sID0gdGhpcy5jb2xvciB8fCBcIiMwMDBcIjtcblx0XHRpZiAodGhpcy5vdXRsaW5lKSB7IGN0eC5zdHJva2VTdHlsZSA9IGNvbDsgY3R4LmxpbmVXaWR0aCA9IHRoaXMub3V0bGluZSoxOyB9XG5cdFx0ZWxzZSB7IGN0eC5maWxsU3R5bGUgPSBjb2w7IH1cblx0XHRcblx0XHR0aGlzLl9kcmF3VGV4dCh0aGlzLl9wcmVwQ29udGV4dChjdHgpKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbWVhc3VyZWQsIHVudHJhbnNmb3JtZWQgd2lkdGggb2YgdGhlIHRleHQgd2l0aG91dCB3cmFwcGluZy4gVXNlIGdldEJvdW5kcyBmb3IgYSBtb3JlIHJvYnVzdCB2YWx1ZS5cblx0ICogQG1ldGhvZCBnZXRNZWFzdXJlZFdpZHRoXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIG1lYXN1cmVkLCB1bnRyYW5zZm9ybWVkIHdpZHRoIG9mIHRoZSB0ZXh0LlxuXHQgKiovXG5cdHAuZ2V0TWVhc3VyZWRXaWR0aCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9nZXRNZWFzdXJlZFdpZHRoKHRoaXMudGV4dCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXBwcm94aW1hdGUgbGluZSBoZWlnaHQgb2YgdGhlIHRleHQsIGlnbm9yaW5nIHRoZSBsaW5lSGVpZ2h0IHByb3BlcnR5LiBUaGlzIGlzIGJhc2VkIG9uIHRoZSBtZWFzdXJlZFxuXHQgKiB3aWR0aCBvZiBhIFwiTVwiIGNoYXJhY3RlciBtdWx0aXBsaWVkIGJ5IDEuMiwgd2hpY2ggcHJvdmlkZXMgYW4gYXBwcm94aW1hdGUgbGluZSBoZWlnaHQgZm9yIG1vc3QgZm9udHMuXG5cdCAqIEBtZXRob2QgZ2V0TWVhc3VyZWRMaW5lSGVpZ2h0XG5cdCAqIEByZXR1cm4ge051bWJlcn0gYW4gYXBwcm94aW1hdGUgbGluZSBoZWlnaHQgb2YgdGhlIHRleHQsIGlnbm9yaW5nIHRoZSBsaW5lSGVpZ2h0IHByb3BlcnR5LiBUaGlzIGlzXG5cdCAqIGJhc2VkIG9uIHRoZSBtZWFzdXJlZCB3aWR0aCBvZiBhIFwiTVwiIGNoYXJhY3RlciBtdWx0aXBsaWVkIGJ5IDEuMiwgd2hpY2ggYXBwcm94aW1hdGVzIGVtIGZvciBtb3N0IGZvbnRzLlxuXHQgKiovXG5cdHAuZ2V0TWVhc3VyZWRMaW5lSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldE1lYXN1cmVkV2lkdGgoXCJNXCIpKjEuMjtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYXBwcm94aW1hdGUgaGVpZ2h0IG9mIG11bHRpLWxpbmUgdGV4dCBieSBtdWx0aXBseWluZyB0aGUgbnVtYmVyIG9mIGxpbmVzIGFnYWluc3QgZWl0aGVyIHRoZVxuXHQgKiA8Y29kZT5saW5lSGVpZ2h0PC9jb2RlPiAoaWYgc3BlY2lmaWVkKSBvciB7eyNjcm9zc0xpbmsgXCJUZXh0L2dldE1lYXN1cmVkTGluZUhlaWdodFwifX17ey9jcm9zc0xpbmt9fS4gTm90ZSB0aGF0XG5cdCAqIHRoaXMgb3BlcmF0aW9uIHJlcXVpcmVzIHRoZSB0ZXh0IGZsb3dpbmcgbG9naWMgdG8gcnVuLCB3aGljaCBoYXMgYW4gYXNzb2NpYXRlZCBDUFUgY29zdC5cblx0ICogQG1ldGhvZCBnZXRNZWFzdXJlZEhlaWdodFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBhcHByb3hpbWF0ZSBoZWlnaHQgb2YgdGhlIHVudHJhbnNmb3JtZWQgbXVsdGktbGluZSB0ZXh0LlxuXHQgKiovXG5cdHAuZ2V0TWVhc3VyZWRIZWlnaHQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZHJhd1RleHQobnVsbCx7fSkuaGVpZ2h0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEb2NjZWQgaW4gc3VwZXJjbGFzcy5cblx0ICovXG5cdHAuZ2V0Qm91bmRzID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSB0aGlzLkRpc3BsYXlPYmplY3RfZ2V0Qm91bmRzKCk7XG5cdFx0aWYgKHJlY3QpIHsgcmV0dXJuIHJlY3Q7IH1cblx0XHRpZiAodGhpcy50ZXh0ID09IG51bGwgfHwgdGhpcy50ZXh0ID09PSBcIlwiKSB7IHJldHVybiBudWxsOyB9XG5cdFx0dmFyIG8gPSB0aGlzLl9kcmF3VGV4dChudWxsLCB7fSk7XG5cdFx0dmFyIHcgPSAodGhpcy5tYXhXaWR0aCAmJiB0aGlzLm1heFdpZHRoIDwgby53aWR0aCkgPyB0aGlzLm1heFdpZHRoIDogby53aWR0aDtcblx0XHR2YXIgeCA9IHcgKiBUZXh0LkhfT0ZGU0VUU1t0aGlzLnRleHRBbGlnbnx8XCJsZWZ0XCJdO1xuXHRcdHZhciBsaW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0fHx0aGlzLmdldE1lYXN1cmVkTGluZUhlaWdodCgpO1xuXHRcdHZhciB5ID0gbGluZUhlaWdodCAqIFRleHQuVl9PRkZTRVRTW3RoaXMudGV4dEJhc2VsaW5lfHxcInRvcFwiXTtcblx0XHRyZXR1cm4gdGhpcy5fcmVjdGFuZ2xlLnNldFZhbHVlcyh4LCB5LCB3LCBvLmhlaWdodCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB3aWR0aCwgaGVpZ2h0LCBhbmQgbGluZXMgcHJvcGVydGllcy4gVGhlIHdpZHRoIGFuZCBoZWlnaHQgYXJlIHRoZSB2aXN1YWwgd2lkdGggYW5kIGhlaWdodFxuXHQgKiBvZiB0aGUgZHJhd24gdGV4dC4gVGhlIGxpbmVzIHByb3BlcnR5IGNvbnRhaW5zIGFuIGFycmF5IG9mIHN0cmluZ3MsIG9uZSBmb3Jcblx0ICogZWFjaCBsaW5lIG9mIHRleHQgdGhhdCB3aWxsIGJlIGRyYXduLCBhY2NvdW50aW5nIGZvciBsaW5lIGJyZWFrcyBhbmQgd3JhcHBpbmcuIFRoZXNlIHN0cmluZ3MgaGF2ZSB0cmFpbGluZ1xuXHQgKiB3aGl0ZXNwYWNlIHJlbW92ZWQuXG5cdCAqIEBtZXRob2QgZ2V0TWV0cmljc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHdpZHRoLCBoZWlnaHQsIGFuZCBsaW5lcyBwcm9wZXJ0aWVzLlxuXHQgKiovXG5cdHAuZ2V0TWV0cmljcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvID0ge2xpbmVzOltdfTtcblx0XHRvLmxpbmVIZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHQgfHwgdGhpcy5nZXRNZWFzdXJlZExpbmVIZWlnaHQoKTtcblx0XHRvLnZPZmZzZXQgPSBvLmxpbmVIZWlnaHQgKiBUZXh0LlZfT0ZGU0VUU1t0aGlzLnRleHRCYXNlbGluZXx8XCJ0b3BcIl07XG5cdFx0cmV0dXJuIHRoaXMuX2RyYXdUZXh0KG51bGwsIG8sIG8ubGluZXMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFRleHQgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7VGV4dH0gYSBjbG9uZSBvZiB0aGUgVGV4dCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lUHJvcHMobmV3IFRleHQodGhpcy50ZXh0LCB0aGlzLmZvbnQsIHRoaXMuY29sb3IpKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1RleHQgKHRleHQ9XCIrICAodGhpcy50ZXh0Lmxlbmd0aCA+IDIwID8gdGhpcy50ZXh0LnN1YnN0cigwLCAxNykrXCIuLi5cIiA6IHRoaXMudGV4dCkgK1wiKV1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9jbG9uZVByb3BzXG5cdCAqIEBwYXJhbSB7VGV4dH0gb1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge1RleHR9IG9cblx0ICoqL1xuXHRwLl9jbG9uZVByb3BzID0gZnVuY3Rpb24obykge1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9fY2xvbmVQcm9wcyhvKTtcblx0XHRvLnRleHRBbGlnbiA9IHRoaXMudGV4dEFsaWduO1xuXHRcdG8udGV4dEJhc2VsaW5lID0gdGhpcy50ZXh0QmFzZWxpbmU7XG5cdFx0by5tYXhXaWR0aCA9IHRoaXMubWF4V2lkdGg7XG5cdFx0by5vdXRsaW5lID0gdGhpcy5vdXRsaW5lO1xuXHRcdG8ubGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodDtcblx0XHRvLmxpbmVXaWR0aCA9IHRoaXMubGluZVdpZHRoO1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRXb3JraW5nQ29udGV4dFxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3ByZXBDb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0Y3R4LmZvbnQgPSB0aGlzLmZvbnR8fFwiMTBweCBzYW5zLXNlcmlmXCI7XG5cdFx0Y3R4LnRleHRBbGlnbiA9IHRoaXMudGV4dEFsaWdufHxcImxlZnRcIjtcblx0XHRjdHgudGV4dEJhc2VsaW5lID0gdGhpcy50ZXh0QmFzZWxpbmV8fFwidG9wXCI7XG5cdFx0cmV0dXJuIGN0eDtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgbXVsdGlsaW5lIHRleHQuXG5cdCAqIEBtZXRob2QgX2RyYXdUZXh0XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICogQHBhcmFtIHtPYmplY3R9IG9cblx0ICogQHBhcmFtIHtBcnJheX0gbGluZXNcblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZHJhd1RleHQgPSBmdW5jdGlvbihjdHgsIG8sIGxpbmVzKSB7XG5cdFx0dmFyIHBhaW50ID0gISFjdHg7XG5cdFx0aWYgKCFwYWludCkge1xuXHRcdFx0Y3R4ID0gVGV4dC5fd29ya2luZ0NvbnRleHQ7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0dGhpcy5fcHJlcENvbnRleHQoY3R4KTtcblx0XHR9XG5cdFx0dmFyIGxpbmVIZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHR8fHRoaXMuZ2V0TWVhc3VyZWRMaW5lSGVpZ2h0KCk7XG5cdFx0XG5cdFx0dmFyIG1heFcgPSAwLCBjb3VudCA9IDA7XG5cdFx0dmFyIGhhcmRMaW5lcyA9IFN0cmluZyh0aGlzLnRleHQpLnNwbGl0KC8oPzpcXHJcXG58XFxyfFxcbikvKTtcblx0XHRmb3IgKHZhciBpPTAsIGw9aGFyZExpbmVzLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdHZhciBzdHIgPSBoYXJkTGluZXNbaV07XG5cdFx0XHR2YXIgdyA9IG51bGw7XG5cdFx0XHRcblx0XHRcdGlmICh0aGlzLmxpbmVXaWR0aCAhPSBudWxsICYmICh3ID0gY3R4Lm1lYXN1cmVUZXh0KHN0cikud2lkdGgpID4gdGhpcy5saW5lV2lkdGgpIHtcblx0XHRcdFx0Ly8gdGV4dCB3cmFwcGluZzpcblx0XHRcdFx0dmFyIHdvcmRzID0gc3RyLnNwbGl0KC8oXFxzKS8pO1xuXHRcdFx0XHRzdHIgPSB3b3Jkc1swXTtcblx0XHRcdFx0dyA9IGN0eC5tZWFzdXJlVGV4dChzdHIpLndpZHRoO1xuXHRcdFx0XHRcblx0XHRcdFx0Zm9yICh2YXIgaj0xLCBqbD13b3Jkcy5sZW5ndGg7IGo8amw7IGorPTIpIHtcblx0XHRcdFx0XHQvLyBMaW5lIG5lZWRzIHRvIHdyYXA6XG5cdFx0XHRcdFx0dmFyIHdvcmRXID0gY3R4Lm1lYXN1cmVUZXh0KHdvcmRzW2pdICsgd29yZHNbaisxXSkud2lkdGg7XG5cdFx0XHRcdFx0aWYgKHcgKyB3b3JkVyA+IHRoaXMubGluZVdpZHRoKSB7XG5cdFx0XHRcdFx0XHRpZiAocGFpbnQpIHsgdGhpcy5fZHJhd1RleHRMaW5lKGN0eCwgc3RyLCBjb3VudCpsaW5lSGVpZ2h0KTsgfVxuXHRcdFx0XHRcdFx0aWYgKGxpbmVzKSB7IGxpbmVzLnB1c2goc3RyKTsgfVxuXHRcdFx0XHRcdFx0aWYgKHcgPiBtYXhXKSB7IG1heFcgPSB3OyB9XG5cdFx0XHRcdFx0XHRzdHIgPSB3b3Jkc1tqKzFdO1xuXHRcdFx0XHRcdFx0dyA9IGN0eC5tZWFzdXJlVGV4dChzdHIpLndpZHRoO1xuXHRcdFx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3RyICs9IHdvcmRzW2pdICsgd29yZHNbaisxXTtcblx0XHRcdFx0XHRcdHcgKz0gd29yZFc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChwYWludCkgeyB0aGlzLl9kcmF3VGV4dExpbmUoY3R4LCBzdHIsIGNvdW50KmxpbmVIZWlnaHQpOyB9XG5cdFx0XHRpZiAobGluZXMpIHsgbGluZXMucHVzaChzdHIpOyB9XG5cdFx0XHRpZiAobyAmJiB3ID09IG51bGwpIHsgdyA9IGN0eC5tZWFzdXJlVGV4dChzdHIpLndpZHRoOyB9XG5cdFx0XHRpZiAodyA+IG1heFcpIHsgbWF4VyA9IHc7IH1cblx0XHRcdGNvdW50Kys7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChvKSB7XG5cdFx0XHRvLndpZHRoID0gbWF4Vztcblx0XHRcdG8uaGVpZ2h0ID0gY291bnQqbGluZUhlaWdodDtcblx0XHR9XG5cdFx0aWYgKCFwYWludCkgeyBjdHgucmVzdG9yZSgpOyB9XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2RyYXdUZXh0TGluZVxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9kcmF3VGV4dExpbmUgPSBmdW5jdGlvbihjdHgsIHRleHQsIHkpIHtcblx0XHQvLyBDaHJvbWUgMTcgd2lsbCBmYWlsIHRvIGRyYXcgdGhlIHRleHQgaWYgdGhlIGxhc3QgcGFyYW0gaXMgaW5jbHVkZWQgYnV0IG51bGwsIHNvIHdlIGZlZWQgaXQgYSBsYXJnZSB2YWx1ZSBpbnN0ZWFkOlxuXHRcdGlmICh0aGlzLm91dGxpbmUpIHsgY3R4LnN0cm9rZVRleHQodGV4dCwgMCwgeSwgdGhpcy5tYXhXaWR0aHx8MHhGRkZGKTsgfVxuXHRcdGVsc2UgeyBjdHguZmlsbFRleHQodGV4dCwgMCwgeSwgdGhpcy5tYXhXaWR0aHx8MHhGRkZGKTsgfVxuXHR9O1xuXHRcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRNZWFzdXJlZFdpZHRoXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nZXRNZWFzdXJlZFdpZHRoID0gZnVuY3Rpb24odGV4dCkge1xuXHRcdHZhciBjdHggPSBUZXh0Ll93b3JraW5nQ29udGV4dDtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdHZhciB3ID0gdGhpcy5fcHJlcENvbnRleHQoY3R4KS5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdHJldHVybiB3O1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuVGV4dCA9IGNyZWF0ZWpzLnByb21vdGUoVGV4dCwgXCJEaXNwbGF5T2JqZWN0XCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEJpdG1hcFRleHQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIERpc3BsYXlzIHRleHQgdXNpbmcgYml0bWFwIGdseXBocyBkZWZpbmVkIGluIGEgc3ByaXRlIHNoZWV0LiBNdWx0aS1saW5lIHRleHQgaXMgc3VwcG9ydGVkXG5cdCAqIHVzaW5nIG5ldyBsaW5lIGNoYXJhY3RlcnMsIGJ1dCBhdXRvbWF0aWMgd3JhcHBpbmcgaXMgbm90IHN1cHBvcnRlZC4gU2VlIHRoZSBcblx0ICoge3sjY3Jvc3NMaW5rIFwiQml0bWFwVGV4dC9zcHJpdGVTaGVldDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBwcm9wZXJ0eSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBkZWZpbmluZyBnbHlwaHMuXG5cdCAqIFxuXHQgKiA8c3Ryb25nPkltcG9ydGFudDo8L3N0cm9uZz4gQml0bWFwVGV4dCBleHRlbmRzIENvbnRhaW5lciwgYnV0IGlzIG5vdCBkZXNpZ25lZCB0byBiZSB1c2VkIGFzIG9uZS5cblx0ICogQXMgc3VjaCwgbWV0aG9kcyBsaWtlIGFkZENoaWxkIGFuZCByZW1vdmVDaGlsZCBhcmUgZGlzYWJsZWQuXG5cdCAqIEBjbGFzcyBCaXRtYXBUZXh0XG5cdCAqIEBleHRlbmRzIERpc3BsYXlPYmplY3Rcblx0ICogQHBhcmFtIHtTdHJpbmd9IFt0ZXh0PVwiXCJdIFRoZSB0ZXh0IHRvIGRpc3BsYXkuXG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IFtzcHJpdGVTaGVldD1udWxsXSBUaGUgc3ByaXRlc2hlZXQgdGhhdCBkZWZpbmVzIHRoZSBjaGFyYWN0ZXIgZ2x5cGhzLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBCaXRtYXBUZXh0KHRleHQsIHNwcml0ZVNoZWV0KSB7XG5cdFx0dGhpcy5Db250YWluZXJfY29uc3RydWN0b3IoKTtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIHRleHQgdG8gZGlzcGxheS5cblx0XHQgKiBAcHJvcGVydHkgdGV4dFxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqIEBkZWZhdWx0IFwiXCJcblx0XHQgKiovXG5cdFx0dGhpcy50ZXh0ID0gdGV4dHx8XCJcIjtcblx0XHRcblx0XHQvKipcblx0XHQgKiBBIFNwcml0ZVNoZWV0IGluc3RhbmNlIHRoYXQgZGVmaW5lcyB0aGUgZ2x5cGhzIGZvciB0aGlzIGJpdG1hcCB0ZXh0LiBFYWNoIGdseXBoL2NoYXJhY3RlclxuXHRcdCAqIHNob3VsZCBoYXZlIGEgc2luZ2xlIGZyYW1lIGFuaW1hdGlvbiBkZWZpbmVkIGluIHRoZSBzcHJpdGUgc2hlZXQgbmFtZWQgdGhlIHNhbWUgYXNcblx0XHQgKiBjb3JyZXNwb25kaW5nIGNoYXJhY3Rlci4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgYW5pbWF0aW9uIGRlZmluaXRpb246XG5cdFx0ICpcblx0XHQgKiBcdFx0XCJBXCI6IHtmcmFtZXM6IFswXX1cblx0XHQgKlxuXHRcdCAqIHdvdWxkIGluZGljYXRlIHRoYXQgdGhlIGZyYW1lIGF0IGluZGV4IDAgb2YgdGhlIHNwcml0ZXNoZWV0IHNob3VsZCBiZSBkcmF3biBmb3IgdGhlIFwiQVwiIGNoYXJhY3Rlci4gVGhlIHNob3J0IGZvcm1cblx0XHQgKiBpcyBhbHNvIGFjY2VwdGFibGU6XG5cdFx0ICogXG5cdFx0ICogXHRcdFwiQVwiOiAwXG5cdFx0ICpcblx0XHQgKiBOb3RlIHRoYXQgaWYgYSBjaGFyYWN0ZXIgaW4gdGhlIHRleHQgaXMgbm90IGZvdW5kIGluIHRoZSBzcHJpdGUgc2hlZXQsIGl0IHdpbGwgYWxzb1xuXHRcdCAqIHRyeSB0byB1c2UgdGhlIGFsdGVybmF0ZSBjYXNlICh1cHBlciBvciBsb3dlcikuXG5cdFx0ICpcblx0XHQgKiBTZWUgU3ByaXRlU2hlZXQgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gZGVmaW5pbmcgc3ByaXRlIHNoZWV0IGRhdGEuXG5cdFx0ICogQHByb3BlcnR5IHNwcml0ZVNoZWV0XG5cdFx0ICogQHR5cGUgU3ByaXRlU2hlZXRcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMuc3ByaXRlU2hlZXQgPSBzcHJpdGVTaGVldDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGhlaWdodCBvZiBlYWNoIGxpbmUgb2YgdGV4dC4gSWYgMCwgdGhlbiBpdCB3aWxsIHVzZSBhIGxpbmUgaGVpZ2h0IGNhbGN1bGF0ZWRcblx0XHQgKiBieSBjaGVja2luZyBmb3IgdGhlIGhlaWdodCBvZiB0aGUgXCIxXCIsIFwiVFwiLCBvciBcIkxcIiBjaGFyYWN0ZXIgKGluIHRoYXQgb3JkZXIpLiBJZlxuXHRcdCAqIHRob3NlIGNoYXJhY3RlcnMgYXJlIG5vdCBkZWZpbmVkLCBpdCB3aWxsIHVzZSB0aGUgaGVpZ2h0IG9mIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGVcblx0XHQgKiBzcHJpdGUgc2hlZXQuXG5cdFx0ICogQHByb3BlcnR5IGxpbmVIZWlnaHRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMubGluZUhlaWdodCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgc3BhY2luZyAoaW4gcGl4ZWxzKSB3aWxsIGJlIGFkZGVkIGFmdGVyIGVhY2ggY2hhcmFjdGVyIGluIHRoZSBvdXRwdXQuXG5cdFx0ICogQHByb3BlcnR5IGxldHRlclNwYWNpbmdcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMubGV0dGVyU3BhY2luZyA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIGEgc3BhY2UgY2hhcmFjdGVyIGlzIG5vdCBkZWZpbmVkIGluIHRoZSBzcHJpdGUgc2hlZXQsIHRoZW4gZW1wdHkgcGl4ZWxzIGVxdWFsIHRvXG5cdFx0ICogc3BhY2VXaWR0aCB3aWxsIGJlIGluc2VydGVkIGluc3RlYWQuIElmIDAsIHRoZW4gaXQgd2lsbCB1c2UgYSB2YWx1ZSBjYWxjdWxhdGVkXG5cdFx0ICogYnkgY2hlY2tpbmcgZm9yIHRoZSB3aWR0aCBvZiB0aGUgXCIxXCIsIFwibFwiLCBcIkVcIiwgb3IgXCJBXCIgY2hhcmFjdGVyIChpbiB0aGF0IG9yZGVyKS4gSWZcblx0XHQgKiB0aG9zZSBjaGFyYWN0ZXJzIGFyZSBub3QgZGVmaW5lZCwgaXQgd2lsbCB1c2UgdGhlIHdpZHRoIG9mIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGVcblx0XHQgKiBzcHJpdGUgc2hlZXQuXG5cdFx0ICogQHByb3BlcnR5IHNwYWNlV2lkdGhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMuc3BhY2VXaWR0aCA9IDA7XG5cdFx0XG5cdFx0XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0IFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9vbGRQcm9wc1xuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5fb2xkUHJvcHMgPSB7dGV4dDowLHNwcml0ZVNoZWV0OjAsbGluZUhlaWdodDowLGxldHRlclNwYWNpbmc6MCxzcGFjZVdpZHRoOjB9O1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEJpdG1hcFRleHQsIGNyZWF0ZWpzLkNvbnRhaW5lcik7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG4vLyBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIEJpdG1hcFRleHQgdXNlcyBTcHJpdGUgaW5zdGFuY2VzIHRvIGRyYXcgdGV4dC4gVG8gcmVkdWNlIHRoZSBjcmVhdGlvbiBhbmQgZGVzdHJ1Y3Rpb24gb2YgaW5zdGFuY2VzIChhbmQgdGh1cyBnYXJiYWdlIGNvbGxlY3Rpb24pLCBpdCBtYWludGFpbnNcblx0ICogYW4gaW50ZXJuYWwgb2JqZWN0IHBvb2wgb2Ygc3ByaXRlIGluc3RhbmNlcyB0byByZXVzZS4gSW5jcmVhc2luZyB0aGlzIHZhbHVlIGNhbiBjYXVzZSBtb3JlIHNwcml0ZXMgdG8gYmVcblx0ICogcmV0YWluZWQsIHNsaWdodGx5IGluY3JlYXNpbmcgbWVtb3J5IHVzZSwgYnV0IHJlZHVjaW5nIGluc3RhbnRpYXRpb24uXG5cdCAqIEBwcm9wZXJ0eSBtYXhQb29sU2l6ZVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVmYXVsdCAxMDBcblx0ICoqL1xuXHRCaXRtYXBUZXh0Lm1heFBvb2xTaXplID0gMTAwO1xuXHRcblx0LyoqXG5cdCAqIFNwcml0ZSBvYmplY3QgcG9vbC5cblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRCaXRtYXBUZXh0Ll9zcHJpdGVQb29sID0gW107XG5cblx0XG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIERvY2NlZCBpbiBzdXBlcmNsYXNzLlxuXHQgKiovXG5cdHAuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgaWdub3JlQ2FjaGUpIHtcblx0XHRpZiAodGhpcy5EaXNwbGF5T2JqZWN0X2RyYXcoY3R4LCBpZ25vcmVDYWNoZSkpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5fdXBkYXRlVGV4dCgpO1xuXHRcdHRoaXMuQ29udGFpbmVyX2RyYXcoY3R4LCBpZ25vcmVDYWNoZSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogRG9jY2VkIGluIHN1cGVyY2xhc3MuXG5cdCAqKi9cblx0cC5nZXRCb3VuZHMgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl91cGRhdGVUZXh0KCk7XG5cdFx0cmV0dXJuIHRoaXMuQ29udGFpbmVyX2dldEJvdW5kcygpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXMuXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBpc1Zpc2libGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcblx0ICoqL1xuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYXNDb250ZW50ID0gdGhpcy5jYWNoZUNhbnZhcyB8fCAodGhpcy5zcHJpdGVTaGVldCAmJiB0aGlzLnNwcml0ZVNoZWV0LmNvbXBsZXRlICYmIHRoaXMudGV4dCk7XG5cdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPT0gMCAmJiB0aGlzLnNjYWxlWSAhPT0gMCAmJiBoYXNDb250ZW50KTtcblx0fTtcblx0XG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmVQcm9wcyhuZXcgQml0bWFwVGV4dCh0aGlzLnRleHQsIHRoaXMuc3ByaXRlU2hlZXQpKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiA8c3Ryb25nPkRpc2FibGVkIGluIEJpdG1hcFRleHQuPC9zdHJvbmc+XG5cdCAqIEBtZXRob2QgYWRkQ2hpbGRcblx0ICoqL1xuXHQvKipcblx0ICogPHN0cm9uZz5EaXNhYmxlZCBpbiBCaXRtYXBUZXh0Ljwvc3Ryb25nPlxuXHQgKiBAbWV0aG9kIGFkZENoaWxkQXRcblx0ICoqL1xuXHQvKipcblx0ICogPHN0cm9uZz5EaXNhYmxlZCBpbiBCaXRtYXBUZXh0Ljwvc3Ryb25nPlxuXHQgKiBAbWV0aG9kIHJlbW92ZUNoaWxkXG5cdCAqKi9cblx0LyoqXG5cdCAqIDxzdHJvbmc+RGlzYWJsZWQgaW4gQml0bWFwVGV4dC48L3N0cm9uZz5cblx0ICogQG1ldGhvZCByZW1vdmVDaGlsZEF0XG5cdCAqKi9cblx0LyoqXG5cdCAqIDxzdHJvbmc+RGlzYWJsZWQgaW4gQml0bWFwVGV4dC48L3N0cm9uZz5cblx0ICogQG1ldGhvZCByZW1vdmVBbGxDaGlsZHJlblxuXHQgKiovXG5cdHAuYWRkQ2hpbGQgPSBwLmFkZENoaWxkQXQgPSBwLnJlbW92ZUNoaWxkID0gcC5yZW1vdmVDaGlsZEF0ID0gcC5yZW1vdmVBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uKCkge307XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuIFx0LyoqXG5cdCAqIEBtZXRob2QgX2Nsb25lUHJvcHNcblx0ICogQHBhcmFtIHtCaXRtYXBUZXh0fSBvXG5cdCAqIEByZXR1cm4ge0JpdG1hcFRleHR9IG9cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2Nsb25lUHJvcHMgPSBmdW5jdGlvbihvKSB7XG5cdFx0dGhpcy5Db250YWluZXJfX2Nsb25lUHJvcHMobyk7XG5cdFx0by5saW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0O1xuXHRcdG8ubGV0dGVyU3BhY2luZyA9IHRoaXMubGV0dGVyU3BhY2luZztcblx0XHRvLnNwYWNlV2lkdGggPSB0aGlzLnNwYWNlV2lkdGg7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0RnJhbWVJbmRleFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY2hhcmFjdGVyXG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IHNwcml0ZVNoZWV0XG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dldEZyYW1lSW5kZXggPSBmdW5jdGlvbihjaGFyYWN0ZXIsIHNwcml0ZVNoZWV0KSB7XG5cdFx0dmFyIGMsIG8gPSBzcHJpdGVTaGVldC5nZXRBbmltYXRpb24oY2hhcmFjdGVyKTtcblx0XHRpZiAoIW8pIHtcblx0XHRcdChjaGFyYWN0ZXIgIT0gKGMgPSBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKSkpIHx8IChjaGFyYWN0ZXIgIT0gKGMgPSBjaGFyYWN0ZXIudG9Mb3dlckNhc2UoKSkpIHx8IChjPW51bGwpO1xuXHRcdFx0aWYgKGMpIHsgbyA9IHNwcml0ZVNoZWV0LmdldEFuaW1hdGlvbihjKTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gbyAmJiBvLmZyYW1lc1swXTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRGcmFtZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY2hhcmFjdGVyXG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IHNwcml0ZVNoZWV0XG5cdCAqIEByZXR1cm4ge09iamVjdH1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dldEZyYW1lID0gZnVuY3Rpb24oY2hhcmFjdGVyLCBzcHJpdGVTaGVldCkge1xuXHRcdHZhciBpbmRleCA9IHRoaXMuX2dldEZyYW1lSW5kZXgoY2hhcmFjdGVyLCBzcHJpdGVTaGVldCk7XG5cdFx0cmV0dXJuIGluZGV4ID09IG51bGwgPyBpbmRleCA6IHNwcml0ZVNoZWV0LmdldEZyYW1lKGluZGV4KTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRMaW5lSGVpZ2h0XG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IHNzXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dldExpbmVIZWlnaHQgPSBmdW5jdGlvbihzcykge1xuXHRcdHZhciBmcmFtZSA9IHRoaXMuX2dldEZyYW1lKFwiMVwiLHNzKSB8fCB0aGlzLl9nZXRGcmFtZShcIlRcIixzcykgfHwgdGhpcy5fZ2V0RnJhbWUoXCJMXCIsc3MpIHx8IHNzLmdldEZyYW1lKDApO1xuXHRcdHJldHVybiBmcmFtZSA/IGZyYW1lLnJlY3QuaGVpZ2h0IDogMTtcblx0fTtcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldFNwYWNlV2lkdGhcblx0ICogQHBhcmFtIHtTcHJpdGVTaGVldH0gc3Ncblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ2V0U3BhY2VXaWR0aCA9IGZ1bmN0aW9uKHNzKSB7XG5cdFx0dmFyIGZyYW1lID0gdGhpcy5fZ2V0RnJhbWUoXCIxXCIsc3MpIHx8IHRoaXMuX2dldEZyYW1lKFwibFwiLHNzKSB8fCB0aGlzLl9nZXRGcmFtZShcImVcIixzcykgfHwgdGhpcy5fZ2V0RnJhbWUoXCJhXCIsc3MpIHx8IHNzLmdldEZyYW1lKDApO1xuXHRcdHJldHVybiBmcmFtZSA/IGZyYW1lLnJlY3Qud2lkdGggOiAxO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2RyYXdUZXh0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl91cGRhdGVUZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHg9MCwgeT0wLCBvPXRoaXMuX29sZFByb3BzLCBjaGFuZ2U9ZmFsc2UsIHNwYWNlVz10aGlzLnNwYWNlV2lkdGgsIGxpbmVIPXRoaXMubGluZUhlaWdodCwgc3M9dGhpcy5zcHJpdGVTaGVldDtcblx0XHR2YXIgcG9vbD1CaXRtYXBUZXh0Ll9zcHJpdGVQb29sLCBraWRzPXRoaXMuY2hpbGRyZW4sIGNoaWxkSW5kZXg9MCwgbnVtS2lkcz1raWRzLmxlbmd0aCwgc3ByaXRlO1xuXHRcdFxuXHRcdGZvciAodmFyIG4gaW4gbykge1xuXHRcdFx0aWYgKG9bbl0gIT0gdGhpc1tuXSkge1xuXHRcdFx0XHRvW25dID0gdGhpc1tuXTtcblx0XHRcdFx0Y2hhbmdlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFjaGFuZ2UpIHsgcmV0dXJuOyB9XG5cdFx0XG5cdFx0dmFyIGhhc1NwYWNlID0gISF0aGlzLl9nZXRGcmFtZShcIiBcIiwgc3MpO1xuXHRcdGlmICghaGFzU3BhY2UgJiYgIXNwYWNlVykgeyBzcGFjZVcgPSB0aGlzLl9nZXRTcGFjZVdpZHRoKHNzKTsgfVxuXHRcdGlmICghbGluZUgpIHsgbGluZUggPSB0aGlzLl9nZXRMaW5lSGVpZ2h0KHNzKTsgfVxuXHRcdFxuXHRcdGZvcih2YXIgaT0wLCBsPXRoaXMudGV4dC5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hhcmFjdGVyID0gdGhpcy50ZXh0LmNoYXJBdChpKTtcblx0XHRcdGlmIChjaGFyYWN0ZXIgPT0gXCIgXCIgJiYgIWhhc1NwYWNlKSB7XG5cdFx0XHRcdHggKz0gc3BhY2VXO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSBpZiAoY2hhcmFjdGVyPT1cIlxcblwiIHx8IGNoYXJhY3Rlcj09XCJcXHJcIikge1xuXHRcdFx0XHRpZiAoY2hhcmFjdGVyPT1cIlxcclwiICYmIHRoaXMudGV4dC5jaGFyQXQoaSsxKSA9PSBcIlxcblwiKSB7IGkrKzsgfSAvLyBjcmxmXG5cdFx0XHRcdHggPSAwO1xuXHRcdFx0XHR5ICs9IGxpbmVIO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGluZGV4ID0gdGhpcy5fZ2V0RnJhbWVJbmRleChjaGFyYWN0ZXIsIHNzKTtcblx0XHRcdGlmIChpbmRleCA9PSBudWxsKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRcblx0XHRcdGlmIChjaGlsZEluZGV4IDwgbnVtS2lkcykge1xuXHRcdFx0XHRzcHJpdGUgPSBraWRzW2NoaWxkSW5kZXhdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2lkcy5wdXNoKHNwcml0ZSA9IHBvb2wubGVuZ3RoID8gcG9vbC5wb3AoKSA6IG5ldyBjcmVhdGVqcy5TcHJpdGUoKSk7XG5cdFx0XHRcdHNwcml0ZS5wYXJlbnQgPSB0aGlzO1xuXHRcdFx0XHRudW1LaWRzKys7XG5cdFx0XHR9XG5cdFx0XHRzcHJpdGUuc3ByaXRlU2hlZXQgPSBzcztcblx0XHRcdHNwcml0ZS5nb3RvQW5kU3RvcChpbmRleCk7XG5cdFx0XHRzcHJpdGUueCA9IHg7XG5cdFx0XHRzcHJpdGUueSA9IHk7XG5cdFx0XHRjaGlsZEluZGV4Kys7XG5cdFx0XHRcblx0XHRcdHggKz0gc3ByaXRlLmdldEJvdW5kcygpLndpZHRoICsgdGhpcy5sZXR0ZXJTcGFjaW5nO1xuXHRcdH1cblx0XHR3aGlsZSAobnVtS2lkcyA+IGNoaWxkSW5kZXgpIHtcblx0XHRcdCAvLyBmYXN0ZXIgdGhhbiByZW1vdmVDaGlsZC5cblx0XHRcdHBvb2wucHVzaChzcHJpdGUgPSBraWRzLnBvcCgpKTtcblx0XHRcdHNwcml0ZS5wYXJlbnQgPSBudWxsO1xuXHRcdFx0bnVtS2lkcy0tO1xuXHRcdH1cblx0XHRpZiAocG9vbC5sZW5ndGggPiBCaXRtYXBUZXh0Lm1heFBvb2xTaXplKSB7IHBvb2wubGVuZ3RoID0gQml0bWFwVGV4dC5tYXhQb29sU2l6ZTsgfVxuXHR9O1xuXG5cblx0Y3JlYXRlanMuQml0bWFwVGV4dCA9IGNyZWF0ZWpzLnByb21vdGUoQml0bWFwVGV4dCwgXCJDb250YWluZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU3ByaXRlU2hlZXRVdGlscy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdFxyXG5cdFxyXG4vLyBjb25zdHJ1Y3RvcjpcclxuXHQvKipcclxuXHQgKiBUaGUgU3ByaXRlU2hlZXRVdGlscyBjbGFzcyBpcyBhIGNvbGxlY3Rpb24gb2Ygc3RhdGljIG1ldGhvZHMgZm9yIHdvcmtpbmcgd2l0aCB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fXMuXHJcblx0ICogQSBzcHJpdGUgc2hlZXQgaXMgYSBzZXJpZXMgb2YgaW1hZ2VzICh1c3VhbGx5IGFuaW1hdGlvbiBmcmFtZXMpIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgaW1hZ2Ugb24gYSByZWd1bGFyIGdyaWQuIEZvclxyXG5cdCAqIGV4YW1wbGUsIGFuIGFuaW1hdGlvbiBjb25zaXN0aW5nIG9mIDggMTAweDEwMCBpbWFnZXMgY291bGQgYmUgY29tYmluZWQgaW50byBhIDQwMHgyMDAgc3ByaXRlIHNoZWV0ICg0IGZyYW1lcyBhY3Jvc3NcclxuXHQgKiBieSAyIGhpZ2gpLiBUaGUgU3ByaXRlU2hlZXRVdGlscyBjbGFzcyB1c2VzIGEgc3RhdGljIGludGVyZmFjZSBhbmQgc2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQuXHJcblx0ICogQGNsYXNzIFNwcml0ZVNoZWV0VXRpbHNcclxuXHQgKiBAc3RhdGljXHJcblx0ICoqL1xyXG5cdGZ1bmN0aW9uIFNwcml0ZVNoZWV0VXRpbHMoKSB7XHJcblx0XHR0aHJvdyBcIlNwcml0ZVNoZWV0VXRpbHMgY2Fubm90IGJlIGluc3RhbnRpYXRlZFwiO1xyXG5cdH1cclxuXHJcblxyXG4vLyBwcml2YXRlIHN0YXRpYyBwcm9wZXJ0aWVzOlxyXG5cdC8qKlxyXG5cdCAqIEBwcm9wZXJ0eSBfd29ya2luZ0NhbnZhc1xyXG5cdCAqIEBzdGF0aWNcclxuXHQgKiBAdHlwZSBIVE1MQ2FudmFzRWxlbWVudCB8IE9iamVjdFxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQqL1xyXG5cdC8qKlxyXG5cdCAqIEBwcm9wZXJ0eSBfd29ya2luZ0NvbnRleHRcclxuXHQgKiBAc3RhdGljXHJcblx0ICogQHR5cGUgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCovXHJcblx0dmFyIGNhbnZhcyA9IChjcmVhdGVqcy5jcmVhdGVDYW52YXM/Y3JlYXRlanMuY3JlYXRlQ2FudmFzKCk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSk7XHJcblx0aWYgKGNhbnZhcy5nZXRDb250ZXh0KSB7XHJcblx0XHRTcHJpdGVTaGVldFV0aWxzLl93b3JraW5nQ2FudmFzID0gY2FudmFzO1xyXG5cdFx0U3ByaXRlU2hlZXRVdGlscy5fd29ya2luZ0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDE7XHJcblx0fVxyXG5cclxuXHJcbi8vIHB1YmxpYyBzdGF0aWMgbWV0aG9kczpcclxuXHQvKipcclxuXHQgKiA8Yj5UaGlzIGlzIGFuIGV4cGVyaW1lbnRhbCBtZXRob2QsIGFuZCBtYXkgYmUgYnVnZ3kuIFBsZWFzZSByZXBvcnQgaXNzdWVzLjwvYj48YnIvPjxici8+XHJcblx0ICogRXh0ZW5kcyB0aGUgZXhpc3Rpbmcgc3ByaXRlIHNoZWV0IGJ5IGZsaXBwaW5nIHRoZSBvcmlnaW5hbCBmcmFtZXMgaG9yaXpvbnRhbGx5LCB2ZXJ0aWNhbGx5LCBvciBib3RoLFxyXG5cdCAqIGFuZCBhZGRpbmcgYXBwcm9wcmlhdGUgYW5pbWF0aW9uICYgZnJhbWUgZGF0YS4gVGhlIGZsaXBwZWQgYW5pbWF0aW9ucyB3aWxsIGhhdmUgYSBzdWZmaXggYWRkZWQgdG8gdGhlaXIgbmFtZXNcclxuXHQgKiAoX2gsIF92LCBfaHYgYXMgYXBwcm9wcmlhdGUpLiBNYWtlIHN1cmUgdGhlIHNwcml0ZSBzaGVldCBpbWFnZXMgYXJlIGZ1bGx5IGxvYWRlZCBiZWZvcmUgdXNpbmcgdGhpcyBtZXRob2QuXHJcblx0ICogPGJyLz48YnIvPlxyXG5cdCAqIEZvciBleGFtcGxlOjxici8+XHJcblx0ICogU3ByaXRlU2hlZXRVdGlscy5hZGRGbGlwcGVkRnJhbWVzKG15U3ByaXRlU2hlZXQsIHRydWUsIHRydWUpO1xyXG5cdCAqIFRoZSBhYm92ZSB3b3VsZCBhZGQgZnJhbWVzIHRoYXQgYXJlIGZsaXBwZWQgaG9yaXpvbnRhbGx5IEFORCBmcmFtZXMgdGhhdCBhcmUgZmxpcHBlZCB2ZXJ0aWNhbGx5LlxyXG5cdCAqIDxici8+PGJyLz5cclxuXHQgKiBOb3RlIHRoYXQgeW91IGNhbiBhbHNvIGZsaXAgYW55IGRpc3BsYXkgb2JqZWN0IGJ5IHNldHRpbmcgaXRzIHNjYWxlWCBvciBzY2FsZVkgdG8gYSBuZWdhdGl2ZSB2YWx1ZS4gT24gc29tZVxyXG5cdCAqIGJyb3dzZXJzIChlc3BlY2lhbGx5IHRob3NlIHdpdGhvdXQgaGFyZHdhcmUgYWNjZWxlcmF0ZWQgY2FudmFzKSB0aGlzIGNhbiByZXN1bHQgaW4gc2xpZ2h0bHkgZGVncmFkZWQgcGVyZm9ybWFuY2UsXHJcblx0ICogd2hpY2ggaXMgd2h5IGFkZEZsaXBwZWRGcmFtZXMgaXMgYXZhaWxhYmxlLlxyXG5cdCAqIEBtZXRob2QgYWRkRmxpcHBlZEZyYW1lc1xyXG5cdCAqIEBzdGF0aWNcclxuXHQgKiBAcGFyYW0ge1Nwcml0ZVNoZWV0fSBzcHJpdGVTaGVldFxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaG9yaXpvbnRhbCBJZiB0cnVlLCBob3Jpem9udGFsbHkgZmxpcHBlZCBmcmFtZXMgd2lsbCBiZSBhZGRlZC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZlcnRpY2FsIElmIHRydWUsIHZlcnRpY2FsbHkgZmxpcHBlZCBmcmFtZXMgd2lsbCBiZSBhZGRlZC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGJvdGggSWYgdHJ1ZSwgZnJhbWVzIHRoYXQgYXJlIGZsaXBwZWQgYm90aCBob3Jpem9udGFsbHkgYW5kIHZlcnRpY2FsbHkgd2lsbCBiZSBhZGRlZC5cclxuXHQgKiBAZGVwcmVjYXRlZCBNb2Rlcm4gYnJvd3NlcnMgcGVyZm9ybSBiZXR0ZXIgd2hlbiBmbGlwcGluZyB2aWEgYSB0cmFuc2Zvcm0gKGV4LiBzY2FsZVg9LTEpIHJlbmRlcmluZyB0aGlzIG9ic29sZXRlLlxyXG5cdCAqKi9cclxuXHRTcHJpdGVTaGVldFV0aWxzLmFkZEZsaXBwZWRGcmFtZXMgPSBmdW5jdGlvbihzcHJpdGVTaGVldCwgaG9yaXpvbnRhbCwgdmVydGljYWwsIGJvdGgpIHtcclxuXHRcdGlmICghaG9yaXpvbnRhbCAmJiAhdmVydGljYWwgJiYgIWJvdGgpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGNvdW50ID0gMDtcclxuXHRcdGlmIChob3Jpem9udGFsKSB7IFNwcml0ZVNoZWV0VXRpbHMuX2ZsaXAoc3ByaXRlU2hlZXQsKytjb3VudCx0cnVlLGZhbHNlKTsgfVxyXG5cdFx0aWYgKHZlcnRpY2FsKSB7IFNwcml0ZVNoZWV0VXRpbHMuX2ZsaXAoc3ByaXRlU2hlZXQsKytjb3VudCxmYWxzZSx0cnVlKTsgfVxyXG5cdFx0aWYgKGJvdGgpIHsgU3ByaXRlU2hlZXRVdGlscy5fZmxpcChzcHJpdGVTaGVldCwrK2NvdW50LHRydWUsdHJ1ZSk7IH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgc2luZ2xlIGZyYW1lIG9mIHRoZSBzcGVjaWZpZWQgc3ByaXRlIHNoZWV0IGFzIGEgbmV3IFBORyBpbWFnZS4gQW4gZXhhbXBsZSBvZiB3aGVuIHRoaXMgbWF5IGJlIHVzZWZ1bCBpc1xyXG5cdCAqIHRvIHVzZSBhIHNwcml0ZXNoZWV0IGZyYW1lIGFzIHRoZSBzb3VyY2UgZm9yIGEgYml0bWFwIGZpbGwuXHJcblx0ICpcclxuXHQgKiA8c3Ryb25nPldBUk5JTkc6PC9zdHJvbmc+IEluIGFsbW9zdCBhbGwgY2FzZXMgaXQgaXMgYmV0dGVyIHRvIGRpc3BsYXkgYSBzaW5nbGUgZnJhbWUgdXNpbmcgYSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVcIn19e3svY3Jvc3NMaW5rfX1cclxuXHQgKiB3aXRoIGEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319IGNhbGwgdGhhbiBpdCBpcyB0byBzbGljZSBvdXQgYSBmcmFtZSB1c2luZyB0aGlzXHJcblx0ICogbWV0aG9kIGFuZCBkaXNwbGF5IGl0IHdpdGggYSBCaXRtYXAgaW5zdGFuY2UuIFlvdSBjYW4gYWxzbyBjcm9wIGFuIGltYWdlIHVzaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJCaXRtYXAvc291cmNlUmVjdFwifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIHByb3BlcnR5IG9mIHt7I2Nyb3NzTGluayBcIkJpdG1hcFwifX17ey9jcm9zc0xpbmt9fS5cclxuXHQgKlxyXG5cdCAqIFRoZSBleHRyYWN0RnJhbWUgbWV0aG9kIG1heSBjYXVzZSBjcm9zcy1kb21haW4gd2FybmluZ3Mgc2luY2UgaXQgYWNjZXNzZXMgcGl4ZWxzIGRpcmVjdGx5IG9uIHRoZSBjYW52YXMuXHJcblx0ICogQG1ldGhvZCBleHRyYWN0RnJhbWVcclxuXHQgKiBAc3RhdGljXHJcblx0ICogQHBhcmFtIHtTcHJpdGVTaGVldH0gc3ByaXRlU2hlZXQgVGhlIFNwcml0ZVNoZWV0IGluc3RhbmNlIHRvIGV4dHJhY3QgYSBmcmFtZSBmcm9tLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gZnJhbWVPckFuaW1hdGlvbiBUaGUgZnJhbWUgbnVtYmVyIG9yIGFuaW1hdGlvbiBuYW1lIHRvIGV4dHJhY3QuIElmIGFuIGFuaW1hdGlvblxyXG5cdCAqIG5hbWUgaXMgc3BlY2lmaWVkLCBvbmx5IHRoZSBmaXJzdCBmcmFtZSBvZiB0aGUgYW5pbWF0aW9uIHdpbGwgYmUgZXh0cmFjdGVkLlxyXG5cdCAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IGEgc2luZ2xlIGZyYW1lIG9mIHRoZSBzcGVjaWZpZWQgc3ByaXRlIHNoZWV0IGFzIGEgbmV3IFBORyBpbWFnZS5cclxuXHQqL1xyXG5cdFNwcml0ZVNoZWV0VXRpbHMuZXh0cmFjdEZyYW1lID0gZnVuY3Rpb24oc3ByaXRlU2hlZXQsIGZyYW1lT3JBbmltYXRpb24pIHtcclxuXHRcdGlmIChpc05hTihmcmFtZU9yQW5pbWF0aW9uKSkge1xyXG5cdFx0XHRmcmFtZU9yQW5pbWF0aW9uID0gc3ByaXRlU2hlZXQuZ2V0QW5pbWF0aW9uKGZyYW1lT3JBbmltYXRpb24pLmZyYW1lc1swXTtcclxuXHRcdH1cclxuXHRcdHZhciBkYXRhID0gc3ByaXRlU2hlZXQuZ2V0RnJhbWUoZnJhbWVPckFuaW1hdGlvbik7XHJcblx0XHRpZiAoIWRhdGEpIHsgcmV0dXJuIG51bGw7IH1cclxuXHRcdHZhciByID0gZGF0YS5yZWN0O1xyXG5cdFx0dmFyIGNhbnZhcyA9IFNwcml0ZVNoZWV0VXRpbHMuX3dvcmtpbmdDYW52YXM7XHJcblx0XHRjYW52YXMud2lkdGggPSByLndpZHRoO1xyXG5cdFx0Y2FudmFzLmhlaWdodCA9IHIuaGVpZ2h0O1xyXG5cdFx0U3ByaXRlU2hlZXRVdGlscy5fd29ya2luZ0NvbnRleHQuZHJhd0ltYWdlKGRhdGEuaW1hZ2UsIHIueCwgci55LCByLndpZHRoLCByLmhlaWdodCwgMCwgMCwgci53aWR0aCwgci5oZWlnaHQpO1xyXG5cdFx0dmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XHJcblx0XHRpbWcuc3JjID0gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcclxuXHRcdHJldHVybiBpbWc7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogTWVyZ2VzIHRoZSByZ2IgY2hhbm5lbHMgb2Ygb25lIGltYWdlIHdpdGggdGhlIGFscGhhIGNoYW5uZWwgb2YgYW5vdGhlci4gVGhpcyBjYW4gYmUgdXNlZCB0byBjb21iaW5lIGEgY29tcHJlc3NlZFxyXG5cdCAqIEpQRUcgaW1hZ2UgY29udGFpbmluZyBjb2xvciBkYXRhIHdpdGggYSBQTkczMiBtb25vY2hyb21hdGljIGltYWdlIGNvbnRhaW5pbmcgYWxwaGEgZGF0YS4gV2l0aCBjZXJ0YWluIHR5cGVzIG9mXHJcblx0ICogaW1hZ2VzICh0aG9zZSB3aXRoIGRldGFpbCB0aGF0IGxlbmQgaXRzZWxmIHRvIEpQRUcgY29tcHJlc3Npb24pIHRoaXMgY2FuIHByb3ZpZGUgc2lnbmlmaWNhbnQgZmlsZSBzaXplIHNhdmluZ3NcclxuXHQgKiB2ZXJzdXMgYSBzaW5nbGUgUkdCQSBQTkczMi4gVGhpcyBtZXRob2QgaXMgdmVyeSBmYXN0IChnZW5lcmFsbHkgb24gdGhlIG9yZGVyIG9mIDEtMiBtcyB0byBydW4pLlxyXG5cdCAqIEBtZXRob2QgbWVyZ2VBbHBoYVxyXG5cdCAqIEBzdGF0aWNcclxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IHJiZ0ltYWdlIFRoZSBpbWFnZSAob3IgY2FudmFzKSBjb250YWluaW5nIHRoZSBSR0IgY2hhbm5lbHMgdG8gdXNlLlxyXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gYWxwaGFJbWFnZSBUaGUgaW1hZ2UgKG9yIGNhbnZhcykgY29udGFpbmluZyB0aGUgYWxwaGEgY2hhbm5lbCB0byB1c2UuXHJcblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgY2FudmFzIHdpbGwgYmUgdXNlZCBhbmQgcmV0dXJuZWQuIElmIG5vdCwgYSBuZXcgY2FudmFzIHdpbGwgYmUgY3JlYXRlZC5cclxuXHQgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gQSBjYW52YXMgd2l0aCB0aGUgY29tYmluZWQgaW1hZ2UgZGF0YS4gVGhpcyBjYW4gYmUgdXNlZCBhcyBhIHNvdXJjZSBmb3IgQml0bWFwIG9yIFNwcml0ZVNoZWV0LlxyXG5cdCAqIEBkZXByZWNhdGVkIFRvb2xzIHN1Y2ggYXMgSW1hZ2VBbHBoYSBnZW5lcmFsbHkgcHJvdmlkZSBiZXR0ZXIgcmVzdWx0cy4gVGhpcyB3aWxsIGJlIG1vdmVkIHRvIHNhbmRib3ggaW4gdGhlIGZ1dHVyZS5cclxuXHQqL1xyXG5cdFNwcml0ZVNoZWV0VXRpbHMubWVyZ2VBbHBoYSA9IGZ1bmN0aW9uKHJnYkltYWdlLCBhbHBoYUltYWdlLCBjYW52YXMpIHtcclxuXHRcdGlmICghY2FudmFzKSB7IGNhbnZhcyA9IGNyZWF0ZWpzLmNyZWF0ZUNhbnZhcz9jcmVhdGVqcy5jcmVhdGVDYW52YXMoKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpOyB9XHJcblx0XHRjYW52YXMud2lkdGggPSBNYXRoLm1heChhbHBoYUltYWdlLndpZHRoLCByZ2JJbWFnZS53aWR0aCk7XHJcblx0XHRjYW52YXMuaGVpZ2h0ID0gTWF0aC5tYXgoYWxwaGFJbWFnZS5oZWlnaHQsIHJnYkltYWdlLmhlaWdodCk7XHJcblx0XHR2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHRcdGN0eC5zYXZlKCk7XHJcblx0XHRjdHguZHJhd0ltYWdlKHJnYkltYWdlLDAsMCk7XHJcblx0XHRjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1pblwiO1xyXG5cdFx0Y3R4LmRyYXdJbWFnZShhbHBoYUltYWdlLDAsMCk7XHJcblx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdFx0cmV0dXJuIGNhbnZhcztcclxuXHR9O1xyXG5cclxuXHJcbi8vIHByaXZhdGUgc3RhdGljIG1ldGhvZHM6XHJcblx0U3ByaXRlU2hlZXRVdGlscy5fZmxpcCA9IGZ1bmN0aW9uKHNwcml0ZVNoZWV0LCBjb3VudCwgaCwgdikge1xyXG5cdFx0dmFyIGltZ3MgPSBzcHJpdGVTaGVldC5faW1hZ2VzO1xyXG5cdFx0dmFyIGNhbnZhcyA9IFNwcml0ZVNoZWV0VXRpbHMuX3dvcmtpbmdDYW52YXM7XHJcblx0XHR2YXIgY3R4ID0gU3ByaXRlU2hlZXRVdGlscy5fd29ya2luZ0NvbnRleHQ7XHJcblx0XHR2YXIgaWwgPSBpbWdzLmxlbmd0aC9jb3VudDtcclxuXHRcdGZvciAodmFyIGk9MDtpPGlsO2krKykge1xyXG5cdFx0XHR2YXIgc3JjID0gaW1nc1tpXTtcclxuXHRcdFx0c3JjLl9fdG1wID0gaTsgLy8gYSBiaXQgaGFja3ksIGJ1dCBmYXN0ZXIgdGhhbiBkb2luZyBpbmRleE9mIGJlbG93LlxyXG5cdFx0XHRjdHguc2V0VHJhbnNmb3JtKDEsMCwwLDEsMCwwKTtcclxuXHRcdFx0Y3R4LmNsZWFyUmVjdCgwLDAsY2FudmFzLndpZHRoKzEsY2FudmFzLmhlaWdodCsxKTtcclxuXHRcdFx0Y2FudmFzLndpZHRoID0gc3JjLndpZHRoO1xyXG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gc3JjLmhlaWdodDtcclxuXHRcdFx0Y3R4LnNldFRyYW5zZm9ybShoPy0xOjEsIDAsIDAsIHY/LTE6MSwgaD9zcmMud2lkdGg6MCwgdj9zcmMuaGVpZ2h0OjApO1xyXG5cdFx0XHRjdHguZHJhd0ltYWdlKHNyYywwLDApO1xyXG5cdFx0XHR2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcclxuXHRcdFx0aW1nLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XHJcblx0XHRcdC8vIHdvcmsgYXJvdW5kIGEgc3RyYW5nZSBidWcgaW4gU2FmYXJpOlxyXG5cdFx0XHRpbWcud2lkdGggPSBzcmMud2lkdGg7XHJcblx0XHRcdGltZy5oZWlnaHQgPSBzcmMuaGVpZ2h0O1xyXG5cdFx0XHRpbWdzLnB1c2goaW1nKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZnJhbWVzID0gc3ByaXRlU2hlZXQuX2ZyYW1lcztcclxuXHRcdHZhciBmbCA9IGZyYW1lcy5sZW5ndGgvY291bnQ7XHJcblx0XHRmb3IgKGk9MDtpPGZsO2krKykge1xyXG5cdFx0XHRzcmMgPSBmcmFtZXNbaV07XHJcblx0XHRcdHZhciByZWN0ID0gc3JjLnJlY3QuY2xvbmUoKTtcclxuXHRcdFx0aW1nID0gaW1nc1tzcmMuaW1hZ2UuX190bXAraWwqY291bnRdO1xyXG5cclxuXHRcdFx0dmFyIGZyYW1lID0ge2ltYWdlOmltZyxyZWN0OnJlY3QscmVnWDpzcmMucmVnWCxyZWdZOnNyYy5yZWdZfTtcclxuXHRcdFx0aWYgKGgpIHtcclxuXHRcdFx0XHRyZWN0LnggPSBpbWcud2lkdGgtcmVjdC54LXJlY3Qud2lkdGg7IC8vIHVwZGF0ZSByZWN0XHJcblx0XHRcdFx0ZnJhbWUucmVnWCA9IHJlY3Qud2lkdGgtc3JjLnJlZ1g7IC8vIHVwZGF0ZSByZWdpc3RyYXRpb24gcG9pbnRcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodikge1xyXG5cdFx0XHRcdHJlY3QueSA9IGltZy5oZWlnaHQtcmVjdC55LXJlY3QuaGVpZ2h0OyAgLy8gdXBkYXRlIHJlY3RcclxuXHRcdFx0XHRmcmFtZS5yZWdZID0gcmVjdC5oZWlnaHQtc3JjLnJlZ1k7IC8vIHVwZGF0ZSByZWdpc3RyYXRpb24gcG9pbnRcclxuXHRcdFx0fVxyXG5cdFx0XHRmcmFtZXMucHVzaChmcmFtZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNmeCA9IFwiX1wiKyhoP1wiaFwiOlwiXCIpKyh2P1widlwiOlwiXCIpO1xyXG5cdFx0dmFyIG5hbWVzID0gc3ByaXRlU2hlZXQuX2FuaW1hdGlvbnM7XHJcblx0XHR2YXIgZGF0YSA9IHNwcml0ZVNoZWV0Ll9kYXRhO1xyXG5cdFx0dmFyIGFsID0gbmFtZXMubGVuZ3RoL2NvdW50O1xyXG5cdFx0Zm9yIChpPTA7aTxhbDtpKyspIHtcclxuXHRcdFx0dmFyIG5hbWUgPSBuYW1lc1tpXTtcclxuXHRcdFx0c3JjID0gZGF0YVtuYW1lXTtcclxuXHRcdFx0dmFyIGFuaW0gPSB7bmFtZTpuYW1lK3NmeCxzcGVlZDpzcmMuc3BlZWQsbmV4dDpzcmMubmV4dCxmcmFtZXM6W119O1xyXG5cdFx0XHRpZiAoc3JjLm5leHQpIHsgYW5pbS5uZXh0ICs9IHNmeDsgfVxyXG5cdFx0XHRmcmFtZXMgPSBzcmMuZnJhbWVzO1xyXG5cdFx0XHRmb3IgKHZhciBqPTAsbD1mcmFtZXMubGVuZ3RoO2o8bDtqKyspIHtcclxuXHRcdFx0XHRhbmltLmZyYW1lcy5wdXNoKGZyYW1lc1tqXStmbCpjb3VudCk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZGF0YVthbmltLm5hbWVdID0gYW5pbTtcclxuXHRcdFx0bmFtZXMucHVzaChhbmltLm5hbWUpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cclxuXHRjcmVhdGVqcy5TcHJpdGVTaGVldFV0aWxzID0gU3ByaXRlU2hlZXRVdGlscztcclxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNwcml0ZVNoZWV0QnVpbGRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogVGhlIFNwcml0ZVNoZWV0QnVpbGRlciBhbGxvd3MgeW91IHRvIGdlbmVyYXRlIHNwcml0ZSBzaGVldHMgYXQgcnVuIHRpbWUgZnJvbSBhbnkgZGlzcGxheSBvYmplY3QuIFRoaXMgY2FuIGFsbG93XG5cdCAqIHlvdSB0byBtYWludGFpbiB5b3VyIGFzc2V0cyBhcyB2ZWN0b3IgZ3JhcGhpY3MgKGZvciBsb3cgZmlsZSBzaXplKSwgYW5kIHJlbmRlciB0aGVtIGF0IHJ1biB0aW1lIGFzIHNwcml0ZSBzaGVldHNcblx0ICogZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cblx0ICpcblx0ICogU3ByaXRlIHNoZWV0cyBjYW4gYmUgYnVpbHQgZWl0aGVyIHN5bmNocm9ub3VzbHksIG9yIGFzeW5jaHJvbm91c2x5LCBzbyB0aGF0IGxhcmdlIHNwcml0ZSBzaGVldHMgY2FuIGJlIGdlbmVyYXRlZFxuXHQgKiB3aXRob3V0IGxvY2tpbmcgdGhlIFVJLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIFwiaW1hZ2VzXCIgdXNlZCBpbiB0aGUgZ2VuZXJhdGVkIHNwcml0ZSBzaGVldCBhcmUgYWN0dWFsbHkgY2FudmFzIGVsZW1lbnRzLCBhbmQgdGhhdCB0aGV5IHdpbGwgYmUgc2l6ZWRcblx0ICogdG8gdGhlIG5lYXJlc3QgcG93ZXIgb2YgMiB1cCB0byB0aGUgdmFsdWUgb2YgPGNvZGU+bWF4V2lkdGg8L2NvZGU+IG9yIDxjb2RlPm1heEhlaWdodDwvY29kZT4uXG5cdCAqIEBjbGFzcyBTcHJpdGVTaGVldEJ1aWxkZXJcblx0ICogQGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIFNwcml0ZVNoZWV0QnVpbGRlcigpIHtcblx0XHR0aGlzLkV2ZW50RGlzcGF0Y2hlcl9jb25zdHJ1Y3RvcigpO1xuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgbWF4aW11bSB3aWR0aCBmb3IgdGhlIGltYWdlcyAobm90IGluZGl2aWR1YWwgZnJhbWVzKSBpbiB0aGUgZ2VuZXJhdGVkIHNwcml0ZSBzaGVldC4gSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlXG5cdFx0ICogYSBwb3dlciBvZiAyIGZvciB0aGlzIHZhbHVlIChleC4gMTAyNCwgMjA0OCwgNDA5NikuIElmIHRoZSBmcmFtZXMgY2Fubm90IGFsbCBmaXQgd2l0aGluIHRoZSBtYXggZGltZW5zaW9ucywgdGhlblxuXHRcdCAqIGFkZGl0aW9uYWwgaW1hZ2VzIHdpbGwgYmUgY3JlYXRlZCBhcyBuZWVkZWQuXG5cdFx0ICogQHByb3BlcnR5IG1heFdpZHRoXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMjA0OFxuXHRcdCovXG5cdFx0dGhpcy5tYXhXaWR0aCA9IDIwNDg7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBtYXhpbXVtIGhlaWdodCBmb3IgdGhlIGltYWdlcyAobm90IGluZGl2aWR1YWwgZnJhbWVzKSBpbiB0aGUgZ2VuZXJhdGVkIHNwcml0ZSBzaGVldC4gSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlXG5cdFx0ICogYSBwb3dlciBvZiAyIGZvciB0aGlzIHZhbHVlIChleC4gMTAyNCwgMjA0OCwgNDA5NikuIElmIHRoZSBmcmFtZXMgY2Fubm90IGFsbCBmaXQgd2l0aGluIHRoZSBtYXggZGltZW5zaW9ucywgdGhlblxuXHRcdCAqIGFkZGl0aW9uYWwgaW1hZ2VzIHdpbGwgYmUgY3JlYXRlZCBhcyBuZWVkZWQuXG5cdFx0ICogQHByb3BlcnR5IG1heEhlaWdodFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDIwNDhcblx0XHQgKiovXG5cdFx0dGhpcy5tYXhIZWlnaHQgPSAyMDQ4O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgc3ByaXRlIHNoZWV0IHRoYXQgd2FzIGdlbmVyYXRlZC4gVGhpcyB3aWxsIGJlIG51bGwgYmVmb3JlIGEgYnVpbGQgaXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cblx0XHQgKiBAcHJvcGVydHkgc3ByaXRlU2hlZXRcblx0XHQgKiBAdHlwZSBTcHJpdGVTaGVldFxuXHRcdCAqKi9cblx0XHR0aGlzLnNwcml0ZVNoZWV0ID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHNjYWxlIHRvIGFwcGx5IHdoZW4gZHJhd2luZyBhbGwgZnJhbWVzIHRvIHRoZSBzcHJpdGUgc2hlZXQuIFRoaXMgaXMgbXVsdGlwbGllZCBhZ2FpbnN0IGFueSBzY2FsZSBzcGVjaWZpZWRcblx0XHQgKiBpbiB0aGUgYWRkRnJhbWUgY2FsbC4gVGhpcyBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIHRvIGdlbmVyYXRlIGEgc3ByaXRlIHNoZWV0IGF0IHJ1biB0aW1lIHRoYXQgaXMgdGFpbG9yZWQgdG9cblx0XHQgKiB0aGUgYSBzcGVjaWZpYyBkZXZpY2UgcmVzb2x1dGlvbiAoZXguIHRhYmxldCB2cyBtb2JpbGUpLlxuXHRcdCAqIEBwcm9wZXJ0eSBzY2FsZVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKiovXG5cdFx0dGhpcy5zY2FsZSA9IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCogVGhlIHBhZGRpbmcgdG8gdXNlIGJldHdlZW4gZnJhbWVzLiBUaGlzIGlzIGhlbHBmdWwgdG8gcHJlc2VydmUgYW50aWFsaWFzaW5nIG9uIGRyYXduIHZlY3RvciBjb250ZW50LlxuXHRcdCogQHByb3BlcnR5IHBhZGRpbmdcblx0XHQqIEB0eXBlIE51bWJlclxuXHRcdCogQGRlZmF1bHQgMVxuXHRcdCoqL1xuXHRcdHRoaXMucGFkZGluZyA9IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEEgbnVtYmVyIGZyb20gMC4wMSB0byAwLjk5IHRoYXQgaW5kaWNhdGVzIHdoYXQgcGVyY2VudGFnZSBvZiB0aW1lIHRoZSBidWlsZGVyIGNhbiB1c2UuIFRoaXMgY2FuIGJlXG5cdFx0ICogdGhvdWdodCBvZiBhcyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgcGVyIHNlY29uZCB0aGUgYnVpbGRlciB3aWxsIHVzZS4gRm9yIGV4YW1wbGUsIHdpdGggYSB0aW1lU2xpY2UgdmFsdWUgb2YgMC4zLFxuXHRcdCAqIHRoZSBidWlsZGVyIHdpbGwgcnVuIDIwIHRpbWVzIHBlciBzZWNvbmQsIHVzaW5nIGFwcHJveGltYXRlbHkgMTVtcyBwZXIgYnVpbGQgKDMwJSBvZiBhdmFpbGFibGUgdGltZSwgb3IgMC4zcyBwZXIgc2Vjb25kKS5cblx0XHQgKiBEZWZhdWx0cyB0byAwLjMuXG5cdFx0ICogQHByb3BlcnR5IHRpbWVTbGljZVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDAuM1xuXHRcdCAqKi9cblx0XHR0aGlzLnRpbWVTbGljZSA9IDAuMztcblx0XG5cdFx0LyoqXG5cdFx0ICogQSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEgdGhhdCBpbmRpY2F0ZXMgdGhlIHByb2dyZXNzIG9mIGEgYnVpbGQsIG9yIC0xIGlmIGEgYnVpbGQgaGFzIG5vdFxuXHRcdCAqIGJlZW4gaW5pdGlhdGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBwcm9ncmVzc1xuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IC0xXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSAtMTtcblx0XG5cdFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9mcmFtZXNcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgQXJyYXlcblx0XHQgKiovXG5cdFx0dGhpcy5fZnJhbWVzID0gW107XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfYW5pbWF0aW9uc1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBBcnJheVxuXHRcdCAqKi9cblx0XHR0aGlzLl9hbmltYXRpb25zID0ge307XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfZGF0YVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBBcnJheVxuXHRcdCAqKi9cblx0XHR0aGlzLl9kYXRhID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9uZXh0RnJhbWVJbmRleFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fbmV4dEZyYW1lSW5kZXggPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2luZGV4XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9pbmRleCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfdGltZXJJRFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fdGltZXJJRCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfc2NhbGVcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3NjYWxlID0gMTtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTcHJpdGVTaGVldEJ1aWxkZXIsIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlcik7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cbi8vIGNvbnN0YW50czpcblx0U3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9ESU1FTlNJT05TID0gXCJmcmFtZSBkaW1lbnNpb25zIGV4Y2VlZCBtYXggc3ByaXRlc2hlZXQgZGltZW5zaW9uc1wiO1xuXHRTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX1JVTk5JTkcgPSBcImEgYnVpbGQgaXMgYWxyZWFkeSBydW5uaW5nXCI7XG5cbi8vIGV2ZW50czpcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiBhIGJ1aWxkIGNvbXBsZXRlcy5cblx0ICogQGV2ZW50IGNvbXBsZXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gYW4gYXN5bmNocm9ub3VzIGJ1aWxkIGhhcyBwcm9ncmVzcy5cblx0ICogQGV2ZW50IHByb2dyZXNzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHByb2dyZXNzIFRoZSBjdXJyZW50IHByb2dyZXNzIHZhbHVlICgwLTEpLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBBZGRzIGEgZnJhbWUgdG8gdGhlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319LiBOb3RlIHRoYXQgdGhlIGZyYW1lIHdpbGwgbm90IGJlIGRyYXduIHVudGlsIHlvdVxuXHQgKiBjYWxsIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0QnVpbGRlci9idWlsZFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuIFRoZSBvcHRpb25hbCBzZXR1cCBwYXJhbXMgYWxsb3cgeW91IHRvIGhhdmVcblx0ICogYSBmdW5jdGlvbiBydW4gaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkcmF3IG9jY3Vycy4gRm9yIGV4YW1wbGUsIHRoaXMgYWxsb3dzIHlvdSB0byBhZGQgYSBzaW5nbGUgc291cmNlIG11bHRpcGxlXG5cdCAqIHRpbWVzLCBidXQgbWFuaXB1bGF0ZSBpdCBvciBpdHMgY2hpbGRyZW4gdG8gY2hhbmdlIGl0IHRvIGdlbmVyYXRlIGRpZmZlcmVudCBmcmFtZXMuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgc291cmNlJ3MgdHJhbnNmb3JtYXRpb25zICh4LCB5LCBzY2FsZSwgcm90YXRlLCBhbHBoYSkgd2lsbCBiZSBpZ25vcmVkLCBleGNlcHQgZm9yIHJlZ1gvWS4gVG8gYXBwbHlcblx0ICogdHJhbnNmb3JtcyB0byBhIHNvdXJjZSBvYmplY3QgYW5kIGhhdmUgdGhlbSBjYXB0dXJlZCBpbiB0aGUgc3ByaXRlIHNoZWV0LCBzaW1wbHkgcGxhY2UgaXQgaW50byBhIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBhbmQgcGFzcyBpbiB0aGUgQ29udGFpbmVyIGFzIHRoZSBzb3VyY2UuXG5cdCAqIEBtZXRob2QgYWRkRnJhbWVcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0XCJ9fXt7L2Nyb3NzTGlua319ICB0byBkcmF3IGFzIHRoZSBmcmFtZS5cblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IFtzb3VyY2VSZWN0XSBBIHt7I2Nyb3NzTGluayBcIlJlY3RhbmdsZVwifX17ey9jcm9zc0xpbmt9fSBkZWZpbmluZyB0aGUgcG9ydGlvbiBvZiB0aGVcblx0ICogc291cmNlIHRvIGRyYXcgdG8gdGhlIGZyYW1lLiBJZiBub3Qgc3BlY2lmaWVkLCBpdCB3aWxsIGxvb2sgZm9yIGEgPGNvZGU+Z2V0Qm91bmRzPC9jb2RlPiBtZXRob2QsIGJvdW5kcyBwcm9wZXJ0eSxcblx0ICogb3IgPGNvZGU+bm9taW5hbEJvdW5kczwvY29kZT4gcHJvcGVydHkgb24gdGhlIHNvdXJjZSB0byB1c2UuIElmIG9uZSBpcyBub3QgZm91bmQsIHRoZSBmcmFtZSB3aWxsIGJlIHNraXBwZWQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGU9MV0gT3B0aW9uYWwuIFRoZSBzY2FsZSB0byBkcmF3IHRoaXMgZnJhbWUgYXQuIERlZmF1bHQgaXMgMS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW3NldHVwRnVuY3Rpb25dIEEgZnVuY3Rpb24gdG8gY2FsbCBpbW1lZGlhdGVseSBiZWZvcmUgZHJhd2luZyB0aGlzIGZyYW1lLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHR3byBwYXJhbWV0ZXJzOiB0aGUgc291cmNlLCBhbmQgc2V0dXBEYXRhLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3NldHVwRGF0YV0gQXJiaXRyYXJ5IHNldHVwIGRhdGEgdG8gcGFzcyB0byBzZXR1cEZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgZnJhbWUgdGhhdCB3YXMganVzdCBhZGRlZCwgb3IgbnVsbCBpZiBhIHNvdXJjZVJlY3QgY291bGQgbm90IGJlIGRldGVybWluZWQuXG5cdCAqKi9cblx0cC5hZGRGcmFtZSA9IGZ1bmN0aW9uKHNvdXJjZSwgc291cmNlUmVjdCwgc2NhbGUsIHNldHVwRnVuY3Rpb24sIHNldHVwRGF0YSkge1xuXHRcdGlmICh0aGlzLl9kYXRhKSB7IHRocm93IFNwcml0ZVNoZWV0QnVpbGRlci5FUlJfUlVOTklORzsgfVxuXHRcdHZhciByZWN0ID0gc291cmNlUmVjdHx8c291cmNlLmJvdW5kc3x8c291cmNlLm5vbWluYWxCb3VuZHM7XG5cdFx0aWYgKCFyZWN0JiZzb3VyY2UuZ2V0Qm91bmRzKSB7IHJlY3QgPSBzb3VyY2UuZ2V0Qm91bmRzKCk7IH1cblx0XHRpZiAoIXJlY3QpIHsgcmV0dXJuIG51bGw7IH1cblx0XHRzY2FsZSA9IHNjYWxlfHwxO1xuXHRcdHJldHVybiB0aGlzLl9mcmFtZXMucHVzaCh7c291cmNlOnNvdXJjZSwgc291cmNlUmVjdDpyZWN0LCBzY2FsZTpzY2FsZSwgZnVuY3Q6c2V0dXBGdW5jdGlvbiwgZGF0YTpzZXR1cERhdGEsIGluZGV4OnRoaXMuX2ZyYW1lcy5sZW5ndGgsIGhlaWdodDpyZWN0LmhlaWdodCpzY2FsZX0pLTE7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gYW5pbWF0aW9uIHRoYXQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgY3JlYXRlZCBzcHJpdGUgc2hlZXQuXG5cdCAqIEBtZXRob2QgYWRkQW5pbWF0aW9uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIGZvciB0aGUgYW5pbWF0aW9uLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBmcmFtZXMgQW4gYXJyYXkgb2YgZnJhbWUgaW5kZXhlcyB0aGF0IGNvbXByaXNlIHRoZSBhbmltYXRpb24uIEV4LiBbMyw2LDVdIHdvdWxkIGRlc2NyaWJlIGFuIGFuaW1hdGlvblxuXHQgKiB0aGF0IHBsYXllZCBmcmFtZSBpbmRleGVzIDMsIDYsIGFuZCA1IGluIHRoYXQgb3JkZXIuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbbmV4dF0gU3BlY2lmaWVzIHRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gY29udGludWUgdG8gYWZ0ZXIgdGhpcyBhbmltYXRpb24gZW5kcy4gWW91IGNhblxuXHQgKiBhbHNvIHBhc3MgZmFsc2UgdG8gaGF2ZSB0aGUgYW5pbWF0aW9uIHN0b3Agd2hlbiBpdCBlbmRzLiBCeSBkZWZhdWx0IGl0IHdpbGwgbG9vcCB0byB0aGUgc3RhcnQgb2YgdGhlIHNhbWUgYW5pbWF0aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2ZyZXF1ZW5jeV0gU3BlY2lmaWVzIGEgZnJhbWUgYWR2YW5jZSBmcmVxdWVuY3kgZm9yIHRoaXMgYW5pbWF0aW9uLiBGb3IgZXhhbXBsZSwgYSB2YWx1ZVxuXHQgKiBvZiAyIHdvdWxkIGNhdXNlIHRoZSBhbmltYXRpb24gdG8gYWR2YW5jZSBldmVyeSBzZWNvbmQgdGljay5cblx0ICoqL1xuXHRwLmFkZEFuaW1hdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIGZyYW1lcywgbmV4dCwgZnJlcXVlbmN5KSB7XG5cdFx0aWYgKHRoaXMuX2RhdGEpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9SVU5OSU5HOyB9XG5cdFx0dGhpcy5fYW5pbWF0aW9uc1tuYW1lXSA9IHtmcmFtZXM6ZnJhbWVzLCBuZXh0Om5leHQsIGZyZXF1ZW5jeTpmcmVxdWVuY3l9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGlzIHdpbGwgdGFrZSBhIE1vdmllQ2xpcCBpbnN0YW5jZSwgYW5kIGFkZCBpdHMgZnJhbWVzIGFuZCBsYWJlbHMgdG8gdGhpcyBidWlsZGVyLiBMYWJlbHMgd2lsbCBiZSBhZGRlZCBhcyBhbiBhbmltYXRpb25cblx0ICogcnVubmluZyBmcm9tIHRoZSBsYWJlbCBpbmRleCB0byB0aGUgbmV4dCBsYWJlbC4gRm9yIGV4YW1wbGUsIGlmIHRoZXJlIGlzIGEgbGFiZWwgbmFtZWQgXCJmb29cIiBhdCBmcmFtZSAwIGFuZCBhIGxhYmVsXG5cdCAqIG5hbWVkIFwiYmFyXCIgYXQgZnJhbWUgMTAsIGluIGEgTW92aWVDbGlwIHdpdGggMTUgZnJhbWVzLCBpdCB3aWxsIGFkZCBhbiBhbmltYXRpb24gbmFtZWQgXCJmb29cIiB0aGF0IHJ1bnMgZnJvbSBmcmFtZVxuXHQgKiBpbmRleCAwIHRvIDksIGFuZCBhbiBhbmltYXRpb24gbmFtZWQgXCJiYXJcIiB0aGF0IHJ1bnMgZnJvbSBmcmFtZSBpbmRleCAxMCB0byAxNC5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoaXMgd2lsbCBpdGVyYXRlIHRocm91Z2ggdGhlIGZ1bGwgTW92aWVDbGlwIHdpdGggYWN0aW9uc0VuYWJsZWQgc2V0IHRvIGZhbHNlLCBlbmRpbmcgb24gdGhlIGxhc3QgZnJhbWUuXG5cdCAqIEBtZXRob2QgYWRkTW92aWVDbGlwXG5cdCAqIEBwYXJhbSB7TW92aWVDbGlwfSBzb3VyY2UgVGhlIHNvdXJjZSBNb3ZpZUNsaXAgaW5zdGFuY2UgdG8gYWRkIHRvIHRoZSBzcHJpdGUgc2hlZXQuXG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBbc291cmNlUmVjdF0gQSB7eyNjcm9zc0xpbmsgXCJSZWN0YW5nbGVcIn19e3svY3Jvc3NMaW5rfX0gZGVmaW5pbmcgdGhlIHBvcnRpb24gb2YgdGhlIHNvdXJjZSB0b1xuXHQgKiBkcmF3IHRvIHRoZSBmcmFtZS4gSWYgbm90IHNwZWNpZmllZCwgaXQgd2lsbCBsb29rIGZvciBhIDxjb2RlPmdldEJvdW5kczwvY29kZT4gbWV0aG9kLCA8Y29kZT5mcmFtZUJvdW5kczwvY29kZT5cblx0ICogQXJyYXksIDxjb2RlPmJvdW5kczwvY29kZT4gcHJvcGVydHksIG9yIDxjb2RlPm5vbWluYWxCb3VuZHM8L2NvZGU+IHByb3BlcnR5IG9uIHRoZSBzb3VyY2UgdG8gdXNlLiBJZiBvbmUgaXMgbm90XG5cdCAqIGZvdW5kLCB0aGUgTW92aWVDbGlwIHdpbGwgYmUgc2tpcHBlZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZT0xXSBUaGUgc2NhbGUgdG8gZHJhdyB0aGUgbW92aWUgY2xpcCBhdC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW3NldHVwRnVuY3Rpb25dIEEgZnVuY3Rpb24gdG8gY2FsbCBpbW1lZGlhdGVseSBiZWZvcmUgZHJhd2luZyBlYWNoIGZyYW1lLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRocmVlIHBhcmFtZXRlcnM6IHRoZSBzb3VyY2UsIHNldHVwRGF0YSwgYW5kIHRoZSBmcmFtZSBpbmRleC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtzZXR1cERhdGFdIEFyYml0cmFyeSBzZXR1cCBkYXRhIHRvIHBhc3MgdG8gc2V0dXBGdW5jdGlvbiBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2xhYmVsRnVuY3Rpb25dIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIG1vdmllY2xpcCBsYWJlbCB0aGF0IGlzIGFkZGVkIHdpdGggZm91ciBwYXJhbWV0ZXJzOiB0aGUgbGFiZWwgbmFtZSwgdGhlIHNvdXJjZSBtb3ZpZWNsaXAgaW5zdGFuY2UsIHRoZSBzdGFydGluZyBmcmFtZSBpbmRleCAoaW4gdGhlIG1vdmllY2xpcCB0aW1lbGluZSkgYW5kIHRoZSBlbmQgaW5kZXguIEl0IG11c3QgcmV0dXJuIGEgbmV3IG5hbWUgZm9yIHRoZSBsYWJlbC9hbmltYXRpb24sIG9yIGZhbHNlIHRvIGV4Y2x1ZGUgdGhlIGxhYmVsLlxuXHQgKiovXG5cdHAuYWRkTW92aWVDbGlwID0gZnVuY3Rpb24oc291cmNlLCBzb3VyY2VSZWN0LCBzY2FsZSwgc2V0dXBGdW5jdGlvbiwgc2V0dXBEYXRhLCBsYWJlbEZ1bmN0aW9uKSB7XG5cdFx0aWYgKHRoaXMuX2RhdGEpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9SVU5OSU5HOyB9XG5cdFx0dmFyIHJlY3RzID0gc291cmNlLmZyYW1lQm91bmRzO1xuXHRcdHZhciByZWN0ID0gc291cmNlUmVjdHx8c291cmNlLmJvdW5kc3x8c291cmNlLm5vbWluYWxCb3VuZHM7XG5cdFx0aWYgKCFyZWN0JiZzb3VyY2UuZ2V0Qm91bmRzKSB7IHJlY3QgPSBzb3VyY2UuZ2V0Qm91bmRzKCk7IH1cblx0XHRpZiAoIXJlY3QgJiYgIXJlY3RzKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGksIGwsIGJhc2VGcmFtZUluZGV4ID0gdGhpcy5fZnJhbWVzLmxlbmd0aDtcblx0XHR2YXIgZHVyYXRpb24gPSBzb3VyY2UudGltZWxpbmUuZHVyYXRpb247XG5cdFx0Zm9yIChpPTA7IGk8ZHVyYXRpb247IGkrKykge1xuXHRcdFx0dmFyIHIgPSAocmVjdHMmJnJlY3RzW2ldKSA/IHJlY3RzW2ldIDogcmVjdDtcblx0XHRcdHRoaXMuYWRkRnJhbWUoc291cmNlLCByLCBzY2FsZSwgdGhpcy5fc2V0dXBNb3ZpZUNsaXBGcmFtZSwge2k6aSwgZjpzZXR1cEZ1bmN0aW9uLCBkOnNldHVwRGF0YX0pO1xuXHRcdH1cblx0XHR2YXIgbGFiZWxzID0gc291cmNlLnRpbWVsaW5lLl9sYWJlbHM7XG5cdFx0dmFyIGxibHMgPSBbXTtcblx0XHRmb3IgKHZhciBuIGluIGxhYmVscykge1xuXHRcdFx0bGJscy5wdXNoKHtpbmRleDpsYWJlbHNbbl0sIGxhYmVsOm59KTtcblx0XHR9XG5cdFx0aWYgKGxibHMubGVuZ3RoKSB7XG5cdFx0XHRsYmxzLnNvcnQoZnVuY3Rpb24oYSxiKXsgcmV0dXJuIGEuaW5kZXgtYi5pbmRleDsgfSk7XG5cdFx0XHRmb3IgKGk9MCxsPWxibHMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0XHR2YXIgbGFiZWwgPSBsYmxzW2ldLmxhYmVsO1xuXHRcdFx0XHR2YXIgc3RhcnQgPSBiYXNlRnJhbWVJbmRleCtsYmxzW2ldLmluZGV4O1xuXHRcdFx0XHR2YXIgZW5kID0gYmFzZUZyYW1lSW5kZXgrKChpID09IGwtMSkgPyBkdXJhdGlvbiA6IGxibHNbaSsxXS5pbmRleCk7XG5cdFx0XHRcdHZhciBmcmFtZXMgPSBbXTtcblx0XHRcdFx0Zm9yICh2YXIgaj1zdGFydDsgajxlbmQ7IGorKykgeyBmcmFtZXMucHVzaChqKTsgfVxuXHRcdFx0XHRpZiAobGFiZWxGdW5jdGlvbikge1xuXHRcdFx0XHRcdGxhYmVsID0gbGFiZWxGdW5jdGlvbihsYWJlbCwgc291cmNlLCBzdGFydCwgZW5kKTtcblx0XHRcdFx0XHRpZiAoIWxhYmVsKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5hZGRBbmltYXRpb24obGFiZWwsIGZyYW1lcywgdHJ1ZSk7IC8vIGZvciBub3csIHRoaXMgbG9vcHMgYWxsIGFuaW1hdGlvbnMuXG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBCdWlsZHMgYSBTcHJpdGVTaGVldCBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBmcmFtZXMuXG5cdCAqIEBtZXRob2QgYnVpbGRcblx0ICogQHJldHVybiB7U3ByaXRlU2hlZXR9IFRoZSBjcmVhdGVkIFNwcml0ZVNoZWV0IGluc3RhbmNlLCBvciBudWxsIGlmIGEgYnVpbGQgaXMgYWxyZWFkeSBydW5uaW5nIG9yIGFuIGVycm9yIG9jY3VycmVkLlxuXHQgKiovXG5cdHAuYnVpbGQgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fZGF0YSkgeyB0aHJvdyBTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX1JVTk5JTkc7IH1cblx0XHR0aGlzLl9zdGFydEJ1aWxkKCk7XG5cdFx0d2hpbGUgKHRoaXMuX2RyYXdOZXh0KCkpIHt9XG5cdFx0dGhpcy5fZW5kQnVpbGQoKTtcblx0XHRyZXR1cm4gdGhpcy5zcHJpdGVTaGVldDtcblx0fTtcblxuXHQvKipcblx0ICogQXN5bmNocm9ub3VzbHkgYnVpbGRzIGEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZnJhbWVzLiBJdCB3aWxsXG5cdCAqIHJ1biAyMCB0aW1lcyBwZXIgc2Vjb25kLCB1c2luZyBhbiBhbW91bnQgb2YgdGltZSBkZWZpbmVkIGJ5IDxjb2RlPnRpbWVTbGljZTwvY29kZT4uIFdoZW4gaXQgaXMgY29tcGxldGUgaXQgd2lsbFxuXHQgKiBjYWxsIHRoZSBzcGVjaWZpZWQgY2FsbGJhY2suXG5cdCAqIEBtZXRob2QgYnVpbGRBc3luY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVTbGljZV0gU2V0cyB0aGUgdGltZVNsaWNlIHByb3BlcnR5IG9uIHRoaXMgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5idWlsZEFzeW5jID0gZnVuY3Rpb24odGltZVNsaWNlKSB7XG5cdFx0aWYgKHRoaXMuX2RhdGEpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9SVU5OSU5HOyB9XG5cdFx0dGhpcy50aW1lU2xpY2UgPSB0aW1lU2xpY2U7XG5cdFx0dGhpcy5fc3RhcnRCdWlsZCgpO1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dGhpcy5fdGltZXJJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IF90aGlzLl9ydW4oKTsgfSwgNTAtTWF0aC5tYXgoMC4wMSwgTWF0aC5taW4oMC45OSwgdGhpcy50aW1lU2xpY2V8fDAuMykpKjUwKTtcblx0fTtcblxuXHQvKipcblx0ICogU3RvcHMgdGhlIGN1cnJlbnQgYXN5bmNocm9ub3VzIGJ1aWxkLlxuXHQgKiBAbWV0aG9kIHN0b3BBc3luY1xuXHQgKiovXG5cdHAuc3RvcEFzeW5jID0gZnVuY3Rpb24oKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVySUQpO1xuXHRcdHRoaXMuX2RhdGEgPSBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTcHJpdGVTaGVldEJ1aWxkZXIgaW5zdGFuY2VzIGNhbm5vdCBiZSBjbG9uZWQuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3coXCJTcHJpdGVTaGVldEJ1aWxkZXIgY2Fubm90IGJlIGNsb25lZC5cIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltTcHJpdGVTaGVldEJ1aWxkZXJdXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfc3RhcnRCdWlsZFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fc3RhcnRCdWlsZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYWQgPSB0aGlzLnBhZGRpbmd8fDA7XG5cdFx0dGhpcy5wcm9ncmVzcyA9IDA7XG5cdFx0dGhpcy5zcHJpdGVTaGVldCA9IG51bGw7XG5cdFx0dGhpcy5faW5kZXggPSAwO1xuXHRcdHRoaXMuX3NjYWxlID0gdGhpcy5zY2FsZTtcblx0XHR2YXIgZGF0YUZyYW1lcyA9IFtdO1xuXHRcdHRoaXMuX2RhdGEgPSB7XG5cdFx0XHRpbWFnZXM6IFtdLFxuXHRcdFx0ZnJhbWVzOiBkYXRhRnJhbWVzLFxuXHRcdFx0YW5pbWF0aW9uczogdGhpcy5fYW5pbWF0aW9ucyAvLyBUT0RPOiBzaG91bGQgd2UgXCJjbG9uZVwiIF9hbmltYXRpb25zIGluIGNhc2Ugc29tZW9uZSBhZGRzIG1vcmUgYW5pbWF0aW9ucyBhZnRlciBhIGJ1aWxkP1xuXHRcdH07XG5cblx0XHR2YXIgZnJhbWVzID0gdGhpcy5fZnJhbWVzLnNsaWNlKCk7XG5cdFx0ZnJhbWVzLnNvcnQoZnVuY3Rpb24oYSxiKSB7IHJldHVybiAoYS5oZWlnaHQ8PWIuaGVpZ2h0KSA/IC0xIDogMTsgfSk7XG5cblx0XHRpZiAoZnJhbWVzW2ZyYW1lcy5sZW5ndGgtMV0uaGVpZ2h0K3BhZCoyID4gdGhpcy5tYXhIZWlnaHQpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9ESU1FTlNJT05TOyB9XG5cdFx0dmFyIHk9MCwgeD0wO1xuXHRcdHZhciBpbWcgPSAwO1xuXHRcdHdoaWxlIChmcmFtZXMubGVuZ3RoKSB7XG5cdFx0XHR2YXIgbyA9IHRoaXMuX2ZpbGxSb3coZnJhbWVzLCB5LCBpbWcsIGRhdGFGcmFtZXMsIHBhZCk7XG5cdFx0XHRpZiAoby53ID4geCkgeyB4ID0gby53OyB9XG5cdFx0XHR5ICs9IG8uaDtcblx0XHRcdGlmICghby5oIHx8ICFmcmFtZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBjYW52YXMgPSBjcmVhdGVqcy5jcmVhdGVDYW52YXM/Y3JlYXRlanMuY3JlYXRlQ2FudmFzKCk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblx0XHRcdFx0Y2FudmFzLndpZHRoID0gdGhpcy5fZ2V0U2l6ZSh4LHRoaXMubWF4V2lkdGgpO1xuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gdGhpcy5fZ2V0U2l6ZSh5LHRoaXMubWF4SGVpZ2h0KTtcblx0XHRcdFx0dGhpcy5fZGF0YS5pbWFnZXNbaW1nXSA9IGNhbnZhcztcblx0XHRcdFx0aWYgKCFvLmgpIHtcblx0XHRcdFx0XHR4PXk9MDtcblx0XHRcdFx0XHRpbWcrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9zZXR1cE1vdmllQ2xpcEZyYW1lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgd2lkdGggJiBoZWlnaHQgb2YgdGhlIHJvdy5cblx0ICoqL1xuXHRwLl9zZXR1cE1vdmllQ2xpcEZyYW1lID0gZnVuY3Rpb24oc291cmNlLCBkYXRhKSB7XG5cdFx0dmFyIGFlID0gc291cmNlLmFjdGlvbnNFbmFibGVkO1xuXHRcdHNvdXJjZS5hY3Rpb25zRW5hYmxlZCA9IGZhbHNlO1xuXHRcdHNvdXJjZS5nb3RvQW5kU3RvcChkYXRhLmkpO1xuXHRcdHNvdXJjZS5hY3Rpb25zRW5hYmxlZCA9IGFlO1xuXHRcdGRhdGEuZiYmZGF0YS5mKHNvdXJjZSwgZGF0YS5kLCBkYXRhLmkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRTaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgd2lkdGggJiBoZWlnaHQgb2YgdGhlIHJvdy5cblx0ICoqL1xuXHRwLl9nZXRTaXplID0gZnVuY3Rpb24oc2l6ZSxtYXgpIHtcblx0XHR2YXIgcG93ID0gNDtcblx0XHR3aGlsZSAoTWF0aC5wb3coMiwrK3BvdykgPCBzaXplKXt9XG5cdFx0cmV0dXJuIE1hdGgubWluKG1heCxNYXRoLnBvdygyLHBvdykpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9maWxsUm93XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGZyYW1lc1xuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IGltZ1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YUZyYW1lc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcGFkXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgd2lkdGggJiBoZWlnaHQgb2YgdGhlIHJvdy5cblx0ICoqL1xuXHRwLl9maWxsUm93ID0gZnVuY3Rpb24oZnJhbWVzLCB5LCBpbWcsIGRhdGFGcmFtZXMsIHBhZCkge1xuXHRcdHZhciB3ID0gdGhpcy5tYXhXaWR0aDtcblx0XHR2YXIgbWF4SCA9IHRoaXMubWF4SGVpZ2h0O1xuXHRcdHkgKz0gcGFkO1xuXHRcdHZhciBoID0gbWF4SC15O1xuXHRcdHZhciB4ID0gcGFkO1xuXHRcdHZhciBoZWlnaHQgPSAwO1xuXHRcdGZvciAodmFyIGk9ZnJhbWVzLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcblx0XHRcdHZhciBmcmFtZSA9IGZyYW1lc1tpXTtcblx0XHRcdHZhciBzYyA9IHRoaXMuX3NjYWxlKmZyYW1lLnNjYWxlO1xuXHRcdFx0dmFyIHJlY3QgPSBmcmFtZS5zb3VyY2VSZWN0O1xuXHRcdFx0dmFyIHNvdXJjZSA9IGZyYW1lLnNvdXJjZTtcblx0XHRcdHZhciByeCA9IE1hdGguZmxvb3Ioc2MqcmVjdC54LXBhZCk7XG5cdFx0XHR2YXIgcnkgPSBNYXRoLmZsb29yKHNjKnJlY3QueS1wYWQpO1xuXHRcdFx0dmFyIHJoID0gTWF0aC5jZWlsKHNjKnJlY3QuaGVpZ2h0K3BhZCoyKTtcblx0XHRcdHZhciBydyA9IE1hdGguY2VpbChzYypyZWN0LndpZHRoK3BhZCoyKTtcblx0XHRcdGlmIChydyA+IHcpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9ESU1FTlNJT05TOyB9XG5cdFx0XHRpZiAocmggPiBoIHx8IHgrcncgPiB3KSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRmcmFtZS5pbWcgPSBpbWc7XG5cdFx0XHRmcmFtZS5yZWN0ID0gbmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSh4LHkscncscmgpO1xuXHRcdFx0aGVpZ2h0ID0gaGVpZ2h0IHx8IHJoO1xuXHRcdFx0ZnJhbWVzLnNwbGljZShpLDEpO1xuXHRcdFx0ZGF0YUZyYW1lc1tmcmFtZS5pbmRleF0gPSBbeCx5LHJ3LHJoLGltZyxNYXRoLnJvdW5kKC1yeCtzYypzb3VyY2UucmVnWC1wYWQpLE1hdGgucm91bmQoLXJ5K3NjKnNvdXJjZS5yZWdZLXBhZCldO1xuXHRcdFx0eCArPSBydztcblx0XHR9XG5cdFx0cmV0dXJuIHt3OngsIGg6aGVpZ2h0fTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZW5kQnVpbGRcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2VuZEJ1aWxkID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zcHJpdGVTaGVldCA9IG5ldyBjcmVhdGVqcy5TcHJpdGVTaGVldCh0aGlzLl9kYXRhKTtcblx0XHR0aGlzLl9kYXRhID0gbnVsbDtcblx0XHR0aGlzLnByb2dyZXNzID0gMTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfcnVuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9ydW4gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdHMgPSBNYXRoLm1heCgwLjAxLCBNYXRoLm1pbigwLjk5LCB0aGlzLnRpbWVTbGljZXx8MC4zKSkqNTA7XG5cdFx0dmFyIHQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpK3RzO1xuXHRcdHZhciBjb21wbGV0ZSA9IGZhbHNlO1xuXHRcdHdoaWxlICh0ID4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSkge1xuXHRcdFx0aWYgKCF0aGlzLl9kcmF3TmV4dCgpKSB7IGNvbXBsZXRlID0gdHJ1ZTsgYnJlYWs7IH1cblx0XHR9XG5cdFx0aWYgKGNvbXBsZXRlKSB7XG5cdFx0XHR0aGlzLl9lbmRCdWlsZCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdFx0dGhpcy5fdGltZXJJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IF90aGlzLl9ydW4oKTsgfSwgNTAtdHMpO1xuXHRcdH1cblx0XHR2YXIgcCA9IHRoaXMucHJvZ3Jlc3MgPSB0aGlzLl9pbmRleC90aGlzLl9mcmFtZXMubGVuZ3RoO1xuXHRcdGlmICh0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiKSkge1xuXHRcdFx0dmFyIGV2dCA9IG5ldyBjcmVhdGVqcy5FdmVudChcInByb2dyZXNzXCIpO1xuXHRcdFx0ZXZ0LnByb2dyZXNzID0gcDtcblx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZHJhd05leHRcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIEJvb2xlYW4gUmV0dXJucyBmYWxzZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGRyYXcuXG5cdCAqKi9cblx0cC5fZHJhd05leHQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgZnJhbWUgPSB0aGlzLl9mcmFtZXNbdGhpcy5faW5kZXhdO1xuXHRcdHZhciBzYyA9IGZyYW1lLnNjYWxlKnRoaXMuX3NjYWxlO1xuXHRcdHZhciByZWN0ID0gZnJhbWUucmVjdDtcblx0XHR2YXIgc291cmNlUmVjdCA9IGZyYW1lLnNvdXJjZVJlY3Q7XG5cdFx0dmFyIGNhbnZhcyA9IHRoaXMuX2RhdGEuaW1hZ2VzW2ZyYW1lLmltZ107XG5cdFx0dmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0ZnJhbWUuZnVuY3QmJmZyYW1lLmZ1bmN0KGZyYW1lLnNvdXJjZSwgZnJhbWUuZGF0YSk7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LnJlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcblx0XHRjdHguY2xpcCgpO1xuXHRcdGN0eC50cmFuc2xhdGUoTWF0aC5jZWlsKHJlY3QueC1zb3VyY2VSZWN0Lngqc2MpLCBNYXRoLmNlaWwocmVjdC55LXNvdXJjZVJlY3QueSpzYykpO1xuXHRcdGN0eC5zY2FsZShzYyxzYyk7XG5cdFx0ZnJhbWUuc291cmNlLmRyYXcoY3R4KTsgLy8gZGlzcGxheSBvYmplY3Qgd2lsbCBkcmF3IGl0c2VsZi5cblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdHJldHVybiAoKyt0aGlzLl9pbmRleCkgPCB0aGlzLl9mcmFtZXMubGVuZ3RoO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuU3ByaXRlU2hlZXRCdWlsZGVyID0gY3JlYXRlanMucHJvbW90ZShTcHJpdGVTaGVldEJ1aWxkZXIsIFwiRXZlbnREaXNwYXRjaGVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIERPTUVsZW1lbnQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIDxiPlRoaXMgY2xhc3MgaXMgc3RpbGwgZXhwZXJpbWVudGFsLCBhbmQgbW9yZSBhZHZhbmNlZCB1c2UgaXMgbGlrZWx5IHRvIGJlIGJ1Z2d5LiBQbGVhc2UgcmVwb3J0IGJ1Z3MuPC9iPlxuXHQgKlxuXHQgKiBBIERPTUVsZW1lbnQgYWxsb3dzIHlvdSB0byBhc3NvY2lhdGUgYSBIVE1MRWxlbWVudCB3aXRoIHRoZSBkaXNwbGF5IGxpc3QuIEl0IHdpbGwgYmUgdHJhbnNmb3JtZWRcblx0ICogd2l0aGluIHRoZSBET00gYXMgdGhvdWdoIGl0IGlzIGNoaWxkIG9mIHRoZSB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX0gaXQgaXMgYWRkZWQgdG8uIEhvd2V2ZXIsIGl0IGlzXG5cdCAqIG5vdCByZW5kZXJlZCB0byBjYW52YXMsIGFuZCBhcyBzdWNoIHdpbGwgcmV0YWluIHdoYXRldmVyIHotaW5kZXggaXQgaGFzIHJlbGF0aXZlIHRvIHRoZSBjYW52YXMgKGllLiBpdCB3aWxsIGJlXG5cdCAqIGRyYXduIGluIGZyb250IG9mIG9yIGJlaGluZCB0aGUgY2FudmFzKS5cblx0ICpcblx0ICogVGhlIHBvc2l0aW9uIG9mIGEgRE9NRWxlbWVudCBpcyByZWxhdGl2ZSB0byB0aGVpciBwYXJlbnQgbm9kZSBpbiB0aGUgRE9NLiBJdCBpcyByZWNvbW1lbmRlZCB0aGF0XG5cdCAqIHRoZSBET00gT2JqZWN0IGJlIGFkZGVkIHRvIGEgZGl2IHRoYXQgYWxzbyBjb250YWlucyB0aGUgY2FudmFzIHNvIHRoYXQgdGhleSBzaGFyZSB0aGUgc2FtZSBwb3NpdGlvblxuXHQgKiBvbiB0aGUgcGFnZS5cblx0ICpcblx0ICogRE9NRWxlbWVudCBpcyB1c2VmdWwgZm9yIHBvc2l0aW9uaW5nIEhUTUwgZWxlbWVudHMgb3ZlciB0b3Agb2YgY2FudmFzIGNvbnRlbnQsIGFuZCBmb3IgZWxlbWVudHNcblx0ICogdGhhdCB5b3Ugd2FudCB0byBkaXNwbGF5IG91dHNpZGUgdGhlIGJvdW5kcyBvZiB0aGUgY2FudmFzLiBGb3IgZXhhbXBsZSwgYSB0b29sdGlwIHdpdGggcmljaCBIVE1MXG5cdCAqIGNvbnRlbnQuXG5cdCAqXG5cdCAqIDxoND5Nb3VzZSBJbnRlcmFjdGlvbjwvaDQ+XG5cdCAqXG5cdCAqIERPTUVsZW1lbnQgaW5zdGFuY2VzIGFyZSBub3QgZnVsbCBFYXNlbEpTIGRpc3BsYXkgb2JqZWN0cywgYW5kIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBFYXNlbEpTIG1vdXNlXG5cdCAqIGV2ZW50cyBvciBzdXBwb3J0IG1ldGhvZHMgbGlrZSBoaXRUZXN0LiBUbyBnZXQgbW91c2UgZXZlbnRzIGZyb20gYSBET01FbGVtZW50LCB5b3UgbXVzdCBpbnN0ZWFkIGFkZCBoYW5kbGVycyB0b1xuXHQgKiB0aGUgaHRtbEVsZW1lbnQgKG5vdGUsIHRoaXMgZG9lcyBub3Qgc3VwcG9ydCBFdmVudERpc3BhdGNoZXIpXG5cdCAqXG5cdCAqICAgICAgdmFyIGRvbUVsZW1lbnQgPSBuZXcgY3JlYXRlanMuRE9NRWxlbWVudChodG1sRWxlbWVudCk7XG5cdCAqICAgICAgZG9tRWxlbWVudC5odG1sRWxlbWVudC5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2xpY2tlZFwiKTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBjbGFzcyBET01FbGVtZW50XG5cdCAqIEBleHRlbmRzIERpc3BsYXlPYmplY3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGh0bWxFbGVtZW50IEEgcmVmZXJlbmNlIG9yIGlkIGZvciB0aGUgRE9NIGVsZW1lbnQgdG8gbWFuYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gRE9NRWxlbWVudChodG1sRWxlbWVudCkge1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9jb25zdHJ1Y3RvcigpO1xuXHRcdFxuXHRcdGlmICh0eXBlb2YoaHRtbEVsZW1lbnQpPT1cInN0cmluZ1wiKSB7IGh0bWxFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaHRtbEVsZW1lbnQpOyB9XG5cdFx0dGhpcy5tb3VzZUVuYWJsZWQgPSBmYWxzZTtcblx0XHRcblx0XHR2YXIgc3R5bGUgPSBodG1sRWxlbWVudC5zdHlsZTtcblx0XHRzdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBzdHlsZS5XZWJraXRUcmFuc2Zvcm1PcmlnaW4gPSBzdHlsZS5tc1RyYW5zZm9ybU9yaWdpbiA9IHN0eWxlLk1velRyYW5zZm9ybU9yaWdpbiA9IHN0eWxlLk9UcmFuc2Zvcm1PcmlnaW4gPSBcIjAlIDAlXCI7XG5cdFx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSBET00gb2JqZWN0IHRvIG1hbmFnZS5cblx0XHQgKiBAcHJvcGVydHkgaHRtbEVsZW1lbnRcblx0XHQgKiBAdHlwZSBIVE1MRWxlbWVudFxuXHRcdCAqL1xuXHRcdHRoaXMuaHRtbEVsZW1lbnQgPSBodG1sRWxlbWVudDtcblx0XG5cdFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9vbGRNdHhcblx0XHQgKiBAdHlwZSBNYXRyaXgyRFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9vbGRQcm9wcyA9IG51bGw7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoRE9NRWxlbWVudCwgY3JlYXRlanMuRGlzcGxheU9iamVjdCk7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzXG5cdCAqL1xuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmh0bWxFbGVtZW50ICE9IG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBkcmF3IHdhcyBoYW5kbGVkICh1c2VmdWwgZm9yIG92ZXJyaWRpbmcgZnVuY3Rpb25hbGl0eSkuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBkcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlQ2FjaGUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRyYXcgb3BlcmF0aW9uIHNob3VsZCBpZ25vcmUgYW55IGN1cnJlbnQgY2FjaGUuXG5cdCAqIEZvciBleGFtcGxlLCB1c2VkIGZvciBkcmF3aW5nIHRoZSBjYWNoZSAodG8gcHJldmVudCBpdCBmcm9tIHNpbXBseSBkcmF3aW5nIGFuIGV4aXN0aW5nIGNhY2hlIGJhY2tcblx0ICogaW50byBpdHNlbGYpLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBpZ25vcmVDYWNoZSkge1xuXHRcdC8vIHRoaXMgcmVsaWVzIG9uIHRoZSBfdGljayBtZXRob2QgYmVjYXVzZSBkcmF3IGlzbid0IGNhbGxlZCBpZiB0aGUgcGFyZW50IGlzIG5vdCB2aXNpYmxlLlxuXHRcdC8vIHRoZSBhY3R1YWwgdXBkYXRlIGhhcHBlbnMgaW4gX2hhbmRsZURyYXdFbmRcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogTm90IGFwcGxpY2FibGUgdG8gRE9NRWxlbWVudC5cblx0ICogQG1ldGhvZCBjYWNoZVxuXHQgKi9cblx0cC5jYWNoZSA9IGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIE5vdCBhcHBsaWNhYmxlIHRvIERPTUVsZW1lbnQuXG5cdCAqIEBtZXRob2QgdW5jYWNoZVxuXHQgKi9cblx0cC51bmNhY2hlID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKipcblx0ICogTm90IGFwcGxpY2FibGUgdG8gRE9NRWxlbWVudC5cblx0ICogQG1ldGhvZCB1cGRhdGVDYWNoZVxuXHQgKi9cblx0cC51cGRhdGVDYWNoZSA9IGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIE5vdCBhcHBsaWNhYmxlIHRvIERPTUVsZW1lbnQuXG5cdCAqIEBtZXRob2QgaGl0VGVzdFxuXHQgKi9cblx0cC5oaXRUZXN0ID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKipcblx0ICogTm90IGFwcGxpY2FibGUgdG8gRE9NRWxlbWVudC5cblx0ICogQG1ldGhvZCBsb2NhbFRvR2xvYmFsXG5cdCAqL1xuXHRwLmxvY2FsVG9HbG9iYWwgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBOb3QgYXBwbGljYWJsZSB0byBET01FbGVtZW50LlxuXHQgKiBAbWV0aG9kIGdsb2JhbFRvTG9jYWxcblx0ICovXG5cdHAuZ2xvYmFsVG9Mb2NhbCA9IGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIE5vdCBhcHBsaWNhYmxlIHRvIERPTUVsZW1lbnQuXG5cdCAqIEBtZXRob2QgbG9jYWxUb0xvY2FsXG5cdCAqL1xuXHRwLmxvY2FsVG9Mb2NhbCA9IGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIERPTUVsZW1lbnQgY2Fubm90IGJlIGNsb25lZC4gVGhyb3dzIGFuIGVycm9yLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3coXCJET01FbGVtZW50IGNhbm5vdCBiZSBjbG9uZWQuXCIpXG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0RPTUVsZW1lbnQgKG5hbWU9XCIrICB0aGlzLm5hbWUgK1wiKV1cIjtcblx0fTtcblxuXHQvKipcbiAgICAgKiBJbnRlcmFjdGlvbiBldmVudHMgc2hvdWxkIGJlIGFkZGVkIHRvIGBodG1sRWxlbWVudGAsIGFuZCBub3QgdGhlIERPTUVsZW1lbnQgaW5zdGFuY2UsIHNpbmNlIERPTUVsZW1lbnQgaW5zdGFuY2VzXG5cdCAqIGFyZSBub3QgZnVsbCBFYXNlbEpTIGRpc3BsYXkgb2JqZWN0cyBhbmQgZG8gbm90IHBhcnRpY2lwYXRlIGluIEVhc2VsSlMgbW91c2UgZXZlbnRzLlxuXHQgKiBAZXZlbnQgY2xpY2tcblx0ICovXG5cbiAgICAgLyoqXG4gICAgICogSW50ZXJhY3Rpb24gZXZlbnRzIHNob3VsZCBiZSBhZGRlZCB0byBgaHRtbEVsZW1lbnRgLCBhbmQgbm90IHRoZSBET01FbGVtZW50IGluc3RhbmNlLCBzaW5jZSBET01FbGVtZW50IGluc3RhbmNlc1xuIFx0ICogYXJlIG5vdCBmdWxsIEVhc2VsSlMgZGlzcGxheSBvYmplY3RzIGFuZCBkbyBub3QgcGFydGljaXBhdGUgaW4gRWFzZWxKUyBtb3VzZSBldmVudHMuXG5cdCAqIEBldmVudCBkYmxDbGlja1xuXHQgKi9cblxuICAgICAvKipcbiAgICAgICogSW50ZXJhY3Rpb24gZXZlbnRzIHNob3VsZCBiZSBhZGRlZCB0byBgaHRtbEVsZW1lbnRgLCBhbmQgbm90IHRoZSBET01FbGVtZW50IGluc3RhbmNlLCBzaW5jZSBET01FbGVtZW50IGluc3RhbmNlc1xuIFx0ICAqIGFyZSBub3QgZnVsbCBFYXNlbEpTIGRpc3BsYXkgb2JqZWN0cyBhbmQgZG8gbm90IHBhcnRpY2lwYXRlIGluIEVhc2VsSlMgbW91c2UgZXZlbnRzLlxuXHQgICogQGV2ZW50IG1vdXNlZG93blxuXHQgICovXG5cbiAgICAgLyoqXG4gICAgICAqIFRoZSBIVE1MRWxlbWVudCBjYW4gbGlzdGVuIGZvciB0aGUgbW91c2VvdmVyIGV2ZW50LCBub3QgdGhlIERPTUVsZW1lbnQgaW5zdGFuY2UuXG4gICAgICAqIFNpbmNlIERPTUVsZW1lbnQgaW5zdGFuY2VzIGFyZSBub3QgZnVsbCBFYXNlbEpTIGRpc3BsYXkgb2JqZWN0cyBhbmQgZG8gbm90IHBhcnRpY2lwYXRlIGluIEVhc2VsSlMgbW91c2UgZXZlbnRzLlxuICAgICAgKiBAZXZlbnQgbW91c2VvdmVyXG5cdCAgKi9cblxuICAgICAvKipcbiAgICAgICogTm90IGFwcGxpY2FibGUgdG8gRE9NRWxlbWVudC5cblx0ICAqIEBldmVudCB0aWNrXG5cdCAgKi9cblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF90aWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldnRPYmogQW4gZXZlbnQgb2JqZWN0IHRoYXQgd2lsbCBiZSBkaXNwYXRjaGVkIHRvIGFsbCB0aWNrIGxpc3RlbmVycy4gVGhpcyBvYmplY3QgaXMgcmV1c2VkIGJldHdlZW4gZGlzcGF0Y2hlcnMgdG8gcmVkdWNlIGNvbnN0cnVjdGlvbiAmIEdDIGNvc3RzLlxuXHQgKiBmdW5jdGlvbi5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fdGljayA9IGZ1bmN0aW9uKGV2dE9iaikge1xuXHRcdHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcblx0XHRzdGFnZSYmc3RhZ2Uub24oXCJkcmF3ZW5kXCIsIHRoaXMuX2hhbmRsZURyYXdFbmQsIHRoaXMsIHRydWUpO1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9fdGljayhldnRPYmopO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZURyYXdFbmRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZ0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2hhbmRsZURyYXdFbmQgPSBmdW5jdGlvbihldnQpIHtcblx0XHR2YXIgbyA9IHRoaXMuaHRtbEVsZW1lbnQ7XG5cdFx0aWYgKCFvKSB7IHJldHVybjsgfVxuXHRcdHZhciBzdHlsZSA9IG8uc3R5bGU7XG5cdFx0XG5cdFx0dmFyIHByb3BzID0gdGhpcy5nZXRDb25jYXRlbmF0ZWREaXNwbGF5UHJvcHModGhpcy5fcHJvcHMpLCBtdHggPSBwcm9wcy5tYXRyaXg7XG5cdFx0XG5cdFx0dmFyIHZpc2liaWxpdHkgPSBwcm9wcy52aXNpYmxlID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiO1xuXHRcdGlmICh2aXNpYmlsaXR5ICE9IHN0eWxlLnZpc2liaWxpdHkpIHsgc3R5bGUudmlzaWJpbGl0eSA9IHZpc2liaWxpdHk7IH1cblx0XHRpZiAoIXByb3BzLnZpc2libGUpIHsgcmV0dXJuOyB9XG5cdFx0XG5cdFx0dmFyIG9sZFByb3BzID0gdGhpcy5fb2xkUHJvcHMsIG9sZE10eCA9IG9sZFByb3BzJiZvbGRQcm9wcy5tYXRyaXg7XG5cdFx0dmFyIG4gPSAxMDAwMDsgLy8gcHJlY2lzaW9uXG5cdFx0XG5cdFx0aWYgKCFvbGRNdHggfHwgIW9sZE10eC5lcXVhbHMobXR4KSkge1xuXHRcdFx0dmFyIHN0ciA9IFwibWF0cml4KFwiICsgKG10eC5hKm58MCkvbiArXCIsXCIrIChtdHguYipufDApL24gK1wiLFwiKyAobXR4LmMqbnwwKS9uICtcIixcIisgKG10eC5kKm58MCkvbiArXCIsXCIrIChtdHgudHgrMC41fDApO1xuXHRcdFx0c3R5bGUudHJhbnNmb3JtID0gc3R5bGUuV2Via2l0VHJhbnNmb3JtID0gc3R5bGUuT1RyYW5zZm9ybSA9IHN0eWxlLm1zVHJhbnNmb3JtID0gc3RyICtcIixcIisgKG10eC50eSswLjV8MCkgK1wiKVwiO1xuXHRcdFx0c3R5bGUuTW96VHJhbnNmb3JtID0gc3RyICtcInB4LFwiKyAobXR4LnR5KzAuNXwwKSArXCJweClcIjtcblx0XHRcdGlmICghb2xkUHJvcHMpIHsgb2xkUHJvcHMgPSB0aGlzLl9vbGRQcm9wcyA9IG5ldyBjcmVhdGVqcy5EaXNwbGF5UHJvcHModHJ1ZSwgTmFOKTsgfVxuXHRcdFx0b2xkUHJvcHMubWF0cml4LmNvcHkobXR4KTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKG9sZFByb3BzLmFscGhhICE9IHByb3BzLmFscGhhKSB7XG5cdFx0XHRzdHlsZS5vcGFjaXR5ID0gXCJcIisocHJvcHMuYWxwaGEqbnwwKS9uO1xuXHRcdFx0b2xkUHJvcHMuYWxwaGEgPSBwcm9wcy5hbHBoYTtcblx0XHR9XG5cdH07XG5cblxuXHRjcmVhdGVqcy5ET01FbGVtZW50ID0gY3JlYXRlanMucHJvbW90ZShET01FbGVtZW50LCBcIkRpc3BsYXlPYmplY3RcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRmlsdGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBCYXNlIGNsYXNzIHRoYXQgYWxsIGZpbHRlcnMgc2hvdWxkIGluaGVyaXQgZnJvbS4gRmlsdGVycyBuZWVkIHRvIGJlIGFwcGxpZWQgdG8gb2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBjYWNoZWQgdXNpbmdcblx0ICogdGhlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvY2FjaGVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLiBJZiBhbiBvYmplY3QgY2hhbmdlcywgcGxlYXNlIGNhY2hlIGl0IGFnYWluLCBvciB1c2Vcblx0ICoge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC91cGRhdGVDYWNoZVwifX17ey9jcm9zc0xpbmt9fS4gTm90ZSB0aGF0IHRoZSBmaWx0ZXJzIG11c3QgYmUgYXBwbGllZCBiZWZvcmUgY2FjaGluZy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIG15SW5zdGFuY2UuZmlsdGVycyA9IFtcblx0ICogICAgICAgICAgbmV3IGNyZWF0ZWpzLkNvbG9yRmlsdGVyKDAsIDAsIDAsIDEsIDI1NSwgMCwgMCksXG5cdCAqICAgICAgICAgIG5ldyBjcmVhdGVqcy5CbHVyRmlsdGVyKDUsIDUsIDEwKVxuXHQgKiAgICAgIF07XG5cdCAqICAgICAgbXlJbnN0YW5jZS5jYWNoZSgwLDAsIDEwMCwgMTAwKTtcblx0ICpcblx0ICogTm90ZSB0aGF0IGVhY2ggZmlsdGVyIGNhbiBpbXBsZW1lbnQgYSB7eyNjcm9zc0xpbmsgXCJGaWx0ZXIvZ2V0Qm91bmRzXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCwgd2hpY2ggcmV0dXJucyB0aGVcblx0ICogbWFyZ2lucyB0aGF0IG5lZWQgdG8gYmUgYXBwbGllZCBpbiBvcmRlciB0byBmdWxseSBkaXNwbGF5IHRoZSBmaWx0ZXIuIEZvciBleGFtcGxlLCB0aGUge3sjY3Jvc3NMaW5rIFwiQmx1ckZpbHRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aWxsIGNhdXNlIGFuIG9iamVjdCB0byBmZWF0aGVyIG91dHdhcmRzLCByZXN1bHRpbmcgaW4gYSBtYXJnaW4gYXJvdW5kIHRoZSBzaGFwZS5cblx0ICpcblx0ICogPGg0PkVhc2VsSlMgRmlsdGVyczwvaDQ+XG5cdCAqIEVhc2VsSlMgY29tZXMgd2l0aCBhIG51bWJlciBvZiBwcmUtYnVpbHQgZmlsdGVycy4gTm90ZSB0aGF0IGluZGl2aWR1YWwgZmlsdGVycyBhcmUgbm90IGNvbXBpbGVkIGludG8gdGhlIG1pbmlmaWVkXG5cdCAqIHZlcnNpb24gb2YgRWFzZWxKUy4gVG8gdXNlIHRoZW0sIHlvdSBtdXN0IGluY2x1ZGUgdGhlbSBtYW51YWxseSBpbiB0aGUgSFRNTC5cblx0ICogPHVsPjxsaT57eyNjcm9zc0xpbmsgXCJBbHBoYU1hcEZpbHRlclwifX17ey9jcm9zc0xpbmt9fSA6IE1hcCBhIGdyZXlzY2FsZSBpbWFnZSB0byB0aGUgYWxwaGEgY2hhbm5lbCBvZiBhIGRpc3BsYXkgb2JqZWN0PC9saT5cblx0ICogICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWxwaGFNYXNrRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319OiBNYXAgYW4gaW1hZ2UncyBhbHBoYSBjaGFubmVsIHRvIHRoZSBhbHBoYSBjaGFubmVsIG9mIGEgZGlzcGxheSBvYmplY3Q8L2xpPlxuXHQgKiAgICAgIDxsaT57eyNjcm9zc0xpbmsgXCJCbHVyRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319OiBBcHBseSB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBibHVyIHRvIGEgZGlzcGxheSBvYmplY3Q8L2xpPlxuXHQgKiAgICAgIDxsaT57eyNjcm9zc0xpbmsgXCJDb2xvckZpbHRlclwifX17ey9jcm9zc0xpbmt9fTogQ29sb3IgdHJhbnNmb3JtIGEgZGlzcGxheSBvYmplY3Q8L2xpPlxuXHQgKiAgICAgIDxsaT57eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeEZpbHRlclwifX17ey9jcm9zc0xpbmt9fTogVHJhbnNmb3JtIGFuIGltYWdlIHVzaW5nIGEge3sjY3Jvc3NMaW5rIFwiQ29sb3JNYXRyaXhcIn19e3svY3Jvc3NMaW5rfX08L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiBAY2xhc3MgRmlsdGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIEZpbHRlcigpIHt9XG5cdHZhciBwID0gRmlsdGVyLnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBQcm92aWRlcyBwYWRkaW5nIHZhbHVlcyBmb3IgdGhpcyBmaWx0ZXIuIFRoYXQgaXMsIGhvdyBtdWNoIHRoZSBmaWx0ZXIgd2lsbCBleHRlbmQgdGhlIHZpc3VhbCBib3VuZHMgb2YgYW4gb2JqZWN0IGl0IGlzIGFwcGxpZWQgdG8uXG5cdCAqIEBtZXRob2QgZ2V0Qm91bmRzXG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBbcmVjdF0gSWYgc3BlY2lmaWVkLCB0aGUgcHJvdmlkZWQgUmVjdGFuZ2xlIGluc3RhbmNlIHdpbGwgYmUgZXhwYW5kZWQgYnkgdGhlIHBhZGRpbmcgYW1vdW50cyBhbmQgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gSWYgYSBgcmVjdGAgcGFyYW0gd2FzIHByb3ZpZGVkLCBpdCBpcyByZXR1cm5lZC4gSWYgbm90LCBlaXRoZXIgYSBuZXcgcmVjdGFuZ2xlIHdpdGggdGhlIHBhZGRpbmcgdmFsdWVzLCBvciBudWxsIGlmIG5vIHBhZGRpbmcgaXMgcmVxdWlyZWQgZm9yIHRoaXMgZmlsdGVyLlxuXHQgKiovXG5cdHAuZ2V0Qm91bmRzID0gZnVuY3Rpb24ocmVjdCkge1xuXHRcdHJldHVybiByZWN0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIHRoZSBmaWx0ZXIgdG8gdGhlIHNwZWNpZmllZCBjb250ZXh0LlxuXHQgKiBAbWV0aG9kIGFwcGx5RmlsdGVyXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIDJEIGNvbnRleHQgdG8gdXNlIGFzIHRoZSBzb3VyY2UuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiB0byB1c2UgZm9yIHRoZSBzb3VyY2UgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCB0byB1c2UgZm9yIHRoZSBzb3VyY2UgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gW3RhcmdldEN0eF0gVGhlIDJEIGNvbnRleHQgdG8gZHJhdyB0aGUgcmVzdWx0IHRvLiBEZWZhdWx0cyB0byB0aGUgY29udGV4dCBwYXNzZWQgdG8gY3R4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RhcmdldFhdIFRoZSB4IHBvc2l0aW9uIHRvIGRyYXcgdGhlIHJlc3VsdCB0by4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIHBhc3NlZCB0byB4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RhcmdldFldIFRoZSB5IHBvc2l0aW9uIHRvIGRyYXcgdGhlIHJlc3VsdCB0by4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIHBhc3NlZCB0byB5LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgZmlsdGVyIHdhcyBhcHBsaWVkIHN1Y2Nlc3NmdWxseS5cblx0ICoqL1xuXHRwLmFwcGx5RmlsdGVyID0gZnVuY3Rpb24oY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0YXJnZXRDdHgsIHRhcmdldFgsIHRhcmdldFkpIHtcblx0XHQvLyB0aGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBiZWNhdXNlIG1vc3QgZmlsdGVycyBhY2Nlc3MgcGl4ZWwgZGF0YS4gSXQgaXMgb3ZlcnJpZGRlbiB3aGVuIG5vdCBuZWVkZWQuXG5cdFx0dGFyZ2V0Q3R4ID0gdGFyZ2V0Q3R4IHx8IGN0eDtcblx0XHRpZiAodGFyZ2V0WCA9PSBudWxsKSB7IHRhcmdldFggPSB4OyB9XG5cdFx0aWYgKHRhcmdldFkgPT0gbnVsbCkgeyB0YXJnZXRZID0geTsgfVxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9hcHBseUZpbHRlcihpbWFnZURhdGEpKSB7XG5cdFx0XHR0YXJnZXRDdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgdGFyZ2V0WCwgdGFyZ2V0WSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbRmlsdGVyXVwiO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBGaWx0ZXIgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7RmlsdGVyfSBBIGNsb25lIG9mIHRoZSBjdXJyZW50IEZpbHRlciBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBGaWx0ZXIoKTtcblx0fTtcblx0XG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9hcHBseUZpbHRlclxuXHQgKiBAcGFyYW0ge0ltYWdlRGF0YX0gaW1hZ2VEYXRhIFRhcmdldCBJbWFnZURhdGEgaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqKi9cblx0cC5fYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbihpbWFnZURhdGEpIHsgcmV0dXJuIHRydWU7IH07XG5cblxuXHRjcmVhdGVqcy5GaWx0ZXIgPSBGaWx0ZXI7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQmx1ckZpbHRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQXBwbGllcyBhIGJveCBibHVyIHRvIERpc3BsYXlPYmplY3RzLiBOb3RlIHRoYXQgdGhpcyBmaWx0ZXIgaXMgZmFpcmx5IENQVSBpbnRlbnNpdmUsIHBhcnRpY3VsYXJseSBpZiB0aGUgcXVhbGl0eSBpc1xuXHQgKiBzZXQgaGlnaGVyIHRoYW4gMS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBUaGlzIGV4YW1wbGUgY3JlYXRlcyBhIHJlZCBjaXJjbGUsIGFuZCB0aGVuIGFwcGxpZXMgYSA1IHBpeGVsIGJsdXIgdG8gaXQuIEl0IHVzZXMgdGhlIHt7I2Nyb3NzTGluayBcIkZpbHRlci9nZXRCb3VuZHNcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kIHRvIGFjY291bnQgZm9yIHRoZSBzcHJlYWQgdGhhdCB0aGUgYmx1ciBjYXVzZXMuXG5cdCAqXG5cdCAqICAgICAgdmFyIHNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCkuc2V0KHt4OjEwMCx5OjEwMH0pO1xuXHQgKiAgICAgIHNoYXBlLmdyYXBoaWNzLmJlZ2luRmlsbChcIiNmZjAwMDBcIikuZHJhd0NpcmNsZSgwLDAsNTApO1xuXHQgKlxuXHQgKiAgICAgIHZhciBibHVyRmlsdGVyID0gbmV3IGNyZWF0ZWpzLkJsdXJGaWx0ZXIoNSwgNSwgMSk7XG5cdCAqICAgICAgc2hhcGUuZmlsdGVycyA9IFtibHVyRmlsdGVyXTtcblx0ICogICAgICB2YXIgYm91bmRzID0gYmx1ckZpbHRlci5nZXRCb3VuZHMoKTtcblx0ICpcblx0ICogICAgICBzaGFwZS5jYWNoZSgtNTArYm91bmRzLngsIC01MCtib3VuZHMueSwgMTAwK2JvdW5kcy53aWR0aCwgMTAwK2JvdW5kcy5oZWlnaHQpO1xuXHQgKlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhbiBtb3JlIGluZm9ybWF0aW9uIG9uIGFwcGx5aW5nIGZpbHRlcnMuXG5cdCAqIEBjbGFzcyBCbHVyRmlsdGVyXG5cdCAqIEBleHRlbmRzIEZpbHRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtibHVyWD0wXSBUaGUgaG9yaXpvbnRhbCBibHVyIHJhZGl1cyBpbiBwaXhlbHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYmx1clk9MF0gVGhlIHZlcnRpY2FsIGJsdXIgcmFkaXVzIGluIHBpeGVscy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtxdWFsaXR5PTFdIFRoZSBudW1iZXIgb2YgYmx1ciBpdGVyYXRpb25zLlxuXHQgKiovXG5cdGZ1bmN0aW9uIEJsdXJGaWx0ZXIoIGJsdXJYLCBibHVyWSwgcXVhbGl0eSkge1xuXHRcdGlmICggaXNOYU4oYmx1clgpIHx8IGJsdXJYIDwgMCApIGJsdXJYID0gMDtcblx0XHRpZiAoIGlzTmFOKGJsdXJZKSB8fCBibHVyWSA8IDAgKSBibHVyWSA9IDA7XG5cdFx0aWYgKCBpc05hTihxdWFsaXR5KSB8fCBxdWFsaXR5IDwgMSAgKSBxdWFsaXR5ID0gMTtcblxuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogSG9yaXpvbnRhbCBibHVyIHJhZGl1cyBpbiBwaXhlbHNcblx0XHQgKiBAcHJvcGVydHkgYmx1clhcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuYmx1clggPSBibHVyWCB8IDA7XG5cblx0XHQvKipcblx0XHQgKiBWZXJ0aWNhbCBibHVyIHJhZGl1cyBpbiBwaXhlbHNcblx0XHQgKiBAcHJvcGVydHkgYmx1cllcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuYmx1clkgPSBibHVyWSB8IDA7XG5cblx0XHQvKipcblx0XHQgKiBOdW1iZXIgb2YgYmx1ciBpdGVyYXRpb25zLiBGb3IgZXhhbXBsZSwgYSB2YWx1ZSBvZiAxIHdpbGwgcHJvZHVjZSBhIHJvdWdoIGJsdXIuIEEgdmFsdWUgb2YgMiB3aWxsIHByb2R1Y2UgYVxuXHRcdCAqIHNtb290aGVyIGJsdXIsIGJ1dCB0YWtlIHR3aWNlIGFzIGxvbmcgdG8gcnVuLlxuXHRcdCAqIEBwcm9wZXJ0eSBxdWFsaXR5XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLnF1YWxpdHkgPSBxdWFsaXR5IHwgMDtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChCbHVyRmlsdGVyLCBjcmVhdGVqcy5GaWx0ZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cbi8vIGNvbnN0YW50czpcblx0LyoqXG5cdCAqIEFycmF5IG9mIG11bHRpcGx5IHZhbHVlcyBmb3IgYmx1ciBjYWxjdWxhdGlvbnMuXG5cdCAqIEBwcm9wZXJ0eSBNVUxfVEFCTEVcblx0ICogQHR5cGUgQXJyYXlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0Qmx1ckZpbHRlci5NVUxfVEFCTEUgPSBbMSwgMTcxLCAyMDUsIDI5MywgNTcsIDM3MywgNzksIDEzNywgMjQxLCAyNywgMzkxLCAzNTcsIDQxLCAxOSwgMjgzLCAyNjUsIDQ5NywgNDY5LCA0NDMsIDQyMSwgMjUsIDE5MSwgMzY1LCAzNDksIDMzNSwgMTYxLCAxNTUsIDE0OSwgOSwgMjc4LCAyNjksIDI2MSwgNTA1LCAyNDUsIDQ3NSwgMjMxLCA0NDksIDQzNywgMjEzLCA0MTUsIDQwNSwgMzk1LCAxOTMsIDM3NywgMzY5LCAzNjEsIDM1MywgMzQ1LCAxNjksIDMzMSwgMzI1LCAzMTksIDMxMywgMzA3LCAzMDEsIDM3LCAxNDUsIDI4NSwgMjgxLCA2OSwgMjcxLCAyNjcsIDI2MywgMjU5LCA1MDksIDUwMSwgNDkzLCAyNDMsIDQ3OSwgMTE4LCA0NjUsIDQ1OSwgMTEzLCA0NDYsIDU1LCA0MzUsIDQyOSwgNDIzLCAyMDksIDQxMywgNTEsIDQwMywgMTk5LCAzOTMsIDk3LCAzLCAzNzksIDM3NSwgMzcxLCAzNjcsIDM2MywgMzU5LCAzNTUsIDM1MSwgMzQ3LCA0MywgODUsIDMzNywgMzMzLCAxNjUsIDMyNywgMzIzLCA1LCAzMTcsIDE1NywgMzExLCA3NywgMzA1LCAzMDMsIDc1LCAyOTcsIDI5NCwgNzMsIDI4OSwgMjg3LCA3MSwgMTQxLCAyNzksIDI3NywgMjc1LCA2OCwgMTM1LCA2NywgMTMzLCAzMywgMjYyLCAyNjAsIDEyOSwgNTExLCA1MDcsIDUwMywgNDk5LCA0OTUsIDQ5MSwgNjEsIDEyMSwgNDgxLCA0NzcsIDIzNywgMjM1LCA0NjcsIDIzMiwgMTE1LCA0NTcsIDIyNywgNDUxLCA3LCA0NDUsIDIyMSwgNDM5LCAyMTgsIDQzMywgMjE1LCA0MjcsIDQyNSwgMjExLCA0MTksIDQxNywgMjA3LCA0MTEsIDQwOSwgMjAzLCAyMDIsIDQwMSwgMzk5LCAzOTYsIDE5NywgNDksIDM4OSwgMzg3LCAzODUsIDM4MywgOTUsIDE4OSwgNDcsIDE4NywgOTMsIDE4NSwgMjMsIDE4MywgOTEsIDE4MSwgNDUsIDE3OSwgODksIDE3NywgMTEsIDE3NSwgODcsIDE3MywgMzQ1LCAzNDMsIDM0MSwgMzM5LCAzMzcsIDIxLCAxNjcsIDgzLCAzMzEsIDMyOSwgMzI3LCAxNjMsIDgxLCAzMjMsIDMyMSwgMzE5LCAxNTksIDc5LCAzMTUsIDMxMywgMzksIDE1NSwgMzA5LCAzMDcsIDE1MywgMzA1LCAzMDMsIDE1MSwgNzUsIDI5OSwgMTQ5LCAzNywgMjk1LCAxNDcsIDczLCAyOTEsIDE0NSwgMjg5LCAyODcsIDE0MywgMjg1LCA3MSwgMTQxLCAyODEsIDM1LCAyNzksIDEzOSwgNjksIDI3NSwgMTM3LCAyNzMsIDE3LCAyNzEsIDEzNSwgMjY5LCAyNjcsIDEzMywgMjY1LCAzMywgMjYzLCAxMzEsIDI2MSwgMTMwLCAyNTksIDEyOSwgMjU3LCAxXTtcblxuXHQvKipcblx0ICogQXJyYXkgb2Ygc2hpZnQgdmFsdWVzIGZvciBibHVyIGNhbGN1bGF0aW9ucy5cblx0ICogQHByb3BlcnR5IFNIR19UQUJMRVxuXHQgKiBAdHlwZSBBcnJheVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRCbHVyRmlsdGVyLlNIR19UQUJMRSA9IFswLCA5LCAxMCwgMTEsIDksIDEyLCAxMCwgMTEsIDEyLCA5LCAxMywgMTMsIDEwLCA5LCAxMywgMTMsIDE0LCAxNCwgMTQsIDE0LCAxMCwgMTMsIDE0LCAxNCwgMTQsIDEzLCAxMywgMTMsIDksIDE0LCAxNCwgMTQsIDE1LCAxNCwgMTUsIDE0LCAxNSwgMTUsIDE0LCAxNSwgMTUsIDE1LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxNSwgMTIsIDE0LCAxNSwgMTUsIDEzLCAxNSwgMTUsIDE1LCAxNSwgMTYsIDE2LCAxNiwgMTUsIDE2LCAxNCwgMTYsIDE2LCAxNCwgMTYsIDEzLCAxNiwgMTYsIDE2LCAxNSwgMTYsIDEzLCAxNiwgMTUsIDE2LCAxNCwgOSwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTMsIDE0LCAxNiwgMTYsIDE1LCAxNiwgMTYsIDEwLCAxNiwgMTUsIDE2LCAxNCwgMTYsIDE2LCAxNCwgMTYsIDE2LCAxNCwgMTYsIDE2LCAxNCwgMTUsIDE2LCAxNiwgMTYsIDE0LCAxNSwgMTQsIDE1LCAxMywgMTYsIDE2LCAxNSwgMTcsIDE3LCAxNywgMTcsIDE3LCAxNywgMTQsIDE1LCAxNywgMTcsIDE2LCAxNiwgMTcsIDE2LCAxNSwgMTcsIDE2LCAxNywgMTEsIDE3LCAxNiwgMTcsIDE2LCAxNywgMTYsIDE3LCAxNywgMTYsIDE3LCAxNywgMTYsIDE3LCAxNywgMTYsIDE2LCAxNywgMTcsIDE3LCAxNiwgMTQsIDE3LCAxNywgMTcsIDE3LCAxNSwgMTYsIDE0LCAxNiwgMTUsIDE2LCAxMywgMTYsIDE1LCAxNiwgMTQsIDE2LCAxNSwgMTYsIDEyLCAxNiwgMTUsIDE2LCAxNywgMTcsIDE3LCAxNywgMTcsIDEzLCAxNiwgMTUsIDE3LCAxNywgMTcsIDE2LCAxNSwgMTcsIDE3LCAxNywgMTYsIDE1LCAxNywgMTcsIDE0LCAxNiwgMTcsIDE3LCAxNiwgMTcsIDE3LCAxNiwgMTUsIDE3LCAxNiwgMTQsIDE3LCAxNiwgMTUsIDE3LCAxNiwgMTcsIDE3LCAxNiwgMTcsIDE1LCAxNiwgMTcsIDE0LCAxNywgMTYsIDE1LCAxNywgMTYsIDE3LCAxMywgMTcsIDE2LCAxNywgMTcsIDE2LCAxNywgMTQsIDE3LCAxNiwgMTcsIDE2LCAxNywgMTYsIDE3LCA5XTtcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuZ2V0Qm91bmRzID0gZnVuY3Rpb24gKHJlY3QpIHtcblx0XHR2YXIgeCA9IHRoaXMuYmx1clh8MCwgeSA9IHRoaXMuYmx1cll8IDA7XG5cdFx0aWYgKHggPD0gMCAmJiB5IDw9IDApIHsgcmV0dXJuIHJlY3Q7IH1cblx0XHR2YXIgcSA9IE1hdGgucG93KHRoaXMucXVhbGl0eSwgMC4yKTtcblx0XHRyZXR1cm4gKHJlY3QgfHwgbmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSgpKS5wYWQoeCpxKzEseSpxKzEseCpxKzEseSpxKzEpO1xuXHR9O1xuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEJsdXJGaWx0ZXIodGhpcy5ibHVyWCwgdGhpcy5ibHVyWSwgdGhpcy5xdWFsaXR5KTtcblx0fTtcblxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0JsdXJGaWx0ZXJdXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuX2FwcGx5RmlsdGVyID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuXG5cdFx0dmFyIHJhZGl1c1ggPSB0aGlzLmJsdXJYID4+IDE7XG5cdFx0aWYgKGlzTmFOKHJhZGl1c1gpIHx8IHJhZGl1c1ggPCAwKSByZXR1cm4gZmFsc2U7XG5cdFx0dmFyIHJhZGl1c1kgPSB0aGlzLmJsdXJZID4+IDE7XG5cdFx0aWYgKGlzTmFOKHJhZGl1c1kpIHx8IHJhZGl1c1kgPCAwKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYgKHJhZGl1c1ggPT0gMCAmJiByYWRpdXNZID09IDApIHJldHVybiBmYWxzZTtcblxuXHRcdHZhciBpdGVyYXRpb25zID0gdGhpcy5xdWFsaXR5O1xuXHRcdGlmIChpc05hTihpdGVyYXRpb25zKSB8fCBpdGVyYXRpb25zIDwgMSkgaXRlcmF0aW9ucyA9IDE7XG5cdFx0aXRlcmF0aW9ucyB8PSAwO1xuXHRcdGlmIChpdGVyYXRpb25zID4gMykgaXRlcmF0aW9ucyA9IDM7XG5cdFx0aWYgKGl0ZXJhdGlvbnMgPCAxKSBpdGVyYXRpb25zID0gMTtcblxuXHRcdHZhciBweCA9IGltYWdlRGF0YS5kYXRhO1xuXHRcdHZhciB4PTAsIHk9MCwgaT0wLCBwPTAsIHlwPTAsIHlpPTAsIHl3PTAsIHI9MCwgZz0wLCBiPTAsIGE9MCwgcHI9MCwgcGc9MCwgcGI9MCwgcGE9MDtcblxuXHRcdHZhciBkaXZ4ID0gKHJhZGl1c1ggKyByYWRpdXNYICsgMSkgfCAwO1xuXHRcdHZhciBkaXZ5ID0gKHJhZGl1c1kgKyByYWRpdXNZICsgMSkgfCAwO1xuXHRcdHZhciB3ID0gaW1hZ2VEYXRhLndpZHRoIHwgMDtcblx0XHR2YXIgaCA9IGltYWdlRGF0YS5oZWlnaHQgfCAwO1xuXG5cdFx0dmFyIHcxID0gKHcgLSAxKSB8IDA7XG5cdFx0dmFyIGgxID0gKGggLSAxKSB8IDA7XG5cdFx0dmFyIHJ4cDEgPSAocmFkaXVzWCArIDEpIHwgMDtcblx0XHR2YXIgcnlwMSA9IChyYWRpdXNZICsgMSkgfCAwO1xuXG5cdFx0dmFyIHNzeCA9IHtyOjAsYjowLGc6MCxhOjB9O1xuXHRcdHZhciBzeCA9IHNzeDtcblx0XHRmb3IgKCBpID0gMTsgaSA8IGRpdng7IGkrKyApXG5cdFx0e1xuXHRcdFx0c3ggPSBzeC5uID0ge3I6MCxiOjAsZzowLGE6MH07XG5cdFx0fVxuXHRcdHN4Lm4gPSBzc3g7XG5cblx0XHR2YXIgc3N5ID0ge3I6MCxiOjAsZzowLGE6MH07XG5cdFx0dmFyIHN5ID0gc3N5O1xuXHRcdGZvciAoIGkgPSAxOyBpIDwgZGl2eTsgaSsrIClcblx0XHR7XG5cdFx0XHRzeSA9IHN5Lm4gPSB7cjowLGI6MCxnOjAsYTowfTtcblx0XHR9XG5cdFx0c3kubiA9IHNzeTtcblxuXHRcdHZhciBzaSA9IG51bGw7XG5cblxuXHRcdHZhciBtdHggPSBCbHVyRmlsdGVyLk1VTF9UQUJMRVtyYWRpdXNYXSB8IDA7XG5cdFx0dmFyIHN0eCA9IEJsdXJGaWx0ZXIuU0hHX1RBQkxFW3JhZGl1c1hdIHwgMDtcblx0XHR2YXIgbXR5ID0gQmx1ckZpbHRlci5NVUxfVEFCTEVbcmFkaXVzWV0gfCAwO1xuXHRcdHZhciBzdHkgPSBCbHVyRmlsdGVyLlNIR19UQUJMRVtyYWRpdXNZXSB8IDA7XG5cblx0XHR3aGlsZSAoaXRlcmF0aW9ucy0tID4gMCkge1xuXG5cdFx0XHR5dyA9IHlpID0gMDtcblx0XHRcdHZhciBtcyA9IG10eDtcblx0XHRcdHZhciBzcyA9IHN0eDtcblx0XHRcdGZvciAoeSA9IGg7IC0teSA+IC0xOykge1xuXHRcdFx0XHRyID0gcnhwMSAqIChwciA9IHB4Wyh5aSkgfCAwXSk7XG5cdFx0XHRcdGcgPSByeHAxICogKHBnID0gcHhbKHlpICsgMSkgfCAwXSk7XG5cdFx0XHRcdGIgPSByeHAxICogKHBiID0gcHhbKHlpICsgMikgfCAwXSk7XG5cdFx0XHRcdGEgPSByeHAxICogKHBhID0gcHhbKHlpICsgMykgfCAwXSk7XG5cblx0XHRcdFx0c3ggPSBzc3g7XG5cblx0XHRcdFx0Zm9yKCBpID0gcnhwMTsgLS1pID4gLTE7IClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHN4LnIgPSBwcjtcblx0XHRcdFx0XHRzeC5nID0gcGc7XG5cdFx0XHRcdFx0c3guYiA9IHBiO1xuXHRcdFx0XHRcdHN4LmEgPSBwYTtcblx0XHRcdFx0XHRzeCA9IHN4Lm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IoIGkgPSAxOyBpIDwgcnhwMTsgaSsrIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHAgPSAoeWkgKyAoKHcxIDwgaSA/IHcxIDogaSkgPDwgMikpIHwgMDtcblx0XHRcdFx0XHRyICs9ICggc3guciA9IHB4W3BdKTtcblx0XHRcdFx0XHRnICs9ICggc3guZyA9IHB4W3ArMV0pO1xuXHRcdFx0XHRcdGIgKz0gKCBzeC5iID0gcHhbcCsyXSk7XG5cdFx0XHRcdFx0YSArPSAoIHN4LmEgPSBweFtwKzNdKTtcblxuXHRcdFx0XHRcdHN4ID0gc3gubjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNpID0gc3N4O1xuXHRcdFx0XHRmb3IgKCB4ID0gMDsgeCA8IHc7IHgrKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRweFt5aSsrXSA9IChyICogbXMpID4+PiBzcztcblx0XHRcdFx0XHRweFt5aSsrXSA9IChnICogbXMpID4+PiBzcztcblx0XHRcdFx0XHRweFt5aSsrXSA9IChiICogbXMpID4+PiBzcztcblx0XHRcdFx0XHRweFt5aSsrXSA9IChhICogbXMpID4+PiBzcztcblxuXHRcdFx0XHRcdHAgPSAoKHl3ICsgKChwID0geCArIHJhZGl1c1ggKyAxKSA8IHcxID8gcCA6IHcxKSkgPDwgMik7XG5cblx0XHRcdFx0XHRyIC09IHNpLnIgLSAoIHNpLnIgPSBweFtwXSk7XG5cdFx0XHRcdFx0ZyAtPSBzaS5nIC0gKCBzaS5nID0gcHhbcCsxXSk7XG5cdFx0XHRcdFx0YiAtPSBzaS5iIC0gKCBzaS5iID0gcHhbcCsyXSk7XG5cdFx0XHRcdFx0YSAtPSBzaS5hIC0gKCBzaS5hID0gcHhbcCszXSk7XG5cblx0XHRcdFx0XHRzaSA9IHNpLm47XG5cblx0XHRcdFx0fVxuXHRcdFx0XHR5dyArPSB3O1xuXHRcdFx0fVxuXG5cdFx0XHRtcyA9IG10eTtcblx0XHRcdHNzID0gc3R5O1xuXHRcdFx0Zm9yICh4ID0gMDsgeCA8IHc7IHgrKykge1xuXHRcdFx0XHR5aSA9ICh4IDw8IDIpIHwgMDtcblxuXHRcdFx0XHRyID0gKHJ5cDEgKiAocHIgPSBweFt5aV0pKSB8IDA7XG5cdFx0XHRcdGcgPSAocnlwMSAqIChwZyA9IHB4Wyh5aSArIDEpIHwgMF0pKSB8IDA7XG5cdFx0XHRcdGIgPSAocnlwMSAqIChwYiA9IHB4Wyh5aSArIDIpIHwgMF0pKSB8IDA7XG5cdFx0XHRcdGEgPSAocnlwMSAqIChwYSA9IHB4Wyh5aSArIDMpIHwgMF0pKSB8IDA7XG5cblx0XHRcdFx0c3kgPSBzc3k7XG5cdFx0XHRcdGZvciggaSA9IDA7IGkgPCByeXAxOyBpKysgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c3kuciA9IHByO1xuXHRcdFx0XHRcdHN5LmcgPSBwZztcblx0XHRcdFx0XHRzeS5iID0gcGI7XG5cdFx0XHRcdFx0c3kuYSA9IHBhO1xuXHRcdFx0XHRcdHN5ID0gc3kubjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHlwID0gdztcblxuXHRcdFx0XHRmb3IoIGkgPSAxOyBpIDw9IHJhZGl1c1k7IGkrKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR5aSA9ICggeXAgKyB4ICkgPDwgMjtcblxuXHRcdFx0XHRcdHIgKz0gKCBzeS5yID0gcHhbeWldKTtcblx0XHRcdFx0XHRnICs9ICggc3kuZyA9IHB4W3lpKzFdKTtcblx0XHRcdFx0XHRiICs9ICggc3kuYiA9IHB4W3lpKzJdKTtcblx0XHRcdFx0XHRhICs9ICggc3kuYSA9IHB4W3lpKzNdKTtcblxuXHRcdFx0XHRcdHN5ID0gc3kubjtcblxuXHRcdFx0XHRcdGlmKCBpIDwgaDEgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHlwICs9IHc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0eWkgPSB4O1xuXHRcdFx0XHRzaSA9IHNzeTtcblx0XHRcdFx0aWYgKCBpdGVyYXRpb25zID4gMCApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmb3IgKCB5ID0gMDsgeSA8IGg7IHkrKyApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cCA9IHlpIDw8IDI7XG5cdFx0XHRcdFx0XHRweFtwKzNdID0gcGEgPShhICogbXMpID4+PiBzcztcblx0XHRcdFx0XHRcdGlmICggcGEgPiAwIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cHhbcF0gICA9ICgociAqIG1zKSA+Pj4gc3MgKTtcblx0XHRcdFx0XHRcdFx0cHhbcCsxXSA9ICgoZyAqIG1zKSA+Pj4gc3MgKTtcblx0XHRcdFx0XHRcdFx0cHhbcCsyXSA9ICgoYiAqIG1zKSA+Pj4gc3MgKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHB4W3BdID0gcHhbcCsxXSA9IHB4W3ArMl0gPSAwXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHAgPSAoIHggKyAoKCAoIHAgPSB5ICsgcnlwMSkgPCBoMSA/IHAgOiBoMSApICogdyApKSA8PCAyO1xuXG5cdFx0XHRcdFx0XHRyIC09IHNpLnIgLSAoIHNpLnIgPSBweFtwXSk7XG5cdFx0XHRcdFx0XHRnIC09IHNpLmcgLSAoIHNpLmcgPSBweFtwKzFdKTtcblx0XHRcdFx0XHRcdGIgLT0gc2kuYiAtICggc2kuYiA9IHB4W3ArMl0pO1xuXHRcdFx0XHRcdFx0YSAtPSBzaS5hIC0gKCBzaS5hID0gcHhbcCszXSk7XG5cblx0XHRcdFx0XHRcdHNpID0gc2kubjtcblxuXHRcdFx0XHRcdFx0eWkgKz0gdztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Zm9yICggeSA9IDA7IHkgPCBoOyB5KysgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHAgPSB5aSA8PCAyO1xuXHRcdFx0XHRcdFx0cHhbcCszXSA9IHBhID0oYSAqIG1zKSA+Pj4gc3M7XG5cdFx0XHRcdFx0XHRpZiAoIHBhID4gMCApXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHBhID0gMjU1IC8gcGE7XG5cdFx0XHRcdFx0XHRcdHB4W3BdICAgPSAoKHIgKiBtcykgPj4+IHNzICkgKiBwYTtcblx0XHRcdFx0XHRcdFx0cHhbcCsxXSA9ICgoZyAqIG1zKSA+Pj4gc3MgKSAqIHBhO1xuXHRcdFx0XHRcdFx0XHRweFtwKzJdID0gKChiICogbXMpID4+PiBzcyApICogcGE7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRweFtwXSA9IHB4W3ArMV0gPSBweFtwKzJdID0gMFxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRwID0gKCB4ICsgKCggKCBwID0geSArIHJ5cDEpIDwgaDEgPyBwIDogaDEgKSAqIHcgKSkgPDwgMjtcblxuXHRcdFx0XHRcdFx0ciAtPSBzaS5yIC0gKCBzaS5yID0gcHhbcF0pO1xuXHRcdFx0XHRcdFx0ZyAtPSBzaS5nIC0gKCBzaS5nID0gcHhbcCsxXSk7XG5cdFx0XHRcdFx0XHRiIC09IHNpLmIgLSAoIHNpLmIgPSBweFtwKzJdKTtcblx0XHRcdFx0XHRcdGEgLT0gc2kuYSAtICggc2kuYSA9IHB4W3ArM10pO1xuXG5cdFx0XHRcdFx0XHRzaSA9IHNpLm47XG5cblx0XHRcdFx0XHRcdHlpICs9IHc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0Y3JlYXRlanMuQmx1ckZpbHRlciA9IGNyZWF0ZWpzLnByb21vdGUoQmx1ckZpbHRlciwgXCJGaWx0ZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQWxwaGFNYXBGaWx0ZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cdFxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBBcHBsaWVzIGEgZ3JleXNjYWxlIGFscGhhIG1hcCBpbWFnZSAob3IgY2FudmFzKSB0byB0aGUgdGFyZ2V0LCBzdWNoIHRoYXQgdGhlIGFscGhhIGNoYW5uZWwgb2YgdGhlIHJlc3VsdCB3aWxsXG5cdCAqIGJlIGNvcGllZCBmcm9tIHRoZSByZWQgY2hhbm5lbCBvZiB0aGUgbWFwLCBhbmQgdGhlIFJHQiBjaGFubmVscyB3aWxsIGJlIGNvcGllZCBmcm9tIHRoZSB0YXJnZXQuXG5cdCAqXG5cdCAqIEdlbmVyYWxseSwgaXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3UgdXNlIHt7I2Nyb3NzTGluayBcIkFscGhhTWFza0ZpbHRlclwifX17ey9jcm9zc0xpbmt9fSwgYmVjYXVzZSBpdCBoYXMgbXVjaFxuXHQgKiBiZXR0ZXIgcGVyZm9ybWFuY2UuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogVGhpcyBleGFtcGxlIGRyYXdzIGEgcmVkLT5ibHVlIGJveCwgY2FjaGVzIGl0LCBhbmQgdGhlbiB1c2VzIHRoZSBjYWNoZSBjYW52YXMgYXMgYW4gYWxwaGEgbWFwIG9uIGEgMTAweDEwMCBpbWFnZS5cblx0ICpcblx0ICogICAgICAgdmFyIGJveCA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuXHQgKiAgICAgICBib3guZ3JhcGhpY3MuYmVnaW5MaW5lYXJHcmFkaWVudEZpbGwoW1wiI2ZmMDAwMFwiLCBcIiMwMDAwZmZcIl0sIFswLCAxXSwgMCwgMCwgMCwgMTAwKVxuXHQgKiAgICAgICBib3guZ3JhcGhpY3MuZHJhd1JlY3QoMCwgMCwgMTAwLCAxMDApO1xuXHQgKiAgICAgICBib3guY2FjaGUoMCwgMCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiAgICAgICB2YXIgYm1wID0gbmV3IGNyZWF0ZWpzLkJpdG1hcChcInBhdGgvdG8vaW1hZ2UuanBnXCIpO1xuXHQgKiAgICAgICBibXAuZmlsdGVycyA9IFtcblx0ICogICAgICAgICAgIG5ldyBjcmVhdGVqcy5BbHBoYU1hcEZpbHRlcihib3guY2FjaGVDYW52YXMpXG5cdCAqICAgICAgIF07XG5cdCAqICAgICAgIGJtcC5jYWNoZSgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqICAgICAgIHN0YWdlLmFkZENoaWxkKGJtcCk7XG5cdCAqXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gYXBwbHlpbmcgZmlsdGVycy5cblx0ICogQGNsYXNzIEFscGhhTWFwRmlsdGVyXG5cdCAqIEBleHRlbmRzIEZpbHRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBhbHBoYU1hcCBUaGUgZ3JleXNjYWxlIGltYWdlIChvciBjYW52YXMpIHRvIHVzZSBhcyB0aGUgYWxwaGEgdmFsdWUgZm9yIHRoZVxuXHQgKiByZXN1bHQuIFRoaXMgc2hvdWxkIGJlIGV4YWN0bHkgdGhlIHNhbWUgZGltZW5zaW9ucyBhcyB0aGUgdGFyZ2V0LlxuXHQgKiovXG5cdGZ1bmN0aW9uIEFscGhhTWFwRmlsdGVyKGFscGhhTWFwKSB7XG5cdFxuXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIGdyZXlzY2FsZSBpbWFnZSAob3IgY2FudmFzKSB0byB1c2UgYXMgdGhlIGFscGhhIHZhbHVlIGZvciB0aGUgcmVzdWx0LiBUaGlzIHNob3VsZCBiZSBleGFjdGx5IHRoZSBzYW1lXG5cdFx0ICogZGltZW5zaW9ucyBhcyB0aGUgdGFyZ2V0LlxuXHRcdCAqIEBwcm9wZXJ0eSBhbHBoYU1hcFxuXHRcdCAqIEB0eXBlIEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnRcblx0XHQgKiovXG5cdFx0dGhpcy5hbHBoYU1hcCA9IGFscGhhTWFwO1xuXHRcdFxuXHRcdFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9hbHBoYU1hcFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2FscGhhTWFwID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX21hcERhdGFcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgVWludDhDbGFtcGVkQXJyYXlcblx0XHQgKiovXG5cdFx0dGhpcy5fbWFwRGF0YSA9IG51bGw7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQWxwaGFNYXBGaWx0ZXIsIGNyZWF0ZWpzLkZpbHRlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG8gPSBuZXcgQWxwaGFNYXBGaWx0ZXIodGhpcy5hbHBoYU1hcCk7XG5cdFx0by5fYWxwaGFNYXAgPSB0aGlzLl9hbHBoYU1hcDtcblx0XHRvLl9tYXBEYXRhID0gdGhpcy5fbWFwRGF0YTtcblx0XHRyZXR1cm4gbztcblx0fTtcblxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltBbHBoYU1hcEZpbHRlcl1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuX2FwcGx5RmlsdGVyID0gZnVuY3Rpb24gKGltYWdlRGF0YSkge1xuXHRcdGlmICghdGhpcy5hbHBoYU1hcCkgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdGlmICghdGhpcy5fcHJlcEFscGhhTWFwKCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XG5cdFx0Ly8gVE9ETzogdXBkYXRlIHRvIHN1cHBvcnQgc2NlbmFyaW9zIHdoZXJlIHRoZSB0YXJnZXQgaGFzIGRpZmZlcmVudCBkaW1lbnNpb25zLlxuXHRcdHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcERhdGE7XG5cdFx0Zm9yKHZhciBpPTAsIGw9ZGF0YS5sZW5ndGg7IGk8bDsgaSArPSA0KSB7IGRhdGFbaSArIDNdID0gbWFwW2ldIHx8IDA7IH1cblx0XHRcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfcHJlcEFscGhhTWFwXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9wcmVwQWxwaGFNYXAgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLmFscGhhTWFwKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGlmICh0aGlzLmFscGhhTWFwID09IHRoaXMuX2FscGhhTWFwICYmIHRoaXMuX21hcERhdGEpIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdHRoaXMuX21hcERhdGEgPSBudWxsO1xuXHRcdHZhciBtYXAgPSB0aGlzLl9hbHBoYU1hcCA9IHRoaXMuYWxwaGFNYXA7XG5cdFx0dmFyIGNhbnZhcyA9IG1hcDtcblx0XHR2YXIgY3R4O1xuXHRcdGlmIChtYXAgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkge1xuXHRcdFx0Y3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FudmFzID0gY3JlYXRlanMuY3JlYXRlQ2FudmFzID8gY3JlYXRlanMuY3JlYXRlQ2FudmFzKCkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXHRcdFx0Y2FudmFzLndpZHRoID0gbWFwLndpZHRoO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IG1hcC5oZWlnaHQ7XG5cdFx0XHRjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdFx0Y3R4LmRyYXdJbWFnZShtYXAsIDAsIDApO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgaW1nRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgbWFwLndpZHRoLCBtYXAuaGVpZ2h0KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHQvL2lmICghdGhpcy5zdXBwcmVzc0Nyb3NzRG9tYWluRXJyb3JzKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmFibGUgdG8gYWNjZXNzIGxvY2FsIGltYWdlIGRhdGE6IFwiICsgZSk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdFxuXHRcdHRoaXMuX21hcERhdGEgPSBpbWdEYXRhLmRhdGE7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5BbHBoYU1hcEZpbHRlciA9IGNyZWF0ZWpzLnByb21vdGUoQWxwaGFNYXBGaWx0ZXIsIFwiRmlsdGVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEFscGhhTWFza0ZpbHRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQXBwbGllcyB0aGUgYWxwaGEgZnJvbSB0aGUgbWFzayBpbWFnZSAob3IgY2FudmFzKSB0byB0aGUgdGFyZ2V0LCBzdWNoIHRoYXQgdGhlIGFscGhhIGNoYW5uZWwgb2YgdGhlIHJlc3VsdCB3aWxsXG5cdCAqIGJlIGRlcml2ZWQgZnJvbSB0aGUgbWFzaywgYW5kIHRoZSBSR0IgY2hhbm5lbHMgd2lsbCBiZSBjb3BpZWQgZnJvbSB0aGUgdGFyZ2V0LiBUaGlzIGNhbiBiZSB1c2VkLCBmb3IgZXhhbXBsZSwgdG9cblx0ICogYXBwbHkgYW4gYWxwaGEgbWFzayB0byBhIGRpc3BsYXkgb2JqZWN0LiBUaGlzIGNhbiBhbHNvIGJlIHVzZWQgdG8gY29tYmluZSBhIEpQRyBjb21wcmVzc2VkIFJHQiBpbWFnZSB3aXRoIGEgUE5HMzJcblx0ICogYWxwaGEgbWFzaywgd2hpY2ggY2FuIHJlc3VsdCBpbiBhIG11Y2ggc21hbGxlciBmaWxlIHNpemUgdGhhbiBhIHNpbmdsZSBQTkczMiBjb250YWluaW5nIEFSR0IuXG5cdCAqXG5cdCAqIDxiPklNUE9SVEFOVCBOT1RFOiBUaGlzIGZpbHRlciBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCB0aGUgdGFyZ2V0Q3R4LCBvciB0YXJnZXRYL1kgcGFyYW1ldGVycyBjb3JyZWN0bHkuPC9iPlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIFRoaXMgZXhhbXBsZSBkcmF3cyBhIGdyYWRpZW50IGJveCwgdGhlbiBjYWNoZXMgaXQgYW5kIHVzZXMgdGhlIFwiY2FjaGVDYW52YXNcIiBhcyB0aGUgYWxwaGEgbWFzayBvbiBhIDEwMHgxMDAgaW1hZ2UuXG5cdCAqXG5cdCAqICAgICAgdmFyIGJveCA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuXHQgKiAgICAgIGJveC5ncmFwaGljcy5iZWdpbkxpbmVhckdyYWRpZW50RmlsbChbXCIjMDAwMDAwXCIsIFwicmdiYSgwLCAwLCAwLCAwKVwiXSwgWzAsIDFdLCAwLCAwLCAxMDAsIDEwMClcblx0ICogICAgICBib3guZ3JhcGhpY3MuZHJhd1JlY3QoMCwgMCwgMTAwLCAxMDApO1xuXHQgKiAgICAgIGJveC5jYWNoZSgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqXG5cdCAqICAgICAgdmFyIGJtcCA9IG5ldyBjcmVhdGVqcy5CaXRtYXAoXCJwYXRoL3RvL2ltYWdlLmpwZ1wiKTtcblx0ICogICAgICBibXAuZmlsdGVycyA9IFtcblx0ICogICAgICAgICAgbmV3IGNyZWF0ZWpzLkFscGhhTWFza0ZpbHRlcihib3guY2FjaGVDYW52YXMpXG5cdCAqICAgICAgXTtcblx0ICogICAgICBibXAuY2FjaGUoMCwgMCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGFwcGx5aW5nIGZpbHRlcnMuXG5cdCAqIEBjbGFzcyBBbHBoYU1hc2tGaWx0ZXJcblx0ICogQGV4dGVuZHMgRmlsdGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IG1hc2tcblx0ICoqL1xuXHRmdW5jdGlvbiBBbHBoYU1hc2tGaWx0ZXIobWFzaykge1xuXHRcblx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSBpbWFnZSAob3IgY2FudmFzKSB0byB1c2UgYXMgdGhlIG1hc2suXG5cdFx0ICogQHByb3BlcnR5IG1hc2tcblx0XHQgKiBAdHlwZSBIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50XG5cdFx0ICoqL1xuXHRcdHRoaXMubWFzayA9IG1hc2s7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQWxwaGFNYXNrRmlsdGVyLCBjcmVhdGVqcy5GaWx0ZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXHRcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBBcHBsaWVzIHRoZSBmaWx0ZXIgdG8gdGhlIHNwZWNpZmllZCBjb250ZXh0LlxuXHQgKlxuXHQgKiA8c3Ryb25nPklNUE9SVEFOVCBOT1RFOiBUaGlzIGZpbHRlciBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCB0aGUgdGFyZ2V0Q3R4LCBvciB0YXJnZXRYL1kgcGFyYW1ldGVyc1xuXHQgKiBjb3JyZWN0bHkuPC9zdHJvbmc+XG5cdCAqIEBtZXRob2QgYXBwbHlGaWx0ZXJcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgMkQgY29udGV4dCB0byB1c2UgYXMgdGhlIHNvdXJjZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uIHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBbdGFyZ2V0Q3R4XSBOT1QgU1VQUE9SVEVEIElOIFRISVMgRklMVEVSLiBUaGUgMkQgY29udGV4dCB0byBkcmF3IHRoZSByZXN1bHQgdG8uIERlZmF1bHRzIHRvIHRoZSBjb250ZXh0IHBhc3NlZCB0byBjdHguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGFyZ2V0WF0gTk9UIFNVUFBPUlRFRCBJTiBUSElTIEZJTFRFUi4gVGhlIHggcG9zaXRpb24gdG8gZHJhdyB0aGUgcmVzdWx0IHRvLiBEZWZhdWx0cyB0byB0aGUgdmFsdWUgcGFzc2VkIHRvIHguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGFyZ2V0WV0gTk9UIFNVUFBPUlRFRCBJTiBUSElTIEZJTFRFUi4gVGhlIHkgcG9zaXRpb24gdG8gZHJhdyB0aGUgcmVzdWx0IHRvLiBEZWZhdWx0cyB0byB0aGUgdmFsdWUgcGFzc2VkIHRvIHkuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBmaWx0ZXIgd2FzIGFwcGxpZWQgc3VjY2Vzc2Z1bGx5LlxuXHQgKiovXG5cdHAuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0YXJnZXRDdHgsIHRhcmdldFgsIHRhcmdldFkpIHtcblx0XHRpZiAoIXRoaXMubWFzaykgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdHRhcmdldEN0eCA9IHRhcmdldEN0eCB8fCBjdHg7XG5cdFx0aWYgKHRhcmdldFggPT0gbnVsbCkgeyB0YXJnZXRYID0geDsgfVxuXHRcdGlmICh0YXJnZXRZID09IG51bGwpIHsgdGFyZ2V0WSA9IHk7IH1cblxuXHRcdHRhcmdldEN0eC5zYXZlKCk7XG5cdFx0aWYgKGN0eCAhPSB0YXJnZXRDdHgpIHtcblx0XHRcdC8vIFRPRE86IHN1cHBvcnQgdGFyZ2V0Q3R4IGFuZCB0YXJnZXRYL1lcblx0XHRcdC8vIGNsZWFyUmVjdCwgdGhlbiBkcmF3IHRoZSBjdHggaW4/XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dGFyZ2V0Q3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24taW5cIjtcblx0XHR0YXJnZXRDdHguZHJhd0ltYWdlKHRoaXMubWFzaywgdGFyZ2V0WCwgdGFyZ2V0WSk7XG5cdFx0dGFyZ2V0Q3R4LnJlc3RvcmUoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBuZXcgQWxwaGFNYXNrRmlsdGVyKHRoaXMubWFzayk7XG5cdH07XG5cblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbQWxwaGFNYXNrRmlsdGVyXVwiO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuQWxwaGFNYXNrRmlsdGVyID0gY3JlYXRlanMucHJvbW90ZShBbHBoYU1hc2tGaWx0ZXIsIFwiRmlsdGVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIENvbG9yRmlsdGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBBcHBsaWVzIGEgY29sb3IgdHJhbnNmb3JtIHRvIERpc3BsYXlPYmplY3RzLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIFRoaXMgZXhhbXBsZSBkcmF3cyBhIHJlZCBjaXJjbGUsIGFuZCB0aGVuIHRyYW5zZm9ybXMgaXQgdG8gQmx1ZS4gVGhpcyBpcyBhY2NvbXBsaXNoZWQgYnkgbXVsdGlwbHlpbmcgYWxsIHRoZSBjaGFubmVsc1xuXHQgKiB0byAwIChleGNlcHQgYWxwaGEsIHdoaWNoIGlzIHNldCB0byAxKSwgYW5kIHRoZW4gYWRkaW5nIDI1NSB0byB0aGUgYmx1ZSBjaGFubmVsLlxuXHQgKlxuXHQgKiAgICAgIHZhciBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpLnNldCh7eDoxMDAseToxMDB9KTtcblx0ICogICAgICBzaGFwZS5ncmFwaGljcy5iZWdpbkZpbGwoXCIjZmYwMDAwXCIpLmRyYXdDaXJjbGUoMCwwLDUwKTtcblx0ICpcblx0ICogICAgICBzaGFwZS5maWx0ZXJzID0gW1xuXHQgKiAgICAgICAgICBuZXcgY3JlYXRlanMuQ29sb3JGaWx0ZXIoMCwwLDAsMSwgMCwwLDI1NSwwKVxuXHQgKiAgICAgIF07XG5cdCAqICAgICAgc2hhcGUuY2FjaGUoLTUwLCAtNTAsIDEwMCwgMTAwKTtcblx0ICpcblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkZpbHRlclwifX17ey9jcm9zc0xpbmt9fSBmb3IgYW4gbW9yZSBpbmZvcm1hdGlvbiBvbiBhcHBseWluZyBmaWx0ZXJzLlxuXHQgKiBAY2xhc3MgQ29sb3JGaWx0ZXJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtyZWRNdWx0aXBsaWVyPTFdIFRoZSBhbW91bnQgdG8gbXVsdGlwbHkgYWdhaW5zdCB0aGUgcmVkIGNoYW5uZWwuIFRoaXMgaXMgYSByYW5nZSBiZXR3ZWVuIDAgYW5kIDEuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZ3JlZW5NdWx0aXBsaWVyPTFdIFRoZSBhbW91bnQgdG8gbXVsdGlwbHkgYWdhaW5zdCB0aGUgZ3JlZW4gY2hhbm5lbC4gVGhpcyBpcyBhIHJhbmdlIGJldHdlZW4gMCBhbmQgMS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtibHVlTXVsdGlwbGllcj0xXSBUaGUgYW1vdW50IHRvIG11bHRpcGx5IGFnYWluc3QgdGhlIGJsdWUgY2hhbm5lbC4gVGhpcyBpcyBhIHJhbmdlIGJldHdlZW4gMCBhbmQgMS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthbHBoYU11bHRpcGxpZXI9MV0gVGhlIGFtb3VudCB0byBtdWx0aXBseSBhZ2FpbnN0IHRoZSBhbHBoYSBjaGFubmVsLiBUaGlzIGlzIGEgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3JlZE9mZnNldD0wXSBUaGUgYW1vdW50IHRvIGFkZCB0byB0aGUgcmVkIGNoYW5uZWwgYWZ0ZXIgaXQgaGFzIGJlZW4gbXVsdGlwbGllZC4gVGhpcyBpcyBhIHJhbmdlXG5cdCAqIGJldHdlZW4gLTI1NSBhbmQgMjU1LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2dyZWVuT2Zmc2V0PTBdIFRoZSBhbW91bnQgdG8gYWRkIHRvIHRoZSBncmVlbiBjaGFubmVsIGFmdGVyIGl0IGhhcyBiZWVuIG11bHRpcGxpZWQuIFRoaXMgaXMgYSByYW5nZVxuXHQgICogYmV0d2VlbiAtMjU1IGFuZCAyNTUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYmx1ZU9mZnNldD0wXSBUaGUgYW1vdW50IHRvIGFkZCB0byB0aGUgYmx1ZSBjaGFubmVsIGFmdGVyIGl0IGhhcyBiZWVuIG11bHRpcGxpZWQuIFRoaXMgaXMgYSByYW5nZVxuXHQgICogYmV0d2VlbiAtMjU1IGFuZCAyNTUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYWxwaGFPZmZzZXQ9MF0gVGhlIGFtb3VudCB0byBhZGQgdG8gdGhlIGFscGhhIGNoYW5uZWwgYWZ0ZXIgaXQgaGFzIGJlZW4gbXVsdGlwbGllZC4gVGhpcyBpcyBhIHJhbmdlXG5cdCAgKiBiZXR3ZWVuIC0yNTUgYW5kIDI1NS5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBleHRlbmRzIEZpbHRlclxuXHQgKiovXG5cdGZ1bmN0aW9uIENvbG9yRmlsdGVyKHJlZE11bHRpcGxpZXIsIGdyZWVuTXVsdGlwbGllciwgYmx1ZU11bHRpcGxpZXIsIGFscGhhTXVsdGlwbGllciwgcmVkT2Zmc2V0LCBncmVlbk9mZnNldCwgYmx1ZU9mZnNldCwgYWxwaGFPZmZzZXQpIHtcblx0XHRcblx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFJlZCBjaGFubmVsIG11bHRpcGxpZXIuXG5cdFx0ICogQHByb3BlcnR5IHJlZE11bHRpcGxpZXJcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5yZWRNdWx0aXBsaWVyID0gcmVkTXVsdGlwbGllciAhPSBudWxsID8gcmVkTXVsdGlwbGllciA6IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEdyZWVuIGNoYW5uZWwgbXVsdGlwbGllci5cblx0XHQgKiBAcHJvcGVydHkgZ3JlZW5NdWx0aXBsaWVyXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuZ3JlZW5NdWx0aXBsaWVyID0gZ3JlZW5NdWx0aXBsaWVyICE9IG51bGwgPyBncmVlbk11bHRpcGxpZXIgOiAxO1xuXHRcblx0XHQvKipcblx0XHQgKiBCbHVlIGNoYW5uZWwgbXVsdGlwbGllci5cblx0XHQgKiBAcHJvcGVydHkgYmx1ZU11bHRpcGxpZXJcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5ibHVlTXVsdGlwbGllciA9IGJsdWVNdWx0aXBsaWVyICE9IG51bGwgPyBibHVlTXVsdGlwbGllciA6IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFscGhhIGNoYW5uZWwgbXVsdGlwbGllci5cblx0XHQgKiBAcHJvcGVydHkgYWxwaGFNdWx0aXBsaWVyXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuYWxwaGFNdWx0aXBsaWVyID0gYWxwaGFNdWx0aXBsaWVyICE9IG51bGwgPyBhbHBoYU11bHRpcGxpZXIgOiAxO1xuXHRcblx0XHQvKipcblx0XHQgKiBSZWQgY2hhbm5lbCBvZmZzZXQgKGFkZGVkIHRvIHZhbHVlKS5cblx0XHQgKiBAcHJvcGVydHkgcmVkT2Zmc2V0XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMucmVkT2Zmc2V0ID0gcmVkT2Zmc2V0IHx8IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEdyZWVuIGNoYW5uZWwgb2Zmc2V0IChhZGRlZCB0byB2YWx1ZSkuXG5cdFx0ICogQHByb3BlcnR5IGdyZWVuT2Zmc2V0XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuZ3JlZW5PZmZzZXQgPSBncmVlbk9mZnNldCB8fCAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBCbHVlIGNoYW5uZWwgb2Zmc2V0IChhZGRlZCB0byB2YWx1ZSkuXG5cdFx0ICogQHByb3BlcnR5IGJsdWVPZmZzZXRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5ibHVlT2Zmc2V0ID0gYmx1ZU9mZnNldCB8fCAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBBbHBoYSBjaGFubmVsIG9mZnNldCAoYWRkZWQgdG8gdmFsdWUpLlxuXHRcdCAqIEBwcm9wZXJ0eSBhbHBoYU9mZnNldFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmFscGhhT2Zmc2V0ID0gYWxwaGFPZmZzZXQgfHwgMDtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChDb2xvckZpbHRlciwgY3JlYXRlanMuRmlsdGVyKTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltDb2xvckZpbHRlcl1cIjtcblx0fTtcblxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvckZpbHRlcih0aGlzLnJlZE11bHRpcGxpZXIsIHRoaXMuZ3JlZW5NdWx0aXBsaWVyLCB0aGlzLmJsdWVNdWx0aXBsaWVyLCB0aGlzLmFscGhhTXVsdGlwbGllciwgdGhpcy5yZWRPZmZzZXQsIHRoaXMuZ3JlZW5PZmZzZXQsIHRoaXMuYmx1ZU9mZnNldCwgdGhpcy5hbHBoYU9mZnNldCk7XG5cdH07XG5cdFxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuX2FwcGx5RmlsdGVyID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG5cdFx0dmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblx0XHR2YXIgbCA9IGRhdGEubGVuZ3RoO1xuXHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKz00KSB7XG5cdFx0XHRkYXRhW2ldID0gZGF0YVtpXSp0aGlzLnJlZE11bHRpcGxpZXIrdGhpcy5yZWRPZmZzZXQ7XG5cdFx0XHRkYXRhW2krMV0gPSBkYXRhW2krMV0qdGhpcy5ncmVlbk11bHRpcGxpZXIrdGhpcy5ncmVlbk9mZnNldDtcblx0XHRcdGRhdGFbaSsyXSA9IGRhdGFbaSsyXSp0aGlzLmJsdWVNdWx0aXBsaWVyK3RoaXMuYmx1ZU9mZnNldDtcblx0XHRcdGRhdGFbaSszXSA9IGRhdGFbaSszXSp0aGlzLmFscGhhTXVsdGlwbGllcit0aGlzLmFscGhhT2Zmc2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLkNvbG9yRmlsdGVyID0gY3JlYXRlanMucHJvbW90ZShDb2xvckZpbHRlciwgXCJGaWx0ZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQ29sb3JNYXRyaXguanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgZm9yIGFzc2VtYmxpbmcgYSBtYXRyaXggZm9yIHVzZSB3aXRoIHRoZSB7eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeEZpbHRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogTW9zdCBtZXRob2RzIHJldHVybiB0aGUgaW5zdGFuY2UgdG8gZmFjaWxpdGF0ZSBjaGFpbmVkIGNhbGxzLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgbXlDb2xvck1hdHJpeC5hZGp1c3RIdWUoMjApLmFkanVzdEJyaWdodG5lc3MoNTApO1xuXHQgKlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhbiBleGFtcGxlIG9mIGhvdyB0byBhcHBseSBmaWx0ZXJzLCBvciB7eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeEZpbHRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgYW4gZXhhbXBsZSBvZiBob3cgdG8gdXNlIENvbG9yTWF0cml4IHRvIGNoYW5nZSBhIERpc3BsYXlPYmplY3QncyBjb2xvci5cblx0ICogQGNsYXNzIENvbG9yTWF0cml4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBicmlnaHRuZXNzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb250cmFzdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gaHVlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIENvbG9yTWF0cml4KGJyaWdodG5lc3MsIGNvbnRyYXN0LCBzYXR1cmF0aW9uLCBodWUpIHtcblx0XHR0aGlzLnNldENvbG9yKGJyaWdodG5lc3MsIGNvbnRyYXN0LCBzYXR1cmF0aW9uLCBodWUpO1xuXHR9XG5cdHZhciBwID0gQ29sb3JNYXRyaXgucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBjb25zdGFudHM6XG5cdC8qKlxuXHQgKiBBcnJheSBvZiBkZWx0YSB2YWx1ZXMgZm9yIGNvbnRyYXN0IGNhbGN1bGF0aW9ucy5cblx0ICogQHByb3BlcnR5IERFTFRBX0lOREVYXG5cdCAqIEB0eXBlIEFycmF5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdENvbG9yTWF0cml4LkRFTFRBX0lOREVYID0gW1xuXHRcdDAsICAgIDAuMDEsIDAuMDIsIDAuMDQsIDAuMDUsIDAuMDYsIDAuMDcsIDAuMDgsIDAuMSwgIDAuMTEsXG5cdFx0MC4xMiwgMC4xNCwgMC4xNSwgMC4xNiwgMC4xNywgMC4xOCwgMC4yMCwgMC4yMSwgMC4yMiwgMC4yNCxcblx0XHQwLjI1LCAwLjI3LCAwLjI4LCAwLjMwLCAwLjMyLCAwLjM0LCAwLjM2LCAwLjM4LCAwLjQwLCAwLjQyLFxuXHRcdDAuNDQsIDAuNDYsIDAuNDgsIDAuNSwgIDAuNTMsIDAuNTYsIDAuNTksIDAuNjIsIDAuNjUsIDAuNjgsXG5cdFx0MC43MSwgMC43NCwgMC43NywgMC44MCwgMC44MywgMC44NiwgMC44OSwgMC45MiwgMC45NSwgMC45OCxcblx0XHQxLjAsICAxLjA2LCAxLjEyLCAxLjE4LCAxLjI0LCAxLjMwLCAxLjM2LCAxLjQyLCAxLjQ4LCAxLjU0LFxuXHRcdDEuNjAsIDEuNjYsIDEuNzIsIDEuNzgsIDEuODQsIDEuOTAsIDEuOTYsIDIuMCwgIDIuMTIsIDIuMjUsXG5cdFx0Mi4zNywgMi41MCwgMi42MiwgMi43NSwgMi44NywgMy4wLCAgMy4yLCAgMy40LCAgMy42LCAgMy44LFxuXHRcdDQuMCwgIDQuMywgIDQuNywgIDQuOSwgIDUuMCwgIDUuNSwgIDYuMCwgIDYuNSwgIDYuOCwgIDcuMCxcblx0XHQ3LjMsICA3LjUsICA3LjgsICA4LjAsICA4LjQsICA4LjcsICA5LjAsICA5LjQsICA5LjYsICA5LjgsXG5cdFx0MTAuMFxuXHRdO1xuXG5cdC8qKlxuXHQgKiBJZGVudGl0eSBtYXRyaXggdmFsdWVzLlxuXHQgKiBAcHJvcGVydHkgSURFTlRJVFlfTUFUUklYXG5cdCAqIEB0eXBlIEFycmF5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdENvbG9yTWF0cml4LklERU5USVRZX01BVFJJWCA9IFtcblx0XHQxLDAsMCwwLDAsXG5cdFx0MCwxLDAsMCwwLFxuXHRcdDAsMCwxLDAsMCxcblx0XHQwLDAsMCwxLDAsXG5cdFx0MCwwLDAsMCwxXG5cdF07XG5cblx0LyoqXG5cdCAqIFRoZSBjb25zdGFudCBsZW5ndGggb2YgYSBjb2xvciBtYXRyaXguXG5cdCAqIEBwcm9wZXJ0eSBMRU5HVEhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdENvbG9yTWF0cml4LkxFTkdUSCA9IENvbG9yTWF0cml4LklERU5USVRZX01BVFJJWC5sZW5ndGg7XG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXNldHMgdGhlIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZXMuXG5cdCAqIEBtZXRob2Qgc2V0Q29sb3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGJyaWdodG5lc3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvbnRyYXN0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzYXR1cmF0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBodWVcblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHAuc2V0Q29sb3IgPSBmdW5jdGlvbihicmlnaHRuZXNzLGNvbnRyYXN0LHNhdHVyYXRpb24saHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVzZXQoKS5hZGp1c3RDb2xvcihicmlnaHRuZXNzLGNvbnRyYXN0LHNhdHVyYXRpb24saHVlKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVzZXRzIHRoZSBtYXRyaXggdG8gaWRlbnRpdHkgdmFsdWVzLlxuXHQgKiBAbWV0aG9kIHJlc2V0XG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqL1xuXHRwLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29weShDb2xvck1hdHJpeC5JREVOVElUWV9NQVRSSVgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCBtZXRob2QgdG8gYWRqdXN0IGJyaWdodG5lc3MsIGNvbnRyYXN0LCBzYXR1cmF0aW9uIGFuZCBodWUuXG5cdCAqIEVxdWl2YWxlbnQgdG8gY2FsbGluZyBhZGp1c3RIdWUoaHVlKSwgYWRqdXN0Q29udHJhc3QoY29udHJhc3QpLFxuXHQgKiBhZGp1c3RCcmlnaHRuZXNzKGJyaWdodG5lc3MpLCBhZGp1c3RTYXR1cmF0aW9uKHNhdHVyYXRpb24pLCBpbiB0aGF0IG9yZGVyLlxuXHQgKiBAbWV0aG9kIGFkanVzdENvbG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBicmlnaHRuZXNzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb250cmFzdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gaHVlXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hZGp1c3RDb2xvciA9IGZ1bmN0aW9uKGJyaWdodG5lc3MsY29udHJhc3Qsc2F0dXJhdGlvbixodWUpIHtcblx0XHR0aGlzLmFkanVzdEh1ZShodWUpO1xuXHRcdHRoaXMuYWRqdXN0Q29udHJhc3QoY29udHJhc3QpO1xuXHRcdHRoaXMuYWRqdXN0QnJpZ2h0bmVzcyhicmlnaHRuZXNzKTtcblx0XHRyZXR1cm4gdGhpcy5hZGp1c3RTYXR1cmF0aW9uKHNhdHVyYXRpb24pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGp1c3RzIHRoZSBicmlnaHRuZXNzIG9mIHBpeGVsIGNvbG9yIGJ5IGFkZGluZyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIHRoZSByZWQsIGdyZWVuIGFuZCBibHVlIGNoYW5uZWxzLlxuXHQgKiBQb3NpdGl2ZSB2YWx1ZXMgd2lsbCBtYWtlIHRoZSBpbWFnZSBicmlnaHRlciwgbmVnYXRpdmUgdmFsdWVzIHdpbGwgbWFrZSBpdCBkYXJrZXIuXG5cdCAqIEBtZXRob2QgYWRqdXN0QnJpZ2h0bmVzc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgQSB2YWx1ZSBiZXR3ZWVuIC0yNTUgJiAyNTUgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBSR0IgY2hhbm5lbHMuXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hZGp1c3RCcmlnaHRuZXNzID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT0gMCB8fCBpc05hTih2YWx1ZSkpIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR2YWx1ZSA9IHRoaXMuX2NsZWFuVmFsdWUodmFsdWUsMjU1KTtcblx0XHR0aGlzLl9tdWx0aXBseU1hdHJpeChbXG5cdFx0XHQxLDAsMCwwLHZhbHVlLFxuXHRcdFx0MCwxLDAsMCx2YWx1ZSxcblx0XHRcdDAsMCwxLDAsdmFsdWUsXG5cdFx0XHQwLDAsMCwxLDAsXG5cdFx0XHQwLDAsMCwwLDFcblx0XHRdKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQWRqdXN0cyB0aGUgY29udHJhc3Qgb2YgcGl4ZWwgY29sb3IuXG5cdCAqIFBvc2l0aXZlIHZhbHVlcyB3aWxsIGluY3JlYXNlIGNvbnRyYXN0LCBuZWdhdGl2ZSB2YWx1ZXMgd2lsbCBkZWNyZWFzZSBjb250cmFzdC5cblx0ICogQG1ldGhvZCBhZGp1c3RDb250cmFzdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgQSB2YWx1ZSBiZXR3ZWVuIC0xMDAgJiAxMDAuXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hZGp1c3RDb250cmFzdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09IDAgfHwgaXNOYU4odmFsdWUpKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dmFsdWUgPSB0aGlzLl9jbGVhblZhbHVlKHZhbHVlLDEwMCk7XG5cdFx0dmFyIHg7XG5cdFx0aWYgKHZhbHVlPDApIHtcblx0XHRcdHggPSAxMjcrdmFsdWUvMTAwKjEyNztcblx0XHR9IGVsc2Uge1xuXHRcdFx0eCA9IHZhbHVlJTE7XG5cdFx0XHRpZiAoeCA9PSAwKSB7XG5cdFx0XHRcdHggPSBDb2xvck1hdHJpeC5ERUxUQV9JTkRFWFt2YWx1ZV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR4ID0gQ29sb3JNYXRyaXguREVMVEFfSU5ERVhbKHZhbHVlPDwwKV0qKDEteCkrQ29sb3JNYXRyaXguREVMVEFfSU5ERVhbKHZhbHVlPDwwKSsxXSp4OyAvLyB1c2UgbGluZWFyIGludGVycG9sYXRpb24gZm9yIG1vcmUgZ3JhbnVsYXJpdHkuXG5cdFx0XHR9XG5cdFx0XHR4ID0geCoxMjcrMTI3O1xuXHRcdH1cblx0XHR0aGlzLl9tdWx0aXBseU1hdHJpeChbXG5cdFx0XHR4LzEyNywwLDAsMCwwLjUqKDEyNy14KSxcblx0XHRcdDAseC8xMjcsMCwwLDAuNSooMTI3LXgpLFxuXHRcdFx0MCwwLHgvMTI3LDAsMC41KigxMjcteCksXG5cdFx0XHQwLDAsMCwxLDAsXG5cdFx0XHQwLDAsMCwwLDFcblx0XHRdKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQWRqdXN0cyB0aGUgY29sb3Igc2F0dXJhdGlvbiBvZiB0aGUgcGl4ZWwuXG5cdCAqIFBvc2l0aXZlIHZhbHVlcyB3aWxsIGluY3JlYXNlIHNhdHVyYXRpb24sIG5lZ2F0aXZlIHZhbHVlcyB3aWxsIGRlY3JlYXNlIHNhdHVyYXRpb24gKHRyZW5kIHRvd2FyZHMgZ3JleXNjYWxlKS5cblx0ICogQG1ldGhvZCBhZGp1c3RTYXR1cmF0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBBIHZhbHVlIGJldHdlZW4gLTEwMCAmIDEwMC5cblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmFkanVzdFNhdHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PSAwIHx8IGlzTmFOKHZhbHVlKSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHZhbHVlID0gdGhpcy5fY2xlYW5WYWx1ZSh2YWx1ZSwxMDApO1xuXHRcdHZhciB4ID0gMSsoKHZhbHVlID4gMCkgPyAzKnZhbHVlLzEwMCA6IHZhbHVlLzEwMCk7XG5cdFx0dmFyIGx1bVIgPSAwLjMwODY7XG5cdFx0dmFyIGx1bUcgPSAwLjYwOTQ7XG5cdFx0dmFyIGx1bUIgPSAwLjA4MjA7XG5cdFx0dGhpcy5fbXVsdGlwbHlNYXRyaXgoW1xuXHRcdFx0bHVtUiooMS14KSt4LGx1bUcqKDEteCksbHVtQiooMS14KSwwLDAsXG5cdFx0XHRsdW1SKigxLXgpLGx1bUcqKDEteCkreCxsdW1CKigxLXgpLDAsMCxcblx0XHRcdGx1bVIqKDEteCksbHVtRyooMS14KSxsdW1CKigxLXgpK3gsMCwwLFxuXHRcdFx0MCwwLDAsMSwwLFxuXHRcdFx0MCwwLDAsMCwxXG5cdFx0XSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblxuXHQvKipcblx0ICogQWRqdXN0cyB0aGUgaHVlIG9mIHRoZSBwaXhlbCBjb2xvci5cblx0ICogQG1ldGhvZCBhZGp1c3RIdWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIEEgdmFsdWUgYmV0d2VlbiAtMTgwICYgMTgwLlxuXHQgKiBAcmV0dXJuIHtDb2xvck1hdHJpeH0gVGhlIENvbG9yTWF0cml4IGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYWRqdXN0SHVlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT0gMCB8fCBpc05hTih2YWx1ZSkpIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR2YWx1ZSA9IHRoaXMuX2NsZWFuVmFsdWUodmFsdWUsMTgwKS8xODAqTWF0aC5QSTtcblx0XHR2YXIgY29zVmFsID0gTWF0aC5jb3ModmFsdWUpO1xuXHRcdHZhciBzaW5WYWwgPSBNYXRoLnNpbih2YWx1ZSk7XG5cdFx0dmFyIGx1bVIgPSAwLjIxMztcblx0XHR2YXIgbHVtRyA9IDAuNzE1O1xuXHRcdHZhciBsdW1CID0gMC4wNzI7XG5cdFx0dGhpcy5fbXVsdGlwbHlNYXRyaXgoW1xuXHRcdFx0bHVtUitjb3NWYWwqKDEtbHVtUikrc2luVmFsKigtbHVtUiksbHVtRytjb3NWYWwqKC1sdW1HKStzaW5WYWwqKC1sdW1HKSxsdW1CK2Nvc1ZhbCooLWx1bUIpK3NpblZhbCooMS1sdW1CKSwwLDAsXG5cdFx0XHRsdW1SK2Nvc1ZhbCooLWx1bVIpK3NpblZhbCooMC4xNDMpLGx1bUcrY29zVmFsKigxLWx1bUcpK3NpblZhbCooMC4xNDApLGx1bUIrY29zVmFsKigtbHVtQikrc2luVmFsKigtMC4yODMpLDAsMCxcblx0XHRcdGx1bVIrY29zVmFsKigtbHVtUikrc2luVmFsKigtKDEtbHVtUikpLGx1bUcrY29zVmFsKigtbHVtRykrc2luVmFsKihsdW1HKSxsdW1CK2Nvc1ZhbCooMS1sdW1CKStzaW5WYWwqKGx1bUIpLDAsMCxcblx0XHRcdDAsMCwwLDEsMCxcblx0XHRcdDAsMCwwLDAsMVxuXHRcdF0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb25jYXRlbmF0ZXMgKG11bHRpcGxpZXMpIHRoZSBzcGVjaWZpZWQgbWF0cml4IHdpdGggdGhpcyBvbmUuXG5cdCAqIEBtZXRob2QgY29uY2F0XG5cdCAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeCBBbiBhcnJheSBvciBDb2xvck1hdHJpeCBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmNvbmNhdCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdG1hdHJpeCA9IHRoaXMuX2ZpeE1hdHJpeChtYXRyaXgpO1xuXHRcdGlmIChtYXRyaXgubGVuZ3RoICE9IENvbG9yTWF0cml4LkxFTkdUSCkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX211bHRpcGx5TWF0cml4KG1hdHJpeCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGlzIENvbG9yTWF0cml4LlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBBIGNsb25lIG9mIHRoaXMgQ29sb3JNYXRyaXguXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAobmV3IENvbG9yTWF0cml4KCkpLmNvcHkodGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybiBhIGxlbmd0aCAyNSAoNXg1KSBhcnJheSBpbnN0YW5jZSBjb250YWluaW5nIHRoaXMgbWF0cml4J3MgdmFsdWVzLlxuXHQgKiBAbWV0aG9kIHRvQXJyYXlcblx0ICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IGhvbGRpbmcgdGhpcyBtYXRyaXgncyB2YWx1ZXMuXG5cdCAqKi9cblx0cC50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyciA9IFtdO1xuXHRcdGZvciAodmFyIGk9IDAsIGw9Q29sb3JNYXRyaXguTEVOR1RIOyBpPGw7IGkrKykge1xuXHRcdFx0YXJyW2ldID0gdGhpc1tpXTtcblx0XHR9XG5cdFx0cmV0dXJuIGFycjtcblx0fTtcblxuXHQvKipcblx0ICogQ29weSB0aGUgc3BlY2lmaWVkIG1hdHJpeCdzIHZhbHVlcyB0byB0aGlzIG1hdHJpeC5cblx0ICogQG1ldGhvZCBjb3B5XG5cdCAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeCBBbiBhcnJheSBvciBDb2xvck1hdHJpeCBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmNvcHkgPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR2YXIgbCA9IENvbG9yTWF0cml4LkxFTkdUSDtcblx0XHRmb3IgKHZhciBpPTA7aTxsO2krKykge1xuXHRcdFx0dGhpc1tpXSA9IG1hdHJpeFtpXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0NvbG9yTWF0cml4XVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX211bHRpcGx5TWF0cml4XG5cdCAqIEBwYXJhbSB7QXJyYXl9IG1hdHJpeFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fbXVsdGlwbHlNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR2YXIgaSwgaiwgaywgY29sID0gW107XG5cblx0XHRmb3IgKGk9MDtpPDU7aSsrKSB7XG5cdFx0XHRmb3IgKGo9MDtqPDU7aisrKSB7XG5cdFx0XHRcdGNvbFtqXSA9IHRoaXNbaitpKjVdO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChqPTA7ajw1O2orKykge1xuXHRcdFx0XHR2YXIgdmFsPTA7XG5cdFx0XHRcdGZvciAoaz0wO2s8NTtrKyspIHtcblx0XHRcdFx0XHR2YWwgKz0gbWF0cml4W2orayo1XSpjb2xba107XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpc1tqK2kqNV0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBNYWtlIHN1cmUgdmFsdWVzIGFyZSB3aXRoaW4gdGhlIHNwZWNpZmllZCByYW5nZSwgaHVlIGhhcyBhIGxpbWl0IG9mIDE4MCwgYnJpZ2h0bmVzcyBpcyAyNTUsIG90aGVycyBhcmUgMTAwLlxuXHQgKiBAbWV0aG9kIF9jbGVhblZhbHVlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgcmF3IG51bWJlclxuXHQgKiBAcGFyYW0ge051bWJlcn0gbGltaXQgVGhlIG1heGltdW0gdGhhdCB0aGUgbnVtYmVyIGNhbiBiZS4gVGhlIG1pbmltdW0gaXMgdGhlIGxpbWl0ICogLTEuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9jbGVhblZhbHVlID0gZnVuY3Rpb24odmFsdWUsIGxpbWl0KSB7XG5cdFx0cmV0dXJuIE1hdGgubWluKGxpbWl0LE1hdGgubWF4KC1saW1pdCx2YWx1ZSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBNYWtlcyBzdXJlIG1hdHJpeGVzIGFyZSA1eDUgKDI1IGxvbmcpLlxuXHQgKiBAbWV0aG9kIF9maXhNYXRyaXhcblx0ICogQHBhcmFtIHtBcnJheX0gbWF0cml4XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9maXhNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRpZiAobWF0cml4IGluc3RhbmNlb2YgQ29sb3JNYXRyaXgpIHsgbWF0cml4ID0gbWF0cml4LnRvQXJyYXkoKTsgfVxuXHRcdGlmIChtYXRyaXgubGVuZ3RoIDwgQ29sb3JNYXRyaXguTEVOR1RIKSB7XG5cdFx0XHRtYXRyaXggPSBtYXRyaXguc2xpY2UoMCxtYXRyaXgubGVuZ3RoKS5jb25jYXQoQ29sb3JNYXRyaXguSURFTlRJVFlfTUFUUklYLnNsaWNlKG1hdHJpeC5sZW5ndGgsQ29sb3JNYXRyaXguTEVOR1RIKSk7XG5cdFx0fSBlbHNlIGlmIChtYXRyaXgubGVuZ3RoID4gQ29sb3JNYXRyaXguTEVOR1RIKSB7XG5cdFx0XHRtYXRyaXggPSBtYXRyaXguc2xpY2UoMCxDb2xvck1hdHJpeC5MRU5HVEgpO1xuXHRcdH1cblx0XHRyZXR1cm4gbWF0cml4O1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuQ29sb3JNYXRyaXggPSBDb2xvck1hdHJpeDtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBDb2xvck1hdHJpeEZpbHRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQWxsb3dzIHlvdSB0byBjYXJyeSBvdXQgY29tcGxleCBjb2xvciBvcGVyYXRpb25zIHN1Y2ggYXMgbW9kaWZ5aW5nIHNhdHVyYXRpb24sIGJyaWdodG5lc3MsIG9yIGludmVydGluZy4gU2VlIHRoZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBjaGFuZ2luZyBjb2xvcnMuIEZvciBhbiBlYXNpZXIgY29sb3IgdHJhbnNmb3JtLFxuXHQgKiBjb25zaWRlciB0aGUge3sjY3Jvc3NMaW5rIFwiQ29sb3JGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogVGhpcyBleGFtcGxlIGNyZWF0ZXMgYSByZWQgY2lyY2xlLCBpbnZlcnRzIGl0cyBodWUsIGFuZCB0aGVuIHNhdHVyYXRlcyBpdCB0byBicmlnaHRlbiBpdCB1cC5cblx0ICpcblx0ICogICAgICB2YXIgc2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKS5zZXQoe3g6MTAwLHk6MTAwfSk7XG5cdCAqICAgICAgc2hhcGUuZ3JhcGhpY3MuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3Q2lyY2xlKDAsMCw1MCk7XG5cdCAqXG5cdCAqICAgICAgdmFyIG1hdHJpeCA9IG5ldyBjcmVhdGVqcy5Db2xvck1hdHJpeCgpLmFkanVzdEh1ZSgxODApLmFkanVzdFNhdHVyYXRpb24oMTAwKTtcblx0ICogICAgICBzaGFwZS5maWx0ZXJzID0gW1xuXHQgKiAgICAgICAgICBuZXcgY3JlYXRlanMuQ29sb3JNYXRyaXhGaWx0ZXIobWF0cml4KVxuXHQgKiAgICAgIF07XG5cdCAqXG5cdCAqICAgICAgc2hhcGUuY2FjaGUoLTUwLCAtNTAsIDEwMCwgMTAwKTtcblx0ICpcblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkZpbHRlclwifX17ey9jcm9zc0xpbmt9fSBmb3IgYW4gbW9yZSBpbmZvcm1hdGlvbiBvbiBhcHBseWluZyBmaWx0ZXJzLlxuXHQgKiBAY2xhc3MgQ29sb3JNYXRyaXhGaWx0ZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBleHRlbmRzIEZpbHRlclxuXHQgKiBAcGFyYW0ge0FycmF5IHwgQ29sb3JNYXRyaXh9IG1hdHJpeCBBIDR4NSBtYXRyaXggZGVzY3JpYmluZyB0aGUgY29sb3Igb3BlcmF0aW9uIHRvIHBlcmZvcm0uIFNlZSBhbHNvIHRoZSB7eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBjbGFzcy5cblx0ICoqL1xuXHRmdW5jdGlvbiBDb2xvck1hdHJpeEZpbHRlcihtYXRyaXgpIHtcblx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIEEgNHg1IG1hdHJpeCBkZXNjcmliaW5nIHRoZSBjb2xvciBvcGVyYXRpb24gdG8gcGVyZm9ybS4gU2VlIGFsc28gdGhlIHt7I2Nyb3NzTGluayBcIkNvbG9yTWF0cml4XCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogQHByb3BlcnR5IG1hdHJpeFxuXHRcdCAqIEB0eXBlIEFycmF5IHwgQ29sb3JNYXRyaXhcblx0XHQgKiovXG5cdFx0dGhpcy5tYXRyaXggPSBtYXRyaXg7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQ29sb3JNYXRyaXhGaWx0ZXIsIGNyZWF0ZWpzLkZpbHRlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cdFxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltDb2xvck1hdHJpeEZpbHRlcl1cIjtcblx0fTtcblxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvck1hdHJpeEZpbHRlcih0aGlzLm1hdHJpeCk7XG5cdH07XG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5fYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbihpbWFnZURhdGEpIHsgXG5cdFx0dmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblx0XHR2YXIgbCA9IGRhdGEubGVuZ3RoO1xuXHRcdHZhciByLGcsYixhO1xuXHRcdHZhciBtdHggPSB0aGlzLm1hdHJpeDtcblx0XHR2YXIgbTAgPSAgbXR4WzBdLCAgbTEgPSAgbXR4WzFdLCAgbTIgPSAgbXR4WzJdLCAgbTMgPSAgbXR4WzNdLCAgbTQgPSAgbXR4WzRdO1xuXHRcdHZhciBtNSA9ICBtdHhbNV0sICBtNiA9ICBtdHhbNl0sICBtNyA9ICBtdHhbN10sICBtOCA9ICBtdHhbOF0sICBtOSA9ICBtdHhbOV07XG5cdFx0dmFyIG0xMCA9IG10eFsxMF0sIG0xMSA9IG10eFsxMV0sIG0xMiA9IG10eFsxMl0sIG0xMyA9IG10eFsxM10sIG0xNCA9IG10eFsxNF07XG5cdFx0dmFyIG0xNSA9IG10eFsxNV0sIG0xNiA9IG10eFsxNl0sIG0xNyA9IG10eFsxN10sIG0xOCA9IG10eFsxOF0sIG0xOSA9IG10eFsxOV07XG5cblx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSs9NCkge1xuXHRcdFx0ciA9IGRhdGFbaV07XG5cdFx0XHRnID0gZGF0YVtpKzFdO1xuXHRcdFx0YiA9IGRhdGFbaSsyXTtcblx0XHRcdGEgPSBkYXRhW2krM107XG5cdFx0XHRkYXRhW2ldID0gciptMCtnKm0xK2IqbTIrYSptMyttNDsgLy8gcmVkXG5cdFx0XHRkYXRhW2krMV0gPSByKm01K2cqbTYrYiptNythKm04K205OyAvLyBncmVlblxuXHRcdFx0ZGF0YVtpKzJdID0gciptMTArZyptMTErYiptMTIrYSptMTMrbTE0OyAvLyBibHVlXG5cdFx0XHRkYXRhW2krM10gPSByKm0xNStnKm0xNitiKm0xNythKm0xOCttMTk7IC8vIGFscGhhXG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuQ29sb3JNYXRyaXhGaWx0ZXIgPSBjcmVhdGVqcy5wcm9tb3RlKENvbG9yTWF0cml4RmlsdGVyLCBcIkZpbHRlclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUb3VjaC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcbiAqIEdsb2JhbCB1dGlsaXR5IGZvciB3b3JraW5nIHdpdGggbXVsdGktdG91Y2ggZW5hYmxlZCBkZXZpY2VzIGluIEVhc2VsSlMuIEN1cnJlbnRseSBzdXBwb3J0cyBXM0MgVG91Y2ggQVBJIChpT1MgYW5kXG4gKiBtb2Rlcm4gQW5kcm9pZCBicm93c2VyKSBhbmQgdGhlIFBvaW50ZXIgQVBJIChJRSksIGluY2x1ZGluZyBtcy1wcmVmaXhlZCBldmVudHMgaW4gSUUxMCwgYW5kIHVucHJlZml4ZWQgaW4gSUUxMS5cbiAqXG4gKiBFbnN1cmUgdGhhdCB5b3Uge3sjY3Jvc3NMaW5rIFwiVG91Y2gvZGlzYWJsZVwifX17ey9jcm9zc0xpbmt9fSB0b3VjaCB3aGVuIGNsZWFuaW5nIHVwIHlvdXIgYXBwbGljYXRpb24uIFlvdSBkbyBub3QgaGF2ZVxuICogdG8gY2hlY2sgaWYgdG91Y2ggaXMgc3VwcG9ydGVkIHRvIGVuYWJsZSBpdCwgYXMgaXQgd2lsbCBmYWlsIGdyYWNlZnVsbHkgaWYgaXQgaXMgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiA8aDQ+RXhhbXBsZTwvaDQ+XG4gKlxuICogICAgICB2YXIgc3RhZ2UgPSBuZXcgY3JlYXRlanMuU3RhZ2UoXCJjYW52YXNJZFwiKTtcbiAqICAgICAgY3JlYXRlanMuVG91Y2guZW5hYmxlKHN0YWdlKTtcbiAqXG4gKiA8c3Ryb25nPk5vdGU6PC9zdHJvbmc+IEl0IGlzIGltcG9ydGFudCB0byBkaXNhYmxlIFRvdWNoIG9uIGEgc3RhZ2UgdGhhdCB5b3UgYXJlIG5vIGxvbmdlciB1c2luZzpcbiAqXG4gKiAgICAgIGNyZWF0ZWpzLlRvdWNoLmRpc2FibGUoc3RhZ2UpO1xuICpcbiAqIEBjbGFzcyBUb3VjaFxuICogQHN0YXRpY1xuICoqL1xuXHRmdW5jdGlvbiBUb3VjaCgpIHtcblx0XHR0aHJvdyBcIlRvdWNoIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWRcIjtcblx0fVxuXG5cbi8vIHB1YmxpYyBzdGF0aWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgYHRydWVgIGlmIHRvdWNoIGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBicm93c2VyLlxuXHQgKiBAbWV0aG9kIGlzU3VwcG9ydGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEluZGljYXRlcyB3aGV0aGVyIHRvdWNoIGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBicm93c2VyLlxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm5cdCEhKCgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIC8vIGlPUyAmIEFuZHJvaWRcblx0XHRcdHx8ICh3aW5kb3cubmF2aWdhdG9yWydtc1BvaW50ZXJFbmFibGVkJ10gJiYgd2luZG93Lm5hdmlnYXRvclsnbXNNYXhUb3VjaFBvaW50cyddID4gMCkgLy8gSUUxMFxuXHRcdFx0fHwgKHdpbmRvdy5uYXZpZ2F0b3JbJ3BvaW50ZXJFbmFibGVkJ10gJiYgd2luZG93Lm5hdmlnYXRvclsnbWF4VG91Y2hQb2ludHMnXSA+IDApKTsgLy8gSUUxMStcblx0fTtcblxuXHQvKipcblx0ICogRW5hYmxlcyB0b3VjaCBpbnRlcmFjdGlvbiBmb3IgdGhlIHNwZWNpZmllZCBFYXNlbEpTIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319LiBDdXJyZW50bHkgc3VwcG9ydHMgaU9TXG5cdCAqIChhbmQgY29tcGF0aWJsZSBicm93c2Vycywgc3VjaCBhcyBtb2Rlcm4gQW5kcm9pZCBicm93c2VycyksIGFuZCBJRTEwLzExLiBTdXBwb3J0cyBib3RoIHNpbmdsZSB0b3VjaCBhbmRcblx0ICogbXVsdGktdG91Y2ggbW9kZXMuIEV4dGVuZHMgdGhlIEVhc2VsSlMge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBtb2RlbCwgYnV0IHdpdGhvdXQgc3VwcG9ydCBmb3Jcblx0ICogZG91YmxlIGNsaWNrIG9yIG92ZXIvb3V0IGV2ZW50cy4gU2VlIHRoZSBNb3VzZUV2ZW50IHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnQvcG9pbnRlcklkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIGVuYWJsZVxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZSBUaGUge3sjY3Jvc3NMaW5rIFwiU3RhZ2VcIn19e3svY3Jvc3NMaW5rfX0gdG8gZW5hYmxlIHRvdWNoIG9uLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaW5nbGVUb3VjaD1mYWxzZV0gSWYgYHRydWVgLCBvbmx5IGEgc2luZ2xlIHRvdWNoIHdpbGwgYmUgYWN0aXZlIGF0IGEgdGltZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbYWxsb3dEZWZhdWx0PWZhbHNlXSBJZiBgdHJ1ZWAsIHRoZW4gZGVmYXVsdCBnZXN0dXJlIGFjdGlvbnMgKGV4LiBzY3JvbGxpbmcsIHpvb21pbmcpIHdpbGwgYmVcblx0ICogYWxsb3dlZCB3aGVuIHRoZSB1c2VyIGlzIGludGVyYWN0aW5nIHdpdGggdGhlIHRhcmdldCBjYW52YXMuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRvdWNoIHdhcyBzdWNjZXNzZnVsbHkgZW5hYmxlZCBvbiB0aGUgdGFyZ2V0IHN0YWdlLlxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guZW5hYmxlID0gZnVuY3Rpb24oc3RhZ2UsIHNpbmdsZVRvdWNoLCBhbGxvd0RlZmF1bHQpIHtcblx0XHRpZiAoIXN0YWdlIHx8ICFzdGFnZS5jYW52YXMgfHwgIVRvdWNoLmlzU3VwcG9ydGVkKCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHN0YWdlLl9fdG91Y2gpIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdC8vIGluamVjdCByZXF1aXJlZCBwcm9wZXJ0aWVzIG9uIHN0YWdlOlxuXHRcdHN0YWdlLl9fdG91Y2ggPSB7cG9pbnRlcnM6e30sIG11bHRpdG91Y2g6IXNpbmdsZVRvdWNoLCBwcmV2ZW50RGVmYXVsdDohYWxsb3dEZWZhdWx0LCBjb3VudDowfTtcblxuXHRcdC8vIG5vdGUgdGhhdCBpbiB0aGUgZnV0dXJlIHdlIG1heSBuZWVkIHRvIGRpc2FibGUgdGhlIHN0YW5kYXJkIG1vdXNlIGV2ZW50IG1vZGVsIGJlZm9yZSBhZGRpbmdcblx0XHQvLyB0aGVzZSB0byBwcmV2ZW50IGR1cGxpY2F0ZSBjYWxscy4gSXQgZG9lc24ndCBzZWVtIHRvIGJlIGFuIGlzc3VlIHdpdGggaU9TIGRldmljZXMgdGhvdWdoLlxuXHRcdGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHsgVG91Y2guX0lPU19lbmFibGUoc3RhZ2UpOyB9XG5cdFx0ZWxzZSBpZiAod2luZG93Lm5hdmlnYXRvclsnbXNQb2ludGVyRW5hYmxlZCddIHx8IHdpbmRvdy5uYXZpZ2F0b3JbXCJwb2ludGVyRW5hYmxlZFwiXSkgeyBUb3VjaC5fSUVfZW5hYmxlKHN0YWdlKTsgfVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIHNldCB1cCB3aGVuIGNhbGxpbmcgYFRvdWNoLmVuYWJsZSgpYCBvbiBhIHN0YWdlLlxuXHQgKiBAbWV0aG9kIGRpc2FibGVcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2UgVGhlIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319IHRvIGRpc2FibGUgdG91Y2ggb24uXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5kaXNhYmxlID0gZnVuY3Rpb24oc3RhZ2UpIHtcblx0XHRpZiAoIXN0YWdlKSB7IHJldHVybjsgfVxuXHRcdGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHsgVG91Y2guX0lPU19kaXNhYmxlKHN0YWdlKTsgfVxuXHRcdGVsc2UgaWYgKHdpbmRvdy5uYXZpZ2F0b3JbJ21zUG9pbnRlckVuYWJsZWQnXSB8fCB3aW5kb3cubmF2aWdhdG9yW1wicG9pbnRlckVuYWJsZWRcIl0pIHsgVG91Y2guX0lFX2Rpc2FibGUoc3RhZ2UpOyB9XG5cdFx0XG5cdFx0ZGVsZXRlIHN0YWdlLl9fdG91Y2g7XG5cdH07XG5cblxuLy8gUHJpdmF0ZSBzdGF0aWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX0lPU19lbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guX0lPU19lbmFibGUgPSBmdW5jdGlvbihzdGFnZSkge1xuXHRcdHZhciBjYW52YXMgPSBzdGFnZS5jYW52YXM7XG5cdFx0dmFyIGYgPSBzdGFnZS5fX3RvdWNoLmYgPSBmdW5jdGlvbihlKSB7IFRvdWNoLl9JT1NfaGFuZGxlRXZlbnQoc3RhZ2UsZSk7IH07XG5cdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIGYsIGZhbHNlKTtcblx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBmLCBmYWxzZSk7XG5cdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBmLCBmYWxzZSk7XG5cdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCBmLCBmYWxzZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX0lPU19kaXNhYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2Vcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRvdWNoLl9JT1NfZGlzYWJsZSA9IGZ1bmN0aW9uKHN0YWdlKSB7XG5cdFx0dmFyIGNhbnZhcyA9IHN0YWdlLmNhbnZhcztcblx0XHRpZiAoIWNhbnZhcykgeyByZXR1cm47IH1cblx0XHR2YXIgZiA9IHN0YWdlLl9fdG91Y2guZjtcblx0XHRjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgZiwgZmFsc2UpO1xuXHRcdGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGYsIGZhbHNlKTtcblx0XHRjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGYsIGZhbHNlKTtcblx0XHRjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIGYsIGZhbHNlKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfSU9TX2hhbmRsZUV2ZW50XG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBldmVudCB0byBoYW5kbGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guX0lPU19oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKHN0YWdlLCBlKSB7XG5cdFx0aWYgKCFzdGFnZSkgeyByZXR1cm47IH1cblx0XHRpZiAoc3RhZ2UuX190b3VjaC5wcmV2ZW50RGVmYXVsdCkgeyBlLnByZXZlbnREZWZhdWx0JiZlLnByZXZlbnREZWZhdWx0KCk7IH1cblx0XHR2YXIgdG91Y2hlcyA9IGUuY2hhbmdlZFRvdWNoZXM7XG5cdFx0dmFyIHR5cGUgPSBlLnR5cGU7XG5cdFx0Zm9yICh2YXIgaT0gMCxsPXRvdWNoZXMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0dmFyIHRvdWNoID0gdG91Y2hlc1tpXTtcblx0XHRcdHZhciBpZCA9IHRvdWNoLmlkZW50aWZpZXI7XG5cdFx0XHRpZiAodG91Y2gudGFyZ2V0ICE9IHN0YWdlLmNhbnZhcykgeyBjb250aW51ZTsgfVxuXG5cdFx0XHRpZiAodHlwZSA9PSBcInRvdWNoc3RhcnRcIikge1xuXHRcdFx0XHR0aGlzLl9oYW5kbGVTdGFydChzdGFnZSwgaWQsIGUsIHRvdWNoLnBhZ2VYLCB0b3VjaC5wYWdlWSk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT0gXCJ0b3VjaG1vdmVcIikge1xuXHRcdFx0XHR0aGlzLl9oYW5kbGVNb3ZlKHN0YWdlLCBpZCwgZSwgdG91Y2gucGFnZVgsIHRvdWNoLnBhZ2VZKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PSBcInRvdWNoZW5kXCIgfHwgdHlwZSA9PSBcInRvdWNoY2FuY2VsXCIpIHtcblx0XHRcdFx0dGhpcy5faGFuZGxlRW5kKHN0YWdlLCBpZCwgZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9JRV9lbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guX0lFX2VuYWJsZSA9IGZ1bmN0aW9uKHN0YWdlKSB7XG5cdFx0dmFyIGNhbnZhcyA9IHN0YWdlLmNhbnZhcztcblx0XHR2YXIgZiA9IHN0YWdlLl9fdG91Y2guZiA9IGZ1bmN0aW9uKGUpIHsgVG91Y2guX0lFX2hhbmRsZUV2ZW50KHN0YWdlLGUpOyB9O1xuXG5cdFx0aWYgKHdpbmRvdy5uYXZpZ2F0b3JbXCJwb2ludGVyRW5hYmxlZFwiXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlckRvd25cIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJNb3ZlXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyVXBcIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJDYW5jZWxcIiwgZiwgZmFsc2UpO1xuXHRcdFx0aWYgKHN0YWdlLl9fdG91Y2gucHJldmVudERlZmF1bHQpIHsgY2FudmFzLnN0eWxlLm1zVG91Y2hBY3Rpb24gPSBcIm5vbmVcIjsgfVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIGYsIGZhbHNlKTtcblx0XHRcdGlmIChzdGFnZS5fX3RvdWNoLnByZXZlbnREZWZhdWx0KSB7IGNhbnZhcy5zdHlsZS50b3VjaEFjdGlvbiA9IFwibm9uZVwiOyB9XG5cblx0XHR9XG5cdFx0c3RhZ2UuX190b3VjaC5hY3RpdmVJRHMgPSB7fTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfSUVfZGlzYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5fSUVfZGlzYWJsZSA9IGZ1bmN0aW9uKHN0YWdlKSB7XG5cdFx0dmFyIGYgPSBzdGFnZS5fX3RvdWNoLmY7XG5cblx0XHRpZiAod2luZG93Lm5hdmlnYXRvcltcInBvaW50ZXJFbmFibGVkXCJdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyTW92ZVwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlclVwXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyQ2FuY2VsXCIsIGYsIGZhbHNlKTtcblx0XHRcdGlmIChzdGFnZS5jYW52YXMpIHtcblx0XHRcdFx0c3RhZ2UuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJEb3duXCIsIGYsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIiwgZiwgZmFsc2UpO1xuXHRcdFx0aWYgKHN0YWdlLmNhbnZhcykge1xuXHRcdFx0XHRzdGFnZS5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGYsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX0lFX2hhbmRsZUV2ZW50XG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBldmVudCB0byBoYW5kbGUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRvdWNoLl9JRV9oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKHN0YWdlLCBlKSB7XG5cdFx0aWYgKCFzdGFnZSkgeyByZXR1cm47IH1cblx0XHRpZiAoc3RhZ2UuX190b3VjaC5wcmV2ZW50RGVmYXVsdCkgeyBlLnByZXZlbnREZWZhdWx0ICYmIGUucHJldmVudERlZmF1bHQoKTsgfVxuXHRcdHZhciB0eXBlID0gZS50eXBlO1xuXHRcdHZhciBpZCA9IGUucG9pbnRlcklkO1xuXHRcdHZhciBpZHMgPSBzdGFnZS5fX3RvdWNoLmFjdGl2ZUlEcztcblxuXHRcdGlmICh0eXBlID09IFwiTVNQb2ludGVyRG93blwiIHx8IHR5cGUgPT0gXCJwb2ludGVyZG93blwiKSB7XG5cdFx0XHRpZiAoZS5zcmNFbGVtZW50ICE9IHN0YWdlLmNhbnZhcykgeyByZXR1cm47IH1cblx0XHRcdGlkc1tpZF0gPSB0cnVlO1xuXHRcdFx0dGhpcy5faGFuZGxlU3RhcnQoc3RhZ2UsIGlkLCBlLCBlLnBhZ2VYLCBlLnBhZ2VZKTtcblx0XHR9IGVsc2UgaWYgKGlkc1tpZF0pIHsgLy8gaXQncyBhbiBpZCB3ZSdyZSB3YXRjaGluZ1xuXHRcdFx0aWYgKHR5cGUgPT0gXCJNU1BvaW50ZXJNb3ZlXCIgfHwgdHlwZSA9PSBcInBvaW50ZXJtb3ZlXCIpIHtcblx0XHRcdFx0dGhpcy5faGFuZGxlTW92ZShzdGFnZSwgaWQsIGUsIGUucGFnZVgsIGUucGFnZVkpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09IFwiTVNQb2ludGVyVXBcIiB8fCB0eXBlID09IFwiTVNQb2ludGVyQ2FuY2VsXCJcblx0XHRcdFx0XHR8fCB0eXBlID09IFwicG9pbnRlcnVwXCIgfHwgdHlwZSA9PSBcInBvaW50ZXJjYW5jZWxcIikge1xuXHRcdFx0XHRkZWxldGUoaWRzW2lkXSk7XG5cdFx0XHRcdHRoaXMuX2hhbmRsZUVuZChzdGFnZSwgaWQsIGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlU3RhcnRcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2Vcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VG91Y2guX2hhbmRsZVN0YXJ0ID0gZnVuY3Rpb24oc3RhZ2UsIGlkLCBlLCB4LCB5KSB7XG5cdFx0dmFyIHByb3BzID0gc3RhZ2UuX190b3VjaDtcblx0XHRpZiAoIXByb3BzLm11bHRpdG91Y2ggJiYgcHJvcHMuY291bnQpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIGlkcyA9IHByb3BzLnBvaW50ZXJzO1xuXHRcdGlmIChpZHNbaWRdKSB7IHJldHVybjsgfVxuXHRcdGlkc1tpZF0gPSB0cnVlO1xuXHRcdHByb3BzLmNvdW50Kys7XG5cdFx0c3RhZ2UuX2hhbmRsZVBvaW50ZXJEb3duKGlkLCBlLCB4LCB5KTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlTW92ZVxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGlkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUb3VjaC5faGFuZGxlTW92ZSA9IGZ1bmN0aW9uKHN0YWdlLCBpZCwgZSwgeCwgeSkge1xuXHRcdGlmICghc3RhZ2UuX190b3VjaC5wb2ludGVyc1tpZF0pIHsgcmV0dXJuOyB9XG5cdFx0c3RhZ2UuX2hhbmRsZVBvaW50ZXJNb3ZlKGlkLCBlLCB4LCB5KTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlRW5kXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gaWRcblx0ICogQHBhcmFtIHtPYmplY3R9IGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRvdWNoLl9oYW5kbGVFbmQgPSBmdW5jdGlvbihzdGFnZSwgaWQsIGUpIHtcblx0XHQvLyBUT0RPOiBjYW5jZWwgc2hvdWxkIGJlIGhhbmRsZWQgZGlmZmVyZW50bHkgZm9yIHByb3BlciBVSSAoZXguIGFuIHVwIHdvdWxkIHRyaWdnZXIgYSBjbGljaywgYSBjYW5jZWwgd291bGQgbW9yZSBjbG9zZWx5IHJlc2VtYmxlIGFuIG91dCkuXG5cdFx0dmFyIHByb3BzID0gc3RhZ2UuX190b3VjaDtcblx0XHR2YXIgaWRzID0gcHJvcHMucG9pbnRlcnM7XG5cdFx0aWYgKCFpZHNbaWRdKSB7IHJldHVybjsgfVxuXHRcdHByb3BzLmNvdW50LS07XG5cdFx0c3RhZ2UuX2hhbmRsZVBvaW50ZXJVcChpZCwgZSwgdHJ1ZSk7XG5cdFx0ZGVsZXRlKGlkc1tpZF0pO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuVG91Y2ggPSBUb3VjaDtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyB2ZXJzaW9uLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogU3RhdGljIGNsYXNzIGhvbGRpbmcgbGlicmFyeSBzcGVjaWZpYyBpbmZvcm1hdGlvbiBzdWNoIGFzIHRoZSB2ZXJzaW9uIGFuZCBidWlsZERhdGUgb2Zcblx0ICogdGhlIGxpYnJhcnkuXG5cdCAqIEBjbGFzcyBFYXNlbEpTXG5cdCAqKi9cblx0dmFyIHMgPSBjcmVhdGVqcy5FYXNlbEpTID0gY3JlYXRlanMuRWFzZWxKUyB8fCB7fTtcblxuXHQvKipcblx0ICogVGhlIHZlcnNpb24gc3RyaW5nIGZvciB0aGlzIHJlbGVhc2UuXG5cdCAqIEBwcm9wZXJ0eSB2ZXJzaW9uXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy52ZXJzaW9uID0gLyo9dmVyc2lvbiovXCIwLjguMVwiOyAvLyBpbmplY3RlZCBieSBidWlsZCBwcm9jZXNzXG5cblx0LyoqXG5cdCAqIFRoZSBidWlsZCBkYXRlIGZvciB0aGlzIHJlbGVhc2UgaW4gVVRDIGZvcm1hdC5cblx0ICogQHByb3BlcnR5IGJ1aWxkRGF0ZVxuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdHMuYnVpbGREYXRlID0gLyo9ZGF0ZSovXCJUaHUsIDIxIE1heSAyMDE1IDE2OjE3OjM5IEdNVFwiOyAvLyBpbmplY3RlZCBieSBidWlsZCBwcm9jZXNzXG5cbn0pKCk7XG4vKiFcbiogUHJlbG9hZEpTXG4qIFZpc2l0IGh0dHA6Ly9jcmVhdGVqcy5jb20vIGZvciBkb2N1bWVudGF0aW9uLCB1cGRhdGVzIGFuZCBleGFtcGxlcy5cbipcbiogQ29weXJpZ2h0IChjKSAyMDEwIGdza2lubmVyLmNvbSwgaW5jLlxuKlxuKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4qIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4qIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuKiBjb25kaXRpb25zOlxuKlxuKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbipcbiogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4qIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4qIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4qIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyB2ZXJzaW9uLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIFN0YXRpYyBjbGFzcyBob2xkaW5nIGxpYnJhcnkgc3BlY2lmaWMgaW5mb3JtYXRpb24gc3VjaCBhcyB0aGUgdmVyc2lvbiBhbmQgYnVpbGREYXRlIG9mIHRoZSBsaWJyYXJ5LlxuXHQgKiBAY2xhc3MgUHJlbG9hZEpTXG5cdCAqKi9cblx0dmFyIHMgPSBjcmVhdGVqcy5QcmVsb2FkSlMgPSBjcmVhdGVqcy5QcmVsb2FkSlMgfHwge307XG5cblx0LyoqXG5cdCAqIFRoZSB2ZXJzaW9uIHN0cmluZyBmb3IgdGhpcyByZWxlYXNlLlxuXHQgKiBAcHJvcGVydHkgdmVyc2lvblxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy52ZXJzaW9uID0gLyo9dmVyc2lvbiovXCIwLjYuMVwiOyAvLyBpbmplY3RlZCBieSBidWlsZCBwcm9jZXNzXG5cblx0LyoqXG5cdCAqIFRoZSBidWlsZCBkYXRlIGZvciB0aGlzIHJlbGVhc2UgaW4gVVRDIGZvcm1hdC5cblx0ICogQHByb3BlcnR5IGJ1aWxkRGF0ZVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy5idWlsZERhdGUgPSAvKj1kYXRlKi9cIlRodSwgMjEgTWF5IDIwMTUgMTY6MTc6MzcgR01UXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxufSkoKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIGV4dGVuZC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuXG4vKipcbiAqIFNldHMgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiBhbmQgY29uc3RydWN0b3IgcHJvcGVydHkgZm9yIGEgbmV3IGNsYXNzLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCByaWdodCBhZnRlciBjcmVhdGluZyB0aGUgY2xhc3MgY29uc3RydWN0b3IuXG4gKlxuICogXHRmdW5jdGlvbiBNeVN1YkNsYXNzKCkge31cbiAqIFx0Y3JlYXRlanMuZXh0ZW5kKE15U3ViQ2xhc3MsIE15U3VwZXJDbGFzcyk7XG4gKiBcdENsYXNzQi5wcm90b3R5cGUuZG9Tb21ldGhpbmcgPSBmdW5jdGlvbigpIHsgfVxuICpcbiAqIFx0dmFyIGZvbyA9IG5ldyBNeVN1YkNsYXNzKCk7XG4gKiBcdGNvbnNvbGUubG9nKGZvbyBpbnN0YW5jZW9mIE15U3VwZXJDbGFzcyk7IC8vIHRydWVcbiAqIFx0Y29uc29sZS5sb2coZm9vLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9PT0gTXlTdWJDbGFzcyk7IC8vIHRydWVcbiAqXG4gKiBAbWV0aG9kIGV4dGVuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ViY2xhc3MgVGhlIHN1YmNsYXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJjbGFzcyBUaGUgc3VwZXJjbGFzcyB0byBleHRlbmQuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgc3ViY2xhc3MncyBuZXcgcHJvdG90eXBlLlxuICovXG5jcmVhdGVqcy5leHRlbmQgPSBmdW5jdGlvbihzdWJjbGFzcywgc3VwZXJjbGFzcykge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRmdW5jdGlvbiBvKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gc3ViY2xhc3M7IH1cblx0by5wcm90b3R5cGUgPSBzdXBlcmNsYXNzLnByb3RvdHlwZTtcblx0cmV0dXJuIChzdWJjbGFzcy5wcm90b3R5cGUgPSBuZXcgbygpKTtcbn07XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBwcm9tb3RlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbi8qKlxuICogUHJvbW90ZXMgYW55IG1ldGhvZHMgb24gdGhlIHN1cGVyIGNsYXNzIHRoYXQgd2VyZSBvdmVycmlkZGVuLCBieSBjcmVhdGluZyBhbiBhbGlhcyBpbiB0aGUgZm9ybWF0IGBwcmVmaXhfbWV0aG9kTmFtZWAuXG4gKiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgdGhlIHN1cGVyIGNsYXNzJ3MgbmFtZSBhcyB0aGUgcHJlZml4LlxuICogQW4gYWxpYXMgdG8gdGhlIHN1cGVyIGNsYXNzJ3MgY29uc3RydWN0b3IgaXMgYWx3YXlzIGFkZGVkIGluIHRoZSBmb3JtYXQgYHByZWZpeF9jb25zdHJ1Y3RvcmAuXG4gKiBUaGlzIGFsbG93cyB0aGUgc3ViY2xhc3MgdG8gY2FsbCBzdXBlciBjbGFzcyBtZXRob2RzIHdpdGhvdXQgdXNpbmcgYGZ1bmN0aW9uLmNhbGxgLCBwcm92aWRpbmcgYmV0dGVyIHBlcmZvcm1hbmNlLlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiBgTXlTdWJDbGFzc2AgZXh0ZW5kcyBgTXlTdXBlckNsYXNzYCwgYW5kIGJvdGggZGVmaW5lIGEgYGRyYXdgIG1ldGhvZCwgdGhlbiBjYWxsaW5nIGBwcm9tb3RlKE15U3ViQ2xhc3MsIFwiTXlTdXBlckNsYXNzXCIpYFxuICogd291bGQgYWRkIGEgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAgbWV0aG9kIHRvIE15U3ViQ2xhc3MgYW5kIHByb21vdGUgdGhlIGBkcmF3YCBtZXRob2Qgb24gYE15U3VwZXJDbGFzc2AgdG8gdGhlXG4gKiBwcm90b3R5cGUgb2YgYE15U3ViQ2xhc3NgIGFzIGBNeVN1cGVyQ2xhc3NfZHJhd2AuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoZSBjbGFzcydzIHByb3RvdHlwZSBpcyBmdWxseSBkZWZpbmVkLlxuICpcbiAqIFx0ZnVuY3Rpb24gQ2xhc3NBKG5hbWUpIHtcbiAqIFx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuICogXHR9XG4gKiBcdENsYXNzQS5wcm90b3R5cGUuZ3JlZXQgPSBmdW5jdGlvbigpIHtcbiAqIFx0XHRyZXR1cm4gXCJIZWxsbyBcIit0aGlzLm5hbWU7XG4gKiBcdH1cbiAqXG4gKiBcdGZ1bmN0aW9uIENsYXNzQihuYW1lLCBwdW5jdHVhdGlvbikge1xuICogXHRcdHRoaXMuQ2xhc3NBX2NvbnN0cnVjdG9yKG5hbWUpO1xuICogXHRcdHRoaXMucHVuY3R1YXRpb24gPSBwdW5jdHVhdGlvbjtcbiAqIFx0fVxuICogXHRjcmVhdGVqcy5leHRlbmQoQ2xhc3NCLCBDbGFzc0EpO1xuICogXHRDbGFzc0IucHJvdG90eXBlLmdyZWV0ID0gZnVuY3Rpb24oKSB7XG4gKiBcdFx0cmV0dXJuIHRoaXMuQ2xhc3NBX2dyZWV0KCkrdGhpcy5wdW5jdHVhdGlvbjtcbiAqIFx0fVxuICogXHRjcmVhdGVqcy5wcm9tb3RlKENsYXNzQiwgXCJDbGFzc0FcIik7XG4gKlxuICogXHR2YXIgZm9vID0gbmV3IENsYXNzQihcIldvcmxkXCIsIFwiIT8hXCIpO1xuICogXHRjb25zb2xlLmxvZyhmb28uZ3JlZXQoKSk7IC8vIEhlbGxvIFdvcmxkIT8hXG4gKlxuICogQG1ldGhvZCBwcm9tb3RlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJjbGFzcyBUaGUgY2xhc3MgdG8gcHJvbW90ZSBzdXBlciBjbGFzcyBtZXRob2RzIG9uLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBUaGUgcHJlZml4IHRvIGFkZCB0byB0aGUgcHJvbW90ZWQgbWV0aG9kIG5hbWVzLiBVc3VhbGx5IHRoZSBuYW1lIG9mIHRoZSBzdXBlcmNsYXNzLlxuICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgdGhlIHN1YmNsYXNzLlxuICovXG5jcmVhdGVqcy5wcm9tb3RlID0gZnVuY3Rpb24oc3ViY2xhc3MsIHByZWZpeCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHR2YXIgc3ViUCA9IHN1YmNsYXNzLnByb3RvdHlwZSwgc3VwUCA9IChPYmplY3QuZ2V0UHJvdG90eXBlT2YmJk9iamVjdC5nZXRQcm90b3R5cGVPZihzdWJQKSl8fHN1YlAuX19wcm90b19fO1xuXHRpZiAoc3VwUCkge1xuXHRcdHN1YlBbKHByZWZpeCs9XCJfXCIpICsgXCJjb25zdHJ1Y3RvclwiXSA9IHN1cFAuY29uc3RydWN0b3I7IC8vIGNvbnN0cnVjdG9yIGlzIG5vdCBhbHdheXMgaW5udW1lcmFibGVcblx0XHRmb3IgKHZhciBuIGluIHN1cFApIHtcblx0XHRcdGlmIChzdWJQLmhhc093blByb3BlcnR5KG4pICYmICh0eXBlb2Ygc3VwUFtuXSA9PSBcImZ1bmN0aW9uXCIpKSB7IHN1YlBbcHJlZml4ICsgbl0gPSBzdXBQW25dOyB9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBzdWJjbGFzcztcbn07XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBpbmRleE9mLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBzcGVjaWZpZWQgdmFsdWUgc2VhcmNoRWxlbWVudCBpbiB0aGUgcGFzc2VkIGluIGFycmF5LCBhbmQgcmV0dXJucyB0aGUgaW5kZXggb2ZcbiAqIHRoYXQgdmFsdWUuICBSZXR1cm5zIC0xIGlmIHZhbHVlIGlzIG5vdCBmb3VuZC5cbiAqXG4gKiAgICAgIHZhciBpID0gY3JlYXRlanMuaW5kZXhPZihteUFycmF5LCBteUVsZW1lbnRUb0ZpbmQpO1xuICpcbiAqIEBtZXRob2QgaW5kZXhPZlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgQXJyYXkgdG8gc2VhcmNoIGZvciBzZWFyY2hFbGVtZW50XG4gKiBAcGFyYW0gc2VhcmNoRWxlbWVudCBFbGVtZW50IHRvIGZpbmQgaW4gYXJyYXkuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBmaXJzdCBpbmRleCBvZiBzZWFyY2hFbGVtZW50IGluIGFycmF5LlxuICovXG5jcmVhdGVqcy5pbmRleE9mID0gZnVuY3Rpb24gKGFycmF5LCBzZWFyY2hFbGVtZW50KXtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Zm9yICh2YXIgaSA9IDAsbD1hcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRpZiAoc2VhcmNoRWxlbWVudCA9PT0gYXJyYXlbaV0pIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59O1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gcHJveHkuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuLyoqXG4gKiBWYXJpb3VzIHV0aWxpdGllcyB0aGF0IHRoZSBDcmVhdGVKUyBTdWl0ZSB1c2VzLiBVdGlsaXRpZXMgYXJlIGNyZWF0ZWQgYXMgc2VwYXJhdGUgZmlsZXMsIGFuZCB3aWxsIGJlIGF2YWlsYWJsZSBvbiB0aGVcbiAqIGNyZWF0ZWpzIG5hbWVzcGFjZSBkaXJlY3RseS5cbiAqXG4gKiA8aDQ+RXhhbXBsZTwvaDQ+XG4gKlxuICogICAgICBteU9iamVjdC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGNyZWF0ZWpzLnByb3h5KG15TWV0aG9kLCBzY29wZSkpO1xuICpcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqIEBtYWluIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIEEgZnVuY3Rpb24gcHJveHkgZm9yIG1ldGhvZHMuIEJ5IGRlZmF1bHQsIEphdmFTY3JpcHQgbWV0aG9kcyBkbyBub3QgbWFpbnRhaW4gc2NvcGUsIHNvIHBhc3NpbmcgYSBtZXRob2QgYXMgYVxuXHQgKiBjYWxsYmFjayB3aWxsIHJlc3VsdCBpbiB0aGUgbWV0aG9kIGdldHRpbmcgY2FsbGVkIGluIHRoZSBzY29wZSBvZiB0aGUgY2FsbGVyLiBVc2luZyBhIHByb3h5IGVuc3VyZXMgdGhhdCB0aGVcblx0ICogbWV0aG9kIGdldHMgY2FsbGVkIGluIHRoZSBjb3JyZWN0IHNjb3BlLlxuXHQgKlxuXHQgKiBBZGRpdGlvbmFsIGFyZ3VtZW50cyBjYW4gYmUgcGFzc2VkIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBmdW5jdGlvbiB3aGVuIGl0IGlzIGNhbGxlZC5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIG15T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJldmVudFwiLCBjcmVhdGVqcy5wcm94eShteUhhbmRsZXIsIHRoaXMsIGFyZzEsIGFyZzIpKTtcblx0ICpcblx0ICogICAgICBmdW5jdGlvbiBteUhhbmRsZXIoYXJnMSwgYXJnMikge1xuXHQgKiAgICAgICAgICAgLy8gVGhpcyBnZXRzIGNhbGxlZCB3aGVuIG15T2JqZWN0Lm15Q2FsbGJhY2sgaXMgZXhlY3V0ZWQuXG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBAbWV0aG9kIHByb3h5XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBUaGUgZnVuY3Rpb24gdG8gY2FsbFxuXHQgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgVGhlIHNjb3BlIHRvIGNhbGwgdGhlIG1ldGhvZCBuYW1lIG9uXG5cdCAqIEBwYXJhbSB7bWl4ZWR9IFthcmddICogQXJndW1lbnRzIHRoYXQgYXJlIGFwcGVuZGVkIHRvIHRoZSBjYWxsYmFjayBmb3IgYWRkaXRpb25hbCBwYXJhbXMuXG5cdCAqIEBwdWJsaWNcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0Y3JlYXRlanMucHJveHkgPSBmdW5jdGlvbiAobWV0aG9kLCBzY29wZSkge1xuXHRcdHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBtZXRob2QuYXBwbHkoc2NvcGUsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkuY29uY2F0KGFBcmdzKSk7XG5cdFx0fTtcblx0fVxuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQnJvd3NlckRldGVjdC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogQW4gb2JqZWN0IHRoYXQgZGV0ZXJtaW5lcyB0aGUgY3VycmVudCBicm93c2VyLCB2ZXJzaW9uLCBvcGVyYXRpbmcgc3lzdGVtLCBhbmQgb3RoZXIgZW52aXJvbm1lbnRcblx0ICogdmFyaWFibGVzIHZpYSB1c2VyIGFnZW50IHN0cmluZy5cblx0ICpcblx0ICogVXNlZCBmb3IgYXVkaW8gYmVjYXVzZSBmZWF0dXJlIGRldGVjdGlvbiBpcyB1bmFibGUgdG8gZGV0ZWN0IHRoZSBtYW55IGxpbWl0YXRpb25zIG9mIG1vYmlsZSBkZXZpY2VzLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgaWYgKGNyZWF0ZWpzLkJyb3dzZXJEZXRlY3QuaXNJT1MpIHsgLy8gZG8gc3R1ZmYgfVxuXHQgKlxuXHQgKiBAcHJvcGVydHkgQnJvd3NlckRldGVjdFxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRmlyZWZveCBUcnVlIGlmIG91ciBicm93c2VyIGlzIEZpcmVmb3guXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPcGVyYSBUcnVlIGlmIG91ciBicm93c2VyIGlzIG9wZXJhLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQ2hyb21lIFRydWUgaWYgb3VyIGJyb3dzZXIgaXMgQ2hyb21lLiAgTm90ZSB0aGF0IENocm9tZSBmb3IgQW5kcm9pZCByZXR1cm5zIHRydWUsIGJ1dCBpcyBhXG5cdCAqIGNvbXBsZXRlbHkgZGlmZmVyZW50IGJyb3dzZXIgd2l0aCBkaWZmZXJlbnQgYWJpbGl0aWVzLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzSU9TIFRydWUgaWYgb3VyIGJyb3dzZXIgaXMgc2FmYXJpIGZvciBpT1MgZGV2aWNlcyAoaVBhZCwgaVBob25lLCBhbmQgaVBvZCkuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNBbmRyb2lkIFRydWUgaWYgb3VyIGJyb3dzZXIgaXMgQW5kcm9pZC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0JsYWNrYmVycnkgVHJ1ZSBpZiBvdXIgYnJvd3NlciBpcyBCbGFja2JlcnJ5LlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0ZnVuY3Rpb24gQnJvd3NlckRldGVjdCgpIHtcblx0XHR0aHJvdyBcIkJyb3dzZXJEZXRlY3QgY2Fubm90IGJlIGluc3RhbnRpYXRlZFwiO1xuXHR9XG5cblx0dmFyIGFnZW50ID0gQnJvd3NlckRldGVjdC5hZ2VudCA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXHRCcm93c2VyRGV0ZWN0LmlzV2luZG93UGhvbmUgPSAoYWdlbnQuaW5kZXhPZihcIklFTW9iaWxlXCIpID4gLTEpIHx8IChhZ2VudC5pbmRleE9mKFwiV2luZG93cyBQaG9uZVwiKSA+IC0xKTtcblx0QnJvd3NlckRldGVjdC5pc0ZpcmVmb3ggPSAoYWdlbnQuaW5kZXhPZihcIkZpcmVmb3hcIikgPiAtMSk7XG5cdEJyb3dzZXJEZXRlY3QuaXNPcGVyYSA9ICh3aW5kb3cub3BlcmEgIT0gbnVsbCk7XG5cdEJyb3dzZXJEZXRlY3QuaXNDaHJvbWUgPSAoYWdlbnQuaW5kZXhPZihcIkNocm9tZVwiKSA+IC0xKTsgIC8vIE5PVEUgdGhhdCBDaHJvbWUgb24gQW5kcm9pZCByZXR1cm5zIHRydWUgYnV0IGlzIGEgY29tcGxldGVseSBkaWZmZXJlbnQgYnJvd3NlciB3aXRoIGRpZmZlcmVudCBhYmlsaXRpZXNcblx0QnJvd3NlckRldGVjdC5pc0lPUyA9IChhZ2VudC5pbmRleE9mKFwiaVBvZFwiKSA+IC0xIHx8IGFnZW50LmluZGV4T2YoXCJpUGhvbmVcIikgPiAtMSB8fCBhZ2VudC5pbmRleE9mKFwiaVBhZFwiKSA+IC0xKSAmJiAhQnJvd3NlckRldGVjdC5pc1dpbmRvd1Bob25lO1xuXHRCcm93c2VyRGV0ZWN0LmlzQW5kcm9pZCA9IChhZ2VudC5pbmRleE9mKFwiQW5kcm9pZFwiKSA+IC0xKSAmJiAhQnJvd3NlckRldGVjdC5pc1dpbmRvd1Bob25lO1xuXHRCcm93c2VyRGV0ZWN0LmlzQmxhY2tiZXJyeSA9IChhZ2VudC5pbmRleE9mKFwiQmxhY2tiZXJyeVwiKSA+IC0xKTtcblxuXHRjcmVhdGVqcy5Ccm93c2VyRGV0ZWN0ID0gQnJvd3NlckRldGVjdDtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEV2ZW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQ29udGFpbnMgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBzaGFyZWQgYnkgYWxsIGV2ZW50cyBmb3IgdXNlIHdpdGhcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBcblx0ICogTm90ZSB0aGF0IEV2ZW50IG9iamVjdHMgYXJlIG9mdGVuIHJldXNlZCwgc28geW91IHNob3VsZCBuZXZlclxuXHQgKiByZWx5IG9uIGFuIGV2ZW50IG9iamVjdCdzIHN0YXRlIG91dHNpZGUgb2YgdGhlIGNhbGwgc3RhY2sgaXQgd2FzIHJlY2VpdmVkIGluLlxuXHQgKiBAY2xhc3MgRXZlbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYnViYmxlcyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZXZlbnQgd2lsbCBidWJibGUgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNhbmNlbGFibGUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mIHRoaXMgZXZlbnQgY2FuIGJlIGNhbmNlbGxlZC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gRXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSkge1xuXHRcdFxuXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IHR5cGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiovXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIG9iamVjdCB0aGF0IGdlbmVyYXRlZCBhbiBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgdGFyZ2V0XG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy50YXJnZXQgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY3VycmVudCB0YXJnZXQgdGhhdCBhIGJ1YmJsaW5nIGV2ZW50IGlzIGJlaW5nIGRpc3BhdGNoZWQgZnJvbS4gRm9yIG5vbi1idWJibGluZyBldmVudHMsIHRoaXMgd2lsbFxuXHRcdCAqIGFsd2F5cyBiZSB0aGUgc2FtZSBhcyB0YXJnZXQuIEZvciBleGFtcGxlLCBpZiBjaGlsZE9iai5wYXJlbnQgPSBwYXJlbnRPYmosIGFuZCBhIGJ1YmJsaW5nIGV2ZW50XG5cdFx0ICogaXMgZ2VuZXJhdGVkIGZyb20gY2hpbGRPYmosIHRoZW4gYSBsaXN0ZW5lciBvbiBwYXJlbnRPYmogd291bGQgcmVjZWl2ZSB0aGUgZXZlbnQgd2l0aFxuXHRcdCAqIHRhcmdldD1jaGlsZE9iaiAodGhlIG9yaWdpbmFsIHRhcmdldCkgYW5kIGN1cnJlbnRUYXJnZXQ9cGFyZW50T2JqICh3aGVyZSB0aGUgbGlzdGVuZXIgd2FzIGFkZGVkKS5cblx0XHQgKiBAcHJvcGVydHkgY3VycmVudFRhcmdldFxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZvciBidWJibGluZyBldmVudHMsIHRoaXMgaW5kaWNhdGVzIHRoZSBjdXJyZW50IGV2ZW50IHBoYXNlOjxPTD5cblx0XHQgKiBcdDxMST4gY2FwdHVyZSBwaGFzZTogc3RhcnRpbmcgZnJvbSB0aGUgdG9wIHBhcmVudCB0byB0aGUgdGFyZ2V0PC9MST5cblx0XHQgKiBcdDxMST4gYXQgdGFyZ2V0IHBoYXNlOiBjdXJyZW50bHkgYmVpbmcgZGlzcGF0Y2hlZCBmcm9tIHRoZSB0YXJnZXQ8L0xJPlxuXHRcdCAqIFx0PExJPiBidWJibGluZyBwaGFzZTogZnJvbSB0aGUgdGFyZ2V0IHRvIHRoZSB0b3AgcGFyZW50PC9MST5cblx0XHQgKiA8L09MPlxuXHRcdCAqIEBwcm9wZXJ0eSBldmVudFBoYXNlXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5ldmVudFBoYXNlID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IHdpbGwgYnViYmxlIHRocm91Z2ggdGhlIGRpc3BsYXkgbGlzdC5cblx0XHQgKiBAcHJvcGVydHkgYnViYmxlc1xuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5idWJibGVzID0gISFidWJibGVzO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdGhpcyBldmVudCBjYW4gYmUgY2FuY2VsbGVkIHZpYVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50L3ByZXZlbnREZWZhdWx0XCJ9fXt7L2Nyb3NzTGlua319LiBUaGlzIGlzIHNldCB2aWEgdGhlIEV2ZW50IGNvbnN0cnVjdG9yLlxuXHRcdCAqIEBwcm9wZXJ0eSBjYW5jZWxhYmxlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmNhbmNlbGFibGUgPSAhIWNhbmNlbGFibGU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBlcG9jaCB0aW1lIGF0IHdoaWNoIHRoaXMgZXZlbnQgd2FzIGNyZWF0ZWQuXG5cdFx0ICogQHByb3BlcnR5IHRpbWVTdGFtcFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMudGltZVN0YW1wID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHt7I2Nyb3NzTGluayBcIkV2ZW50L3ByZXZlbnREZWZhdWx0XCJ9fXt7L2Nyb3NzTGlua319IGhhcyBiZWVuIGNhbGxlZFxuXHRcdCAqIG9uIHRoaXMgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IGRlZmF1bHRQcmV2ZW50ZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYge3sjY3Jvc3NMaW5rIFwiRXZlbnQvc3RvcFByb3BhZ2F0aW9uXCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXCJ9fXt7L2Nyb3NzTGlua319IGhhcyBiZWVuIGNhbGxlZCBvbiB0aGlzIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBwcm9wYWdhdGlvblN0b3BwZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkXG5cdFx0ICogb24gdGhpcyBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9yZW1vdmVcIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkIG9uIHRoaXMgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IHJlbW92ZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMucmVtb3ZlZCA9IGZhbHNlO1xuXHR9XG5cdHZhciBwID0gRXZlbnQucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblx0XG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogU2V0cyB7eyNjcm9zc0xpbmsgXCJFdmVudC9kZWZhdWx0UHJldmVudGVkXCJ9fXt7L2Nyb3NzTGlua319IHRvIHRydWUuXG5cdCAqIE1pcnJvcnMgdGhlIERPTSBldmVudCBzdGFuZGFyZC5cblx0ICogQG1ldGhvZCBwcmV2ZW50RGVmYXVsdFxuXHQgKiovXG5cdHAucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0aGlzLmNhbmNlbGFibGUmJnRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcHJvcGFnYXRpb25TdG9wcGVkXCJ9fXt7L2Nyb3NzTGlua319IHRvIHRydWUuXG5cdCAqIE1pcnJvcnMgdGhlIERPTSBldmVudCBzdGFuZGFyZC5cblx0ICogQG1ldGhvZCBzdG9wUHJvcGFnYXRpb25cblx0ICoqL1xuXHRwLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB7eyNjcm9zc0xpbmsgXCJFdmVudC9wcm9wYWdhdGlvblN0b3BwZWRcIn19e3svY3Jvc3NMaW5rfX0gYW5kXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50L2ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZFwifX17ey9jcm9zc0xpbmt9fSB0byB0cnVlLlxuXHQgKiBNaXJyb3JzIHRoZSBET00gZXZlbnQgc3RhbmRhcmQuXG5cdCAqIEBtZXRob2Qgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXG5cdCAqKi9cblx0cC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDYXVzZXMgdGhlIGFjdGl2ZSBsaXN0ZW5lciB0byBiZSByZW1vdmVkIHZpYSByZW1vdmVFdmVudExpc3RlbmVyKCk7XG5cdCAqIFxuXHQgKiBcdFx0bXlCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2dCkge1xuXHQgKiBcdFx0XHQvLyBkbyBzdHVmZi4uLlxuXHQgKiBcdFx0XHRldnQucmVtb3ZlKCk7IC8vIHJlbW92ZXMgdGhpcyBsaXN0ZW5lci5cblx0ICogXHRcdH0pO1xuXHQgKiBcblx0ICogQG1ldGhvZCByZW1vdmVcblx0ICoqL1xuXHRwLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVtb3ZlZCA9IHRydWU7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBFdmVudCBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtFdmVudH0gYSBjbG9uZSBvZiB0aGUgRXZlbnQgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgRXZlbnQodGhpcy50eXBlLCB0aGlzLmJ1YmJsZXMsIHRoaXMuY2FuY2VsYWJsZSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUHJvdmlkZXMgYSBjaGFpbmFibGUgc2hvcnRjdXQgbWV0aG9kIGZvciBzZXR0aW5nIGEgbnVtYmVyIG9mIHByb3BlcnRpZXMgb24gdGhlIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHNldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQSBnZW5lcmljIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gY29weSB0byB0aGUgaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4ge0V2ZW50fSBSZXR1cm5zIHRoZSBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5zZXQgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdGZvciAodmFyIG4gaW4gcHJvcHMpIHsgdGhpc1tuXSA9IHByb3BzW25dOyB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltFdmVudCAodHlwZT1cIit0aGlzLnR5cGUrXCIpXVwiO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkV2ZW50ID0gRXZlbnQ7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRXJyb3JFdmVudC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyYWwgZXJyb3Ige3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0sIHRoYXQgZGVzY3JpYmVzIGFuIGVycm9yIHRoYXQgb2NjdXJyZWQsIGFzIHdlbGwgYXMgYW55IGRldGFpbHMuXG5cdCAqIEBjbGFzcyBFcnJvckV2ZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbdGl0bGVdIFRoZSBlcnJvciB0aXRsZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIFRoZSBlcnJvciBkZXNjcmlwdGlvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIEFkZGl0aW9uYWwgZXJyb3IgZGF0YVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEVycm9yRXZlbnQodGl0bGUsIG1lc3NhZ2UsIGRhdGEpIHtcblx0XHR0aGlzLkV2ZW50X2NvbnN0cnVjdG9yKFwiZXJyb3JcIik7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgc2hvcnQgZXJyb3IgdGl0bGUsIHdoaWNoIGluZGljYXRlcyB0aGUgdHlwZSBvZiBlcnJvciB0aGF0IG9jY3VycmVkLlxuXHRcdCAqIEBwcm9wZXJ0eSB0aXRsZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdHRoaXMudGl0bGUgPSB0aXRsZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB2ZXJib3NlIGVycm9yIG1lc3NhZ2UsIGNvbnRhaW5pbmcgZGV0YWlscyBhYm91dCB0aGUgZXJyb3IuXG5cdFx0ICogQHByb3BlcnR5IG1lc3NhZ2Vcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXG5cdFx0LyoqXG5cdFx0ICogQWRkaXRpb25hbCBkYXRhIGF0dGFjaGVkIHRvIGFuIGVycm9yLlxuXHRcdCAqIEBwcm9wZXJ0eSBkYXRhXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLmRhdGEgPSBkYXRhO1xuXHR9XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoRXJyb3JFdmVudCwgY3JlYXRlanMuRXZlbnQpO1xuXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQodGhpcy50aXRsZSwgdGhpcy5tZXNzYWdlLCB0aGlzLmRhdGEpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkVycm9yRXZlbnQgPSBjcmVhdGVqcy5wcm9tb3RlKEVycm9yRXZlbnQsIFwiRXZlbnRcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBFdmVudERpc3BhdGNoZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG4vLyBjb25zdHJ1Y3RvcjpcclxuXHQvKipcclxuXHQgKiBFdmVudERpc3BhdGNoZXIgcHJvdmlkZXMgbWV0aG9kcyBmb3IgbWFuYWdpbmcgcXVldWVzIG9mIGV2ZW50IGxpc3RlbmVycyBhbmQgZGlzcGF0Y2hpbmcgZXZlbnRzLlxyXG5cdCAqXHJcblx0ICogWW91IGNhbiBlaXRoZXIgZXh0ZW5kIEV2ZW50RGlzcGF0Y2hlciBvciBtaXggaXRzIG1ldGhvZHMgaW50byBhbiBleGlzdGluZyBwcm90b3R5cGUgb3IgaW5zdGFuY2UgYnkgdXNpbmcgdGhlXHJcblx0ICogRXZlbnREaXNwYXRjaGVyIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9pbml0aWFsaXplXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cclxuXHQgKiBcclxuXHQgKiBUb2dldGhlciB3aXRoIHRoZSBDcmVhdGVKUyBFdmVudCBjbGFzcywgRXZlbnREaXNwYXRjaGVyIHByb3ZpZGVzIGFuIGV4dGVuZGVkIGV2ZW50IG1vZGVsIHRoYXQgaXMgYmFzZWQgb24gdGhlXHJcblx0ICogRE9NIExldmVsIDIgZXZlbnQgbW9kZWwsIGluY2x1ZGluZyBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyLCBhbmQgZGlzcGF0Y2hFdmVudC4gSXQgc3VwcG9ydHNcclxuXHQgKiBidWJibGluZyAvIGNhcHR1cmUsIHByZXZlbnREZWZhdWx0LCBzdG9wUHJvcGFnYXRpb24sIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiwgYW5kIGhhbmRsZUV2ZW50LlxyXG5cdCAqIFxyXG5cdCAqIEV2ZW50RGlzcGF0Y2hlciBhbHNvIGV4cG9zZXMgYSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvb25cIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLCB3aGljaCBtYWtlcyBpdCBlYXNpZXJcclxuXHQgKiB0byBjcmVhdGUgc2NvcGVkIGxpc3RlbmVycywgbGlzdGVuZXJzIHRoYXQgb25seSBydW4gb25jZSwgYW5kIGxpc3RlbmVycyB3aXRoIGFzc29jaWF0ZWQgYXJiaXRyYXJ5IGRhdGEuIFRoZSBcclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvb2ZmXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCBpcyBtZXJlbHkgYW4gYWxpYXMgdG9cclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvcmVtb3ZlRXZlbnRMaXN0ZW5lclwifX17ey9jcm9zc0xpbmt9fS5cclxuXHQgKiBcclxuXHQgKiBBbm90aGVyIGFkZGl0aW9uIHRvIHRoZSBET00gTGV2ZWwgMiBtb2RlbCBpcyB0aGUge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL3JlbW92ZUFsbEV2ZW50TGlzdGVuZXJzXCJ9fXt7L2Nyb3NzTGlua319XHJcblx0ICogbWV0aG9kLCB3aGljaCBjYW4gYmUgdXNlZCB0byBsaXN0ZW5lcnMgZm9yIGFsbCBldmVudHMsIG9yIGxpc3RlbmVycyBmb3IgYSBzcGVjaWZpYyBldmVudC4gVGhlIEV2ZW50IG9iamVjdCBhbHNvIFxyXG5cdCAqIGluY2x1ZGVzIGEge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcmVtb3ZlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCB3aGljaCByZW1vdmVzIHRoZSBhY3RpdmUgbGlzdGVuZXIuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICogQWRkIEV2ZW50RGlzcGF0Y2hlciBjYXBhYmlsaXRpZXMgdG8gdGhlIFwiTXlDbGFzc1wiIGNsYXNzLlxyXG5cdCAqXHJcblx0ICogICAgICBFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShNeUNsYXNzLnByb3RvdHlwZSk7XHJcblx0ICpcclxuXHQgKiBBZGQgYW4gZXZlbnQgKHNlZSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvYWRkRXZlbnRMaXN0ZW5lclwifX17ey9jcm9zc0xpbmt9fSkuXHJcblx0ICpcclxuXHQgKiAgICAgIGluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJldmVudE5hbWVcIiwgaGFuZGxlck1ldGhvZCk7XHJcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVyTWV0aG9kKGV2ZW50KSB7XHJcblx0ICogICAgICAgICAgY29uc29sZS5sb2coZXZlbnQudGFyZ2V0ICsgXCIgV2FzIENsaWNrZWRcIik7XHJcblx0ICogICAgICB9XHJcblx0ICpcclxuXHQgKiA8Yj5NYWludGFpbmluZyBwcm9wZXIgc2NvcGU8L2I+PGJyIC8+XHJcblx0ICogU2NvcGUgKGllLiBcInRoaXNcIikgY2FuIGJlIGJlIGEgY2hhbGxlbmdlIHdpdGggZXZlbnRzLiBVc2luZyB0aGUge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL29uXCJ9fXt7L2Nyb3NzTGlua319XHJcblx0ICogbWV0aG9kIHRvIHN1YnNjcmliZSB0byBldmVudHMgc2ltcGxpZmllcyB0aGlzLlxyXG5cdCAqXHJcblx0ICogICAgICBpbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuXHQgKiAgICAgICAgICBjb25zb2xlLmxvZyhpbnN0YW5jZSA9PSB0aGlzKTsgLy8gZmFsc2UsIHNjb3BlIGlzIGFtYmlndW91cy5cclxuXHQgKiAgICAgIH0pO1xyXG5cdCAqICAgICAgXHJcblx0ICogICAgICBpbnN0YW5jZS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0ICogICAgICAgICAgY29uc29sZS5sb2coaW5zdGFuY2UgPT0gdGhpcyk7IC8vIHRydWUsIFwib25cIiB1c2VzIGRpc3BhdGNoZXIgc2NvcGUgYnkgZGVmYXVsdC5cclxuXHQgKiAgICAgIH0pO1xyXG5cdCAqIFxyXG5cdCAqIElmIHlvdSB3YW50IHRvIHVzZSBhZGRFdmVudExpc3RlbmVyIGluc3RlYWQsIHlvdSBtYXkgd2FudCB0byB1c2UgZnVuY3Rpb24uYmluZCgpIG9yIGEgc2ltaWxhciBwcm94eSB0byBtYW5hZ2Ugc2NvcGUuXHJcblx0ICogICAgICBcclxuXHQgKlxyXG5cdCAqIEBjbGFzcyBFdmVudERpc3BhdGNoZXJcclxuXHQgKiBAY29uc3RydWN0b3JcclxuXHQgKiovXHJcblx0ZnVuY3Rpb24gRXZlbnREaXNwYXRjaGVyKCkge1xyXG5cdFxyXG5cdFxyXG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcclxuXHRcdC8qKlxyXG5cdFx0ICogQHByb3RlY3RlZFxyXG5cdFx0ICogQHByb3BlcnR5IF9saXN0ZW5lcnNcclxuXHRcdCAqIEB0eXBlIE9iamVjdFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5fbGlzdGVuZXJzID0gbnVsbDtcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAcHJvcGVydHkgX2NhcHR1cmVMaXN0ZW5lcnNcclxuXHRcdCAqIEB0eXBlIE9iamVjdFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5fY2FwdHVyZUxpc3RlbmVycyA9IG51bGw7XHJcblx0fVxyXG5cdHZhciBwID0gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZTtcclxuXHJcblx0LyoqXHJcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxyXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIGZvciBkZXRhaWxzLlxyXG5cdCAqXHJcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICogQGRlcHJlY2F0ZWRcclxuXHQgKi9cclxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cclxuXHJcblxyXG4vLyBzdGF0aWMgcHVibGljIG1ldGhvZHM6XHJcblx0LyoqXHJcblx0ICogU3RhdGljIGluaXRpYWxpemVyIHRvIG1peCBFdmVudERpc3BhdGNoZXIgbWV0aG9kcyBpbnRvIGEgdGFyZ2V0IG9iamVjdCBvciBwcm90b3R5cGUuXHJcblx0ICogXHJcblx0ICogXHRcdEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplKE15Q2xhc3MucHJvdG90eXBlKTsgLy8gYWRkIHRvIHRoZSBwcm90b3R5cGUgb2YgdGhlIGNsYXNzXHJcblx0ICogXHRcdEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplKG15T2JqZWN0KTsgLy8gYWRkIHRvIGEgc3BlY2lmaWMgaW5zdGFuY2VcclxuXHQgKiBcclxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcclxuXHQgKiBAc3RhdGljXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCB0byBpbmplY3QgRXZlbnREaXNwYXRjaGVyIG1ldGhvZHMgaW50by4gVGhpcyBjYW4gYmUgYW4gaW5zdGFuY2Ugb3IgYVxyXG5cdCAqIHByb3RvdHlwZS5cclxuXHQgKiovXHJcblx0RXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUgPSBmdW5jdGlvbih0YXJnZXQpIHtcclxuXHRcdHRhcmdldC5hZGRFdmVudExpc3RlbmVyID0gcC5hZGRFdmVudExpc3RlbmVyO1xyXG5cdFx0dGFyZ2V0Lm9uID0gcC5vbjtcclxuXHRcdHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyID0gdGFyZ2V0Lm9mZiA9ICBwLnJlbW92ZUV2ZW50TGlzdGVuZXI7XHJcblx0XHR0YXJnZXQucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMgPSBwLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzO1xyXG5cdFx0dGFyZ2V0Lmhhc0V2ZW50TGlzdGVuZXIgPSBwLmhhc0V2ZW50TGlzdGVuZXI7XHJcblx0XHR0YXJnZXQuZGlzcGF0Y2hFdmVudCA9IHAuZGlzcGF0Y2hFdmVudDtcclxuXHRcdHRhcmdldC5fZGlzcGF0Y2hFdmVudCA9IHAuX2Rpc3BhdGNoRXZlbnQ7XHJcblx0XHR0YXJnZXQud2lsbFRyaWdnZXIgPSBwLndpbGxUcmlnZ2VyO1xyXG5cdH07XHJcblx0XHJcblxyXG4vLyBwdWJsaWMgbWV0aG9kczpcclxuXHQvKipcclxuXHQgKiBBZGRzIHRoZSBzcGVjaWZpZWQgZXZlbnQgbGlzdGVuZXIuIE5vdGUgdGhhdCBhZGRpbmcgbXVsdGlwbGUgbGlzdGVuZXJzIHRvIHRoZSBzYW1lIGZ1bmN0aW9uIHdpbGwgcmVzdWx0IGluXHJcblx0ICogbXVsdGlwbGUgY2FsbGJhY2tzIGdldHRpbmcgZmlyZWQuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrKTtcclxuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XHJcblx0ICogICAgICAgICAvLyBDbGljayBoYXBwZW5lZC5cclxuXHQgKiAgICAgIH1cclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgYWRkRXZlbnRMaXN0ZW5lclxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbiB8IE9iamVjdH0gbGlzdGVuZXIgQW4gb2JqZWN0IHdpdGggYSBoYW5kbGVFdmVudCBtZXRob2QsIG9yIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuXHJcblx0ICogdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZV0gRm9yIGV2ZW50cyB0aGF0IGJ1YmJsZSwgaW5kaWNhdGVzIHdoZXRoZXIgdG8gbGlzdGVuIGZvciB0aGUgZXZlbnQgaW4gdGhlIGNhcHR1cmUgb3IgYnViYmxpbmcvdGFyZ2V0IHBoYXNlLlxyXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9uIHwgT2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0ZW5lciBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cclxuXHQgKiovXHJcblx0cC5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnM7XHJcblx0XHRpZiAodXNlQ2FwdHVyZSkge1xyXG5cdFx0XHRsaXN0ZW5lcnMgPSB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVyc3x8e307XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnN8fHt9O1xyXG5cdFx0fVxyXG5cdFx0dmFyIGFyciA9IGxpc3RlbmVyc1t0eXBlXTtcclxuXHRcdGlmIChhcnIpIHsgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTsgfVxyXG5cdFx0YXJyID0gbGlzdGVuZXJzW3R5cGVdOyAvLyByZW1vdmUgbWF5IGhhdmUgZGVsZXRlZCB0aGUgYXJyYXlcclxuXHRcdGlmICghYXJyKSB7IGxpc3RlbmVyc1t0eXBlXSA9IFtsaXN0ZW5lcl07ICB9XHJcblx0XHRlbHNlIHsgYXJyLnB1c2gobGlzdGVuZXIpOyB9XHJcblx0XHRyZXR1cm4gbGlzdGVuZXI7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBBIHNob3J0Y3V0IG1ldGhvZCBmb3IgdXNpbmcgYWRkRXZlbnRMaXN0ZW5lciB0aGF0IG1ha2VzIGl0IGVhc2llciB0byBzcGVjaWZ5IGFuIGV4ZWN1dGlvbiBzY29wZSwgaGF2ZSBhIGxpc3RlbmVyXHJcblx0ICogb25seSBydW4gb25jZSwgYXNzb2NpYXRlIGFyYml0cmFyeSBkYXRhIHdpdGggdGhlIGxpc3RlbmVyLCBhbmQgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHQgKiBcclxuXHQgKiBUaGlzIG1ldGhvZCB3b3JrcyBieSBjcmVhdGluZyBhbiBhbm9ueW1vdXMgd3JhcHBlciBmdW5jdGlvbiBhbmQgc3Vic2NyaWJpbmcgaXQgd2l0aCBhZGRFdmVudExpc3RlbmVyLlxyXG5cdCAqIFRoZSBjcmVhdGVkIGFub255bW91cyBmdW5jdGlvbiBpcyByZXR1cm5lZCBmb3IgdXNlIHdpdGggLnJlbW92ZUV2ZW50TGlzdGVuZXIgKG9yIC5vZmYpLlxyXG5cdCAqIFxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKiBcclxuXHQgKiBcdFx0dmFyIGxpc3RlbmVyID0gbXlCdG4ub24oXCJjbGlja1wiLCBoYW5kbGVDbGljaywgbnVsbCwgZmFsc2UsIHtjb3VudDozfSk7XHJcblx0ICogXHRcdGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2dCwgZGF0YSkge1xyXG5cdCAqIFx0XHRcdGRhdGEuY291bnQgLT0gMTtcclxuXHQgKiBcdFx0XHRjb25zb2xlLmxvZyh0aGlzID09IG15QnRuKTsgLy8gdHJ1ZSAtIHNjb3BlIGRlZmF1bHRzIHRvIHRoZSBkaXNwYXRjaGVyXHJcblx0ICogXHRcdFx0aWYgKGRhdGEuY291bnQgPT0gMCkge1xyXG5cdCAqIFx0XHRcdFx0YWxlcnQoXCJjbGlja2VkIDMgdGltZXMhXCIpO1xyXG5cdCAqIFx0XHRcdFx0bXlCdG4ub2ZmKFwiY2xpY2tcIiwgbGlzdGVuZXIpO1xyXG5cdCAqIFx0XHRcdFx0Ly8gYWx0ZXJuYXRlbHk6IGV2dC5yZW1vdmUoKTtcclxuXHQgKiBcdFx0XHR9XHJcblx0ICogXHRcdH1cclxuXHQgKiBcclxuXHQgKiBAbWV0aG9kIG9uXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBBbiBvYmplY3Qgd2l0aCBhIGhhbmRsZUV2ZW50IG1ldGhvZCwgb3IgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5cclxuXHQgKiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSBUaGUgc2NvcGUgdG8gZXhlY3V0ZSB0aGUgbGlzdGVuZXIgaW4uIERlZmF1bHRzIHRvIHRoZSBkaXNwYXRjaGVyL2N1cnJlbnRUYXJnZXQgZm9yIGZ1bmN0aW9uIGxpc3RlbmVycywgYW5kIHRvIHRoZSBsaXN0ZW5lciBpdHNlbGYgZm9yIG9iamVjdCBsaXN0ZW5lcnMgKGllLiB1c2luZyBoYW5kbGVFdmVudCkuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gSWYgdHJ1ZSwgdGhlIGxpc3RlbmVyIHdpbGwgcmVtb3ZlIGl0c2VsZiBhZnRlciB0aGUgZmlyc3QgdGltZSBpdCBpcyB0cmlnZ2VyZWQuXHJcblx0ICogQHBhcmFtIHsqfSBbZGF0YV0gQXJiaXRyYXJ5IGRhdGEgdGhhdCB3aWxsIGJlIGluY2x1ZGVkIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHdoZW4gdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlPWZhbHNlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXHJcblx0ICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgdGhlIGFub255bW91cyBmdW5jdGlvbiB0aGF0IHdhcyBjcmVhdGVkIGFuZCBhc3NpZ25lZCBhcyB0aGUgbGlzdGVuZXIuIFRoaXMgaXMgbmVlZGVkIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIgbGF0ZXIgdXNpbmcgLnJlbW92ZUV2ZW50TGlzdGVuZXIuXHJcblx0ICoqL1xyXG5cdHAub24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgc2NvcGUsIG9uY2UsIGRhdGEsIHVzZUNhcHR1cmUpIHtcclxuXHRcdGlmIChsaXN0ZW5lci5oYW5kbGVFdmVudCkge1xyXG5cdFx0XHRzY29wZSA9IHNjb3BlfHxsaXN0ZW5lcjtcclxuXHRcdFx0bGlzdGVuZXIgPSBsaXN0ZW5lci5oYW5kbGVFdmVudDtcclxuXHRcdH1cclxuXHRcdHNjb3BlID0gc2NvcGV8fHRoaXM7XHJcblx0XHRyZXR1cm4gdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmN0aW9uKGV2dCkge1xyXG5cdFx0XHRcdGxpc3RlbmVyLmNhbGwoc2NvcGUsIGV2dCwgZGF0YSk7XHJcblx0XHRcdFx0b25jZSYmZXZ0LnJlbW92ZSgpO1xyXG5cdFx0XHR9LCB1c2VDYXB0dXJlKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgZXZlbnQgbGlzdGVuZXIuXHJcblx0ICpcclxuXHQgKiA8Yj5JbXBvcnRhbnQgTm90ZTo8L2I+IHRoYXQgeW91IG11c3QgcGFzcyB0aGUgZXhhY3QgZnVuY3Rpb24gcmVmZXJlbmNlIHVzZWQgd2hlbiB0aGUgZXZlbnQgd2FzIGFkZGVkLiBJZiBhIHByb3h5XHJcblx0ICogZnVuY3Rpb24sIG9yIGZ1bmN0aW9uIGNsb3N1cmUgaXMgdXNlZCBhcyB0aGUgY2FsbGJhY2ssIHRoZSBwcm94eS9jbG9zdXJlIHJlZmVyZW5jZSBtdXN0IGJlIHVzZWQgLSBhIG5ldyBwcm94eSBvclxyXG5cdCAqIGNsb3N1cmUgd2lsbCBub3Qgd29yay5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gb3Igb2JqZWN0LlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdIEZvciBldmVudHMgdGhhdCBidWJibGUsIGluZGljYXRlcyB3aGV0aGVyIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50IGluIHRoZSBjYXB0dXJlIG9yIGJ1YmJsaW5nL3RhcmdldCBwaGFzZS5cclxuXHQgKiovXHJcblx0cC5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB1c2VDYXB0dXJlID8gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA6IHRoaXMuX2xpc3RlbmVycztcclxuXHRcdGlmICghbGlzdGVuZXJzKSB7IHJldHVybjsgfVxyXG5cdFx0dmFyIGFyciA9IGxpc3RlbmVyc1t0eXBlXTtcclxuXHRcdGlmICghYXJyKSB7IHJldHVybjsgfVxyXG5cdFx0Zm9yICh2YXIgaT0wLGw9YXJyLmxlbmd0aDsgaTxsOyBpKyspIHtcclxuXHRcdFx0aWYgKGFycltpXSA9PSBsaXN0ZW5lcikge1xyXG5cdFx0XHRcdGlmIChsPT0xKSB7IGRlbGV0ZShsaXN0ZW5lcnNbdHlwZV0pOyB9IC8vIGFsbG93cyBmb3IgZmFzdGVyIGNoZWNrcy5cclxuXHRcdFx0XHRlbHNlIHsgYXJyLnNwbGljZShpLDEpOyB9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEEgc2hvcnRjdXQgdG8gdGhlIHJlbW92ZUV2ZW50TGlzdGVuZXIgbWV0aG9kLCB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMgYW5kIHJldHVybiB2YWx1ZS4gVGhpcyBpcyBhIGNvbXBhbmlvbiB0byB0aGVcclxuXHQgKiAub24gbWV0aG9kLlxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBvZmZcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb24gfCBPYmplY3R9IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiBvciBvYmplY3QuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZV0gRm9yIGV2ZW50cyB0aGF0IGJ1YmJsZSwgaW5kaWNhdGVzIHdoZXRoZXIgdG8gbGlzdGVuIGZvciB0aGUgZXZlbnQgaW4gdGhlIGNhcHR1cmUgb3IgYnViYmxpbmcvdGFyZ2V0IHBoYXNlLlxyXG5cdCAqKi9cclxuXHRwLm9mZiA9IHAucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgc3BlY2lmaWVkIHR5cGUsIG9yIGFsbCBsaXN0ZW5lcnMgb2YgYWxsIHR5cGVzLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVyc1xyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5yZW1vdmVBbGxFdmVudExpc3RlbmVycygpO1xyXG5cdCAqXHJcblx0ICogICAgICAvLyBSZW1vdmUgYWxsIGNsaWNrIGxpc3RlbmVyc1xyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5yZW1vdmVBbGxFdmVudExpc3RlbmVycyhcImNsaWNrXCIpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCByZW1vdmVBbGxFdmVudExpc3RlbmVyc1xyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC4gSWYgb21pdHRlZCwgYWxsIGxpc3RlbmVycyBmb3IgYWxsIHR5cGVzIHdpbGwgYmUgcmVtb3ZlZC5cclxuXHQgKiovXHJcblx0cC5yZW1vdmVBbGxFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdGlmICghdHlwZSkgeyB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzID0gbnVsbDsgfVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGlmICh0aGlzLl9saXN0ZW5lcnMpIHsgZGVsZXRlKHRoaXMuX2xpc3RlbmVyc1t0eXBlXSk7IH1cclxuXHRcdFx0aWYgKHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMpIHsgZGVsZXRlKHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnNbdHlwZV0pOyB9XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogRGlzcGF0Y2hlcyB0aGUgc3BlY2lmaWVkIGV2ZW50IHRvIGFsbCBsaXN0ZW5lcnMuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIC8vIFVzZSBhIHN0cmluZyBldmVudFxyXG5cdCAqICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiY29tcGxldGVcIik7XHJcblx0ICpcclxuXHQgKiAgICAgIC8vIFVzZSBhbiBFdmVudCBpbnN0YW5jZVxyXG5cdCAqICAgICAgdmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwicHJvZ3Jlc3NcIik7XHJcblx0ICogICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBkaXNwYXRjaEV2ZW50XHJcblx0ICogQHBhcmFtIHtPYmplY3QgfCBTdHJpbmcgfCBFdmVudH0gZXZlbnRPYmogQW4gb2JqZWN0IHdpdGggYSBcInR5cGVcIiBwcm9wZXJ0eSwgb3IgYSBzdHJpbmcgdHlwZS5cclxuXHQgKiBXaGlsZSBhIGdlbmVyaWMgb2JqZWN0IHdpbGwgd29yaywgaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIGEgQ3JlYXRlSlMgRXZlbnQgaW5zdGFuY2UuIElmIGEgc3RyaW5nIGlzIHVzZWQsXHJcblx0ICogZGlzcGF0Y2hFdmVudCB3aWxsIGNvbnN0cnVjdCBhbiBFdmVudCBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgdHlwZS5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBldmVudE9iai5kZWZhdWx0UHJldmVudGVkLlxyXG5cdCAqKi9cclxuXHRwLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudE9iaikge1xyXG5cdFx0aWYgKHR5cGVvZiBldmVudE9iaiA9PSBcInN0cmluZ1wiKSB7XHJcblx0XHRcdC8vIHdvbid0IGJ1YmJsZSwgc28gc2tpcCBldmVyeXRoaW5nIGlmIHRoZXJlJ3Mgbm8gbGlzdGVuZXJzOlxyXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG5cdFx0XHRpZiAoIWxpc3RlbmVycyB8fCAhbGlzdGVuZXJzW2V2ZW50T2JqXSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0ZXZlbnRPYmogPSBuZXcgY3JlYXRlanMuRXZlbnQoZXZlbnRPYmopO1xyXG5cdFx0fSBlbHNlIGlmIChldmVudE9iai50YXJnZXQgJiYgZXZlbnRPYmouY2xvbmUpIHtcclxuXHRcdFx0Ly8gcmVkaXNwYXRjaGluZyBhbiBhY3RpdmUgZXZlbnQgb2JqZWN0LCBzbyBjbG9uZSBpdDpcclxuXHRcdFx0ZXZlbnRPYmogPSBldmVudE9iai5jbG9uZSgpO1xyXG5cdFx0fVxyXG5cdFx0dHJ5IHsgZXZlbnRPYmoudGFyZ2V0ID0gdGhpczsgfSBjYXRjaCAoZSkge30gLy8gdHJ5L2NhdGNoIGFsbG93cyByZWRpc3BhdGNoaW5nIG9mIG5hdGl2ZSBldmVudHNcclxuXHJcblx0XHRpZiAoIWV2ZW50T2JqLmJ1YmJsZXMgfHwgIXRoaXMucGFyZW50KSB7XHJcblx0XHRcdHRoaXMuX2Rpc3BhdGNoRXZlbnQoZXZlbnRPYmosIDIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHRvcD10aGlzLCBsaXN0PVt0b3BdO1xyXG5cdFx0XHR3aGlsZSAodG9wLnBhcmVudCkgeyBsaXN0LnB1c2godG9wID0gdG9wLnBhcmVudCk7IH1cclxuXHRcdFx0dmFyIGksIGw9bGlzdC5sZW5ndGg7XHJcblxyXG5cdFx0XHQvLyBjYXB0dXJlICYgYXRUYXJnZXRcclxuXHRcdFx0Zm9yIChpPWwtMTsgaT49MCAmJiAhZXZlbnRPYmoucHJvcGFnYXRpb25TdG9wcGVkOyBpLS0pIHtcclxuXHRcdFx0XHRsaXN0W2ldLl9kaXNwYXRjaEV2ZW50KGV2ZW50T2JqLCAxKyhpPT0wKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gYnViYmxpbmdcclxuXHRcdFx0Zm9yIChpPTE7IGk8bCAmJiAhZXZlbnRPYmoucHJvcGFnYXRpb25TdG9wcGVkOyBpKyspIHtcclxuXHRcdFx0XHRsaXN0W2ldLl9kaXNwYXRjaEV2ZW50KGV2ZW50T2JqLCAzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGV2ZW50T2JqLmRlZmF1bHRQcmV2ZW50ZWQ7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXHJcblx0ICogQG1ldGhvZCBoYXNFdmVudExpc3RlbmVyXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxyXG5cdCAqKi9cclxuXHRwLmhhc0V2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLCBjYXB0dXJlTGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVycztcclxuXHRcdHJldHVybiAhISgobGlzdGVuZXJzICYmIGxpc3RlbmVyc1t0eXBlXSkgfHwgKGNhcHR1cmVMaXN0ZW5lcnMgJiYgY2FwdHVyZUxpc3RlbmVyc1t0eXBlXSkpO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUgb24gdGhpcyBvYmplY3Qgb3IgYW55IG9mIGl0c1xyXG5cdCAqIGFuY2VzdG9ycyAocGFyZW50LCBwYXJlbnQncyBwYXJlbnQsIGV0YykuIEEgcmV0dXJuIHZhbHVlIG9mIHRydWUgaW5kaWNhdGVzIHRoYXQgaWYgYSBidWJibGluZyBldmVudCBvZiB0aGVcclxuXHQgKiBzcGVjaWZpZWQgdHlwZSBpcyBkaXNwYXRjaGVkIGZyb20gdGhpcyBvYmplY3QsIGl0IHdpbGwgdHJpZ2dlciBhdCBsZWFzdCBvbmUgbGlzdGVuZXIuXHJcblx0ICogXHJcblx0ICogVGhpcyBpcyBzaW1pbGFyIHRvIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9oYXNFdmVudExpc3RlbmVyXCJ9fXt7L2Nyb3NzTGlua319LCBidXQgaXQgc2VhcmNoZXMgdGhlIGVudGlyZVxyXG5cdCAqIGV2ZW50IGZsb3cgZm9yIGEgbGlzdGVuZXIsIG5vdCBqdXN0IHRoaXMgb2JqZWN0LlxyXG5cdCAqIEBtZXRob2Qgd2lsbFRyaWdnZXJcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cclxuXHQgKiovXHJcblx0cC53aWxsVHJpZ2dlciA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdHZhciBvID0gdGhpcztcclxuXHRcdHdoaWxlIChvKSB7XHJcblx0XHRcdGlmIChvLmhhc0V2ZW50TGlzdGVuZXIodHlwZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0byA9IG8ucGFyZW50O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cclxuXHQgKiovXHJcblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIFwiW0V2ZW50RGlzcGF0Y2hlcl1cIjtcclxuXHR9O1xyXG5cclxuXHJcbi8vIHByaXZhdGUgbWV0aG9kczpcclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIF9kaXNwYXRjaEV2ZW50XHJcblx0ICogQHBhcmFtIHtPYmplY3QgfCBTdHJpbmcgfCBFdmVudH0gZXZlbnRPYmpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRQaGFzZVxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiovXHJcblx0cC5fZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50T2JqLCBldmVudFBoYXNlKSB7XHJcblx0XHR2YXIgbCwgbGlzdGVuZXJzID0gKGV2ZW50UGhhc2U9PTEpID8gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA6IHRoaXMuX2xpc3RlbmVycztcclxuXHRcdGlmIChldmVudE9iaiAmJiBsaXN0ZW5lcnMpIHtcclxuXHRcdFx0dmFyIGFyciA9IGxpc3RlbmVyc1tldmVudE9iai50eXBlXTtcclxuXHRcdFx0aWYgKCFhcnJ8fCEobD1hcnIubGVuZ3RoKSkgeyByZXR1cm47IH1cclxuXHRcdFx0dHJ5IHsgZXZlbnRPYmouY3VycmVudFRhcmdldCA9IHRoaXM7IH0gY2F0Y2ggKGUpIHt9XHJcblx0XHRcdHRyeSB7IGV2ZW50T2JqLmV2ZW50UGhhc2UgPSBldmVudFBoYXNlOyB9IGNhdGNoIChlKSB7fVxyXG5cdFx0XHRldmVudE9iai5yZW1vdmVkID0gZmFsc2U7XHJcblx0XHRcdFxyXG5cdFx0XHRhcnIgPSBhcnIuc2xpY2UoKTsgLy8gdG8gYXZvaWQgaXNzdWVzIHdpdGggaXRlbXMgYmVpbmcgcmVtb3ZlZCBvciBhZGRlZCBkdXJpbmcgdGhlIGRpc3BhdGNoXHJcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsICYmICFldmVudE9iai5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ7IGkrKykge1xyXG5cdFx0XHRcdHZhciBvID0gYXJyW2ldO1xyXG5cdFx0XHRcdGlmIChvLmhhbmRsZUV2ZW50KSB7IG8uaGFuZGxlRXZlbnQoZXZlbnRPYmopOyB9XHJcblx0XHRcdFx0ZWxzZSB7IG8oZXZlbnRPYmopOyB9XHJcblx0XHRcdFx0aWYgKGV2ZW50T2JqLnJlbW92ZWQpIHtcclxuXHRcdFx0XHRcdHRoaXMub2ZmKGV2ZW50T2JqLnR5cGUsIG8sIGV2ZW50UGhhc2U9PTEpO1xyXG5cdFx0XHRcdFx0ZXZlbnRPYmoucmVtb3ZlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cclxuXHRjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIgPSBFdmVudERpc3BhdGNoZXI7XHJcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBQcm9ncmVzc0V2ZW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uIChzY29wZSkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBDcmVhdGVKUyB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGRpc3BhdGNoZWQgd2hlbiBwcm9ncmVzcyBjaGFuZ2VzLlxuXHQgKiBAY2xhc3MgUHJvZ3Jlc3NFdmVudFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbG9hZGVkIFRoZSBhbW91bnQgdGhhdCBoYXMgYmVlbiBsb2FkZWQuIFRoaXMgY2FuIGJlIGFueSBudW1iZXIgcmVsYXRpdmUgdG8gdGhlIHRvdGFsLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RvdGFsPTFdIFRoZSB0b3RhbCBhbW91bnQgdGhhdCB3aWxsIGxvYWQuIFRoaXMgd2lsbCBkZWZhdWx0IHRvIDEsIHNvIGlmIHRoZSBgbG9hZGVkYCB2YWx1ZSBpc1xuXHQgKiBhIHBlcmNlbnRhZ2UgKGJldHdlZW4gMCBhbmQgMSksIGl0IGNhbiBiZSBvbWl0dGVkLlxuXHQgKiBAdG9kbyBDb25zaWRlciBoYXZpbmcgdGhpcyBldmVudCBiZSBhIFwiZmlsZXByb2dyZXNzXCIgZXZlbnQgYXMgd2VsbFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFByb2dyZXNzRXZlbnQobG9hZGVkLCB0b3RhbCkge1xuXHRcdHRoaXMuRXZlbnRfY29uc3RydWN0b3IoXCJwcm9ncmVzc1wiKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBhbW91bnQgdGhhdCBoYXMgYmVlbiBsb2FkZWQgKG91dCBvZiBhIHRvdGFsIGFtb3VudClcblx0XHQgKiBAcHJvcGVydHkgbG9hZGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLmxvYWRlZCA9IGxvYWRlZDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0b3RhbCBcInNpemVcIiBvZiB0aGUgbG9hZC5cblx0XHQgKiBAcHJvcGVydHkgdG90YWxcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKi9cblx0XHR0aGlzLnRvdGFsID0gKHRvdGFsID09IG51bGwpID8gMSA6IHRvdGFsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHBlcmNlbnRhZ2UgKG91dCBvZiAxKSB0aGF0IHRoZSBsb2FkIGhhcyBiZWVuIGNvbXBsZXRlZC4gVGhpcyBpcyBjYWxjdWxhdGVkIHVzaW5nIGBsb2FkZWQvdG90YWxgLlxuXHRcdCAqIEBwcm9wZXJ0eSBwcm9ncmVzc1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSAodG90YWwgPT0gMCkgPyAwIDogdGhpcy5sb2FkZWQgLyB0aGlzLnRvdGFsO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFByb2dyZXNzRXZlbnQsIGNyZWF0ZWpzLkV2ZW50KTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBQcm9ncmVzc0V2ZW50IGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge1Byb2dyZXNzRXZlbnR9IGEgY2xvbmUgb2YgdGhlIEV2ZW50IGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IGNyZWF0ZWpzLlByb2dyZXNzRXZlbnQodGhpcy5sb2FkZWQsIHRoaXMudG90YWwpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLlByb2dyZXNzRXZlbnQgPSBjcmVhdGVqcy5wcm9tb3RlKFByb2dyZXNzRXZlbnQsIFwiRXZlbnRcIik7XG5cbn0od2luZG93KSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBqc29uMy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuLyohIEpTT04gdjMuMy4yIHwgaHR0cDovL2Jlc3RpZWpzLmdpdGh1Yi5pby9qc29uMyB8IENvcHlyaWdodCAyMDEyLTIwMTQsIEtpdCBDYW1icmlkZ2UgfCBodHRwOi8va2l0Lm1pdC1saWNlbnNlLm9yZyAqL1xuOyhmdW5jdGlvbiAoKSB7XG4gIC8vIERldGVjdCB0aGUgYGRlZmluZWAgZnVuY3Rpb24gZXhwb3NlZCBieSBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuIFRoZVxuICAvLyBzdHJpY3QgYGRlZmluZWAgY2hlY2sgaXMgbmVjZXNzYXJ5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggYHIuanNgLlxuICB2YXIgaXNMb2FkZXIgPSB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZDtcblxuICAvLyBBIHNldCBvZiB0eXBlcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIG9iamVjdHMgZnJvbSBwcmltaXRpdmVzLlxuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgIFwib2JqZWN0XCI6IHRydWVcbiAgfTtcblxuICAvLyBEZXRlY3QgdGhlIGBleHBvcnRzYCBvYmplY3QgZXhwb3NlZCBieSBDb21tb25KUyBpbXBsZW1lbnRhdGlvbnMuXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLy8gVXNlIHRoZSBgZ2xvYmFsYCBvYmplY3QgZXhwb3NlZCBieSBOb2RlIChpbmNsdWRpbmcgQnJvd3NlcmlmeSB2aWFcbiAgLy8gYGluc2VydC1tb2R1bGUtZ2xvYmFsc2ApLCBOYXJ3aGFsLCBhbmQgUmluZ28gYXMgdGhlIGRlZmF1bHQgY29udGV4dCxcbiAgLy8gYW5kIHRoZSBgd2luZG93YCBvYmplY3QgaW4gYnJvd3NlcnMuIFJoaW5vIGV4cG9ydHMgYSBgZ2xvYmFsYCBmdW5jdGlvblxuICAvLyBpbnN0ZWFkLlxuICB2YXIgcm9vdCA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyB8fCB0aGlzLFxuICAgICAgZnJlZUdsb2JhbCA9IGZyZWVFeHBvcnRzICYmIG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIHR5cGVvZiBnbG9iYWwgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWw7XG5cbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWxbXCJnbG9iYWxcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcIndpbmRvd1wiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wic2VsZlwiXSA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8vIFB1YmxpYzogSW5pdGlhbGl6ZXMgSlNPTiAzIHVzaW5nIHRoZSBnaXZlbiBgY29udGV4dGAgb2JqZWN0LCBhdHRhY2hpbmcgdGhlXG4gIC8vIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGZ1bmN0aW9ucyB0byB0aGUgc3BlY2lmaWVkIGBleHBvcnRzYCBvYmplY3QuXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0LCBleHBvcnRzKSB7XG4gICAgY29udGV4dCB8fCAoY29udGV4dCA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG4gICAgZXhwb3J0cyB8fCAoZXhwb3J0cyA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG5cbiAgICAvLyBOYXRpdmUgY29uc3RydWN0b3IgYWxpYXNlcy5cbiAgICB2YXIgTnVtYmVyID0gY29udGV4dFtcIk51bWJlclwiXSB8fCByb290W1wiTnVtYmVyXCJdLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0W1wiU3RyaW5nXCJdIHx8IHJvb3RbXCJTdHJpbmdcIl0sXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHRbXCJPYmplY3RcIl0gfHwgcm9vdFtcIk9iamVjdFwiXSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHRbXCJEYXRlXCJdIHx8IHJvb3RbXCJEYXRlXCJdLFxuICAgICAgICBTeW50YXhFcnJvciA9IGNvbnRleHRbXCJTeW50YXhFcnJvclwiXSB8fCByb290W1wiU3ludGF4RXJyb3JcIl0sXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHRbXCJUeXBlRXJyb3JcIl0gfHwgcm9vdFtcIlR5cGVFcnJvclwiXSxcbiAgICAgICAgTWF0aCA9IGNvbnRleHRbXCJNYXRoXCJdIHx8IHJvb3RbXCJNYXRoXCJdLFxuICAgICAgICBuYXRpdmVKU09OID0gY29udGV4dFtcIkpTT05cIl0gfHwgcm9vdFtcIkpTT05cIl07XG5cbiAgICAvLyBEZWxlZ2F0ZSB0byB0aGUgbmF0aXZlIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGltcGxlbWVudGF0aW9ucy5cbiAgICBpZiAodHlwZW9mIG5hdGl2ZUpTT04gPT0gXCJvYmplY3RcIiAmJiBuYXRpdmVKU09OKSB7XG4gICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IG5hdGl2ZUpTT04uc3RyaW5naWZ5O1xuICAgICAgZXhwb3J0cy5wYXJzZSA9IG5hdGl2ZUpTT04ucGFyc2U7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgYWxpYXNlcy5cbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBnZXRDbGFzcyA9IG9iamVjdFByb3RvLnRvU3RyaW5nLFxuICAgICAgICBpc1Byb3BlcnR5LCBmb3JFYWNoLCB1bmRlZjtcblxuICAgIC8vIFRlc3QgdGhlIGBEYXRlI2dldFVUQypgIG1ldGhvZHMuIEJhc2VkIG9uIHdvcmsgYnkgQFlhZmZsZS5cbiAgICB2YXIgaXNFeHRlbmRlZCA9IG5ldyBEYXRlKC0zNTA5ODI3MzM0NTczMjkyKTtcbiAgICB0cnkge1xuICAgICAgLy8gVGhlIGBnZXRVVENGdWxsWWVhcmAsIGBNb250aGAsIGFuZCBgRGF0ZWAgbWV0aG9kcyByZXR1cm4gbm9uc2Vuc2ljYWxcbiAgICAgIC8vIHJlc3VsdHMgZm9yIGNlcnRhaW4gZGF0ZXMgaW4gT3BlcmEgPj0gMTAuNTMuXG4gICAgICBpc0V4dGVuZGVkID0gaXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpID09IC0xMDkyNTIgJiYgaXNFeHRlbmRlZC5nZXRVVENNb250aCgpID09PSAwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpID09PSAxICYmXG4gICAgICAgIC8vIFNhZmFyaSA8IDIuMC4yIHN0b3JlcyB0aGUgaW50ZXJuYWwgbWlsbGlzZWNvbmQgdGltZSB2YWx1ZSBjb3JyZWN0bHksXG4gICAgICAgIC8vIGJ1dCBjbGlwcyB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBkYXRlIG1ldGhvZHMgdG8gdGhlIHJhbmdlIG9mXG4gICAgICAgIC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cbiAgICAgICAgaXNFeHRlbmRlZC5nZXRVVENIb3VycygpID09IDEwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWludXRlcygpID09IDM3ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDU2Vjb25kcygpID09IDYgJiYgaXNFeHRlbmRlZC5nZXRVVENNaWxsaXNlY29uZHMoKSA9PSA3MDg7XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXG4gICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgd2hldGhlciB0aGUgbmF0aXZlIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBwYXJzZWBcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgYXJlIHNwZWMtY29tcGxpYW50LiBCYXNlZCBvbiB3b3JrIGJ5IEtlbiBTbnlkZXIuXG4gICAgZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICAgIGlmIChoYXNbbmFtZV0gIT09IHVuZGVmKSB7XG4gICAgICAgIC8vIFJldHVybiBjYWNoZWQgZmVhdHVyZSB0ZXN0IHJlc3VsdC5cbiAgICAgICAgcmV0dXJuIGhhc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1N1cHBvcnRlZDtcbiAgICAgIGlmIChuYW1lID09IFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpIHtcbiAgICAgICAgLy8gSUUgPD0gNyBkb2Vzbid0IHN1cHBvcnQgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIHVzaW5nIHNxdWFyZVxuICAgICAgICAvLyBicmFja2V0IG5vdGF0aW9uLiBJRSA4IG9ubHkgc3VwcG9ydHMgdGhpcyBmb3IgcHJpbWl0aXZlcy5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBcImFcIlswXSAhPSBcImFcIjtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImpzb25cIikge1xuICAgICAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciBib3RoIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBKU09OLnBhcnNlYCBhcmVcbiAgICAgICAgLy8gc3VwcG9ydGVkLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IGhhcyhcImpzb24tc3RyaW5naWZ5XCIpICYmIGhhcyhcImpzb24tcGFyc2VcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUsIHNlcmlhbGl6ZWQgPSAne1wiYVwiOlsxLHRydWUsZmFsc2UsbnVsbCxcIlxcXFx1MDAwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcIl19JztcbiAgICAgICAgLy8gVGVzdCBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tc3RyaW5naWZ5XCIpIHtcbiAgICAgICAgICB2YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnksIHN0cmluZ2lmeVN1cHBvcnRlZCA9IHR5cGVvZiBzdHJpbmdpZnkgPT0gXCJmdW5jdGlvblwiICYmIGlzRXh0ZW5kZWQ7XG4gICAgICAgICAgaWYgKHN0cmluZ2lmeVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgLy8gQSB0ZXN0IGZ1bmN0aW9uIG9iamVjdCB3aXRoIGEgY3VzdG9tIGB0b0pTT05gIG1ldGhvZC5cbiAgICAgICAgICAgICh2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9KS50b0pTT04gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCAzLjFiMSBhbmQgYjIgc2VyaWFsaXplIHN0cmluZywgbnVtYmVyLCBhbmQgYm9vbGVhblxuICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZXMgYXMgb2JqZWN0IGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgwKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIsIGFuZCBKU09OIDIgc2VyaWFsaXplIHdyYXBwZWQgcHJpbWl0aXZlcyBhcyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IE51bWJlcigpKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IFN0cmluZygpKSA9PSAnXCJcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3JcbiAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBkZWZpbmUgYSBjYW5vbmljYWwgSlNPTiByZXByZXNlbnRhdGlvbiAodGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGB0b0pTT05gIHByb3BlcnRpZXMgYXMgd2VsbCwgKnVubGVzcyogdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gd2l0aGluIGFuIG9iamVjdCBvciBhcnJheSkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KGdldENsYXNzKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBJRSA4IHNlcmlhbGl6ZXMgYHVuZGVmaW5lZGAgYXMgYFwidW5kZWZpbmVkXCJgLiBTYWZhcmkgPD0gNS4xLjcgYW5kXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjMgcGFzcyB0aGlzIHRlc3QuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHVuZGVmKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjcgYW5kIEZGIDMuMWIzIHRocm93IGBFcnJvcmBzIGFuZCBgVHlwZUVycm9yYHMsXG4gICAgICAgICAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LCBpZiB0aGUgdmFsdWUgaXMgb21pdHRlZCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgbnVtYmVyLFxuICAgICAgICAgICAgICAgIC8vIHN0cmluZywgYXJyYXksIG9iamVjdCwgQm9vbGVhbiwgb3IgYG51bGxgIGxpdGVyYWwuIFRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcyBhcyB3ZWxsLCB1bmxlc3MgdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIG9iamVjdCBvciBhcnJheSBsaXRlcmFscy4gWVVJIDMuMC4wYjEgaWdub3JlcyBjdXN0b20gYHRvSlNPTmBcbiAgICAgICAgICAgICAgICAvLyBtZXRob2RzIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt2YWx1ZV0pID09IFwiWzFdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgc2VyaWFsaXplcyBgW3VuZGVmaW5lZF1gIGFzIGBcIltdXCJgIGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAgICAvLyBgXCJbbnVsbF1cImAuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZl0pID09IFwiW251bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBZVUkgMy4wLjBiMSBmYWlscyB0byBzZXJpYWxpemUgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsKSA9PSBcIm51bGxcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIGhhbHRzIHNlcmlhbGl6YXRpb24gaWYgYW4gYXJyYXkgY29udGFpbnMgYSBmdW5jdGlvbjpcbiAgICAgICAgICAgICAgICAvLyBgWzEsIHRydWUsIGdldENsYXNzLCAxXWAgc2VyaWFsaXplcyBhcyBcIlsxLHRydWUsXSxcIi4gRkYgMy4xYjNcbiAgICAgICAgICAgICAgICAvLyBlbGlkZXMgbm9uLUpTT04gdmFsdWVzIGZyb20gb2JqZWN0cyBhbmQgYXJyYXlzLCB1bmxlc3MgdGhleVxuICAgICAgICAgICAgICAgIC8vIGRlZmluZSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmLCBnZXRDbGFzcywgbnVsbF0pID09IFwiW251bGwsbnVsbCxudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHNlcmlhbGl6YXRpb24gdGVzdC4gRkYgMy4xYjEgdXNlcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZXNcbiAgICAgICAgICAgICAgICAvLyB3aGVyZSBjaGFyYWN0ZXIgZXNjYXBlIGNvZGVzIGFyZSBleHBlY3RlZCAoZS5nLiwgYFxcYmAgPT4gYFxcdTAwMDhgKS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoeyBcImFcIjogW3ZhbHVlLCB0cnVlLCBmYWxzZSwgbnVsbCwgXCJcXHgwMFxcYlxcblxcZlxcclxcdFwiXSB9KSA9PSBzZXJpYWxpemVkICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEgYW5kIGIyIGlnbm9yZSB0aGUgYGZpbHRlcmAgYW5kIGB3aWR0aGAgYXJndW1lbnRzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsLCB2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFsxLCAyXSwgbnVsbCwgMSkgPT0gXCJbXFxuIDEsXFxuIDJcXG5dXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBKU09OIDIsIFByb3RvdHlwZSA8PSAxLjcsIGFuZCBvbGRlciBXZWJLaXQgYnVpbGRzIGluY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIGV4dGVuZGVkIHllYXJzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtOC42NGUxNSkpID09ICdcIi0yNzE4MjEtMDQtMjBUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFRoZSBtaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKDguNjRlMTUpKSA9PSAnXCIrMjc1NzYwLTA5LTEzVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDw9IDExLjAgaW5jb3JyZWN0bHkgc2VyaWFsaXplcyB5ZWFycyBwcmlvciB0byAwIGFzIG5lZ2F0aXZlXG4gICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCB5ZWFycyBpbnN0ZWFkIG9mIHNpeC1kaWdpdCB5ZWFycy4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTYyMTk4NzU1MmU1KSkgPT0gJ1wiLTAwMDAwMS0wMS0wMVQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS41IGFuZCBPcGVyYSA+PSAxMC41MyBpbmNvcnJlY3RseSBzZXJpYWxpemUgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgbGVzcyB0aGFuIDEwMDAuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC0xKSkgPT0gJ1wiMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaXCInO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHN0cmluZ2lmeVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXN0IGBKU09OLnBhcnNlYC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXBhcnNlXCIpIHtcbiAgICAgICAgICB2YXIgcGFyc2UgPSBleHBvcnRzLnBhcnNlO1xuICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2UgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYSBiYXJlIGxpdGVyYWwgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgIC8vIENvbmZvcm1pbmcgaW1wbGVtZW50YXRpb25zIHNob3VsZCBhbHNvIGNvZXJjZSB0aGUgaW5pdGlhbCBhcmd1bWVudCB0b1xuICAgICAgICAgICAgICAvLyBhIHN0cmluZyBwcmlvciB0byBwYXJzaW5nLlxuICAgICAgICAgICAgICBpZiAocGFyc2UoXCIwXCIpID09PSAwICYmICFwYXJzZShmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgcGFyc2luZyB0ZXN0LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlU3VwcG9ydGVkID0gdmFsdWVbXCJhXCJdLmxlbmd0aCA9PSA1ICYmIHZhbHVlW1wiYVwiXVswXSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuMiBhbmQgRkYgMy4xYjEgYWxsb3cgdW5lc2NhcGVkIHRhYnMgaW4gc3RyaW5ncy5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSAhcGFyc2UoJ1wiXFx0XCInKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCBhbmQgNC4wLjEgYWxsb3cgbGVhZGluZyBgK2Agc2lnbnMgYW5kIGxlYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNpbWFsIHBvaW50cy4gRkYgNC4wLCA0LjAuMSwgYW5kIElFIDktMTAgYWxzbyBhbGxvd1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjAxXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAsIDQuMC4xLCBhbmQgUmhpbm8gMS43UjMtUjQgYWxsb3cgdHJhaWxpbmcgZGVjaW1hbFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50cy4gVGhlc2UgZW52aXJvbm1lbnRzLCBhbG9uZyB3aXRoIEZGIDMuMWIxIGFuZCAyLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzIGluIEpTT04gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIxLlwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gcGFyc2VTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNbbmFtZV0gPSAhIWlzU3VwcG9ydGVkO1xuICAgIH1cblxuICAgIGlmICghaGFzKFwianNvblwiKSkge1xuICAgICAgLy8gQ29tbW9uIGBbW0NsYXNzXV1gIG5hbWUgYWxpYXNlcy5cbiAgICAgIHZhciBmdW5jdGlvbkNsYXNzID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLFxuICAgICAgICAgIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiLFxuICAgICAgICAgIG51bWJlckNsYXNzID0gXCJbb2JqZWN0IE51bWJlcl1cIixcbiAgICAgICAgICBzdHJpbmdDbGFzcyA9IFwiW29iamVjdCBTdHJpbmddXCIsXG4gICAgICAgICAgYXJyYXlDbGFzcyA9IFwiW29iamVjdCBBcnJheV1cIixcbiAgICAgICAgICBib29sZWFuQ2xhc3MgPSBcIltvYmplY3QgQm9vbGVhbl1cIjtcblxuICAgICAgLy8gRGV0ZWN0IGluY29tcGxldGUgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxuICAgICAgdmFyIGNoYXJJbmRleEJ1Z2d5ID0gaGFzKFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpO1xuXG4gICAgICAvLyBEZWZpbmUgYWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMgaWYgdGhlIGBEYXRlYCBtZXRob2RzIGFyZSBidWdneS5cbiAgICAgIGlmICghaXNFeHRlbmRlZCkge1xuICAgICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgICAgICAvLyBBIG1hcHBpbmcgYmV0d2VlbiB0aGUgbW9udGhzIG9mIHRoZSB5ZWFyIGFuZCB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlblxuICAgICAgICAvLyBKYW51YXJ5IDFzdCBhbmQgdGhlIGZpcnN0IG9mIHRoZSByZXNwZWN0aXZlIG1vbnRoLlxuICAgICAgICB2YXIgTW9udGhzID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcbiAgICAgICAgLy8gSW50ZXJuYWw6IENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdGhlIFVuaXggZXBvY2ggYW5kIHRoZVxuICAgICAgICAvLyBmaXJzdCBkYXkgb2YgdGhlIGdpdmVuIG1vbnRoLlxuICAgICAgICB2YXIgZ2V0RGF5ID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG4gICAgICAgICAgcmV0dXJuIE1vbnRoc1ttb250aF0gKyAzNjUgKiAoeWVhciAtIDE5NzApICsgZmxvb3IoKHllYXIgLSAxOTY5ICsgKG1vbnRoID0gKyhtb250aCA+IDEpKSkgLyA0KSAtIGZsb29yKCh5ZWFyIC0gMTkwMSArIG1vbnRoKSAvIDEwMCkgKyBmbG9vcigoeWVhciAtIDE2MDEgKyBtb250aCkgLyA0MDApO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyBpZiBhIHByb3BlcnR5IGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIHRoZSBnaXZlblxuICAgICAgLy8gb2JqZWN0LiBEZWxlZ2F0ZXMgdG8gdGhlIG5hdGl2ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBtZXRob2QuXG4gICAgICBpZiAoIShpc1Byb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHkpKSB7XG4gICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBjb25zdHJ1Y3RvcjtcbiAgICAgICAgICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XG4gICAgICAgICAgICAvLyBUaGUgKnByb3RvKiBwcm9wZXJ0eSBjYW5ub3QgYmUgc2V0IG11bHRpcGxlIHRpbWVzIGluIHJlY2VudFxuICAgICAgICAgICAgLy8gdmVyc2lvbnMgb2YgRmlyZWZveCBhbmQgU2VhTW9ua2V5LlxuICAgICAgICAgICAgXCJ0b1N0cmluZ1wiOiAxXG4gICAgICAgICAgfSwgbWVtYmVycykudG9TdHJpbmcgIT0gZ2V0Q2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuMyBkb2Vzbid0IGltcGxlbWVudCBgT2JqZWN0I2hhc093blByb3BlcnR5YCwgYnV0XG4gICAgICAgICAgICAvLyBzdXBwb3J0cyB0aGUgbXV0YWJsZSAqcHJvdG8qIHByb3BlcnR5LlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAvLyBDYXB0dXJlIGFuZCBicmVhayB0aGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIChzZWUgc2VjdGlvbiA4LjYuMlxuICAgICAgICAgICAgICAvLyBvZiB0aGUgRVMgNS4xIHNwZWMpLiBUaGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIHByZXZlbnRzIGFuXG4gICAgICAgICAgICAgIC8vIHVuc2FmZSB0cmFuc2Zvcm1hdGlvbiBieSB0aGUgQ2xvc3VyZSBDb21waWxlci5cbiAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcy5fX3Byb3RvX18sIHJlc3VsdCA9IHByb3BlcnR5IGluICh0aGlzLl9fcHJvdG9fXyA9IG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gb3JpZ2luYWw7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDYXB0dXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbGV2ZWwgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IG1lbWJlcnMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgdG8gc2ltdWxhdGUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW5cbiAgICAgICAgICAgIC8vIG90aGVyIGVudmlyb25tZW50cy5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9ICh0aGlzLmNvbnN0cnVjdG9yIHx8IGNvbnN0cnVjdG9yKS5wcm90b3R5cGU7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmICEocHJvcGVydHkgaW4gcGFyZW50ICYmIHRoaXNbcHJvcGVydHldID09PSBwYXJlbnRbcHJvcGVydHldKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lbWJlcnMgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBpc1Byb3BlcnR5LmNhbGwodGhpcywgcHJvcGVydHkpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogTm9ybWFsaXplcyB0aGUgYGZvci4uLmluYCBpdGVyYXRpb24gYWxnb3JpdGhtIGFjcm9zc1xuICAgICAgLy8gZW52aXJvbm1lbnRzLiBFYWNoIGVudW1lcmF0ZWQga2V5IGlzIHlpZWxkZWQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLlxuICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzaXplID0gMCwgUHJvcGVydGllcywgbWVtYmVycywgcHJvcGVydHk7XG5cbiAgICAgICAgLy8gVGVzdHMgZm9yIGJ1Z3MgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQncyBgZm9yLi4uaW5gIGFsZ29yaXRobS4gVGhlXG4gICAgICAgIC8vIGB2YWx1ZU9mYCBwcm9wZXJ0eSBpbmhlcml0cyB0aGUgbm9uLWVudW1lcmFibGUgZmxhZyBmcm9tXG4gICAgICAgIC8vIGBPYmplY3QucHJvdG90eXBlYCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgTmV0c2NhcGUsIGFuZCBNb3ppbGxhLlxuICAgICAgICAoUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlT2YgPSAwO1xuICAgICAgICB9KS5wcm90b3R5cGUudmFsdWVPZiA9IDA7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUHJvcGVydGllc2AgY2xhc3MuXG4gICAgICAgIG1lbWJlcnMgPSBuZXcgUHJvcGVydGllcygpO1xuICAgICAgICBmb3IgKHByb3BlcnR5IGluIG1lbWJlcnMpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgYWxsIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIGlmIChpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFByb3BlcnRpZXMgPSBtZW1iZXJzID0gbnVsbDtcblxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGl0ZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgIC8vIEEgbGlzdCBvZiBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBtZW1iZXJzID0gW1widmFsdWVPZlwiLCBcInRvU3RyaW5nXCIsIFwidG9Mb2NhbGVTdHJpbmdcIiwgXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLCBcImlzUHJvdG90eXBlT2ZcIiwgXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdO1xuICAgICAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxuICAgICAgICAgIC8vIHByb3BlcnRpZXMuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgbGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGhhc1Byb3BlcnR5ID0gIWlzRnVuY3Rpb24gJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciAhPSBcImZ1bmN0aW9uXCIgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eV0gJiYgb2JqZWN0Lmhhc093blByb3BlcnR5IHx8IGlzUHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBHZWNrbyA8PSAxLjAgZW51bWVyYXRlcyB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHVuZGVyXG4gICAgICAgICAgICAgIC8vIGNlcnRhaW4gY29uZGl0aW9uczsgSUUgZG9lcyBub3QuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gbWVtYmVycy5sZW5ndGg7IHByb3BlcnR5ID0gbWVtYmVyc1stLWxlbmd0aF07IGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgY2FsbGJhY2socHJvcGVydHkpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHNpemUgPT0gMikge1xuICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuNCBlbnVtZXJhdGVzIHNoYWRvd2VkIHByb3BlcnRpZXMgdHdpY2UuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzZXQgb2YgaXRlcmF0ZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBTdG9yZSBlYWNoIHByb3BlcnR5IG5hbWUgdG8gcHJldmVudCBkb3VibGUgZW51bWVyYXRpb24uIFRoZVxuICAgICAgICAgICAgICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxuICAgICAgICAgICAgICAvLyBlbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgIWlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkgJiYgKG1lbWJlcnNbcHJvcGVydHldID0gMSkgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGlzQ29uc3RydWN0b3I7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiAhKGlzQ29uc3RydWN0b3IgPSBwcm9wZXJ0eSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgZHVlIHRvXG4gICAgICAgICAgICAvLyBjcm9zcy1lbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciB8fCBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCAocHJvcGVydHkgPSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFB1YmxpYzogU2VyaWFsaXplcyBhIEphdmFTY3JpcHQgYHZhbHVlYCBhcyBhIEpTT04gc3RyaW5nLiBUaGUgb3B0aW9uYWxcbiAgICAgIC8vIGBmaWx0ZXJgIGFyZ3VtZW50IG1heSBzcGVjaWZ5IGVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgYWx0ZXJzIGhvdyBvYmplY3QgYW5kXG4gICAgICAvLyBhcnJheSBtZW1iZXJzIGFyZSBzZXJpYWxpemVkLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBudW1iZXJzIHRoYXRcbiAgICAgIC8vIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgb3B0aW9uYWwgYHdpZHRoYFxuICAgICAgLy8gYXJndW1lbnQgbWF5IGJlIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXG4gICAgICAvLyBsZXZlbCBvZiB0aGUgb3V0cHV0LlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSkge1xuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgRXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXFxcXFwiJyxcbiAgICAgICAgICA4OiBcIlxcXFxiXCIsXG4gICAgICAgICAgMTI6IFwiXFxcXGZcIixcbiAgICAgICAgICAxMDogXCJcXFxcblwiLFxuICAgICAgICAgIDEzOiBcIlxcXFxyXCIsXG4gICAgICAgICAgOTogXCJcXFxcdFwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IENvbnZlcnRzIGB2YWx1ZWAgaW50byBhIHplcm8tcGFkZGVkIHN0cmluZyBzdWNoIHRoYXQgaXRzXG4gICAgICAgIC8vIGxlbmd0aCBpcyBhdCBsZWFzdCBlcXVhbCB0byBgd2lkdGhgLiBUaGUgYHdpZHRoYCBtdXN0IGJlIDw9IDYuXG4gICAgICAgIHZhciBsZWFkaW5nWmVyb2VzID0gXCIwMDAwMDBcIjtcbiAgICAgICAgdmFyIHRvUGFkZGVkU3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoLCB2YWx1ZSkge1xuICAgICAgICAgIC8vIFRoZSBgfHwgMGAgZXhwcmVzc2lvbiBpcyBuZWNlc3NhcnkgdG8gd29yayBhcm91bmQgYSBidWcgaW5cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgd2hlcmUgYDAgPT0gLTBgLCBidXQgYFN0cmluZygtMCkgIT09IFwiMFwiYC5cbiAgICAgICAgICByZXR1cm4gKGxlYWRpbmdaZXJvZXMgKyAodmFsdWUgfHwgMCkpLnNsaWNlKC13aWR0aCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgKGNoYXJhY3RlcnMgd2l0aCBjb2RlIHVuaXQgdmFsdWVzIGJldHdlZW4gMCBhbmQgMzEpIHdpdGhcbiAgICAgICAgLy8gdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgdmFyIHVuaWNvZGVQcmVmaXggPSBcIlxcXFx1MDBcIjtcbiAgICAgICAgdmFyIHF1b3RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICdcIicsIGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCB1c2VDaGFySW5kZXggPSAhY2hhckluZGV4QnVnZ3kgfHwgbGVuZ3RoID4gMTA7XG4gICAgICAgICAgdmFyIHN5bWJvbHMgPSB1c2VDaGFySW5kZXggJiYgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuc3BsaXQoXCJcIikgOiB2YWx1ZSk7XG4gICAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBjb250cm9sIGNoYXJhY3RlciwgYXBwZW5kIGl0cyBVbmljb2RlIG9yXG4gICAgICAgICAgICAvLyBzaG9ydGhhbmQgZXNjYXBlIHNlcXVlbmNlOyBvdGhlcndpc2UsIGFwcGVuZCB0aGUgY2hhcmFjdGVyIGFzLWlzLlxuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDg6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMjogY2FzZSAxMzogY2FzZSAzNDogY2FzZSA5MjpcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gRXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1bmljb2RlUHJlZml4ICsgdG9QYWRkZWRTdHJpbmcoMiwgY2hhckNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdXNlQ2hhckluZGV4ID8gc3ltYm9sc1tpbmRleF0gOiB2YWx1ZS5jaGFyQXQoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ1wiJztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgc2VyaWFsaXplcyBhbiBvYmplY3QuIEltcGxlbWVudHMgdGhlXG4gICAgICAgIC8vIGBTdHIoa2V5LCBob2xkZXIpYCwgYEpPKHZhbHVlKWAsIGFuZCBgSkEodmFsdWUpYCBvcGVyYXRpb25zLlxuICAgICAgICB2YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKHByb3BlcnR5LCBvYmplY3QsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUsIGNsYXNzTmFtZSwgeWVhciwgbW9udGgsIGRhdGUsIHRpbWUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIHJlc3VsdHMsIGVsZW1lbnQsIGluZGV4LCBsZW5ndGgsIHByZWZpeCwgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBOZWNlc3NhcnkgZm9yIGhvc3Qgb2JqZWN0IHN1cHBvcnQuXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGRhdGVDbGFzcyAmJiAhaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCkge1xuICAgICAgICAgICAgICAgIC8vIERhdGVzIGFyZSBzZXJpYWxpemVkIGFjY29yZGluZyB0byB0aGUgYERhdGUjdG9KU09OYCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuOS41LjQ0LiBTZWUgc2VjdGlvbiAxNS45LjEuMTVcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0LlxuICAgICAgICAgICAgICAgIGlmIChnZXREYXkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGNvbXB1dGUgdGhlIHllYXIsIG1vbnRoLCBkYXRlLCBob3VycywgbWludXRlcyxcbiAgICAgICAgICAgICAgICAgIC8vIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgaWYgdGhlIGBnZXRVVEMqYCBtZXRob2RzIGFyZVxuICAgICAgICAgICAgICAgICAgLy8gYnVnZ3kuIEFkYXB0ZWQgZnJvbSBAWWFmZmxlJ3MgYGRhdGUtc2hpbWAgcHJvamVjdC5cbiAgICAgICAgICAgICAgICAgIGRhdGUgPSBmbG9vcih2YWx1ZSAvIDg2NGU1KTtcbiAgICAgICAgICAgICAgICAgIGZvciAoeWVhciA9IGZsb29yKGRhdGUgLyAzNjUuMjQyNSkgKyAxOTcwIC0gMTsgZ2V0RGF5KHllYXIgKyAxLCAwKSA8PSBkYXRlOyB5ZWFyKyspO1xuICAgICAgICAgICAgICAgICAgZm9yIChtb250aCA9IGZsb29yKChkYXRlIC0gZ2V0RGF5KHllYXIsIDApKSAvIDMwLjQyKTsgZ2V0RGF5KHllYXIsIG1vbnRoICsgMSkgPD0gZGF0ZTsgbW9udGgrKyk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gMSArIGRhdGUgLSBnZXREYXkoeWVhciwgbW9udGgpO1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGB0aW1lYCB2YWx1ZSBzcGVjaWZpZXMgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkgKHNlZSBFU1xuICAgICAgICAgICAgICAgICAgLy8gNS4xIHNlY3Rpb24gMTUuOS4xLjIpLiBUaGUgZm9ybXVsYSBgKEEgJSBCICsgQikgJSBCYCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgICAvLyB0byBjb21wdXRlIGBBIG1vZHVsbyBCYCwgYXMgdGhlIGAlYCBvcGVyYXRvciBkb2VzIG5vdFxuICAgICAgICAgICAgICAgICAgLy8gY29ycmVzcG9uZCB0byB0aGUgYG1vZHVsb2Agb3BlcmF0aW9uIGZvciBuZWdhdGl2ZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgdGltZSA9ICh2YWx1ZSAlIDg2NGU1ICsgODY0ZTUpICUgODY0ZTU7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgYXJlIG9idGFpbmVkIGJ5XG4gICAgICAgICAgICAgICAgICAvLyBkZWNvbXBvc2luZyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheS4gU2VlIHNlY3Rpb24gMTUuOS4xLjEwLlxuICAgICAgICAgICAgICAgICAgaG91cnMgPSBmbG9vcih0aW1lIC8gMzZlNSkgJSAyNDtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBmbG9vcih0aW1lIC8gNmU0KSAlIDYwO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IGZsb29yKHRpbWUgLyAxZTMpICUgNjA7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aW1lICUgMWUzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB5ZWFyID0gdmFsdWUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICAgIG1vbnRoID0gdmFsdWUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSB2YWx1ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgICAgICAgICAgICBob3VycyA9IHZhbHVlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gdmFsdWUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IHZhbHVlLmdldFVUQ1NlY29uZHMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gKHllYXIgPD0gMCB8fCB5ZWFyID49IDFlNCA/ICh5ZWFyIDwgMCA/IFwiLVwiIDogXCIrXCIpICsgdG9QYWRkZWRTdHJpbmcoNiwgeWVhciA8IDAgPyAteWVhciA6IHllYXIpIDogdG9QYWRkZWRTdHJpbmcoNCwgeWVhcikpICtcbiAgICAgICAgICAgICAgICAgIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbW9udGggKyAxKSArIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgZGF0ZSkgK1xuICAgICAgICAgICAgICAgICAgLy8gTW9udGhzLCBkYXRlcywgaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzIHNob3VsZCBoYXZlIHR3b1xuICAgICAgICAgICAgICAgICAgLy8gZGlnaXRzOyBtaWxsaXNlY29uZHMgc2hvdWxkIGhhdmUgdGhyZWUuXG4gICAgICAgICAgICAgICAgICBcIlRcIiArIHRvUGFkZGVkU3RyaW5nKDIsIGhvdXJzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbWludXRlcykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIHNlY29uZHMpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNS4wLCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgICAgXCIuXCIgKyB0b1BhZGRlZFN0cmluZygzLCBtaWxsaXNlY29uZHMpICsgXCJaXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT0gXCJmdW5jdGlvblwiICYmICgoY2xhc3NOYW1lICE9IG51bWJlckNsYXNzICYmIGNsYXNzTmFtZSAhPSBzdHJpbmdDbGFzcyAmJiBjbGFzc05hbWUgIT0gYXJyYXlDbGFzcykgfHwgaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkpIHtcbiAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIGFkZHMgbm9uLXN0YW5kYXJkIGB0b0pTT05gIG1ldGhvZHMgdG8gdGhlXG4gICAgICAgICAgICAgIC8vIGBOdW1iZXJgLCBgU3RyaW5nYCwgYERhdGVgLCBhbmQgYEFycmF5YCBwcm90b3R5cGVzLiBKU09OIDNcbiAgICAgICAgICAgICAgLy8gaWdub3JlcyBhbGwgYHRvSlNPTmAgbWV0aG9kcyBvbiB0aGVzZSBvYmplY3RzIHVubGVzcyB0aGV5IGFyZVxuICAgICAgICAgICAgICAvLyBkZWZpbmVkIGRpcmVjdGx5IG9uIGFuIGluc3RhbmNlLlxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gSWYgYSByZXBsYWNlbWVudCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIGNhbGwgaXQgdG8gb2J0YWluIHRoZSB2YWx1ZVxuICAgICAgICAgICAgLy8gZm9yIHNlcmlhbGl6YXRpb24uXG4gICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBib29sZWFuQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEJvb2xlYW5zIGFyZSByZXByZXNlbnRlZCBsaXRlcmFsbHkuXG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIGBJbmZpbml0eWAgYW5kIGBOYU5gIGFyZSBzZXJpYWxpemVkIGFzXG4gICAgICAgICAgICAvLyBgXCJudWxsXCJgLlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDAgPyBcIlwiICsgdmFsdWUgOiBcIm51bGxcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgLy8gU3RyaW5ncyBhcmUgZG91YmxlLXF1b3RlZCBhbmQgZXNjYXBlZC5cbiAgICAgICAgICAgIHJldHVybiBxdW90ZShcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGlzIGlzIGEgbGluZWFyIHNlYXJjaDsgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIC8vIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZiB1bmlxdWUgbmVzdGVkIG9iamVjdHMuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgIGlmIChzdGFja1tsZW5ndGhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIEN5Y2xpYyBzdHJ1Y3R1cmVzIGNhbm5vdCBiZSBzZXJpYWxpemVkIGJ5IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgaW5kZW50IG9uZSBhZGRpdGlvbmFsIGxldmVsLlxuICAgICAgICAgICAgcHJlZml4ID0gaW5kZW50YXRpb247XG4gICAgICAgICAgICBpbmRlbnRhdGlvbiArPSB3aGl0ZXNwYWNlO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBhcnJheSBlbGVtZW50cy5cbiAgICAgICAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gc2VyaWFsaXplKGluZGV4LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW1lbnQgPT09IHVuZGVmID8gXCJudWxsXCIgOiBlbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJbXFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIl1cIiA6IChcIltcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIl1cIikpIDogXCJbXVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdCBtZW1iZXJzLiBNZW1iZXJzIGFyZSBzZWxlY3RlZCBmcm9tXG4gICAgICAgICAgICAgIC8vIGVpdGhlciBhIHVzZXItc3BlY2lmaWVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMsIG9yIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgLy8gaXRzZWxmLlxuICAgICAgICAgICAgICBmb3JFYWNoKHByb3BlcnRpZXMgfHwgdmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2VyaWFsaXplKHByb3BlcnR5LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMzogXCJJZiBgZ2FwYCB7d2hpdGVzcGFjZX1cbiAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgYG1lbWJlcmAge3F1b3RlKHByb3BlcnR5KSArIFwiOlwifVxuICAgICAgICAgICAgICAgICAgLy8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgYG1lbWJlcmAgYW5kIHRoZSBgc3BhY2VgIGNoYXJhY3Rlci5cIlxuICAgICAgICAgICAgICAgICAgLy8gVGhlIFwiYHNwYWNlYCBjaGFyYWN0ZXJcIiByZWZlcnMgdG8gdGhlIGxpdGVyYWwgc3BhY2VcbiAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgbm90IHRoZSBgc3BhY2VgIHt3aWR0aH0gYXJndW1lbnQgcHJvdmlkZWQgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocXVvdGUocHJvcGVydHkpICsgXCI6XCIgKyAod2hpdGVzcGFjZSA/IFwiIFwiIDogXCJcIikgKyBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJ7XFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIn1cIiA6IChcIntcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIn1cIikpIDogXCJ7fVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgdHJhdmVyc2VkIG9iamVjdCBzdGFjay5cbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5zdHJpbmdpZnlgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoc291cmNlLCBmaWx0ZXIsIHdpZHRoKSB7XG4gICAgICAgICAgdmFyIHdoaXRlc3BhY2UsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCBjbGFzc05hbWU7XG4gICAgICAgICAgaWYgKG9iamVjdFR5cGVzW3R5cGVvZiBmaWx0ZXJdICYmIGZpbHRlcikge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKGZpbHRlcikpID09IGZ1bmN0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmaWx0ZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHByb3BlcnR5IG5hbWVzIGFycmF5IGludG8gYSBtYWtlc2hpZnQgc2V0LlxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKSksIGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpICYmIChwcm9wZXJ0aWVzW3ZhbHVlXSA9IDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwod2lkdGgpKSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBgd2lkdGhgIHRvIGFuIGludGVnZXIgYW5kIGNyZWF0ZSBhIHN0cmluZyBjb250YWluaW5nXG4gICAgICAgICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgIGlmICgod2lkdGggLT0gd2lkdGggJSAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHdoaXRlc3BhY2UgPSBcIlwiLCB3aWR0aCA+IDEwICYmICh3aWR0aCA9IDEwKTsgd2hpdGVzcGFjZS5sZW5ndGggPCB3aWR0aDsgd2hpdGVzcGFjZSArPSBcIiBcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAgIHdoaXRlc3BhY2UgPSB3aWR0aC5sZW5ndGggPD0gMTAgPyB3aWR0aCA6IHdpZHRoLnNsaWNlKDAsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIGRpc2NhcmRzIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGVtcHR5IHN0cmluZyBrZXlzXG4gICAgICAgICAgLy8gKGBcIlwiYCkgb25seSBpZiB0aGV5IGFyZSB1c2VkIGRpcmVjdGx5IHdpdGhpbiBhbiBvYmplY3QgbWVtYmVyIGxpc3RcbiAgICAgICAgICAvLyAoZS5nLiwgYCEoXCJcIiBpbiB7IFwiXCI6IDF9KWApLlxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoXCJcIiwgKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gc291cmNlLCB2YWx1ZSksIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBcIlwiLCBbXSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXBhcnNlXCIpKSB7XG4gICAgICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgdW5lc2NhcGVkXG4gICAgICAgIC8vIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgVW5lc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcIixcbiAgICAgICAgICAzNDogJ1wiJyxcbiAgICAgICAgICA0NzogXCIvXCIsXG4gICAgICAgICAgOTg6IFwiXFxiXCIsXG4gICAgICAgICAgMTE2OiBcIlxcdFwiLFxuICAgICAgICAgIDExMDogXCJcXG5cIixcbiAgICAgICAgICAxMDI6IFwiXFxmXCIsXG4gICAgICAgICAgMTE0OiBcIlxcclwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFN0b3JlcyB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICB2YXIgSW5kZXgsIFNvdXJjZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVzZXRzIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93cyBhIGBTeW50YXhFcnJvcmAuXG4gICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmV0dXJucyB0aGUgbmV4dCB0b2tlbiwgb3IgYFwiJFwiYCBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkXG4gICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzdHJpbmcuIEEgdG9rZW4gbWF5IGJlIGEgc3RyaW5nLCBudW1iZXIsIGBudWxsYFxuICAgICAgICAvLyBsaXRlcmFsLCBvciBCb29sZWFuIGxpdGVyYWwuXG4gICAgICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IFNvdXJjZSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aCwgdmFsdWUsIGJlZ2luLCBwb3NpdGlvbiwgaXNTaWduZWQsIGNoYXJDb2RlO1xuICAgICAgICAgIHdoaWxlIChJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UgdG9rZW5zLCBpbmNsdWRpbmcgdGFicywgY2FycmlhZ2UgcmV0dXJucywgbGluZVxuICAgICAgICAgICAgICAgIC8vIGZlZWRzLCBhbmQgc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDEyMzogY2FzZSAxMjU6IGNhc2UgOTE6IGNhc2UgOTM6IGNhc2UgNTg6IGNhc2UgNDQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIChge2AsIGB9YCwgYFtgLCBgXWAsIGA6YCwgb3IgYCxgKSBhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIHZhbHVlID0gY2hhckluZGV4QnVnZ3kgPyBzb3VyY2UuY2hhckF0KEluZGV4KSA6IHNvdXJjZVtJbmRleF07XG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgLy8gYFwiYCBkZWxpbWl0cyBhIEpTT04gc3RyaW5nOyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmRcbiAgICAgICAgICAgICAgICAvLyBiZWdpbiBwYXJzaW5nIHRoZSBzdHJpbmcuIFN0cmluZyB0b2tlbnMgYXJlIHByZWZpeGVkIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgLy8gc2VudGluZWwgYEBgIGNoYXJhY3RlciB0byBkaXN0aW5ndWlzaCB0aGVtIGZyb20gcHVuY3R1YXRvcnMgYW5kXG4gICAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmluZyB0b2tlbnMuXG4gICAgICAgICAgICAgICAgZm9yICh2YWx1ZSA9IFwiQFwiLCBJbmRleCsrOyBJbmRleCA8IGxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5lc2NhcGVkIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycyAodGhvc2Ugd2l0aCBhIGNvZGUgdW5pdFxuICAgICAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gdGhlIHNwYWNlIGNoYXJhY3RlcikgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09IDkyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgcmV2ZXJzZSBzb2xpZHVzIChgXFxgKSBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGFuIGVzY2FwZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udHJvbCBjaGFyYWN0ZXIgKGluY2x1ZGluZyBgXCJgLCBgXFxgLCBhbmQgYC9gKSBvciBVbmljb2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTI6IGNhc2UgMzQ6IGNhc2UgNDc6IGNhc2UgOTg6IGNhc2UgMTE2OiBjYXNlIDExMDogY2FzZSAxMDI6IGNhc2UgMTE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gVW5lc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBcXHVgIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgdmFsaWRhdGUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IGNvZGUgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXggKyA0OyBJbmRleCA8IHBvc2l0aW9uOyBJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHZhbGlkIHNlcXVlbmNlIGNvbXByaXNlcyBmb3VyIGhleGRpZ2l0cyAoY2FzZS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZW5zaXRpdmUpIHRoYXQgZm9ybSBhIHNpbmdsZSBoZXhhZGVjaW1hbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyIHx8IGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZShcIjB4XCIgKyBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBbiB1bmVzY2FwZWQgZG91YmxlLXF1b3RlIGNoYXJhY3RlciBtYXJrcyB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSBhIHN0cmluZyBpcyB2YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJDb2RlID49IDMyICYmIGNoYXJDb2RlICE9IDkyICYmIGNoYXJDb2RlICE9IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHN0cmluZyBhcy1pcy5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZCByZXR1cm4gdGhlIHJldml2ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW50ZXJtaW5hdGVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIG51bWJlcnMgYW5kIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBwYXN0IHRoZSBuZWdhdGl2ZSBzaWduLCBpZiBvbmUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYW4gaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVyb2VzIGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0OCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXggKyAxKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIG9jdGFsIGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGludGVnZXIgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgZm9yICg7IEluZGV4IDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IEluZGV4KyspO1xuICAgICAgICAgICAgICAgICAgLy8gRmxvYXRzIGNhbm5vdCBjb250YWluIGEgbGVhZGluZyBkZWNpbWFsIHBvaW50OyBob3dldmVyLCB0aGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSA0Nikge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBkZWNpbWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIHRyYWlsaW5nIGRlY2ltYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgZXhwb25lbnRzLiBUaGUgYGVgIGRlbm90aW5nIHRoZSBleHBvbmVudCBpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDEwMSB8fCBjaGFyQ29kZSA9PSA2OSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHBhc3QgdGhlIHNpZ24gZm9sbG93aW5nIHRoZSBleHBvbmVudCwgaWYgb25lIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQzIHx8IGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZXhwb25lbnRpYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIGVtcHR5IGV4cG9uZW50LlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgcGFyc2VkIHZhbHVlIHRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gK3NvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIG5lZ2F0aXZlIHNpZ24gbWF5IG9ubHkgcHJlY2VkZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgIGlmIChpc1NpZ25lZCkge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYHRydWVgLCBgZmFsc2VgLCBhbmQgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA1KSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5yZWNvZ25pemVkIHRva2VuLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJldHVybiB0aGUgc2VudGluZWwgYCRgIGNoYXJhY3RlciBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgICAvLyBvZiB0aGUgc291cmNlIHN0cmluZy5cbiAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFBhcnNlcyBhIEpTT04gYHZhbHVlYCB0b2tlbi5cbiAgICAgICAgdmFyIGdldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHRzLCBoYXNNZW1iZXJzO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIiRcIikge1xuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICgoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgPT0gXCJAXCIpIHtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxuICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiW1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxuICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3Npbmcgc3F1YXJlIGJyYWNrZXQgbWFya3MgdGhlIGVuZCBvZiB0aGUgYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYXJyYXkgbGl0ZXJhbCBjb250YWlucyBlbGVtZW50cywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0aW5nIHRoZSBwcmV2aW91cyBlbGVtZW50IGZyb20gdGhlXG4gICAgICAgICAgICAgICAgLy8gbmV4dC5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIGFycmF5IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVsaXNpb25zIGFuZCBsZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChnZXQodmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBvYmplY3QsIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IG9iamVjdC5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIGN1cmx5IGJyYWNlIG1hcmtzIHRoZSBlbmQgb2YgdGhlIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZCwgb2JqZWN0IHByb3BlcnR5IG5hbWVzIG11c3QgYmVcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIGFuZCBhIGA6YCBtdXN0IHNlcGFyYXRlIGVhY2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgICAvLyBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIgfHwgdHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIgfHwgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pICE9IFwiQFwiIHx8IGxleCgpICE9IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzW3ZhbHVlLnNsaWNlKDEpXSA9IGdldChsZXgoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBVcGRhdGVzIGEgdHJhdmVyc2VkIG9iamVjdCBtZW1iZXIuXG4gICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHdhbGsoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZikge1xuICAgICAgICAgICAgZGVsZXRlIHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0gPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgdHJhdmVyc2VzIGEgcGFyc2VkIEpTT04gb2JqZWN0LCBpbnZva2luZyB0aGVcbiAgICAgICAgLy8gYGNhbGxiYWNrYCBmdW5jdGlvbiBmb3IgZWFjaCB2YWx1ZS4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFdhbGsoaG9sZGVyLCBuYW1lKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldLCBsZW5ndGg7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0cyBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGBmYWxzZWBcbiAgICAgICAgICAgIC8vIGZvciBhcnJheSBpbmRpY2VzIChlLmcuLCBgIVsxLCAyLCAzXS5oYXNPd25Qcm9wZXJ0eShcIjBcIilgKS5cbiAgICAgICAgICAgIGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIGZvciAobGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIGxlbmd0aCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzb3VyY2UsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5wYXJzZWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcbiAgICAgICAgICBJbmRleCA9IDA7XG4gICAgICAgICAgU291cmNlID0gXCJcIiArIHNvdXJjZTtcbiAgICAgICAgICByZXN1bHQgPSBnZXQobGV4KCkpO1xuICAgICAgICAgIC8vIElmIGEgSlNPTiBzdHJpbmcgY29udGFpbnMgbXVsdGlwbGUgdG9rZW5zLCBpdCBpcyBpbnZhbGlkLlxuICAgICAgICAgIGlmIChsZXgoKSAhPSBcIiRcIikge1xuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGdldENsYXNzLmNhbGwoY2FsbGJhY2spID09IGZ1bmN0aW9uQ2xhc3MgPyB3YWxrKCh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHJlc3VsdCwgdmFsdWUpLCBcIlwiLCBjYWxsYmFjaykgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0c1tcInJ1bkluQ29udGV4dFwiXSA9IHJ1bkluQ29udGV4dDtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfVxuXG4gIGlmIChmcmVlRXhwb3J0cyAmJiAhaXNMb2FkZXIpIHtcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIGVudmlyb25tZW50cy5cbiAgICBydW5JbkNvbnRleHQocm9vdCwgZnJlZUV4cG9ydHMpO1xuICB9IGVsc2Uge1xuICAgIC8vIEV4cG9ydCBmb3Igd2ViIGJyb3dzZXJzIGFuZCBKYXZhU2NyaXB0IGVuZ2luZXMuXG4gICAgdmFyIG5hdGl2ZUpTT04gPSByb290LkpTT04sXG4gICAgICAgIHByZXZpb3VzSlNPTiA9IHJvb3RbXCJKU09OM1wiXSxcbiAgICAgICAgaXNSZXN0b3JlZCA9IGZhbHNlO1xuXG4gICAgdmFyIEpTT04zID0gcnVuSW5Db250ZXh0KHJvb3QsIChyb290W1wiSlNPTjNcIl0gPSB7XG4gICAgICAvLyBQdWJsaWM6IFJlc3RvcmVzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgZ2xvYmFsIGBKU09OYCBvYmplY3QgYW5kXG4gICAgICAvLyByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgSlNPTjNgIG9iamVjdC5cbiAgICAgIFwibm9Db25mbGljdFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNSZXN0b3JlZCkge1xuICAgICAgICAgIGlzUmVzdG9yZWQgPSB0cnVlO1xuICAgICAgICAgIHJvb3QuSlNPTiA9IG5hdGl2ZUpTT047XG4gICAgICAgICAgcm9vdFtcIkpTT04zXCJdID0gcHJldmlvdXNKU09OO1xuICAgICAgICAgIG5hdGl2ZUpTT04gPSBwcmV2aW91c0pTT04gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OMztcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICByb290LkpTT04gPSB7XG4gICAgICBcInBhcnNlXCI6IEpTT04zLnBhcnNlLFxuICAgICAgXCJzdHJpbmdpZnlcIjogSlNPTjMuc3RyaW5naWZ5XG4gICAgfTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBmb3IgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLlxuICBpZiAoaXNMb2FkZXIpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEpTT04zO1xuICAgIH0pO1xuICB9XG59KS5jYWxsKHRoaXMpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRG9tVXRpbHMuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cblx0LyoqXG5cdCAqIEEgZmV3IHV0aWxpdGllcyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgZG9tLlxuXHQgKiBAY2xhc3MgRG9tVXRpbHNcblx0ICovXG5cdHZhciBzID0ge307XG5cblx0cy5hcHBlbmRUb0hlYWQgPSBmdW5jdGlvbiAoZWwpIHtcblx0XHRzLmdldEhlYWQoKS5hcHBlbmRDaGlsZChlbClcblx0fVxuXG5cdHMuZ2V0SGVhZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG5cdH1cblxuXHRzLmdldEJvZHkgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJib2R5XCIpWzBdO1xuXHR9XG5cblx0Y3JlYXRlanMuRG9tVXRpbHMgPSBzO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRGF0YVV0aWxzLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXG5cdC8qKlxuXHQgKiBBIGZldyBkYXRhIHV0aWxpdGllcyBmb3IgZm9ybWF0dGluZyBkaWZmZXJlbnQgZGF0YSB0eXBlcy5cblx0ICogQGNsYXNzIERhdGFVdGlsc1xuXHQgKi9cblx0dmFyIHMgPSB7fTtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogUGFyc2UgWE1MIHVzaW5nIHRoZSBET00uIFRoaXMgaXMgcmVxdWlyZWQgd2hlbiBwcmVsb2FkaW5nIFhNTCBvciBTVkcuXG5cdCAqIEBtZXRob2QgcGFyc2VYTUxcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIHJhdyB0ZXh0IG9yIFhNTCB0aGF0IGlzIGxvYWRlZCBieSBYSFIuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBtaW1lIHR5cGUgb2YgdGhlIFhNTC4gVXNlIFwidGV4dC94bWxcIiBmb3IgWE1MLCBhbmQgIFwiaW1hZ2Uvc3ZnK3htbFwiIGZvciBTVkcgcGFyc2luZy5cblx0ICogQHJldHVybiB7WE1MfSBBbiBYTUwgZG9jdW1lbnRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5wYXJzZVhNTCA9IGZ1bmN0aW9uICh0ZXh0LCB0eXBlKSB7XG5cdFx0dmFyIHhtbCA9IG51bGw7XG5cdFx0Ly8gQ29jb29uSlMgZG9lcyBub3Qgc3VwcG9ydCBYTUwgcGFyc2luZyB3aXRoIGVpdGhlciBtZXRob2QuXG5cblx0XHQvLyBNb3N0IGJyb3dzZXJzIHdpbGwgdXNlIERPTVBhcnNlclxuXHRcdC8vIElFIGZhaWxzIG9uIGNlcnRhaW4gU1ZHIGZpbGVzLCBzbyB3ZSBoYXZlIGEgZmFsbGJhY2sgYmVsb3cuXG5cdFx0dHJ5IHtcblx0XHRcdGlmICh3aW5kb3cuRE9NUGFyc2VyKSB7XG5cdFx0XHRcdHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG5cdFx0XHRcdHhtbCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodGV4dCwgdHlwZSk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIGZvciBJRSBzdXBwb3J0LlxuXHRcdGlmICgheG1sKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR4bWwgPSBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxET01cIik7XG5cdFx0XHRcdHhtbC5hc3luYyA9IGZhbHNlO1xuXHRcdFx0XHR4bWwubG9hZFhNTCh0ZXh0KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0eG1sID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4geG1sO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXJzZSBhIHN0cmluZyBpbnRvIGFuIE9iamVjdC5cblx0ICogQG1ldGhvZCBwYXJzZUpTT05cblx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSBsb2FkZWQgSlNPTiBzdHJpbmdcblx0ICogQHJldHVybnMge09iamVjdH0gQSBKYXZhU2NyaXB0IG9iamVjdC5cblx0ICovXG5cdHMucGFyc2VKU09OID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Ly8gVE9ETzsgSGFuZGxlIHRoaXMgd2l0aCBhIGN1c3RvbSBlcnJvcj9cblx0XHRcdHRocm93IGU7XG5cdFx0fVxuXHR9O1xuXG5cdGNyZWF0ZWpzLkRhdGFVdGlscyA9IHM7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBMb2FkSXRlbS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBBbGwgbG9hZGVycyBhY2NlcHQgYW4gaXRlbSBjb250YWluaW5nIHRoZSBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhpcyBjbGFzcy4gSWYgYSByYXcgb2JqZWN0IGlzIHBhc3NlZCBpbnN0ZWFkLFxuXHQgKiBpdCB3aWxsIG5vdCBiZSBhZmZlY3RlZCwgYnV0IGl0IG11c3QgY29udGFpbiBhdCBsZWFzdCBhIHt7I2Nyb3NzTGluayBcInNyYzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eS4gQVxuXHQgKiBzdHJpbmcgcGF0aCBvciBIVE1MIHRhZyBpcyBhbHNvIGFjY2VwdGFibGUsIGJ1dCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGEgTG9hZEl0ZW0gdXNpbmcgdGhlXG5cdCAqIHt7I2Nyb3NzTGluayBcImNyZWF0ZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgYnkge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogQGNsYXNzIExvYWRJdGVtXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdGZ1bmN0aW9uIExvYWRJdGVtKCkge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBzb3VyY2Ugb2YgdGhlIGZpbGUgdGhhdCBpcyBiZWluZyBsb2FkZWQuIFRoaXMgcHJvcGVydHkgaXMgPGI+cmVxdWlyZWQ8L2I+LiBUaGUgc291cmNlIGNhbiBlaXRoZXIgYmUgYVxuXHRcdCAqIHN0cmluZyAocmVjb21tZW5kZWQpLCBvciBhbiBIVE1MIHRhZy5cblx0XHQgKiBUaGlzIGNhbiBhbHNvIGJlIGFuIG9iamVjdCwgYnV0IGluIHRoYXQgY2FzZSBpdCBoYXMgdG8gaW5jbHVkZSBhIHR5cGUgYW5kIGJlIGhhbmRsZWQgYnkgYSBwbHVnaW4uXG5cdFx0ICogQHByb3BlcnR5IHNyY1xuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuc3JjID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIGZpbGUgdGhhdCBpcyBiZWluZyBsb2FkZWQuIFRoZSB0eXBlIG9mIHRoZSBmaWxlIGlzIHVzdWFsbHkgaW5mZXJyZWQgYnkgdGhlIGV4dGVuc2lvbiwgYnV0IGNhbiBhbHNvXG5cdFx0ICogYmUgc2V0IG1hbnVhbGx5LiBUaGlzIGlzIGhlbHBmdWwgaW4gY2FzZXMgd2hlcmUgYSBmaWxlIGRvZXMgbm90IGhhdmUgYW4gZXh0ZW5zaW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSB0eXBlXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy50eXBlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIGlkZW50aWZpZXIgd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmVmZXJlbmNlIHRoZSBsb2FkZWQgb2JqZWN0LiBJZiBub25lIGlzIHByb3ZpZGVkLCB0aGlzIHdpbGwgYmVcblx0XHQgKiBhdXRvbWF0aWNhbGx5IHNldCB0byB0aGUge3sjY3Jvc3NMaW5rIFwic3JjOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBpZFxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuaWQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lcyBpZiBhIG1hbmlmZXN0IHdpbGwgbWFpbnRhaW4gdGhlIG9yZGVyIG9mIHRoaXMgaXRlbSwgaW4gcmVsYXRpb24gdG8gb3RoZXIgaXRlbXMgaW4gdGhlIG1hbmlmZXN0XG5cdFx0ICogdGhhdCBoYXZlIGFsc28gc2V0IHRoZSBgbWFpbnRhaW5PcmRlcmAgcHJvcGVydHkgdG8gYHRydWVgLiBUaGlzIG9ubHkgYXBwbGllcyB3aGVuIHRoZSBtYXggY29ubmVjdGlvbnMgaGFzXG5cdFx0ICogYmVlbiBzZXQgYWJvdmUgMSAodXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldE1heENvbm5lY3Rpb25zXCJ9fXt7L2Nyb3NzTGlua319KS4gRXZlcnl0aGluZyB3aXRoIHRoaXNcblx0XHQgKiBwcm9wZXJ0eSBzZXQgdG8gYGZhbHNlYCB3aWxsIGZpbmlzaCBhcyBpdCBpcyBsb2FkZWQuIE9yZGVyZWQgaXRlbXMgYXJlIGNvbWJpbmVkIHdpdGggc2NyaXB0IHRhZ3MgbG9hZGluZyBpblxuXHRcdCAqIG9yZGVyIHdoZW4ge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL21haW50YWluU2NyaXB0T3JkZXI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaXMgc2V0IHRvIGB0cnVlYC5cblx0XHQgKiBAcHJvcGVydHkgbWFpbnRhaW5PcmRlclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5tYWludGFpbk9yZGVyID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBBIGNhbGxiYWNrIHVzZWQgYnkgSlNPTlAgcmVxdWVzdHMgdGhhdCBkZWZpbmVzIHdoYXQgZ2xvYmFsIG1ldGhvZCB0byBjYWxsIHdoZW4gdGhlIEpTT05QIGNvbnRlbnQgaXMgbG9hZGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBjYWxsYmFja1xuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gYXJiaXRyYXJ5IGRhdGEgb2JqZWN0LCB3aGljaCBpcyBpbmNsdWRlZCB3aXRoIHRoZSBsb2FkZWQgb2JqZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBkYXRhXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5kYXRhID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByZXF1ZXN0IG1ldGhvZCB1c2VkIGZvciBIVFRQIGNhbGxzLiBCb3RoIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0dFVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBvclxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1BPU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcmVxdWVzdCB0eXBlcyBhcmUgc3VwcG9ydGVkLCBhbmQgYXJlIGRlZmluZWQgYXNcblx0XHQgKiBjb25zdGFudHMgb24ge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IG1ldGhvZFxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgZ2V0XG5cdFx0ICovXG5cdFx0dGhpcy5tZXRob2QgPSBjcmVhdGVqcy5Mb2FkSXRlbS5HRVQ7XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiBuYW1lL3ZhbHVlIHBhaXJzIHRvIHNlbmQgdG8gdGhlIHNlcnZlci5cblx0XHQgKiBAcHJvcGVydHkgdmFsdWVzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy52YWx1ZXMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IGhhc2ggb2YgaGVhZGVycyB0byBhdHRhY2ggdG8gYW4gWEhSIHJlcXVlc3QuIFByZWxvYWRKUyB3aWxsIGF1dG9tYXRpY2FsbHkgYXR0YWNoIHNvbWUgZGVmYXVsdFxuXHRcdCAqIGhlYWRlcnMgd2hlbiByZXF1aXJlZCwgaW5jbHVkaW5nIFwiT3JpZ2luXCIsIFwiQ29udGVudC1UeXBlXCIsIGFuZCBcIlgtUmVxdWVzdGVkLVdpdGhcIi4gWW91IG1heSBvdmVycmlkZSB0aGVcblx0XHQgKiBkZWZhdWx0IGhlYWRlcnMgYnkgaW5jbHVkaW5nIHRoZW0gaW4geW91ciBoZWFkZXJzIG9iamVjdC5cblx0XHQgKiBAcHJvcGVydHkgaGVhZGVyc1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuaGVhZGVycyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBFbmFibGUgY3JlZGVudGlhbHMgZm9yIFhIUiByZXF1ZXN0cy5cblx0XHQgKiBAcHJvcGVydHkgd2l0aENyZWRlbnRpYWxzXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBtaW1lIHR5cGUgb2YgWEhSLWJhc2VkIHJlcXVlc3RzLiBUaGlzIGlzIGF1dG9tYXRpY2FsbHkgc2V0IHRvIFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiIGZvciB0ZXh0XG5cdFx0ICogYmFzZWQgZmlsZXMgKGpzb24sIHhtbCwgdGV4dCwgY3NzLCBqcykuXG5cdFx0ICogQHByb3BlcnR5IG1pbWVUeXBlXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5taW1lVHlwZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBTZXRzIHRoZSBjcm9zc09yaWdpbiBhdHRyaWJ1dGUgZm9yIENPUlMtZW5hYmxlZCBpbWFnZXMgbG9hZGluZyBjcm9zcy1kb21haW4uXG5cdFx0ICogQHByb3BlcnR5IGNyb3NzT3JpZ2luXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgQW5vbnltb3VzXG5cdFx0ICovXG5cdFx0dGhpcy5jcm9zc09yaWdpbiA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIGEgcmVxdWVzdCB0aW1lcyBvdXQuIFRoaXMgb25seSBhcHBsaWVzIHRvIHRhZy1iYXNlZCBhbmQgYW5kIFhIUlxuXHRcdCAqIChsZXZlbCBvbmUpIGxvYWRpbmcsIGFzIFhIUiAobGV2ZWwgMikgcHJvdmlkZXMgaXRzIG93biB0aW1lb3V0IGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBsb2FkVGltZW91dFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgODAwMCAoOCBzZWNvbmRzKVxuXHRcdCAqL1xuXHRcdHRoaXMubG9hZFRpbWVvdXQgPSBzLkxPQURfVElNRU9VVF9ERUZBVUxUO1xuXHR9O1xuXG5cdHZhciBwID0gTG9hZEl0ZW0ucHJvdG90eXBlID0ge307XG5cdHZhciBzID0gTG9hZEl0ZW07XG5cblx0LyoqXG5cdCAqIERlZmF1bHQgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIGEgcmVxdWVzdCB0aW1lcyBvdXQuIFRoaXMgb25seSBhcHBsaWVzIHRvIHRhZy1iYXNlZCBhbmQgYW5kIFhIUlxuXHQgKiAobGV2ZWwgb25lKSBsb2FkaW5nLCBhcyBYSFIgKGxldmVsIDIpIHByb3ZpZGVzIGl0cyBvd24gdGltZW91dCBldmVudC5cblx0ICogQHByb3BlcnR5IExPQURfVElNRU9VVF9ERUZBVUxUXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuTE9BRF9USU1FT1VUX0RFRkFVTFQgPSA4MDAwO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBMb2FkSXRlbS5cblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPlN0cmluZy1iYXNlZCBpdGVtcyBhcmUgY29udmVydGVkIHRvIGEgTG9hZEl0ZW0gd2l0aCBhIHBvcHVsYXRlZCB7eyNjcm9zc0xpbmsgXCJzcmM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uPC9saT5cblx0ICogICAgIDxsaT5Mb2FkSXRlbSBpbnN0YW5jZXMgYXJlIHJldHVybmVkIGFzLWlzPC9saT5cblx0ICogICAgIDxsaT5PYmplY3RzIGFyZSByZXR1cm5lZCB3aXRoIGFueSBuZWVkZWQgcHJvcGVydGllcyBhZGRlZDwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIEBtZXRob2QgY3JlYXRlXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18U3RyaW5nfE9iamVjdH0gdmFsdWUgVGhlIGxvYWQgaXRlbSB2YWx1ZVxuXHQgKiBAcmV0dXJucyB7TG9hZEl0ZW18T2JqZWN0fVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0dmFyIGl0ZW0gPSBuZXcgTG9hZEl0ZW0oKTtcblx0XHRcdGl0ZW0uc3JjID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gaXRlbTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2Ygcykge1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QgJiYgdmFsdWUuc3JjKSB7XG5cdFx0XHRpZiAodmFsdWUubG9hZFRpbWVvdXQgPT0gbnVsbCkge1xuXHRcdFx0XHR2YWx1ZS5sb2FkVGltZW91dCA9IHMuTE9BRF9USU1FT1VUX0RFRkFVTFQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlR5cGUgbm90IHJlY29nbml6ZWQuXCIpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUHJvdmlkZXMgYSBjaGFpbmFibGUgc2hvcnRjdXQgbWV0aG9kIGZvciBzZXR0aW5nIGEgbnVtYmVyIG9mIHByb3BlcnRpZXMgb24gdGhlIGluc3RhbmNlLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIGxvYWRJdGVtID0gbmV3IGNyZWF0ZWpzLkxvYWRJdGVtKCkuc2V0KHtzcmM6XCJpbWFnZS5wbmdcIiwgbWFpbnRhaW5PcmRlcjp0cnVlfSk7XG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBBIGdlbmVyaWMgb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBjb3B5IHRvIHRoZSBMb2FkSXRlbSBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7TG9hZEl0ZW19IFJldHVybnMgdGhlIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0Ki9cblx0cC5zZXQgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdGZvciAodmFyIG4gaW4gcHJvcHMpIHsgdGhpc1tuXSA9IHByb3BzW25dOyB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0Y3JlYXRlanMuTG9hZEl0ZW0gPSBzO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gUmVxdWVzdFV0aWxzLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4oZnVuY3Rpb24gKCkge1xuXG5cdC8qKlxuXHQgKiBVdGlsaXRpZXMgdGhhdCBhc3Npc3Qgd2l0aCBwYXJzaW5nIGxvYWQgaXRlbXMsIGFuZCBkZXRlcm1pbmluZyBmaWxlIHR5cGVzLCBldGMuXG5cdCAqIEBjbGFzcyBSZXF1ZXN0VXRpbHNcblx0ICovXG5cdHZhciBzID0ge307XG5cblx0LyoqXG5cdCAqIFRoZSBSZWd1bGFyIEV4cHJlc3Npb24gdXNlZCB0byB0ZXN0IGZpbGUgVVJMUyBmb3IgYW4gYWJzb2x1dGUgcGF0aC5cblx0ICogQHByb3BlcnR5IEFCU09MVVRFX1BBVEhcblx0ICogQHR5cGUge1JlZ0V4cH1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5BQlNPTFVURV9QQVRUID0gL14oPzpcXHcrOik/XFwvezJ9L2k7XG5cblx0LyoqXG5cdCAqIFRoZSBSZWd1bGFyIEV4cHJlc3Npb24gdXNlZCB0byB0ZXN0IGZpbGUgVVJMUyBmb3IgYSByZWxhdGl2ZSBwYXRoLlxuXHQgKiBAcHJvcGVydHkgUkVMQVRJVkVfUEFUSFxuXHQgKiBAdHlwZSB7UmVnRXhwfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLlJFTEFUSVZFX1BBVFQgPSAoL15bLi9dKj9cXC8vaSk7XG5cblx0LyoqXG5cdCAqIFRoZSBSZWd1bGFyIEV4cHJlc3Npb24gdXNlZCB0byB0ZXN0IGZpbGUgVVJMUyBmb3IgYW4gZXh0ZW5zaW9uLiBOb3RlIHRoYXQgVVJJcyBtdXN0IGFscmVhZHkgaGF2ZSB0aGUgcXVlcnkgc3RyaW5nXG5cdCAqIHJlbW92ZWQuXG5cdCAqIEBwcm9wZXJ0eSBFWFRFTlNJT05fUEFUVFxuXHQgKiBAdHlwZSB7UmVnRXhwfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLkVYVEVOU0lPTl9QQVRUID0gL1xcLz9bXi9dK1xcLihcXHd7MSw1fSkkL2k7XG5cblx0LyoqXG5cdCAqIFBhcnNlIGEgZmlsZSBwYXRoIHRvIGRldGVybWluZSB0aGUgaW5mb3JtYXRpb24gd2UgbmVlZCB0byB3b3JrIHdpdGggaXQuIEN1cnJlbnRseSwgUHJlbG9hZEpTIG5lZWRzIHRvIGtub3c6XG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5JZiB0aGUgcGF0aCBpcyBhYnNvbHV0ZS4gQWJzb2x1dGUgcGF0aHMgc3RhcnQgd2l0aCBhIHByb3RvY29sIChzdWNoIGFzIGBodHRwOi8vYCwgYGZpbGU6Ly9gLCBvclxuXHQgKiAgICAgYC8vbmV0d29ya1BhdGhgKTwvbGk+XG5cdCAqICAgICA8bGk+SWYgdGhlIHBhdGggaXMgcmVsYXRpdmUuIFJlbGF0aXZlIHBhdGhzIHN0YXJ0IHdpdGggYC4uL2Agb3IgYC9wYXRoYCAob3Igc2ltaWxhcik8L2xpPlxuXHQgKiAgICAgPGxpPlRoZSBmaWxlIGV4dGVuc2lvbi4gVGhpcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBmaWxlbmFtZSB3aXRoIGFuIGV4dGVuc2lvbi4gUXVlcnkgc3RyaW5ncyBhcmUgZHJvcHBlZCwgYW5kXG5cdCAqICAgICB0aGUgZmlsZSBwYXRoIGlzIGV4cGVjdGVkIHRvIGZvbGxvdyB0aGUgZm9ybWF0IGBuYW1lLmV4dGAuPC9saT5cblx0ICogPC91bD5cblx0ICogQG1ldGhvZCBwYXJzZVVSSVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBPYmplY3Qgd2l0aCBhbiBgYWJzb2x1dGVgIGFuZCBgcmVsYXRpdmVgIEJvb2xlYW4gdmFsdWVzLCBhcyB3ZWxsIGFzIGFuIG9wdGlvbmFsICdleHRlbnNpb25gXG5cdCAqIHByb3BlcnR5LCB3aGljaCBpcyB0aGUgbG93ZXJjYXNlIGV4dGVuc2lvbi5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5wYXJzZVVSSSA9IGZ1bmN0aW9uIChwYXRoKSB7XG5cdFx0dmFyIGluZm8gPSB7YWJzb2x1dGU6IGZhbHNlLCByZWxhdGl2ZTogZmFsc2V9O1xuXHRcdGlmIChwYXRoID09IG51bGwpIHsgcmV0dXJuIGluZm87IH1cblxuXHRcdC8vIERyb3AgdGhlIHF1ZXJ5IHN0cmluZ1xuXHRcdHZhciBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKFwiP1wiKTtcblx0XHRpZiAocXVlcnlJbmRleCA+IC0xKSB7XG5cdFx0XHRwYXRoID0gcGF0aC5zdWJzdHIoMCwgcXVlcnlJbmRleCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJzb2x1dGVcblx0XHR2YXIgbWF0Y2g7XG5cdFx0aWYgKHMuQUJTT0xVVEVfUEFUVC50ZXN0KHBhdGgpKSB7XG5cdFx0XHRpbmZvLmFic29sdXRlID0gdHJ1ZTtcblxuXHRcdFx0Ly8gUmVsYXRpdmVcblx0XHR9IGVsc2UgaWYgKHMuUkVMQVRJVkVfUEFUVC50ZXN0KHBhdGgpKSB7XG5cdFx0XHRpbmZvLnJlbGF0aXZlID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBFeHRlbnNpb25cblx0XHRpZiAobWF0Y2ggPSBwYXRoLm1hdGNoKHMuRVhURU5TSU9OX1BBVFQpKSB7XG5cdFx0XHRpbmZvLmV4dGVuc2lvbiA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBpbmZvO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBGb3JtYXRzIGFuIG9iamVjdCBpbnRvIGEgcXVlcnkgc3RyaW5nIGZvciBlaXRoZXIgYSBQT1NUIG9yIEdFVCByZXF1ZXN0LlxuXHQgKiBAbWV0aG9kIGZvcm1hdFF1ZXJ5U3RyaW5nXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBkYXRhIHRvIGNvbnZlcnQgdG8gYSBxdWVyeSBzdHJpbmcuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtxdWVyeV0gRXhpc3RpbmcgbmFtZS92YWx1ZSBwYWlycyB0byBhcHBlbmQgb24gdG8gdGhpcyBxdWVyeS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5mb3JtYXRRdWVyeVN0cmluZyA9IGZ1bmN0aW9uIChkYXRhLCBxdWVyeSkge1xuXHRcdGlmIChkYXRhID09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBkYXRhLicpO1xuXHRcdH1cblx0XHR2YXIgcGFyYW1zID0gW107XG5cdFx0Zm9yICh2YXIgbiBpbiBkYXRhKSB7XG5cdFx0XHRwYXJhbXMucHVzaChuICsgJz0nICsgZXNjYXBlKGRhdGFbbl0pKTtcblx0XHR9XG5cdFx0aWYgKHF1ZXJ5KSB7XG5cdFx0XHRwYXJhbXMgPSBwYXJhbXMuY29uY2F0KHF1ZXJ5KTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcmFtcy5qb2luKCcmJyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEEgdXRpbGl0eSBtZXRob2QgdGhhdCBidWlsZHMgYSBmaWxlIHBhdGggdXNpbmcgYSBzb3VyY2UgYW5kIGEgZGF0YSBvYmplY3QsIGFuZCBmb3JtYXRzIGl0IGludG8gYSBuZXcgcGF0aC5cblx0ICogQG1ldGhvZCBidWlsZFBhdGhcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyYyBUaGUgc291cmNlIHBhdGggdG8gYWRkIHZhbHVlcyB0by5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXSBPYmplY3QgdXNlZCB0byBhcHBlbmQgdmFsdWVzIHRvIHRoaXMgcmVxdWVzdCBhcyBhIHF1ZXJ5IHN0cmluZy4gRXhpc3RpbmcgcGFyYW1ldGVycyBvbiB0aGVcblx0ICogcGF0aCB3aWxsIGJlIHByZXNlcnZlZC5cblx0ICogQHJldHVybnMge3N0cmluZ30gQSBmb3JtYXR0ZWQgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIHBhdGggYW5kIHRoZSBzdXBwbGllZCBwYXJhbWV0ZXJzLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChzcmMsIGRhdGEpIHtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gc3JjO1xuXHRcdH1cblxuXHRcdHZhciBxdWVyeSA9IFtdO1xuXHRcdHZhciBpZHggPSBzcmMuaW5kZXhPZignPycpO1xuXG5cdFx0aWYgKGlkeCAhPSAtMSkge1xuXHRcdFx0dmFyIHEgPSBzcmMuc2xpY2UoaWR4ICsgMSk7XG5cdFx0XHRxdWVyeSA9IHF1ZXJ5LmNvbmNhdChxLnNwbGl0KCcmJykpO1xuXHRcdH1cblxuXHRcdGlmIChpZHggIT0gLTEpIHtcblx0XHRcdHJldHVybiBzcmMuc2xpY2UoMCwgaWR4KSArICc/JyArIHRoaXMuX2Zvcm1hdFF1ZXJ5U3RyaW5nKGRhdGEsIHF1ZXJ5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHNyYyArICc/JyArIHRoaXMuX2Zvcm1hdFF1ZXJ5U3RyaW5nKGRhdGEsIHF1ZXJ5KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgaXNDcm9zc0RvbWFpblxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBBIGxvYWQgaXRlbSB3aXRoIGEgYHNyY2AgcHJvcGVydHkuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBsb2FkIGl0ZW0gaXMgbG9hZGluZyBmcm9tIGEgZGlmZmVyZW50IGRvbWFpbiB0aGFuIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzQ3Jvc3NEb21haW4gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHZhciB0YXJnZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcblx0XHR0YXJnZXQuaHJlZiA9IGl0ZW0uc3JjO1xuXG5cdFx0dmFyIGhvc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcblx0XHRob3N0LmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG5cdFx0dmFyIGNyb3NzZG9tYWluID0gKHRhcmdldC5ob3N0bmFtZSAhPSBcIlwiKSAmJlxuXHRcdFx0XHRcdFx0ICAodGFyZ2V0LnBvcnQgIT0gaG9zdC5wb3J0IHx8XG5cdFx0XHRcdFx0XHQgICB0YXJnZXQucHJvdG9jb2wgIT0gaG9zdC5wcm90b2NvbCB8fFxuXHRcdFx0XHRcdFx0ICAgdGFyZ2V0Lmhvc3RuYW1lICE9IGhvc3QuaG9zdG5hbWUpO1xuXHRcdHJldHVybiBjcm9zc2RvbWFpbjtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBpc0xvY2FsXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIEEgbG9hZCBpdGVtIHdpdGggYSBgc3JjYCBwcm9wZXJ0eVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgbG9hZCBpdGVtIGlzIGxvYWRpbmcgZnJvbSB0aGUgXCJmaWxlOlwiIHByb3RvY29sLiBBc3N1bWUgdGhhdCB0aGUgaG9zdCBtdXN0IGJlIGxvY2FsIGFzXG5cdCAqIHdlbGwuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNMb2NhbCA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0dmFyIHRhcmdldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXHRcdHRhcmdldC5ocmVmID0gaXRlbS5zcmM7XG5cdFx0cmV0dXJuIHRhcmdldC5ob3N0bmFtZSA9PSBcIlwiICYmIHRhcmdldC5wcm90b2NvbCA9PSBcImZpbGU6XCI7XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSBpZiBhIHNwZWNpZmljIHR5cGUgc2hvdWxkIGJlIGxvYWRlZCBhcyBhIGJpbmFyeSBmaWxlLiBDdXJyZW50bHksIG9ubHkgaW1hZ2VzIGFuZCBpdGVtcyBtYXJrZWRcblx0ICogc3BlY2lmaWNhbGx5IGFzIFwiYmluYXJ5XCIgYXJlIGxvYWRlZCBhcyBiaW5hcnkuIE5vdGUgdGhhdCBhdWRpbyBpcyA8Yj5ub3Q8L2I+IGEgYmluYXJ5IHR5cGUsIGFzIHdlIGNhbiBub3QgcGxheVxuXHQgKiBiYWNrIHVzaW5nIGFuIGF1ZGlvIHRhZyBpZiBpdCBpcyBsb2FkZWQgYXMgYmluYXJ5LiBQbHVnaW5zIGNhbiBjaGFuZ2UgdGhlIGl0ZW0gdHlwZSB0byBiaW5hcnkgdG8gZW5zdXJlIHRoZXkgZ2V0XG5cdCAqIGEgYmluYXJ5IHJlc3VsdCB0byB3b3JrIHdpdGguIEJpbmFyeSBmaWxlcyBhcmUgbG9hZGVkIHVzaW5nIFhIUjIuIFR5cGVzIGFyZSBkZWZpbmVkIGFzIHN0YXRpYyBjb25zdGFudHMgb25cblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgaXNCaW5hcnlcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGl0ZW0gdHlwZS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIHNwZWNpZmllZCB0eXBlIGlzIGJpbmFyeS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pc0JpbmFyeSA9IGZ1bmN0aW9uICh0eXBlKSB7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLklNQUdFOlxuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5CSU5BUlk6XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgaXRlbSBpcyBhIHZhbGlkIEhUTUxJbWFnZUVsZW1lbnRcblx0ICogQG1ldGhvZCBpc0ltYWdlVGFnXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzSW1hZ2VUYWcgPSBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0gaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBpdGVtIGlzIGEgdmFsaWQgSFRNTEF1ZGlvRWxlbWVudFxuXHQgKiBAbWV0aG9kIGlzQXVkaW9UYWdcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cblx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNBdWRpb1RhZyA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRpZiAod2luZG93LkhUTUxBdWRpb0VsZW1lbnQpIHtcblx0XHRcdHJldHVybiBpdGVtIGluc3RhbmNlb2YgSFRNTEF1ZGlvRWxlbWVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgaXRlbSBpcyBhIHZhbGlkIEhUTUxWaWRlb0VsZW1lbnRcblx0ICogQG1ldGhvZCBpc1ZpZGVvVGFnXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzVmlkZW9UYWcgPSBmdW5jdGlvbihpdGVtKSB7XG5cdFx0aWYgKHdpbmRvdy5IVE1MVmlkZW9FbGVtZW50KSB7XG5cdFx0XHRyZXR1cm4gaXRlbSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSBpZiBhIHNwZWNpZmljIHR5cGUgaXMgYSB0ZXh0LWJhc2VkIGFzc2V0LCBhbmQgc2hvdWxkIGJlIGxvYWRlZCBhcyBVVEYtOC5cblx0ICogQG1ldGhvZCBpc1RleHRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGl0ZW0gdHlwZS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIHNwZWNpZmllZCB0eXBlIGlzIHRleHQuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNUZXh0ID0gZnVuY3Rpb24gKHR5cGUpIHtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVEVYVDpcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTjpcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuTUFOSUZFU1Q6XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlhNTDpcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuQ1NTOlxuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TVkc6XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpBVkFTQ1JJUFQ6XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNQUklURVNIRUVUOlxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSB0aGUgdHlwZSBvZiB0aGUgb2JqZWN0IHVzaW5nIGNvbW1vbiBleHRlbnNpb25zLiBOb3RlIHRoYXQgdGhlIHR5cGUgY2FuIGJlIHBhc3NlZCBpbiB3aXRoIHRoZSBsb2FkIGl0ZW1cblx0ICogaWYgaXQgaXMgYW4gdW51c3VhbCBleHRlbnNpb24uXG5cdCAqIEBtZXRob2QgZ2V0VHlwZUJ5RXh0ZW5zaW9uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBleHRlbnNpb24gVGhlIGZpbGUgZXh0ZW5zaW9uIHRvIHVzZSB0byBkZXRlcm1pbmUgdGhlIGxvYWQgdHlwZS5cblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgZGV0ZXJtaW5lZCBsb2FkIHR5cGUgKGZvciBleGFtcGxlLCA8Y29kZT5BYnN0cmFjdExvYWRlci5JTUFHRTwvY29kZT4pLiBXaWxsIHJldHVybiBgbnVsbGAgaWZcblx0ICogdGhlIHR5cGUgY2FuIG5vdCBiZSBkZXRlcm1pbmVkIGJ5IHRoZSBleHRlbnNpb24uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuZ2V0VHlwZUJ5RXh0ZW5zaW9uID0gZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuXHRcdGlmIChleHRlbnNpb24gPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlRFWFQ7XG5cdFx0fVxuXG5cdFx0c3dpdGNoIChleHRlbnNpb24udG9Mb3dlckNhc2UoKSkge1xuXHRcdFx0Y2FzZSBcImpwZWdcIjpcblx0XHRcdGNhc2UgXCJqcGdcIjpcblx0XHRcdGNhc2UgXCJnaWZcIjpcblx0XHRcdGNhc2UgXCJwbmdcIjpcblx0XHRcdGNhc2UgXCJ3ZWJwXCI6XG5cdFx0XHRjYXNlIFwiYm1wXCI6XG5cdFx0XHRcdHJldHVybiBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5JTUFHRTtcblx0XHRcdGNhc2UgXCJvZ2dcIjpcblx0XHRcdGNhc2UgXCJtcDNcIjpcblx0XHRcdGNhc2UgXCJ3ZWJtXCI6XG5cdFx0XHRcdHJldHVybiBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TT1VORDtcblx0XHRcdGNhc2UgXCJtcDRcIjpcblx0XHRcdGNhc2UgXCJ3ZWJtXCI6XG5cdFx0XHRjYXNlIFwidHNcIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlZJREVPO1xuXHRcdFx0Y2FzZSBcImpzb25cIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpTT047XG5cdFx0XHRjYXNlIFwieG1sXCI6XG5cdFx0XHRcdHJldHVybiBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5YTUw7XG5cdFx0XHRjYXNlIFwiY3NzXCI6XG5cdFx0XHRcdHJldHVybiBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5DU1M7XG5cdFx0XHRjYXNlIFwianNcIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpBVkFTQ1JJUFQ7XG5cdFx0XHRjYXNlICdzdmcnOlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU1ZHO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlRFWFQ7XG5cdFx0fVxuXHR9O1xuXG5cdGNyZWF0ZWpzLlJlcXVlc3RVdGlscyA9IHM7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBBYnN0cmFjdExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG4vLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogVGhlIGJhc2UgbG9hZGVyLCB3aGljaCBkZWZpbmVzIGFsbCB0aGUgZ2VuZXJpYyBtZXRob2RzLCBwcm9wZXJ0aWVzLCBhbmQgZXZlbnRzLiBBbGwgbG9hZGVycyBleHRlbmQgdGhpcyBjbGFzcyxcblx0ICogaW5jbHVkaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBjbGFzcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfG9iamVjdHxzdHJpbmd9IGxvYWRJdGVtIFRoZSBpdGVtIHRvIGJlIGxvYWRlZC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcHJlZmVyWEhSXSBEZXRlcm1pbmVzIGlmIHRoZSBMb2FkSXRlbSBzaG91bGQgPGVtPnRyeTwvZW0+IGFuZCBsb2FkIHVzaW5nIFhIUiwgb3IgdGFrZSBhXG5cdCAqIHRhZy1iYXNlZCBhcHByb2FjaCwgd2hpY2ggY2FuIGJlIGJldHRlciBpbiBjcm9zcy1kb21haW4gc2l0dWF0aW9ucy4gTm90IGFsbCBsb2FkZXJzIGNhbiBsb2FkIHVzaW5nIG9uZSBvciB0aGVcblx0ICogb3RoZXIsIHNvIHRoaXMgaXMgYSBzdWdnZXN0ZWQgZGlyZWN0aXZlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIFRoZSB0eXBlIG9mIGxvYWRlci4gTG9hZGVyIHR5cGVzIGFyZSBkZWZpbmVkIGFzIGNvbnN0YW50cyBvbiB0aGUgQWJzdHJhY3RMb2FkZXIgY2xhc3MsXG5cdCAqIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiSU1BR0U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIkNTUzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSwgZXRjLlxuXHQgKiBAZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJcblx0ICovXG5cdGZ1bmN0aW9uIEFic3RyYWN0TG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIsIHR5cGUpIHtcblx0XHR0aGlzLkV2ZW50RGlzcGF0Y2hlcl9jb25zdHJ1Y3RvcigpO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBJZiB0aGUgbG9hZGVyIGhhcyBjb21wbGV0ZWQgbG9hZGluZy4gVGhpcyBwcm92aWRlcyBhIHF1aWNrIGNoZWNrLCBidXQgYWxzbyBlbnN1cmVzIHRoYXQgdGhlIGRpZmZlcmVudCBhcHByb2FjaGVzXG5cdFx0ICogdXNlZCBmb3IgbG9hZGluZyBkbyBub3QgcGlsZSB1cCByZXN1bHRpbmcgaW4gbW9yZSB0aGFuIG9uZSBgY29tcGxldGVgIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBsb2FkZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMubG9hZGVkID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBEZXRlcm1pbmUgaWYgdGhlIGxvYWRlciB3YXMgY2FuY2VsZWQuIENhbmNlbGVkIGxvYWRzIHdpbGwgbm90IGZpcmUgY29tcGxldGUgZXZlbnRzLiBOb3RlIHRoYXQgdGhpcyBwcm9wZXJ0eVxuXHRcdCAqIGlzIHJlYWRvbmx5LCBzbyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gcXVldWVzIHNob3VsZCBiZSBjbG9zZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2Nsb3NlXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogaW5zdGVhZC5cblx0XHQgKiBAcHJvcGVydHkgY2FuY2VsZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMuY2FuY2VsZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IGxvYWQgcHJvZ3Jlc3MgKHBlcmNlbnRhZ2UpIGZvciB0aGlzIGl0ZW0uIFRoaXMgd2lsbCBiZSBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXG5cdFx0ICpcblx0XHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdFx0ICpcblx0XHQgKiAgICAgdmFyIHF1ZXVlID0gbmV3IGNyZWF0ZWpzLkxvYWRRdWV1ZSgpO1xuXHRcdCAqICAgICBxdWV1ZS5sb2FkRmlsZShcImxhcmdlSW1hZ2UucG5nXCIpO1xuXHRcdCAqICAgICBxdWV1ZS5vbihcInByb2dyZXNzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdCAqICAgICAgICAgY29uc29sZS5sb2coXCJQcm9ncmVzczpcIiwgcXVldWUucHJvZ3Jlc3MsIGV2ZW50LnByb2dyZXNzKTtcblx0XHQgKiAgICAgfSk7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgcHJvZ3Jlc3Ncblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLnByb2dyZXNzID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIGl0ZW0gdGhpcyBsb2FkZXIgd2lsbCBsb2FkLiBTZWUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGEgZnVsbCBsaXN0IG9mXG5cdFx0ICogc3VwcG9ydGVkIHR5cGVzLlxuXHRcdCAqIEBwcm9wZXJ0eSB0eXBlXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKi9cblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBmb3JtYXR0ZXIgZnVuY3Rpb24gdGhhdCBjb252ZXJ0cyB0aGUgbG9hZGVkIHJhdyByZXN1bHQgaW50byB0aGUgZmluYWwgcmVzdWx0LiBGb3IgZXhhbXBsZSwgdGhlIEpTT05Mb2FkZXJcblx0XHQgKiBjb252ZXJ0cyBhIHN0cmluZyBvZiB0ZXh0IGludG8gYSBKYXZhU2NyaXB0IG9iamVjdC4gTm90IGFsbCBsb2FkZXJzIGhhdmUgYSByZXN1bHRGb3JtYXR0ZXIsIGFuZCB0aGlzIHByb3BlcnR5XG5cdFx0ICogY2FuIGJlIG92ZXJyaWRkZW4gdG8gcHJvdmlkZSBjdXN0b20gZm9ybWF0dGluZy5cblx0XHQgKlxuXHRcdCAqIE9wdGlvbmFsbHksIGEgcmVzdWx0Rm9ybWF0dGVyIGNhbiByZXR1cm4gYSBjYWxsYmFjayBmdW5jdGlvbiBpbiBjYXNlcyB3aGVyZSB0aGUgZm9ybWF0dGluZyBuZWVkcyB0byBiZVxuXHRcdCAqIGFzeW5jaHJvbm91cywgc3VjaCBhcyBjcmVhdGluZyBhIG5ldyBpbWFnZS5cblx0XHQgKiBAcHJvcGVydHkgcmVzdWx0Rm9ybWF0dGVyXG5cdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IG51bGw7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSB0aGlzIGxvYWRlciByZXByZXNlbnRzLiBOb3RlIHRoYXQgdGhpcyBpcyBudWxsIGluIGEge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319LFxuXHRcdCAqIGJ1dCB3aWxsIGJlIGF2YWlsYWJsZSBvbiBsb2FkZXJzIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiWE1MTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJJbWFnZUxvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgX2l0ZW1cblx0XHQgKiBAdHlwZSB7TG9hZEl0ZW18T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0aWYgKGxvYWRJdGVtKSB7XG5cdFx0XHR0aGlzLl9pdGVtID0gY3JlYXRlanMuTG9hZEl0ZW0uY3JlYXRlKGxvYWRJdGVtKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5faXRlbSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0aGUgbG9hZGVyIHdpbGwgdHJ5IGFuZCBsb2FkIGNvbnRlbnQgdXNpbmcgWEhSICh0cnVlKSBvciBIVE1MIHRhZ3MgKGZhbHNlKS5cblx0XHQgKiBAcHJvcGVydHkgX3ByZWZlclhIUlxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcHJlZmVyWEhSID0gcHJlZmVyWEhSO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxvYWRlZCByZXN1bHQgYWZ0ZXIgaXQgaXMgZm9ybWF0dGVkIGJ5IGFuIG9wdGlvbmFsIHt7I2Nyb3NzTGluayBcInJlc3VsdEZvcm1hdHRlclwifX17ey9jcm9zc0xpbmt9fS4gRm9yXG5cdFx0ICogaXRlbXMgdGhhdCBhcmUgbm90IGZvcm1hdHRlZCwgdGhpcyB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSB7eyNjcm9zc0xpbmsgXCJfcmF3UmVzdWx0OnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIFRoZSByZXN1bHQgaXMgYWNjZXNzZWQgdXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcImdldFJlc3VsdFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cdFx0ICogQHByb3BlcnR5IF9yZXN1bHRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fFN0cmluZ31cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3Jlc3VsdCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbG9hZGVkIHJlc3VsdCBiZWZvcmUgaXQgaXMgZm9ybWF0dGVkLiBUaGUgcmF3UmVzdWx0IGlzIGFjY2Vzc2VkIHVzaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJnZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBtZXRob2QsIGFuZCBwYXNzaW5nIGB0cnVlYC5cblx0XHQgKiBAcHJvcGVydHkgX3Jhd1Jlc3VsdFxuXHRcdCAqIEB0eXBlIHtPYmplY3R8U3RyaW5nfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcmF3UmVzdWx0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEEgbGlzdCBvZiBpdGVtcyB0aGF0IGxvYWRlcnMgbG9hZCBiZWhpbmQgdGhlIHNjZW5lcy4gVGhpcyBkb2VzIG5vdCBpbmNsdWRlIHRoZSBtYWluIGl0ZW0gdGhlIGxvYWRlciBpc1xuXHRcdCAqIHJlc3BvbnNpYmxlIGZvciBsb2FkaW5nLiBFeGFtcGxlcyBvZiBsb2FkZXJzIHRoYXQgaGF2ZSBzdWItaXRlbXMgaW5jbHVkZSB0aGUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gYW5kXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkSXRlbXNcblx0XHQgKiBAdHlwZSB7bnVsbH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZGVkSXRlbXMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGF0dHJpYnV0ZSB0aGUgaXRlbXMgbG9hZGVkIHVzaW5nIHRhZ3MgdXNlIGZvciB0aGUgc291cmNlLlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fdGFnU3JjQXR0cmlidXRlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIEhUTUwgdGFnIChvciBzaW1pbGFyKSB0aGF0IGEgbG9hZGVyIG1heSB1c2UgdG8gbG9hZCBIVE1MIGNvbnRlbnQsIHN1Y2ggYXMgaW1hZ2VzLCBzY3JpcHRzLCBldGMuXG5cdFx0ICogQHByb3BlcnR5IF90YWdcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fdGFnID0gbnVsbDtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChBYnN0cmFjdExvYWRlciwgY3JlYXRlanMuRXZlbnREaXNwYXRjaGVyKTtcblx0dmFyIHMgPSBBYnN0cmFjdExvYWRlcjtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG5cdC8qKlxuXHQgKiBEZWZpbmVzIGEgUE9TVCByZXF1ZXN0LCB1c2UgZm9yIGEgbWV0aG9kIHZhbHVlIHdoZW4gbG9hZGluZyBkYXRhLlxuXHQgKiBAcHJvcGVydHkgUE9TVFxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBwb3N0XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuUE9TVCA9IFwiUE9TVFwiO1xuXG5cdC8qKlxuXHQgKiBEZWZpbmVzIGEgR0VUIHJlcXVlc3QsIHVzZSBmb3IgYSBtZXRob2QgdmFsdWUgd2hlbiBsb2FkaW5nIGRhdGEuXG5cdCAqIEBwcm9wZXJ0eSBHRVRcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICogQGRlZmF1bHQgZ2V0XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuR0VUID0gXCJHRVRcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgZ2VuZXJpYyBiaW5hcnkgdHlwZXMuIE5vdGUgdGhhdCBpbWFnZXMgYXJlIGxvYWRlZCBhcyBiaW5hcnkgZmlsZXMgd2hlbiB1c2luZyBYSFIuXG5cdCAqIEBwcm9wZXJ0eSBCSU5BUllcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgYmluYXJ5XG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLkJJTkFSWSA9IFwiYmluYXJ5XCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGNzcyBmaWxlcy4gQ1NTIGZpbGVzIGFyZSBsb2FkZWQgdXNpbmcgYSAmbHQ7bGluayZndDsgd2hlbiBsb2FkZWQgd2l0aCBYSFIsIG9yIGFcblx0ICogJmx0O3N0eWxlJmd0OyB0YWcgd2hlbiBsb2FkZWQgd2l0aCB0YWdzLlxuXHQgKiBAcHJvcGVydHkgQ1NTXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGNzc1xuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5DU1MgPSBcImNzc1wiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBpbWFnZSBmaWxlcywgdXN1YWxseSBwbmcsIGdpZiwgb3IganBnL2pwZWcuIEltYWdlcyBhcmUgbG9hZGVkIGludG8gYW4gJmx0O2ltYWdlJmd0OyB0YWcuXG5cdCAqIEBwcm9wZXJ0eSBJTUFHRVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBpbWFnZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5JTUFHRSA9IFwiaW1hZ2VcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgamF2YXNjcmlwdCBmaWxlcywgdXN1YWxseSB3aXRoIHRoZSBcImpzXCIgZmlsZSBleHRlbnNpb24uIEphdmFTY3JpcHQgZmlsZXMgYXJlIGxvYWRlZCBpbnRvIGFcblx0ICogJmx0O3NjcmlwdCZndDsgdGFnLlxuXHQgKlxuXHQgKiBTaW5jZSB2ZXJzaW9uIDAuNC4xKywgZHVlIHRvIGhvdyB0YWctbG9hZGVkIHNjcmlwdHMgd29yaywgYWxsIEphdmFTY3JpcHQgZmlsZXMgYXJlIGF1dG9tYXRpY2FsbHkgaW5qZWN0ZWQgaW50b1xuXHQgKiB0aGUgYm9keSBvZiB0aGUgZG9jdW1lbnQgdG8gbWFpbnRhaW4gcGFyaXR5IGJldHdlZW4gWEhSIGFuZCB0YWctbG9hZGVkIHNjcmlwdHMuIEluIHZlcnNpb24gMC40LjAgYW5kIGVhcmxpZXIsXG5cdCAqIG9ubHkgdGFnLWxvYWRlZCBzY3JpcHRzIGFyZSBpbmplY3RlZC5cblx0ICogQHByb3BlcnR5IEpBVkFTQ1JJUFRcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgamF2YXNjcmlwdFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5KQVZBU0NSSVBUID0gXCJqYXZhc2NyaXB0XCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGpzb24gZmlsZXMsIHVzdWFsbHkgd2l0aCB0aGUgXCJqc29uXCIgZmlsZSBleHRlbnNpb24uIEpTT04gZGF0YSBpcyBsb2FkZWQgYW5kIHBhcnNlZCBpbnRvIGFcblx0ICogSmF2YVNjcmlwdCBvYmplY3QuIE5vdGUgdGhhdCBpZiBhIGBjYWxsYmFja2AgaXMgcHJlc2VudCBvbiB0aGUgbG9hZCBpdGVtLCB0aGUgZmlsZSB3aWxsIGJlIGxvYWRlZCB3aXRoIEpTT05QLFxuXHQgKiBubyBtYXR0ZXIgd2hhdCB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3ByZWZlclhIUjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpcyBzZXQgdG8sIGFuZCB0aGUgSlNPTlxuXHQgKiBtdXN0IGNvbnRhaW4gYSBtYXRjaGluZyB3cmFwcGVyIGZ1bmN0aW9uLlxuXHQgKiBAcHJvcGVydHkgSlNPTlxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBqc29uXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLkpTT04gPSBcImpzb25cIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IganNvbnAgZmlsZXMsIHVzdWFsbHkgd2l0aCB0aGUgXCJqc29uXCIgZmlsZSBleHRlbnNpb24uIEpTT04gZGF0YSBpcyBsb2FkZWQgYW5kIHBhcnNlZCBpbnRvIGFcblx0ICogSmF2YVNjcmlwdCBvYmplY3QuIFlvdSBhcmUgcmVxdWlyZWQgdG8gcGFzcyBhIGNhbGxiYWNrIHBhcmFtZXRlciB0aGF0IG1hdGNoZXMgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgaW4gdGhlIEpTT04uXG5cdCAqIE5vdGUgdGhhdCBKU09OUCB3aWxsIGFsd2F5cyBiZSB1c2VkIGlmIHRoZXJlIGlzIGEgY2FsbGJhY2sgcHJlc2VudCwgbm8gbWF0dGVyIHdoYXQgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9wcmVmZXJYSFI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogcHJvcGVydHkgaXMgc2V0IHRvLlxuXHQgKiBAcHJvcGVydHkgSlNPTlBcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQganNvbnBcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuSlNPTlAgPSBcImpzb25wXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGpzb24tYmFzZWQgbWFuaWZlc3QgZmlsZXMsIHVzdWFsbHkgd2l0aCB0aGUgXCJqc29uXCIgZmlsZSBleHRlbnNpb24uIFRoZSBKU09OIGRhdGEgaXMgbG9hZGVkXG5cdCAqIGFuZCBwYXJzZWQgaW50byBhIEphdmFTY3JpcHQgb2JqZWN0LiBQcmVsb2FkSlMgd2lsbCB0aGVuIGxvb2sgZm9yIGEgXCJtYW5pZmVzdFwiIHByb3BlcnR5IGluIHRoZSBKU09OLCB3aGljaCBpcyBhblxuXHQgKiBBcnJheSBvZiBmaWxlcyB0byBsb2FkLCBmb2xsb3dpbmcgdGhlIHNhbWUgZm9ybWF0IGFzIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC4gSWYgYSBcImNhbGxiYWNrXCIgaXMgc3BlY2lmaWVkIG9uIHRoZSBtYW5pZmVzdCBvYmplY3QsIHRoZW4gaXQgd2lsbCBiZSBsb2FkZWQgdXNpbmcgSlNPTlAgaW5zdGVhZCxcblx0ICogcmVnYXJkbGVzcyBvZiB3aGF0IHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvcHJlZmVyWEhSOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGlzIHNldCB0by5cblx0ICogQHByb3BlcnR5IE1BTklGRVNUXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IG1hbmlmZXN0XG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLk1BTklGRVNUID0gXCJtYW5pZmVzdFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBzb3VuZCBmaWxlcywgdXN1YWxseSBtcDMsIG9nZywgb3Igd2F2LiBXaGVuIGxvYWRpbmcgdmlhIHRhZ3MsIGF1ZGlvIGlzIGxvYWRlZCBpbnRvIGFuXG5cdCAqICZsdDthdWRpbyZndDsgdGFnLlxuXHQgKiBAcHJvcGVydHkgU09VTkRcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgc291bmRcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuU09VTkQgPSBcInNvdW5kXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIHZpZGVvIGZpbGVzLCB1c3VhbGx5IG1wNCwgdHMsIG9yIG9nZy4gV2hlbiBsb2FkaW5nIHZpYSB0YWdzLCB2aWRlbyBpcyBsb2FkZWQgaW50byBhblxuXHQgKiAmbHQ7dmlkZW8mZ3Q7IHRhZy5cblx0ICogQHByb3BlcnR5IFZJREVPXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHZpZGVvXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLlZJREVPID0gXCJ2aWRlb1wiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBTcHJpdGVTaGVldCBmaWxlcy4gU3ByaXRlU2hlZXQgZmlsZXMgYXJlIEpTT04gZmlsZXMgdGhhdCBjb250YWluIHN0cmluZyBpbWFnZSBwYXRocy5cblx0ICogQHByb3BlcnR5IFNQUklURVNIRUVUXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHNwcml0ZXNoZWV0XG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLlNQUklURVNIRUVUID0gXCJzcHJpdGVzaGVldFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBTVkcgZmlsZXMuXG5cdCAqIEBwcm9wZXJ0eSBTVkdcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgc3ZnXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLlNWRyA9IFwic3ZnXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIHRleHQgZmlsZXMsIHdoaWNoIGlzIGFsc28gdGhlIGRlZmF1bHQgZmlsZSB0eXBlIGlmIHRoZSB0eXBlIGNhbiBub3QgYmUgZGV0ZXJtaW5lZC4gVGV4dCBpc1xuXHQgKiBsb2FkZWQgYXMgcmF3IHRleHQuXG5cdCAqIEBwcm9wZXJ0eSBURVhUXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHRleHRcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuVEVYVCA9IFwidGV4dFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciB4bWwgZmlsZXMuIFhNTCBpcyBsb2FkZWQgaW50byBhbiBYTUwgZG9jdW1lbnQuXG5cdCAqIEBwcm9wZXJ0eSBYTUxcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgeG1sXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLlhNTCA9IFwieG1sXCI7XG5cbi8vIEV2ZW50c1xuXHQvKipcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIlByb2dyZXNzRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIHRoZSBvdmVyYWxsIHByb2dyZXNzIGNoYW5nZXMuIFByaW9yIHRvXG5cdCAqIHZlcnNpb24gMC42LjAsIHRoaXMgd2FzIGp1c3QgYSByZWd1bGFyIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAZXZlbnQgcHJvZ3Jlc3Ncblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGUge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIGEgbG9hZCBzdGFydHMuXG5cdCAqIEBldmVudCBsb2Fkc3RhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAc2luY2UgMC4zLjFcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIHdoZW4gdGhlIGVudGlyZSBxdWV1ZSBoYXMgYmVlbiBsb2FkZWQuXG5cdCAqIEBldmVudCBjb21wbGV0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBzaW5jZSAwLjMuMFxuXHQgKi9cblxuXHQvKipcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIkVycm9yRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIHRoZSBsb2FkZXIgZW5jb3VudGVycyBhbiBlcnJvci4gSWYgdGhlIGVycm9yIHdhc1xuXHQgKiBlbmNvdW50ZXJlZCBieSBhIGZpbGUsIHRoZSBldmVudCB3aWxsIGNvbnRhaW4gdGhlIGl0ZW0gdGhhdCBjYXVzZWQgdGhlIGVycm9yLiBQcmlvciB0byB2ZXJzaW9uIDAuNi4wLCB0aGlzIHdhc1xuXHQgKiBqdXN0IGEgcmVndWxhciB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQGV2ZW50IGVycm9yXG5cdCAqIEBzaW5jZSAwLjMuMFxuXHQgKi9cblxuXHQvKipcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgd2hlbiB0aGUgbG9hZGVyIGVuY291bnRlcnMgYW4gaW50ZXJuYWwgZmlsZSBsb2FkIGVycm9yLlxuXHQgKiBUaGlzIGVuYWJsZXMgbG9hZGVycyB0byBtYWludGFpbiBpbnRlcm5hbCBxdWV1ZXMsIGFuZCBzdXJmYWNlIGZpbGUgbG9hZCBlcnJvcnMuXG5cdCAqIEBldmVudCBmaWxlZXJyb3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVuIHR5cGUgKFwiZmlsZWVycm9yXCIpXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18b2JqZWN0fSBUaGUgaXRlbSB0aGF0IGVuY291bnRlcmVkIHRoZSBlcnJvclxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIHdoZW4gYSBsb2FkZXIgaW50ZXJuYWxseSBsb2FkcyBhIGZpbGUuIFRoaXMgZW5hYmxlc1xuXHQgKiBsb2FkZXJzIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gdG8gbWFpbnRhaW4gaW50ZXJuYWwge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319c1xuXHQgKiBhbmQgbm90aWZ5IHdoZW4gdGhleSBoYXZlIGxvYWRlZCBhIGZpbGUuIFRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZGlzcGF0Y2hlcyBhXG5cdCAqIHNsaWdodGx5IGRpZmZlcmVudCB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZWxvYWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQuXG5cdCAqIEBldmVudCBmaWxlbG9hZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUgKFwiZmlsZWxvYWRcIilcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIGZpbGUgaXRlbSB3aGljaCB3YXMgc3BlY2lmaWVkIGluIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogb3Ige3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fSBjYWxsLiBJZiBvbmx5IGEgc3RyaW5nIHBhdGggb3IgdGFnIHdhcyBzcGVjaWZpZWQsIHRoZVxuXHQgKiBvYmplY3Qgd2lsbCBjb250YWluIHRoYXQgdmFsdWUgYXMgYSBgc3JjYCBwcm9wZXJ0eS5cblx0ICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCBUaGUgSFRNTCB0YWcgb3IgcGFyc2VkIHJlc3VsdCBvZiB0aGUgbG9hZGVkIGl0ZW0uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByYXdSZXN1bHQgVGhlIHVucHJvY2Vzc2VkIHJlc3VsdCwgdXN1YWxseSB0aGUgcmF3IHRleHQgb3IgYmluYXJ5IGRhdGEgYmVmb3JlIGl0IGlzIGNvbnZlcnRlZFxuXHQgKiB0byBhIHVzYWJsZSBvYmplY3QuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgYWZ0ZXIgdGhlIGludGVybmFsIHJlcXVlc3QgaXMgY3JlYXRlZCwgYnV0IGJlZm9yZSBhIGxvYWQuXG5cdCAqIFRoaXMgYWxsb3dzIHVwZGF0ZXMgdG8gdGhlIGxvYWRlciBmb3Igc3BlY2lmaWMgbG9hZGluZyBuZWVkcywgc3VjaCBhcyBiaW5hcnkgb3IgWEhSIGltYWdlIGxvYWRpbmcuXG5cdCAqIEBldmVudCBpbml0aWFsaXplXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZSAoXCJpbml0aWFsaXplXCIpXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlciBUaGUgbG9hZGVyIHRoYXQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG5cdCAqL1xuXG5cblx0LyoqXG5cdCAqIEdldCBhIHJlZmVyZW5jZSB0byB0aGUgbWFuaWZlc3QgaXRlbSB0aGF0IGlzIGxvYWRlZCBieSB0aGlzIGxvYWRlci4gSW4gc29tZSBjYXNlcyB0aGlzIHdpbGwgYmUgdGhlIHZhbHVlIHRoYXQgd2FzXG5cdCAqIHBhc3NlZCBpbnRvIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fS4gSG93ZXZlciBpZiBvbmx5IGEgU3RyaW5nIHBhdGggd2FzIHBhc3NlZCBpbiwgdGhlbiBpdCB3aWxsXG5cdCAqIGJlIGEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgZ2V0SXRlbVxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBtYW5pZmVzdCBpdGVtIHRoYXQgdGhpcyBsb2FkZXIgaXMgcmVzcG9uc2libGUgZm9yIGxvYWRpbmcuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5nZXRJdGVtID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9pdGVtO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIGNvbnRlbnQgdGhhdCB3YXMgbG9hZGVkIGJ5IHRoZSBsb2FkZXIgKG9ubHkgYXZhaWxhYmxlIGFmdGVyIHRoZSB7eyNjcm9zc0xpbmsgXCJjb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBpcyBkaXNwYXRjaGVkLlxuXHQgKiBAbWV0aG9kIGdldFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyYXc9ZmFsc2VdIERldGVybWluZXMgaWYgdGhlIHJldHVybmVkIHJlc3VsdCB3aWxsIGJlIHRoZSBmb3JtYXR0ZWQgY29udGVudCwgb3IgdGhlIHJhdyBsb2FkZWRcblx0ICogZGF0YSAoaWYgaXQgZXhpc3RzKS5cblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuZ2V0UmVzdWx0ID0gZnVuY3Rpb24gKHJhdykge1xuXHRcdHJldHVybiByYXcgPyB0aGlzLl9yYXdSZXN1bHQgOiB0aGlzLl9yZXN1bHQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgYHRhZ2AgdGhpcyBvYmplY3QgY3JlYXRlcyBvciB1c2VzIGZvciBsb2FkaW5nLlxuXHQgKiBAbWV0aG9kIGdldFRhZ1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB0YWcgaW5zdGFuY2Vcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmdldFRhZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fdGFnO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGB0YWdgIHRoaXMgaXRlbSB1c2VzIGZvciBsb2FkaW5nLlxuXHQgKiBAbWV0aG9kIHNldFRhZ1xuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFnIFRoZSB0YWcgaW5zdGFuY2Vcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLnNldFRhZyA9IGZ1bmN0aW9uKHRhZykge1xuXHQgIHRoaXMuX3RhZyA9IHRhZztcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW4gbG9hZGluZyB0aGUgaXRlbS4gVGhpcyBtZXRob2QgaXMgcmVxdWlyZWQgd2hlbiB1c2luZyBhIGxvYWRlciBieSBpdHNlbGYuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG5cdCAqICAgICAgcXVldWUub24oXCJjb21wbGV0ZVwiLCBoYW5kbGVDb21wbGV0ZSk7XG5cdCAqICAgICAgcXVldWUubG9hZE1hbmlmZXN0KGZpbGVBcnJheSwgZmFsc2UpOyAvLyBOb3RlIHRoZSAybmQgYXJndW1lbnQgdGhhdCB0ZWxscyB0aGUgcXVldWUgbm90IHRvIHN0YXJ0IGxvYWRpbmcgeWV0XG5cdCAqICAgICAgcXVldWUubG9hZCgpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIGxvYWRcblx0ICovXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jcmVhdGVSZXF1ZXN0KCk7XG5cblx0XHR0aGlzLl9yZXF1ZXN0Lm9uKFwiY29tcGxldGVcIiwgdGhpcywgdGhpcyk7XG5cdFx0dGhpcy5fcmVxdWVzdC5vbihcInByb2dyZXNzXCIsIHRoaXMsIHRoaXMpO1xuXHRcdHRoaXMuX3JlcXVlc3Qub24oXCJsb2FkU3RhcnRcIiwgdGhpcywgdGhpcyk7XG5cdFx0dGhpcy5fcmVxdWVzdC5vbihcImFib3J0XCIsIHRoaXMsIHRoaXMpO1xuXHRcdHRoaXMuX3JlcXVlc3Qub24oXCJ0aW1lb3V0XCIsIHRoaXMsIHRoaXMpO1xuXHRcdHRoaXMuX3JlcXVlc3Qub24oXCJlcnJvclwiLCB0aGlzLCB0aGlzKTtcblxuXHRcdHZhciBldnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJpbml0aWFsaXplXCIpO1xuXHRcdGV2dC5sb2FkZXIgPSB0aGlzLl9yZXF1ZXN0O1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuXG5cdFx0dGhpcy5fcmVxdWVzdC5sb2FkKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENsb3NlIHRoZSB0aGUgaXRlbS4gVGhpcyB3aWxsIHN0b3AgYW55IG9wZW4gcmVxdWVzdHMgKGFsdGhvdWdoIGRvd25sb2FkcyB1c2luZyBIVE1MIHRhZ3MgbWF5IHN0aWxsIGNvbnRpbnVlIGluXG5cdCAqIHRoZSBiYWNrZ3JvdW5kKSwgYnV0IGV2ZW50cyB3aWxsIG5vdCBsb25nZXIgYmUgZGlzcGF0Y2hlZC5cblx0ICogQG1ldGhvZCBjYW5jZWxcblx0ICovXG5cdHAuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY2FuY2VsZWQgPSB0cnVlO1xuXHRcdHRoaXMuZGVzdHJveSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cCB0aGUgbG9hZGVyLlxuXHQgKiBAbWV0aG9kIGRlc3Ryb3lcblx0ICovXG5cdHAuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9yZXF1ZXN0KSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LmRlc3Ryb3koKTtcblx0XHR9XG5cblx0XHR0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcblxuXHRcdHRoaXMuX2l0ZW0gPSBudWxsO1xuXHRcdHRoaXMuX3Jhd1Jlc3VsdCA9IG51bGw7XG5cdFx0dGhpcy5fcmVzdWx0ID0gbnVsbDtcblxuXHRcdHRoaXMuX2xvYWRJdGVtcyA9IG51bGw7XG5cblx0XHR0aGlzLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCBhbnkgaXRlbXMgbG9hZGVkIGludGVybmFsbHkgYnkgdGhlIGxvYWRlci4gVGhlIGVuYWJsZXMgbG9hZGVycyBzdWNoIGFzIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHRvIGV4cG9zZSBpdGVtcyBpdCBsb2FkcyBpbnRlcm5hbGx5LlxuXHQgKiBAbWV0aG9kIGdldExvYWRlZEl0ZW1zXG5cdCAqIEByZXR1cm4ge0FycmF5fSBBIGxpc3Qgb2YgdGhlIGl0ZW1zIGxvYWRlZCBieSB0aGUgbG9hZGVyLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuZ2V0TG9hZGVkSXRlbXMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRlZEl0ZW1zO1xuXHR9O1xuXG5cblx0Ly8gUHJpdmF0ZSBtZXRob2RzXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW4gaW50ZXJuYWwgcmVxdWVzdCB1c2VkIGZvciBsb2FkaW5nLiBCeSBkZWZhdWx0LCBhbiB7eyNjcm9zc0xpbmsgXCJYSFJSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdCAqIHt7I2Nyb3NzTGluayBcIlRhZ1JlcXVlc3RcIn19e3svY3Jvc3NMaW5rfX0gaXMgY3JlYXRlZCwgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSBvZiB7eyNjcm9zc0xpbmsgXCJwcmVmZXJYSFI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIE90aGVyIGxvYWRlcnMgbWF5IG92ZXJyaWRlIHRoaXMgdG8gdXNlIGRpZmZlcmVudCByZXF1ZXN0IHR5cGVzLCBzdWNoIGFzIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiB3aGljaCB1c2VzIHt7I2Nyb3NzTGluayBcIkpTT05Mb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gb3Ige3sjY3Jvc3NMaW5rIFwiSlNPTlBMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gdW5kZXIgdGhlIGhvb2QuXG5cdCAqIEBtZXRob2QgX2NyZWF0ZVJlcXVlc3Rcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fcHJlZmVyWEhSKSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLlRhZ1JlcXVlc3QodGhpcy5faXRlbSwgdGhpcy5fdGFnIHx8IHRoaXMuX2NyZWF0ZVRhZygpLCB0aGlzLl90YWdTcmNBdHRyaWJ1dGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLlhIUlJlcXVlc3QodGhpcy5faXRlbSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgdGhlIEhUTUwgdGFnIHVzZWQgZm9yIGxvYWRpbmcuIFRoaXMgbWV0aG9kIGRvZXMgbm90aGluZyBieSBkZWZhdWx0LCBhbmQgbmVlZHMgdG8gYmUgaW1wbGVtZW50ZWRcblx0ICogYnkgbG9hZGVycyB0aGF0IHJlcXVpcmUgdGFnIGxvYWRpbmcuXG5cdCAqIEBtZXRob2QgX2NyZWF0ZVRhZ1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSB0YWcgc291cmNlXG5cdCAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBUaGUgdGFnIHRoYXQgd2FzIGNyZWF0ZWRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fY3JlYXRlVGFnID0gZnVuY3Rpb24oc3JjKSB7IHJldHVybiBudWxsOyB9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhIGxvYWRzdGFydCB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvbG9hZHN0YXJ0OmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IGZvciBkZXRhaWxzIG9uIHRoZSBldmVudCBwYXlsb2FkLlxuXHQgKiBAbWV0aG9kIF9zZW5kTG9hZFN0YXJ0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3NlbmRMb2FkU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2lzQ2FuY2VsZWQoKSkgeyByZXR1cm47IH1cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJsb2Fkc3RhcnRcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoIGEge3sjY3Jvc3NMaW5rIFwiUHJvZ3Jlc3NFdmVudFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBfc2VuZFByb2dyZXNzXG5cdCAqIEBwYXJhbSB7TnVtYmVyIHwgT2JqZWN0fSB2YWx1ZSBUaGUgcHJvZ3Jlc3Mgb2YgdGhlIGxvYWRlZCBpdGVtLCBvciBhbiBvYmplY3QgY29udGFpbmluZyA8Y29kZT5sb2FkZWQ8L2NvZGU+XG5cdCAqIGFuZCA8Y29kZT50b3RhbDwvY29kZT4gcHJvcGVydGllcy5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2VuZFByb2dyZXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMuX2lzQ2FuY2VsZWQoKSkgeyByZXR1cm47IH1cblx0XHR2YXIgZXZlbnQgPSBudWxsO1xuXHRcdGlmICh0eXBlb2YodmFsdWUpID09IFwibnVtYmVyXCIpIHtcblx0XHRcdHRoaXMucHJvZ3Jlc3MgPSB2YWx1ZTtcblx0XHRcdGV2ZW50ID0gbmV3IGNyZWF0ZWpzLlByb2dyZXNzRXZlbnQodGhpcy5wcm9ncmVzcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV2ZW50ID0gdmFsdWU7XG5cdFx0XHR0aGlzLnByb2dyZXNzID0gdmFsdWUubG9hZGVkIC8gdmFsdWUudG90YWw7XG5cdFx0XHRldmVudC5wcm9ncmVzcyA9IHRoaXMucHJvZ3Jlc3M7XG5cdFx0XHRpZiAoaXNOYU4odGhpcy5wcm9ncmVzcykgfHwgdGhpcy5wcm9ncmVzcyA9PSBJbmZpbml0eSkgeyB0aGlzLnByb2dyZXNzID0gMDsgfVxuXHRcdH1cblx0XHR0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiKSAmJiB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhIGNvbXBsZXRlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9jb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudFxuXHQgKiBAbWV0aG9kIF9zZW5kQ29tcGxldGVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2VuZENvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9pc0NhbmNlbGVkKCkpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLmxvYWRlZCA9IHRydWU7XG5cblx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJjb21wbGV0ZVwiKTtcblx0XHRldmVudC5yYXdSZXN1bHQgPSB0aGlzLl9yYXdSZXN1bHQ7XG5cblx0XHRpZiAodGhpcy5fcmVzdWx0ICE9IG51bGwpIHtcblx0XHRcdGV2ZW50LnJlc3VsdCA9IHRoaXMuX3Jlc3VsdDtcblx0XHR9XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhbiBlcnJvciB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvZXJyb3I6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgZm9yIGRldGFpbHMgb24gdGhlIGV2ZW50IHBheWxvYWQuXG5cdCAqIEBtZXRob2QgX3NlbmRFcnJvclxuXHQgKiBAcGFyYW0ge0Vycm9yRXZlbnR9IGV2ZW50IFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBzcGVjaWZpYyBlcnJvciBwcm9wZXJ0aWVzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZW5kRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRpZiAodGhpcy5faXNDYW5jZWxlZCgpIHx8ICF0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJlcnJvclwiKSkgeyByZXR1cm47IH1cblx0XHRpZiAoZXZlbnQgPT0gbnVsbCkge1xuXHRcdFx0ZXZlbnQgPSBuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlBSRUxPQURfRVJST1JfRU1QVFlcIik7IC8vIFRPRE86IFBvcHVsYXRlIGVycm9yXG5cdFx0fVxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSBpZiB0aGUgbG9hZCBoYXMgYmVlbiBjYW5jZWxlZC4gVGhpcyBpcyBpbXBvcnRhbnQgdG8gZW5zdXJlIHRoYXQgbWV0aG9kIGNhbGxzIG9yIGFzeW5jaHJvbm91cyBldmVudHNcblx0ICogZG8gbm90IGNhdXNlIGlzc3VlcyBhZnRlciB0aGUgcXVldWUgaGFzIGJlZW4gY2xlYW5lZCB1cC5cblx0ICogQG1ldGhvZCBfaXNDYW5jZWxlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgbG9hZGVyIGhhcyBiZWVuIGNhbmNlbGVkLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9pc0NhbmNlbGVkID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh3aW5kb3cuY3JlYXRlanMgPT0gbnVsbCB8fCB0aGlzLmNhbmNlbGVkKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBIGN1c3RvbSByZXN1bHQgZm9ybWF0dGVyIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWQganVzdCBiZWZvcmUgYSByZXF1ZXN0IGRpc3BhdGNoZXMgaXRzIGNvbXBsZXRlIGV2ZW50LiBNb3N0XG5cdCAqIGxvYWRlciB0eXBlcyBhbHJlYWR5IGhhdmUgYW4gaW50ZXJuYWwgZm9ybWF0dGVyLCBidXQgdGhpcyBjYW4gYmUgdXNlci1vdmVycmlkZGVuIGZvciBjdXN0b20gZm9ybWF0dGluZy4gVGhlXG5cdCAqIGZvcm1hdHRlZCByZXN1bHQgd2lsbCBiZSBhdmFpbGFibGUgb24gTG9hZGVycyB1c2luZyB7eyNjcm9zc0xpbmsgXCJnZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCBwYXNzaW5nIGB0cnVlYC5cblx0ICogQHByb3BlcnR5IHJlc3VsdEZvcm1hdHRlclxuXHQgKiBAdHlwZSBGdW5jdGlvblxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBmb3JtYXR0ZWQgcmVzdWx0XG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5yZXN1bHRGb3JtYXR0ZXIgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBIYW5kbGUgZXZlbnRzIGZyb20gaW50ZXJuYWwgcmVxdWVzdHMuIEJ5IGRlZmF1bHQsIGxvYWRlcnMgd2lsbCBoYW5kbGUsIGFuZCByZWRpc3BhdGNoIHRoZSBuZWNlc3NhcnkgZXZlbnRzLCBidXRcblx0ICogdGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gZm9yIGN1c3RvbSBiZWhhdmlvdXJzLlxuXHQgKiBAbWV0aG9kIGhhbmRsZUV2ZW50XG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0aGF0IHRoZSBpbnRlcm5hbCByZXF1ZXN0IGRpc3BhdGNoZXMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0c3dpdGNoIChldmVudC50eXBlKSB7XG5cdFx0XHRjYXNlIFwiY29tcGxldGVcIjpcblx0XHRcdFx0dGhpcy5fcmF3UmVzdWx0ID0gZXZlbnQudGFyZ2V0Ll9yZXNwb25zZTtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0Rm9ybWF0dGVyICYmIHRoaXMucmVzdWx0Rm9ybWF0dGVyKHRoaXMpO1xuXHRcdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdFx0XHRpZiAocmVzdWx0IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdFx0XHRyZXN1bHQoZnVuY3Rpb24ocmVzdWx0KSB7XG5cdFx0XHRcdFx0XHRfdGhpcy5fcmVzdWx0ID0gcmVzdWx0O1xuXHRcdFx0XHRcdFx0X3RoaXMuX3NlbmRDb21wbGV0ZSgpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX3Jlc3VsdCA9ICByZXN1bHQgfHwgdGhpcy5fcmF3UmVzdWx0O1xuXHRcdFx0XHRcdHRoaXMuX3NlbmRDb21wbGV0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcInByb2dyZXNzXCI6XG5cdFx0XHRcdHRoaXMuX3NlbmRQcm9ncmVzcyhldmVudCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImVycm9yXCI6XG5cdFx0XHRcdHRoaXMuX3NlbmRFcnJvcihldmVudCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImxvYWRzdGFydFwiOlxuXHRcdFx0XHR0aGlzLl9zZW5kTG9hZFN0YXJ0KCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBcImFib3J0XCI6XG5cdFx0XHRjYXNlIFwidGltZW91dFwiOlxuXHRcdFx0XHRpZiAoIXRoaXMuX2lzQ2FuY2VsZWQoKSkge1xuXHRcdFx0XHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldmVudC50eXBlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgYnVpbGRQYXRoXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJSZXF1ZXN0VXRpbHNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIHt7I2Nyb3NzTGluayBcIlJlcXVlc3RVdGlscy9idWlsZFBhdGhcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaW5zdGVhZC5cblx0ICovXG5cdHAuYnVpbGRQYXRoID0gZnVuY3Rpb24gKHNyYywgZGF0YSkge1xuXHRcdHJldHVybiBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuYnVpbGRQYXRoKHNyYywgZGF0YSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltQcmVsb2FkSlMgQWJzdHJhY3RMb2FkZXJdXCI7XG5cdH07XG5cblx0Y3JlYXRlanMuQWJzdHJhY3RMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEFic3RyYWN0TG9hZGVyLCBcIkV2ZW50RGlzcGF0Y2hlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEFic3RyYWN0TWVkaWFMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogVGhlIEFic3RyYWN0TWVkaWFMb2FkZXIgaXMgYSBiYXNlIGNsYXNzIHRoYXQgaGFuZGxlcyBzb21lIG9mIHRoZSBzaGFyZWQgbWV0aG9kcyBhbmQgcHJvcGVydGllcyBvZiBsb2FkZXJzIHRoYXRcblx0ICogaGFuZGxlIEhUTUwgbWVkaWEgZWxlbWVudHMsIHN1Y2ggYXMgVmlkZW8gYW5kIEF1ZGlvLlxuXHQgKiBAY2xhc3MgQWJzdHJhY3RNZWRpYUxvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgbWVkaWEgdG8gbG9hZC4gVXN1YWxseSBcInZpZGVvXCIgb3IgXCJhdWRpb1wiLlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEFic3RyYWN0TWVkaWFMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUiwgdHlwZSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgdHlwZSk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBcInNyY1wiO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEFic3RyYWN0TWVkaWFMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblxuXHQvLyBzdGF0aWMgcHJvcGVydGllc1xuXHQvLyBwdWJsaWMgbWV0aG9kc1xuXHRwLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVGFnUmVxdWVzdCB3aWxsIGhhbmRsZSBtb3N0IG9mIHRoaXMsIGJ1dCBTb3VuZCAvIFZpZGVvIG5lZWQgYSBmZXcgY3VzdG9tIHByb3BlcnRpZXMsIHNvIGp1c3QgaGFuZGxlIHRoZW0gaGVyZS5cblx0XHRpZiAoIXRoaXMuX3RhZykge1xuXHRcdFx0dGhpcy5fdGFnID0gdGhpcy5fY3JlYXRlVGFnKHRoaXMuX2l0ZW0uc3JjKTtcblx0XHR9XG5cblx0XHR0aGlzLl90YWcucHJlbG9hZCA9IFwiYXV0b1wiO1xuXHRcdHRoaXMuX3RhZy5sb2FkKCk7XG5cblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2xvYWQoKTtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyB0YWcgZm9yIGxvYWRpbmcgaWYgaXQgZG9lc24ndCBleGlzdCB5ZXQuXG5cdCAqIEBtZXRob2QgX2NyZWF0ZVRhZ1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY3JlYXRlVGFnID0gZnVuY3Rpb24gKCkge307XG5cblxuXHRwLl9jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9wcmVmZXJYSFIpIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuTWVkaWFUYWdSZXF1ZXN0KHRoaXMuX2l0ZW0sIHRoaXMuX3RhZyB8fCB0aGlzLl9jcmVhdGVUYWcoKSwgdGhpcy5fdGFnU3JjQXR0cmlidXRlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5YSFJSZXF1ZXN0KHRoaXMuX2l0ZW0pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIG1lZGlhIGZpbGVzLlxuXHQgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEByZXR1cm5zIHtIVE1MVmlkZW9FbGVtZW50fEhUTUxBdWRpb0VsZW1lbnR9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9mb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0dGhpcy5fdGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIgJiYgdGhpcy5fdGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5dGhyb3VnaFwiLCB0aGlzLl9sb2FkZWRIYW5kbGVyKTtcblx0XHR0aGlzLl90YWcub25zdGFsbGVkID0gbnVsbDtcblx0XHRpZiAodGhpcy5fcHJlZmVyWEhSKSB7XG5cdFx0XHRsb2FkZXIuZ2V0VGFnKCkuc3JjID0gbG9hZGVyLmdldFJlc3VsdCh0cnVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIGxvYWRlci5nZXRUYWcoKTtcblx0fTtcblxuXHRjcmVhdGVqcy5BYnN0cmFjdE1lZGlhTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShBYnN0cmFjdE1lZGlhTG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQWJzdHJhY3RSZXF1ZXN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIEEgYmFzZSBjbGFzcyBmb3IgYWN0dWFsIGRhdGEgcmVxdWVzdHMsIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiWEhSUmVxdWVzdFwifX17ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiVGFnUmVxdWVzdFwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogYW5kIHt7I2Nyb3NzTGluayBcIk1lZGlhUmVxdWVzdFwifX17ey9jcm9zc0xpbmt9fS4gUHJlbG9hZEpTIGxvYWRlcnMgd2lsbCB0eXBpY2FsbHkgdXNlIGEgZGF0YSBsb2FkZXIgdW5kZXIgdGhlXG5cdCAqIGhvb2QgdG8gZ2V0IGRhdGEuXG5cdCAqIEBjbGFzcyBBYnN0cmFjdFJlcXVlc3Rcblx0ICogQHBhcmFtIHtMb2FkSXRlbX0gaXRlbVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdHZhciBBYnN0cmFjdFJlcXVlc3QgPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHRoaXMuX2l0ZW0gPSBpdGVtO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEFic3RyYWN0UmVxdWVzdCwgY3JlYXRlanMuRXZlbnREaXNwYXRjaGVyKTtcblxuXHQvLyBwdWJsaWMgbWV0aG9kc1xuXHQvKipcblx0ICogQmVnaW4gYSBsb2FkLlxuXHQgKiBAbWV0aG9kIGxvYWRcblx0ICovXG5cdHAubG9hZCA9ICBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cCBhIHJlcXVlc3QuXG5cdCAqIEBtZXRob2QgZGVzdHJveVxuXHQgKi9cblx0cC5kZXN0cm95ID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKipcblx0ICogQ2FuY2VsIGFuIGluLXByb2dyZXNzIHJlcXVlc3QuXG5cdCAqIEBtZXRob2QgY2FuY2VsXG5cdCAqL1xuXHRwLmNhbmNlbCA9IGZ1bmN0aW9uKCkge307XG5cblx0Y3JlYXRlanMuQWJzdHJhY3RSZXF1ZXN0ID0gY3JlYXRlanMucHJvbW90ZShBYnN0cmFjdFJlcXVlc3QsIFwiRXZlbnREaXNwYXRjaGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVGFnUmVxdWVzdC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBbiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdFJlcXVlc3RcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBsb2FkcyBIVE1MIHRhZ3MsIHN1Y2ggYXMgaW1hZ2VzIGFuZCBzY3JpcHRzLlxuXHQgKiBAY2xhc3MgVGFnUmVxdWVzdFxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YWdcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyY0F0dHJpYnV0ZSBUaGUgdGFnIGF0dHJpYnV0ZSB0aGF0IHNwZWNpZmllcyB0aGUgc291cmNlLCBzdWNoIGFzIFwic3JjXCIsIFwiaHJlZlwiLCBldGMuXG5cdCAqL1xuXHRmdW5jdGlvbiBUYWdSZXF1ZXN0KGxvYWRJdGVtLCB0YWcsIHNyY0F0dHJpYnV0ZSkge1xuXHRcdHRoaXMuQWJzdHJhY3RSZXF1ZXN0X2NvbnN0cnVjdG9yKGxvYWRJdGVtKTtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogVGhlIEhUTUwgdGFnIGluc3RhbmNlIHRoYXQgaXMgdXNlZCB0byBsb2FkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfdGFnXG5cdFx0ICogQHR5cGUge0hUTUxFbGVtZW50fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl90YWcgPSB0YWc7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdGFnIGF0dHJpYnV0ZSB0aGF0IHNwZWNpZmllcyB0aGUgc291cmNlLCBzdWNoIGFzIFwic3JjXCIsIFwiaHJlZlwiLCBldGMuXG5cdFx0ICogQHByb3BlcnR5IF90YWdTcmNBdHRyaWJ1dGVcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBzcmNBdHRyaWJ1dGU7XG5cblx0XHQvKipcblx0XHQgKiBBIG1ldGhvZCBjbG9zdXJlIHVzZWQgZm9yIGhhbmRsaW5nIHRoZSB0YWcgbG9hZCBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRlZEhhbmRsZXJcblx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkZWRIYW5kbGVyID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlVGFnQ29tcGxldGUsIHRoaXMpO1xuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgZWxlbWVudCB3YXMgYWRkZWQgdG8gdGhlIERPTSBhdXRvbWF0aWNhbGx5IGJ5IFByZWxvYWRKUywgc28gaXQgY2FuIGJlIGNsZWFuZWQgdXAgYWZ0ZXIuXG5cdFx0ICogQHByb3BlcnR5IF9hZGRlZFRvRE9NXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9hZGRlZFRvRE9NID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBEZXRlcm1pbmVzIHdoYXQgdGhlIHRhZ3MgaW5pdGlhbCBzdHlsZS52aXNpYmlsaXR5IHdhcywgc28gd2UgY2FuIHNldCBpdCBjb3JyZWN0bHkgYWZ0ZXIgYSBsb2FkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge251bGx9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9zdGFydFRhZ1Zpc2liaWxpdHkgPSBudWxsO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFRhZ1JlcXVlc3QsIGNyZWF0ZWpzLkFic3RyYWN0UmVxdWVzdCk7XG5cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3RhZy5vbmxvYWQgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUYWdDb21wbGV0ZSwgdGhpcyk7XG5cdFx0dGhpcy5fdGFnLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2UsIHRoaXMpO1xuXHRcdHRoaXMuX3RhZy5vbmVycm9yID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlRXJyb3IsIHRoaXMpO1xuXG5cdFx0dmFyIGV2dCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImluaXRpYWxpemVcIik7XG5cdFx0ZXZ0LmxvYWRlciA9IHRoaXMuX3RhZztcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldnQpO1xuXG5cdFx0dGhpcy5faGlkZVRhZygpO1xuXG5cdFx0dGhpcy5fbG9hZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRpbWVvdXQsIHRoaXMpLCB0aGlzLl9pdGVtLmxvYWRUaW1lb3V0KTtcblxuXHRcdHRoaXMuX3RhZ1t0aGlzLl90YWdTcmNBdHRyaWJ1dGVdID0gdGhpcy5faXRlbS5zcmM7XG5cblx0XHQvLyB3ZGc6OiBBcHBlbmQgdGhlIHRhZyBBRlRFUiBzZXR0aW5nIHRoZSBzcmMsIG9yIFNWRyBsb2FkaW5nIG9uIGlPUyB3aWxsIGZhaWwuXG5cdFx0aWYgKHRoaXMuX3RhZy5wYXJlbnROb2RlID09IG51bGwpIHtcblx0XHRcdHdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX3RhZyk7XG5cdFx0XHR0aGlzLl9hZGRlZFRvRE9NID0gdHJ1ZTtcblx0XHR9XG5cdH07XG5cblx0cC5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fY2xlYW4oKTtcblx0XHR0aGlzLl90YWcgPSBudWxsO1xuXG5cdFx0dGhpcy5BYnN0cmFjdFJlcXVlc3RfZGVzdHJveSgpO1xuXHR9O1xuXG5cdC8vIHByaXZhdGUgbWV0aG9kc1xuXHQvKipcblx0ICogSGFuZGxlIHRoZSByZWFkeVN0YXRlQ2hhbmdlIGV2ZW50IGZyb20gYSB0YWcuIFdlIG5lZWQgdGhpcyBpbiBwbGFjZSBvZiB0aGUgYG9ubG9hZGAgY2FsbGJhY2sgKG1haW5seSBTQ1JJUFRcblx0ICogYW5kIExJTksgdGFncyksIGJ1dCBvdGhlciBjYXNlcyBtYXkgZXhpc3QuXG5cdCAqIEBtZXRob2QgX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2Vcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2xvYWRUaW1lb3V0KTtcblx0XHQvLyBUaGlzIGlzIHN0cmljdGx5IGZvciB0YWdzIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgb25sb2FkLlxuXHRcdHZhciB0YWcgPSB0aGlzLl90YWc7XG5cblx0XHQvLyBDb21wbGV0ZSBpcyBmb3Igb2xkIElFIHN1cHBvcnQuXG5cdFx0aWYgKHRhZy5yZWFkeVN0YXRlID09IFwibG9hZGVkXCIgfHwgdGFnLnJlYWR5U3RhdGUgPT0gXCJjb21wbGV0ZVwiKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVUYWdDb21wbGV0ZSgpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlIGFueSBlcnJvciBldmVudHMgZnJvbSB0aGUgdGFnLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVFcnJvclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9oYW5kbGVFcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2NsZWFuKCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiZXJyb3JcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZSB0aGUgdGFnJ3Mgb25sb2FkIGNhbGxiYWNrLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVUYWdDb21wbGV0ZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlVGFnQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fcmF3UmVzdWx0ID0gdGhpcy5fdGFnO1xuXHRcdHRoaXMuX3Jlc3VsdCA9IHRoaXMucmVzdWx0Rm9ybWF0dGVyICYmIHRoaXMucmVzdWx0Rm9ybWF0dGVyKHRoaXMpIHx8IHRoaXMuX3Jhd1Jlc3VsdDtcblxuXHRcdHRoaXMuX2NsZWFuKCk7XG5cdFx0dGhpcy5fc2hvd1RhZygpO1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiY29tcGxldGVcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSB0YWcgcmVxdWVzdCBoYXMgbm90IGxvYWRlZCB3aXRoaW4gdGhlIHRpbWUgc3BlY2lmaWVkIGluIGxvYWRUaW1lb3V0LlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVFcnJvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiBlcnJvciBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fY2xlYW4oKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3IGNyZWF0ZWpzLkV2ZW50KFwidGltZW91dFwiKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMsIGJ1dCBkb24ndCBkZXN0cm95IHRoZSByZXF1ZXN0IG9iamVjdFxuXHQgKiBAbWV0aG9kIF9jbGVhblxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY2xlYW4gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl90YWcub25sb2FkID0gbnVsbDtcblx0XHR0aGlzLl90YWcub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblx0XHR0aGlzLl90YWcub25lcnJvciA9IG51bGw7XG5cdFx0aWYgKHRoaXMuX2FkZGVkVG9ET00gJiYgdGhpcy5fdGFnLnBhcmVudE5vZGUgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fdGFnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fdGFnKTtcblx0XHR9XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2xvYWRUaW1lb3V0KTtcblx0fTtcblxuXHRwLl9oaWRlVGFnID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc3RhcnRUYWdWaXNpYmlsaXR5ID0gdGhpcy5fdGFnLnN0eWxlLnZpc2liaWxpdHk7XG5cdFx0dGhpcy5fdGFnLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuXHR9O1xuXG5cdHAuX3Nob3dUYWcgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl90YWcuc3R5bGUudmlzaWJpbGl0eSA9IHRoaXMuX3N0YXJ0VGFnVmlzaWJpbGl0eTtcblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlIGEgc3RhbGxlZCBhdWRpbyBldmVudC4gVGhlIG1haW4gcGxhY2UgdGhpcyBoYXBwZW5zIGlzIHdpdGggSFRNTEF1ZGlvIGluIENocm9tZSB3aGVuIHBsYXlpbmcgYmFjayBhdWRpb1xuXHQgKiB0aGF0IGlzIGFscmVhZHkgaW4gYSBsb2FkLCBidXQgbm90IGNvbXBsZXRlLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVTdGFsbGVkXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVTdGFsbGVkID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vSWdub3JlLCBsZXQgdGhlIHRpbWVvdXQgdGFrZSBjYXJlIG9mIGl0LiBTb21ldGltZXMgaXRzIG5vdCByZWFsbHkgc3RvcHBlZC5cblx0fTtcblxuXHRjcmVhdGVqcy5UYWdSZXF1ZXN0ID0gY3JlYXRlanMucHJvbW90ZShUYWdSZXF1ZXN0LCBcIkFic3RyYWN0UmVxdWVzdFwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIE1lZGlhVGFnUmVxdWVzdC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBbiB7eyNjcm9zc0xpbmsgXCJUYWdSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgbG9hZHMgSFRNTCB0YWdzIGZvciB2aWRlbyBhbmQgYXVkaW8uXG5cdCAqIEBjbGFzcyBNZWRpYVRhZ1JlcXVlc3Rcblx0ICogQHBhcmFtIHtMb2FkSXRlbX0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtIVE1MQXVkaW9FbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IHRhZ1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjQXR0cmlidXRlIFRoZSB0YWcgYXR0cmlidXRlIHRoYXQgc3BlY2lmaWVzIHRoZSBzb3VyY2UsIHN1Y2ggYXMgXCJzcmNcIiwgXCJocmVmXCIsIGV0Yy5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBNZWRpYVRhZ1JlcXVlc3QobG9hZEl0ZW0sIHRhZywgc3JjQXR0cmlidXRlKSB7XG5cdFx0dGhpcy5BYnN0cmFjdFJlcXVlc3RfY29uc3RydWN0b3IobG9hZEl0ZW0pO1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHR0aGlzLl90YWcgPSB0YWc7XG5cdFx0dGhpcy5fdGFnU3JjQXR0cmlidXRlID0gc3JjQXR0cmlidXRlO1xuXHRcdHRoaXMuX2xvYWRlZEhhbmRsZXIgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUYWdDb21wbGV0ZSwgdGhpcyk7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoTWVkaWFUYWdSZXF1ZXN0LCBjcmVhdGVqcy5UYWdSZXF1ZXN0KTtcblx0dmFyIHMgPSBNZWRpYVRhZ1JlcXVlc3Q7XG5cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzYyA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVN0YWxsZWQsIHRoaXMpO1xuXHRcdHRoaXMuX3N0YWxsZWRDYWxsYmFjayA9IHNjO1xuXG5cdFx0dmFyIHBjID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlUHJvZ3Jlc3MsIHRoaXMpO1xuXHRcdHRoaXMuX2hhbmRsZVByb2dyZXNzID0gcGM7XG5cblx0XHR0aGlzLl90YWcuYWRkRXZlbnRMaXN0ZW5lcihcInN0YWxsZWRcIiwgc2MpO1xuXHRcdHRoaXMuX3RhZy5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgcGMpO1xuXG5cdFx0Ly8gVGhpcyB3aWxsIHRlbGwgdXMgd2hlbiBhdWRpbyBpcyBidWZmZXJlZCBlbm91Z2ggdG8gcGxheSB0aHJvdWdoLCBidXQgbm90IHdoZW4gaXRzIGxvYWRlZC5cblx0XHQvLyBUaGUgdGFnIGRvZXNuJ3Qga2VlcCBsb2FkaW5nIGluIENocm9tZSBvbmNlIGVub3VnaCBoYXMgYnVmZmVyZWQsIGFuZCB3ZSBoYXZlIGRlY2lkZWQgdGhhdCBiZWhhdmlvdXIgaXMgc3VmZmljaWVudC5cblx0XHR0aGlzLl90YWcuYWRkRXZlbnRMaXN0ZW5lciAmJiB0aGlzLl90YWcuYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsIHRoaXMuX2xvYWRlZEhhbmRsZXIsIGZhbHNlKTsgLy8gY2FucGxheXRocm91Z2ggY2FsbGJhY2sgZG9lc24ndCB3b3JrIGluIENocm9tZSwgc28gd2UgdXNlIGFuIGV2ZW50LlxuXG5cdFx0dGhpcy5UYWdSZXF1ZXN0X2xvYWQoKTtcblx0fTtcblxuXHQvLyBwcml2YXRlIG1ldGhvZHNcblx0cC5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fbG9hZFRpbWVvdXQpO1xuXHRcdC8vIFRoaXMgaXMgc3RyaWN0bHkgZm9yIHRhZ3MgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBvbmxvYWQuXG5cdFx0dmFyIHRhZyA9IHRoaXMuX3RhZztcblxuXHRcdC8vIENvbXBsZXRlIGlzIGZvciBvbGQgSUUgc3VwcG9ydC5cblx0XHRpZiAodGFnLnJlYWR5U3RhdGUgPT0gXCJsb2FkZWRcIiB8fCB0YWcucmVhZHlTdGF0ZSA9PSBcImNvbXBsZXRlXCIpIHtcblx0XHRcdHRoaXMuX2hhbmRsZVRhZ0NvbXBsZXRlKCk7XG5cdFx0fVxuXHR9O1xuXG5cdHAuX2hhbmRsZVN0YWxsZWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly9JZ25vcmUsIGxldCB0aGUgdGltZW91dCB0YWtlIGNhcmUgb2YgaXQuIFNvbWV0aW1lcyBpdHMgbm90IHJlYWxseSBzdG9wcGVkLlxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbiBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgcHJvZ3Jlc3MuXG5cdCAqIEBtZXRob2QgX2hhbmRsZVByb2dyZXNzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIHByb2dyZXNzIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRpZiAoIWV2ZW50IHx8IGV2ZW50LmxvYWRlZCA+IDAgJiYgZXZlbnQudG90YWwgPT0gMCkge1xuXHRcdFx0cmV0dXJuOyAvLyBTb21ldGltZXMgd2UgZ2V0IG5vIFwidG90YWxcIiwgc28ganVzdCBpZ25vcmUgdGhlIHByb2dyZXNzIGV2ZW50LlxuXHRcdH1cblxuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5Qcm9ncmVzc0V2ZW50KGV2ZW50LmxvYWRlZCwgZXZlbnQudG90YWwpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0cC5fY2xlYW4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIgJiYgdGhpcy5fdGFnLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5dGhyb3VnaFwiLCB0aGlzLl9sb2FkZWRIYW5kbGVyKTtcblx0XHR0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN0YWxsZWRcIiwgdGhpcy5fc3RhbGxlZENhbGxiYWNrKTtcblx0XHR0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIHRoaXMuX3Byb2dyZXNzQ2FsbGJhY2spO1xuXG5cdFx0dGhpcy5UYWdSZXF1ZXN0X19jbGVhbigpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLk1lZGlhVGFnUmVxdWVzdCA9IGNyZWF0ZWpzLnByb21vdGUoTWVkaWFUYWdSZXF1ZXN0LCBcIlRhZ1JlcXVlc3RcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBYSFJSZXF1ZXN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIHByZWxvYWRlciB0aGF0IGxvYWRzIGl0ZW1zIHVzaW5nIFhIUiByZXF1ZXN0cywgdXN1YWxseSBYTUxIdHRwUmVxdWVzdC4gSG93ZXZlciBYRG9tYWluUmVxdWVzdHMgd2lsbCBiZSB1c2VkXG5cdCAqIGZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMgaWYgcG9zc2libGUsIGFuZCBvbGRlciB2ZXJzaW9ucyBvZiBJRSBmYWxsIGJhY2sgb24gdG8gQWN0aXZlWCBvYmplY3RzIHdoZW4gbmVjZXNzYXJ5LlxuXHQgKiBYSFIgcmVxdWVzdHMgbG9hZCB0aGUgY29udGVudCBhcyB0ZXh0IG9yIGJpbmFyeSBkYXRhLCBwcm92aWRlIHByb2dyZXNzIGFuZCBjb25zaXN0ZW50IGNvbXBsZXRpb24gZXZlbnRzLCBhbmRcblx0ICogY2FuIGJlIGNhbmNlbGVkIGR1cmluZyBsb2FkLiBOb3RlIHRoYXQgWEhSIGlzIG5vdCBzdXBwb3J0ZWQgaW4gSUUgNiBvciBlYXJsaWVyLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvclxuXHQgKiBjcm9zcy1kb21haW4gbG9hZGluZy5cblx0ICogQGNsYXNzIFhIUlJlcXVlc3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSBvYmplY3QgdGhhdCBkZWZpbmVzIHRoZSBmaWxlIHRvIGxvYWQuIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgYW4gb3ZlcnZpZXcgb2Ygc3VwcG9ydGVkIGZpbGUgcHJvcGVydGllcy5cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICovXG5cdGZ1bmN0aW9uIFhIUlJlcXVlc3QgKGl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0UmVxdWVzdF9jb25zdHJ1Y3RvcihpdGVtKTtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogQSByZWZlcmVuY2UgdG8gdGhlIFhIUiByZXF1ZXN0IHVzZWQgdG8gbG9hZCB0aGUgY29udGVudC5cblx0XHQgKiBAcHJvcGVydHkgX3JlcXVlc3Rcblx0XHQgKiBAdHlwZSB7WE1MSHR0cFJlcXVlc3QgfCBYRG9tYWluUmVxdWVzdCB8IEFjdGl2ZVguWE1MSFRUUH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBtYW51YWwgbG9hZCB0aW1lb3V0IHRoYXQgaXMgdXNlZCBmb3IgYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCB0aGUgb25UaW1lb3V0IGV2ZW50IG9uIFhIUiAoWEhSIGxldmVsIDEsXG5cdFx0ICogdHlwaWNhbGx5IElFOSkuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkVGltZW91dFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkVGltZW91dCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYnJvd3NlcidzIFhIUiAoWE1MSFRUUFJlcXVlc3QpIHZlcnNpb24uIFN1cHBvcnRlZCB2ZXJzaW9ucyBhcmUgMSBhbmQgMi4gVGhlcmUgaXMgbm8gb2ZmaWNpYWwgd2F5IHRvIGRldGVjdFxuXHRcdCAqIHRoZSB2ZXJzaW9uLCBzbyB3ZSB1c2UgY2FwYWJpbGl0aWVzIHRvIG1ha2UgYSBiZXN0IGd1ZXNzLlxuXHRcdCAqIEBwcm9wZXJ0eSBfeGhyTGV2ZWxcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3hockxldmVsID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByZXNwb25zZSBvZiBhIGxvYWRlZCBmaWxlLiBUaGlzIGlzIHNldCBiZWNhdXNlIGl0IGlzIGV4cGVuc2l2ZSB0byBsb29rIHVwIGNvbnN0YW50bHkuIFRoaXMgcHJvcGVydHkgd2lsbCBiZVxuXHRcdCAqIG51bGwgdW50aWwgdGhlIGZpbGUgaXMgbG9hZGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmVzcG9uc2Vcblx0XHQgKiBAdHlwZSB7bWl4ZWR9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9yZXNwb25zZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcmVzcG9uc2Ugb2YgdGhlIGxvYWRlZCBmaWxlIGJlZm9yZSBpdCBpcyBtb2RpZmllZC4gSW4gbW9zdCBjYXNlcywgY29udGVudCBpcyBjb252ZXJ0ZWQgZnJvbSByYXcgdGV4dCB0b1xuXHRcdCAqIGFuIEhUTUwgdGFnIG9yIGEgZm9ybWF0dGVkIG9iamVjdCB3aGljaCBpcyBzZXQgdG8gdGhlIDxjb2RlPnJlc3VsdDwvY29kZT4gcHJvcGVydHksIGJ1dCB0aGUgZGV2ZWxvcGVyIG1heSBzdGlsbFxuXHRcdCAqIHdhbnQgdG8gYWNjZXNzIHRoZSByYXcgY29udGVudCBhcyBpdCB3YXMgbG9hZGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmF3UmVzcG9uc2Vcblx0XHQgKiBAdHlwZSB7U3RyaW5nfE9iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3Jhd1Jlc3BvbnNlID0gbnVsbDtcblxuXHRcdHRoaXMuX2NhbmNlbGVkID0gZmFsc2U7XG5cblx0XHQvLyBTZXR1cCBvdXIgZXZlbnQgaGFuZGxlcnMgbm93LlxuXHRcdHRoaXMuX2hhbmRsZUxvYWRTdGFydFByb3h5ID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlTG9hZFN0YXJ0LCB0aGlzKTtcblx0XHR0aGlzLl9oYW5kbGVQcm9ncmVzc1Byb3h5ID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlUHJvZ3Jlc3MsIHRoaXMpO1xuXHRcdHRoaXMuX2hhbmRsZUFib3J0UHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVBYm9ydCwgdGhpcyk7XG5cdFx0dGhpcy5faGFuZGxlRXJyb3JQcm94eSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUVycm9yLCB0aGlzKTtcblx0XHR0aGlzLl9oYW5kbGVUaW1lb3V0UHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUaW1lb3V0LCB0aGlzKTtcblx0XHR0aGlzLl9oYW5kbGVMb2FkUHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVMb2FkLCB0aGlzKTtcblx0XHR0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlUHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlLCB0aGlzKTtcblxuXHRcdGlmICghdGhpcy5fY3JlYXRlWEhSKGl0ZW0pKSB7XG5cdFx0XHQvL1RPRE86IFRocm93IGVycm9yP1xuXHRcdH1cblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChYSFJSZXF1ZXN0LCBjcmVhdGVqcy5BYnN0cmFjdFJlcXVlc3QpO1xuXG4vLyBzdGF0aWMgcHJvcGVydGllc1xuXHQvKipcblx0ICogQSBsaXN0IG9mIFhNTEhUVFAgb2JqZWN0IElEcyB0byB0cnkgd2hlbiBidWlsZGluZyBhbiBBY3RpdmVYIG9iamVjdCBmb3IgWEhSIHJlcXVlc3RzIGluIGVhcmxpZXIgdmVyc2lvbnMgb2YgSUUuXG5cdCAqIEBwcm9wZXJ0eSBBQ1RJVkVYX1ZFUlNJT05TXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHNpbmNlIDAuNC4yXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRYSFJSZXF1ZXN0LkFDVElWRVhfVkVSU0lPTlMgPSBbXG5cdFx0XCJNc3htbDIuWE1MSFRUUC42LjBcIixcblx0XHRcIk1zeG1sMi5YTUxIVFRQLjUuMFwiLFxuXHRcdFwiTXN4bWwyLlhNTEhUVFAuNC4wXCIsXG5cdFx0XCJNU1hNTDIuWE1MSFRUUC4zLjBcIixcblx0XHRcIk1TWE1MMi5YTUxIVFRQXCIsXG5cdFx0XCJNaWNyb3NvZnQuWE1MSFRUUFwiXG5cdF07XG5cbi8vIFB1YmxpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBMb29rIHVwIHRoZSBsb2FkZWQgcmVzdWx0LlxuXHQgKiBAbWV0aG9kIGdldFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyYXc9ZmFsc2VdIFJldHVybiBhIHJhdyByZXN1bHQgaW5zdGVhZCBvZiBhIGZvcm1hdHRlZCByZXN1bHQuIFRoaXMgYXBwbGllcyB0byBjb250ZW50XG5cdCAqIGxvYWRlZCB2aWEgWEhSIHN1Y2ggYXMgc2NyaXB0cywgWE1MLCBDU1MsIGFuZCBJbWFnZXMuIElmIHRoZXJlIGlzIG5vIHJhdyByZXN1bHQsIHRoZSBmb3JtYXR0ZWQgcmVzdWx0IHdpbGwgYmVcblx0ICogcmV0dXJuZWQgaW5zdGVhZC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBIHJlc3VsdCBvYmplY3QgY29udGFpbmluZyB0aGUgY29udGVudCB0aGF0IHdhcyBsb2FkZWQsIHN1Y2ggYXM6XG5cdCAqIDx1bD5cblx0ICogICAgICA8bGk+QW4gaW1hZ2UgdGFnICgmbHQ7aW1hZ2UgLyZndDspIGZvciBpbWFnZXM8L2xpPlxuXHQgKiAgICAgIDxsaT5BIHNjcmlwdCB0YWcgZm9yIEphdmFTY3JpcHQgKCZsdDtzY3JpcHQgLyZndDspLiBOb3RlIHRoYXQgc2NyaXB0cyBsb2FkZWQgd2l0aCB0YWdzIG1heSBiZSBhZGRlZCB0byB0aGVcblx0ICogICAgICBIVE1MIGhlYWQuPC9saT5cblx0ICogICAgICA8bGk+QSBzdHlsZSB0YWcgZm9yIENTUyAoJmx0O3N0eWxlIC8mZ3Q7KTwvbGk+XG5cdCAqICAgICAgPGxpPlJhdyB0ZXh0IGZvciBURVhUPC9saT5cblx0ICogICAgICA8bGk+QSBmb3JtYXR0ZWQgSmF2YVNjcmlwdCBvYmplY3QgZGVmaW5lZCBieSBKU09OPC9saT5cblx0ICogICAgICA8bGk+QW4gWE1MIGRvY3VtZW50PC9saT5cblx0ICogICAgICA8bGk+QW4gYmluYXJ5IGFycmF5YnVmZmVyIGxvYWRlZCBieSBYSFI8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBOb3RlIHRoYXQgaWYgYSByYXcgcmVzdWx0IGlzIHJlcXVlc3RlZCwgYnV0IG5vdCBmb3VuZCwgdGhlIHJlc3VsdCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQuXG5cdCAqL1xuXHRwLmdldFJlc3VsdCA9IGZ1bmN0aW9uIChyYXcpIHtcblx0XHRpZiAocmF3ICYmIHRoaXMuX3Jhd1Jlc3BvbnNlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmF3UmVzcG9uc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9yZXNwb25zZTtcblx0fTtcblxuXHQvLyBPdmVycmlkZXMgYWJzdHJhY3QgbWV0aG9kIGluIEFic3RyYWN0UmVxdWVzdFxuXHRwLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmNhbmNlbGVkID0gdHJ1ZTtcblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuX3JlcXVlc3QuYWJvcnQoKTtcblx0fTtcblxuXHQvLyBPdmVycmlkZXMgYWJzdHJhY3QgbWV0aG9kIGluIEFic3RyYWN0TG9hZGVyXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVxdWVzdCA9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVFcnJvcigpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vRXZlbnRzXG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2Fkc3RhcnRcIiwgdGhpcy5faGFuZGxlTG9hZFN0YXJ0UHJveHksIGZhbHNlKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIHRoaXMuX2hhbmRsZVByb2dyZXNzUHJveHksIGZhbHNlKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHRoaXMuX2hhbmRsZUFib3J0UHJveHksIGZhbHNlKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMuX2hhbmRsZUVycm9yUHJveHksIGZhbHNlKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcInRpbWVvdXRcIiwgdGhpcy5faGFuZGxlVGltZW91dFByb3h5LCBmYWxzZSk7XG5cblx0XHRcdC8vIE5vdGU6IFdlIGRvbid0IGdldCBvbmxvYWQgaW4gYWxsIGJyb3dzZXJzIChlYXJsaWVyIEZGIGFuZCBJRSkuIG9uUmVhZHlTdGF0ZUNoYW5nZSBoYW5kbGVzIHRoZXNlLlxuXHRcdFx0dGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCB0aGlzLl9oYW5kbGVMb2FkUHJveHksIGZhbHNlKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIiwgdGhpcy5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZVByb3h5LCBmYWxzZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIElFOSBzdXBwb3J0XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9ubG9hZHN0YXJ0ID0gdGhpcy5faGFuZGxlTG9hZFN0YXJ0UHJveHk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSB0aGlzLl9oYW5kbGVQcm9ncmVzc1Byb3h5O1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbmFib3J0ID0gdGhpcy5faGFuZGxlQWJvcnRQcm94eTtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25lcnJvciA9IHRoaXMuX2hhbmRsZUVycm9yUHJveHk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9udGltZW91dCA9IHRoaXMuX2hhbmRsZVRpbWVvdXRQcm94eTtcblxuXHRcdFx0Ly8gTm90ZTogV2UgZG9uJ3QgZ2V0IG9ubG9hZCBpbiBhbGwgYnJvd3NlcnMgKGVhcmxpZXIgRkYgYW5kIElFKS4gb25SZWFkeVN0YXRlQ2hhbmdlIGhhbmRsZXMgdGhlc2UuXG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9ubG9hZCA9IHRoaXMuX2hhbmRsZUxvYWRQcm94eTtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZVByb3h5O1xuXHRcdH1cblxuXHRcdC8vIFNldCB1cCBhIHRpbWVvdXQgaWYgd2UgZG9uJ3QgaGF2ZSBYSFIyXG5cdFx0aWYgKHRoaXMuX3hockxldmVsID09IDEpIHtcblx0XHRcdHRoaXMuX2xvYWRUaW1lb3V0ID0gc2V0VGltZW91dChjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUaW1lb3V0LCB0aGlzKSwgdGhpcy5faXRlbS5sb2FkVGltZW91dCk7XG5cdFx0fVxuXG5cdFx0Ly8gU29tZXRpbWVzIHdlIGdldCBiYWNrIDQwNHMgaW1tZWRpYXRlbHksIHBhcnRpY3VsYXJseSB3aGVuIHRoZXJlIGlzIGEgY3Jvc3Mgb3JpZ2luIHJlcXVlc3QuICAvLyBub3RlIHRoaXMgZG9lcyBub3QgY2F0Y2ggaW4gQ2hyb21lXG5cdFx0dHJ5IHtcblx0XHRcdGlmICghdGhpcy5faXRlbS52YWx1ZXMgfHwgdGhpcy5faXRlbS5tZXRob2QgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuR0VUKSB7XG5cdFx0XHRcdHRoaXMuX3JlcXVlc3Quc2VuZCgpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9pdGVtLm1ldGhvZCA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5QT1NUKSB7XG5cdFx0XHRcdHRoaXMuX3JlcXVlc3Quc2VuZChjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuZm9ybWF0UXVlcnlTdHJpbmcodGhpcy5faXRlbS52YWx1ZXMpKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiWEhSX1NFTkRcIiwgbnVsbCwgZXJyb3IpKTtcblx0XHR9XG5cdH07XG5cblx0cC5zZXRSZXNwb25zZVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuXHRcdC8vIFNvbWUgb2xkIGJyb3dzZXJzIGRvZXNuJ3Qgc3VwcG9ydCBibG9iLCBzbyB3ZSBjb252ZXJ0IGFycmF5YnVmZmVyIHRvIGJsb2IgYWZ0ZXIgcmVzcG9uc2UgaXMgZG93bmxvYWRlZFxuXHRcdGlmICh0eXBlID09PSAnYmxvYicpIHtcblx0XHRcdHR5cGUgPSB3aW5kb3cuVVJMID8gJ2Jsb2InIDogJ2FycmF5YnVmZmVyJztcblx0XHRcdHRoaXMuX3Jlc3BvbnNlVHlwZSA9IHR5cGU7XG5cdFx0fVxuXHRcdHRoaXMuX3JlcXVlc3QucmVzcG9uc2VUeXBlID0gdHlwZTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IGFsbCB0aGUgcmVzcG9uc2UgaGVhZGVycyBmcm9tIHRoZSBYbWxIdHRwUmVxdWVzdC5cblx0ICpcblx0ICogPHN0cm9uZz5Gcm9tIHRoZSBkb2NzOjwvc3Ryb25nPiBSZXR1cm4gYWxsIHRoZSBIVFRQIGhlYWRlcnMsIGV4Y2x1ZGluZyBoZWFkZXJzIHRoYXQgYXJlIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaFxuXHQgKiBmb3IgU2V0LUNvb2tpZSBvciBTZXQtQ29va2llMiwgYXMgYSBzaW5nbGUgc3RyaW5nLCB3aXRoIGVhY2ggaGVhZGVyIGxpbmUgc2VwYXJhdGVkIGJ5IGEgVSswMDBEIENSIFUrMDAwQSBMRiBwYWlyLFxuXHQgKiBleGNsdWRpbmcgdGhlIHN0YXR1cyBsaW5lLCBhbmQgd2l0aCBlYWNoIGhlYWRlciBuYW1lIGFuZCBoZWFkZXIgdmFsdWUgc2VwYXJhdGVkIGJ5IGEgVSswMDNBIENPTE9OIFUrMDAyMCBTUEFDRVxuXHQgKiBwYWlyLlxuXHQgKiBAbWV0aG9kIGdldEFsbFJlc3BvbnNlSGVhZGVyc1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblx0cC5nZXRBbGxSZXNwb25zZUhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCBhIHNwZWNpZmljIHJlc3BvbnNlIGhlYWRlciBmcm9tIHRoZSBYbWxIdHRwUmVxdWVzdC5cblx0ICpcblx0ICogPHN0cm9uZz5Gcm9tIHRoZSBkb2NzOjwvc3Ryb25nPiBSZXR1cm5zIHRoZSBoZWFkZXIgZmllbGQgdmFsdWUgZnJvbSB0aGUgcmVzcG9uc2Ugb2Ygd2hpY2ggdGhlIGZpZWxkIG5hbWUgbWF0Y2hlc1xuXHQgKiBoZWFkZXIsIHVubGVzcyB0aGUgZmllbGQgbmFtZSBpcyBTZXQtQ29va2llIG9yIFNldC1Db29raWUyLlxuXHQgKiBAbWV0aG9kIGdldFJlc3BvbnNlSGVhZGVyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGhlYWRlciBuYW1lIHRvIHJldHJpZXZlLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblx0cC5nZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXIpIHtcblx0XHRpZiAodGhpcy5fcmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlciBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH07XG5cbi8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBUaGUgWEhSIHJlcXVlc3QgaGFzIHJlcG9ydGVkIHByb2dyZXNzLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVQcm9ncmVzc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiBwcm9ncmVzcyBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVByb2dyZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKCFldmVudCB8fCBldmVudC5sb2FkZWQgPiAwICYmIGV2ZW50LnRvdGFsID09IDApIHtcblx0XHRcdHJldHVybjsgLy8gU29tZXRpbWVzIHdlIGdldCBubyBcInRvdGFsXCIsIHNvIGp1c3QgaWdub3JlIHRoZSBwcm9ncmVzcyBldmVudC5cblx0XHR9XG5cblx0XHR2YXIgbmV3RXZlbnQgPSBuZXcgY3JlYXRlanMuUHJvZ3Jlc3NFdmVudChldmVudC5sb2FkZWQsIGV2ZW50LnRvdGFsKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgWEhSIHJlcXVlc3QgaGFzIHJlcG9ydGVkIGEgbG9hZCBzdGFydC5cblx0ICogQG1ldGhvZCBfaGFuZGxlTG9hZFN0YXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGxvYWRTdGFydCBldmVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZUxvYWRTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9sb2FkVGltZW91dCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwibG9hZHN0YXJ0XCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgWEhSIHJlcXVlc3QgaGFzIHJlcG9ydGVkIGFuIGFib3J0IGV2ZW50LlxuXHQgKiBAbWV0aG9kIGhhbmRsZUFib3J0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGFib3J0IGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlQWJvcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlhIUl9BQk9SVEVEXCIsIG51bGwsIGV2ZW50KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgYW4gZXJyb3IgZXZlbnQuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUVycm9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGVycm9yIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChldmVudC5tZXNzYWdlKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgYSByZWFkeVN0YXRlIGNoYW5nZS4gTm90ZSB0aGF0IG9sZGVyIGJyb3dzZXJzIChJRSA3ICYgOCkgZG8gbm90IHByb3ZpZGUgYW4gb25sb2FkXG5cdCAqIGV2ZW50LCBzbyB3ZSBtdXN0IG1vbml0b3IgdGhlIHJlYWR5U3RhdGVDaGFuZ2UgdG8gZGV0ZXJtaW5lIGlmIHRoZSBmaWxlIGlzIGxvYWRlZC5cblx0ICogQG1ldGhvZCBfaGFuZGxlUmVhZHlTdGF0ZUNoYW5nZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiByZWFkeVN0YXRlQ2hhbmdlIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGlmICh0aGlzLl9yZXF1ZXN0LnJlYWR5U3RhdGUgPT0gNCkge1xuXHRcdFx0dGhpcy5faGFuZGxlTG9hZCgpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVGhlIFhIUiByZXF1ZXN0IGhhcyBjb21wbGV0ZWQuIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBYSFIgcmVxdWVzdCBkaXJlY3RseSwgb3IgYnkgYSByZWFkeVN0YXRlQ2hhbmdlIHRoYXQgaGFzXG5cdCAqIDxjb2RlPnJlcXVlc3QucmVhZHlTdGF0ZSA9PSA0PC9jb2RlPi4gT25seSB0aGUgZmlyc3QgY2FsbCB0byB0aGlzIG1ldGhvZCB3aWxsIGJlIHByb2Nlc3NlZC5cblx0ICogQG1ldGhvZCBfaGFuZGxlTG9hZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIFhIUiBsb2FkIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGlmICh0aGlzLmxvYWRlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLmxvYWRlZCA9IHRydWU7XG5cblx0XHR2YXIgZXJyb3IgPSB0aGlzLl9jaGVja0Vycm9yKCk7XG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVFcnJvcihlcnJvcik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fcmVzcG9uc2UgPSB0aGlzLl9nZXRSZXNwb25zZSgpO1xuXHRcdC8vIENvbnZlcnQgYXJyYXlidWZmZXIgYmFjayB0byBibG9iXG5cdFx0aWYgKHRoaXMuX3Jlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhpcy5fcmVzcG9uc2UgPSBuZXcgQmxvYihbdGhpcy5fcmVzcG9uc2VdKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gdXNlIEJsb2JCdWlsZGVyIGlmIEJsb2IgY29uc3RydWN0b3IgaXMgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHQvLyBUZXN0ZWQgb24gQW5kcm9pZCAyLjMgfiA0LjIgYW5kIGlPUzUgc2FmYXJpXG5cdFx0XHRcdHdpbmRvdy5CbG9iQnVpbGRlciA9IHdpbmRvdy5CbG9iQnVpbGRlciB8fCB3aW5kb3cuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1vekJsb2JCdWlsZGVyIHx8IHdpbmRvdy5NU0Jsb2JCdWlsZGVyO1xuXHRcdFx0XHRpZiAoZS5uYW1lID09PSAnVHlwZUVycm9yJyAmJiB3aW5kb3cuQmxvYkJ1aWxkZXIpIHtcblx0XHRcdFx0XHR2YXIgYnVpbGRlciA9IG5ldyBCbG9iQnVpbGRlcigpO1xuXHRcdFx0XHRcdGJ1aWxkZXIuYXBwZW5kKHRoaXMuX3Jlc3BvbnNlKTtcblx0XHRcdFx0XHR0aGlzLl9yZXNwb25zZSA9IGJ1aWxkZXIuZ2V0QmxvYigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2NsZWFuKCk7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3IGNyZWF0ZWpzLkV2ZW50KFwiY29tcGxldGVcIikpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgWEhSIHJlcXVlc3QgaGFzIHRpbWVkIG91dC4gVGhpcyBpcyBjYWxsZWQgYnkgdGhlIFhIUiByZXF1ZXN0IGRpcmVjdGx5LCBvciB2aWEgYSA8Y29kZT5zZXRUaW1lb3V0PC9jb2RlPlxuXHQgKiBjYWxsYmFjay5cblx0ICogQG1ldGhvZCBfaGFuZGxlVGltZW91dFxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2V2ZW50XSBUaGUgWEhSIHRpbWVvdXQgZXZlbnQuIFRoaXMgaXMgb2NjYXNpb25hbGx5IG51bGwgd2hlbiBjYWxsZWQgYnkgdGhlIGJhY2t1cCBzZXRUaW1lb3V0LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlVGltZW91dCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuX2NsZWFuKCk7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJQUkVMT0FEX1RJTUVPVVRcIiwgbnVsbCwgZXZlbnQpKTtcblx0fTtcblxuLy8gUHJvdGVjdGVkXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgdGhlcmUgaXMgYW4gZXJyb3IgaW4gdGhlIGN1cnJlbnQgbG9hZC4gVGhpcyBjaGVja3MgdGhlIHN0YXR1cyBvZiB0aGUgcmVxdWVzdCBmb3IgcHJvYmxlbSBjb2Rlcy4gTm90ZVxuXHQgKiB0aGF0IHRoaXMgZG9lcyBub3QgY2hlY2sgZm9yIGFuIGFjdHVhbCByZXNwb25zZS4gQ3VycmVudGx5LCBpdCBvbmx5IGNoZWNrcyBmb3IgNDA0IG9yIDAgZXJyb3IgY29kZS5cblx0ICogQG1ldGhvZCBfY2hlY2tFcnJvclxuXHQgKiBAcmV0dXJuIHtpbnR9IElmIHRoZSByZXF1ZXN0IHN0YXR1cyByZXR1cm5zIGFuIGVycm9yIGNvZGUuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jaGVja0Vycm9yID0gZnVuY3Rpb24gKCkge1xuXHRcdC8vTE06IFByb2JhYmx5IG5lZWQgYWRkaXRpb25hbCBoYW5kbGVycyBoZXJlLCBtYXliZSA1MDFcblx0XHR2YXIgc3RhdHVzID0gcGFyc2VJbnQodGhpcy5fcmVxdWVzdC5zdGF0dXMpO1xuXG5cdFx0c3dpdGNoIChzdGF0dXMpIHtcblx0XHRcdGNhc2UgNDA0OiAgIC8vIE5vdCBGb3VuZFxuXHRcdFx0Y2FzZSAwOiAgICAgLy8gTm90IExvYWRlZFxuXHRcdFx0XHRyZXR1cm4gbmV3IEVycm9yKHN0YXR1cyk7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBWYWxpZGF0ZSB0aGUgcmVzcG9uc2UuIERpZmZlcmVudCBicm93c2VycyBoYXZlIGRpZmZlcmVudCBhcHByb2FjaGVzLCBzb21lIG9mIHdoaWNoIHRocm93IGVycm9ycyB3aGVuIGFjY2Vzc2VkXG5cdCAqIGluIG90aGVyIGJyb3dzZXJzLiBJZiB0aGVyZSBpcyBubyByZXNwb25zZSwgdGhlIDxjb2RlPl9yZXNwb25zZTwvY29kZT4gcHJvcGVydHkgd2lsbCByZW1haW4gbnVsbC5cblx0ICogQG1ldGhvZCBfZ2V0UmVzcG9uc2Vcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2dldFJlc3BvbnNlID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZXNwb25zZSAhPSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QucmVzcG9uc2UgIT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JlcXVlc3QucmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQW5kcm9pZCAyLjIgdXNlcyAucmVzcG9uc2VUZXh0XG5cdFx0dHJ5IHtcblx0XHRcdGlmICh0aGlzLl9yZXF1ZXN0LnJlc3BvbnNlVGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXF1ZXN0LnJlc3BvbnNlVGV4dDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiBsb2FkaW5nIFhNTCwgSUU5IGRvZXMgbm90IHJldHVybiAucmVzcG9uc2UsIGluc3RlYWQgaXQgcmV0dXJucyByZXNwb25zZVhNTC54bWxcblx0XHR0cnkge1xuXHRcdFx0aWYgKHRoaXMuX3JlcXVlc3QucmVzcG9uc2VYTUwgIT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVxdWVzdC5yZXNwb25zZVhNTDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhbiBYSFIgcmVxdWVzdC4gRGVwZW5kaW5nIG9uIGEgbnVtYmVyIG9mIGZhY3RvcnMsIHdlIGdldCB0b3RhbGx5IGRpZmZlcmVudCByZXN1bHRzLlxuXHQgKiA8b2w+PGxpPlNvbWUgYnJvd3NlcnMgZ2V0IGFuIDxjb2RlPlhEb21haW5SZXF1ZXN0PC9jb2RlPiB3aGVuIGxvYWRpbmcgY3Jvc3MtZG9tYWluLjwvbGk+XG5cdCAqICAgICAgPGxpPlhNTEh0dHBSZXF1ZXN0IGFyZSBjcmVhdGVkIHdoZW4gYXZhaWxhYmxlLjwvbGk+XG5cdCAqICAgICAgPGxpPkFjdGl2ZVguWE1MSFRUUCBvYmplY3RzIGFyZSB1c2VkIGluIG9sZGVyIElFIGJyb3dzZXJzLjwvbGk+XG5cdCAqICAgICAgPGxpPlRleHQgcmVxdWVzdHMgb3ZlcnJpZGUgdGhlIG1pbWUgdHlwZSBpZiBwb3NzaWJsZTwvbGk+XG5cdCAqICAgICAgPGxpPk9yaWdpbiBoZWFkZXJzIGFyZSBzZW50IGZvciBjcm9zc2RvbWFpbiByZXF1ZXN0cyBpbiBzb21lIGJyb3dzZXJzLjwvbGk+XG5cdCAqICAgICAgPGxpPkJpbmFyeSBsb2FkcyBzZXQgdGhlIHJlc3BvbnNlIHR5cGUgdG8gXCJhcnJheWJ1ZmZlclwiPC9saT48L29sPlxuXHQgKiBAbWV0aG9kIF9jcmVhdGVYSFJcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIHJlcXVlc3RlZCBpdGVtIHRoYXQgaXMgYmVpbmcgbG9hZGVkLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiBhbiBYSFIgcmVxdWVzdCBvciBlcXVpdmFsZW50IHdhcyBzdWNjZXNzZnVsbHkgY3JlYXRlZC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NyZWF0ZVhIUiA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0Ly8gQ2hlY2sgZm9yIGNyb3NzLWRvbWFpbiBsb2Fkcy4gV2UgY2FuJ3QgZnVsbHkgc3VwcG9ydCB0aGVtLCBidXQgd2UgY2FuIHRyeS5cblx0XHR2YXIgY3Jvc3Nkb21haW4gPSBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNDcm9zc0RvbWFpbihpdGVtKTtcblx0XHR2YXIgaGVhZGVycyA9IHt9O1xuXG5cdFx0Ly8gQ3JlYXRlIHRoZSByZXF1ZXN0LiBGYWxsYmFjayB0byB3aGF0ZXZlciBzdXBwb3J0IHdlIGhhdmUuXG5cdFx0dmFyIHJlcSA9IG51bGw7XG5cdFx0aWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuXHRcdFx0cmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0XHQvLyBUaGlzIGlzIDggb3IgOSwgc28gdXNlIFhEb21haW5SZXF1ZXN0IGluc3RlYWQuXG5cdFx0XHRpZiAoY3Jvc3Nkb21haW4gJiYgcmVxLndpdGhDcmVkZW50aWFscyA9PT0gdW5kZWZpbmVkICYmIHdpbmRvdy5YRG9tYWluUmVxdWVzdCkge1xuXHRcdFx0XHRyZXEgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgeyAvLyBPbGQgSUUgdmVyc2lvbnMgdXNlIGEgZGlmZmVyZW50IGFwcHJvYWNoXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHMuQUNUSVZFWF9WRVJTSU9OUy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGF4VmVyc2lvbiA9IHMuQUNUSVZFWF9WRVJTSU9OU1tpXTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXEgPSBuZXcgQWN0aXZlWE9iamVjdChheFZlcnNpb24pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChyZXEgPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRGVmYXVsdCB0byB1dGYtOCBmb3IgVGV4dCByZXF1ZXN0cy5cblx0XHRpZiAoaXRlbS5taW1lVHlwZSA9PSBudWxsICYmIGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc1RleHQoaXRlbS50eXBlKSkge1xuXHRcdFx0aXRlbS5taW1lVHlwZSA9IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiO1xuXHRcdH1cblxuXHRcdC8vIElFOSBkb2Vzbid0IHN1cHBvcnQgb3ZlcnJpZGVNaW1lVHlwZSgpLCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGZvciBpdC5cblx0XHRpZiAoaXRlbS5taW1lVHlwZSAmJiByZXEub3ZlcnJpZGVNaW1lVHlwZSkge1xuXHRcdFx0cmVxLm92ZXJyaWRlTWltZVR5cGUoaXRlbS5taW1lVHlwZSk7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIHRoZSBYSFIgbGV2ZWxcblx0XHR0aGlzLl94aHJMZXZlbCA9ICh0eXBlb2YgcmVxLnJlc3BvbnNlVHlwZSA9PT0gXCJzdHJpbmdcIikgPyAyIDogMTtcblxuXHRcdHZhciBzcmMgPSBudWxsO1xuXHRcdGlmIChpdGVtLm1ldGhvZCA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5HRVQpIHtcblx0XHRcdHNyYyA9IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5idWlsZFBhdGgoaXRlbS5zcmMsIGl0ZW0udmFsdWVzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3JjID0gaXRlbS5zcmM7XG5cdFx0fVxuXG5cdFx0Ly8gT3BlbiB0aGUgcmVxdWVzdC4gIFNldCBjcm9zcy1kb21haW4gZmxhZ3MgaWYgaXQgaXMgc3VwcG9ydGVkIChYSFIgbGV2ZWwgMSBvbmx5KVxuXHRcdHJlcS5vcGVuKGl0ZW0ubWV0aG9kIHx8IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkdFVCwgc3JjLCB0cnVlKTtcblxuXHRcdGlmIChjcm9zc2RvbWFpbiAmJiByZXEgaW5zdGFuY2VvZiBYTUxIdHRwUmVxdWVzdCAmJiB0aGlzLl94aHJMZXZlbCA9PSAxKSB7XG5cdFx0XHRoZWFkZXJzW1wiT3JpZ2luXCJdID0gbG9jYXRpb24ub3JpZ2luO1xuXHRcdH1cblxuXHRcdC8vIFRvIHNlbmQgZGF0YSB3ZSBuZWVkIHRvIHNldCB0aGUgQ29udGVudC10eXBlIGhlYWRlcilcblx0XHRpZiAoaXRlbS52YWx1ZXMgJiYgaXRlbS5tZXRob2QgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuUE9TVCkge1xuXHRcdFx0aGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI7XG5cdFx0fVxuXG5cdFx0aWYgKCFjcm9zc2RvbWFpbiAmJiAhaGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl0pIHtcblx0XHRcdGhlYWRlcnNbXCJYLVJlcXVlc3RlZC1XaXRoXCJdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdH1cblxuXHRcdGlmIChpdGVtLmhlYWRlcnMpIHtcblx0XHRcdGZvciAodmFyIG4gaW4gaXRlbS5oZWFkZXJzKSB7XG5cdFx0XHRcdGhlYWRlcnNbbl0gPSBpdGVtLmhlYWRlcnNbbl07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChuIGluIGhlYWRlcnMpIHtcblx0XHRcdHJlcS5zZXRSZXF1ZXN0SGVhZGVyKG4sIGhlYWRlcnNbbl0pXG5cdFx0fVxuXG5cdFx0aWYgKHJlcSBpbnN0YW5jZW9mIFhNTEh0dHBSZXF1ZXN0ICYmIGl0ZW0ud2l0aENyZWRlbnRpYWxzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJlcS53aXRoQ3JlZGVudGlhbHMgPSBpdGVtLndpdGhDcmVkZW50aWFscztcblx0XHR9XG5cblx0XHR0aGlzLl9yZXF1ZXN0ID0gcmVxO1xuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEEgcmVxdWVzdCBoYXMgY29tcGxldGVkIChvciBmYWlsZWQgb3IgY2FuY2VsZWQpLCBhbmQgbmVlZHMgdG8gYmUgZGlzcG9zZWQuXG5cdCAqIEBtZXRob2QgX2NsZWFuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jbGVhbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fbG9hZFRpbWVvdXQpO1xuXG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lciAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2Fkc3RhcnRcIiwgdGhpcy5faGFuZGxlTG9hZFN0YXJ0UHJveHkpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgdGhpcy5faGFuZGxlUHJvZ3Jlc3NQcm94eSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCB0aGlzLl9oYW5kbGVBYm9ydFByb3h5KTtcblx0XHRcdHRoaXMuX3JlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMuX2hhbmRsZUVycm9yUHJveHkpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwidGltZW91dFwiLCB0aGlzLl9oYW5kbGVUaW1lb3V0UHJveHkpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCB0aGlzLl9oYW5kbGVMb2FkUHJveHkpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLCB0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlUHJveHkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9ubG9hZHN0YXJ0ID0gbnVsbDtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25wcm9ncmVzcyA9IG51bGw7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9uYWJvcnQgPSBudWxsO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbmVycm9yID0gbnVsbDtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub250aW1lb3V0ID0gbnVsbDtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25sb2FkID0gbnVsbDtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gXCJbUHJlbG9hZEpTIFhIUlJlcXVlc3RdXCI7XG5cdH07XG5cblx0Y3JlYXRlanMuWEhSUmVxdWVzdCA9IGNyZWF0ZWpzLnByb21vdGUoWEhSUmVxdWVzdCwgXCJBYnN0cmFjdFJlcXVlc3RcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBMb2FkUXVldWUuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4vKlxuIFRPRE86IFdJTkRPV1MgSVNTVUVTXG4gKiBObyBlcnJvciBmb3IgSFRNTCBhdWRpbyBpbiBJRSA2NzhcbiAqIFNWRyBubyBmYWlsdXJlIGVycm9yIGluIElFIDY3IChtYXliZSA4KSBUQUdTIEFORCBYSFJcbiAqIE5vIHNjcmlwdCBjb21wbGV0ZSBoYW5kbGVyIGluIElFIDY3IFRBR1MgKFhIUiBpcyBmaW5lKVxuICogTm8gWE1ML0pTT04gaW4gSUU2IFRBR1NcbiAqIE5lZWQgdG8gaGlkZSBsb2FkaW5nIFNWRyBpbiBPcGVyYSBUQUdTXG4gKiBObyBDU1Mgb25sb2FkL3JlYWR5c3RhdGVjaGFuZ2UgaW4gU2FmYXJpIG9yIEFuZHJvaWQgVEFHUyAocmVxdWlyZXMgcnVsZSBjaGVja2luZylcbiAqIFNWRyBubyBsb2FkIG9yIGZhaWx1cmUgaW4gT3BlcmEgWEhSXG4gKiBSZXBvcnRlZCBpc3N1ZXMgd2l0aCBJRTcvOFxuICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG4vLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogVGhlIExvYWRRdWV1ZSBjbGFzcyBpcyB0aGUgbWFpbiBBUEkgZm9yIHByZWxvYWRpbmcgY29udGVudC4gTG9hZFF1ZXVlIGlzIGEgbG9hZCBtYW5hZ2VyLCB3aGljaCBjYW4gcHJlbG9hZCBlaXRoZXJcblx0ICogYSBzaW5nbGUgZmlsZSwgb3IgcXVldWUgb2YgZmlsZXMuXG5cdCAqXG5cdCAqIDxiPkNyZWF0aW5nIGEgUXVldWU8L2I+PGJyIC8+XG5cdCAqIFRvIHVzZSBMb2FkUXVldWUsIGNyZWF0ZSBhIExvYWRRdWV1ZSBpbnN0YW5jZS4gSWYgeW91IHdhbnQgdG8gZm9yY2UgdGFnIGxvYWRpbmcgd2hlcmUgcG9zc2libGUsIHNldCB0aGUgcHJlZmVyWEhSXG5cdCAqIGFyZ3VtZW50IHRvIGZhbHNlLlxuXHQgKlxuXHQgKiAgICAgIHZhciBxdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUodHJ1ZSk7XG5cdCAqXG5cdCAqIDxiPkxpc3RlbmluZyBmb3IgRXZlbnRzPC9iPjxiciAvPlxuXHQgKiBBZGQgYW55IGxpc3RlbmVycyB5b3Ugd2FudCB0byB0aGUgcXVldWUuIFNpbmNlIFByZWxvYWRKUyAwLjMuMCwgdGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBsZXRzIHlvdSBhZGQgYXMgbWFueSBsaXN0ZW5lcnMgYXMgeW91IHdhbnQgZm9yIGV2ZW50cy4gWW91IGNhbiBzdWJzY3JpYmUgdG8gdGhlIGZvbGxvd2luZyBldmVudHM6PHVsPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2NvbXBsZXRlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319OiBmaXJlZCB3aGVuIGEgcXVldWUgY29tcGxldGVzIGxvYWRpbmcgYWxsXG5cdCAqICAgICBmaWxlczwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvZXJyb3I6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX06IGZpcmVkIHdoZW4gdGhlIHF1ZXVlIGVuY291bnRlcnMgYW4gZXJyb3Igd2l0aFxuXHQgKiAgICAgYW55IGZpbGUuPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9wcm9ncmVzczpldmVudFwifX17ey9jcm9zc0xpbmt9fTogUHJvZ3Jlc3MgZm9yIHRoZSBlbnRpcmUgcXVldWUgaGFzXG5cdCAqICAgICBjaGFuZ2VkLjwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319OiBBIHNpbmdsZSBmaWxlIGhhcyBjb21wbGV0ZWQgbG9hZGluZy48L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlcHJvZ3Jlc3M6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX06IFByb2dyZXNzIGZvciBhIHNpbmdsZSBmaWxlIGhhcyBjaGFuZ2VzLiBOb3RlXG5cdCAqICAgICB0aGF0IG9ubHkgZmlsZXMgbG9hZGVkIHdpdGggWEhSIChvciBwb3NzaWJseSBieSBwbHVnaW5zKSB3aWxsIGZpcmUgcHJvZ3Jlc3MgZXZlbnRzIG90aGVyIHRoYW4gMCBvciAxMDAlLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqICAgICAgcXVldWUub24oXCJmaWxlbG9hZFwiLCBoYW5kbGVGaWxlTG9hZCwgdGhpcyk7XG5cdCAqICAgICAgcXVldWUub24oXCJjb21wbGV0ZVwiLCBoYW5kbGVDb21wbGV0ZSwgdGhpcyk7XG5cdCAqXG5cdCAqIDxiPkFkZGluZyBmaWxlcyBhbmQgbWFuaWZlc3RzPC9iPjxiciAvPlxuXHQgKiBBZGQgZmlsZXMgeW91IHdhbnQgdG8gbG9hZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX0gb3IgYWRkIG11bHRpcGxlIGZpbGVzIGF0IGFcblx0ICogdGltZSB1c2luZyBhIGxpc3Qgb3IgYSBtYW5pZmVzdCBkZWZpbml0aW9uIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX0uIEZpbGVzIGFyZVxuXHQgKiBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBhY3RpdmUgcXVldWUsIHNvIHlvdSBjYW4gdXNlIHRoZXNlIG1ldGhvZHMgYXMgbWFueSB0aW1lcyBhcyB5b3UgbGlrZSwgd2hlbmV2ZXIgeW91XG5cdCAqIGxpa2UuXG5cdCAqXG5cdCAqICAgICAgcXVldWUubG9hZEZpbGUoXCJmaWxlUGF0aC9maWxlLmpwZ1wiKTtcblx0ICogICAgICBxdWV1ZS5sb2FkRmlsZSh7aWQ6XCJpbWFnZVwiLCBzcmM6XCJmaWxlUGF0aC9maWxlLmpwZ1wifSk7XG5cdCAqICAgICAgcXVldWUubG9hZE1hbmlmZXN0KFtcImZpbGVQYXRoL2ZpbGUuanBnXCIsIHtpZDpcImltYWdlXCIsIHNyYzpcImZpbGVQYXRoL2ZpbGUuanBnXCJ9XSk7XG5cdCAqXG5cdCAqICAgICAgLy8gVXNlIGFuIGV4dGVybmFsIG1hbmlmZXN0XG5cdCAqICAgICAgcXVldWUubG9hZE1hbmlmZXN0KFwicGF0aC90by9tYW5pZmVzdC5qc29uXCIpO1xuXHQgKiAgICAgIHF1ZXVlLmxvYWRNYW5pZmVzdCh7c3JjOlwibWFuaWZlc3QuanNvblwiLCB0eXBlOlwibWFuaWZlc3RcIn0pO1xuXHQgKlxuXHQgKiBJZiB5b3UgcGFzcyBgZmFsc2VgIGFzIHRoZSBgbG9hZE5vd2AgcGFyYW1ldGVyLCB0aGUgcXVldWUgd2lsbCBub3Qga2ljayBvZiB0aGUgbG9hZCBvZiB0aGUgZmlsZXMsIGJ1dCBpdCB3aWxsIG5vdFxuXHQgKiBzdG9wIGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZC4gQ2FsbCB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvbG9hZFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgdG8gYmVnaW5cblx0ICogYSBwYXVzZWQgcXVldWUuIE5vdGUgdGhhdCBhIHBhdXNlZCBxdWV1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgcmVzdW1lIHdoZW4gbmV3IGZpbGVzIGFyZSBhZGRlZCB0byBpdCB3aXRoIGFcblx0ICogYGxvYWROb3dgIGFyZ3VtZW50IG9mIGB0cnVlYC5cblx0ICpcblx0ICogICAgICBxdWV1ZS5sb2FkKCk7XG5cdCAqXG5cdCAqIDxiPkZpbGUgVHlwZXM8L2I+PGJyIC8+XG5cdCAqIFRoZSBmaWxlIHR5cGUgb2YgYSBtYW5pZmVzdCBpdGVtIGlzIGF1dG8tZGV0ZXJtaW5lZCBieSB0aGUgZmlsZSBleHRlbnNpb24uIFRoZSBwYXR0ZXJuIG1hdGNoaW5nIGluIFByZWxvYWRKU1xuXHQgKiBzaG91bGQgaGFuZGxlIHRoZSBtYWpvcml0eSBvZiBzdGFuZGFyZCBmaWxlIGFuZCB1cmwgZm9ybWF0cywgYW5kIHdvcmtzIHdpdGggY29tbW9uIGZpbGUgZXh0ZW5zaW9ucy4gSWYgeW91IGhhdmVcblx0ICogZWl0aGVyIGEgbm9uLXN0YW5kYXJkIGZpbGUgZXh0ZW5zaW9uLCBvciBhcmUgc2VydmluZyB0aGUgZmlsZSB1c2luZyBhIHByb3h5IHNjcmlwdCwgdGhlbiB5b3UgY2FuIHBhc3MgaW4gYVxuXHQgKiA8Y29kZT50eXBlPC9jb2RlPiBwcm9wZXJ0eSB3aXRoIGFueSBtYW5pZmVzdCBpdGVtLlxuXHQgKlxuXHQgKiAgICAgIHF1ZXVlLmxvYWRGaWxlKHtzcmM6XCJwYXRoL3RvL215RmlsZS5tcDN4XCIsIHR5cGU6Y3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU09VTkR9KTtcblx0ICpcblx0ICogICAgICAvLyBOb3RlIHRoYXQgUHJlbG9hZEpTIHdpbGwgbm90IHJlYWQgYSBmaWxlIGV4dGVuc2lvbiBmcm9tIHRoZSBxdWVyeSBzdHJpbmdcblx0ICogICAgICBxdWV1ZS5sb2FkRmlsZSh7c3JjOlwiaHR0cDovL3NlcnZlci5jb20vcHJveHk/ZmlsZT1pbWFnZS5qcGdcIiwgdHlwZTpjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5JTUFHRX0pO1xuXHQgKlxuXHQgKiBTdXBwb3J0ZWQgdHlwZXMgYXJlIGRlZmluZWQgb24gdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzLCBhbmQgaW5jbHVkZTpcblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0JJTkFSWTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogUmF3IGJpbmFyeSBkYXRhIHZpYSBYSFI8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0NTUzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogQ1NTIGZpbGVzPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9JTUFHRTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogQ29tbW9uIGltYWdlIGZvcm1hdHM8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pBVkFTQ1JJUFQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IEphdmFTY3JpcHQgZmlsZXM8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pTT046cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IEpTT04gZGF0YTwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSlNPTlA6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IEpTT04gZmlsZXMgY3Jvc3MtZG9tYWluPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9NQU5JRkVTVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogQSBsaXN0IG9mIGZpbGVzIHRvIGxvYWQgaW4gSlNPTiBmb3JtYXQsIHNlZVxuXHQgKiAgICAge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319PC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TT1VORDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogQXVkaW8gZmlsZSBmb3JtYXRzPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TUFJJVEVTSEVFVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogSlNPTiBTcHJpdGVTaGVldCBkZWZpbml0ZWlvbnMuIFRoaXNcblx0ICogICAgIHdpbGwgYWxzbyBsb2FkIHN1Yi1pbWFnZXMsIGFuZCBwcm92aWRlIGEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UuPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TVkc6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IFNWRyBmaWxlczwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvVEVYVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogVGV4dCBmaWxlcyAtIFhIUiBvbmx5PC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9YTUw6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX06IFhNTCBkYXRhPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogPGVtPk5vdGU6IExvYWRlciB0eXBlcyB1c2VkIHRvIGJlIGRlZmluZWQgb24gTG9hZFF1ZXVlLCBidXQgaGF2ZSBiZWVuIG1vdmVkIHRvIEFic3RyYWN0TG9hZGVyIGZvciBiZXR0ZXJcblx0ICogcG9ydGFiaWxpdHkgb2YgbG9hZGVyIGNsYXNzZXMsIHdoaWNoIGNhbiBiZSB1c2VkIGluZGl2aWR1YWxseSBub3cuIFRoZSBwcm9wZXJ0aWVzIG9uIExvYWRRdWV1ZSBzdGlsbCBleGlzdCwgYnV0XG5cdCAqIGFyZSBkZXByZWNhdGVkLjwvZW0+XG5cdCAqXG5cdCAqIDxiPkhhbmRsaW5nIFJlc3VsdHM8L2I+PGJyIC8+XG5cdCAqIFdoZW4gYSBmaWxlIGlzIGZpbmlzaGVkIGRvd25sb2FkaW5nLCBhIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBpc1xuXHQgKiBkaXNwYXRjaGVkLiBJbiBhbiBleGFtcGxlIGFib3ZlLCB0aGVyZSBpcyBhbiBldmVudCBsaXN0ZW5lciBzbmlwcGV0IGZvciBmaWxlbG9hZC4gTG9hZGVkIGZpbGVzIGFyZSB1c3VhbGx5IGFcblx0ICogZm9ybWF0dGVkIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGltbWVkaWF0ZWx5LCBpbmNsdWRpbmc6XG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5CaW5hcnk6IFRoZSBiaW5hcnkgbG9hZGVkIHJlc3VsdDwvbGk+XG5cdCAqICAgICA8bGk+Q1NTOiBBICZsdDtsaW5rIC8mZ3Q7IHRhZzwvbGk+XG5cdCAqICAgICA8bGk+SW1hZ2U6IEFuICZsdDtpbWcgLyZndDsgdGFnPC9saT5cblx0ICogICAgIDxsaT5KYXZhU2NyaXB0OiBBICZsdDtzY3JpcHQgLyZndDsgdGFnPC9saT5cblx0ICogICAgIDxsaT5KU09OL0pTT05QOiBBIGZvcm1hdHRlZCBKYXZhU2NyaXB0IE9iamVjdDwvbGk+XG5cdCAqICAgICA8bGk+TWFuaWZlc3Q6IEEgSmF2YVNjcmlwdCBvYmplY3QuXG5cdCAqICAgICA8bGk+U291bmQ6IEFuICZsdDthdWRpbyAvJmd0OyB0YWc8L2E+XG5cdCAqICAgICA8bGk+U3ByaXRlU2hlZXQ6IEEge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UsIGNvbnRhaW5pbmcgbG9hZGVkIGltYWdlcy5cblx0ICogICAgIDxsaT5TVkc6IEFuICZsdDtvYmplY3QgLyZndDsgdGFnPC9saT5cblx0ICogICAgIDxsaT5UZXh0OiBSYXcgdGV4dDwvbGk+XG5cdCAqICAgICA8bGk+WE1MOiBBbiBYTUwgRE9NIG5vZGU8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZUZpbGVMb2FkKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIHZhciBpdGVtID0gZXZlbnQuaXRlbTsgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGl0ZW0gdGhhdCB3YXMgcGFzc2VkIGluIHRvIHRoZSBMb2FkUXVldWVcblx0ICogICAgICAgICAgdmFyIHR5cGUgPSBpdGVtLnR5cGU7XG5cdCAqXG5cdCAqICAgICAgICAgIC8vIEFkZCBhbnkgaW1hZ2VzIHRvIHRoZSBwYWdlIGJvZHkuXG5cdCAqICAgICAgICAgIGlmICh0eXBlID09IGNyZWF0ZWpzLkxvYWRRdWV1ZS5JTUFHRSkge1xuXHQgKiAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChldmVudC5yZXN1bHQpO1xuXHQgKiAgICAgICAgICB9XG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBBdCBhbnkgdGltZSBhZnRlciB0aGUgZmlsZSBoYXMgYmVlbiBsb2FkZWQgKHVzdWFsbHkgYWZ0ZXIgdGhlIHF1ZXVlIGhhcyBjb21wbGV0ZWQpLCBhbnkgcmVzdWx0IGNhbiBiZSBsb29rZWQgdXBcblx0ICogdmlhIGl0cyBcImlkXCIgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2dldFJlc3VsdFwifX17ey9jcm9zc0xpbmt9fS4gSWYgbm8gaWQgd2FzIHByb3ZpZGVkLCB0aGVuIHRoZVxuXHQgKiBcInNyY1wiIG9yIGZpbGUgcGF0aCBjYW4gYmUgdXNlZCBpbnN0ZWFkLCBpbmNsdWRpbmcgdGhlIGBwYXRoYCBkZWZpbmVkIGJ5IGEgbWFuaWZlc3QsIGJ1dCA8c3Ryb25nPm5vdCBpbmNsdWRpbmc8L3N0cm9uZz5cblx0ICogYSBiYXNlIHBhdGggZGVmaW5lZCBvbiB0aGUgTG9hZFF1ZXVlLiBJdCBpcyByZWNvbW1lbmRlZCB0byBhbHdheXMgcGFzcyBhbiBpZCBpZiB5b3Ugd2FudCB0byBsb29rIHVwIGNvbnRlbnQuXG5cdCAqXG5cdCAqICAgICAgdmFyIGltYWdlID0gcXVldWUuZ2V0UmVzdWx0KFwiaW1hZ2VcIik7XG5cdCAqICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbWFnZSk7XG5cdCAqXG5cdCAqIFJhdyBsb2FkZWQgY29udGVudCBjYW4gYmUgYWNjZXNzZWQgdXNpbmcgdGhlIDxjb2RlPnJhd1Jlc3VsdDwvY29kZT4gcHJvcGVydHkgb2YgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCwgb3IgY2FuIGJlIGxvb2tlZCB1cCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZ2V0UmVzdWx0XCJ9fXt7L2Nyb3NzTGlua319LCBwYXNzaW5nIGB0cnVlYCBhcyB0aGUgMm5kXG5cdCAqIGFyZ3VtZW50LiBUaGlzIGlzIG9ubHkgYXBwbGljYWJsZSBmb3IgY29udGVudCB0aGF0IGhhcyBiZWVuIHBhcnNlZCBmb3IgdGhlIGJyb3dzZXIsIHNwZWNpZmljYWxseTogSmF2YVNjcmlwdCxcblx0ICogQ1NTLCBYTUwsIFNWRywgYW5kIEpTT04gb2JqZWN0cywgb3IgYW55dGhpbmcgbG9hZGVkIHdpdGggWEhSLlxuXHQgKlxuXHQgKiAgICAgIHZhciBpbWFnZSA9IHF1ZXVlLmdldFJlc3VsdChcImltYWdlXCIsIHRydWUpOyAvLyBsb2FkIHRoZSBiaW5hcnkgaW1hZ2UgZGF0YSBsb2FkZWQgd2l0aCBYSFIuXG5cdCAqXG5cdCAqIDxiPlBsdWdpbnM8L2I+PGJyIC8+XG5cdCAqIExvYWRRdWV1ZSBoYXMgYSBzaW1wbGUgcGx1Z2luIGFyY2hpdGVjdHVyZSB0byBoZWxwIHByb2Nlc3MgYW5kIHByZWxvYWQgY29udGVudC4gRm9yIGV4YW1wbGUsIHRvIHByZWxvYWQgYXVkaW8sXG5cdCAqIG1ha2Ugc3VyZSB0byBpbnN0YWxsIHRoZSA8YSBocmVmPVwiaHR0cDovL3NvdW5kanMuY29tXCI+U291bmRKUzwvYT4gU291bmQgY2xhc3MsIHdoaWNoIHdpbGwgaGVscCBsb2FkIEhUTUwgYXVkaW8sXG5cdCAqIEZsYXNoIGF1ZGlvLCBhbmQgV2ViQXVkaW8gZmlsZXMuIFRoaXMgc2hvdWxkIGJlIGluc3RhbGxlZCA8c3Ryb25nPmJlZm9yZTwvc3Ryb25nPiBsb2FkaW5nIGFueSBhdWRpbyBmaWxlcy5cblx0ICpcblx0ICogICAgICBxdWV1ZS5pbnN0YWxsUGx1Z2luKGNyZWF0ZWpzLlNvdW5kKTtcblx0ICpcblx0ICogPGg0Pktub3duIEJyb3dzZXIgSXNzdWVzPC9oND5cblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPkJyb3dzZXJzIHdpdGhvdXQgYXVkaW8gc3VwcG9ydCBjYW4gbm90IGxvYWQgYXVkaW8gZmlsZXMuPC9saT5cblx0ICogICAgIDxsaT5TYWZhcmkgb24gTWFjIE9TIFggY2FuIG9ubHkgcGxheSBIVE1MIGF1ZGlvIGlmIFF1aWNrVGltZSBpcyBpbnN0YWxsZWQ8L2xpPlxuXHQgKiAgICAgPGxpPkhUTUwgQXVkaW8gdGFncyB3aWxsIG9ubHkgZG93bmxvYWQgdW50aWwgdGhlaXIgPGNvZGU+Y2FuUGxheVRocm91Z2g8L2NvZGU+IGV2ZW50IGlzIGZpcmVkLiBCcm93c2VycyBvdGhlclxuXHQgKiAgICAgdGhhbiBDaHJvbWUgd2lsbCBjb250aW51ZSB0byBkb3dubG9hZCBpbiB0aGUgYmFja2dyb3VuZC48L2xpPlxuXHQgKiAgICAgPGxpPldoZW4gbG9hZGluZyBzY3JpcHRzIHVzaW5nIHRhZ3MsIHRoZXkgYXJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gdGhlIGRvY3VtZW50LjwvbGk+XG5cdCAqICAgICA8bGk+U2NyaXB0cyBsb2FkZWQgdmlhIFhIUiBtYXkgbm90IGJlIHByb3Blcmx5IGluc3BlY3RhYmxlIHdpdGggYnJvd3NlciB0b29scy48L2xpPlxuXHQgKiAgICAgPGxpPklFNiBhbmQgSUU3IChhbmQgc29tZSBvdGhlciBicm93c2VycykgbWF5IG5vdCBiZSBhYmxlIHRvIGxvYWQgWE1MLCBUZXh0LCBvciBKU09OLCBzaW5jZSB0aGV5IHJlcXVpcmVcblx0ICogICAgIFhIUiB0byB3b3JrLjwvbGk+XG5cdCAqICAgICA8bGk+Q29udGVudCBsb2FkZWQgdmlhIHRhZ3Mgd2lsbCBub3Qgc2hvdyBwcm9ncmVzcywgYW5kIHdpbGwgY29udGludWUgdG8gZG93bmxvYWQgaW4gdGhlIGJhY2tncm91bmQgd2hlblxuXHQgKiAgICAgY2FuY2VsZWQsIGFsdGhvdWdoIG5vIGV2ZW50cyB3aWxsIGJlIGRpc3BhdGNoZWQuPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogQGNsYXNzIExvYWRRdWV1ZVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmVmZXJYSFI9dHJ1ZV0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwcmVsb2FkIGluc3RhbmNlIHdpbGwgZmF2b3IgbG9hZGluZyB3aXRoIFhIUiAoWE1MIEhUVFBcblx0ICogUmVxdWVzdHMpLCBvciBIVE1MIHRhZ3MuIFdoZW4gdGhpcyBpcyBgZmFsc2VgLCB0aGUgcXVldWUgd2lsbCB1c2UgdGFnIGxvYWRpbmcgd2hlbiBwb3NzaWJsZSwgYW5kIGZhbGwgYmFjayBvbiBYSFJcblx0ICogd2hlbiBuZWNlc3NhcnkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbYmFzZVBhdGg9XCJcIl0gQSBwYXRoIHRoYXQgd2lsbCBiZSBwcmVwZW5kZWQgb24gdG8gdGhlIHNvdXJjZSBwYXJhbWV0ZXIgb2YgYWxsIGl0ZW1zIGluIHRoZSBxdWV1ZVxuXHQgKiBiZWZvcmUgdGhleSBhcmUgbG9hZGVkLiAgU291cmNlcyBiZWdpbm5pbmcgd2l0aCBhIHByb3RvY29sIHN1Y2ggYXMgYGh0dHA6Ly9gIG9yIGEgcmVsYXRpdmUgcGF0aCBzdWNoIGFzIGAuLi9gXG5cdCAqIHdpbGwgbm90IHJlY2VpdmUgYSBiYXNlIHBhdGguXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEJvb2xlYW59IFtjcm9zc09yaWdpbj1cIlwiXSBBbiBvcHRpb25hbCBmbGFnIHRvIHN1cHBvcnQgaW1hZ2VzIGxvYWRlZCBmcm9tIGEgQ09SUy1lbmFibGVkIHNlcnZlci4gVG9cblx0ICogdXNlIGl0LCBzZXQgdGhpcyB2YWx1ZSB0byBgdHJ1ZWAsIHdoaWNoIHdpbGwgZGVmYXVsdCB0aGUgY3Jvc3NPcmlnaW4gcHJvcGVydHkgb24gaW1hZ2VzIHRvIFwiQW5vbnltb3VzXCIuIEFueVxuXHQgKiBzdHJpbmcgdmFsdWUgd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCwgYnV0IG9ubHkgXCJcIiBhbmQgXCJBbm9ueW1vdXNcIiBhcmUgcmVjb21tZW5kZWQuIDxzdHJvbmc+Tm90ZTogVGhlIGNyb3NzT3JpZ2luXG5cdCAqIHBhcmFtZXRlciBpcyBkZXByZWNhdGVkLiBVc2UgTG9hZEl0ZW0uY3Jvc3NPcmlnaW4gaW5zdGVhZDwvc3Ryb25nPlxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICovXG5cdGZ1bmN0aW9uIExvYWRRdWV1ZSAocHJlZmVyWEhSLCBiYXNlUGF0aCwgY3Jvc3NPcmlnaW4pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKCk7XG5cblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBvZiB0aGUgcGx1Z2lucyByZWdpc3RlcmVkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9pbnN0YWxsUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBfcGx1Z2luc1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBzaW5jZSAwLjYuMVxuXHRcdCAqL1xuXHRcdHRoaXMuX3BsdWdpbnMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBoYXNoIG9mIGNhbGxiYWNrcyB0aGF0IGFyZSBmaXJlZCBmb3IgZWFjaCBmaWxlIHR5cGUgYmVmb3JlIHRoZSBmaWxlIGlzIGxvYWRlZCwgZ2l2aW5nIHBsdWdpbnMgdGhlXG5cdFx0ICogYWJpbGl0eSB0byBvdmVycmlkZSBwcm9wZXJ0aWVzIG9mIHRoZSBsb2FkLiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvaW5zdGFsbFBsdWdpblwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIG1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgX3R5cGVDYWxsYmFja3Ncblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fdHlwZUNhbGxiYWNrcyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IGhhc2ggb2YgY2FsbGJhY2tzIHRoYXQgYXJlIGZpcmVkIGZvciBlYWNoIGZpbGUgZXh0ZW5zaW9uIGJlZm9yZSB0aGUgZmlsZSBpcyBsb2FkZWQsIGdpdmluZyBwbHVnaW5zIHRoZVxuXHRcdCAqIGFiaWxpdHkgdG8gb3ZlcnJpZGUgcHJvcGVydGllcyBvZiB0aGUgbG9hZC4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2luc3RhbGxQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBtZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdFx0ICogQHByb3BlcnR5IF9leHRlbnNpb25DYWxsYmFja3Ncblx0XHQgKiBAdHlwZSB7bnVsbH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2V4dGVuc2lvbkNhbGxiYWNrcyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG5leHQgcHJlbG9hZCBxdWV1ZSB0byBwcm9jZXNzIHdoZW4gdGhpcyBvbmUgaXMgY29tcGxldGUuIElmIGFuIGVycm9yIGlzIHRocm93biBpbiB0aGUgY3VycmVudCBxdWV1ZSwgYW5kXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3N0b3BPbkVycm9yOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlzIGB0cnVlYCwgdGhlIG5leHQgcXVldWUgd2lsbCBub3QgYmUgcHJvY2Vzc2VkLlxuXHRcdCAqIEBwcm9wZXJ0eSBuZXh0XG5cdFx0ICogQHR5cGUge0xvYWRRdWV1ZX1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5uZXh0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEVuc3VyZSBsb2FkZWQgc2NyaXB0cyBcImNvbXBsZXRlXCIgaW4gdGhlIG9yZGVyIHRoZXkgYXJlIHNwZWNpZmllZC4gTG9hZGVkIHNjcmlwdHMgYXJlIGFkZGVkIHRvIHRoZSBkb2N1bWVudCBoZWFkXG5cdFx0ICogb25jZSB0aGV5IGFyZSBsb2FkZWQuIFNjcmlwdHMgbG9hZGVkIHZpYSB0YWdzIHdpbGwgbG9hZCBvbmUtYXQtYS10aW1lIHdoZW4gdGhpcyBwcm9wZXJ0eSBpcyBgdHJ1ZWAsIHdoZXJlYXNcblx0XHQgKiBzY3JpcHRzIGxvYWRlZCB1c2luZyBYSFIgY2FuIGxvYWQgaW4gYW55IG9yZGVyLCBidXQgd2lsbCBcImZpbmlzaFwiIGFuZCBiZSBhZGRlZCB0byB0aGUgZG9jdW1lbnQgaW4gdGhlIG9yZGVyXG5cdFx0ICogc3BlY2lmaWVkLlxuXHRcdCAqXG5cdFx0ICogQW55IGl0ZW1zIGNhbiBiZSBzZXQgdG8gbG9hZCBpbiBvcmRlciBieSBzZXR0aW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJtYWludGFpbk9yZGVyOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogcHJvcGVydHkgb24gdGhlIGxvYWQgaXRlbSwgb3IgYnkgZW5zdXJpbmcgdGhhdCBvbmx5IG9uZSBjb25uZWN0aW9uIGNhbiBiZSBvcGVuIGF0IGEgdGltZSB1c2luZ1xuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRNYXhDb25uZWN0aW9uc1wifX17ey9jcm9zc0xpbmt9fS4gTm90ZSB0aGF0IHdoZW4gdGhlIGBtYWludGFpblNjcmlwdE9yZGVyYCBwcm9wZXJ0eVxuXHRcdCAqIGlzIHNldCB0byBgdHJ1ZWAsIHNjcmlwdHMgaXRlbXMgYXJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIGBtYWludGFpbk9yZGVyPXRydWVgLCBhbmQgY2hhbmdpbmcgdGhlXG5cdFx0ICogYG1haW50YWluU2NyaXB0T3JkZXJgIHRvIGBmYWxzZWAgZHVyaW5nIGEgbG9hZCB3aWxsIG5vdCBjaGFuZ2UgaXRlbXMgYWxyZWFkeSBpbiBhIHF1ZXVlLlxuXHRcdCAqXG5cdFx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHRcdCAqXG5cdFx0ICogICAgICB2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG5cdFx0ICogICAgICBxdWV1ZS5zZXRNYXhDb25uZWN0aW9ucygzKTsgLy8gU2V0IGEgaGlnaGVyIG51bWJlciB0byBsb2FkIG11bHRpcGxlIGl0ZW1zIGF0IG9uY2Vcblx0XHQgKiAgICAgIHF1ZXVlLm1haW50YWluU2NyaXB0T3JkZXIgPSB0cnVlOyAvLyBFbnN1cmUgc2NyaXB0cyBhcmUgbG9hZGVkIGluIG9yZGVyXG5cdFx0ICogICAgICBxdWV1ZS5sb2FkTWFuaWZlc3QoW1xuXHRcdCAqICAgICAgICAgIFwic2NyaXB0MS5qc1wiLFxuXHRcdCAqICAgICAgICAgIFwic2NyaXB0Mi5qc1wiLFxuXHRcdCAqICAgICAgICAgIFwiaW1hZ2UucG5nXCIsIC8vIExvYWQgYW55IHRpbWVcblx0XHQgKiAgICAgICAgICB7c3JjOiBcImltYWdlMi5wbmdcIiwgbWFpbnRhaW5PcmRlcjogdHJ1ZX0gLy8gV2lsbCB3YWl0IGZvciBzY3JpcHQyLmpzXG5cdFx0ICogICAgICAgICAgXCJpbWFnZTMucG5nXCIsXG5cdFx0ICogICAgICAgICAgXCJzY3JpcHQzLmpzXCIgLy8gV2lsbCB3YWl0IGZvciBpbWFnZTIucG5nIGJlZm9yZSBsb2FkaW5nIChvciBjb21wbGV0aW5nIHdoZW4gbG9hZGluZyB3aXRoIFhIUilcblx0XHQgKiAgICAgIF0pO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IG1haW50YWluU2NyaXB0T3JkZXJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICovXG5cdFx0dGhpcy5tYWludGFpblNjcmlwdE9yZGVyID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgaWYgdGhlIExvYWRRdWV1ZSB3aWxsIHN0b3AgcHJvY2Vzc2luZyB0aGUgY3VycmVudCBxdWV1ZSB3aGVuIGFuIGVycm9yIGlzIGVuY291bnRlcmVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBzdG9wT25FcnJvclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5zdG9wT25FcnJvciA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBtYXhpbXVtIG9wZW4gY29ubmVjdGlvbnMgdGhhdCBhIGxvYWRRdWV1ZSB0cmllcyB0byBtYWludGFpbi4gUGxlYXNlIHNlZVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRNYXhDb25uZWN0aW9uc1wifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgX21heENvbm5lY3Rpb25zXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9tYXhDb25uZWN0aW9ucyA9IDE7XG5cblx0XHQvKipcblx0XHQgKiBBbiBpbnRlcm5hbCBsaXN0IG9mIGFsbCB0aGUgZGVmYXVsdCBMb2FkZXJzIHRoYXQgYXJlIGluY2x1ZGVkIHdpdGggUHJlbG9hZEpTLiBCZWZvcmUgYW4gaXRlbSBpcyBsb2FkZWQsIHRoZVxuXHRcdCAqIGF2YWlsYWJsZSBsb2FkZXIgbGlzdCBpcyBpdGVyYXRlZCwgaW4gdGhlIG9yZGVyIHRoZXkgYXJlIGluY2x1ZGVkLCBhbmQgYXMgc29vbiBhcyBhIGxvYWRlciBpbmRpY2F0ZXMgaXQgY2FuXG5cdFx0ICogaGFuZGxlIHRoZSBjb250ZW50LCBpdCB3aWxsIGJlIHNlbGVjdGVkLiBUaGUgZGVmYXVsdCBsb2FkZXIsICh7eyNjcm9zc0xpbmsgXCJUZXh0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGlzXG5cdFx0ICogbGFzdCBpbiB0aGUgbGlzdCwgc28gaXQgd2lsbCBiZSB1c2VkIGlmIG5vIG90aGVyIG1hdGNoIGlzIGZvdW5kLiBUeXBpY2FsbHksIGxvYWRlcnMgd2lsbCBtYXRjaCBiYXNlZCBvbiB0aGVcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS90eXBlXCJ9fXt7L2Nyb3NzTGlua319LCB3aGljaCBpcyBhdXRvbWF0aWNhbGx5IGRldGVybWluZWQgdXNpbmcgdGhlIGZpbGUgZXh0ZW5zaW9uIG9mXG5cdFx0ICogdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL3NyYzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKlxuXHRcdCAqIExvYWRlcnMgY2FuIGJlIHJlbW92ZWQgZnJvbSBQcmVsb2FkSlMgYnkgc2ltcGx5IG5vdCBpbmNsdWRpbmcgdGhlbS5cblx0XHQgKlxuXHRcdCAqIEN1c3RvbSBsb2FkZXJzIGluc3RhbGxlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJyZWdpc3RlckxvYWRlclwifX17ey9jcm9zc0xpbmt9fSB3aWxsIGJlIHByZXBlbmRlZCB0byB0aGlzIGxpc3Rcblx0XHQgKiBzbyB0aGF0IHRoZXkgYXJlIGNoZWNrZWQgZmlyc3QuXG5cdFx0ICogQHByb3BlcnR5IF9hdmFpbGFibGVMb2FkZXJzXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHNpbmNlIDAuNi4wXG5cdFx0ICovXG5cdFx0dGhpcy5fYXZhaWxhYmxlTG9hZGVycyA9IFtcblx0XHRcdGNyZWF0ZWpzLkltYWdlTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuSmF2YVNjcmlwdExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLkNTU0xvYWRlcixcblx0XHRcdGNyZWF0ZWpzLkpTT05Mb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5KU09OUExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlNvdW5kTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuTWFuaWZlc3RMb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5TcHJpdGVTaGVldExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlhNTExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlNWR0xvYWRlcixcblx0XHRcdGNyZWF0ZWpzLkJpbmFyeUxvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlZpZGVvTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuVGV4dExvYWRlcixcblx0XHRdO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBidWlsdCBpbiBsb2FkZXJzLCBzbyB0aGV5IGNhbid0IGJlIHJlbW92ZWQgYnkge3sjY3Jvc3NMaW5rIFwidW5yZWdpc3RlckxvYWRlclwifX17ey9jcm9zc0xpbmt9LlxuXHRcdFx0XHQgKiBAcHJvcGVydHkgX2RlZmF1bHRMb2FkZXJMZW5ndGhcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHNpbmNlIDAuNi4wXG5cdFx0ICovXG5cdFx0dGhpcy5fZGVmYXVsdExvYWRlckxlbmd0aCA9IHRoaXMuX2F2YWlsYWJsZUxvYWRlcnMubGVuZ3RoO1xuXG5cdFx0dGhpcy5pbml0KHByZWZlclhIUiwgYmFzZVBhdGgsIGNyb3NzT3JpZ2luKTtcblx0fVxuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKExvYWRRdWV1ZSwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IExvYWRRdWV1ZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblx0LyoqXG5cdCAqIEFuIGludGVybmFsIGluaXRpYWxpemF0aW9uIG1ldGhvZCwgd2hpY2ggaXMgdXNlZCBmb3IgaW5pdGlhbCBzZXQgdXAsIGJ1dCBhbHNvIHRvIHJlc2V0IHRoZSBMb2FkUXVldWUuXG5cdCAqIEBtZXRob2QgaW5pdFxuXHQgKiBAcGFyYW0gcHJlZmVyWEhSXG5cdCAqIEBwYXJhbSBiYXNlUGF0aFxuXHQgKiBAcGFyYW0gY3Jvc3NPcmlnaW5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuaW5pdCA9IGZ1bmN0aW9uIChwcmVmZXJYSFIsIGJhc2VQYXRoLCBjcm9zc09yaWdpbikge1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgdXNlWEhSXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqIEBkZXByZWNhdGVkIFVzZSBwcmVmZXJYSFIgaW5zdGVhZC5cblx0XHQgKi9cblx0XHR0aGlzLnVzZVhIUiA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBUcnkgYW5kIHVzZSBYTUxIdHRwUmVxdWVzdCAoWEhSKSB3aGVuIHBvc3NpYmxlLiBOb3RlIHRoYXQgTG9hZFF1ZXVlIHdpbGwgZGVmYXVsdCB0byB0YWcgbG9hZGluZyBvciBYSFJcblx0XHQgKiBsb2FkaW5nIGRlcGVuZGluZyBvbiB0aGUgcmVxdWlyZW1lbnRzIGZvciBhIG1lZGlhIHR5cGUuIEZvciBleGFtcGxlLCBIVE1MIGF1ZGlvIGNhbiBub3QgYmUgbG9hZGVkIHdpdGggWEhSLFxuXHRcdCAqIGFuZCBwbGFpbiB0ZXh0IGNhbiBub3QgYmUgbG9hZGVkIHdpdGggdGFncywgc28gaXQgd2lsbCBkZWZhdWx0IHRoZSB0aGUgY29ycmVjdCB0eXBlIGluc3RlYWQgb2YgdXNpbmcgdGhlXG5cdFx0ICogdXNlci1kZWZpbmVkIHR5cGUuXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqIEBzaW5jZSAwLjYuMFxuXHRcdCAqL1xuXHRcdHRoaXMucHJlZmVyWEhSID0gdHJ1ZTsgLy9UT0RPOiBHZXQvU2V0XG5cdFx0dGhpcy5fcHJlZmVyWEhSID0gdHJ1ZTtcblx0XHR0aGlzLnNldFByZWZlclhIUihwcmVmZXJYSFIpO1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRoZSBxdWV1ZSBpcyBjdXJyZW50bHkgcGF1c2VkIG9yIG5vdC5cblx0XHQgKiBAcHJvcGVydHkgX3BhdXNlZFxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBBIHBhdGggdGhhdCB3aWxsIGJlIHByZXBlbmRlZCBvbiB0byB0aGUgaXRlbSdzIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL3NyYzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS4gVGhlXG5cdFx0ICogYF9iYXNlUGF0aGAgcHJvcGVydHkgd2lsbCBvbmx5IGJlIHVzZWQgaWYgYW4gaXRlbSdzIHNvdXJjZSBpcyByZWxhdGl2ZSwgYW5kIGRvZXMgbm90IGluY2x1ZGUgYSBwcm90b2NvbCBzdWNoXG5cdFx0ICogYXMgYGh0dHA6Ly9gLCBvciBhIHJlbGF0aXZlIHBhdGggc3VjaCBhcyBgLi4vYC5cblx0XHQgKiBAcHJvcGVydHkgX2Jhc2VQYXRoXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBzaW5jZSAwLjMuMVxuXHRcdCAqL1xuXHRcdHRoaXMuX2Jhc2VQYXRoID0gYmFzZVBhdGg7XG5cblx0XHQvKipcblx0XHQgKiBBbiBvcHRpb25hbCBmbGFnIHRvIHNldCBvbiBpbWFnZXMgdGhhdCBhcmUgbG9hZGVkIHVzaW5nIFByZWxvYWRKUywgd2hpY2ggZW5hYmxlcyBDT1JTIHN1cHBvcnQuIEltYWdlcyBsb2FkZWRcblx0XHQgKiBjcm9zcy1kb21haW4gYnkgc2VydmVycyB0aGF0IHN1cHBvcnQgQ09SUyByZXF1aXJlIHRoZSBjcm9zc09yaWdpbiBmbGFnIHRvIGJlIGxvYWRlZCBhbmQgaW50ZXJhY3RlZCB3aXRoIGJ5XG5cdFx0ICogYSBjYW52YXMuIFdoZW4gbG9hZGluZyBsb2NhbGx5LCBvciB3aXRoIGEgc2VydmVyIHdpdGggbm8gQ09SUyBzdXBwb3J0LCB0aGlzIGZsYWcgY2FuIGNhdXNlIG90aGVyIHNlY3VyaXR5IGlzc3Vlcyxcblx0XHQgKiBzbyBpdCBpcyByZWNvbW1lbmRlZCB0byBvbmx5IHNldCBpdCBpZiB5b3UgYXJlIHN1cmUgdGhlIHNlcnZlciBzdXBwb3J0cyBpdC4gQ3VycmVudGx5LCBzdXBwb3J0ZWQgdmFsdWVzIGFyZSBcIlwiXG5cdFx0ICogYW5kIFwiQW5vbnltb3VzXCIuXG5cdFx0ICogQHByb3BlcnR5IF9jcm9zc09yaWdpblxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgXCJcIlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHNpbmNlIDAuNC4xXG5cdFx0ICovXG5cdFx0dGhpcy5fY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRTdGFydCBldmVudCB3YXMgZGlzcGF0Y2hlZCBhbHJlYWR5LiBUaGlzIGV2ZW50IGlzIG9ubHkgZmlyZWQgb25lIHRpbWUsIHdoZW4gdGhlIGZpcnN0XG5cdFx0ICogZmlsZSBpcyByZXF1ZXN0ZWQuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkU3RhcnRXYXNEaXNwYXRjaGVkXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRTdGFydFdhc0Rpc3BhdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgaWYgdGhlcmUgaXMgY3VycmVudGx5IGEgc2NyaXB0IGxvYWRpbmcuIFRoaXMgaGVscHMgZW5zdXJlIHRoYXQgb25seSBhIHNpbmdsZSBzY3JpcHQgbG9hZHMgYXQgb25jZSB3aGVuXG5cdFx0ICogdXNpbmcgYSBzY3JpcHQgdGFnIHRvIGRvIHByZWxvYWRpbmcuXG5cdFx0ICogQHByb3BlcnR5IF9jdXJyZW50bHlMb2FkaW5nU2NyaXB0XG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9jdXJyZW50bHlMb2FkaW5nU2NyaXB0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGN1cnJlbnRseSBkb3dubG9hZGluZyBmaWxlcy5cblx0XHQgKiBAcHJvcGVydHkgX2N1cnJlbnRMb2Fkc1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2N1cnJlbnRMb2FkcyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgY29udGFpbmluZyB0aGUgcXVldWVkIGl0ZW1zIHRoYXQgaGF2ZSBub3QgeWV0IHN0YXJ0ZWQgZG93bmxvYWRpbmcuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkUXVldWVcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkUXVldWUgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IGNvbnRhaW5pbmcgZG93bmxvYWRzIHRoYXQgaGF2ZSBub3QgY29tcGxldGVkLCBzbyB0aGF0IHRoZSBMb2FkUXVldWUgY2FuIGJlIHByb3Blcmx5IHJlc2V0LlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZFF1ZXVlQmFja3VwXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZFF1ZXVlQmFja3VwID0gW107XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiBpdGVtcyB0aGF0IGhhdmUgZmluaXNoZWQgZG93bmxvYWRpbmcsIGluZGV4ZWQgYnkgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogaWQuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkSXRlbXNCeUlkXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRJdGVtc0J5SWQgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBoYXNoIG9mIGl0ZW1zIHRoYXQgaGF2ZSBmaW5pc2hlZCBkb3dubG9hZGluZywgaW5kZXhlZCBieSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIHNvdXJjZS5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRJdGVtc0J5U3JjXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRJdGVtc0J5U3JjID0ge307XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiBsb2FkZWQgaXRlbXMsIGluZGV4ZWQgYnkgdGhlIElEIG9mIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRlZFJlc3VsdHNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZGVkUmVzdWx0cyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IGhhc2ggb2YgdW4tcGFyc2VkIGxvYWRlZCBpdGVtcywgaW5kZXhlZCBieSB0aGUgSUQgb2YgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZGVkUmF3UmVzdWx0c1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkZWRSYXdSZXN1bHRzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRoYXQgaGF2ZSBiZWVuIHJlcXVlc3RlZC4gVGhpcyBoZWxwcyBtYW5hZ2UgYW4gb3ZlcmFsbCBwcm9ncmVzcyB3aXRob3V0IGtub3dpbmcgaG93IGxhcmdlXG5cdFx0ICogdGhlIGZpbGVzIGFyZSBiZWZvcmUgdGhleSBhcmUgZG93bmxvYWRlZC4gVGhpcyBkb2VzIG5vdCBpbmNsdWRlIGl0ZW1zIGluc2lkZSBvZiBsb2FkZXJzIHN1Y2ggYXMgdGhlXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IF9udW1JdGVtc1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbnVtSXRlbXMgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG51bWJlciBvZiBpdGVtcyB0aGF0IGhhdmUgY29tcGxldGVkIGxvYWRlZC4gVGhpcyBoZWxwcyBtYW5hZ2UgYW4gb3ZlcmFsbCBwcm9ncmVzcyB3aXRob3V0IGtub3dpbmcgaG93IGxhcmdlXG5cdFx0ICogdGhlIGZpbGVzIGFyZSBiZWZvcmUgdGhleSBhcmUgZG93bmxvYWRlZC5cblx0XHQgKiBAcHJvcGVydHkgX251bUl0ZW1zTG9hZGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9udW1JdGVtc0xvYWRlZCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBBIGxpc3Qgb2Ygc2NyaXB0cyBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIHJlcXVlc3RlZC4gVGhpcyBoZWxwcyBlbnN1cmUgdGhhdCBzY3JpcHRzIGFyZSBcImNvbXBsZXRlZFwiIGluIHRoZSByaWdodFxuXHRcdCAqIG9yZGVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBfc2NyaXB0T3JkZXJcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9zY3JpcHRPcmRlciA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBsaXN0IG9mIHNjcmlwdHMgdGhhdCBoYXZlIGJlZW4gbG9hZGVkLiBJdGVtcyBhcmUgYWRkZWQgdG8gdGhpcyBsaXN0IGFzIDxjb2RlPm51bGw8L2NvZGU+IHdoZW4gdGhleSBhcmVcblx0XHQgKiByZXF1ZXN0ZWQsIGNvbnRhaW4gdGhlIGxvYWRlZCBpdGVtIGlmIGl0IGhhcyBjb21wbGV0ZWQsIGJ1dCBub3QgYmVlbiBkaXNwYXRjaGVkIHRvIHRoZSB1c2VyLCBhbmQgPGNvZGU+dHJ1ZTwvdHJ1ZT5cblx0XHQgKiBvbmNlIHRoZXkgYXJlIGNvbXBsZXRlIGFuZCBoYXZlIGJlZW4gZGlzcGF0Y2hlZC5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRlZFNjcmlwdHNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkZWRTY3JpcHRzID0gW107XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbGFzdCBwcm9ncmVzcyBhbW91bnQuIFRoaXMgaXMgdXNlZCB0byBzdXBwcmVzcyBkdXBsaWNhdGUgcHJvZ3Jlc3MgZXZlbnRzLlxuXHRcdCAqIEBwcm9wZXJ0eSBfbGFzdFByb2dyZXNzXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBzaW5jZSAwLjYuMFxuXHRcdCAqL1xuXHRcdHRoaXMuX2xhc3RQcm9ncmVzcyA9IE5hTjtcblxuXHR9O1xuXG4vLyBzdGF0aWMgcHJvcGVydGllc1xuXHQvKipcblx0ICogVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIGFzc3VtZSBhIGxvYWQgaGFzIGZhaWxlZC4gQW4ge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvZXJyb3I6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgaXMgZGlzcGF0Y2hlZCBpZiB0aGUgdGltZW91dCBpcyByZWFjaGVkIGJlZm9yZSBhbnkgZGF0YSBpcyByZWNlaXZlZC5cblx0ICogQHByb3BlcnR5IGxvYWRUaW1lb3V0XG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDgwMDBcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC40LjFcblx0ICogQGRlcHJlY2F0ZWQgSW4gZmF2b3VyIG9mIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL0xPQURfVElNRU9VVF9ERUZBVUxUOnByb3BlcnR5fX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eS5cblx0ICovXG5cdHMubG9hZFRpbWVvdXQgPSA4MDAwO1xuXG5cdC8qKlxuXHQgKiBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gYXNzdW1lIGEgbG9hZCBoYXMgZmFpbGVkLlxuXHQgKiBAcHJvcGVydHkgTE9BRF9USU1FT1VUXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDBcblx0ICogQGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkVGltZW91dDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eS5cblx0ICovXG5cdHMuTE9BRF9USU1FT1VUID0gMDtcblxuLy8gUHJlbG9hZCBUeXBlc1xuXHQvKipcblx0ICogQHByb3BlcnR5IEJJTkFSWVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBiaW5hcnlcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0JJTkFSWTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5CSU5BUlkgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5CSU5BUlk7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBDU1Ncblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgY3NzXG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9DU1M6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuQ1NTID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuQ1NTO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgSU1BR0Vcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgaW1hZ2Vcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0NTUzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5JTUFHRSA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLklNQUdFO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgSkFWQVNDUklQVFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBqYXZhc2NyaXB0XG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KQVZBU0NSSVBUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLkpBVkFTQ1JJUFQgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KQVZBU0NSSVBUO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgSlNPTlxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBqc29uXG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KU09OOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLkpTT04gPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KU09OO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgSlNPTlBcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQganNvbnBcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pTT05QOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLkpTT05QID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTlA7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBNQU5JRkVTVFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBtYW5pZmVzdFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL01BTklGRVNUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLk1BTklGRVNUID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuTUFOSUZFU1Q7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBTT1VORFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBzb3VuZFxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSkFWQVNDUklQVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5TT1VORCA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNPVU5EO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgVklERU9cblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgdmlkZW9cblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pBVkFTQ1JJUFQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuVklERU8gPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5WSURFTztcblxuXHQvKipcblx0ICogQHByb3BlcnR5IFNWR1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBzdmdcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1NWRzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5TVkcgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TVkc7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBURVhUXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHRleHRcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1RFWFQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuVEVYVCA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlRFWFQ7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBYTUxcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgeG1sXG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9YTUw6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuWE1MID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuWE1MO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgUE9TVFxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1BPU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuUE9TVCA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlBPU1Q7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBHRVRcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9HRVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuR0VUID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuR0VUO1xuXG4vLyBldmVudHNcblx0LyoqXG5cdCAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhbiBpbmRpdmlkdWFsIGZpbGUgaGFzIGxvYWRlZCwgYW5kIGJlZW4gcHJvY2Vzc2VkLlxuXHQgKiBAZXZlbnQgZmlsZWxvYWRcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBUaGUgZmlsZSBpdGVtIHdoaWNoIHdhcyBzcGVjaWZpZWQgaW4gdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvciB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319IGNhbGwuIElmIG9ubHkgYSBzdHJpbmcgcGF0aCBvciB0YWcgd2FzIHNwZWNpZmllZCwgdGhlXG5cdCAqIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhhdCB2YWx1ZSBhcyBhIGBzcmNgIHByb3BlcnR5LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0IFRoZSBIVE1MIHRhZyBvciBwYXJzZWQgcmVzdWx0IG9mIHRoZSBsb2FkZWQgaXRlbS5cblx0ICogQHBhcmFtIHtPYmplY3R9IHJhd1Jlc3VsdCBUaGUgdW5wcm9jZXNzZWQgcmVzdWx0LCB1c3VhbGx5IHRoZSByYXcgdGV4dCBvciBiaW5hcnkgZGF0YSBiZWZvcmUgaXQgaXMgY29udmVydGVkXG5cdCAqIHRvIGEgdXNhYmxlIG9iamVjdC5cblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGlzIHt7I2Nyb3NzTGluayBcIlByb2dyZXNzRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIGFuIGFuIGluZGl2aWR1YWwgZmlsZSdzIHByb2dyZXNzIGNoYW5nZXMuXG5cdCAqIEBldmVudCBmaWxlcHJvZ3Jlc3Ncblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gYW4gaW5kaXZpZHVhbCBmaWxlIHN0YXJ0cyB0byBsb2FkLlxuXHQgKiBAZXZlbnQgZmlsZXN0YXJ0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBUaGUgZmlsZSBpdGVtIHdoaWNoIHdhcyBzcGVjaWZpZWQgaW4gdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvciB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319IGNhbGwuIElmIG9ubHkgYSBzdHJpbmcgcGF0aCBvciB0YWcgd2FzIHNwZWNpZmllZCwgdGhlXG5cdCAqIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhhdCB2YWx1ZSBhcyBhIHByb3BlcnR5LlxuXHQgKi9cblxuLy8gcHVibGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIFJlZ2lzdGVyIGEgY3VzdG9tIGxvYWRlcnMgY2xhc3MuIE5ldyBsb2FkZXJzIGFyZSBnaXZlbiBwcmVjZWRlbmNlIG92ZXIgbG9hZGVycyBhZGRlZCBlYXJsaWVyIGFuZCBkZWZhdWx0IGxvYWRlcnMuXG5cdCAqIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgbG9hZGVycyBleHRlbmQge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uIExvYWRlcnMgY2FuIG9ubHkgYmUgYWRkZWRcblx0ICogb25jZSwgYW5kIHdpbGwgYmUgcHJlcGVuZGVkIHRvIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSBsb2FkZXJzLlxuXHQgKiBAbWV0aG9kIHJlZ2lzdGVyTG9hZGVyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb258QWJzdHJhY3RMb2FkZXJ9IGxvYWRlciBUaGUgQWJzdHJhY3RMb2FkZXIgY2xhc3MgdG8gYWRkLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAucmVnaXN0ZXJMb2FkZXIgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0aWYgKCFsb2FkZXIgfHwgIWxvYWRlci5jYW5Mb2FkSXRlbSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibG9hZGVyIGlzIG9mIGFuIGluY29ycmVjdCB0eXBlLlwiKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuX2F2YWlsYWJsZUxvYWRlcnMuaW5kZXhPZihsb2FkZXIpICE9IC0xKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJsb2FkZXIgYWxyZWFkeSBleGlzdHMuXCIpOyAvL0xNOiBNYXliZSBqdXN0IHNpbGVudGx5IGZhaWwgaGVyZVxuXHRcdH1cblxuXHRcdHRoaXMuX2F2YWlsYWJsZUxvYWRlcnMudW5zaGlmdChsb2FkZXIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYSBjdXN0b20gbG9hZGVyIGFkZGVkIHVzaWcge3sjY3Jvc3NMaW5rIFwicmVnaXN0ZXJMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uIE9ubHkgY3VzdG9tIGxvYWRlcnMgY2FuIGJlXG5cdCAqIHVucmVnaXN0ZXJlZCwgdGhlIGRlZmF1bHQgbG9hZGVycyB3aWxsIGFsd2F5cyBiZSBhdmFpbGFibGUuXG5cdCAqIEBtZXRob2QgdW5yZWdpc3RlckxvYWRlclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufEFic3RyYWN0TG9hZGVyfSBsb2FkZXIgVGhlIEFic3RyYWN0TG9hZGVyIGNsYXNzIHRvIHJlbW92ZVxuXHQgKi9cblx0cC51bnJlZ2lzdGVyTG9hZGVyID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdHZhciBpZHggPSB0aGlzLl9hdmFpbGFibGVMb2FkZXJzLmluZGV4T2YobG9hZGVyKTtcblx0XHRpZiAoaWR4ICE9IC0xICYmIGlkeCA8IHRoaXMuX2RlZmF1bHRMb2FkZXJMZW5ndGggLSAxKSB7XG5cdFx0XHR0aGlzLl9hdmFpbGFibGVMb2FkZXJzLnNwbGljZShpZHgsIDEpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBzZXRVc2VYSFJcblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBUaGUgbmV3IHVzZVhIUiB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRoZSBuZXcgdXNlWEhSIHZhbHVlLiBJZiBYSFIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYnJvd3NlciwgdGhpcyB3aWxsIHJldHVybiBmYWxzZSwgZXZlbiBpZlxuXHQgKiB0aGUgcHJvdmlkZWQgdmFsdWUgYXJndW1lbnQgd2FzIHRydWUuXG5cdCAqIEBzaW5jZSAwLjMuMFxuXHQgKiBAZGVwcmVjYXRlZCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcInByZWZlclhIUjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSwgb3IgdGhlIHt7I2Nyb3NzTGluayBcInNldFVzZVhIUlwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QgaW5zdGVhZC5cblx0ICovXG5cdHAuc2V0VXNlWEhSID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0UHJlZmVyWEhSKHZhbHVlKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2hhbmdlIHRoZSB7eyNjcm9zc0xpbmsgXCJwcmVmZXJYSFI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gdmFsdWUuIE5vdGUgdGhhdCBpZiB0aGlzIGlzIHNldCB0byBgdHJ1ZWAsIGl0IG1heVxuXHQgKiBmYWlsLCBvciBiZSBpZ25vcmVkIGRlcGVuZGluZyBvbiB0aGUgYnJvd3NlcidzIGNhcGFiaWxpdGllcyBhbmQgdGhlIGxvYWQgdHlwZS5cblx0ICogQG1ldGhvZCBzZXRQcmVmZXJYSFJcblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZVxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVGhlIHZhbHVlIG9mIHt7I2Nyb3NzTGluayBcInByZWZlclhIUlwifX17ey9jcm9zc0xpbmt9fSB0aGF0IHdhcyBzdWNjZXNzZnVsbHkgc2V0LlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuc2V0UHJlZmVyWEhSID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHdlIGNhbiB1c2UgWEhSLiBYSFIgZGVmYXVsdHMgdG8gVFJVRSwgYnV0IHRoZSBicm93c2VyIG1heSBub3Qgc3VwcG9ydCBpdC5cblx0XHQvL1RPRE86IFNob3VsZCB3ZSBiZSBjaGVja2luZyBmb3IgdGhlIG90aGVyIFhIUiB0eXBlcz8gTWlnaHQgaGF2ZSB0byBkbyBhIHRyeS9jYXRjaCBvbiB0aGUgZGlmZmVyZW50IHR5cGVzIHNpbWlsYXIgdG8gY3JlYXRlWEhSLlxuXHRcdHRoaXMucHJlZmVyWEhSID0gKHZhbHVlICE9IGZhbHNlICYmIHdpbmRvdy5YTUxIdHRwUmVxdWVzdCAhPSBudWxsKTtcblx0XHRyZXR1cm4gdGhpcy5wcmVmZXJYSFI7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3BzIGFsbCBxdWV1ZWQgYW5kIGxvYWRpbmcgaXRlbXMsIGFuZCBjbGVhcnMgdGhlIHF1ZXVlLiBUaGlzIGFsc28gcmVtb3ZlcyBhbGwgaW50ZXJuYWwgcmVmZXJlbmNlcyB0byBsb2FkZWRcblx0ICogY29udGVudCwgYW5kIGFsbG93cyB0aGUgcXVldWUgdG8gYmUgdXNlZCBhZ2Fpbi5cblx0ICogQG1ldGhvZCByZW1vdmVBbGxcblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXHRwLnJlbW92ZUFsbCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnJlbW92ZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9wcyBhbiBpdGVtIGZyb20gYmVpbmcgbG9hZGVkLCBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBxdWV1ZS4gSWYgbm90aGluZyBpcyBwYXNzZWQsIGFsbCBpdGVtcyBhcmUgcmVtb3ZlZC5cblx0ICogVGhpcyBhbHNvIHJlbW92ZXMgaW50ZXJuYWwgcmVmZXJlbmNlcyB0byBsb2FkZWQgaXRlbShzKS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHF1ZXVlLmxvYWRNYW5pZmVzdChbXG5cdCAqICAgICAgICAgIHtzcmM6XCJ0ZXN0LnBuZ1wiLCBpZDpcInBuZ1wifSxcblx0ICogICAgICAgICAge3NyYzpcInRlc3QuanBnXCIsIGlkOlwianBnXCJ9LFxuXHQgKiAgICAgICAgICB7c3JjOlwidGVzdC5tcDNcIiwgaWQ6XCJtcDNcIn1cblx0ICogICAgICBdKTtcblx0ICogICAgICBxdWV1ZS5yZW1vdmUoXCJwbmdcIik7IC8vIFNpbmdsZSBpdGVtIGJ5IElEXG5cdCAqICAgICAgcXVldWUucmVtb3ZlKFwicG5nXCIsIFwidGVzdC5qcGdcIik7IC8vIEl0ZW1zIGFzIGFyZ3VtZW50cy4gTWl4ZWQgaWQgYW5kIHNyYy5cblx0ICogICAgICBxdWV1ZS5yZW1vdmUoW1widGVzdC5wbmdcIiwgXCJqcGdcIl0pOyAvLyBJdGVtcyBpbiBhbiBBcnJheS4gTWl4ZWQgaWQgYW5kIHNyYy5cblx0ICpcblx0ICogQG1ldGhvZCByZW1vdmVcblx0ICogQHBhcmFtIHtTdHJpbmcgfCBBcnJheX0gaWRzT3JVcmxzKiBUaGUgaWQgb3IgaWRzIHRvIHJlbW92ZSBmcm9tIHRoaXMgcXVldWUuIFlvdSBjYW4gcGFzcyBhbiBpdGVtLCBhbiBhcnJheSBvZlxuXHQgKiBpdGVtcywgb3IgbXVsdGlwbGUgaXRlbXMgYXMgYXJndW1lbnRzLlxuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cdHAucmVtb3ZlID0gZnVuY3Rpb24gKGlkc09yVXJscykge1xuXHRcdHZhciBhcmdzID0gbnVsbDtcblxuXHRcdGlmIChpZHNPclVybHMgJiYgIShpZHNPclVybHMgaW5zdGFuY2VvZiBBcnJheSkpIHtcblx0XHRcdGFyZ3MgPSBbaWRzT3JVcmxzXTtcblx0XHR9IGVsc2UgaWYgKGlkc09yVXJscykge1xuXHRcdFx0YXJncyA9IGlkc09yVXJscztcblx0XHR9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGl0ZW1zV2VyZVJlbW92ZWQgPSBmYWxzZTtcblxuXHRcdC8vIERlc3Ryb3kgZXZlcnl0aGluZ1xuXHRcdGlmICghYXJncykge1xuXHRcdFx0dGhpcy5jbG9zZSgpO1xuXHRcdFx0Zm9yICh2YXIgbiBpbiB0aGlzLl9sb2FkSXRlbXNCeUlkKSB7XG5cdFx0XHRcdHRoaXMuX2Rpc3Bvc2VJdGVtKHRoaXMuX2xvYWRJdGVtc0J5SWRbbl0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5pbml0KHRoaXMucHJlZmVyWEhSLCB0aGlzLl9iYXNlUGF0aCk7XG5cblx0XHRcdC8vIFJlbW92ZSBzcGVjaWZpYyBpdGVtc1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aGlsZSAoYXJncy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSBhcmdzLnBvcCgpO1xuXHRcdFx0XHR2YXIgciA9IHRoaXMuZ2V0UmVzdWx0KGl0ZW0pO1xuXG5cdFx0XHRcdC8vUmVtb3ZlIGZyb20gdGhlIG1haW4gbG9hZCBRdWV1ZVxuXHRcdFx0XHRmb3IgKGkgPSB0aGlzLl9sb2FkUXVldWUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRsb2FkSXRlbSA9IHRoaXMuX2xvYWRRdWV1ZVtpXS5nZXRJdGVtKCk7XG5cdFx0XHRcdFx0aWYgKGxvYWRJdGVtLmlkID09IGl0ZW0gfHwgbG9hZEl0ZW0uc3JjID09IGl0ZW0pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2xvYWRRdWV1ZS5zcGxpY2UoaSwgMSlbMF0uY2FuY2VsKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvL1JlbW92ZSBmcm9tIHRoZSBiYWNrdXAgcXVldWVcblx0XHRcdFx0Zm9yIChpID0gdGhpcy5fbG9hZFF1ZXVlQmFja3VwLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0bG9hZEl0ZW0gPSB0aGlzLl9sb2FkUXVldWVCYWNrdXBbaV0uZ2V0SXRlbSgpO1xuXHRcdFx0XHRcdGlmIChsb2FkSXRlbS5pZCA9PSBpdGVtIHx8IGxvYWRJdGVtLnNyYyA9PSBpdGVtKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9sb2FkUXVldWVCYWNrdXAuc3BsaWNlKGksIDEpWzBdLmNhbmNlbCgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHIpIHtcblx0XHRcdFx0XHR0aGlzLl9kaXNwb3NlSXRlbSh0aGlzLmdldEl0ZW0oaXRlbSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSB0aGlzLl9jdXJyZW50TG9hZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRcdHZhciBsb2FkSXRlbSA9IHRoaXMuX2N1cnJlbnRMb2Fkc1tpXS5nZXRJdGVtKCk7XG5cdFx0XHRcdFx0XHRpZiAobG9hZEl0ZW0uaWQgPT0gaXRlbSB8fCBsb2FkSXRlbS5zcmMgPT0gaXRlbSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9jdXJyZW50TG9hZHMuc3BsaWNlKGksIDEpWzBdLmNhbmNlbCgpO1xuXHRcdFx0XHRcdFx0XHRpdGVtc1dlcmVSZW1vdmVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGNhbGxlZCBkdXJpbmcgYSBsb2FkLCB0cnkgdG8gbG9hZCB0aGUgbmV4dCBpdGVtLlxuXHRcdFx0aWYgKGl0ZW1zV2VyZVJlbW92ZWQpIHtcblx0XHRcdFx0dGhpcy5fbG9hZE5leHQoKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3BzIGFsbCBvcGVuIGxvYWRzLCBkZXN0cm95cyBhbnkgbG9hZGVkIGl0ZW1zLCBhbmQgcmVzZXRzIHRoZSBxdWV1ZSwgc28gYWxsIGl0ZW1zIGNhblxuXHQgKiBiZSByZWxvYWRlZCBhZ2FpbiBieSBjYWxsaW5nIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2xvYWRcIn19e3svY3Jvc3NMaW5rfX0uIEl0ZW1zIGFyZSBub3QgcmVtb3ZlZCBmcm9tIHRoZVxuXHQgKiBxdWV1ZS4gVG8gcmVtb3ZlIGl0ZW1zIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3JlbW92ZVwifX17ey9jcm9zc0xpbmt9fSBvclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvcmVtb3ZlQWxsXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblx0ICogQG1ldGhvZCByZXNldFxuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cdHAucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5jbG9zZSgpO1xuXHRcdGZvciAodmFyIG4gaW4gdGhpcy5fbG9hZEl0ZW1zQnlJZCkge1xuXHRcdFx0dGhpcy5fZGlzcG9zZUl0ZW0odGhpcy5fbG9hZEl0ZW1zQnlJZFtuXSk7XG5cdFx0fVxuXG5cdFx0Ly9SZXNldCB0aGUgcXVldWUgdG8gaXRzIHN0YXJ0IHN0YXRlXG5cdFx0dmFyIGEgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2xvYWRRdWV1ZUJhY2t1cC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGEucHVzaCh0aGlzLl9sb2FkUXVldWVCYWNrdXBbaV0uZ2V0SXRlbSgpKTtcblx0XHR9XG5cblx0XHR0aGlzLmxvYWRNYW5pZmVzdChhLCBmYWxzZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVyIGEgcGx1Z2luLiBQbHVnaW5zIGNhbiBtYXAgdG8gbG9hZCB0eXBlcyAoc291bmQsIGltYWdlLCBldGMpLCBvciBzcGVjaWZpYyBleHRlbnNpb25zIChwbmcsIG1wMywgZXRjKS5cblx0ICogQ3VycmVudGx5LCBvbmx5IG9uZSBwbHVnaW4gY2FuIGV4aXN0IHBlciB0eXBlL2V4dGVuc2lvbi5cblx0ICpcblx0ICogV2hlbiBhIHBsdWdpbiBpcyBpbnN0YWxsZWQsIGEgPGNvZGU+Z2V0UHJlbG9hZEhhbmRsZXJzKCk8L2NvZGU+IG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBvbiBpdC4gRm9yIG1vcmUgaW5mb3JtYXRpb25cblx0ICogb24gdGhpcyBtZXRob2QsIGNoZWNrIG91dCB0aGUge3sjY3Jvc3NMaW5rIFwiU2FtcGxlUGx1Z2luL2dldFByZWxvYWRIYW5kbGVyc1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgaW4gdGhlXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNhbXBsZVBsdWdpblwifX17ey9jcm9zc0xpbmt9fSBjbGFzcy5cblx0ICpcblx0ICogQmVmb3JlIGEgZmlsZSBpcyBsb2FkZWQsIGEgbWF0Y2hpbmcgcGx1Z2luIGhhcyBhbiBvcHBvcnR1bml0eSB0byBtb2RpZnkgdGhlIGxvYWQuIElmIGEgYGNhbGxiYWNrYCBpcyByZXR1cm5lZFxuXHQgKiBmcm9tIHRoZSB7eyNjcm9zc0xpbmsgXCJTYW1wbGVQbHVnaW4vZ2V0UHJlbG9hZEhhbmRsZXJzXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCwgaXQgd2lsbCBiZSBpbnZva2VkIGZpcnN0LCBhbmQgaXRzXG5cdCAqIHJlc3VsdCBtYXkgY2FuY2VsIG9yIG1vZGlmeSB0aGUgaXRlbS4gVGhlIGNhbGxiYWNrIG1ldGhvZCBjYW4gYWxzbyByZXR1cm4gYSBgY29tcGxldGVIYW5kbGVyYCB0byBiZSBmaXJlZCB3aGVuXG5cdCAqIHRoZSBmaWxlIGlzIGxvYWRlZCwgb3IgYSBgdGFnYCBvYmplY3QsIHdoaWNoIHdpbGwgbWFuYWdlIHRoZSBhY3R1YWwgZG93bmxvYWQuIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlXG5cdCAqIG1ldGhvZHMsIGNoZWNrIG91dCB0aGUge3sjY3Jvc3NMaW5rIFwiU2FtcGxlUGx1Z2luL3ByZWxvYWRIYW5kbGVyXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJTYW1wbGVQbHVnaW4vZmlsZUxvYWRIYW5kbGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZHMgb24gdGhlIHt7I2Nyb3NzTGluayBcIlNhbXBsZVBsdWdpblwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogQG1ldGhvZCBpbnN0YWxsUGx1Z2luXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHBsdWdpbiBUaGUgcGx1Z2luIGNsYXNzIHRvIGluc3RhbGwuXG5cdCAqL1xuXHRwLmluc3RhbGxQbHVnaW4gPSBmdW5jdGlvbiAocGx1Z2luKSB7XG5cdFx0aWYgKHBsdWdpbiA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHBsdWdpbi5nZXRQcmVsb2FkSGFuZGxlcnMgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fcGx1Z2lucy5wdXNoKHBsdWdpbik7XG5cdFx0XHR2YXIgbWFwID0gcGx1Z2luLmdldFByZWxvYWRIYW5kbGVycygpO1xuXHRcdFx0bWFwLnNjb3BlID0gcGx1Z2luO1xuXG5cdFx0XHRpZiAobWFwLnR5cGVzICE9IG51bGwpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBtYXAudHlwZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5fdHlwZUNhbGxiYWNrc1ttYXAudHlwZXNbaV1dID0gbWFwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtYXAuZXh0ZW5zaW9ucyAhPSBudWxsKSB7XG5cdFx0XHRcdGZvciAoaSA9IDAsIGwgPSBtYXAuZXh0ZW5zaW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR0aGlzLl9leHRlbnNpb25DYWxsYmFja3NbbWFwLmV4dGVuc2lvbnNbaV1dID0gbWFwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbmN1cnJlbnQgY29ubmVjdGlvbnMuIE5vdGUgdGhhdCBicm93c2VycyBhbmQgc2VydmVycyBtYXkgaGF2ZSBhIGJ1aWx0LWluIG1heGltdW1cblx0ICogbnVtYmVyIG9mIG9wZW4gY29ubmVjdGlvbnMsIHNvIGFueSBhZGRpdGlvbmFsIGNvbm5lY3Rpb25zIG1heSByZW1haW4gaW4gYSBwZW5kaW5nIHN0YXRlIHVudGlsIHRoZSBicm93c2VyXG5cdCAqIG9wZW5zIHRoZSBjb25uZWN0aW9uLiBXaGVuIGxvYWRpbmcgc2NyaXB0cyB1c2luZyB0YWdzLCBhbmQgd2hlbiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbWFpbnRhaW5TY3JpcHRPcmRlcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpcyBgdHJ1ZWAsIG9ubHkgb25lIHNjcmlwdCBpcyBsb2FkZWQgYXQgYSB0aW1lIGR1ZSB0byBicm93c2VyIGxpbWl0YXRpb25zLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIHF1ZXVlID0gbmV3IGNyZWF0ZWpzLkxvYWRRdWV1ZSgpO1xuXHQgKiAgICAgIHF1ZXVlLnNldE1heENvbm5lY3Rpb25zKDEwKTsgLy8gQWxsb3cgMTAgY29uY3VycmVudCBsb2Fkc1xuXHQgKlxuXHQgKiBAbWV0aG9kIHNldE1heENvbm5lY3Rpb25zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgbG9hZHMgdG8gYWxsb3cuIEJ5IGRlZmF1bHQsIG9ubHkgYSBzaW5nbGUgY29ubmVjdGlvbiBwZXIgTG9hZFF1ZXVlXG5cdCAqIGlzIG9wZW4gYXQgYW55IHRpbWUuXG5cdCAqL1xuXHRwLnNldE1heENvbm5lY3Rpb25zID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dGhpcy5fbWF4Q29ubmVjdGlvbnMgPSB2YWx1ZTtcblx0XHRpZiAoIXRoaXMuX3BhdXNlZCAmJiB0aGlzLl9sb2FkUXVldWUubGVuZ3RoID4gMCkge1xuXHRcdFx0dGhpcy5fbG9hZE5leHQoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIExvYWQgYSBzaW5nbGUgZmlsZS4gVG8gYWRkIG11bHRpcGxlIGZpbGVzIGF0IG9uY2UsIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuXG5cdCAqXG5cdCAqIEZpbGVzIGFyZSBhbHdheXMgYXBwZW5kZWQgdG8gdGhlIGN1cnJlbnQgcXVldWUsIHNvIHRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIG11bHRpcGxlIHRpbWVzIHRvIGFkZCBmaWxlcy5cblx0ICogVG8gY2xlYXIgdGhlIHF1ZXVlIGZpcnN0LCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2Nsb3NlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblx0ICogQG1ldGhvZCBsb2FkRmlsZVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdHxTdHJpbmd9IGZpbGUgVGhlIGZpbGUgb2JqZWN0IG9yIHBhdGggdG8gbG9hZC4gQSBmaWxlIGNhbiBiZSBlaXRoZXJcblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPkEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2U8L2xpPlxuXHQgKiAgICAgPGxpPkFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgZGVmaW5lZCBieSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fTwvbGk+XG5cdCAqICAgICA8bGk+T1IgQSBzdHJpbmcgcGF0aCB0byBhIHJlc291cmNlLiBOb3RlIHRoYXQgdGhpcyBraW5kIG9mIGxvYWQgaXRlbSB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqICAgICBpbiB0aGUgYmFja2dyb3VuZC48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtsb2FkTm93PXRydWVdIEtpY2sgb2ZmIGFuIGltbWVkaWF0ZSBsb2FkICh0cnVlKSBvciB3YWl0IGZvciBhIGxvYWQgY2FsbCAoZmFsc2UpLiBUaGUgZGVmYXVsdFxuXHQgKiB2YWx1ZSBpcyB0cnVlLiBJZiB0aGUgcXVldWUgaXMgcGF1c2VkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRQYXVzZWRcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCB0aGUgdmFsdWUgaXNcblx0ICogYHRydWVgLCB0aGUgcXVldWUgd2lsbCByZXN1bWUgYXV0b21hdGljYWxseS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtiYXNlUGF0aF0gQSBiYXNlIHBhdGggdGhhdCB3aWxsIGJlIHByZXBlbmRlZCB0byBlYWNoIGZpbGUuIFRoZSBiYXNlUGF0aCBhcmd1bWVudCBvdmVycmlkZXMgdGhlXG5cdCAqIHBhdGggc3BlY2lmaWVkIGluIHRoZSBjb25zdHJ1Y3Rvci4gTm90ZSB0aGF0IGlmIHlvdSBsb2FkIGEgbWFuaWZlc3QgdXNpbmcgYSBmaWxlIG9mIHR5cGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvTUFOSUZFU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIGl0cyBmaWxlcyB3aWxsIDxzdHJvbmc+Tk9UPC9zdHJvbmc+IHVzZSB0aGUgYmFzZVBhdGggcGFyYW1ldGVyLiA8c3Ryb25nPlRoZSBiYXNlUGF0aCBwYXJhbWV0ZXIgaXMgZGVwcmVjYXRlZC48L3N0cm9uZz5cblx0ICogVGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uIFBsZWFzZSBlaXRoZXIgdXNlIHRoZSBgYmFzZVBhdGhgIHBhcmFtZXRlciBpbiB0aGUgTG9hZFF1ZXVlXG5cdCAqIGNvbnN0cnVjdG9yLCBvciBhIGBwYXRoYCBwcm9wZXJ0eSBpbiBhIG1hbmlmZXN0IGRlZmluaXRpb24uXG5cdCAqL1xuXHRwLmxvYWRGaWxlID0gZnVuY3Rpb24gKGZpbGUsIGxvYWROb3csIGJhc2VQYXRoKSB7XG5cdFx0aWYgKGZpbGUgPT0gbnVsbCkge1xuXHRcdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJQUkVMT0FEX05PX0ZJTEVcIik7XG5cdFx0XHR0aGlzLl9zZW5kRXJyb3IoZXZlbnQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9hZGRJdGVtKGZpbGUsIG51bGwsIGJhc2VQYXRoKTtcblxuXHRcdGlmIChsb2FkTm93ICE9PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5zZXRQYXVzZWQoZmFsc2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNldFBhdXNlZCh0cnVlKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIExvYWQgYW4gYXJyYXkgb2YgZmlsZXMuIFRvIGxvYWQgYSBzaW5nbGUgZmlsZSwgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXHQgKiBUaGUgZmlsZXMgaW4gdGhlIG1hbmlmZXN0IGFyZSByZXF1ZXN0ZWQgaW4gdGhlIHNhbWUgb3JkZXIsIGJ1dCBtYXkgY29tcGxldGUgaW4gYSBkaWZmZXJlbnQgb3JkZXIgaWYgdGhlIG1heFxuXHQgKiBjb25uZWN0aW9ucyBhcmUgc2V0IGFib3ZlIDEgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldE1heENvbm5lY3Rpb25zXCJ9fXt7L2Nyb3NzTGlua319LiBTY3JpcHRzIHdpbGwgbG9hZFxuXHQgKiBpbiB0aGUgcmlnaHQgb3JkZXIgYXMgbG9uZyBhcyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbWFpbnRhaW5TY3JpcHRPcmRlclwifX17ey9jcm9zc0xpbmt9fSBpcyB0cnVlICh3aGljaCBpc1xuXHQgKiBkZWZhdWx0KS5cblx0ICpcblx0ICogRmlsZXMgYXJlIGFsd2F5cyBhcHBlbmRlZCB0byB0aGUgY3VycmVudCBxdWV1ZSwgc28gdGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgbXVsdGlwbGUgdGltZXMgdG8gYWRkIGZpbGVzLlxuXHQgKiBUbyBjbGVhciB0aGUgcXVldWUgZmlyc3QsIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvY2xvc2VcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXHQgKiBAbWV0aG9kIGxvYWRNYW5pZmVzdFxuXHQgKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xPYmplY3R9IG1hbmlmZXN0IEFuIGxpc3Qgb2YgZmlsZXMgdG8gbG9hZC4gVGhlIGxvYWRNYW5pZmVzdCBjYWxsIHN1cHBvcnRzIGZvdXIgdHlwZXMgb2Zcblx0ICogbWFuaWZlc3RzOlxuXHQgKiA8b2w+XG5cdCAqICAgICA8bGk+QSBzdHJpbmcgcGF0aCwgd2hpY2ggcG9pbnRzIHRvIGEgbWFuaWZlc3QgZmlsZSwgd2hpY2ggaXMgYSBKU09OIGZpbGUgdGhhdCBjb250YWlucyBhIFwibWFuaWZlc3RcIiBwcm9wZXJ0eSxcblx0ICogICAgIHdoaWNoIGRlZmluZXMgdGhlIGxpc3Qgb2YgZmlsZXMgdG8gbG9hZCwgYW5kIGNhbiBvcHRpb25hbGx5IGNvbnRhaW4gYSBcInBhdGhcIiBwcm9wZXJ0eSwgd2hpY2ggd2lsbCBiZVxuXHQgKiAgICAgcHJlcGVuZGVkIHRvIGVhY2ggZmlsZSBpbiB0aGUgbGlzdC48L2xpPlxuXHQgKiAgICAgPGxpPkFuIG9iamVjdCB3aGljaCBkZWZpbmVzIGEgXCJzcmNcIiwgd2hpY2ggaXMgYSBKU09OIG9yIEpTT05QIGZpbGUuIEEgXCJjYWxsYmFja1wiIGNhbiBiZSBkZWZpbmVkIGZvciBKU09OUFxuXHQgKiAgICAgZmlsZS4gVGhlIEpTT04vSlNPTlAgZmlsZSBzaG91bGQgY29udGFpbiBhIFwibWFuaWZlc3RcIiBwcm9wZXJ0eSwgd2hpY2ggZGVmaW5lcyB0aGUgbGlzdCBvZiBmaWxlcyB0byBsb2FkLFxuXHQgKiAgICAgYW5kIGNhbiBvcHRpb25hbGx5IGNvbnRhaW4gYSBcInBhdGhcIiBwcm9wZXJ0eSwgd2hpY2ggd2lsbCBiZSBwcmVwZW5kZWQgdG8gZWFjaCBmaWxlIGluIHRoZSBsaXN0LjwvbGk+XG5cdCAqICAgICA8bGk+QW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIGEgXCJtYW5pZmVzdFwiIHByb3BlcnR5LCB3aGljaCBkZWZpbmVzIHRoZSBsaXN0IG9mIGZpbGVzIHRvIGxvYWQsIGFuZCBjYW5cblx0ICogICAgIG9wdGlvbmFsbHkgY29udGFpbiBhIFwicGF0aFwiIHByb3BlcnR5LCB3aGljaCB3aWxsIGJlIHByZXBlbmRlZCB0byBlYWNoIGZpbGUgaW4gdGhlIGxpc3QuPC9saT5cblx0ICogICAgIDxsaT5BbiBBcnJheSBvZiBmaWxlcyB0byBsb2FkLjwvbGk+XG5cdCAqIDwvb2w+XG5cdCAqXG5cdCAqIEVhY2ggXCJmaWxlXCIgaW4gYSBtYW5pZmVzdCBjYW4gYmUgZWl0aGVyOlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+QSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZTwvbGk+XG5cdCAqICAgICA8bGk+QW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBkZWZpbmVkIGJ5IHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319PC9saT5cblx0ICogICAgIDxsaT5PUiBBIHN0cmluZyBwYXRoIHRvIGEgcmVzb3VyY2UuIE5vdGUgdGhhdCB0aGlzIGtpbmQgb2YgbG9hZCBpdGVtIHdpbGwgYmUgY29udmVydGVkIHRvIGEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX1cblx0ICogICAgIGluIHRoZSBiYWNrZ3JvdW5kLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2xvYWROb3c9dHJ1ZV0gS2ljayBvZmYgYW4gaW1tZWRpYXRlIGxvYWQgKHRydWUpIG9yIHdhaXQgZm9yIGEgbG9hZCBjYWxsIChmYWxzZSkuIFRoZSBkZWZhdWx0XG5cdCAqIHZhbHVlIGlzIHRydWUuIElmIHRoZSBxdWV1ZSBpcyBwYXVzZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldFBhdXNlZFwifX17ey9jcm9zc0xpbmt9fSBhbmQgdGhpcyB2YWx1ZSBpc1xuXHQgKiBgdHJ1ZWAsIHRoZSBxdWV1ZSB3aWxsIHJlc3VtZSBhdXRvbWF0aWNhbGx5LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2Jhc2VQYXRoXSBBIGJhc2UgcGF0aCB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIHRvIGVhY2ggZmlsZS4gVGhlIGJhc2VQYXRoIGFyZ3VtZW50IG92ZXJyaWRlcyB0aGVcblx0ICogcGF0aCBzcGVjaWZpZWQgaW4gdGhlIGNvbnN0cnVjdG9yLiBOb3RlIHRoYXQgaWYgeW91IGxvYWQgYSBtYW5pZmVzdCB1c2luZyBhIGZpbGUgb2YgdHlwZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvTUFOSUZFU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIGl0cyBmaWxlcyB3aWxsIDxzdHJvbmc+Tk9UPC9zdHJvbmc+IHVzZSB0aGUgYmFzZVBhdGggcGFyYW1ldGVyLiA8c3Ryb25nPlRoZSBiYXNlUGF0aCBwYXJhbWV0ZXIgaXMgZGVwcmVjYXRlZC48L3N0cm9uZz5cblx0ICogVGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uIFBsZWFzZSBlaXRoZXIgdXNlIHRoZSBgYmFzZVBhdGhgIHBhcmFtZXRlciBpbiB0aGUgTG9hZFF1ZXVlXG5cdCAqIGNvbnN0cnVjdG9yLCBvciBhIGBwYXRoYCBwcm9wZXJ0eSBpbiBhIG1hbmlmZXN0IGRlZmluaXRpb24uXG5cdCAqL1xuXHRwLmxvYWRNYW5pZmVzdCA9IGZ1bmN0aW9uIChtYW5pZmVzdCwgbG9hZE5vdywgYmFzZVBhdGgpIHtcblx0XHR2YXIgZmlsZUxpc3QgPSBudWxsO1xuXHRcdHZhciBwYXRoID0gbnVsbDtcblxuXHRcdC8vIEFycmF5LWJhc2VkIGxpc3Qgb2YgaXRlbXNcblx0XHRpZiAobWFuaWZlc3QgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0aWYgKG1hbmlmZXN0Lmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9NQU5JRkVTVF9FTVBUWVwiKTtcblx0XHRcdFx0dGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0ZmlsZUxpc3QgPSBtYW5pZmVzdDtcblxuXHRcdFx0Ly8gU3RyaW5nLWJhc2VkLiBPbmx5IGZpbGUgbWFuaWZlc3RzIGNhbiBiZSBzcGVjaWZpZWQgdGhpcyB3YXkuIEFueSBvdGhlciB0eXBlcyB3aWxsIGNhdXNlIGFuIGVycm9yIHdoZW4gbG9hZGVkLlxuXHRcdH0gZWxzZSBpZiAodHlwZW9mKG1hbmlmZXN0KSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0ZmlsZUxpc3QgPSBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzcmM6IG1hbmlmZXN0LFxuXHRcdFx0XHRcdHR5cGU6IHMuTUFOSUZFU1Rcblx0XHRcdFx0fVxuXHRcdFx0XTtcblxuXHRcdH0gZWxzZSBpZiAodHlwZW9mKG1hbmlmZXN0KSA9PSBcIm9iamVjdFwiKSB7XG5cblx0XHRcdC8vIEFuIG9iamVjdCB0aGF0IGRlZmluZXMgYSBtYW5pZmVzdCBwYXRoXG5cdFx0XHRpZiAobWFuaWZlc3Quc3JjICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKG1hbmlmZXN0LnR5cGUgPT0gbnVsbCkge1xuXHRcdFx0XHRcdG1hbmlmZXN0LnR5cGUgPSBzLk1BTklGRVNUO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG1hbmlmZXN0LnR5cGUgIT0gcy5NQU5JRkVTVCkge1xuXHRcdFx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9NQU5JRkVTVF9UWVBFXCIpO1xuXHRcdFx0XHRcdHRoaXMuX3NlbmRFcnJvcihldmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZmlsZUxpc3QgPSBbbWFuaWZlc3RdO1xuXG5cdFx0XHRcdC8vIEFuIG9iamVjdCB0aGF0IGRlZmluZXMgYSBtYW5pZmVzdFxuXHRcdFx0fSBlbHNlIGlmIChtYW5pZmVzdC5tYW5pZmVzdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGZpbGVMaXN0ID0gbWFuaWZlc3QubWFuaWZlc3Q7XG5cdFx0XHRcdHBhdGggPSBtYW5pZmVzdC5wYXRoO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVbnN1cHBvcnRlZC4gVGhpcyB3aWxsIHRocm93IGFuIGVycm9yLlxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlBSRUxPQURfTUFOSUZFU1RfTlVMTFwiKTtcblx0XHRcdHRoaXMuX3NlbmRFcnJvcihldmVudCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBmaWxlTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHRoaXMuX2FkZEl0ZW0oZmlsZUxpc3RbaV0sIHBhdGgsIGJhc2VQYXRoKTtcblx0XHR9XG5cblx0XHRpZiAobG9hZE5vdyAhPT0gZmFsc2UpIHtcblx0XHRcdHRoaXMuc2V0UGF1c2VkKGZhbHNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRQYXVzZWQodHJ1ZSk7XG5cdFx0fVxuXG5cdH07XG5cblx0LyoqXG5cdCAqIFN0YXJ0IGEgTG9hZFF1ZXVlIHRoYXQgd2FzIGNyZWF0ZWQsIGJ1dCBub3QgYXV0b21hdGljYWxseSBzdGFydGVkLlxuXHQgKiBAbWV0aG9kIGxvYWRcblx0ICovXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnNldFBhdXNlZChmYWxzZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIExvb2sgdXAgYSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSB1c2luZyBlaXRoZXIgdGhlIFwiaWRcIiBvciBcInNyY1wiIHRoYXQgd2FzIHNwZWNpZmllZCB3aGVuIGxvYWRpbmcgaXQuIE5vdGUgdGhhdCBpZiBubyBcImlkXCIgd2FzXG5cdCAqIHN1cHBsaWVkIHdpdGggdGhlIGxvYWQgaXRlbSwgdGhlIElEIHdpbGwgYmUgdGhlIFwic3JjXCIsIGluY2x1ZGluZyBhIGBwYXRoYCBwcm9wZXJ0eSBkZWZpbmVkIGJ5IGEgbWFuaWZlc3QuIFRoZVxuXHQgKiBgYmFzZVBhdGhgIHdpbGwgbm90IGJlIHBhcnQgb2YgdGhlIElELlxuXHQgKiBAbWV0aG9kIGdldEl0ZW1cblx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSA8Y29kZT5pZDwvY29kZT4gb3IgPGNvZGU+c3JjPC9jb2RlPiBvZiB0aGUgbG9hZCBpdGVtLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBsb2FkIGl0ZW0gdGhhdCB3YXMgaW5pdGlhbGx5IHJlcXVlc3RlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogb3Ige3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fS4gVGhpcyBvYmplY3QgaXMgYWxzbyByZXR1cm5lZCB2aWEgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBhcyB0aGUgYGl0ZW1gIHBhcmFtZXRlci5cblx0ICovXG5cdHAuZ2V0SXRlbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHJldHVybiB0aGlzLl9sb2FkSXRlbXNCeUlkW3ZhbHVlXSB8fCB0aGlzLl9sb2FkSXRlbXNCeVNyY1t2YWx1ZV07XG5cdH07XG5cblx0LyoqXG5cdCAqIExvb2sgdXAgYSBsb2FkZWQgcmVzdWx0IHVzaW5nIGVpdGhlciB0aGUgXCJpZFwiIG9yIFwic3JjXCIgdGhhdCB3YXMgc3BlY2lmaWVkIHdoZW4gbG9hZGluZyBpdC4gTm90ZSB0aGF0IGlmIG5vIFwiaWRcIlxuXHQgKiB3YXMgc3VwcGxpZWQgd2l0aCB0aGUgbG9hZCBpdGVtLCB0aGUgSUQgd2lsbCBiZSB0aGUgXCJzcmNcIiwgaW5jbHVkaW5nIGEgYHBhdGhgIHByb3BlcnR5IGRlZmluZWQgYnkgYSBtYW5pZmVzdC4gVGhlXG5cdCAqIGBiYXNlUGF0aGAgd2lsbCBub3QgYmUgcGFydCBvZiB0aGUgSUQuXG5cdCAqIEBtZXRob2QgZ2V0UmVzdWx0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgPGNvZGU+aWQ8L2NvZGU+IG9yIDxjb2RlPnNyYzwvY29kZT4gb2YgdGhlIGxvYWQgaXRlbS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcmF3UmVzdWx0PWZhbHNlXSBSZXR1cm4gYSByYXcgcmVzdWx0IGluc3RlYWQgb2YgYSBmb3JtYXR0ZWQgcmVzdWx0LiBUaGlzIGFwcGxpZXMgdG8gY29udGVudFxuXHQgKiBsb2FkZWQgdmlhIFhIUiBzdWNoIGFzIHNjcmlwdHMsIFhNTCwgQ1NTLCBhbmQgSW1hZ2VzLiBJZiB0aGVyZSBpcyBubyByYXcgcmVzdWx0LCB0aGUgZm9ybWF0dGVkIHJlc3VsdCB3aWxsIGJlXG5cdCAqIHJldHVybmVkIGluc3RlYWQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQSByZXN1bHQgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvbnRlbnQgdGhhdCB3YXMgbG9hZGVkLCBzdWNoIGFzOlxuXHQgKiA8dWw+XG5cdCAqICAgICAgPGxpPkFuIGltYWdlIHRhZyAoJmx0O2ltYWdlIC8mZ3Q7KSBmb3IgaW1hZ2VzPC9saT5cblx0ICogICAgICA8bGk+QSBzY3JpcHQgdGFnIGZvciBKYXZhU2NyaXB0ICgmbHQ7c2NyaXB0IC8mZ3Q7KS4gTm90ZSB0aGF0IHNjcmlwdHMgYXJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gdGhlIEhUTUxcblx0ICogICAgICBET00uPC9saT5cblx0ICogICAgICA8bGk+QSBzdHlsZSB0YWcgZm9yIENTUyAoJmx0O3N0eWxlIC8mZ3Q7IG9yICZsdDtsaW5rICZndDspPC9saT5cblx0ICogICAgICA8bGk+UmF3IHRleHQgZm9yIFRFWFQ8L2xpPlxuXHQgKiAgICAgIDxsaT5BIGZvcm1hdHRlZCBKYXZhU2NyaXB0IG9iamVjdCBkZWZpbmVkIGJ5IEpTT048L2xpPlxuXHQgKiAgICAgIDxsaT5BbiBYTUwgZG9jdW1lbnQ8L2xpPlxuXHQgKiAgICAgIDxsaT5BIGJpbmFyeSBhcnJheWJ1ZmZlciBsb2FkZWQgYnkgWEhSPC9saT5cblx0ICogICAgICA8bGk+QW4gYXVkaW8gdGFnICgmbHQ7YXVkaW8gJmd0OykgZm9yIEhUTUwgYXVkaW8uIE5vdGUgdGhhdCBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgU291bmRKUyBBUElzIHRvIHBsYXlcblx0ICogICAgICBsb2FkZWQgYXVkaW8uIFNwZWNpZmljYWxseSwgYXVkaW8gbG9hZGVkIGJ5IEZsYXNoIGFuZCBXZWJBdWRpbyB3aWxsIHJldHVybiBhIGxvYWRlciBvYmplY3QgdXNpbmcgdGhpcyBtZXRob2Rcblx0ICogICAgICB3aGljaCBjYW4gbm90IGJlIHVzZWQgdG8gcGxheSBhdWRpbyBiYWNrLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIFRoaXMgb2JqZWN0IGlzIGFsc28gcmV0dXJuZWQgdmlhIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZWxvYWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgYXMgdGhlICdpdGVtYFxuXHQgKiBwYXJhbWV0ZXIuIE5vdGUgdGhhdCBpZiBhIHJhdyByZXN1bHQgaXMgcmVxdWVzdGVkLCBidXQgbm90IGZvdW5kLCB0aGUgcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZC5cblx0ICovXG5cdHAuZ2V0UmVzdWx0ID0gZnVuY3Rpb24gKHZhbHVlLCByYXdSZXN1bHQpIHtcblx0XHR2YXIgaXRlbSA9IHRoaXMuX2xvYWRJdGVtc0J5SWRbdmFsdWVdIHx8IHRoaXMuX2xvYWRJdGVtc0J5U3JjW3ZhbHVlXTtcblx0XHRpZiAoaXRlbSA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0dmFyIGlkID0gaXRlbS5pZDtcblx0XHRpZiAocmF3UmVzdWx0ICYmIHRoaXMuX2xvYWRlZFJhd1Jlc3VsdHNbaWRdKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbG9hZGVkUmF3UmVzdWx0c1tpZF07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9sb2FkZWRSZXN1bHRzW2lkXTtcblx0fTtcblxuXHQvKipcblx0ICogR2VuZXJhdGUgYW4gbGlzdCBvZiBpdGVtcyBsb2FkZWQgYnkgdGhpcyBxdWV1ZS5cblx0ICogQG1ldGhvZCBnZXRJdGVtc1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGxvYWRlZCBEZXRlcm1pbmVzIGlmIG9ubHkgaXRlbXMgdGhhdCBoYXZlIGJlZW4gbG9hZGVkIHNob3VsZCBiZSByZXR1cm5lZC4gSWYgZmFsc2UsIGluLXByb2dyZXNzXG5cdCAqIGFuZCBmYWlsZWQgbG9hZCBpdGVtcyB3aWxsIGFsc28gYmUgaW5jbHVkZWQuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBsaXN0IG9mIG9iamVjdHMgdGhhdCBoYXZlIGJlZW4gbG9hZGVkLiBFYWNoIGl0ZW0gaW5jbHVkZXMgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiByZXN1bHQsIGFuZCByYXdSZXN1bHQuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5nZXRJdGVtcyA9IGZ1bmN0aW9uIChsb2FkZWQpIHtcblx0XHR2YXIgYXJyID0gW107XG5cdFx0Zm9yICh2YXIgbiBpbiB0aGlzLl9sb2FkSXRlbXNCeUlkKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHRoaXMuX2xvYWRJdGVtc0J5SWRbbl07XG5cdFx0XHR2YXIgcmVzdWx0ID0gdGhpcy5nZXRSZXN1bHQobik7XG5cdFx0XHRpZiAobG9hZGVkID09PSB0cnVlICYmIHJlc3VsdCA9PSBudWxsKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0YXJyLnB1c2goe1xuXHRcdFx0XHRpdGVtOiBpdGVtLFxuXHRcdFx0XHRyZXN1bHQ6IHJlc3VsdCxcblx0XHRcdFx0cmF3UmVzdWx0OiB0aGlzLmdldFJlc3VsdChuLCB0cnVlKVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBhcnI7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhdXNlIG9yIHJlc3VtZSB0aGUgY3VycmVudCBsb2FkLiBBY3RpdmUgbG9hZHMgd2lsbCBub3QgYmUgY2FuY2VsbGVkLCBidXQgdGhlIG5leHQgaXRlbXMgaW4gdGhlIHF1ZXVlIHdpbGwgbm90XG5cdCAqIGJlIHByb2Nlc3NlZCB3aGVuIGFjdGl2ZSBsb2FkcyBjb21wbGV0ZS4gTG9hZFF1ZXVlcyBhcmUgbm90IHBhdXNlZCBieSBkZWZhdWx0LlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgaWYgbmV3IGl0ZW1zIGFyZSBhZGRlZCB0byB0aGUgcXVldWUgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX0sIGEgcGF1c2VkIHF1ZXVlIHdpbGwgYmUgcmVzdW1lZCwgdW5sZXNzIHRoZSBgbG9hZE5vd2Bcblx0ICogYXJndW1lbnQgaXMgYGZhbHNlYC5cblx0ICogQG1ldGhvZCBzZXRQYXVzZWRcblx0ICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSBXaGV0aGVyIHRoZSBxdWV1ZSBzaG91bGQgYmUgcGF1c2VkIG9yIG5vdC5cblx0ICovXG5cdHAuc2V0UGF1c2VkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dGhpcy5fcGF1c2VkID0gdmFsdWU7XG5cdFx0aWYgKCF0aGlzLl9wYXVzZWQpIHtcblx0XHRcdHRoaXMuX2xvYWROZXh0KCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbG9zZSB0aGUgYWN0aXZlIHF1ZXVlLiBDbG9zaW5nIGEgcXVldWUgY29tcGxldGVseSBlbXB0aWVzIHRoZSBxdWV1ZSwgYW5kIHByZXZlbnRzIGFueSByZW1haW5pbmcgaXRlbXMgZnJvbVxuXHQgKiBzdGFydGluZyB0byBkb3dubG9hZC4gTm90ZSB0aGF0IGN1cnJlbnRseSBhbnkgYWN0aXZlIGxvYWRzIHdpbGwgcmVtYWluIG9wZW4sIGFuZCBldmVudHMgbWF5IGJlIHByb2Nlc3NlZC5cblx0ICpcblx0ICogVG8gc3RvcCBhbmQgcmVzdGFydCBhIHF1ZXVlLCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9zZXRQYXVzZWRcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGluc3RlYWQuXG5cdCAqIEBtZXRob2QgY2xvc2Vcblx0ICovXG5cdHAuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0d2hpbGUgKHRoaXMuX2N1cnJlbnRMb2Fkcy5sZW5ndGgpIHtcblx0XHRcdHRoaXMuX2N1cnJlbnRMb2Fkcy5wb3AoKS5jYW5jZWwoKTtcblx0XHR9XG5cdFx0dGhpcy5fc2NyaXB0T3JkZXIubGVuZ3RoID0gMDtcblx0XHR0aGlzLl9sb2FkZWRTY3JpcHRzLmxlbmd0aCA9IDA7XG5cdFx0dGhpcy5sb2FkU3RhcnRXYXNEaXNwYXRjaGVkID0gZmFsc2U7XG5cdFx0dGhpcy5faXRlbUNvdW50ID0gMDtcblx0XHR0aGlzLl9sYXN0UHJvZ3Jlc3MgPSBOYU47XG5cdH07XG5cbi8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBBZGQgYW4gaXRlbSB0byB0aGUgcXVldWUuIEl0ZW1zIGFyZSBmb3JtYXR0ZWQgaW50byBhIHVzYWJsZSBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHByb3BlcnRpZXMgbmVjZXNzYXJ5IHRvXG5cdCAqIGxvYWQgdGhlIGNvbnRlbnQuIFRoZSBsb2FkIHF1ZXVlIGlzIHBvcHVsYXRlZCB3aXRoIHRoZSBsb2FkZXIgaW5zdGFuY2UgdGhhdCBoYW5kbGVzIHByZWxvYWRpbmcsIGFuZCBub3QgdGhlIGxvYWRcblx0ICogaXRlbSB0aGF0IHdhcyBwYXNzZWQgaW4gYnkgdGhlIHVzZXIuIFRvIGxvb2sgdXAgdGhlIGxvYWQgaXRlbSBieSBpZCBvciBzcmMsIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlLmdldEl0ZW1cIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLlxuXHQgKiBAbWV0aG9kIF9hZGRJdGVtXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdmFsdWUgVGhlIGl0ZW0gdG8gYWRkIHRvIHRoZSBxdWV1ZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXSBBbiBvcHRpb25hbCBwYXRoIHByZXBlbmRlZCB0byB0aGUgYHNyY2AuIFRoZSBwYXRoIHdpbGwgb25seSBiZSBwcmVwZW5kZWQgaWYgdGhlIHNyYyBpc1xuXHQgKiByZWxhdGl2ZSwgYW5kIGRvZXMgbm90IHN0YXJ0IHdpdGggYSBwcm90b2NvbCBzdWNoIGFzIGBodHRwOi8vYCwgb3IgYSBwYXRoIGxpa2UgYC4uL2AuIElmIHRoZSBMb2FkUXVldWUgd2FzXG5cdCAqIHByb3ZpZGVkIGEge3sjY3Jvc3NMaW5rIFwiX2Jhc2VQYXRoXCJ9fXt7L2Nyb3NzTGlua319LCB0aGVuIGl0IHdpbGwgb3B0aW9uYWxseSBiZSBwcmVwZW5kZWQgYWZ0ZXIuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbYmFzZVBhdGhdIDxzdHJvbmc+RGVwcmVjYXRlZDwvc3Ryb25nPkFuIG9wdGlvbmFsIGJhc2VQYXRoIHBhc3NlZCBpbnRvIGEge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvciB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX0gY2FsbC4gVGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHRhZ2dlZFxuXHQgKiB2ZXJzaW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fYWRkSXRlbSA9IGZ1bmN0aW9uICh2YWx1ZSwgcGF0aCwgYmFzZVBhdGgpIHtcblx0XHR2YXIgaXRlbSA9IHRoaXMuX2NyZWF0ZUxvYWRJdGVtKHZhbHVlLCBwYXRoLCBiYXNlUGF0aCk7IC8vIGJhc2VQYXRoIGFuZCBtYW5pZmVzdCBwYXRoIGFyZSBhZGRlZCB0byB0aGUgc3JjLlxuXHRcdGlmIChpdGVtID09IG51bGwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9IC8vIFNvbWV0aW1lcyBwbHVnaW5zIG9yIHR5cGVzIHNob3VsZCBiZSBza2lwcGVkLlxuXHRcdHZhciBsb2FkZXIgPSB0aGlzLl9jcmVhdGVMb2FkZXIoaXRlbSk7XG5cdFx0aWYgKGxvYWRlciAhPSBudWxsKSB7XG5cdFx0XHRpZiAoXCJwbHVnaW5zXCIgaW4gbG9hZGVyKSB7XG5cdFx0XHRcdGxvYWRlci5wbHVnaW5zID0gdGhpcy5fcGx1Z2lucztcblx0XHRcdH1cblx0XHRcdGl0ZW0uX2xvYWRlciA9IGxvYWRlcjtcblx0XHRcdHRoaXMuX2xvYWRRdWV1ZS5wdXNoKGxvYWRlcik7XG5cdFx0XHR0aGlzLl9sb2FkUXVldWVCYWNrdXAucHVzaChsb2FkZXIpO1xuXG5cdFx0XHR0aGlzLl9udW1JdGVtcysrO1xuXHRcdFx0dGhpcy5fdXBkYXRlUHJvZ3Jlc3MoKTtcblxuXHRcdFx0Ly8gT25seSB3b3JyeSBhYm91dCBzY3JpcHQgb3JkZXIgd2hlbiB1c2luZyBYSFIgdG8gbG9hZCBzY3JpcHRzLiBUYWdzIGFyZSBvbmx5IGxvYWRpbmcgb25lIGF0IGEgdGltZS5cblx0XHRcdGlmICgodGhpcy5tYWludGFpblNjcmlwdE9yZGVyXG5cdFx0XHRcdFx0JiYgaXRlbS50eXBlID09IGNyZWF0ZWpzLkxvYWRRdWV1ZS5KQVZBU0NSSVBUXG5cdFx0XHRcdFx0XHQvLyYmIGxvYWRlciBpbnN0YW5jZW9mIGNyZWF0ZWpzLlhIUkxvYWRlciAvL05PVEU6IEhhdmUgdG8gdHJhY2sgYWxsIEpTIGZpbGVzIHRoaXMgd2F5XG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdHx8IGl0ZW0ubWFpbnRhaW5PcmRlciA9PT0gdHJ1ZSkge1xuXHRcdFx0XHR0aGlzLl9zY3JpcHRPcmRlci5wdXNoKGl0ZW0pO1xuXHRcdFx0XHR0aGlzLl9sb2FkZWRTY3JpcHRzLnB1c2gobnVsbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSByZWZpbmVkIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319LCB3aGljaCBjb250YWlucyBhbGwgdGhlIHJlcXVpcmVkIHByb3BlcnRpZXMuIFRoZSB0eXBlIG9mXG5cdCAqIGl0ZW0gaXMgZGV0ZXJtaW5lZCBieSBicm93c2VyIHN1cHBvcnQsIHJlcXVpcmVtZW50cyBiYXNlZCBvbiB0aGUgZmlsZSB0eXBlLCBhbmQgZGV2ZWxvcGVyIHNldHRpbmdzLiBGb3IgZXhhbXBsZSxcblx0ICogWEhSIGlzIG9ubHkgdXNlZCBmb3IgZmlsZSB0eXBlcyB0aGF0IHN1cHBvcnQgaXQgaW4gbmV3IGJyb3dzZXJzLlxuXHQgKlxuXHQgKiBCZWZvcmUgdGhlIGl0ZW0gaXMgcmV0dXJuZWQsIGFueSBwbHVnaW5zIHJlZ2lzdGVyZWQgdG8gaGFuZGxlIHRoZSB0eXBlIG9yIGV4dGVuc2lvbiB3aWxsIGJlIGZpcmVkLCB3aGljaCBtYXlcblx0ICogYWx0ZXIgdGhlIGxvYWQgaXRlbS5cblx0ICogQG1ldGhvZCBfY3JlYXRlTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtTdHJpbmcgfCBPYmplY3QgfCBIVE1MQXVkaW9FbGVtZW50IHwgSFRNTEltYWdlRWxlbWVudH0gdmFsdWUgVGhlIGl0ZW0gdGhhdCBuZWVkcyB0byBiZSBwcmVsb2FkZWQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF0gQSBwYXRoIHRvIHByZXBlbmQgdG8gdGhlIGl0ZW0ncyBzb3VyY2UuIFNvdXJjZXMgYmVnaW5uaW5nIHdpdGggaHR0cDovLyBvciBzaW1pbGFyIHdpbGxcblx0ICogbm90IHJlY2VpdmUgYSBwYXRoLiBTaW5jZSBQcmVsb2FkSlMgMC40LjEsIHRoZSBzcmMgd2lsbCBiZSBtb2RpZmllZCB0byBpbmNsdWRlIHRoZSBgcGF0aGAgYW5kIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9fYmFzZVBhdGg6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2hlbiBpdCBpcyBhZGRlZC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtiYXNlUGF0aF0gPHN0cm9uZz5EZXByZWN0YXRlZDwvc3Ryb25nPiBBIGJhc2UgcGF0aCB0byBwcmVwZW5kIHRvIHRoZSBpdGVtcyBzb3VyY2UgaW4gYWRkaXRpb24gdG9cblx0ICogdGhlIHBhdGggYXJndW1lbnQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGxvYWRlciBpbnN0YW5jZSB0aGF0IHdpbGwgYmUgdXNlZC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NyZWF0ZUxvYWRJdGVtID0gZnVuY3Rpb24gKHZhbHVlLCBwYXRoLCBiYXNlUGF0aCkge1xuXHRcdHZhciBpdGVtID0gY3JlYXRlanMuTG9hZEl0ZW0uY3JlYXRlKHZhbHVlKTtcblx0XHRpZiAoaXRlbSA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR2YXIgYnAgPSBcIlwiOyAvLyBTdG9yZSB0aGUgZ2VuZXJhdGVkIGJhc2VQYXRoXG5cdFx0dmFyIHVzZUJhc2VQYXRoID0gYmFzZVBhdGggfHwgdGhpcy5fYmFzZVBhdGg7XG5cblx0XHRpZiAoaXRlbS5zcmMgaW5zdGFuY2VvZiBPYmplY3QpIHtcblx0XHRcdGlmICghaXRlbS50eXBlKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSAvLyB0aGUgdGhlIHNyYyBpcyBhbiBvYmplY3QsIHR5cGUgaXMgcmVxdWlyZWQgdG8gcGFzcyBvZmYgdG8gcGx1Z2luXG5cdFx0XHRpZiAocGF0aCkge1xuXHRcdFx0XHRicCA9IHBhdGg7XG5cdFx0XHRcdHZhciBwYXRoTWF0Y2ggPSBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMucGFyc2VVUkkocGF0aCk7XG5cdFx0XHRcdC8vIEFsc28gYXBwZW5kIGJhc2VQYXRoXG5cdFx0XHRcdGlmICh1c2VCYXNlUGF0aCAhPSBudWxsICYmICFwYXRoTWF0Y2guYWJzb2x1dGUgJiYgIXBhdGhNYXRjaC5yZWxhdGl2ZSkge1xuXHRcdFx0XHRcdGJwID0gdXNlQmFzZVBhdGggKyBicDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh1c2VCYXNlUGF0aCAhPSBudWxsKSB7XG5cdFx0XHRcdGJwID0gdXNlQmFzZVBhdGg7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIERldGVybWluZSBFeHRlbnNpb24sIGV0Yy5cblx0XHRcdHZhciBtYXRjaCA9IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5wYXJzZVVSSShpdGVtLnNyYyk7XG5cdFx0XHRpZiAobWF0Y2guZXh0ZW5zaW9uKSB7XG5cdFx0XHRcdGl0ZW0uZXh0ID0gbWF0Y2guZXh0ZW5zaW9uO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGl0ZW0udHlwZSA9PSBudWxsKSB7XG5cdFx0XHRcdGl0ZW0udHlwZSA9IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5nZXRUeXBlQnlFeHRlbnNpb24oaXRlbS5leHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmplY3QgcGF0aCAmIGJhc2VQYXRoXG5cdFx0XHR2YXIgYXV0b0lkID0gaXRlbS5zcmM7XG5cdFx0XHRpZiAoIW1hdGNoLmFic29sdXRlICYmICFtYXRjaC5yZWxhdGl2ZSkge1xuXHRcdFx0XHRpZiAocGF0aCkge1xuXHRcdFx0XHRcdGJwID0gcGF0aDtcblx0XHRcdFx0XHR2YXIgcGF0aE1hdGNoID0gY3JlYXRlanMuUmVxdWVzdFV0aWxzLnBhcnNlVVJJKHBhdGgpO1xuXHRcdFx0XHRcdGF1dG9JZCA9IHBhdGggKyBhdXRvSWQ7XG5cdFx0XHRcdFx0Ly8gQWxzbyBhcHBlbmQgYmFzZVBhdGhcblx0XHRcdFx0XHRpZiAodXNlQmFzZVBhdGggIT0gbnVsbCAmJiAhcGF0aE1hdGNoLmFic29sdXRlICYmICFwYXRoTWF0Y2gucmVsYXRpdmUpIHtcblx0XHRcdFx0XHRcdGJwID0gdXNlQmFzZVBhdGggKyBicDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAodXNlQmFzZVBhdGggIT0gbnVsbCkge1xuXHRcdFx0XHRcdGJwID0gdXNlQmFzZVBhdGg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGl0ZW0uc3JjID0gYnAgKyBpdGVtLnNyYztcblx0XHR9XG5cdFx0aXRlbS5wYXRoID0gYnA7XG5cblx0XHQvLyBJZiB0aGVyZSdzIG5vIGlkLCBzZXQgb25lIG5vdy5cblx0XHRpZiAoaXRlbS5pZCA9PT0gdW5kZWZpbmVkIHx8IGl0ZW0uaWQgPT09IG51bGwgfHwgaXRlbS5pZCA9PT0gXCJcIikge1xuXHRcdFx0aXRlbS5pZCA9IGF1dG9JZDtcblx0XHR9XG5cblx0XHQvLyBHaXZlIHBsdWdpbnMgYSBjaGFuY2UgdG8gbW9kaWZ5IHRoZSBsb2FkSXRlbTpcblx0XHR2YXIgY3VzdG9tSGFuZGxlciA9IHRoaXMuX3R5cGVDYWxsYmFja3NbaXRlbS50eXBlXSB8fCB0aGlzLl9leHRlbnNpb25DYWxsYmFja3NbaXRlbS5leHRdO1xuXHRcdGlmIChjdXN0b21IYW5kbGVyKSB7XG5cdFx0XHQvLyBQbHVnaW5zIGFyZSBub3cgcGFzc2VkIGJvdGggdGhlIGZ1bGwgc291cmNlLCBhcyB3ZWxsIGFzIGEgY29tYmluZWQgcGF0aCtiYXNlUGF0aCAoYXBwcm9wcmlhdGVseSlcblx0XHRcdHZhciByZXN1bHQgPSBjdXN0b21IYW5kbGVyLmNhbGxiYWNrLmNhbGwoY3VzdG9tSGFuZGxlci5zY29wZSwgaXRlbSwgdGhpcyk7XG5cblx0XHRcdC8vIFRoZSBwbHVnaW4gd2lsbCBoYW5kbGUgdGhlIGxvYWQsIG9yIGhhcyBjYW5jZWxlZCBpdC4gSWdub3JlIGl0LlxuXHRcdFx0aWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdFx0Ly8gTG9hZCBhcyBub3JtYWw6XG5cdFx0XHR9IGVsc2UgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuXHRcdFx0XHQvLyBEbyBOb3RoaW5nXG5cblx0XHRcdFx0Ly8gUmVzdWx0IGlzIGEgbG9hZGVyIGNsYXNzOlxuXHRcdFx0fSBlbHNlIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuXHRcdFx0XHRpdGVtLl9sb2FkZXIgPSByZXN1bHQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSB0aGUgZXh0ZW5zaW9uIGluIGNhc2UgdGhlIHR5cGUgY2hhbmdlZDpcblx0XHRcdG1hdGNoID0gY3JlYXRlanMuUmVxdWVzdFV0aWxzLnBhcnNlVVJJKGl0ZW0uc3JjKTtcblx0XHRcdGlmIChtYXRjaC5leHRlbnNpb24gIT0gbnVsbCkge1xuXHRcdFx0XHRpdGVtLmV4dCA9IG1hdGNoLmV4dGVuc2lvbjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdG9yZSB0aGUgaXRlbSBmb3IgbG9va3VwLiBUaGlzIGFsc28gaGVscHMgY2xlYW4tdXAgbGF0ZXIuXG5cdFx0dGhpcy5fbG9hZEl0ZW1zQnlJZFtpdGVtLmlkXSA9IGl0ZW07XG5cdFx0dGhpcy5fbG9hZEl0ZW1zQnlTcmNbaXRlbS5zcmNdID0gaXRlbTtcblxuXHRcdGlmIChpdGVtLmNyb3NzT3JpZ2luID09IG51bGwpIHtcblx0XHRcdGl0ZW0uY3Jvc3NPcmlnaW4gPSB0aGlzLl9jcm9zc09yaWdpbjtcblx0XHR9XG5cblx0XHRyZXR1cm4gaXRlbTtcblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgbG9hZGVyIGZvciBhIGxvYWQgaXRlbS5cblx0ICogQG1ldGhvZCBfY3JlYXRlTG9hZGVyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIEEgZm9ybWF0dGVkIGxvYWQgaXRlbSB0aGF0IGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIGEgbG9hZGVyLlxuXHQgKiBAcmV0dXJuIHtBYnN0cmFjdExvYWRlcn0gQSBsb2FkZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBsb2FkIGNvbnRlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jcmVhdGVMb2FkZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdGlmIChpdGVtLl9sb2FkZXIgIT0gbnVsbCkgeyAvLyBBIHBsdWdpbiBhbHJlYWR5IHNwZWNpZmllZCBhIGxvYWRlclxuXHRcdFx0cmV0dXJuIGl0ZW0uX2xvYWRlcjtcblx0XHR9XG5cblx0XHQvLyBJbml0aWFsbHksIHRyeSBhbmQgdXNlIHRoZSBwcm92aWRlZC9zdXBwb3J0ZWQgWEhSIG1vZGU6XG5cdFx0dmFyIHByZWZlclhIUiA9IHRoaXMucHJlZmVyWEhSO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9hdmFpbGFibGVMb2FkZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgbG9hZGVyID0gdGhpcy5fYXZhaWxhYmxlTG9hZGVyc1tpXTtcblx0XHRcdGlmIChsb2FkZXIgJiYgbG9hZGVyLmNhbkxvYWRJdGVtKGl0ZW0pKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgbG9hZGVyKGl0ZW0sIHByZWZlclhIUik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gVE9ETzogTG9nIGVycm9yIChyZXF1aXJlcyBjcmVhdGVqcy5sb2cpXG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIExvYWQgdGhlIG5leHQgaXRlbSBpbiB0aGUgcXVldWUuIElmIHRoZSBxdWV1ZSBpcyBlbXB0eSAoYWxsIGl0ZW1zIGhhdmUgYmVlbiBsb2FkZWQpLCB0aGVuIHRoZSBjb21wbGV0ZSBldmVudFxuXHQgKiBpcyBwcm9jZXNzZWQuIFRoZSBxdWV1ZSB3aWxsIFwiZmlsbCB1cFwiIGFueSBlbXB0eSBzbG90cywgdXAgdG8gdGhlIG1heCBjb25uZWN0aW9uIHNwZWNpZmllZCB1c2luZ1xuXHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUuc2V0TWF4Q29ubmVjdGlvbnNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLiBUaGUgb25seSBleGNlcHRpb24gaXMgc2NyaXB0cyB0aGF0IGFyZSBsb2FkZWRcblx0ICogdXNpbmcgdGFncywgd2hpY2ggaGF2ZSB0byBiZSBsb2FkZWQgb25lIGF0IGEgdGltZSB0byBtYWludGFpbiBsb2FkIG9yZGVyLlxuXHQgKiBAbWV0aG9kIF9sb2FkTmV4dFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fbG9hZE5leHQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3BhdXNlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9ubHkgZGlzcGF0Y2ggbG9hZHN0YXJ0IGV2ZW50IHdoZW4gdGhlIGZpcnN0IGZpbGUgaXMgbG9hZGVkLlxuXHRcdGlmICghdGhpcy5fbG9hZFN0YXJ0V2FzRGlzcGF0Y2hlZCkge1xuXHRcdFx0dGhpcy5fc2VuZExvYWRTdGFydCgpO1xuXHRcdFx0dGhpcy5fbG9hZFN0YXJ0V2FzRGlzcGF0Y2hlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHF1ZXVlIGhhcyBjb21wbGV0ZWQuXG5cdFx0aWYgKHRoaXMuX251bUl0ZW1zID09IHRoaXMuX251bUl0ZW1zTG9hZGVkKSB7XG5cdFx0XHR0aGlzLmxvYWRlZCA9IHRydWU7XG5cdFx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblxuXHRcdFx0Ly8gTG9hZCB0aGUgbmV4dCBxdWV1ZSwgaWYgaXQgaGFzIGJlZW4gZGVmaW5lZC5cblx0XHRcdGlmICh0aGlzLm5leHQgJiYgdGhpcy5uZXh0LmxvYWQpIHtcblx0XHRcdFx0dGhpcy5uZXh0LmxvYWQoKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5sb2FkZWQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBNdXN0IGl0ZXJhdGUgZm9yd2FyZHMgdG8gbG9hZCBpbiB0aGUgcmlnaHQgb3JkZXIuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9sb2FkUXVldWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLl9jdXJyZW50TG9hZHMubGVuZ3RoID49IHRoaXMuX21heENvbm5lY3Rpb25zKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGxvYWRlciA9IHRoaXMuX2xvYWRRdWV1ZVtpXTtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBiZSBvbmx5IGxvYWRpbmcgb25lIHRhZy1zY3JpcHQgYXQgYSB0aW1lOlxuXHRcdFx0Ly8gTm90ZTogbWFpbnRhaW5PcmRlciBpdGVtcyBkb24ndCBkbyBhbnl0aGluZyBoZXJlIGJlY2F1c2Ugd2UgY2FuIGhvbGQgb250byB0aGVpciBsb2FkZWQgdmFsdWVcblx0XHRcdGlmICghdGhpcy5fY2FuU3RhcnRMb2FkKGxvYWRlcikpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9sb2FkUXVldWUuc3BsaWNlKGksIDEpO1xuXHRcdFx0aS0tO1xuXHRcdFx0dGhpcy5fbG9hZEl0ZW0obG9hZGVyKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2luIGxvYWRpbmcgYW4gaXRlbS4gRXZlbnQgbGlzdGVuZXJzIGFyZSBub3QgYWRkZWQgdG8gdGhlIGxvYWRlcnMgdW50aWwgdGhlIGxvYWQgc3RhcnRzLlxuXHQgKiBAbWV0aG9kIF9sb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXIgVGhlIGxvYWRlciBpbnN0YW5jZSB0byBzdGFydC4gQ3VycmVudGx5LCB0aGlzIHdpbGwgYmUgYW4gWEhSTG9hZGVyIG9yIFRhZ0xvYWRlci5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2xvYWRJdGVtID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdGxvYWRlci5vbihcImZpbGVsb2FkXCIsIHRoaXMuX2hhbmRsZUZpbGVMb2FkLCB0aGlzKTtcblx0XHRsb2FkZXIub24oXCJwcm9ncmVzc1wiLCB0aGlzLl9oYW5kbGVQcm9ncmVzcywgdGhpcyk7XG5cdFx0bG9hZGVyLm9uKFwiY29tcGxldGVcIiwgdGhpcy5faGFuZGxlRmlsZUNvbXBsZXRlLCB0aGlzKTtcblx0XHRsb2FkZXIub24oXCJlcnJvclwiLCB0aGlzLl9oYW5kbGVFcnJvciwgdGhpcyk7XG5cdFx0bG9hZGVyLm9uKFwiZmlsZWVycm9yXCIsIHRoaXMuX2hhbmRsZUZpbGVFcnJvciwgdGhpcyk7XG5cdFx0dGhpcy5fY3VycmVudExvYWRzLnB1c2gobG9hZGVyKTtcblx0XHR0aGlzLl9zZW5kRmlsZVN0YXJ0KGxvYWRlci5nZXRJdGVtKCkpO1xuXHRcdGxvYWRlci5sb2FkKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBjYWxsYmFjayB0aGF0IGlzIGZpcmVkIHdoZW4gYSBsb2FkZXIgbG9hZHMgYSBmaWxlLiBUaGlzIGVuYWJsZXMgbG9hZGVycyBsaWtlIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHRvIG1haW50YWluIGludGVybmFsIHF1ZXVlcywgYnV0IGZvciB0aGlzIHF1ZXVlIHRvIGRpc3BhdGNoIHRoZSB7eyNjcm9zc0xpbmsgXCJmaWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudHMuXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBmcm9tIHRoZSBsb2FkZXIuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5faGFuZGxlRmlsZUxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC50YXJnZXQgPSBudWxsO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBjYWxsYmFjayB0aGF0IGlzIGZpcmVkIHdoZW4gYSBsb2FkZXIgZW5jb3VudGVycyBhbiBlcnJvciBmcm9tIGFuIGludGVybmFsIGZpbGUgbG9hZCBvcGVyYXRpb24uIFRoaXMgZW5hYmxlc1xuXHQgKiBsb2FkZXJzIGxpa2UgTVxuXHQgKiBAcGFyYW0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZUZpbGVFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiRklMRV9MT0FEX0VSUk9SXCIsIG51bGwsIGV2ZW50Lml0ZW0pO1xuXHRcdHRoaXMuX3NlbmRFcnJvcihuZXdFdmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBjYWxsYmFjayB0aGF0IGlzIGZpcmVkIHdoZW4gYSBsb2FkZXIgZW5jb3VudGVycyBhbiBlcnJvci4gVGhlIHF1ZXVlIHdpbGwgY29udGludWUgbG9hZGluZyB1bmxlc3Mge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3N0b3BPbkVycm9yOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGlzIHNldCB0byBgdHJ1ZWAuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUVycm9yXG5cdCAqIEBwYXJhbSB7RXJyb3JFdmVudH0gZXZlbnQgVGhlIGVycm9yIGV2ZW50LCBjb250YWluaW5nIHJlbGV2YW50IGVycm9yIGluZm9ybWF0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgbG9hZGVyID0gZXZlbnQudGFyZ2V0O1xuXHRcdHRoaXMuX251bUl0ZW1zTG9hZGVkKys7XG5cblx0XHR0aGlzLl9maW5pc2hPcmRlcmVkSXRlbShsb2FkZXIsIHRydWUpO1xuXHRcdHRoaXMuX3VwZGF0ZVByb2dyZXNzKCk7XG5cblx0XHR2YXIgbmV3RXZlbnQgPSBuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIkZJTEVfTE9BRF9FUlJPUlwiLCBudWxsLCBsb2FkZXIuZ2V0SXRlbSgpKTtcblx0XHQvLyBUT0RPOiBQcm9wYWdhdGUgYWN0dWFsIGVycm9yIG1lc3NhZ2UuXG5cblx0XHR0aGlzLl9zZW5kRXJyb3IobmV3RXZlbnQpO1xuXG5cdFx0aWYgKCF0aGlzLnN0b3BPbkVycm9yKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVMb2FkSXRlbShsb2FkZXIpO1xuXHRcdFx0dGhpcy5fY2xlYW5Mb2FkSXRlbShsb2FkZXIpO1xuXHRcdFx0dGhpcy5fbG9hZE5leHQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRQYXVzZWQodHJ1ZSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbiBpdGVtIGhhcyBmaW5pc2hlZCBsb2FkaW5nLiBXZSBjYW4gYXNzdW1lIHRoYXQgaXQgaXMgdG90YWxseSBsb2FkZWQsIGhhcyBiZWVuIHBhcnNlZCBmb3IgaW1tZWRpYXRlIHVzZSwgYW5kXG5cdCAqIGlzIGF2YWlsYWJsZSBhcyB0aGUgXCJyZXN1bHRcIiBwcm9wZXJ0eSBvbiB0aGUgbG9hZCBpdGVtLiBUaGUgcmF3IHRleHQgcmVzdWx0IGZvciBhIHBhcnNlZCBpdGVtIChzdWNoIGFzIEpTT04sIFhNTCxcblx0ICogQ1NTLCBKYXZhU2NyaXB0LCBldGMpIGlzIGF2YWlsYWJsZSBhcyB0aGUgXCJyYXdSZXN1bHRcIiBwcm9wZXJ0eSwgYW5kIGNhbiBhbHNvIGJlIGxvb2tlZCB1cCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZ2V0UmVzdWx0XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVGaWxlQ29tcGxldGVcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IG9iamVjdCBmcm9tIHRoZSBsb2FkZXIuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVGaWxlQ29tcGxldGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgbG9hZGVyID0gZXZlbnQudGFyZ2V0O1xuXHRcdHZhciBpdGVtID0gbG9hZGVyLmdldEl0ZW0oKTtcblxuXHRcdHZhciByZXN1bHQgPSBsb2FkZXIuZ2V0UmVzdWx0KCk7XG5cdFx0dGhpcy5fbG9hZGVkUmVzdWx0c1tpdGVtLmlkXSA9IHJlc3VsdDtcblx0XHR2YXIgcmF3UmVzdWx0ID0gbG9hZGVyLmdldFJlc3VsdCh0cnVlKTtcblx0XHRpZiAocmF3UmVzdWx0ICE9IG51bGwgJiYgcmF3UmVzdWx0ICE9PSByZXN1bHQpIHtcblx0XHRcdHRoaXMuX2xvYWRlZFJhd1Jlc3VsdHNbaXRlbS5pZF0gPSByYXdSZXN1bHQ7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2F2ZUxvYWRlZEl0ZW1zKGxvYWRlcik7XG5cblx0XHQvLyBSZW1vdmUgdGhlIGxvYWQgaXRlbVxuXHRcdHRoaXMuX3JlbW92ZUxvYWRJdGVtKGxvYWRlcik7XG5cblx0XHRpZiAoIXRoaXMuX2ZpbmlzaE9yZGVyZWRJdGVtKGxvYWRlcikpIHtcblx0XHRcdC8vIFRoZSBpdGVtIHdhcyBOT1QgbWFuYWdlZCwgc28gcHJvY2VzcyBpdCBub3dcblx0XHRcdHRoaXMuX3Byb2Nlc3NGaW5pc2hlZExvYWQoaXRlbSwgbG9hZGVyKTtcblx0XHR9XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgbG9hZCBpdGVtXG5cdFx0dGhpcy5fY2xlYW5Mb2FkSXRlbShsb2FkZXIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTb21lIGxvYWRlcnMgbWlnaHQgbG9hZCBhZGRpdGlvbmFsIGNvbnRlbnQsIG90aGVyIHRoYW4gdGhlIGl0ZW0gdGhleSB3ZXJlIHBhc3NlZCAoc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fSkuXG5cdCAqIEFueSBpdGVtcyBleHBvc2VkIGJ5IHRoZSBsb2FkZXIgdXNpbmcge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvZ2V0TG9hZEl0ZW1zXCJ9fXt7L2Nyb3NzTGlua319IGFyZSBhZGRlZCB0byB0aGVcblx0ICogTG9hZFF1ZXVlJ3MgbG9vay11cHMsIGluY2x1ZGluZyB7eyNjcm9zc0xpbmsgXCJnZXRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJnZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kcy5cblx0ICogQG1ldGhvZCBfc2F2ZUxvYWRlZEl0ZW1zXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5fc2F2ZUxvYWRlZEl0ZW1zID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdC8vIFRPRE86IE5vdCBzdXJlIGhvdyB0byBoYW5kbGUgdGhpcy4gV291bGQgYmUgbmljZSB0byBleHBvc2UgdGhlIGl0ZW1zLlxuXHRcdC8vIExvYWRlcnMgbWF5IGxvYWQgc3ViLWl0ZW1zLiBUaGlzIGFkZHMgdGhlbSB0byB0aGlzIHF1ZXVlXG5cdFx0dmFyIGxpc3QgPSBsb2FkZXIuZ2V0TG9hZGVkSXRlbXMoKTtcblx0XHRpZiAobGlzdCA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBsaXN0W2ldLml0ZW07XG5cblx0XHRcdC8vIFN0b3JlIGl0ZW0gbG9va3Vwc1xuXHRcdFx0dGhpcy5fbG9hZEl0ZW1zQnlTcmNbaXRlbS5zcmNdID0gaXRlbTtcblx0XHRcdHRoaXMuX2xvYWRJdGVtc0J5SWRbaXRlbS5pZF0gPSBpdGVtO1xuXG5cdFx0XHQvLyBTdG9yZSBsb2FkZWQgY29udGVudFxuXHRcdFx0dGhpcy5fbG9hZGVkUmVzdWx0c1tpdGVtLmlkXSA9IGxpc3RbaV0ucmVzdWx0O1xuXHRcdFx0dGhpcy5fbG9hZGVkUmF3UmVzdWx0c1tpdGVtLmlkXSA9IGxpc3RbaV0ucmF3UmVzdWx0O1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRmxhZyBhbiBpdGVtIGFzIGZpbmlzaGVkLiBJZiB0aGUgaXRlbSdzIG9yZGVyIGlzIGJlaW5nIG1hbmFnZWQsIHRoZW4gZW5zdXJlIHRoYXQgaXQgaXMgYWxsb3dlZCB0byBmaW5pc2gsIGFuZCBpZlxuXHQgKiBzbywgdHJpZ2dlciBwcmlvciBpdGVtcyB0byB0cmlnZ2VyIGFzIHdlbGwuXG5cdCAqIEBtZXRob2QgX2ZpbmlzaE9yZGVyZWRJdGVtXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGxvYWRGYWlsZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIGl0ZW0ncyBvcmRlciBpcyBiZWluZyBtYW5hZ2VkLiBUaGlzIGFsbG93cyB0aGUgY2FsbGVyIHRvIHRha2UgYW4gYWx0ZXJuYXRlXG5cdCAqIGJlaGF2aW91ciBpZiBpdCBpcy5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2ZpbmlzaE9yZGVyZWRJdGVtID0gZnVuY3Rpb24gKGxvYWRlciwgbG9hZEZhaWxlZCkge1xuXHRcdHZhciBpdGVtID0gbG9hZGVyLmdldEl0ZW0oKTtcblxuXHRcdGlmICgodGhpcy5tYWludGFpblNjcmlwdE9yZGVyICYmIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5Mb2FkUXVldWUuSkFWQVNDUklQVClcblx0XHRcdFx0fHwgaXRlbS5tYWludGFpbk9yZGVyKSB7XG5cblx0XHRcdC8vVE9ETzogRXZhbHVhdGUgcmVtb3ZhbCBvZiB0aGUgX2N1cnJlbnRseUxvYWRpbmdTY3JpcHRcblx0XHRcdGlmIChsb2FkZXIgaW5zdGFuY2VvZiBjcmVhdGVqcy5KYXZhU2NyaXB0TG9hZGVyKSB7XG5cdFx0XHRcdHRoaXMuX2N1cnJlbnRseUxvYWRpbmdTY3JpcHQgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGluZGV4ID0gY3JlYXRlanMuaW5kZXhPZih0aGlzLl9zY3JpcHRPcmRlciwgaXRlbSk7XG5cdFx0XHRpZiAoaW5kZXggPT0gLTEpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSAvLyBUaGlzIGxvYWRlciBubyBsb25nZXIgZXhpc3RzXG5cdFx0XHR0aGlzLl9sb2FkZWRTY3JpcHRzW2luZGV4XSA9IChsb2FkRmFpbGVkID09PSB0cnVlKSA/IHRydWUgOiBpdGVtO1xuXG5cdFx0XHR0aGlzLl9jaGVja1NjcmlwdExvYWRPcmRlcigpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbnN1cmUgdGhlIHNjcmlwdHMgbG9hZCBhbmQgZGlzcGF0Y2ggaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIFdoZW4gdXNpbmcgWEhSLCBzY3JpcHRzIGFyZSBzdG9yZWQgaW4gYW4gYXJyYXkgaW4gdGhlXG5cdCAqIG9yZGVyIHRoZXkgd2VyZSBhZGRlZCwgYnV0IHdpdGggYSBcIm51bGxcIiB2YWx1ZS4gV2hlbiB0aGV5IGFyZSBjb21wbGV0ZWQsIHRoZSB2YWx1ZSBpcyBzZXQgdG8gdGhlIGxvYWQgaXRlbSxcblx0ICogYW5kIHRoZW4gd2hlbiB0aGV5IGFyZSBwcm9jZXNzZWQgYW5kIGRpc3BhdGNoZWQsIHRoZSB2YWx1ZSBpcyBzZXQgdG8gYHRydWVgLiBUaGlzIG1ldGhvZCBzaW1wbHlcblx0ICogaXRlcmF0ZXMgdGhlIGFycmF5LCBhbmQgZW5zdXJlcyB0aGF0IGFueSBsb2FkZWQgaXRlbXMgdGhhdCBhcmUgbm90IHByZWNlZGVkIGJ5IGEgYG51bGxgIHZhbHVlIGFyZVxuXHQgKiBkaXNwYXRjaGVkLlxuXHQgKiBAbWV0aG9kIF9jaGVja1NjcmlwdExvYWRPcmRlclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY2hlY2tTY3JpcHRMb2FkT3JkZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGwgPSB0aGlzLl9sb2FkZWRTY3JpcHRzLmxlbmd0aDtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHRoaXMuX2xvYWRlZFNjcmlwdHNbaV07XG5cdFx0XHRpZiAoaXRlbSA9PT0gbnVsbCkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH0gLy8gVGhpcyBpcyBzdGlsbCBsb2FkaW5nLiBEbyBub3QgcHJvY2VzcyBmdXJ0aGVyLlxuXHRcdFx0aWYgKGl0ZW0gPT09IHRydWUpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9IC8vIFRoaXMgaGFzIGNvbXBsZXRlZCwgYW5kIGJlZW4gcHJvY2Vzc2VkLiBNb3ZlIG9uLlxuXG5cdFx0XHR2YXIgbG9hZEl0ZW0gPSB0aGlzLl9sb2FkZWRSZXN1bHRzW2l0ZW0uaWRdO1xuXHRcdFx0aWYgKGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5Mb2FkUXVldWUuSkFWQVNDUklQVCkge1xuXHRcdFx0XHQvLyBBcHBlbmQgc2NyaXB0IHRhZ3MgdG8gdGhlIGhlYWQgYXV0b21hdGljYWxseS5cblx0XHRcdFx0Y3JlYXRlanMuRG9tVXRpbHMuYXBwZW5kVG9IZWFkKGxvYWRJdGVtKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGxvYWRlciA9IGl0ZW0uX2xvYWRlcjtcblx0XHRcdHRoaXMuX3Byb2Nlc3NGaW5pc2hlZExvYWQoaXRlbSwgbG9hZGVyKTtcblx0XHRcdHRoaXMuX2xvYWRlZFNjcmlwdHNbaV0gPSB0cnVlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQSBmaWxlIGhhcyBjb21wbGV0ZWQgbG9hZGluZywgYW5kIHRoZSBMb2FkUXVldWUgY2FuIG1vdmUgb24uIFRoaXMgdHJpZ2dlcnMgdGhlIGNvbXBsZXRlIGV2ZW50LCBhbmQga2ljay1zdGFydHNcblx0ICogdGhlIG5leHQgaXRlbS5cblx0ICogQG1ldGhvZCBfcHJvY2Vzc0ZpbmlzaGVkTG9hZFxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbVxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fcHJvY2Vzc0ZpbmlzaGVkTG9hZCA9IGZ1bmN0aW9uIChpdGVtLCBsb2FkZXIpIHtcblx0XHR0aGlzLl9udW1JdGVtc0xvYWRlZCsrO1xuXG5cdFx0Ly8gU2luY2UgTG9hZFF1ZXVlIG5lZWRzIG1haW50YWluIG9yZGVyLCB3ZSBjYW4ndCBhcHBlbmQgc2NyaXB0cyBpbiB0aGUgbG9hZGVyLlxuXHRcdC8vIFNvIHdlIGRvIGl0IGhlcmUgaW5zdGVhZC4gT3IgaW4gX2NoZWNrU2NyaXB0TG9hZE9yZGVyKCk7XG5cdFx0aWYgKCF0aGlzLm1haW50YWluU2NyaXB0T3JkZXIgJiYgaXRlbS50eXBlID09IGNyZWF0ZWpzLkxvYWRRdWV1ZS5KQVZBU0NSSVBUKSB7XG5cdFx0XHRjcmVhdGVqcy5Eb21VdGlscy5hcHBlbmRUb0hlYWQoaXRlbS5yZXN1bHQpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VwZGF0ZVByb2dyZXNzKCk7XG5cdFx0dGhpcy5fc2VuZEZpbGVDb21wbGV0ZShpdGVtLCBsb2FkZXIpO1xuXHRcdHRoaXMuX2xvYWROZXh0KCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuc3VyZSBpdGVtcyB3aXRoIGBtYWludGFpbk9yZGVyPXRydWVgIHRoYXQgYXJlIGJlZm9yZSB0aGUgc3BlY2lmaWVkIGl0ZW0gaGF2ZSBsb2FkZWQuIFRoaXMgb25seSBhcHBsaWVzIHRvXG5cdCAqIEphdmFTY3JpcHQgaXRlbXMgdGhhdCBhcmUgYmVpbmcgbG9hZGVkIHdpdGggYSBUYWdMb2FkZXIsIHNpbmNlIHRoZXkgaGF2ZSB0byBiZSBsb2FkZWQgYW5kIGNvbXBsZXRlZCA8c3Ryb25nPmJlZm9yZTwvc3Ryb25nPlxuXHQgKiB0aGUgc2NyaXB0IGNhbiBldmVuIGJlIHN0YXJ0ZWQsIHNpbmNlIGl0IGV4aXN0IGluIHRoZSBET00gd2hpbGUgbG9hZGluZy5cblx0ICogQG1ldGhvZCBfY2FuU3RhcnRMb2FkXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlciBUaGUgbG9hZGVyIGZvciB0aGUgaXRlbVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBpdGVtIGNhbiBzdGFydCBhIGxvYWQgb3Igbm90LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY2FuU3RhcnRMb2FkID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdGlmICghdGhpcy5tYWludGFpblNjcmlwdE9yZGVyIHx8IGxvYWRlci5wcmVmZXJYSFIpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHR2YXIgaXRlbSA9IGxvYWRlci5nZXRJdGVtKCk7XG5cdFx0aWYgKGl0ZW0udHlwZSAhPSBjcmVhdGVqcy5Mb2FkUXVldWUuSkFWQVNDUklQVCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9jdXJyZW50bHlMb2FkaW5nU2NyaXB0KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIGluZGV4ID0gdGhpcy5fc2NyaXB0T3JkZXIuaW5kZXhPZihpdGVtKTtcblx0XHR2YXIgaSA9IDA7XG5cdFx0d2hpbGUgKGkgPCBpbmRleCkge1xuXHRcdFx0dmFyIGNoZWNrSXRlbSA9IHRoaXMuX2xvYWRlZFNjcmlwdHNbaV07XG5cdFx0XHRpZiAoY2hlY2tJdGVtID09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aSsrO1xuXHRcdH1cblx0XHR0aGlzLl9jdXJyZW50bHlMb2FkaW5nU2NyaXB0ID0gdHJ1ZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQSBsb2FkIGl0ZW0gaXMgY29tcGxldGVkIG9yIHdhcyBjYW5jZWxlZCwgYW5kIG5lZWRzIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgTG9hZFF1ZXVlLlxuXHQgKiBAbWV0aG9kIF9yZW1vdmVMb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXIgQSBsb2FkZXIgaW5zdGFuY2UgdG8gcmVtb3ZlLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fcmVtb3ZlTG9hZEl0ZW0gPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0dmFyIGwgPSB0aGlzLl9jdXJyZW50TG9hZHMubGVuZ3RoO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAodGhpcy5fY3VycmVudExvYWRzW2ldID09IGxvYWRlcikge1xuXHRcdFx0XHR0aGlzLl9jdXJyZW50TG9hZHMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSB1bm5lZWRlZCByZWZlcmVuY2VzIGZyb20gYSBsb2FkZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSBsb2FkZXJcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NsZWFuTG9hZEl0ZW0gPSBmdW5jdGlvbihsb2FkZXIpIHtcblx0XHR2YXIgaXRlbSA9IGxvYWRlci5nZXRJdGVtKCk7XG5cdFx0aWYgKGl0ZW0pIHtcblx0XHRcdGRlbGV0ZSBpdGVtLl9sb2FkZXI7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEFuIGl0ZW0gaGFzIGRpc3BhdGNoZWQgcHJvZ3Jlc3MuIFByb3BhZ2F0ZSB0aGF0IHByb2dyZXNzLCBhbmQgdXBkYXRlIHRoZSBMb2FkUXVldWUncyBvdmVyYWxsIHByb2dyZXNzLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVQcm9ncmVzc1xuXHQgKiBAcGFyYW0ge1Byb2dyZXNzRXZlbnR9IGV2ZW50IFRoZSBwcm9ncmVzcyBldmVudCBmcm9tIHRoZSBpdGVtLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgbG9hZGVyID0gZXZlbnQudGFyZ2V0O1xuXHRcdHRoaXMuX3NlbmRGaWxlUHJvZ3Jlc3MobG9hZGVyLmdldEl0ZW0oKSwgbG9hZGVyLnByb2dyZXNzKTtcblx0XHR0aGlzLl91cGRhdGVQcm9ncmVzcygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBPdmVyYWxsIHByb2dyZXNzIGhhcyBjaGFuZ2VkLCBzbyBkZXRlcm1pbmUgdGhlIG5ldyBwcm9ncmVzcyBhbW91bnQgYW5kIGRpc3BhdGNoIGl0LiBUaGlzIGNoYW5nZXMgYW55IHRpbWUgYW5cblx0ICogaXRlbSBkaXNwYXRjaGVzIHByb2dyZXNzIG9yIGNvbXBsZXRlcy4gTm90ZSB0aGF0IHNpbmNlIHdlIGRvbid0IGFsd2F5cyBrbm93IHRoZSBhY3R1YWwgZmlsZXNpemUgb2YgaXRlbXMgYmVmb3JlXG5cdCAqIHRoZXkgYXJlIGxvYWRlZC4gSW4gdGhpcyBjYXNlLCB3ZSBkZWZpbmUgYSBcInNsb3RcIiBmb3IgZWFjaCBpdGVtICgxIGl0ZW0gaW4gMTAgd291bGQgZ2V0IDEwJSksIGFuZCB0aGVuIGFwcGVuZFxuXHQgKiBsb2FkZWQgcHJvZ3Jlc3Mgb24gdG9wIG9mIHRoZSBhbHJlYWR5LWxvYWRlZCBpdGVtcy5cblx0ICpcblx0ICogRm9yIGV4YW1wbGUsIGlmIDUvMTAgaXRlbXMgaGF2ZSBsb2FkZWQsIGFuZCBpdGVtIDYgaXMgMjAlIGxvYWRlZCwgdGhlIHRvdGFsIHByb2dyZXNzIHdvdWxkIGJlOlxuXHQgKiA8dWw+XG5cdCAqICAgICAgPGxpPjUvMTAgb2YgdGhlIGl0ZW1zIGluIHRoZSBxdWV1ZSAoNTAlKTwvbGk+XG5cdCAqICAgICAgPGxpPnBsdXMgMjAlIG9mIGl0ZW0gNidzIHNsb3QgKDIlKTwvbGk+XG5cdCAqICAgICAgPGxpPmVxdWFscyA1MiU8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBAbWV0aG9kIF91cGRhdGVQcm9ncmVzc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fdXBkYXRlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGxvYWRlZCA9IHRoaXMuX251bUl0ZW1zTG9hZGVkIC8gdGhpcy5fbnVtSXRlbXM7IC8vIEZ1bGx5IExvYWRlZCBQcm9ncmVzc1xuXHRcdHZhciByZW1haW5pbmcgPSB0aGlzLl9udW1JdGVtcyAtIHRoaXMuX251bUl0ZW1zTG9hZGVkO1xuXHRcdGlmIChyZW1haW5pbmcgPiAwKSB7XG5cdFx0XHR2YXIgY2h1bmsgPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jdXJyZW50TG9hZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGNodW5rICs9IHRoaXMuX2N1cnJlbnRMb2Fkc1tpXS5wcm9ncmVzcztcblx0XHRcdH1cblx0XHRcdGxvYWRlZCArPSAoY2h1bmsgLyByZW1haW5pbmcpICogKHJlbWFpbmluZyAvIHRoaXMuX251bUl0ZW1zKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fbGFzdFByb2dyZXNzICE9IGxvYWRlZCkge1xuXHRcdFx0dGhpcy5fc2VuZFByb2dyZXNzKGxvYWRlZCk7XG5cdFx0XHR0aGlzLl9sYXN0UHJvZ3Jlc3MgPSBsb2FkZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiBvdXQgaXRlbSByZXN1bHRzLCB0byBmcmVlIHRoZW0gZnJvbSBtZW1vcnkuIE1haW5seSwgdGhlIGxvYWRlZCBpdGVtIGFuZCByZXN1bHRzIGFyZSBjbGVhcmVkIGZyb20gaW50ZXJuYWxcblx0ICogaGFzaGVzLlxuXHQgKiBAbWV0aG9kIF9kaXNwb3NlSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgaXRlbSB0aGF0IHdhcyBwYXNzZWQgaW4gZm9yIHByZWxvYWRpbmcuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9kaXNwb3NlSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0ZGVsZXRlIHRoaXMuX2xvYWRlZFJlc3VsdHNbaXRlbS5pZF07XG5cdFx0ZGVsZXRlIHRoaXMuX2xvYWRlZFJhd1Jlc3VsdHNbaXRlbS5pZF07XG5cdFx0ZGVsZXRlIHRoaXMuX2xvYWRJdGVtc0J5SWRbaXRlbS5pZF07XG5cdFx0ZGVsZXRlIHRoaXMuX2xvYWRJdGVtc0J5U3JjW2l0ZW0uc3JjXTtcblx0fTtcblxuXHQvKipcblx0ICogRGlzcGF0Y2ggYSBcImZpbGVwcm9ncmVzc1wiIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LiBQbGVhc2Ugc2VlIHRoZSBMb2FkUXVldWUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVwcm9ncmVzczpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBmb3IgZGV0YWlscyBvbiB0aGUgZXZlbnQgcGF5bG9hZC5cblx0ICogQG1ldGhvZCBfc2VuZEZpbGVQcm9ncmVzc1xuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgaXRlbSB0aGF0IGlzIGJlaW5nIGxvYWRlZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHByb2dyZXNzIFRoZSBhbW91bnQgdGhlIGl0ZW0gaGFzIGJlZW4gbG9hZGVkIChiZXR3ZWVuIDAgYW5kIDEpLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZW5kRmlsZVByb2dyZXNzID0gZnVuY3Rpb24gKGl0ZW0sIHByb2dyZXNzKSB7XG5cdFx0aWYgKHRoaXMuX2lzQ2FuY2VsZWQoKSB8fCB0aGlzLl9wYXVzZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCF0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJmaWxlcHJvZ3Jlc3NcIikpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvL0xNOiBSZXdvcmsgUHJvZ3Jlc3NFdmVudCB0byBzdXBwb3J0IHRoaXM/XG5cdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiZmlsZXByb2dyZXNzXCIpO1xuXHRcdGV2ZW50LnByb2dyZXNzID0gcHJvZ3Jlc3M7XG5cdFx0ZXZlbnQubG9hZGVkID0gcHJvZ3Jlc3M7XG5cdFx0ZXZlbnQudG90YWwgPSAxO1xuXHRcdGV2ZW50Lml0ZW0gPSBpdGVtO1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRGlzcGF0Y2ggYSBmaWxlbG9hZCB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fS4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGZvclxuXHQgKiBkZXRhaWxzIG9uIHRoZSBldmVudCBwYXlsb2FkLlxuXHQgKiBAbWV0aG9kIF9zZW5kRmlsZUNvbXBsZXRlXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW1PYmplY3R9IGl0ZW0gVGhlIGl0ZW0gdGhhdCBpcyBiZWluZyBsb2FkZWQuXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZW5kRmlsZUNvbXBsZXRlID0gZnVuY3Rpb24gKGl0ZW0sIGxvYWRlcikge1xuXHRcdGlmICh0aGlzLl9pc0NhbmNlbGVkKCkgfHwgdGhpcy5fcGF1c2VkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiZmlsZWxvYWRcIik7XG5cdFx0ZXZlbnQubG9hZGVyID0gbG9hZGVyO1xuXHRcdGV2ZW50Lml0ZW0gPSBpdGVtO1xuXHRcdGV2ZW50LnJlc3VsdCA9IHRoaXMuX2xvYWRlZFJlc3VsdHNbaXRlbS5pZF07XG5cdFx0ZXZlbnQucmF3UmVzdWx0ID0gdGhpcy5fbG9hZGVkUmF3UmVzdWx0c1tpdGVtLmlkXTtcblxuXHRcdC8vIFRoaXMgY2FsbHMgYSBoYW5kbGVyIHNwZWNpZmllZCBvbiB0aGUgYWN0dWFsIGxvYWQgaXRlbS4gQ3VycmVudGx5LCB0aGUgU291bmRKUyBwbHVnaW4gdXNlcyB0aGlzLlxuXHRcdGlmIChpdGVtLmNvbXBsZXRlSGFuZGxlcikge1xuXHRcdFx0aXRlbS5jb21wbGV0ZUhhbmRsZXIoZXZlbnQpO1xuXHRcdH1cblxuXHRcdHRoaXMuaGFzRXZlbnRMaXN0ZW5lcihcImZpbGVsb2FkXCIpICYmIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoIGEgZmlsZXN0YXJ0IHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGltbWVkaWF0ZWx5IGJlZm9yZSBhIGZpbGUgc3RhcnRzIHRvIGxvYWQuIFBsZWFzZSBzZWVcblx0ICogdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlc3RhcnQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgZm9yIGRldGFpbHMgb24gdGhlIGV2ZW50IHBheWxvYWQuXG5cdCAqIEBtZXRob2QgX3NlbmRGaWxlU3RhcnRcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIGl0ZW0gdGhhdCBpcyBiZWluZyBsb2FkZWQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3NlbmRGaWxlU3RhcnQgPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVzdGFydFwiKTtcblx0XHRldmVudC5pdGVtID0gaXRlbTtcblx0XHR0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJmaWxlc3RhcnRcIikgJiYgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltQcmVsb2FkSlMgTG9hZFF1ZXVlXVwiO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkxvYWRRdWV1ZSA9IGNyZWF0ZWpzLnByb21vdGUoTG9hZFF1ZXVlLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFRleHRMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIFRleHQgZmlsZXMuXG5cdCAqIEBjbGFzcyBUZXh0TG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFRleHRMb2FkZXIobG9hZEl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCB0cnVlLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5URVhUKTtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChUZXh0TG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gVGV4dExvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgbG9hZHMgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9URVhUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBidXQgaXMgYWxzbyB0aGUgZGVmYXVsdCBsb2FkZXIgaWYgYSBmaWxlIHR5cGUgY2FuIG5vdCBiZSBkZXRlcm1pbmVkLlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlRFWFQ7XG5cdH07XG5cblx0Y3JlYXRlanMuVGV4dExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoVGV4dExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEJpbmFyeUxvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgYmluYXJ5IGZpbGVzLiBUaGlzIGlzIHVzZWZ1bCBmb3IgbG9hZGluZyB3ZWIgYXVkaW8sIG9yIGNvbnRlbnQgdGhhdCByZXF1aXJlcyBhbiBBcnJheUJ1ZmZlci5cblx0ICogQGNsYXNzIEJpbmFyeUxvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBCaW5hcnlMb2FkZXIobG9hZEl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCB0cnVlLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5CSU5BUlkpO1xuXHRcdHRoaXMub24oXCJpbml0aWFsaXplXCIsIHRoaXMuX3VwZGF0ZVhIUiwgdGhpcyk7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQmluYXJ5TG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gQmluYXJ5TG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvQklOQVJZOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuQklOQVJZO1xuXHR9O1xuXG5cdC8vIHByaXZhdGUgbWV0aG9kc1xuXHQvKipcblx0ICogQmVmb3JlIHRoZSBpdGVtIGxvYWRzLCBzZXQgdGhlIHJlc3BvbnNlIHR5cGUgdG8gXCJhcnJheWJ1ZmZlclwiXG5cdCAqIEBwcm9wZXJ0eSBfdXBkYXRlWEhSXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl91cGRhdGVYSFIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC5sb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XG5cdH07XG5cblx0Y3JlYXRlanMuQmluYXJ5TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShCaW5hcnlMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBDU1NMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIENTUyBmaWxlcy5cblx0ICogQGNsYXNzIENTU0xvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBDU1NMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuQ1NTKTtcblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5yZXN1bHRGb3JtYXR0ZXIgPSB0aGlzLl9mb3JtYXRSZXN1bHQ7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSA9IFwiaHJlZlwiO1xuXG5cdFx0aWYgKHByZWZlclhIUikge1xuXHRcdFx0dGhpcy5fdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl90YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblx0XHR9XG5cblx0XHR0aGlzLl90YWcucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cdFx0dGhpcy5fdGFnLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQ1NTTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gQ1NTTG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvQ1NTOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkNTUztcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIENTUyBmaWxlcy5cblx0ICogQG1ldGhvZCBfZm9ybWF0UmVzdWx0XG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcmV0dXJucyB7SFRNTExpbmtFbGVtZW50fEhUTUxTdHlsZUVsZW1lbnR9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9mb3JtYXRSZXN1bHQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0aWYgKHRoaXMuX3ByZWZlclhIUikge1xuXHRcdFx0dmFyIHRhZyA9IGxvYWRlci5nZXRUYWcoKTtcblxuXHRcdFx0aWYgKHRhZy5zdHlsZVNoZWV0KSB7IC8vIElFXG5cdFx0XHRcdHRhZy5zdHlsZVNoZWV0LmNzc1RleHQgPSBsb2FkZXIuZ2V0UmVzdWx0KHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobG9hZGVyLmdldFJlc3VsdCh0cnVlKSk7XG5cdFx0XHRcdHRhZy5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhZyA9IHRoaXMuX3RhZztcblx0XHR9XG5cblx0XHRjcmVhdGVqcy5Eb21VdGlscy5hcHBlbmRUb0hlYWQodGFnKTtcblxuXHRcdHJldHVybiB0YWc7XG5cdH07XG5cblx0Y3JlYXRlanMuQ1NTTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShDU1NMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBJbWFnZUxvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgaW1hZ2UgZmlsZXMuXG5cdCAqIEBjbGFzcyBJbWFnZUxvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBJbWFnZUxvYWRlciAobG9hZEl0ZW0sIHByZWZlclhIUikge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSU1BR0UpO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IHRoaXMuX2Zvcm1hdFJlc3VsdDtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5fdGFnU3JjQXR0cmlidXRlID0gXCJzcmNcIjtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBwcmVsb2FkIGl0ZW0gaXMgYWxyZWFkeSBhIHRhZy5cblx0XHRpZiAoY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzSW1hZ2VUYWcobG9hZEl0ZW0pKSB7XG5cdFx0XHR0aGlzLl90YWcgPSBsb2FkSXRlbTtcblx0XHR9IGVsc2UgaWYgKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0ltYWdlVGFnKGxvYWRJdGVtLnNyYykpIHtcblx0XHRcdHRoaXMuX3RhZyA9IGxvYWRJdGVtLnNyYztcblx0XHR9IGVsc2UgaWYgKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0ltYWdlVGFnKGxvYWRJdGVtLnRhZykpIHtcblx0XHRcdHRoaXMuX3RhZyA9IGxvYWRJdGVtLnRhZztcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fdGFnICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3ByZWZlclhIUiA9IGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl90YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuXHRcdH1cblxuXHRcdHRoaXMub24oXCJpbml0aWFsaXplXCIsIHRoaXMuX3VwZGF0ZVhIUiwgdGhpcyk7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoSW1hZ2VMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBJbWFnZUxvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0lNQUdFOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLklNQUdFO1xuXHR9O1xuXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdGFnLnNyYyAhPSBcIlwiICYmIHRoaXMuX3RhZy5jb21wbGV0ZSkge1xuXHRcdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGNyb3NzT3JpZ2luID0gdGhpcy5faXRlbS5jcm9zc09yaWdpbjtcblx0XHRpZiAoY3Jvc3NPcmlnaW4gPT0gdHJ1ZSkgeyBjcm9zc09yaWdpbiA9IFwiQW5vbnltb3VzXCI7IH1cblx0XHRpZiAoY3Jvc3NPcmlnaW4gIT0gbnVsbCAmJiAhY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzTG9jYWwodGhpcy5faXRlbS5zcmMpKSB7XG5cdFx0XHR0aGlzLl90YWcuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblx0XHR9XG5cblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2xvYWQoKTtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogQmVmb3JlIHRoZSBpdGVtIGxvYWRzLCBzZXQgaXRzIG1pbWVUeXBlIGFuZCByZXNwb25zZVR5cGUuXG5cdCAqIEBwcm9wZXJ0eSBfdXBkYXRlWEhSXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl91cGRhdGVYSFIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC5sb2FkZXIubWltZVR5cGUgPSAndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZC1iaW5hcnknO1xuXG5cdFx0Ly8gT25seSBleGlzdHMgZm9yIFhIUlxuXHRcdGlmIChldmVudC5sb2FkZXIuc2V0UmVzcG9uc2VUeXBlKSB7XG5cdFx0XHRldmVudC5sb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYmxvYlwiKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBJbWFnZSBmaWxlcy5cblx0ICogQG1ldGhvZCBfZm9ybWF0UmVzdWx0XG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcmV0dXJucyB7SFRNTEltYWdlRWxlbWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHJldHVybiBmdW5jdGlvbiAoZG9uZSkge1xuXHRcdFx0dmFyIHRhZyA9IF90aGlzLl90YWc7XG5cdFx0XHR2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuXG5cdFx0XHRpZiAoIV90aGlzLl9wcmVmZXJYSFIpIHtcblx0XHRcdFx0Ly9kb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRhZyk7XG5cdFx0XHR9IGVsc2UgaWYgKFVSTCkge1xuXHRcdFx0XHR2YXIgb2JqVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChsb2FkZXIuZ2V0UmVzdWx0KHRydWUpKTtcblx0XHRcdFx0dGFnLnNyYyA9IG9ialVSTDtcblx0XHRcdFx0dGFnLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKF90aGlzLnNyYyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhZy5zcmMgPSBsb2FkZXIuZ2V0SXRlbSgpLnNyYztcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRhZy5jb21wbGV0ZSkge1xuXHRcdFx0XHRkb25lKHRhZyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGRvbmUodGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkltYWdlTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShJbWFnZUxvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEphdmFTY3JpcHRMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIEphdmFTY3JpcHQgZmlsZXMuXG5cdCAqIEBjbGFzcyBKYXZhU2NyaXB0TG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZlclhIUlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEphdmFTY3JpcHRMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSkFWQVNDUklQVCk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBcInNyY1wiO1xuXHRcdHRoaXMuc2V0VGFnKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEphdmFTY3JpcHRMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBKYXZhU2NyaXB0TG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSkFWQVNDUklQVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpBVkFTQ1JJUFQ7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBKYXZhU2NyaXB0IGZpbGVzLlxuXHQgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEByZXR1cm5zIHtIVE1MTGlua0VsZW1lbnR8SFRNTFN0eWxlRWxlbWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHR2YXIgdGFnID0gbG9hZGVyLmdldFRhZygpO1xuXHRcdGlmICh0aGlzLl9wcmVmZXJYSFIpIHtcblx0XHRcdHRhZy50ZXh0ID0gbG9hZGVyLmdldFJlc3VsdCh0cnVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRhZztcblx0fTtcblxuXHRjcmVhdGVqcy5KYXZhU2NyaXB0TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShKYXZhU2NyaXB0TG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gSlNPTkxvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgSlNPTiBmaWxlcy4gVG8gbG9hZCBKU09OIGNyb3NzLWRvbWFpbiwgdXNlIEpTT05QIGFuZCB0aGUge3sjY3Jvc3NMaW5rIFwiSlNPTlBMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaW5zdGVhZC4gVG8gbG9hZCBKU09OLWZvcm1hdHRlZCBtYW5pZmVzdHMsIHVzZSB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHRvXG5cdCAqIGxvYWQgRWFzZWxKUyBTcHJpdGVTaGVldHMsIHVzZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldExvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQGNsYXNzIEpTT05Mb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gSlNPTkxvYWRlcihsb2FkSXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHRydWUsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpTT04pO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IHRoaXMuX2Zvcm1hdFJlc3VsdDtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChKU09OTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gSlNPTkxvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pTT046cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTiAmJiAhaXRlbS5fbG9hZEFzSlNPTlA7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBKU09OIGZpbGVzLlxuXHQgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEByZXR1cm5zIHtIVE1MTGlua0VsZW1lbnR8SFRNTFN0eWxlRWxlbWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHR2YXIganNvbiA9IG51bGw7XG5cdFx0dHJ5IHtcblx0XHRcdGpzb24gPSBjcmVhdGVqcy5EYXRhVXRpbHMucGFyc2VKU09OKGxvYWRlci5nZXRSZXN1bHQodHJ1ZSkpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiSlNPTl9GT1JNQVRcIiwgbnVsbCwgZSk7XG5cdFx0XHR0aGlzLl9zZW5kRXJyb3IoZXZlbnQpO1xuXHRcdFx0cmV0dXJuIGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpzb247XG5cdH07XG5cblx0Y3JlYXRlanMuSlNPTkxvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoSlNPTkxvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEpTT05QTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBKU09OUCBmaWxlcywgd2hpY2ggYXJlIEpTT04tZm9ybWF0dGVkIHRleHQgZmlsZXMsIHdyYXBwZWQgaW4gYSBjYWxsYmFjay4gVG8gbG9hZCByZWd1bGFyIEpTT05cblx0ICogd2l0aG91dCBhIGNhbGxiYWNrIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiSlNPTkxvYWRlclwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLiBUbyBsb2FkIEpTT04tZm9ybWF0dGVkIG1hbmlmZXN0cyxcblx0ICogdXNlIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgdG8gbG9hZCBFYXNlbEpTIFNwcml0ZVNoZWV0cywgdXNlXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgSlNPTlAgZmlsZXMgbG9hZGVkIGNvbmN1cnJlbnRseSByZXF1aXJlIGEgPGVtPnVuaXF1ZTwvZW0+IGNhbGxiYWNrLiBUbyBlbnN1cmUgSlNPTlAgZmlsZXMgYXJlIGxvYWRlZFxuXHQgKiBpbiBvcmRlciwgZWl0aGVyIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldE1heENvbm5lY3Rpb25zXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCAoc2V0IHRvIDEpLFxuXHQgKiBvciBzZXQge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vbWFpbnRhaW5PcmRlcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBvbiBpdGVtcyB3aXRoIHRoZSBzYW1lIGNhbGxiYWNrLlxuXHQgKiBAY2xhc3MgSlNPTlBMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gSlNPTlBMb2FkZXIobG9hZEl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBmYWxzZSwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTlApO1xuXHRcdHRoaXMuc2V0VGFnKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpO1xuXHRcdHRoaXMuZ2V0VGFnKCkudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoSlNPTlBMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBKU09OUExvYWRlcjtcblxuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSlNPTlA6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTlAgfHwgaXRlbS5fbG9hZEFzSlNPTlA7XG5cdH07XG5cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0cC5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jYW5jZWwoKTtcblx0XHR0aGlzLl9kaXNwb3NlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIExvYWRzIHRoZSBKU09OcCBmaWxlLiAgQmVjYXVzZSBvZiB0aGUgdW5pcXVlIGxvYWRpbmcgbmVlZHMgb2YganNvblBcblx0ICogd2UgZG9uJ3QgdXNlIHRoZSBBYnN0cmFjdExvYWRlci5sb2FkKCkgbWV0aG9kLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGxvYWRcblx0ICpcblx0ICovXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5faXRlbS5jYWxsYmFjayA9PSBudWxsKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIGlzIHJlcXVpcmVkIGZvciBsb2FkaW5nIEpTT05QIHJlcXVlc3RzLicpO1xuXHRcdH1cblxuXHRcdC8vIFRPRE86IExvb2sgaW50byBjcmVhdGluZyBvdXIgb3duIGlGcmFtZSB0byBoYW5kbGUgdGhlIGxvYWRcblx0XHQvLyBJbiB0aGUgZmlyc3QgYXR0ZW1wdCwgRkYgZGlkIG5vdCBnZXQgdGhlIHJlc3VsdFxuXHRcdC8vICAgcmVzdWx0IGluc3RhbmNlb2YgT2JqZWN0IGRpZCBub3Qgd29yayBlaXRoZXJcblx0XHQvLyAgIHNvIHdlIHdvdWxkIG5lZWQgdG8gY2xvbmUgdGhlIHJlc3VsdC5cblx0XHRpZiAod2luZG93W3RoaXMuX2l0ZW0uY2FsbGJhY2tdICE9IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XCJKU09OUCBjYWxsYmFjayAnXCIgK1xuXHRcdFx0XHR0aGlzLl9pdGVtLmNhbGxiYWNrICtcblx0XHRcdFx0XCInIGFscmVhZHkgZXhpc3RzIG9uIHdpbmRvdy4gWW91IG5lZWQgdG8gc3BlY2lmeSBhIGRpZmZlcmVudCBjYWxsYmFjayBvciByZS1uYW1lIHRoZSBjdXJyZW50IG9uZS5cIik7XG5cdFx0fVxuXG5cdFx0d2luZG93W3RoaXMuX2l0ZW0uY2FsbGJhY2tdID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlTG9hZCwgdGhpcyk7XG5cdFx0d2luZG93LmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fdGFnKTtcblxuXHRcdHRoaXMuX2xvYWRUaW1lb3V0ID0gc2V0VGltZW91dChjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUaW1lb3V0LCB0aGlzKSwgdGhpcy5faXRlbS5sb2FkVGltZW91dCk7XG5cblx0XHQvLyBMb2FkIHRoZSB0YWdcblx0XHR0aGlzLl90YWcuc3JjID0gdGhpcy5faXRlbS5zcmM7XG5cdH07XG5cblx0Ly8gcHJpdmF0ZSBtZXRob2RzXG5cdC8qKlxuXHQgKiBIYW5kbGUgdGhlIEpTT05QIGNhbGxiYWNrLCB3aGljaCBpcyBhIHB1YmxpYyBtZXRob2QgZGVmaW5lZCBvbiBgd2luZG93YC5cblx0ICogQG1ldGhvZCBfaGFuZGxlTG9hZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgZm9ybWF0dGVkIEpTT04gZGF0YS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZUxvYWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdHRoaXMuX3Jlc3VsdCA9IHRoaXMuX3Jhd1Jlc3VsdCA9IGRhdGE7XG5cdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cblx0XHR0aGlzLl9kaXNwb3NlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSB0YWcgcmVxdWVzdCBoYXMgbm90IGxvYWRlZCB3aXRoaW4gdGhlIHRpbWUgc3BlY2ZpZWQgaW4gbG9hZFRpbWVvdXQuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUVycm9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGVycm9yIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9kaXNwb3NlKCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwidGltZW91dFwiKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENsZWFuIHVwIHRoZSBKU09OUCBsb2FkLiBUaGlzIGNsZWFycyBvdXQgdGhlIGNhbGxiYWNrIGFuZCBzY3JpcHQgdGFnIHRoYXQgdGhpcyBsb2FkZXIgY3JlYXRlcy5cblx0ICogQG1ldGhvZCBfZGlzcG9zZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR3aW5kb3cuZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLl90YWcpO1xuXHRcdGRlbGV0ZSB3aW5kb3dbdGhpcy5faXRlbS5jYWxsYmFja107XG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5fbG9hZFRpbWVvdXQpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkpTT05QTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShKU09OUExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIE1hbmlmZXN0TG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBKU09OIG1hbmlmZXN0cy4gSXRlbXMgaW5zaWRlIHRoZSBtYW5pZmVzdCBhcmUgbG9hZGVkIGJlZm9yZSB0aGUgbG9hZGVyIGNvbXBsZXRlcy4gVG8gbG9hZCBtYW5pZmVzdHNcblx0ICogdXNpbmcgSlNPTlAsIHNwZWNpZnkgYSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS9jYWxsYmFjazpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBhcyBwYXJ0IG9mIHRoZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogVGhlIGxpc3Qgb2YgZmlsZXMgaW4gdGhlIG1hbmlmZXN0IG11c3QgYmUgZGVmaW5lZCBvbiB0aGUgdG9wLWxldmVsIEpTT04gb2JqZWN0IGluIGEgYG1hbmlmZXN0YCBwcm9wZXJ0eS4gVGhpc1xuXHQgKiBleGFtcGxlIHNob3dzIGEgc2FtcGxlIG1hbmlmZXN0IGRlZmluaXRpb24sIGFzIHdlbGwgYXMgaG93IHRvIHRvIGluY2x1ZGUgYSBzdWItbWFuaWZlc3QuXG5cdCAqXG5cdCAqIFx0XHR7XG5cdCAqIFx0XHRcdFwicGF0aFwiOiBcImFzc2V0cy9cIixcblx0ICpcdCBcdCAgICBcIm1hbmlmZXN0XCI6IFtcblx0ICpcdFx0XHRcdFwiaW1hZ2UucG5nXCIsXG5cdCAqXHRcdFx0XHR7XCJzcmNcIjogXCJpbWFnZTIucG5nXCIsIFwiaWRcIjpcImltYWdlMlwifSxcblx0ICpcdFx0XHRcdHtcInNyY1wiOiBcInN1Yi1tYW5pZmVzdC5qc29uXCIsIFwidHlwZVwiOlwibWFuaWZlc3RcIiwgXCJjYWxsYmFja1wiOlwianNvbkNhbGxiYWNrXCJ9XG5cdCAqXHQgXHQgICAgXVxuXHQgKlx0IFx0fVxuXHQgKlxuXHQgKiBXaGVuIGEgTWFuaWZlc3RMb2FkZXIgaGFzIGNvbXBsZXRlZCBsb2FkaW5nLCB0aGUgcGFyZW50IGxvYWRlciAodXN1YWxseSBhIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogYnV0IGNvdWxkIGFsc28gYmUgYW5vdGhlciBNYW5pZmVzdExvYWRlcikgd2lsbCBpbmhlcml0IGFsbCB0aGUgbG9hZGVkIGl0ZW1zLCBzbyB5b3UgY2FuIGFjY2VzcyB0aGVtIGRpcmVjdGx5LlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIHt7I2Nyb3NzTGluayBcIkpTT05Mb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkpTT05QTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGFyZVxuXHQgKiBoaWdoZXIgcHJpb3JpdHkgbG9hZGVycywgc28gbWFuaWZlc3RzIDxzdHJvbmc+bXVzdDwvc3Ryb25nPiBzZXQgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL3R5cGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgdG8ge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvTUFOSUZFU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBjbGFzcyBNYW5pZmVzdExvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBNYW5pZmVzdExvYWRlcihsb2FkSXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIG51bGwsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLk1BTklGRVNUKTtcblxuXHQvLyBQdWJsaWMgUHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IG9mIHRoZSBwbHVnaW5zIHJlZ2lzdGVyZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2luc3RhbGxQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0sXG5cdFx0ICogdXNlZCB0byBwYXNzIHBsdWdpbnMgdG8gbmV3IExvYWRRdWV1ZXMgdGhhdCBtYXkgYmUgY3JlYXRlZC5cblx0XHQgKiBAcHJvcGVydHkgX3BsdWdpbnNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAc2luY2UgMC42LjFcblx0XHQgKi9cblx0XHR0aGlzLnBsdWdpbnMgPSBudWxsO1xuXG5cblx0Ly8gUHJvdGVjdGVkIFByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBBbiBpbnRlcm5hbCB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBsb2FkcyB0aGUgY29udGVudHMgb2YgdGhlIG1hbmlmZXN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBfbWFuaWZlc3RRdWV1ZVxuXHRcdCAqIEB0eXBlIHtMb2FkUXVldWV9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9tYW5pZmVzdFF1ZXVlID0gbnVsbDtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChNYW5pZmVzdExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IE1hbmlmZXN0TG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBwcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBUaGUgYW1vdW50IG9mIHByb2dyZXNzIHRoYXQgdGhlIG1hbmlmZXN0IGl0c2VsZiB0YWtlcyB1cC5cblx0ICogQHByb3BlcnR5IE1BTklGRVNUX1BST0dSRVNTXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDAuMjUgKDI1JSlcblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5NQU5JRkVTVF9QUk9HUkVTUyA9IDAuMjU7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9NQU5JRkVTVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLk1BTklGRVNUO1xuXHR9O1xuXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2xvYWQoKTtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHRwLl9jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gdGhpcy5faXRlbS5jYWxsYmFjaztcblx0XHRpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5KU09OUExvYWRlcih0aGlzLl9pdGVtKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5KU09OTG9hZGVyKHRoaXMuX2l0ZW0pO1xuXHRcdH1cblx0fTtcblxuXHRwLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0c3dpdGNoIChldmVudC50eXBlKSB7XG5cdFx0XHRjYXNlIFwiY29tcGxldGVcIjpcblx0XHRcdFx0dGhpcy5fcmF3UmVzdWx0ID0gZXZlbnQudGFyZ2V0LmdldFJlc3VsdCh0cnVlKTtcblx0XHRcdFx0dGhpcy5fcmVzdWx0ID0gZXZlbnQudGFyZ2V0LmdldFJlc3VsdCgpO1xuXHRcdFx0XHR0aGlzLl9zZW5kUHJvZ3Jlc3Mocy5NQU5JRkVTVF9QUk9HUkVTUyk7XG5cdFx0XHRcdHRoaXMuX2xvYWRNYW5pZmVzdCh0aGlzLl9yZXN1bHQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRjYXNlIFwicHJvZ3Jlc3NcIjpcblx0XHRcdFx0ZXZlbnQubG9hZGVkICo9IHMuTUFOSUZFU1RfUFJPR1JFU1M7XG5cdFx0XHRcdHRoaXMucHJvZ3Jlc3MgPSBldmVudC5sb2FkZWQgLyBldmVudC50b3RhbDtcblx0XHRcdFx0aWYgKGlzTmFOKHRoaXMucHJvZ3Jlc3MpIHx8IHRoaXMucHJvZ3Jlc3MgPT0gSW5maW5pdHkpIHsgdGhpcy5wcm9ncmVzcyA9IDA7IH1cblx0XHRcdFx0dGhpcy5fc2VuZFByb2dyZXNzKGV2ZW50KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2hhbmRsZUV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHRwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2Rlc3Ryb3koKTtcblx0XHR0aGlzLl9tYW5pZmVzdFF1ZXVlLmNsb3NlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhbmQgbG9hZCB0aGUgbWFuaWZlc3QgaXRlbXMgb25jZSB0aGUgYWN0dWFsIG1hbmlmZXN0IGhhcyBiZWVuIGxvYWRlZC5cblx0ICogQG1ldGhvZCBfbG9hZE1hbmlmZXN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBqc29uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9sb2FkTWFuaWZlc3QgPSBmdW5jdGlvbiAoanNvbikge1xuXHRcdGlmIChqc29uICYmIGpzb24ubWFuaWZlc3QpIHtcblx0XHRcdHZhciBxdWV1ZSA9IHRoaXMuX21hbmlmZXN0UXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG5cdFx0XHRxdWV1ZS5vbihcImZpbGVsb2FkXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0RmlsZUxvYWQsIHRoaXMpO1xuXHRcdFx0cXVldWUub24oXCJwcm9ncmVzc1wiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdFByb2dyZXNzLCB0aGlzKTtcblx0XHRcdHF1ZXVlLm9uKFwiY29tcGxldGVcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RDb21wbGV0ZSwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRxdWV1ZS5vbihcImVycm9yXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0RXJyb3IsIHRoaXMsIHRydWUpO1xuXHRcdFx0Zm9yKHZhciBpID0gMCwgbCA9IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcdC8vIGNvbnNlcnZlIG9yZGVyIG9mIHBsdWdpbnNcblx0XHRcdFx0cXVldWUuaW5zdGFsbFBsdWdpbih0aGlzLnBsdWdpbnNbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cXVldWUubG9hZE1hbmlmZXN0KGpzb24pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEFuIGl0ZW0gZnJvbSB0aGUge3sjY3Jvc3NMaW5rIFwiX21hbmlmZXN0UXVldWU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaGFzIGNvbXBsZXRlZC5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RGaWxlTG9hZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RGaWxlTG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LnRhcmdldCA9IG51bGw7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG1hbmlmZXN0IGhhcyBjb21wbGV0ZWQgbG9hZGluZy4gVGhpcyB0cmlnZ2VycyB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvY29tcGxldGU6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZnJvbSB0aGUgTWFuaWZlc3RMb2FkZXIuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0Q29tcGxldGVcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZU1hbmlmZXN0Q29tcGxldGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLl9sb2FkZWRJdGVtcyA9IHRoaXMuX21hbmlmZXN0UXVldWUuZ2V0SXRlbXModHJ1ZSk7XG5cdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBtYW5pZmVzdCBoYXMgcmVwb3J0ZWQgcHJvZ3Jlc3MuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0UHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtQcm9ncmVzc0V2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RQcm9ncmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSBldmVudC5wcm9ncmVzcyAqICgxIC0gcy5NQU5JRkVTVF9QUk9HUkVTUykgKyBzLk1BTklGRVNUX1BST0dSRVNTO1xuXHRcdHRoaXMuX3NlbmRQcm9ncmVzcyh0aGlzLnByb2dyZXNzKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG1hbmlmZXN0IGhhcyByZXBvcnRlZCBhbiBlcnJvciB3aXRoIG9uZSBvZiB0aGUgZmlsZXMuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0RXJyb3Jcblx0ICogQHBhcmFtIHtFcnJvckV2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImZpbGVlcnJvclwiKTtcblx0XHRuZXdFdmVudC5pdGVtID0gZXZlbnQuZGF0YTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3RXZlbnQpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLk1hbmlmZXN0TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShNYW5pZmVzdExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNvdW5kTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBIVE1MIGF1ZGlvIGZpbGVzLiBQcmVsb2FkSlMgY2FuIG5vdCBsb2FkIFdlYkF1ZGlvIGZpbGVzLCBhcyBhIFdlYkF1ZGlvIGNvbnRleHQgaXMgcmVxdWlyZWQsIHdoaWNoXG5cdCAqIHNob3VsZCBiZSBjcmVhdGVkIGJ5IGVpdGhlciBhIGxpYnJhcnkgcGxheWluZyB0aGUgc291bmQgKHN1Y2ggYXMgPGEgaHJlZj1cImh0dHA6Ly9zb3VuZGpzLmNvbVwiPlNvdW5kSlM8L2E+LCBvciBhblxuXHQgKiBleHRlcm5hbCBmcmFtZXdvcmsgdGhhdCBoYW5kbGVzIGF1ZGlvIHBsYXliYWNrLiBUbyBsb2FkIGNvbnRlbnQgdGhhdCBjYW4gYmUgcGxheWVkIGJ5IFdlYkF1ZGlvLCB1c2UgdGhlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkJpbmFyeUxvYWRlclwifX17ey9jcm9zc0xpbmt9fSwgYW5kIGhhbmRsZSB0aGUgYXVkaW8gY29udGV4dCBkZWNvZGluZyBtYW51YWxseS5cblx0ICogQGNsYXNzIFNvdW5kTG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZlclhIUlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdE1lZGlhTG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gU291bmRMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuXHRcdHRoaXMuQWJzdHJhY3RNZWRpYUxvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgcHJlZmVyWEhSLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TT1VORCk7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdGlmIChjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNBdWRpb1RhZyhsb2FkSXRlbSkpIHtcblx0XHRcdHRoaXMuX3RhZyA9IGxvYWRJdGVtO1xuXHRcdH0gZWxzZSBpZiAoY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzQXVkaW9UYWcobG9hZEl0ZW0uc3JjKSkge1xuXHRcdFx0dGhpcy5fdGFnID0gbG9hZEl0ZW07XG5cdFx0fSBlbHNlIGlmIChjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNBdWRpb1RhZyhsb2FkSXRlbS50YWcpKSB7XG5cdFx0XHR0aGlzLl90YWcgPSBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNBdWRpb1RhZyhsb2FkSXRlbSkgPyBsb2FkSXRlbSA6IGxvYWRJdGVtLnNyYztcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fdGFnICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3ByZWZlclhIUiA9IGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTb3VuZExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RNZWRpYUxvYWRlcik7XG5cdHZhciBzID0gU291bmRMb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TT1VORDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TT1VORDtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHRwLl9jcmVhdGVUYWcgPSBmdW5jdGlvbiAoc3JjKSB7XG5cdFx0dmFyIHRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhdWRpb1wiKTtcblx0XHR0YWcuYXV0b3BsYXkgPSBmYWxzZTtcblx0XHR0YWcucHJlbG9hZCA9IFwibm9uZVwiO1xuXG5cdFx0Ly9MTTogRmlyZWZveCBmYWlscyB3aGVuIHRoaXMgdGhlIHByZWxvYWQ9XCJub25lXCIgZm9yIG90aGVyIHRhZ3MsIGJ1dCBpdCBuZWVkcyB0byBiZSBcIm5vbmVcIiB0byBlbnN1cmUgUHJlbG9hZEpTIHdvcmtzLlxuXHRcdHRhZy5zcmMgPSBzcmM7XG5cdFx0cmV0dXJuIHRhZztcblx0fTtcblxuXHRjcmVhdGVqcy5Tb3VuZExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoU291bmRMb2FkZXIsIFwiQWJzdHJhY3RNZWRpYUxvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFZpZGVvTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciB2aWRlbyBmaWxlcy5cblx0ICogQGNsYXNzIFZpZGVvTG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZlclhIUlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdE1lZGlhTG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gVmlkZW9Mb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuXHRcdHRoaXMuQWJzdHJhY3RNZWRpYUxvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgcHJlZmVyWEhSLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5WSURFTyk7XG5cblx0XHRpZiAoY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzVmlkZW9UYWcobG9hZEl0ZW0pIHx8IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc1ZpZGVvVGFnKGxvYWRJdGVtLnNyYykpIHtcblx0XHRcdHRoaXMuc2V0VGFnKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc1ZpZGVvVGFnKGxvYWRJdGVtKT9sb2FkSXRlbTpsb2FkSXRlbS5zcmMpO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCB1c2UgWEhSIGZvciBhIHRhZyB0aGF0J3MgcGFzc2VkIGluLlxuXHRcdFx0dGhpcy5fcHJlZmVyWEhSID0gZmFsc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2V0VGFnKHRoaXMuX2NyZWF0ZVRhZygpKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoVmlkZW9Mb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TWVkaWFMb2FkZXIpO1xuXHR2YXIgcyA9IFZpZGVvTG9hZGVyO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBuZXcgdmlkZW8gdGFnXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NyZWF0ZVRhZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xuXHR9O1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvVklERU86cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVklERU87XG5cdH07XG5cblx0Y3JlYXRlanMuVmlkZW9Mb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKFZpZGVvTG9hZGVyLCBcIkFic3RyYWN0TWVkaWFMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTcHJpdGVTaGVldExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgRWFzZWxKUyBTcHJpdGVTaGVldHMuIEltYWdlcyBpbnNpZGUgdGhlIHNwcml0ZXNoZWV0IGRlZmluaXRpb24gYXJlIGxvYWRlZCBiZWZvcmUgdGhlIGxvYWRlclxuXHQgKiBjb21wbGV0ZXMuIFRvIGxvYWQgU3ByaXRlU2hlZXRzIHVzaW5nIEpTT05QLCBzcGVjaWZ5IGEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vY2FsbGJhY2s6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogYXMgcGFydCBvZiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0uIE5vdGUgdGhhdCB0aGUge3sjY3Jvc3NMaW5rIFwiSlNPTkxvYWRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBhbmQge3sjY3Jvc3NMaW5rIFwiSlNPTlBMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gYXJlIGhpZ2hlciBwcmlvcml0eSBsb2FkZXJzLCBzbyBTcHJpdGVTaGVldHMgPHN0cm9uZz5tdXN0PC9zdHJvbmc+XG5cdCAqIHNldCB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0ge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vdHlwZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eVxuXHQgKiB0byB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TUFJJVEVTSEVFVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQGNsYXNzIFNwcml0ZVNoZWV0TG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFNwcml0ZVNoZWV0TG9hZGVyKGxvYWRJdGVtKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgbnVsbCwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU1BSSVRFU0hFRVQpO1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBBbiBpbnRlcm5hbCBxdWV1ZSB3aGljaCBsb2FkcyB0aGUgU3ByaXRlU2hlZXQncyBpbWFnZXMuXG5cdFx0ICogQG1ldGhvZCBfbWFuaWZlc3RRdWV1ZVxuXHRcdCAqIEB0eXBlIHtMb2FkUXVldWV9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9tYW5pZmVzdFF1ZXVlID0gbnVsbDtcblx0fVxuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFNwcml0ZVNoZWV0TG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gU3ByaXRlU2hlZXRMb2FkZXI7XG5cblx0Ly8gc3RhdGljIHByb3BlcnRpZXNcblx0LyoqXG5cdCAqIFRoZSBhbW91bnQgb2YgcHJvZ3Jlc3MgdGhhdCB0aGUgbWFuaWZlc3QgaXRzZWxmIHRha2VzIHVwLlxuXHQgKiBAcHJvcGVydHkgU1BSSVRFU0hFRVRfUFJPR1JFU1Ncblx0ICogQHR5cGUge251bWJlcn1cblx0ICogQGRlZmF1bHQgMC4yNSAoMjUlKVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLlNQUklURVNIRUVUX1BST0dSRVNTID0gMC4yNTtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1NQUklURVNIRUVUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU1BSSVRFU0hFRVQ7XG5cdH07XG5cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0cC5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9kZXN0cm95O1xuXHRcdHRoaXMuX21hbmlmZXN0UXVldWUuY2xvc2UoKTtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHRwLl9jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gdGhpcy5faXRlbS5jYWxsYmFjaztcblx0XHRpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiBjYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLkpTT05QTG9hZGVyKHRoaXMuX2l0ZW0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLkpTT05Mb2FkZXIodGhpcy5faXRlbSk7XG5cdFx0fVxuXHR9O1xuXG5cdHAuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcblx0XHRcdGNhc2UgXCJjb21wbGV0ZVwiOlxuXHRcdFx0XHR0aGlzLl9yYXdSZXN1bHQgPSBldmVudC50YXJnZXQuZ2V0UmVzdWx0KHRydWUpO1xuXHRcdFx0XHR0aGlzLl9yZXN1bHQgPSBldmVudC50YXJnZXQuZ2V0UmVzdWx0KCk7XG5cdFx0XHRcdHRoaXMuX3NlbmRQcm9ncmVzcyhzLlNQUklURVNIRUVUX1BST0dSRVNTKTtcblx0XHRcdFx0dGhpcy5fbG9hZE1hbmlmZXN0KHRoaXMuX3Jlc3VsdCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdGNhc2UgXCJwcm9ncmVzc1wiOlxuXHRcdFx0XHRldmVudC5sb2FkZWQgKj0gcy5TUFJJVEVTSEVFVF9QUk9HUkVTUztcblx0XHRcdFx0dGhpcy5wcm9ncmVzcyA9IGV2ZW50LmxvYWRlZCAvIGV2ZW50LnRvdGFsO1xuXHRcdFx0XHRpZiAoaXNOYU4odGhpcy5wcm9ncmVzcykgfHwgdGhpcy5wcm9ncmVzcyA9PSBJbmZpbml0eSkgeyB0aGlzLnByb2dyZXNzID0gMDsgfVxuXHRcdFx0XHR0aGlzLl9zZW5kUHJvZ3Jlc3MoZXZlbnQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfaGFuZGxlRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW5kIGxvYWQgdGhlIGltYWdlcyBvbmNlIHRoZSBTcHJpdGVTaGVldCBKU09OIGhhcyBiZWVuIGxvYWRlZC5cblx0ICogQG1ldGhvZCBfbG9hZE1hbmlmZXN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBqc29uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9sb2FkTWFuaWZlc3QgPSBmdW5jdGlvbiAoanNvbikge1xuXHRcdGlmIChqc29uICYmIGpzb24uaW1hZ2VzKSB7XG5cdFx0XHR2YXIgcXVldWUgPSB0aGlzLl9tYW5pZmVzdFF1ZXVlID0gbmV3IGNyZWF0ZWpzLkxvYWRRdWV1ZSgpO1xuXHRcdFx0cXVldWUub24oXCJjb21wbGV0ZVwiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdENvbXBsZXRlLCB0aGlzLCB0cnVlKTtcblx0XHRcdHF1ZXVlLm9uKFwiZmlsZWxvYWRcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RGaWxlTG9hZCwgdGhpcyk7XG5cdFx0XHRxdWV1ZS5vbihcInByb2dyZXNzXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0UHJvZ3Jlc3MsIHRoaXMpO1xuXHRcdFx0cXVldWUub24oXCJlcnJvclwiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdEVycm9yLCB0aGlzLCB0cnVlKTtcblx0XHRcdHF1ZXVlLmxvYWRNYW5pZmVzdChqc29uLmltYWdlcyk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbiBpdGVtIGZyb20gdGhlIHt7I2Nyb3NzTGluayBcIl9tYW5pZmVzdFF1ZXVlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGhhcyBjb21wbGV0ZWQuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0RmlsZUxvYWRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZU1hbmlmZXN0RmlsZUxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgaW1hZ2UgPSBldmVudC5yZXN1bHQ7XG5cdFx0aWYgKGltYWdlICE9IG51bGwpIHtcblx0XHRcdHZhciBpbWFnZXMgPSB0aGlzLmdldFJlc3VsdCgpLmltYWdlcztcblx0XHRcdHZhciBwb3MgPSBpbWFnZXMuaW5kZXhPZihldmVudC5pdGVtLnNyYyk7XG5cdFx0XHRpbWFnZXNbcG9zXSA9IGltYWdlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVGhlIGltYWdlcyBoYXZlIGNvbXBsZXRlZCBsb2FkaW5nLiBUaGlzIHRyaWdnZXJzIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9jb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSBmcm9tIHRoZSBTcHJpdGVTaGVldExvYWRlci5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RDb21wbGV0ZVxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RDb21wbGV0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuX3Jlc3VsdCA9IG5ldyBjcmVhdGVqcy5TcHJpdGVTaGVldCh0aGlzLl9yZXN1bHQpO1xuXHRcdHRoaXMuX2xvYWRlZEl0ZW1zID0gdGhpcy5fbWFuaWZlc3RRdWV1ZS5nZXRJdGVtcyh0cnVlKTtcblx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIGltYWdlcyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0gaGFzIHJlcG9ydGVkIHByb2dyZXNzLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNYW5pZmVzdFByb2dyZXNzXG5cdCAqIEBwYXJhbSB7UHJvZ3Jlc3NFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZU1hbmlmZXN0UHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR0aGlzLnByb2dyZXNzID0gZXZlbnQucHJvZ3Jlc3MgKiAoMSAtIHMuU1BSSVRFU0hFRVRfUFJPR1JFU1MpICsgcy5TUFJJVEVTSEVFVF9QUk9HUkVTUztcblx0XHR0aGlzLl9zZW5kUHJvZ3Jlc3ModGhpcy5wcm9ncmVzcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFuIGltYWdlIGhhcyByZXBvcnRlZCBhbiBlcnJvci5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RFcnJvclxuXHQgKiBAcGFyYW0ge0Vycm9yRXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVNYW5pZmVzdEVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIG5ld0V2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiZmlsZWVycm9yXCIpO1xuXHRcdG5ld0V2ZW50Lml0ZW0gPSBldmVudC5kYXRhO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG5cdH07XG5cblx0Y3JlYXRlanMuU3ByaXRlU2hlZXRMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKFNwcml0ZVNoZWV0TG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU1ZHTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBTVkcgZmlsZXMuXG5cdCAqIEBjbGFzcyBTVkdMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gU1ZHTG9hZGVyKGxvYWRJdGVtLCBwcmVmZXJYSFIpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNWRyk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBcImRhdGFcIjtcblxuXHRcdGlmIChwcmVmZXJYSFIpIHtcblx0XHRcdHRoaXMuc2V0VGFnKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIikpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNldFRhZyhkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib2JqZWN0XCIpKTtcblx0XHRcdHRoaXMuZ2V0VGFnKCkudHlwZSA9IFwiaW1hZ2Uvc3ZnK3htbFwiO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChTVkdMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBTVkdMb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9TVkc6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TVkc7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBTVkcgZmlsZXMuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHJldHVybnMge09iamVjdH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHQvLyBtaW1lIHNob3VsZCBiZSBpbWFnZS9zdmcreG1sLCBidXQgT3BlcmEgcmVxdWlyZXMgdGV4dC94bWxcblx0XHR2YXIgeG1sID0gY3JlYXRlanMuRGF0YVV0aWxzLnBhcnNlWE1MKGxvYWRlci5nZXRSZXN1bHQodHJ1ZSksIFwidGV4dC94bWxcIik7XG5cdFx0dmFyIHRhZyA9IGxvYWRlci5nZXRUYWcoKTtcblxuXHRcdGlmICghdGhpcy5fcHJlZmVyWEhSICYmIGRvY3VtZW50LmJvZHkuY29udGFpbnModGFnKSkge1xuXHRcdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0YWcpO1xuXHRcdH1cblxuXHRcdGlmICh4bWwuZG9jdW1lbnRFbGVtZW50ICE9IG51bGwpIHtcblx0XHRcdHRhZy5hcHBlbmRDaGlsZCh4bWwuZG9jdW1lbnRFbGVtZW50KTtcblx0XHRcdHRhZy5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG5cdFx0XHRyZXR1cm4gdGFnO1xuXHRcdH0gZWxzZSB7IC8vIEZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgU1ZHLCBqdXN0IGdpdmUgdGhlbSB0aGUgWE1MLiAoSUUgOS04KVxuXHRcdFx0cmV0dXJuIHhtbDtcblx0XHR9XG5cdH07XG5cblx0Y3JlYXRlanMuU1ZHTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShTVkdMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBYTUxMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIENTUyBmaWxlcy5cblx0ICogQGNsYXNzIFhNTExvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBYTUxMb2FkZXIobG9hZEl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCB0cnVlLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5YTUwpO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IHRoaXMuX2Zvcm1hdFJlc3VsdDtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChYTUxMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBYTUxMb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9YTUw6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuWE1MO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBUaGUgcmVzdWx0IGZvcm1hdHRlciBmb3IgWE1MIGZpbGVzLlxuXHQgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEByZXR1cm5zIHtYTUxEb2N1bWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHRyZXR1cm4gY3JlYXRlanMuRGF0YVV0aWxzLnBhcnNlWE1MKGxvYWRlci5nZXRSZXN1bHQodHJ1ZSksIFwidGV4dC94bWxcIik7XG5cdH07XG5cblx0Y3JlYXRlanMuWE1MTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShYTUxMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG4vKiFcbiogVHdlZW5KU1xuKiBWaXNpdCBodHRwOi8vY3JlYXRlanMuY29tLyBmb3IgZG9jdW1lbnRhdGlvbiwgdXBkYXRlcyBhbmQgZXhhbXBsZXMuXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMCBnc2tpbm5lci5jb20sIGluYy5cbipcbiogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4qIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiogY29uZGl0aW9uczpcbipcbiogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4qXG4qIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4qIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4qIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cblxuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gZXh0ZW5kLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbi8qKlxuICogU2V0cyB1cCB0aGUgcHJvdG90eXBlIGNoYWluIGFuZCBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBmb3IgYSBuZXcgY2xhc3MuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIHJpZ2h0IGFmdGVyIGNyZWF0aW5nIHRoZSBjbGFzcyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBcdGZ1bmN0aW9uIE15U3ViQ2xhc3MoKSB7fVxuICogXHRjcmVhdGVqcy5leHRlbmQoTXlTdWJDbGFzcywgTXlTdXBlckNsYXNzKTtcbiAqIFx0Q2xhc3NCLnByb3RvdHlwZS5kb1NvbWV0aGluZyA9IGZ1bmN0aW9uKCkgeyB9XG4gKlxuICogXHR2YXIgZm9vID0gbmV3IE15U3ViQ2xhc3MoKTtcbiAqIFx0Y29uc29sZS5sb2coZm9vIGluc3RhbmNlb2YgTXlTdXBlckNsYXNzKTsgLy8gdHJ1ZVxuICogXHRjb25zb2xlLmxvZyhmb28ucHJvdG90eXBlLmNvbnN0cnVjdG9yID09PSBNeVN1YkNsYXNzKTsgLy8gdHJ1ZVxuICpcbiAqIEBtZXRob2QgZXh0ZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJjbGFzcyBUaGUgc3ViY2xhc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdXBlcmNsYXNzIFRoZSBzdXBlcmNsYXNzIHRvIGV4dGVuZC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBzdWJjbGFzcydzIG5ldyBwcm90b3R5cGUuXG4gKi9cbmNyZWF0ZWpzLmV4dGVuZCA9IGZ1bmN0aW9uKHN1YmNsYXNzLCBzdXBlcmNsYXNzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGZ1bmN0aW9uIG8oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBzdWJjbGFzczsgfVxuXHRvLnByb3RvdHlwZSA9IHN1cGVyY2xhc3MucHJvdG90eXBlO1xuXHRyZXR1cm4gKHN1YmNsYXNzLnByb3RvdHlwZSA9IG5ldyBvKCkpO1xufTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIHByb21vdGUuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuLyoqXG4gKiBAY2xhc3MgVXRpbGl0eSBNZXRob2RzXG4gKi9cblxuLyoqXG4gKiBQcm9tb3RlcyBhbnkgbWV0aG9kcyBvbiB0aGUgc3VwZXIgY2xhc3MgdGhhdCB3ZXJlIG92ZXJyaWRkZW4sIGJ5IGNyZWF0aW5nIGFuIGFsaWFzIGluIHRoZSBmb3JtYXQgYHByZWZpeF9tZXRob2ROYW1lYC5cbiAqIEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGUgc3VwZXIgY2xhc3MncyBuYW1lIGFzIHRoZSBwcmVmaXguXG4gKiBBbiBhbGlhcyB0byB0aGUgc3VwZXIgY2xhc3MncyBjb25zdHJ1Y3RvciBpcyBhbHdheXMgYWRkZWQgaW4gdGhlIGZvcm1hdCBgcHJlZml4X2NvbnN0cnVjdG9yYC5cbiAqIFRoaXMgYWxsb3dzIHRoZSBzdWJjbGFzcyB0byBjYWxsIHN1cGVyIGNsYXNzIG1ldGhvZHMgd2l0aG91dCB1c2luZyBgZnVuY3Rpb24uY2FsbGAsIHByb3ZpZGluZyBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIGBNeVN1YkNsYXNzYCBleHRlbmRzIGBNeVN1cGVyQ2xhc3NgLCBhbmQgYm90aCBkZWZpbmUgYSBgZHJhd2AgbWV0aG9kLCB0aGVuIGNhbGxpbmcgYHByb21vdGUoTXlTdWJDbGFzcywgXCJNeVN1cGVyQ2xhc3NcIilgXG4gKiB3b3VsZCBhZGQgYSBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYCBtZXRob2QgdG8gTXlTdWJDbGFzcyBhbmQgcHJvbW90ZSB0aGUgYGRyYXdgIG1ldGhvZCBvbiBgTXlTdXBlckNsYXNzYCB0byB0aGVcbiAqIHByb3RvdHlwZSBvZiBgTXlTdWJDbGFzc2AgYXMgYE15U3VwZXJDbGFzc19kcmF3YC5cbiAqXG4gKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGNsYXNzJ3MgcHJvdG90eXBlIGlzIGZ1bGx5IGRlZmluZWQuXG4gKlxuICogXHRmdW5jdGlvbiBDbGFzc0EobmFtZSkge1xuICogXHRcdHRoaXMubmFtZSA9IG5hbWU7XG4gKiBcdH1cbiAqIFx0Q2xhc3NBLnByb3RvdHlwZS5ncmVldCA9IGZ1bmN0aW9uKCkge1xuICogXHRcdHJldHVybiBcIkhlbGxvIFwiK3RoaXMubmFtZTtcbiAqIFx0fVxuICpcbiAqIFx0ZnVuY3Rpb24gQ2xhc3NCKG5hbWUsIHB1bmN0dWF0aW9uKSB7XG4gKiBcdFx0dGhpcy5DbGFzc0FfY29uc3RydWN0b3IobmFtZSk7XG4gKiBcdFx0dGhpcy5wdW5jdHVhdGlvbiA9IHB1bmN0dWF0aW9uO1xuICogXHR9XG4gKiBcdGNyZWF0ZWpzLmV4dGVuZChDbGFzc0IsIENsYXNzQSk7XG4gKiBcdENsYXNzQi5wcm90b3R5cGUuZ3JlZXQgPSBmdW5jdGlvbigpIHtcbiAqIFx0XHRyZXR1cm4gdGhpcy5DbGFzc0FfZ3JlZXQoKSt0aGlzLnB1bmN0dWF0aW9uO1xuICogXHR9XG4gKiBcdGNyZWF0ZWpzLnByb21vdGUoQ2xhc3NCLCBcIkNsYXNzQVwiKTtcbiAqXG4gKiBcdHZhciBmb28gPSBuZXcgQ2xhc3NCKFwiV29ybGRcIiwgXCIhPyFcIik7XG4gKiBcdGNvbnNvbGUubG9nKGZvby5ncmVldCgpKTsgLy8gSGVsbG8gV29ybGQhPyFcbiAqXG4gKiBAbWV0aG9kIHByb21vdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YmNsYXNzIFRoZSBjbGFzcyB0byBwcm9tb3RlIHN1cGVyIGNsYXNzIG1ldGhvZHMgb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IFRoZSBwcmVmaXggdG8gYWRkIHRvIHRoZSBwcm9tb3RlZCBtZXRob2QgbmFtZXMuIFVzdWFsbHkgdGhlIG5hbWUgb2YgdGhlIHN1cGVyY2xhc3MuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgc3ViY2xhc3MuXG4gKi9cbmNyZWF0ZWpzLnByb21vdGUgPSBmdW5jdGlvbihzdWJjbGFzcywgcHJlZml4KSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciBzdWJQID0gc3ViY2xhc3MucHJvdG90eXBlLCBzdXBQID0gKE9iamVjdC5nZXRQcm90b3R5cGVPZiYmT2JqZWN0LmdldFByb3RvdHlwZU9mKHN1YlApKXx8c3ViUC5fX3Byb3RvX187XG5cdGlmIChzdXBQKSB7XG5cdFx0c3ViUFsocHJlZml4Kz1cIl9cIikgKyBcImNvbnN0cnVjdG9yXCJdID0gc3VwUC5jb25zdHJ1Y3RvcjsgLy8gY29uc3RydWN0b3IgaXMgbm90IGFsd2F5cyBpbm51bWVyYWJsZVxuXHRcdGZvciAodmFyIG4gaW4gc3VwUCkge1xuXHRcdFx0aWYgKHN1YlAuaGFzT3duUHJvcGVydHkobikgJiYgKHR5cGVvZiBzdXBQW25dID09IFwiZnVuY3Rpb25cIikpIHsgc3ViUFtwcmVmaXggKyBuXSA9IHN1cFBbbl07IH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHN1YmNsYXNzO1xufTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEV2ZW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQ29udGFpbnMgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBzaGFyZWQgYnkgYWxsIGV2ZW50cyBmb3IgdXNlIHdpdGhcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBcblx0ICogTm90ZSB0aGF0IEV2ZW50IG9iamVjdHMgYXJlIG9mdGVuIHJldXNlZCwgc28geW91IHNob3VsZCBuZXZlclxuXHQgKiByZWx5IG9uIGFuIGV2ZW50IG9iamVjdCdzIHN0YXRlIG91dHNpZGUgb2YgdGhlIGNhbGwgc3RhY2sgaXQgd2FzIHJlY2VpdmVkIGluLlxuXHQgKiBAY2xhc3MgRXZlbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYnViYmxlcyBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZXZlbnQgd2lsbCBidWJibGUgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNhbmNlbGFibGUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mIHRoaXMgZXZlbnQgY2FuIGJlIGNhbmNlbGxlZC5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gRXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSkge1xuXHRcdFxuXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IHR5cGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiovXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIG9iamVjdCB0aGF0IGdlbmVyYXRlZCBhbiBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgdGFyZ2V0XG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy50YXJnZXQgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY3VycmVudCB0YXJnZXQgdGhhdCBhIGJ1YmJsaW5nIGV2ZW50IGlzIGJlaW5nIGRpc3BhdGNoZWQgZnJvbS4gRm9yIG5vbi1idWJibGluZyBldmVudHMsIHRoaXMgd2lsbFxuXHRcdCAqIGFsd2F5cyBiZSB0aGUgc2FtZSBhcyB0YXJnZXQuIEZvciBleGFtcGxlLCBpZiBjaGlsZE9iai5wYXJlbnQgPSBwYXJlbnRPYmosIGFuZCBhIGJ1YmJsaW5nIGV2ZW50XG5cdFx0ICogaXMgZ2VuZXJhdGVkIGZyb20gY2hpbGRPYmosIHRoZW4gYSBsaXN0ZW5lciBvbiBwYXJlbnRPYmogd291bGQgcmVjZWl2ZSB0aGUgZXZlbnQgd2l0aFxuXHRcdCAqIHRhcmdldD1jaGlsZE9iaiAodGhlIG9yaWdpbmFsIHRhcmdldCkgYW5kIGN1cnJlbnRUYXJnZXQ9cGFyZW50T2JqICh3aGVyZSB0aGUgbGlzdGVuZXIgd2FzIGFkZGVkKS5cblx0XHQgKiBAcHJvcGVydHkgY3VycmVudFRhcmdldFxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEZvciBidWJibGluZyBldmVudHMsIHRoaXMgaW5kaWNhdGVzIHRoZSBjdXJyZW50IGV2ZW50IHBoYXNlOjxPTD5cblx0XHQgKiBcdDxMST4gY2FwdHVyZSBwaGFzZTogc3RhcnRpbmcgZnJvbSB0aGUgdG9wIHBhcmVudCB0byB0aGUgdGFyZ2V0PC9MST5cblx0XHQgKiBcdDxMST4gYXQgdGFyZ2V0IHBoYXNlOiBjdXJyZW50bHkgYmVpbmcgZGlzcGF0Y2hlZCBmcm9tIHRoZSB0YXJnZXQ8L0xJPlxuXHRcdCAqIFx0PExJPiBidWJibGluZyBwaGFzZTogZnJvbSB0aGUgdGFyZ2V0IHRvIHRoZSB0b3AgcGFyZW50PC9MST5cblx0XHQgKiA8L09MPlxuXHRcdCAqIEBwcm9wZXJ0eSBldmVudFBoYXNlXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5ldmVudFBoYXNlID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IHdpbGwgYnViYmxlIHRocm91Z2ggdGhlIGRpc3BsYXkgbGlzdC5cblx0XHQgKiBAcHJvcGVydHkgYnViYmxlc1xuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5idWJibGVzID0gISFidWJibGVzO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdGhpcyBldmVudCBjYW4gYmUgY2FuY2VsbGVkIHZpYVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50L3ByZXZlbnREZWZhdWx0XCJ9fXt7L2Nyb3NzTGlua319LiBUaGlzIGlzIHNldCB2aWEgdGhlIEV2ZW50IGNvbnN0cnVjdG9yLlxuXHRcdCAqIEBwcm9wZXJ0eSBjYW5jZWxhYmxlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmNhbmNlbGFibGUgPSAhIWNhbmNlbGFibGU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBlcG9jaCB0aW1lIGF0IHdoaWNoIHRoaXMgZXZlbnQgd2FzIGNyZWF0ZWQuXG5cdFx0ICogQHByb3BlcnR5IHRpbWVTdGFtcFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMudGltZVN0YW1wID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHt7I2Nyb3NzTGluayBcIkV2ZW50L3ByZXZlbnREZWZhdWx0XCJ9fXt7L2Nyb3NzTGlua319IGhhcyBiZWVuIGNhbGxlZFxuXHRcdCAqIG9uIHRoaXMgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IGRlZmF1bHRQcmV2ZW50ZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYge3sjY3Jvc3NMaW5rIFwiRXZlbnQvc3RvcFByb3BhZ2F0aW9uXCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXCJ9fXt7L2Nyb3NzTGlua319IGhhcyBiZWVuIGNhbGxlZCBvbiB0aGlzIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBwcm9wYWdhdGlvblN0b3BwZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkXG5cdFx0ICogb24gdGhpcyBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9yZW1vdmVcIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkIG9uIHRoaXMgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IHJlbW92ZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMucmVtb3ZlZCA9IGZhbHNlO1xuXHR9XG5cdHZhciBwID0gRXZlbnQucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblx0XG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogU2V0cyB7eyNjcm9zc0xpbmsgXCJFdmVudC9kZWZhdWx0UHJldmVudGVkXCJ9fXt7L2Nyb3NzTGlua319IHRvIHRydWUuXG5cdCAqIE1pcnJvcnMgdGhlIERPTSBldmVudCBzdGFuZGFyZC5cblx0ICogQG1ldGhvZCBwcmV2ZW50RGVmYXVsdFxuXHQgKiovXG5cdHAucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0aGlzLmNhbmNlbGFibGUmJnRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcHJvcGFnYXRpb25TdG9wcGVkXCJ9fXt7L2Nyb3NzTGlua319IHRvIHRydWUuXG5cdCAqIE1pcnJvcnMgdGhlIERPTSBldmVudCBzdGFuZGFyZC5cblx0ICogQG1ldGhvZCBzdG9wUHJvcGFnYXRpb25cblx0ICoqL1xuXHRwLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB7eyNjcm9zc0xpbmsgXCJFdmVudC9wcm9wYWdhdGlvblN0b3BwZWRcIn19e3svY3Jvc3NMaW5rfX0gYW5kXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50L2ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZFwifX17ey9jcm9zc0xpbmt9fSB0byB0cnVlLlxuXHQgKiBNaXJyb3JzIHRoZSBET00gZXZlbnQgc3RhbmRhcmQuXG5cdCAqIEBtZXRob2Qgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXG5cdCAqKi9cblx0cC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDYXVzZXMgdGhlIGFjdGl2ZSBsaXN0ZW5lciB0byBiZSByZW1vdmVkIHZpYSByZW1vdmVFdmVudExpc3RlbmVyKCk7XG5cdCAqIFxuXHQgKiBcdFx0bXlCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2dCkge1xuXHQgKiBcdFx0XHQvLyBkbyBzdHVmZi4uLlxuXHQgKiBcdFx0XHRldnQucmVtb3ZlKCk7IC8vIHJlbW92ZXMgdGhpcyBsaXN0ZW5lci5cblx0ICogXHRcdH0pO1xuXHQgKiBcblx0ICogQG1ldGhvZCByZW1vdmVcblx0ICoqL1xuXHRwLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVtb3ZlZCA9IHRydWU7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBFdmVudCBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtFdmVudH0gYSBjbG9uZSBvZiB0aGUgRXZlbnQgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgRXZlbnQodGhpcy50eXBlLCB0aGlzLmJ1YmJsZXMsIHRoaXMuY2FuY2VsYWJsZSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUHJvdmlkZXMgYSBjaGFpbmFibGUgc2hvcnRjdXQgbWV0aG9kIGZvciBzZXR0aW5nIGEgbnVtYmVyIG9mIHByb3BlcnRpZXMgb24gdGhlIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHNldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQSBnZW5lcmljIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gY29weSB0byB0aGUgaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4ge0V2ZW50fSBSZXR1cm5zIHRoZSBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5zZXQgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdGZvciAodmFyIG4gaW4gcHJvcHMpIHsgdGhpc1tuXSA9IHByb3BzW25dOyB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltFdmVudCAodHlwZT1cIit0aGlzLnR5cGUrXCIpXVwiO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkV2ZW50ID0gRXZlbnQ7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRXZlbnREaXNwYXRjaGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuLy8gY29uc3RydWN0b3I6XHJcblx0LyoqXHJcblx0ICogRXZlbnREaXNwYXRjaGVyIHByb3ZpZGVzIG1ldGhvZHMgZm9yIG1hbmFnaW5nIHF1ZXVlcyBvZiBldmVudCBsaXN0ZW5lcnMgYW5kIGRpc3BhdGNoaW5nIGV2ZW50cy5cclxuXHQgKlxyXG5cdCAqIFlvdSBjYW4gZWl0aGVyIGV4dGVuZCBFdmVudERpc3BhdGNoZXIgb3IgbWl4IGl0cyBtZXRob2RzIGludG8gYW4gZXhpc3RpbmcgcHJvdG90eXBlIG9yIGluc3RhbmNlIGJ5IHVzaW5nIHRoZVxyXG5cdCAqIEV2ZW50RGlzcGF0Y2hlciB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvaW5pdGlhbGl6ZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXHJcblx0ICogXHJcblx0ICogVG9nZXRoZXIgd2l0aCB0aGUgQ3JlYXRlSlMgRXZlbnQgY2xhc3MsIEV2ZW50RGlzcGF0Y2hlciBwcm92aWRlcyBhbiBleHRlbmRlZCBldmVudCBtb2RlbCB0aGF0IGlzIGJhc2VkIG9uIHRoZVxyXG5cdCAqIERPTSBMZXZlbCAyIGV2ZW50IG1vZGVsLCBpbmNsdWRpbmcgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciwgYW5kIGRpc3BhdGNoRXZlbnQuIEl0IHN1cHBvcnRzXHJcblx0ICogYnViYmxpbmcgLyBjYXB0dXJlLCBwcmV2ZW50RGVmYXVsdCwgc3RvcFByb3BhZ2F0aW9uLCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24sIGFuZCBoYW5kbGVFdmVudC5cclxuXHQgKiBcclxuXHQgKiBFdmVudERpc3BhdGNoZXIgYWxzbyBleHBvc2VzIGEge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL29uXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCwgd2hpY2ggbWFrZXMgaXQgZWFzaWVyXHJcblx0ICogdG8gY3JlYXRlIHNjb3BlZCBsaXN0ZW5lcnMsIGxpc3RlbmVycyB0aGF0IG9ubHkgcnVuIG9uY2UsIGFuZCBsaXN0ZW5lcnMgd2l0aCBhc3NvY2lhdGVkIGFyYml0cmFyeSBkYXRhLiBUaGUgXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL29mZlwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgaXMgbWVyZWx5IGFuIGFsaWFzIHRvXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL3JlbW92ZUV2ZW50TGlzdGVuZXJcIn19e3svY3Jvc3NMaW5rfX0uXHJcblx0ICogXHJcblx0ICogQW5vdGhlciBhZGRpdGlvbiB0byB0aGUgRE9NIExldmVsIDIgbW9kZWwgaXMgdGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9yZW1vdmVBbGxFdmVudExpc3RlbmVyc1wifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIG1ldGhvZCwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbGlzdGVuZXJzIGZvciBhbGwgZXZlbnRzLCBvciBsaXN0ZW5lcnMgZm9yIGEgc3BlY2lmaWMgZXZlbnQuIFRoZSBFdmVudCBvYmplY3QgYWxzbyBcclxuXHQgKiBpbmNsdWRlcyBhIHt7I2Nyb3NzTGluayBcIkV2ZW50L3JlbW92ZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2Qgd2hpY2ggcmVtb3ZlcyB0aGUgYWN0aXZlIGxpc3RlbmVyLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqIEFkZCBFdmVudERpc3BhdGNoZXIgY2FwYWJpbGl0aWVzIHRvIHRoZSBcIk15Q2xhc3NcIiBjbGFzcy5cclxuXHQgKlxyXG5cdCAqICAgICAgRXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUoTXlDbGFzcy5wcm90b3R5cGUpO1xyXG5cdCAqXHJcblx0ICogQWRkIGFuIGV2ZW50IChzZWUge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL2FkZEV2ZW50TGlzdGVuZXJcIn19e3svY3Jvc3NMaW5rfX0pLlxyXG5cdCAqXHJcblx0ICogICAgICBpbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKFwiZXZlbnROYW1lXCIsIGhhbmRsZXJNZXRob2QpO1xyXG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlck1ldGhvZChldmVudCkge1xyXG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LnRhcmdldCArIFwiIFdhcyBDbGlja2VkXCIpO1xyXG5cdCAqICAgICAgfVxyXG5cdCAqXHJcblx0ICogPGI+TWFpbnRhaW5pbmcgcHJvcGVyIHNjb3BlPC9iPjxiciAvPlxyXG5cdCAqIFNjb3BlIChpZS4gXCJ0aGlzXCIpIGNhbiBiZSBiZSBhIGNoYWxsZW5nZSB3aXRoIGV2ZW50cy4gVXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9vblwifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIG1ldGhvZCB0byBzdWJzY3JpYmUgdG8gZXZlbnRzIHNpbXBsaWZpZXMgdGhpcy5cclxuXHQgKlxyXG5cdCAqICAgICAgaW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0ICogICAgICAgICAgY29uc29sZS5sb2coaW5zdGFuY2UgPT0gdGhpcyk7IC8vIGZhbHNlLCBzY29wZSBpcyBhbWJpZ3VvdXMuXHJcblx0ICogICAgICB9KTtcclxuXHQgKiAgICAgIFxyXG5cdCAqICAgICAgaW5zdGFuY2Uub24oXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCkge1xyXG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKGluc3RhbmNlID09IHRoaXMpOyAvLyB0cnVlLCBcIm9uXCIgdXNlcyBkaXNwYXRjaGVyIHNjb3BlIGJ5IGRlZmF1bHQuXHJcblx0ICogICAgICB9KTtcclxuXHQgKiBcclxuXHQgKiBJZiB5b3Ugd2FudCB0byB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpbnN0ZWFkLCB5b3UgbWF5IHdhbnQgdG8gdXNlIGZ1bmN0aW9uLmJpbmQoKSBvciBhIHNpbWlsYXIgcHJveHkgdG8gbWFuYWdlIHNjb3BlLlxyXG5cdCAqICAgICAgXHJcblx0ICpcclxuXHQgKiBAY2xhc3MgRXZlbnREaXNwYXRjaGVyXHJcblx0ICogQGNvbnN0cnVjdG9yXHJcblx0ICoqL1xyXG5cdGZ1bmN0aW9uIEV2ZW50RGlzcGF0Y2hlcigpIHtcclxuXHRcclxuXHRcclxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XHJcblx0XHQvKipcclxuXHRcdCAqIEBwcm90ZWN0ZWRcclxuXHRcdCAqIEBwcm9wZXJ0eSBfbGlzdGVuZXJzXHJcblx0XHQgKiBAdHlwZSBPYmplY3RcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuX2xpc3RlbmVycyA9IG51bGw7XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogQHByb3RlY3RlZFxyXG5cdFx0ICogQHByb3BlcnR5IF9jYXB0dXJlTGlzdGVuZXJzXHJcblx0XHQgKiBAdHlwZSBPYmplY3RcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgPSBudWxsO1xyXG5cdH1cclxuXHR2YXIgcCA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGU7XHJcblxyXG5cdC8qKlxyXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cclxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cclxuXHQgKiBmb3IgZGV0YWlscy5cclxuXHQgKlxyXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqIEBkZXByZWNhdGVkXHJcblx0ICovXHJcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXHJcblxyXG5cclxuLy8gc3RhdGljIHB1YmxpYyBtZXRob2RzOlxyXG5cdC8qKlxyXG5cdCAqIFN0YXRpYyBpbml0aWFsaXplciB0byBtaXggRXZlbnREaXNwYXRjaGVyIG1ldGhvZHMgaW50byBhIHRhcmdldCBvYmplY3Qgb3IgcHJvdG90eXBlLlxyXG5cdCAqIFxyXG5cdCAqIFx0XHRFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShNeUNsYXNzLnByb3RvdHlwZSk7IC8vIGFkZCB0byB0aGUgcHJvdG90eXBlIG9mIHRoZSBjbGFzc1xyXG5cdCAqIFx0XHRFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShteU9iamVjdCk7IC8vIGFkZCB0byBhIHNwZWNpZmljIGluc3RhbmNlXHJcblx0ICogXHJcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXHJcblx0ICogQHN0YXRpY1xyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdG8gaW5qZWN0IEV2ZW50RGlzcGF0Y2hlciBtZXRob2RzIGludG8uIFRoaXMgY2FuIGJlIGFuIGluc3RhbmNlIG9yIGFcclxuXHQgKiBwcm90b3R5cGUuXHJcblx0ICoqL1xyXG5cdEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplID0gZnVuY3Rpb24odGFyZ2V0KSB7XHJcblx0XHR0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lciA9IHAuYWRkRXZlbnRMaXN0ZW5lcjtcclxuXHRcdHRhcmdldC5vbiA9IHAub247XHJcblx0XHR0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHRhcmdldC5vZmYgPSAgcC5yZW1vdmVFdmVudExpc3RlbmVyO1xyXG5cdFx0dGFyZ2V0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gcC5yZW1vdmVBbGxFdmVudExpc3RlbmVycztcclxuXHRcdHRhcmdldC5oYXNFdmVudExpc3RlbmVyID0gcC5oYXNFdmVudExpc3RlbmVyO1xyXG5cdFx0dGFyZ2V0LmRpc3BhdGNoRXZlbnQgPSBwLmRpc3BhdGNoRXZlbnQ7XHJcblx0XHR0YXJnZXQuX2Rpc3BhdGNoRXZlbnQgPSBwLl9kaXNwYXRjaEV2ZW50O1xyXG5cdFx0dGFyZ2V0LndpbGxUcmlnZ2VyID0gcC53aWxsVHJpZ2dlcjtcclxuXHR9O1xyXG5cdFxyXG5cclxuLy8gcHVibGljIG1ldGhvZHM6XHJcblx0LyoqXHJcblx0ICogQWRkcyB0aGUgc3BlY2lmaWVkIGV2ZW50IGxpc3RlbmVyLiBOb3RlIHRoYXQgYWRkaW5nIG11bHRpcGxlIGxpc3RlbmVycyB0byB0aGUgc2FtZSBmdW5jdGlvbiB3aWxsIHJlc3VsdCBpblxyXG5cdCAqIG11bHRpcGxlIGNhbGxiYWNrcyBnZXR0aW5nIGZpcmVkLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljayk7XHJcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xyXG5cdCAqICAgICAgICAgLy8gQ2xpY2sgaGFwcGVuZWQuXHJcblx0ICogICAgICB9XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXJcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb24gfCBPYmplY3R9IGxpc3RlbmVyIEFuIG9iamVjdCB3aXRoIGEgaGFuZGxlRXZlbnQgbWV0aG9kLCBvciBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlblxyXG5cdCAqIHRoZSBldmVudCBpcyBkaXNwYXRjaGVkLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdIEZvciBldmVudHMgdGhhdCBidWJibGUsIGluZGljYXRlcyB3aGV0aGVyIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50IGluIHRoZSBjYXB0dXJlIG9yIGJ1YmJsaW5nL3RhcmdldCBwaGFzZS5cclxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbiB8IE9iamVjdH0gUmV0dXJucyB0aGUgbGlzdGVuZXIgZm9yIGNoYWluaW5nIG9yIGFzc2lnbm1lbnQuXHJcblx0ICoqL1xyXG5cdHAuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzO1xyXG5cdFx0aWYgKHVzZUNhcHR1cmUpIHtcclxuXHRcdFx0bGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnN8fHt9O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzfHx7fTtcclxuXHRcdH1cclxuXHRcdHZhciBhcnIgPSBsaXN0ZW5lcnNbdHlwZV07XHJcblx0XHRpZiAoYXJyKSB7IHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7IH1cclxuXHRcdGFyciA9IGxpc3RlbmVyc1t0eXBlXTsgLy8gcmVtb3ZlIG1heSBoYXZlIGRlbGV0ZWQgdGhlIGFycmF5XHJcblx0XHRpZiAoIWFycikgeyBsaXN0ZW5lcnNbdHlwZV0gPSBbbGlzdGVuZXJdOyAgfVxyXG5cdFx0ZWxzZSB7IGFyci5wdXNoKGxpc3RlbmVyKTsgfVxyXG5cdFx0cmV0dXJuIGxpc3RlbmVyO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogQSBzaG9ydGN1dCBtZXRob2QgZm9yIHVzaW5nIGFkZEV2ZW50TGlzdGVuZXIgdGhhdCBtYWtlcyBpdCBlYXNpZXIgdG8gc3BlY2lmeSBhbiBleGVjdXRpb24gc2NvcGUsIGhhdmUgYSBsaXN0ZW5lclxyXG5cdCAqIG9ubHkgcnVuIG9uY2UsIGFzc29jaWF0ZSBhcmJpdHJhcnkgZGF0YSB3aXRoIHRoZSBsaXN0ZW5lciwgYW5kIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblx0ICogXHJcblx0ICogVGhpcyBtZXRob2Qgd29ya3MgYnkgY3JlYXRpbmcgYW4gYW5vbnltb3VzIHdyYXBwZXIgZnVuY3Rpb24gYW5kIHN1YnNjcmliaW5nIGl0IHdpdGggYWRkRXZlbnRMaXN0ZW5lci5cclxuXHQgKiBUaGUgY3JlYXRlZCBhbm9ueW1vdXMgZnVuY3Rpb24gaXMgcmV0dXJuZWQgZm9yIHVzZSB3aXRoIC5yZW1vdmVFdmVudExpc3RlbmVyIChvciAub2ZmKS5cclxuXHQgKiBcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICogXHJcblx0ICogXHRcdHZhciBsaXN0ZW5lciA9IG15QnRuLm9uKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2ssIG51bGwsIGZhbHNlLCB7Y291bnQ6M30pO1xyXG5cdCAqIFx0XHRmdW5jdGlvbiBoYW5kbGVDbGljayhldnQsIGRhdGEpIHtcclxuXHQgKiBcdFx0XHRkYXRhLmNvdW50IC09IDE7XHJcblx0ICogXHRcdFx0Y29uc29sZS5sb2codGhpcyA9PSBteUJ0bik7IC8vIHRydWUgLSBzY29wZSBkZWZhdWx0cyB0byB0aGUgZGlzcGF0Y2hlclxyXG5cdCAqIFx0XHRcdGlmIChkYXRhLmNvdW50ID09IDApIHtcclxuXHQgKiBcdFx0XHRcdGFsZXJ0KFwiY2xpY2tlZCAzIHRpbWVzIVwiKTtcclxuXHQgKiBcdFx0XHRcdG15QnRuLm9mZihcImNsaWNrXCIsIGxpc3RlbmVyKTtcclxuXHQgKiBcdFx0XHRcdC8vIGFsdGVybmF0ZWx5OiBldnQucmVtb3ZlKCk7XHJcblx0ICogXHRcdFx0fVxyXG5cdCAqIFx0XHR9XHJcblx0ICogXHJcblx0ICogQG1ldGhvZCBvblxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbiB8IE9iamVjdH0gbGlzdGVuZXIgQW4gb2JqZWN0IHdpdGggYSBoYW5kbGVFdmVudCBtZXRob2QsIG9yIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuXHJcblx0ICogdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gVGhlIHNjb3BlIHRvIGV4ZWN1dGUgdGhlIGxpc3RlbmVyIGluLiBEZWZhdWx0cyB0byB0aGUgZGlzcGF0Y2hlci9jdXJyZW50VGFyZ2V0IGZvciBmdW5jdGlvbiBsaXN0ZW5lcnMsIGFuZCB0byB0aGUgbGlzdGVuZXIgaXRzZWxmIGZvciBvYmplY3QgbGlzdGVuZXJzIChpZS4gdXNpbmcgaGFuZGxlRXZlbnQpLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIElmIHRydWUsIHRoZSBsaXN0ZW5lciB3aWxsIHJlbW92ZSBpdHNlbGYgYWZ0ZXIgdGhlIGZpcnN0IHRpbWUgaXQgaXMgdHJpZ2dlcmVkLlxyXG5cdCAqIEBwYXJhbSB7Kn0gW2RhdGFdIEFyYml0cmFyeSBkYXRhIHRoYXQgd2lsbCBiZSBpbmNsdWRlZCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciB3aGVuIHRoZSBsaXN0ZW5lciBpcyBjYWxsZWQuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZT1mYWxzZV0gRm9yIGV2ZW50cyB0aGF0IGJ1YmJsZSwgaW5kaWNhdGVzIHdoZXRoZXIgdG8gbGlzdGVuIGZvciB0aGUgZXZlbnQgaW4gdGhlIGNhcHR1cmUgb3IgYnViYmxpbmcvdGFyZ2V0IHBoYXNlLlxyXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBhbm9ueW1vdXMgZnVuY3Rpb24gdGhhdCB3YXMgY3JlYXRlZCBhbmQgYXNzaWduZWQgYXMgdGhlIGxpc3RlbmVyLiBUaGlzIGlzIG5lZWRlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGxhdGVyIHVzaW5nIC5yZW1vdmVFdmVudExpc3RlbmVyLlxyXG5cdCAqKi9cclxuXHRwLm9uID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIHNjb3BlLCBvbmNlLCBkYXRhLCB1c2VDYXB0dXJlKSB7XHJcblx0XHRpZiAobGlzdGVuZXIuaGFuZGxlRXZlbnQpIHtcclxuXHRcdFx0c2NvcGUgPSBzY29wZXx8bGlzdGVuZXI7XHJcblx0XHRcdGxpc3RlbmVyID0gbGlzdGVuZXIuaGFuZGxlRXZlbnQ7XHJcblx0XHR9XHJcblx0XHRzY29wZSA9IHNjb3BlfHx0aGlzO1xyXG5cdFx0cmV0dXJuIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jdGlvbihldnQpIHtcclxuXHRcdFx0XHRsaXN0ZW5lci5jYWxsKHNjb3BlLCBldnQsIGRhdGEpO1xyXG5cdFx0XHRcdG9uY2UmJmV2dC5yZW1vdmUoKTtcclxuXHRcdFx0fSwgdXNlQ2FwdHVyZSk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGV2ZW50IGxpc3RlbmVyLlxyXG5cdCAqXHJcblx0ICogPGI+SW1wb3J0YW50IE5vdGU6PC9iPiB0aGF0IHlvdSBtdXN0IHBhc3MgdGhlIGV4YWN0IGZ1bmN0aW9uIHJlZmVyZW5jZSB1c2VkIHdoZW4gdGhlIGV2ZW50IHdhcyBhZGRlZC4gSWYgYSBwcm94eVxyXG5cdCAqIGZ1bmN0aW9uLCBvciBmdW5jdGlvbiBjbG9zdXJlIGlzIHVzZWQgYXMgdGhlIGNhbGxiYWNrLCB0aGUgcHJveHkvY2xvc3VyZSByZWZlcmVuY2UgbXVzdCBiZSB1c2VkIC0gYSBuZXcgcHJveHkgb3JcclxuXHQgKiBjbG9zdXJlIHdpbGwgbm90IHdvcmsuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrKTtcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lclxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbiB8IE9iamVjdH0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIG9yIG9iamVjdC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXHJcblx0ICoqL1xyXG5cdHAucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdXNlQ2FwdHVyZSA/IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgOiB0aGlzLl9saXN0ZW5lcnM7XHJcblx0XHRpZiAoIWxpc3RlbmVycykgeyByZXR1cm47IH1cclxuXHRcdHZhciBhcnIgPSBsaXN0ZW5lcnNbdHlwZV07XHJcblx0XHRpZiAoIWFycikgeyByZXR1cm47IH1cclxuXHRcdGZvciAodmFyIGk9MCxsPWFyci5sZW5ndGg7IGk8bDsgaSsrKSB7XHJcblx0XHRcdGlmIChhcnJbaV0gPT0gbGlzdGVuZXIpIHtcclxuXHRcdFx0XHRpZiAobD09MSkgeyBkZWxldGUobGlzdGVuZXJzW3R5cGVdKTsgfSAvLyBhbGxvd3MgZm9yIGZhc3RlciBjaGVja3MuXHJcblx0XHRcdFx0ZWxzZSB7IGFyci5zcGxpY2UoaSwxKTsgfVxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBBIHNob3J0Y3V0IHRvIHRoZSByZW1vdmVFdmVudExpc3RlbmVyIG1ldGhvZCwgd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFuZCByZXR1cm4gdmFsdWUuIFRoaXMgaXMgYSBjb21wYW5pb24gdG8gdGhlXHJcblx0ICogLm9uIG1ldGhvZC5cclxuXHQgKlxyXG5cdCAqIEBtZXRob2Qgb2ZmXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gb3Igb2JqZWN0LlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdIEZvciBldmVudHMgdGhhdCBidWJibGUsIGluZGljYXRlcyB3aGV0aGVyIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50IGluIHRoZSBjYXB0dXJlIG9yIGJ1YmJsaW5nL3RhcmdldCBwaGFzZS5cclxuXHQgKiovXHJcblx0cC5vZmYgPSBwLnJlbW92ZUV2ZW50TGlzdGVuZXI7XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBmb3IgdGhlIHNwZWNpZmllZCB0eXBlLCBvciBhbGwgbGlzdGVuZXJzIG9mIGFsbCB0eXBlcy5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnNcclxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoKTtcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gUmVtb3ZlIGFsbCBjbGljayBsaXN0ZW5lcnNcclxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoXCJjbGlja1wiKTtcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnNcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3R5cGVdIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuIElmIG9taXR0ZWQsIGFsbCBsaXN0ZW5lcnMgZm9yIGFsbCB0eXBlcyB3aWxsIGJlIHJlbW92ZWQuXHJcblx0ICoqL1xyXG5cdHAucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XHJcblx0XHRpZiAoIXR5cGUpIHsgdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA9IG51bGw7IH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRpZiAodGhpcy5fbGlzdGVuZXJzKSB7IGRlbGV0ZSh0aGlzLl9saXN0ZW5lcnNbdHlwZV0pOyB9XHJcblx0XHRcdGlmICh0aGlzLl9jYXB0dXJlTGlzdGVuZXJzKSB7IGRlbGV0ZSh0aGlzLl9jYXB0dXJlTGlzdGVuZXJzW3R5cGVdKTsgfVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIERpc3BhdGNoZXMgdGhlIHNwZWNpZmllZCBldmVudCB0byBhbGwgbGlzdGVuZXJzLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICAvLyBVc2UgYSBzdHJpbmcgZXZlbnRcclxuXHQgKiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpO1xyXG5cdCAqXHJcblx0ICogICAgICAvLyBVc2UgYW4gRXZlbnQgaW5zdGFuY2VcclxuXHQgKiAgICAgIHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcInByb2dyZXNzXCIpO1xyXG5cdCAqICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgZGlzcGF0Y2hFdmVudFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0IHwgU3RyaW5nIHwgRXZlbnR9IGV2ZW50T2JqIEFuIG9iamVjdCB3aXRoIGEgXCJ0eXBlXCIgcHJvcGVydHksIG9yIGEgc3RyaW5nIHR5cGUuXHJcblx0ICogV2hpbGUgYSBnZW5lcmljIG9iamVjdCB3aWxsIHdvcmssIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBhIENyZWF0ZUpTIEV2ZW50IGluc3RhbmNlLiBJZiBhIHN0cmluZyBpcyB1c2VkLFxyXG5cdCAqIGRpc3BhdGNoRXZlbnQgd2lsbCBjb25zdHJ1Y3QgYW4gRXZlbnQgaW5zdGFuY2Ugd2l0aCB0aGUgc3BlY2lmaWVkIHR5cGUuXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0aGUgdmFsdWUgb2YgZXZlbnRPYmouZGVmYXVsdFByZXZlbnRlZC5cclxuXHQgKiovXHJcblx0cC5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnRPYmopIHtcclxuXHRcdGlmICh0eXBlb2YgZXZlbnRPYmogPT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHQvLyB3b24ndCBidWJibGUsIHNvIHNraXAgZXZlcnl0aGluZyBpZiB0aGVyZSdzIG5vIGxpc3RlbmVyczpcclxuXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcclxuXHRcdFx0aWYgKCFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVyc1tldmVudE9ial0pIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdGV2ZW50T2JqID0gbmV3IGNyZWF0ZWpzLkV2ZW50KGV2ZW50T2JqKTtcclxuXHRcdH0gZWxzZSBpZiAoZXZlbnRPYmoudGFyZ2V0ICYmIGV2ZW50T2JqLmNsb25lKSB7XHJcblx0XHRcdC8vIHJlZGlzcGF0Y2hpbmcgYW4gYWN0aXZlIGV2ZW50IG9iamVjdCwgc28gY2xvbmUgaXQ6XHJcblx0XHRcdGV2ZW50T2JqID0gZXZlbnRPYmouY2xvbmUoKTtcclxuXHRcdH1cclxuXHRcdHRyeSB7IGV2ZW50T2JqLnRhcmdldCA9IHRoaXM7IH0gY2F0Y2ggKGUpIHt9IC8vIHRyeS9jYXRjaCBhbGxvd3MgcmVkaXNwYXRjaGluZyBvZiBuYXRpdmUgZXZlbnRzXHJcblxyXG5cdFx0aWYgKCFldmVudE9iai5idWJibGVzIHx8ICF0aGlzLnBhcmVudCkge1xyXG5cdFx0XHR0aGlzLl9kaXNwYXRjaEV2ZW50KGV2ZW50T2JqLCAyKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciB0b3A9dGhpcywgbGlzdD1bdG9wXTtcclxuXHRcdFx0d2hpbGUgKHRvcC5wYXJlbnQpIHsgbGlzdC5wdXNoKHRvcCA9IHRvcC5wYXJlbnQpOyB9XHJcblx0XHRcdHZhciBpLCBsPWxpc3QubGVuZ3RoO1xyXG5cclxuXHRcdFx0Ly8gY2FwdHVyZSAmIGF0VGFyZ2V0XHJcblx0XHRcdGZvciAoaT1sLTE7IGk+PTAgJiYgIWV2ZW50T2JqLnByb3BhZ2F0aW9uU3RvcHBlZDsgaS0tKSB7XHJcblx0XHRcdFx0bGlzdFtpXS5fZGlzcGF0Y2hFdmVudChldmVudE9iaiwgMSsoaT09MCkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGJ1YmJsaW5nXHJcblx0XHRcdGZvciAoaT0xOyBpPGwgJiYgIWV2ZW50T2JqLnByb3BhZ2F0aW9uU3RvcHBlZDsgaSsrKSB7XHJcblx0XHRcdFx0bGlzdFtpXS5fZGlzcGF0Y2hFdmVudChldmVudE9iaiwgMyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBldmVudE9iai5kZWZhdWx0UHJldmVudGVkO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudCB0eXBlLlxyXG5cdCAqIEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lclxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cclxuXHQgKiovXHJcblx0cC5oYXNFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycywgY2FwdHVyZUxpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnM7XHJcblx0XHRyZXR1cm4gISEoKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnNbdHlwZV0pIHx8IChjYXB0dXJlTGlzdGVuZXJzICYmIGNhcHR1cmVMaXN0ZW5lcnNbdHlwZV0pKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudCB0eXBlIG9uIHRoaXMgb2JqZWN0IG9yIGFueSBvZiBpdHNcclxuXHQgKiBhbmNlc3RvcnMgKHBhcmVudCwgcGFyZW50J3MgcGFyZW50LCBldGMpLiBBIHJldHVybiB2YWx1ZSBvZiB0cnVlIGluZGljYXRlcyB0aGF0IGlmIGEgYnViYmxpbmcgZXZlbnQgb2YgdGhlXHJcblx0ICogc3BlY2lmaWVkIHR5cGUgaXMgZGlzcGF0Y2hlZCBmcm9tIHRoaXMgb2JqZWN0LCBpdCB3aWxsIHRyaWdnZXIgYXQgbGVhc3Qgb25lIGxpc3RlbmVyLlxyXG5cdCAqIFxyXG5cdCAqIFRoaXMgaXMgc2ltaWxhciB0byB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvaGFzRXZlbnRMaXN0ZW5lclwifX17ey9jcm9zc0xpbmt9fSwgYnV0IGl0IHNlYXJjaGVzIHRoZSBlbnRpcmVcclxuXHQgKiBldmVudCBmbG93IGZvciBhIGxpc3RlbmVyLCBub3QganVzdCB0aGlzIG9iamVjdC5cclxuXHQgKiBAbWV0aG9kIHdpbGxUcmlnZ2VyXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXHJcblx0ICoqL1xyXG5cdHAud2lsbFRyaWdnZXIgPSBmdW5jdGlvbih0eXBlKSB7XHJcblx0XHR2YXIgbyA9IHRoaXM7XHJcblx0XHR3aGlsZSAobykge1xyXG5cdFx0XHRpZiAoby5oYXNFdmVudExpc3RlbmVyKHR5cGUpKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcdG8gPSBvLnBhcmVudDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXHJcblx0ICoqL1xyXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBcIltFdmVudERpc3BhdGNoZXJdXCI7XHJcblx0fTtcclxuXHJcblxyXG4vLyBwcml2YXRlIG1ldGhvZHM6XHJcblx0LyoqXHJcblx0ICogQG1ldGhvZCBfZGlzcGF0Y2hFdmVudFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0IHwgU3RyaW5nIHwgRXZlbnR9IGV2ZW50T2JqXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50UGhhc2VcclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICoqL1xyXG5cdHAuX2Rpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudE9iaiwgZXZlbnRQaGFzZSkge1xyXG5cdFx0dmFyIGwsIGxpc3RlbmVycyA9IChldmVudFBoYXNlPT0xKSA/IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgOiB0aGlzLl9saXN0ZW5lcnM7XHJcblx0XHRpZiAoZXZlbnRPYmogJiYgbGlzdGVuZXJzKSB7XHJcblx0XHRcdHZhciBhcnIgPSBsaXN0ZW5lcnNbZXZlbnRPYmoudHlwZV07XHJcblx0XHRcdGlmICghYXJyfHwhKGw9YXJyLmxlbmd0aCkpIHsgcmV0dXJuOyB9XHJcblx0XHRcdHRyeSB7IGV2ZW50T2JqLmN1cnJlbnRUYXJnZXQgPSB0aGlzOyB9IGNhdGNoIChlKSB7fVxyXG5cdFx0XHR0cnkgeyBldmVudE9iai5ldmVudFBoYXNlID0gZXZlbnRQaGFzZTsgfSBjYXRjaCAoZSkge31cclxuXHRcdFx0ZXZlbnRPYmoucmVtb3ZlZCA9IGZhbHNlO1xyXG5cdFx0XHRcclxuXHRcdFx0YXJyID0gYXJyLnNsaWNlKCk7IC8vIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGl0ZW1zIGJlaW5nIHJlbW92ZWQgb3IgYWRkZWQgZHVyaW5nIHRoZSBkaXNwYXRjaFxyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bCAmJiAhZXZlbnRPYmouaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgbyA9IGFycltpXTtcclxuXHRcdFx0XHRpZiAoby5oYW5kbGVFdmVudCkgeyBvLmhhbmRsZUV2ZW50KGV2ZW50T2JqKTsgfVxyXG5cdFx0XHRcdGVsc2UgeyBvKGV2ZW50T2JqKTsgfVxyXG5cdFx0XHRcdGlmIChldmVudE9iai5yZW1vdmVkKSB7XHJcblx0XHRcdFx0XHR0aGlzLm9mZihldmVudE9iai50eXBlLCBvLCBldmVudFBoYXNlPT0xKTtcclxuXHRcdFx0XHRcdGV2ZW50T2JqLnJlbW92ZWQgPSBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHJcblx0Y3JlYXRlanMuRXZlbnREaXNwYXRjaGVyID0gRXZlbnREaXNwYXRjaGVyO1xyXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVGlja2VyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBUaGUgVGlja2VyIHByb3ZpZGVzIGEgY2VudHJhbGl6ZWQgdGljayBvciBoZWFydGJlYXQgYnJvYWRjYXN0IGF0IGEgc2V0IGludGVydmFsLiBMaXN0ZW5lcnMgY2FuIHN1YnNjcmliZSB0byB0aGUgdGlja1xuXHQgKiBldmVudCB0byBiZSBub3RpZmllZCB3aGVuIGEgc2V0IHRpbWUgaW50ZXJ2YWwgaGFzIGVsYXBzZWQuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgaW50ZXJ2YWwgdGhhdCB0aGUgdGljayBldmVudCBpcyBjYWxsZWQgaXMgYSB0YXJnZXQgaW50ZXJ2YWwsIGFuZCBtYXkgYmUgYnJvYWRjYXN0IGF0IGEgc2xvd2VyIGludGVydmFsXG5cdCAqIHdoZW4gdW5kZXIgaGlnaCBDUFUgbG9hZC4gVGhlIFRpY2tlciBjbGFzcyB1c2VzIGEgc3RhdGljIGludGVyZmFjZSAoZXguIGBUaWNrZXIuZnJhbWVyYXRlID0gMzA7YCkgYW5kXG5cdCAqIGNhbiBub3QgYmUgaW5zdGFudGlhdGVkLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIGhhbmRsZVRpY2spO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZVRpY2soZXZlbnQpIHtcblx0ICogICAgICAgICAgLy8gQWN0aW9ucyBjYXJyaWVkIG91dCBlYWNoIHRpY2sgKGFrYSBmcmFtZSlcblx0ICogICAgICAgICAgaWYgKCFldmVudC5wYXVzZWQpIHtcblx0ICogICAgICAgICAgICAgIC8vIEFjdGlvbnMgY2FycmllZCBvdXQgd2hlbiB0aGUgVGlja2VyIGlzIG5vdCBwYXVzZWQuXG5cdCAqICAgICAgICAgIH1cblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBjbGFzcyBUaWNrZXJcblx0ICogQHVzZXMgRXZlbnREaXNwYXRjaGVyXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRmdW5jdGlvbiBUaWNrZXIoKSB7XG5cdFx0dGhyb3cgXCJUaWNrZXIgY2Fubm90IGJlIGluc3RhbnRpYXRlZC5cIjtcblx0fVxuXG5cbi8vIGNvbnN0YW50czpcblx0LyoqXG5cdCAqIEluIHRoaXMgbW9kZSwgVGlja2VyIHVzZXMgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBBUEksIGJ1dCBhdHRlbXB0cyB0byBzeW5jaCB0aGUgdGlja3MgdG8gdGFyZ2V0IGZyYW1lcmF0ZS4gSXRcblx0ICogdXNlcyBhIHNpbXBsZSBoZXVyaXN0aWMgdGhhdCBjb21wYXJlcyB0aGUgdGltZSBvZiB0aGUgUkFGIHJldHVybiB0byB0aGUgdGFyZ2V0IHRpbWUgZm9yIHRoZSBjdXJyZW50IGZyYW1lIGFuZFxuXHQgKiBkaXNwYXRjaGVzIHRoZSB0aWNrIHdoZW4gdGhlIHRpbWUgaXMgd2l0aGluIGEgY2VydGFpbiB0aHJlc2hvbGQuXG5cdCAqXG5cdCAqIFRoaXMgbW9kZSBoYXMgYSBoaWdoZXIgdmFyaWFuY2UgZm9yIHRpbWUgYmV0d2VlbiBmcmFtZXMgdGhhbiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvVElNRU9VVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogYnV0IGRvZXMgbm90IHJlcXVpcmUgdGhhdCBjb250ZW50IGJlIHRpbWUgYmFzZWQgYXMgd2l0aCB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvUkFGOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHdoaWxlXG5cdCAqIGdhaW5pbmcgdGhlIGJlbmVmaXRzIG9mIHRoYXQgQVBJIChzY3JlZW4gc3luY2gsIGJhY2tncm91bmQgdGhyb3R0bGluZykuXG5cdCAqXG5cdCAqIFZhcmlhbmNlIGlzIHVzdWFsbHkgbG93ZXN0IGZvciBmcmFtZXJhdGVzIHRoYXQgYXJlIGEgZGl2aXNvciBvZiB0aGUgUkFGIGZyZXF1ZW5jeS4gVGhpcyBpcyB1c3VhbGx5IDYwLCBzb1xuXHQgKiBmcmFtZXJhdGVzIG9mIDEwLCAxMiwgMTUsIDIwLCBhbmQgMzAgd29yayB3ZWxsLlxuXHQgKlxuXHQgKiBGYWxscyBiYWNrIHRvIHt7I2Nyb3NzTGluayBcIlRpY2tlci9USU1FT1VUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlmIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgQVBJIGlzIG5vdFxuXHQgKiBzdXBwb3J0ZWQuXG5cdCAqIEBwcm9wZXJ0eSBSQUZfU1lOQ0hFRFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IFwic3luY2hlZFwiXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdFRpY2tlci5SQUZfU1lOQ0hFRCA9IFwic3luY2hlZFwiO1xuXG5cdC8qKlxuXHQgKiBJbiB0aGlzIG1vZGUsIFRpY2tlciBwYXNzZXMgdGhyb3VnaCB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGhlYXJ0YmVhdCwgaWdub3JpbmcgdGhlIHRhcmdldCBmcmFtZXJhdGUgY29tcGxldGVseS5cblx0ICogQmVjYXVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZnJlcXVlbmN5IGlzIG5vdCBkZXRlcm1pbmlzdGljLCBhbnkgY29udGVudCB1c2luZyB0aGlzIG1vZGUgc2hvdWxkIGJlIHRpbWUgYmFzZWQuXG5cdCAqIFlvdSBjYW4gbGV2ZXJhZ2Uge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2dldFRpbWVcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBvYmplY3QncyBcImRlbHRhXCIgcHJvcGVydGllcyB0byBtYWtlIHRoaXMgZWFzaWVyLlxuXHQgKlxuXHQgKiBGYWxscyBiYWNrIG9uIHt7I2Nyb3NzTGluayBcIlRpY2tlci9USU1FT1VUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGlmIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgQVBJIGlzIG5vdFxuXHQgKiBzdXBwb3J0ZWQuXG5cdCAqIEBwcm9wZXJ0eSBSQUZcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBcInJhZlwiXG5cdCAqIEByZWFkb25seVxuXHQgKiovXG5cdFRpY2tlci5SQUYgPSBcInJhZlwiO1xuXG5cdC8qKlxuXHQgKiBJbiB0aGlzIG1vZGUsIFRpY2tlciB1c2VzIHRoZSBzZXRUaW1lb3V0IEFQSS4gVGhpcyBwcm92aWRlcyBwcmVkaWN0YWJsZSwgYWRhcHRpdmUgZnJhbWUgdGltaW5nLCBidXQgZG9lcyBub3Rcblx0ICogcHJvdmlkZSB0aGUgYmVuZWZpdHMgb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIChzY3JlZW4gc3luY2gsIGJhY2tncm91bmQgdGhyb3R0bGluZykuXG5cdCAqIEBwcm9wZXJ0eSBUSU1FT1VUXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgXCJ0aW1lb3V0XCJcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0VGlja2VyLlRJTUVPVVQgPSBcInRpbWVvdXRcIjtcblxuXG4vLyBzdGF0aWMgZXZlbnRzOlxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCBlYWNoIHRpY2suIFRoZSBldmVudCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gZWFjaCBsaXN0ZW5lciBldmVuIHdoZW4gdGhlIFRpY2tlciBoYXMgYmVlbiBwYXVzZWQgdXNpbmdcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3NldFBhdXNlZFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLlRpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBoYW5kbGVUaWNrKTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVUaWNrKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKFwiUGF1c2VkOlwiLCBldmVudC5wYXVzZWQsIGV2ZW50LmRlbHRhKTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBldmVudCB0aWNrXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBwYXVzZWQgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRpY2tlciBpcyBjdXJyZW50bHkgcGF1c2VkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgVGhlIHRpbWUgZWxhcHNlZCBpbiBtcyBzaW5jZSB0aGUgbGFzdCB0aWNrLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdGltZSBUaGUgdG90YWwgdGltZSBpbiBtcyBzaW5jZSBUaWNrZXIgd2FzIGluaXRpYWxpemVkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcnVuVGltZSBUaGUgdG90YWwgdGltZSBpbiBtcyB0aGF0IFRpY2tlciB3YXMgbm90IHBhdXNlZCBzaW5jZSBpdCB3YXMgaW5pdGlhbGl6ZWQuIEZvciBleGFtcGxlLFxuXHQgKiBcdHlvdSBjb3VsZCBkZXRlcm1pbmUgdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgdGhlIFRpY2tlciBoYXMgYmVlbiBwYXVzZWQgc2luY2UgaW5pdGlhbGl6YXRpb24gd2l0aCBgdGltZS1ydW5UaW1lYC5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cbi8vIHB1YmxpYyBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIERlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aW1pbmdNb2RlXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uIElmIHRydWUsIHRpbWluZ01vZGUgd2lsbFxuXHQgKiB1c2Uge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1JBRl9TWU5DSEVEXCJ9fXt7L2Nyb3NzTGlua319IGJ5IGRlZmF1bHQuXG5cdCAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aW1pbmdNb2RlXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAcHJvcGVydHkgdXNlUkFGXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqKi9cblx0VGlja2VyLnVzZVJBRiA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpZXMgdGhlIHRpbWluZyBhcGkgKHNldFRpbWVvdXQgb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSBhbmQgbW9kZSB0byB1c2UuIFNlZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvVElNRU9VVFwifX17ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1JBRlwifX17ey9jcm9zc0xpbmt9fSwgYW5kXG5cdCAqIHt7I2Nyb3NzTGluayBcIlRpY2tlci9SQUZfU1lOQ0hFRFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9kZSBkZXRhaWxzLlxuXHQgKiBAcHJvcGVydHkgdGltaW5nTW9kZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IFRpY2tlci5USU1FT1VUXG5cdCAqKi9cblx0VGlja2VyLnRpbWluZ01vZGUgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpZXMgYSBtYXhpbXVtIHZhbHVlIGZvciB0aGUgZGVsdGEgcHJvcGVydHkgaW4gdGhlIHRpY2sgZXZlbnQgb2JqZWN0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGJ1aWxkaW5nIHRpbWVcblx0ICogYmFzZWQgYW5pbWF0aW9ucyBhbmQgc3lzdGVtcyB0byBwcmV2ZW50IGlzc3VlcyBjYXVzZWQgYnkgbGFyZ2UgdGltZSBnYXBzIGNhdXNlZCBieSBiYWNrZ3JvdW5kIHRhYnMsIHN5c3RlbSBzbGVlcCxcblx0ICogYWxlcnQgZGlhbG9ncywgb3Igb3RoZXIgYmxvY2tpbmcgcm91dGluZXMuIERvdWJsZSB0aGUgZXhwZWN0ZWQgZnJhbWUgZHVyYXRpb24gaXMgb2Z0ZW4gYW4gZWZmZWN0aXZlIHZhbHVlXG5cdCAqIChleC4gbWF4RGVsdGE9NTAgd2hlbiBydW5uaW5nIGF0IDQwZnBzKS5cblx0ICogXG5cdCAqIFRoaXMgZG9lcyBub3QgaW1wYWN0IGFueSBvdGhlciB2YWx1ZXMgKGV4LiB0aW1lLCBydW5UaW1lLCBldGMpLCBzbyB5b3UgbWF5IGV4cGVyaWVuY2UgaXNzdWVzIGlmIHlvdSBlbmFibGUgbWF4RGVsdGFcblx0ICogd2hlbiB1c2luZyBib3RoIGRlbHRhIGFuZCBvdGhlciB2YWx1ZXMuXG5cdCAqIFxuXHQgKiBJZiAwLCB0aGVyZSBpcyBubyBtYXhpbXVtLlxuXHQgKiBAcHJvcGVydHkgbWF4RGVsdGFcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAwXG5cdCAqL1xuXHRUaWNrZXIubWF4RGVsdGEgPSAwO1xuXHRcblx0LyoqXG5cdCAqIFdoZW4gdGhlIHRpY2tlciBpcyBwYXVzZWQsIGFsbCBsaXN0ZW5lcnMgd2lsbCBzdGlsbCByZWNlaXZlIGEgdGljayBldmVudCwgYnV0IHRoZSA8Y29kZT5wYXVzZWQ8L2NvZGU+IHByb3BlcnR5XG5cdCAqIG9mIHRoZSBldmVudCB3aWxsIGJlIGB0cnVlYC4gQWxzbywgd2hpbGUgcGF1c2VkIHRoZSBgcnVuVGltZWAgd2lsbCBub3QgaW5jcmVhc2UuIFNlZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fSxcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2dldFRpbWVcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvZ2V0RXZlbnRUaW1lXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlXG5cdCAqIGluZm8uXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgaGFuZGxlVGljayk7XG5cdCAqICAgICAgY3JlYXRlanMuVGlja2VyLnBhdXNlZCA9IHRydWU7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlVGljayhldmVudCkge1xuXHQgKiAgICAgICAgICBjb25zb2xlLmxvZyhldmVudC5wYXVzZWQsXG5cdCAqICAgICAgICAgIFx0Y3JlYXRlanMuVGlja2VyLmdldFRpbWUoZmFsc2UpLFxuXHQgKiAgICAgICAgICBcdGNyZWF0ZWpzLlRpY2tlci5nZXRUaW1lKHRydWUpKTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBwYXVzZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICoqL1xuXHRUaWNrZXIucGF1c2VkID0gZmFsc2U7XG5cblxuLy8gbWl4LWluczpcblx0Ly8gRXZlbnREaXNwYXRjaGVyIG1ldGhvZHM6XG5cdFRpY2tlci5yZW1vdmVFdmVudExpc3RlbmVyID0gbnVsbDtcblx0VGlja2VyLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gbnVsbDtcblx0VGlja2VyLmRpc3BhdGNoRXZlbnQgPSBudWxsO1xuXHRUaWNrZXIuaGFzRXZlbnRMaXN0ZW5lciA9IG51bGw7XG5cdFRpY2tlci5fbGlzdGVuZXJzID0gbnVsbDtcblx0Y3JlYXRlanMuRXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUoVGlja2VyKTsgLy8gaW5qZWN0IEV2ZW50RGlzcGF0Y2hlciBtZXRob2RzLlxuXHRUaWNrZXIuX2FkZEV2ZW50TGlzdGVuZXIgPSBUaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcjtcblx0VGlja2VyLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcblx0XHQhVGlja2VyLl9pbml0ZWQmJlRpY2tlci5pbml0KCk7XG5cdFx0cmV0dXJuIFRpY2tlci5fYWRkRXZlbnRMaXN0ZW5lci5hcHBseShUaWNrZXIsIGFyZ3VtZW50cyk7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfaW5pdGVkXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX2luaXRlZCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3N0YXJ0VGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3N0YXJ0VGltZSA9IDA7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfcGF1c2VkVGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3BhdXNlZFRpbWU9MDtcblxuXHQvKipcblx0ICogVGhlIG51bWJlciBvZiB0aWNrcyB0aGF0IGhhdmUgcGFzc2VkXG5cdCAqIEBwcm9wZXJ0eSBfdGlja3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aWNrcyA9IDA7XG5cblx0LyoqXG5cdCAqIFRoZSBudW1iZXIgb2YgdGlja3MgdGhhdCBoYXZlIHBhc3NlZCB3aGlsZSBUaWNrZXIgaGFzIGJlZW4gcGF1c2VkXG5cdCAqIEBwcm9wZXJ0eSBfcGF1c2VkVGlja3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9wYXVzZWRUaWNrcyA9IDA7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfaW50ZXJ2YWxcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9pbnRlcnZhbCA9IDUwO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX2xhc3RUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fbGFzdFRpbWUgPSAwO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX3RpbWVzXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aW1lcyA9IG51bGw7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfdGlja1RpbWVzXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aWNrVGltZXMgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBTdG9yZXMgdGhlIHRpbWVvdXQgb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGlkLlxuXHQgKiBAcHJvcGVydHkgX3RpbWVySWRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aW1lcklkID0gbnVsbDtcblx0XG5cdC8qKlxuXHQgKiBUcnVlIGlmIGN1cnJlbnRseSB1c2luZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGZhbHNlIGlmIHVzaW5nIHNldFRpbWVvdXQuIFRoaXMgbWF5IGJlIGRpZmZlcmVudCB0aGFuIHRpbWluZ01vZGVcblx0ICogaWYgdGhhdCBwcm9wZXJ0eSBjaGFuZ2VkIGFuZCBhIHRpY2sgaGFzbid0IGZpcmVkLlxuXHQgKiBAcHJvcGVydHkgX3JhZlxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9yYWYgPSB0cnVlO1xuXHRcblxuLy8gc3RhdGljIGdldHRlciAvIHNldHRlcnM6XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9pbnRlcnZhbDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIHNldEludGVydmFsXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGludGVydmFsXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLnNldEludGVydmFsID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcblx0XHRUaWNrZXIuX2ludGVydmFsID0gaW50ZXJ2YWw7XG5cdFx0aWYgKCFUaWNrZXIuX2luaXRlZCkgeyByZXR1cm47IH1cblx0XHRUaWNrZXIuX3NldHVwVGljaygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9mcmFtZXJhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXRJbnRlcnZhbFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuZ2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gVGlja2VyLl9pbnRlcnZhbDtcblx0fTtcblxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvZnJhbWVyYXRlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2Qgc2V0RlBTXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLnNldEZQUyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0VGlja2VyLnNldEludGVydmFsKDEwMDAvdmFsdWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9pbnRlcnZhbDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldEZQU1xuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuZ2V0RlBTID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIDEwMDAvVGlja2VyLl9pbnRlcnZhbDtcblx0fTtcblxuXHQvKipcblx0ICogSW5kaWNhdGVzIHRoZSB0YXJnZXQgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSBiZXR3ZWVuIHRpY2tzLiBEZWZhdWx0IGlzIDUwICgyMCBGUFMpLlxuXHQgKiBOb3RlIHRoYXQgYWN0dWFsIHRpbWUgYmV0d2VlbiB0aWNrcyBtYXkgYmUgbW9yZSB0aGFuIHNwZWNpZmllZCBkZXBlbmRpbmcgb24gQ1BVIGxvYWQuXG5cdCAqIFRoaXMgcHJvcGVydHkgaXMgaWdub3JlZCBpZiB0aGUgdGlja2VyIGlzIHVzaW5nIHRoZSBgUkFGYCB0aW1pbmcgbW9kZS5cblx0ICogQHByb3BlcnR5IGludGVydmFsXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICoqL1xuXHQgXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgdGhlIHRhcmdldCBmcmFtZSByYXRlIGluIGZyYW1lcyBwZXIgc2Vjb25kIChGUFMpLiBFZmZlY3RpdmVseSBqdXN0IGEgc2hvcnRjdXQgdG8gYGludGVydmFsYCwgd2hlcmVcblx0ICogYGZyYW1lcmF0ZSA9PSAxMDAwL2ludGVydmFsYC5cblx0ICogQHByb3BlcnR5IGZyYW1lcmF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqKi9cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhUaWNrZXIsIHtcblx0XHRcdGludGVydmFsOiB7IGdldDogVGlja2VyLmdldEludGVydmFsLCBzZXQ6IFRpY2tlci5zZXRJbnRlcnZhbCB9LFxuXHRcdFx0ZnJhbWVyYXRlOiB7IGdldDogVGlja2VyLmdldEZQUywgc2V0OiBUaWNrZXIuc2V0RlBTIH1cblx0XHR9KTtcblx0fSBjYXRjaCAoZSkgeyBjb25zb2xlLmxvZyhlKTsgfVxuXG5cbi8vIHB1YmxpYyBzdGF0aWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFN0YXJ0cyB0aGUgdGljay4gVGhpcyBpcyBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBmaXJzdCBsaXN0ZW5lciBpcyBhZGRlZC5cblx0ICogQG1ldGhvZCBpbml0XG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUaWNrZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChUaWNrZXIuX2luaXRlZCkgeyByZXR1cm47IH1cblx0XHRUaWNrZXIuX2luaXRlZCA9IHRydWU7XG5cdFx0VGlja2VyLl90aW1lcyA9IFtdO1xuXHRcdFRpY2tlci5fdGlja1RpbWVzID0gW107XG5cdFx0VGlja2VyLl9zdGFydFRpbWUgPSBUaWNrZXIuX2dldFRpbWUoKTtcblx0XHRUaWNrZXIuX3RpbWVzLnB1c2goVGlja2VyLl9sYXN0VGltZSA9IDApO1xuXHRcdFRpY2tlci5pbnRlcnZhbCA9IFRpY2tlci5faW50ZXJ2YWw7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU3RvcHMgdGhlIFRpY2tlciBhbmQgcmVtb3ZlcyBhbGwgbGlzdGVuZXJzLiBVc2UgaW5pdCgpIHRvIHJlc3RhcnQgdGhlIFRpY2tlci5cblx0ICogQG1ldGhvZCByZXNldFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VGlja2VyLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKFRpY2tlci5fcmFmKSB7XG5cdFx0XHR2YXIgZiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5vQ2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cdFx0XHRmJiZmKFRpY2tlci5fdGltZXJJZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNsZWFyVGltZW91dChUaWNrZXIuX3RpbWVySWQpO1xuXHRcdH1cblx0XHRUaWNrZXIucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoXCJ0aWNrXCIpO1xuXHRcdFRpY2tlci5fdGltZXJJZCA9IFRpY2tlci5fdGltZXMgPSBUaWNrZXIuX3RpY2tUaW1lcyA9IG51bGw7XG5cdFx0VGlja2VyLl9zdGFydFRpbWUgPSBUaWNrZXIuX2xhc3RUaW1lID0gVGlja2VyLl90aWNrcyA9IDA7XG5cdFx0VGlja2VyLl9pbml0ZWQgPSBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYXZlcmFnZSB0aW1lIHNwZW50IHdpdGhpbiBhIHRpY2suIFRoaXMgY2FuIHZhcnkgc2lnbmlmaWNhbnRseSBmcm9tIHRoZSB2YWx1ZSBwcm92aWRlZCBieSBnZXRNZWFzdXJlZEZQU1xuXHQgKiBiZWNhdXNlIGl0IG9ubHkgbWVhc3VyZXMgdGhlIHRpbWUgc3BlbnQgd2l0aGluIHRoZSB0aWNrIGV4ZWN1dGlvbiBzdGFjay4gXG5cdCAqIFxuXHQgKiBFeGFtcGxlIDE6IFdpdGggYSB0YXJnZXQgRlBTIG9mIDIwLCBnZXRNZWFzdXJlZEZQUygpIHJldHVybnMgMjBmcHMsIHdoaWNoIGluZGljYXRlcyBhbiBhdmVyYWdlIG9mIDUwbXMgYmV0d2VlbiBcblx0ICogdGhlIGVuZCBvZiBvbmUgdGljayBhbmQgdGhlIGVuZCBvZiB0aGUgbmV4dC4gSG93ZXZlciwgZ2V0TWVhc3VyZWRUaWNrVGltZSgpIHJldHVybnMgMTVtcy4gVGhpcyBpbmRpY2F0ZXMgdGhhdCBcblx0ICogdGhlcmUgbWF5IGJlIHVwIHRvIDM1bXMgb2YgXCJpZGxlXCIgdGltZSBiZXR3ZWVuIHRoZSBlbmQgb2Ygb25lIHRpY2sgYW5kIHRoZSBzdGFydCBvZiB0aGUgbmV4dC5cblx0ICpcblx0ICogRXhhbXBsZSAyOiBXaXRoIGEgdGFyZ2V0IEZQUyBvZiAzMCwgZ2V0RlBTKCkgcmV0dXJucyAxMGZwcywgd2hpY2ggaW5kaWNhdGVzIGFuIGF2ZXJhZ2Ugb2YgMTAwbXMgYmV0d2VlbiB0aGUgZW5kIG9mXG5cdCAqIG9uZSB0aWNrIGFuZCB0aGUgZW5kIG9mIHRoZSBuZXh0LiBIb3dldmVyLCBnZXRNZWFzdXJlZFRpY2tUaW1lKCkgcmV0dXJucyAyMG1zLiBUaGlzIHdvdWxkIGluZGljYXRlIHRoYXQgc29tZXRoaW5nXG5cdCAqIG90aGVyIHRoYW4gdGhlIHRpY2sgaXMgdXNpbmcgfjgwbXMgKGFub3RoZXIgc2NyaXB0LCBET00gcmVuZGVyaW5nLCBldGMpLlxuXHQgKiBAbWV0aG9kIGdldE1lYXN1cmVkVGlja1RpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RpY2tzXSBUaGUgbnVtYmVyIG9mIHByZXZpb3VzIHRpY2tzIG92ZXIgd2hpY2ggdG8gbWVhc3VyZSB0aGUgYXZlcmFnZSB0aW1lIHNwZW50IGluIGEgdGljay5cblx0ICogRGVmYXVsdHMgdG8gdGhlIG51bWJlciBvZiB0aWNrcyBwZXIgc2Vjb25kLiBUbyBnZXQgb25seSB0aGUgbGFzdCB0aWNrJ3MgdGltZSwgcGFzcyBpbiAxLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBhdmVyYWdlIHRpbWUgc3BlbnQgaW4gYSB0aWNrIGluIG1pbGxpc2Vjb25kcy5cblx0ICoqL1xuXHRUaWNrZXIuZ2V0TWVhc3VyZWRUaWNrVGltZSA9IGZ1bmN0aW9uKHRpY2tzKSB7XG5cdFx0dmFyIHR0bD0wLCB0aW1lcz1UaWNrZXIuX3RpY2tUaW1lcztcblx0XHRpZiAoIXRpbWVzIHx8IHRpbWVzLmxlbmd0aCA8IDEpIHsgcmV0dXJuIC0xOyB9XG5cblx0XHQvLyBieSBkZWZhdWx0LCBjYWxjdWxhdGUgYXZlcmFnZSBmb3IgdGhlIHBhc3QgfjEgc2Vjb25kOlxuXHRcdHRpY2tzID0gTWF0aC5taW4odGltZXMubGVuZ3RoLCB0aWNrc3x8KFRpY2tlci5nZXRGUFMoKXwwKSk7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPHRpY2tzOyBpKyspIHsgdHRsICs9IHRpbWVzW2ldOyB9XG5cdFx0cmV0dXJuIHR0bC90aWNrcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYWN0dWFsIGZyYW1lcyAvIHRpY2tzIHBlciBzZWNvbmQuXG5cdCAqIEBtZXRob2QgZ2V0TWVhc3VyZWRGUFNcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gW3RpY2tzXSBUaGUgbnVtYmVyIG9mIHByZXZpb3VzIHRpY2tzIG92ZXIgd2hpY2ggdG8gbWVhc3VyZSB0aGUgYWN0dWFsIGZyYW1lcyAvIHRpY2tzIHBlciBzZWNvbmQuXG5cdCAqIERlZmF1bHRzIHRvIHRoZSBudW1iZXIgb2YgdGlja3MgcGVyIHNlY29uZC5cblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgYWN0dWFsIGZyYW1lcyAvIHRpY2tzIHBlciBzZWNvbmQuIERlcGVuZGluZyBvbiBwZXJmb3JtYW5jZSwgdGhpcyBtYXkgZGlmZmVyXG5cdCAqIGZyb20gdGhlIHRhcmdldCBmcmFtZXMgcGVyIHNlY29uZC5cblx0ICoqL1xuXHRUaWNrZXIuZ2V0TWVhc3VyZWRGUFMgPSBmdW5jdGlvbih0aWNrcykge1xuXHRcdHZhciB0aW1lcyA9IFRpY2tlci5fdGltZXM7XG5cdFx0aWYgKCF0aW1lcyB8fCB0aW1lcy5sZW5ndGggPCAyKSB7IHJldHVybiAtMTsgfVxuXG5cdFx0Ly8gYnkgZGVmYXVsdCwgY2FsY3VsYXRlIGZwcyBmb3IgdGhlIHBhc3QgfjEgc2Vjb25kOlxuXHRcdHRpY2tzID0gTWF0aC5taW4odGltZXMubGVuZ3RoLTEsIHRpY2tzfHwoVGlja2VyLmdldEZQUygpfDApKTtcblx0XHRyZXR1cm4gMTAwMC8oKHRpbWVzWzBdLXRpbWVzW3RpY2tzXSkvdGlja3MpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9wYXVzZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBzZXRQYXVzZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLnNldFBhdXNlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0Ly8gVE9ETzogZGVwcmVjYXRlZC5cblx0XHRUaWNrZXIucGF1c2VkID0gdmFsdWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3BhdXNlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldFBhdXNlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLmdldFBhdXNlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFRPRE86IGRlcHJlY2F0ZWQuXG5cdFx0cmV0dXJuIFRpY2tlci5wYXVzZWQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2UgVGlja2VyIHdhcyBpbml0aWFsaXplZCB2aWEge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2luaXRcIn19LlxuXHQgKiBSZXR1cm5zIC0xIGlmIFRpY2tlciBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQuIEZvciBleGFtcGxlLCB5b3UgY291bGQgdXNlXG5cdCAqIHRoaXMgaW4gYSB0aW1lIHN5bmNocm9uaXplZCBhbmltYXRpb24gdG8gZGV0ZXJtaW5lIHRoZSBleGFjdCBhbW91bnQgb2YgdGltZSB0aGF0IGhhcyBlbGFwc2VkLlxuXHQgKiBAbWV0aG9kIGdldFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtydW5UaW1lPWZhbHNlXSBJZiB0cnVlIG9ubHkgdGltZSBlbGFwc2VkIHdoaWxlIFRpY2tlciB3YXMgbm90IHBhdXNlZCB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBJZiBmYWxzZSwgdGhlIHZhbHVlIHJldHVybmVkIHdpbGwgYmUgdG90YWwgdGltZSBlbGFwc2VkIHNpbmNlIHRoZSBmaXJzdCB0aWNrIGV2ZW50IGxpc3RlbmVyIHdhcyBhZGRlZC5cblx0ICogQHJldHVybiB7TnVtYmVyfSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlIFRpY2tlciB3YXMgaW5pdGlhbGl6ZWQgb3IgLTEuXG5cdCAqKi9cblx0VGlja2VyLmdldFRpbWUgPSBmdW5jdGlvbihydW5UaW1lKSB7XG5cdFx0cmV0dXJuIFRpY2tlci5fc3RhcnRUaW1lID8gVGlja2VyLl9nZXRUaW1lKCkgLSAocnVuVGltZSA/IFRpY2tlci5fcGF1c2VkVGltZSA6IDApIDogLTE7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNpbWlsYXIgdG8gZ2V0VGltZSgpLCBidXQgcmV0dXJucyB0aGUgdGltZSBvbiB0aGUgbW9zdCByZWNlbnQgdGljayBldmVudCBvYmplY3QuXG5cdCAqIEBtZXRob2QgZ2V0RXZlbnRUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHJ1blRpbWUge0Jvb2xlYW59IFtydW5UaW1lPWZhbHNlXSBJZiB0cnVlLCB0aGUgcnVuVGltZSBwcm9wZXJ0eSB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2YgdGltZS5cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHRpbWUgb3IgcnVuVGltZSBwcm9wZXJ0eSBmcm9tIHRoZSBtb3N0IHJlY2VudCB0aWNrIGV2ZW50IG9yIC0xLlxuXHQgKi9cblx0VGlja2VyLmdldEV2ZW50VGltZSA9IGZ1bmN0aW9uKHJ1blRpbWUpIHtcblx0XHRyZXR1cm4gVGlja2VyLl9zdGFydFRpbWUgPyAoVGlja2VyLl9sYXN0VGltZSB8fCBUaWNrZXIuX3N0YXJ0VGltZSkgLSAocnVuVGltZSA/IFRpY2tlci5fcGF1c2VkVGltZSA6IDApIDogLTE7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRpY2tzIHRoYXQgaGF2ZSBiZWVuIGJyb2FkY2FzdCBieSBUaWNrZXIuXG5cdCAqIEBtZXRob2QgZ2V0VGlja3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHBhdXNlYWJsZSBJbmRpY2F0ZXMgd2hldGhlciB0byBpbmNsdWRlIHRpY2tzIHRoYXQgd291bGQgaGF2ZSBiZWVuIGJyb2FkY2FzdFxuXHQgKiB3aGlsZSBUaWNrZXIgd2FzIHBhdXNlZC4gSWYgdHJ1ZSBvbmx5IHRpY2sgZXZlbnRzIGJyb2FkY2FzdCB3aGlsZSBUaWNrZXIgaXMgbm90IHBhdXNlZCB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBJZiBmYWxzZSwgdGljayBldmVudHMgdGhhdCB3b3VsZCBoYXZlIGJlZW4gYnJvYWRjYXN0IHdoaWxlIFRpY2tlciB3YXMgcGF1c2VkIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHJldHVyblxuXHQgKiB2YWx1ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgZmFsc2UuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gb2YgdGlja3MgdGhhdCBoYXZlIGJlZW4gYnJvYWRjYXN0LlxuXHQgKiovXG5cdFRpY2tlci5nZXRUaWNrcyA9IGZ1bmN0aW9uKHBhdXNlYWJsZSkge1xuXHRcdHJldHVybiAgVGlja2VyLl90aWNrcyAtIChwYXVzZWFibGUgPyBUaWNrZXIuX3BhdXNlZFRpY2tzIDogMCk7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBzdGF0aWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVN5bmNoXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5faGFuZGxlU3luY2ggPSBmdW5jdGlvbigpIHtcblx0XHRUaWNrZXIuX3RpbWVySWQgPSBudWxsO1xuXHRcdFRpY2tlci5fc2V0dXBUaWNrKCk7XG5cblx0XHQvLyBydW4gaWYgZW5vdWdoIHRpbWUgaGFzIGVsYXBzZWQsIHdpdGggYSBsaXR0bGUgYml0IG9mIGZsZXhpYmlsaXR5IHRvIGJlIGVhcmx5OlxuXHRcdGlmIChUaWNrZXIuX2dldFRpbWUoKSAtIFRpY2tlci5fbGFzdFRpbWUgPj0gKFRpY2tlci5faW50ZXJ2YWwtMSkqMC45Nykge1xuXHRcdFx0VGlja2VyLl90aWNrKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVSQUZcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9oYW5kbGVSQUYgPSBmdW5jdGlvbigpIHtcblx0XHRUaWNrZXIuX3RpbWVySWQgPSBudWxsO1xuXHRcdFRpY2tlci5fc2V0dXBUaWNrKCk7XG5cdFx0VGlja2VyLl90aWNrKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVRpbWVvdXRcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9oYW5kbGVUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0VGlja2VyLl90aW1lcklkID0gbnVsbDtcblx0XHRUaWNrZXIuX3NldHVwVGljaygpO1xuXHRcdFRpY2tlci5fdGljaygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9zZXR1cFRpY2tcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9zZXR1cFRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoVGlja2VyLl90aW1lcklkICE9IG51bGwpIHsgcmV0dXJuOyB9IC8vIGF2b2lkIGR1cGxpY2F0ZXNcblxuXHRcdHZhciBtb2RlID0gVGlja2VyLnRpbWluZ01vZGV8fChUaWNrZXIudXNlUkFGJiZUaWNrZXIuUkFGX1NZTkNIRUQpO1xuXHRcdGlmIChtb2RlID09IFRpY2tlci5SQUZfU1lOQ0hFRCB8fCBtb2RlID09IFRpY2tlci5SQUYpIHtcblx0XHRcdHZhciBmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXHRcdFx0aWYgKGYpIHtcblx0XHRcdFx0VGlja2VyLl90aW1lcklkID0gZihtb2RlID09IFRpY2tlci5SQUYgPyBUaWNrZXIuX2hhbmRsZVJBRiA6IFRpY2tlci5faGFuZGxlU3luY2gpO1xuXHRcdFx0XHRUaWNrZXIuX3JhZiA9IHRydWU7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFx0VGlja2VyLl9yYWYgPSBmYWxzZTtcblx0XHRUaWNrZXIuX3RpbWVySWQgPSBzZXRUaW1lb3V0KFRpY2tlci5faGFuZGxlVGltZW91dCwgVGlja2VyLl9pbnRlcnZhbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3RpY2tcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl90aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhdXNlZCA9IFRpY2tlci5wYXVzZWQ7XG5cdFx0dmFyIHRpbWUgPSBUaWNrZXIuX2dldFRpbWUoKTtcblx0XHR2YXIgZWxhcHNlZFRpbWUgPSB0aW1lLVRpY2tlci5fbGFzdFRpbWU7XG5cdFx0VGlja2VyLl9sYXN0VGltZSA9IHRpbWU7XG5cdFx0VGlja2VyLl90aWNrcysrO1xuXHRcdFxuXHRcdGlmIChwYXVzZWQpIHtcblx0XHRcdFRpY2tlci5fcGF1c2VkVGlja3MrKztcblx0XHRcdFRpY2tlci5fcGF1c2VkVGltZSArPSBlbGFwc2VkVGltZTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKFRpY2tlci5oYXNFdmVudExpc3RlbmVyKFwidGlja1wiKSkge1xuXHRcdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwidGlja1wiKTtcblx0XHRcdHZhciBtYXhEZWx0YSA9IFRpY2tlci5tYXhEZWx0YTtcblx0XHRcdGV2ZW50LmRlbHRhID0gKG1heERlbHRhICYmIGVsYXBzZWRUaW1lID4gbWF4RGVsdGEpID8gbWF4RGVsdGEgOiBlbGFwc2VkVGltZTtcblx0XHRcdGV2ZW50LnBhdXNlZCA9IHBhdXNlZDtcblx0XHRcdGV2ZW50LnRpbWUgPSB0aW1lO1xuXHRcdFx0ZXZlbnQucnVuVGltZSA9IHRpbWUtVGlja2VyLl9wYXVzZWRUaW1lO1xuXHRcdFx0VGlja2VyLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdH1cblx0XHRcblx0XHRUaWNrZXIuX3RpY2tUaW1lcy51bnNoaWZ0KFRpY2tlci5fZ2V0VGltZSgpLXRpbWUpO1xuXHRcdHdoaWxlIChUaWNrZXIuX3RpY2tUaW1lcy5sZW5ndGggPiAxMDApIHsgVGlja2VyLl90aWNrVGltZXMucG9wKCk7IH1cblxuXHRcdFRpY2tlci5fdGltZXMudW5zaGlmdCh0aW1lKTtcblx0XHR3aGlsZSAoVGlja2VyLl90aW1lcy5sZW5ndGggPiAxMDApIHsgVGlja2VyLl90aW1lcy5wb3AoKTsgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHZhciBub3cgPSB3aW5kb3cucGVyZm9ybWFuY2UgJiYgKHBlcmZvcm1hbmNlLm5vdyB8fCBwZXJmb3JtYW5jZS5tb3pOb3cgfHwgcGVyZm9ybWFuY2UubXNOb3cgfHwgcGVyZm9ybWFuY2Uub05vdyB8fCBwZXJmb3JtYW5jZS53ZWJraXROb3cpO1xuXHRUaWNrZXIuX2dldFRpbWUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKChub3cmJm5vdy5jYWxsKHBlcmZvcm1hbmNlKSl8fChuZXcgRGF0ZSgpLmdldFRpbWUoKSkpIC0gVGlja2VyLl9zdGFydFRpbWU7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5UaWNrZXIgPSBUaWNrZXI7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVHdlZW4uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbi8vIFRPRE86IHBvc3NpYmx5IGFkZCBhIEVORCBhY3Rpb25zTW9kZSAob25seSBydW5zIGFjdGlvbnMgdGhhdCA9PSBwb3NpdGlvbik/XG4vLyBUT0RPOiBldmFsdWF0ZSBhIHdheSB0byBkZWNvdXBsZSBwYXVzZWQgZnJvbSB0aWNrIHJlZ2lzdHJhdGlvbi5cblxuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgVHdlZW4gaW5zdGFuY2UgdHdlZW5zIHByb3BlcnRpZXMgZm9yIGEgc2luZ2xlIHRhcmdldC4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmUgY2hhaW5lZCBmb3IgZWFzeSBjb25zdHJ1Y3Rpb24gYW5kIHNlcXVlbmNpbmc6XG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB0YXJnZXQuYWxwaGEgPSAxO1xuXHQgKlx0ICAgIGNyZWF0ZWpzLlR3ZWVuLmdldCh0YXJnZXQpXG5cdCAqXHQgICAgICAgICAud2FpdCg1MDApXG5cdCAqXHQgICAgICAgICAudG8oe2FscGhhOjAsIHZpc2libGU6ZmFsc2V9LCAxMDAwKVxuXHQgKlx0ICAgICAgICAgLmNhbGwoaGFuZGxlQ29tcGxldGUpO1xuXHQgKlx0ICAgIGZ1bmN0aW9uIGhhbmRsZUNvbXBsZXRlKCkge1xuXHQgKlx0ICAgIFx0Ly9Ud2VlbiBjb21wbGV0ZVxuXHQgKlx0ICAgIH1cblx0ICpcblx0ICogTXVsdGlwbGUgdHdlZW5zIGNhbiBwb2ludCB0byB0aGUgc2FtZSBpbnN0YW5jZSwgaG93ZXZlciBpZiB0aGV5IGFmZmVjdCB0aGUgc2FtZSBwcm9wZXJ0aWVzIHRoZXJlIGNvdWxkIGJlIHVuZXhwZWN0ZWRcblx0ICogYmVoYXZpb3VyLiBUbyBzdG9wIGFsbCB0d2VlbnMgb24gYW4gb2JqZWN0LCB1c2Uge3sjY3Jvc3NMaW5rIFwiVHdlZW4vcmVtb3ZlVHdlZW5zXCJ9fXt7L2Nyb3NzTGlua319IG9yIHBhc3MgYG92ZXJyaWRlOnRydWVgXG5cdCAqIGluIHRoZSBwcm9wcyBhcmd1bWVudC5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0LCB7b3ZlcnJpZGU6dHJ1ZX0pLnRvKHt4OjEwMH0pO1xuXHQgKlxuXHQgKiBTdWJzY3JpYmUgdG8gdGhlIHt7I2Nyb3NzTGluayBcIlR3ZWVuL2NoYW5nZTpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCB0byBnZXQgbm90aWZpZWQgd2hlbiBhIHByb3BlcnR5IG9mIHRoZVxuXHQgKiB0YXJnZXQgaXMgY2hhbmdlZC5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0LCB7b3ZlcnJpZGU6dHJ1ZX0pLnRvKHt4OjEwMH0pLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlQ2hhbmdlKTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UoZXZlbnQpIHtcblx0ICogICAgICAgICAgLy8gVGhlIHR3ZWVuIGNoYW5nZWQuXG5cdCAqICAgICAgfVxuXHQgKlxuXHQgKiBTZWUgdGhlIFR3ZWVuIHt7I2Nyb3NzTGluayBcIlR3ZWVuL2dldFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgZm9yIGFkZGl0aW9uYWwgcGFyYW0gZG9jdW1lbnRhdGlvbi5cblx0ICogQGNsYXNzIFR3ZWVuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdGhhdCB3aWxsIGhhdmUgaXRzIHByb3BlcnRpZXMgdHdlZW5lZC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gVGhlIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyB0byBhcHBseSB0byB0aGlzIHR3ZWVuIGluc3RhbmNlIChleC4gYHtsb29wOnRydWUsIHBhdXNlZDp0cnVlfWAuXG5cdCAqIEFsbCBwcm9wZXJ0aWVzIGRlZmF1bHQgdG8gZmFsc2UuIFN1cHBvcnRlZCBwcm9wcyBhcmU6PFVMPlxuXHQgKiAgICA8TEk+IGxvb3A6IHNldHMgdGhlIGxvb3AgcHJvcGVydHkgb24gdGhpcyB0d2Vlbi48L0xJPlxuXHQgKiAgICA8TEk+IHVzZVRpY2tzOiB1c2VzIHRpY2tzIGZvciBhbGwgZHVyYXRpb25zIGluc3RlYWQgb2YgbWlsbGlzZWNvbmRzLjwvTEk+XG5cdCAqICAgIDxMST4gaWdub3JlR2xvYmFsUGF1c2U6IHNldHMgdGhlIHt7I2Nyb3NzTGluayBcIlR3ZWVuL2lnbm9yZUdsb2JhbFBhdXNlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IG9uIHRoaXMgdHdlZW4uPC9MST5cblx0ICogICAgPExJPiBvdmVycmlkZTogaWYgdHJ1ZSwgYFR3ZWVuLnJlbW92ZVR3ZWVucyh0YXJnZXQpYCB3aWxsIGJlIGNhbGxlZCB0byByZW1vdmUgYW55IG90aGVyIHR3ZWVucyB3aXRoIHRoZSBzYW1lIHRhcmdldC5cblx0ICogICAgPExJPiBwYXVzZWQ6IGluZGljYXRlcyB3aGV0aGVyIHRvIHN0YXJ0IHRoZSB0d2VlbiBwYXVzZWQuPC9MST5cblx0ICogICAgPExJPiBwb3NpdGlvbjogaW5kaWNhdGVzIHRoZSBpbml0aWFsIHBvc2l0aW9uIGZvciB0aGlzIHR3ZWVuLjwvTEk+XG5cdCAqICAgIDxMST4gb25DaGFuZ2U6IHNwZWNpZmllcyBhIGxpc3RlbmVyIGZvciB0aGUgXCJjaGFuZ2VcIiBldmVudC48L0xJPlxuXHQgKiA8L1VMPlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3BsdWdpbkRhdGFdIEFuIG9iamVjdCBjb250YWluaW5nIGRhdGEgZm9yIHVzZSBieSBpbnN0YWxsZWQgcGx1Z2lucy4gU2VlIGluZGl2aWR1YWxcblx0ICogcGx1Z2lucycgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy5cblx0ICogQGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gVHdlZW4odGFyZ2V0LCBwcm9wcywgcGx1Z2luRGF0YSkge1xuXG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIENhdXNlcyB0aGlzIHR3ZWVuIHRvIGNvbnRpbnVlIHBsYXlpbmcgd2hlbiBhIGdsb2JhbCBwYXVzZSBpcyBhY3RpdmUuIEZvciBleGFtcGxlLCBpZiBUd2VlbkpTIGlzIHVzaW5nIHt7I2Nyb3NzTGluayBcIlRpY2tlclwifX17ey9jcm9zc0xpbmt9fSxcblx0XHQgKiB0aGVuIHNldHRpbmcgdGhpcyB0byB0cnVlICh0aGUgZGVmYXVsdCkgd2lsbCBjYXVzZSB0aGlzIHR3ZWVuIHRvIGJlIHBhdXNlZCB3aGVuIDxjb2RlPlRpY2tlci5zZXRQYXVzZWQodHJ1ZSk8L2NvZGU+XG5cdFx0ICogaXMgY2FsbGVkLiBTZWUgdGhlIFR3ZWVuIHt7I2Nyb3NzTGluayBcIlR3ZWVuL3RpY2tcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGZvciBtb3JlIGluZm8uIENhbiBiZSBzZXQgdmlhIHRoZSBwcm9wc1xuXHRcdCAqIHBhcmFtZXRlci5cblx0XHQgKiBAcHJvcGVydHkgaWdub3JlR2xvYmFsUGF1c2Vcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmlnbm9yZUdsb2JhbFBhdXNlID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIElmIHRydWUsIHRoZSB0d2VlbiB3aWxsIGxvb3Agd2hlbiBpdCByZWFjaGVzIHRoZSBlbmQuIENhbiBiZSBzZXQgdmlhIHRoZSBwcm9wcyBwYXJhbS5cblx0XHQgKiBAcHJvcGVydHkgbG9vcFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5sb29wID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNwZWNpZmllcyB0aGUgdG90YWwgZHVyYXRpb24gb2YgdGhpcyB0d2VlbiBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIHVzZVRpY2tzIGlzIHRydWUpLlxuXHRcdCAqIFRoaXMgdmFsdWUgaXMgYXV0b21hdGljYWxseSB1cGRhdGVkIGFzIHlvdSBtb2RpZnkgdGhlIHR3ZWVuLiBDaGFuZ2luZyBpdCBkaXJlY3RseSBjb3VsZCByZXN1bHQgaW4gdW5leHBlY3RlZFxuXHRcdCAqIGJlaGF2aW91ci5cblx0XHQgKiBAcHJvcGVydHkgZHVyYXRpb25cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLmR1cmF0aW9uID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQWxsb3dzIHlvdSB0byBzcGVjaWZ5IGRhdGEgdGhhdCB3aWxsIGJlIHVzZWQgYnkgaW5zdGFsbGVkIHBsdWdpbnMuIEVhY2ggcGx1Z2luIHVzZXMgdGhpcyBkaWZmZXJlbnRseSwgYnV0IGluIGdlbmVyYWxcblx0XHQgKiB5b3Ugc3BlY2lmeSBkYXRhIGJ5IHNldHRpbmcgaXQgdG8gYSBwcm9wZXJ0eSBvZiBwbHVnaW5EYXRhIHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgcGx1Z2luIGNsYXNzLlxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICpcdG15VHdlZW4ucGx1Z2luRGF0YS5QbHVnaW5DbGFzc05hbWUgPSBkYXRhO1xuXHRcdCAqIDxici8+XG5cdFx0ICogQWxzbywgbW9zdCBwbHVnaW5zIHN1cHBvcnQgYSBwcm9wZXJ0eSB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGVtLiBUaGlzIGlzIHR5cGljYWxseSB0aGUgcGx1Z2luIGNsYXNzIG5hbWUgZm9sbG93ZWQgYnkgXCJfZW5hYmxlZFwiLjxici8+XG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKlx0bXlUd2Vlbi5wbHVnaW5EYXRhLlBsdWdpbkNsYXNzTmFtZV9lbmFibGVkID0gZmFsc2U7PGJyLz5cblx0XHQgKiA8YnIvPlxuXHRcdCAqIFNvbWUgcGx1Z2lucyBhbHNvIHN0b3JlIGluc3RhbmNlIGRhdGEgaW4gdGhpcyBvYmplY3QsIHVzdWFsbHkgaW4gYSBwcm9wZXJ0eSBuYW1lZCBfUGx1Z2luQ2xhc3NOYW1lLlxuXHRcdCAqIFNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgaW5kaXZpZHVhbCBwbHVnaW5zIGZvciBtb3JlIGRldGFpbHMuXG5cdFx0ICogQHByb3BlcnR5IHBsdWdpbkRhdGFcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMucGx1Z2luRGF0YSA9IHBsdWdpbkRhdGEgfHwge307XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0YXJnZXQgb2YgdGhpcyB0d2Vlbi4gVGhpcyBpcyB0aGUgb2JqZWN0IG9uIHdoaWNoIHRoZSB0d2VlbmVkIHByb3BlcnRpZXMgd2lsbCBiZSBjaGFuZ2VkLiBDaGFuZ2luZ1xuXHRcdCAqIHRoaXMgcHJvcGVydHkgYWZ0ZXIgdGhlIHR3ZWVuIGlzIGNyZWF0ZWQgd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSB0YXJnZXRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY3VycmVudCBub3JtYWxpemVkIHBvc2l0aW9uIG9mIHRoZSB0d2Vlbi4gVGhpcyB3aWxsIGFsd2F5cyBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgZHVyYXRpb24uXG5cdFx0ICogQ2hhbmdpbmcgdGhpcyBwcm9wZXJ0eSBkaXJlY3RseSB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBwb3NpdGlvblxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5wb3NpdGlvbiA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGUgdHdlZW4ncyBjdXJyZW50IHBvc2l0aW9uIGlzIHdpdGhpbiBhIHBhc3NpdmUgd2FpdC5cblx0XHQgKiBAcHJvcGVydHkgcGFzc2l2ZVxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMucGFzc2l2ZSA9IGZhbHNlO1xuXHRcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9wYXVzZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9jdXJRdWV1ZVByb3BzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fY3VyUXVldWVQcm9wcyA9IHt9O1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2luaXRRdWV1ZVByb3BzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5faW5pdFF1ZXVlUHJvcHMgPSB7fTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9zdGVwc1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fc3RlcHMgPSBbXTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9hY3Rpb25zXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9hY3Rpb25zID0gW107XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJhdyBwb3NpdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgX3ByZXZQb3NpdGlvblxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9wcmV2UG9zaXRpb24gPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgcG9zaXRpb24gd2l0aGluIHRoZSBjdXJyZW50IHN0ZXAuXG5cdFx0ICogQHByb3BlcnR5IF9zdGVwUG9zaXRpb25cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fc3RlcFBvc2l0aW9uID0gMDsgLy8gdGhpcyBpcyBuZWVkZWQgYnkgTW92aWVDbGlwLlxuXHRcblx0XHQvKipcblx0XHQgKiBOb3JtYWxpemVkIHBvc2l0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcHJldlBvc1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgLTFcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fcHJldlBvcyA9IC0xO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3RhcmdldFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3RhcmdldCA9IHRhcmdldDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF91c2VUaWNrc1xuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3VzZVRpY2tzID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfaW5pdGVkXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5faW5pdGVkID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHR3ZWVuIGlzIGN1cnJlbnRseSByZWdpc3RlcmVkIHdpdGggVHdlZW4uXG5cdFx0ICogQHByb3BlcnR5IF9yZWdpc3RlcmVkXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fcmVnaXN0ZXJlZCA9IGZhbHNlO1xuXG5cblx0XHRpZiAocHJvcHMpIHtcblx0XHRcdHRoaXMuX3VzZVRpY2tzID0gcHJvcHMudXNlVGlja3M7XG5cdFx0XHR0aGlzLmlnbm9yZUdsb2JhbFBhdXNlID0gcHJvcHMuaWdub3JlR2xvYmFsUGF1c2U7XG5cdFx0XHR0aGlzLmxvb3AgPSBwcm9wcy5sb29wO1xuXHRcdFx0cHJvcHMub25DaGFuZ2UgJiYgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHByb3BzLm9uQ2hhbmdlKTtcblx0XHRcdGlmIChwcm9wcy5vdmVycmlkZSkgeyBUd2Vlbi5yZW1vdmVUd2VlbnModGFyZ2V0KTsgfVxuXHRcdH1cblx0XHRpZiAocHJvcHMmJnByb3BzLnBhdXNlZCkgeyB0aGlzLl9wYXVzZWQ9dHJ1ZTsgfVxuXHRcdGVsc2UgeyBjcmVhdGVqcy5Ud2Vlbi5fcmVnaXN0ZXIodGhpcyx0cnVlKTsgfVxuXHRcdGlmIChwcm9wcyYmcHJvcHMucG9zaXRpb24hPW51bGwpIHsgdGhpcy5zZXRQb3NpdGlvbihwcm9wcy5wb3NpdGlvbiwgVHdlZW4uTk9ORSk7IH1cblxuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFR3ZWVuLCBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXHRcblxuLy8gc3RhdGljIHByb3BlcnRpZXNcblx0LyoqXG5cdCAqIENvbnN0YW50IGRlZmluaW5nIHRoZSBub25lIGFjdGlvbnNNb2RlIGZvciB1c2Ugd2l0aCBzZXRQb3NpdGlvbi5cblx0ICogQHByb3BlcnR5IE5PTkVcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqIEBkZWZhdWx0IDBcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VHdlZW4uTk9ORSA9IDA7XG5cblx0LyoqXG5cdCAqIENvbnN0YW50IGRlZmluaW5nIHRoZSBsb29wIGFjdGlvbnNNb2RlIGZvciB1c2Ugd2l0aCBzZXRQb3NpdGlvbi5cblx0ICogQHByb3BlcnR5IExPT1Bcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqIEBkZWZhdWx0IDFcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VHdlZW4uTE9PUCA9IDE7XG5cblx0LyoqXG5cdCAqIENvbnN0YW50IGRlZmluaW5nIHRoZSByZXZlcnNlIGFjdGlvbnNNb2RlIGZvciB1c2Ugd2l0aCBzZXRQb3NpdGlvbi5cblx0ICogQHByb3BlcnR5IFJFVkVSU0Vcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqIEBkZWZhdWx0IDJcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VHdlZW4uUkVWRVJTRSA9IDI7XG5cblx0LyoqXG5cdCAqIENvbnN0YW50IHJldHVybmVkIGJ5IHBsdWdpbnMgdG8gdGVsbCB0aGUgdHdlZW4gbm90IHRvIHVzZSBkZWZhdWx0IGFzc2lnbm1lbnQuXG5cdCAqIEBwcm9wZXJ0eSBJR05PUkVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFR3ZWVuLklHTk9SRSA9IHt9O1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX2xpc3RlbmVyc1xuXHQgKiBAdHlwZSBBcnJheVtUd2Vlbl1cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRUd2Vlbi5fdHdlZW5zID0gW107XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfcGx1Z2luc1xuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRUd2Vlbi5fcGx1Z2lucyA9IHt9O1xuXG5cbi8vIHN0YXRpYyBtZXRob2RzXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBuZXcgdHdlZW4gaW5zdGFuY2UuIFRoaXMgaXMgZnVuY3Rpb25hbGx5IGlkZW50aWNhbCB0byB1c2luZyBcIm5ldyBUd2VlbiguLi4pXCIsIGJ1dCBsb29rcyBjbGVhbmVyXG5cdCAqIHdpdGggdGhlIGNoYWluZWQgc3ludGF4IG9mIFR3ZWVuSlMuXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICpcdFx0dmFyIHR3ZWVuID0gY3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldCk7XG5cdCAqXG5cdCAqIEBtZXRob2QgZ2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdGhhdCB3aWxsIGhhdmUgaXRzIHByb3BlcnRpZXMgdHdlZW5lZC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gVGhlIGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyB0byBhcHBseSB0byB0aGlzIHR3ZWVuIGluc3RhbmNlIChleC4gYHtsb29wOnRydWUsIHBhdXNlZDp0cnVlfWApLlxuXHQgKiBBbGwgcHJvcGVydGllcyBkZWZhdWx0IHRvIGBmYWxzZWAuIFN1cHBvcnRlZCBwcm9wcyBhcmU6XG5cdCAqIDxVTD5cblx0ICogICAgPExJPiBsb29wOiBzZXRzIHRoZSBsb29wIHByb3BlcnR5IG9uIHRoaXMgdHdlZW4uPC9MST5cblx0ICogICAgPExJPiB1c2VUaWNrczogdXNlcyB0aWNrcyBmb3IgYWxsIGR1cmF0aW9ucyBpbnN0ZWFkIG9mIG1pbGxpc2Vjb25kcy48L0xJPlxuXHQgKiAgICA8TEk+IGlnbm9yZUdsb2JhbFBhdXNlOiBzZXRzIHRoZSB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9pZ25vcmVHbG9iYWxQYXVzZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBvblxuXHQgKiAgICB0aGlzIHR3ZWVuLjwvTEk+XG5cdCAqICAgIDxMST4gb3ZlcnJpZGU6IGlmIHRydWUsIGBjcmVhdGVqcy5Ud2Vlbi5yZW1vdmVUd2VlbnModGFyZ2V0KWAgd2lsbCBiZSBjYWxsZWQgdG8gcmVtb3ZlIGFueSBvdGhlciB0d2VlbnMgd2l0aFxuXHQgKiAgICB0aGUgc2FtZSB0YXJnZXQuXG5cdCAqICAgIDxMST4gcGF1c2VkOiBpbmRpY2F0ZXMgd2hldGhlciB0byBzdGFydCB0aGUgdHdlZW4gcGF1c2VkLjwvTEk+XG5cdCAqICAgIDxMST4gcG9zaXRpb246IGluZGljYXRlcyB0aGUgaW5pdGlhbCBwb3NpdGlvbiBmb3IgdGhpcyB0d2Vlbi48L0xJPlxuXHQgKiAgICA8TEk+IG9uQ2hhbmdlOiBzcGVjaWZpZXMgYSBsaXN0ZW5lciBmb3IgdGhlIHt7I2Nyb3NzTGluayBcIlR3ZWVuL2NoYW5nZTpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudC48L0xJPlxuXHQgKiA8L1VMPlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3BsdWdpbkRhdGFdIEFuIG9iamVjdCBjb250YWluaW5nIGRhdGEgZm9yIHVzZSBieSBpbnN0YWxsZWQgcGx1Z2lucy4gU2VlIGluZGl2aWR1YWwgcGx1Z2lucydcblx0ICogZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3ZlcnJpZGU9ZmFsc2VdIElmIHRydWUsIGFueSBwcmV2aW91cyB0d2VlbnMgb24gdGhlIHNhbWUgdGFyZ2V0IHdpbGwgYmUgcmVtb3ZlZC4gVGhpcyBpcyB0aGVcblx0ICogc2FtZSBhcyBjYWxsaW5nIGBUd2Vlbi5yZW1vdmVUd2VlbnModGFyZ2V0KWAuXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBBIHJlZmVyZW5jZSB0byB0aGUgY3JlYXRlZCB0d2Vlbi4gQWRkaXRpb25hbCBjaGFpbmVkIHR3ZWVucywgbWV0aG9kIGNhbGxzLCBvciBjYWxsYmFja3MgY2FuIGJlXG5cdCAqIGFwcGxpZWQgdG8gdGhlIHJldHVybmVkIHR3ZWVuIGluc3RhbmNlLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUd2Vlbi5nZXQgPSBmdW5jdGlvbih0YXJnZXQsIHByb3BzLCBwbHVnaW5EYXRhLCBvdmVycmlkZSkge1xuXHRcdGlmIChvdmVycmlkZSkgeyBUd2Vlbi5yZW1vdmVUd2VlbnModGFyZ2V0KTsgfVxuXHRcdHJldHVybiBuZXcgVHdlZW4odGFyZ2V0LCBwcm9wcywgcGx1Z2luRGF0YSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkdmFuY2VzIGFsbCB0d2VlbnMuIFRoaXMgdHlwaWNhbGx5IHVzZXMgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlclwifX17ey9jcm9zc0xpbmt9fSBjbGFzcywgYnV0IHlvdSBjYW4gY2FsbCBpdFxuXHQgKiBtYW51YWxseSBpZiB5b3UgcHJlZmVyIHRvIHVzZSB5b3VyIG93biBcImhlYXJ0YmVhdFwiIGltcGxlbWVudGF0aW9uLlxuXHQgKiBAbWV0aG9kIHRpY2tcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhIFRoZSBjaGFuZ2UgaW4gdGltZSBpbiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdGljay4gUmVxdWlyZWQgdW5sZXNzIGFsbCB0d2VlbnMgaGF2ZVxuXHQgKiBgdXNlVGlja3NgIHNldCB0byB0cnVlLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHBhdXNlZCBJbmRpY2F0ZXMgd2hldGhlciBhIGdsb2JhbCBwYXVzZSBpcyBpbiBlZmZlY3QuIFR3ZWVucyB3aXRoIHt7I2Nyb3NzTGluayBcIlR3ZWVuL2lnbm9yZUdsb2JhbFBhdXNlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdpbGwgaWdub3JlIHRoaXMsIGJ1dCBhbGwgb3RoZXJzIHdpbGwgcGF1c2UgaWYgdGhpcyBpcyBgdHJ1ZWAuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFR3ZWVuLnRpY2sgPSBmdW5jdGlvbihkZWx0YSwgcGF1c2VkKSB7XG5cdFx0dmFyIHR3ZWVucyA9IFR3ZWVuLl90d2VlbnMuc2xpY2UoKTsgLy8gdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zLlxuXHRcdGZvciAodmFyIGk9dHdlZW5zLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcblx0XHRcdHZhciB0d2VlbiA9IHR3ZWVuc1tpXTtcblx0XHRcdGlmICgocGF1c2VkICYmICF0d2Vlbi5pZ25vcmVHbG9iYWxQYXVzZSkgfHwgdHdlZW4uX3BhdXNlZCkgeyBjb250aW51ZTsgfVxuXHRcdFx0dHdlZW4udGljayh0d2Vlbi5fdXNlVGlja3M/MTpkZWx0YSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGUgZXZlbnRzIHRoYXQgcmVzdWx0IGZyb20gVHdlZW4gYmVpbmcgdXNlZCBhcyBhbiBldmVudCBoYW5kbGVyLiBUaGlzIGlzIGluY2x1ZGVkIHRvIGFsbG93IFR3ZWVuIHRvIGhhbmRsZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudHMgZnJvbSB0aGUgY3JlYXRlanMge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBObyBvdGhlciBldmVudHMgYXJlIGhhbmRsZWQgaW4gVHdlZW4uXG5cdCAqIEBtZXRob2QgaGFuZGxlRXZlbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IEFuIGV2ZW50IG9iamVjdCBwYXNzZWQgaW4gYnkgdGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlclwifX17ey9jcm9zc0xpbmt9fS4gV2lsbFxuXHQgKiB1c3VhbGx5IGJlIG9mIHR5cGUgXCJ0aWNrXCIuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNC4yXG5cdCAqL1xuXHRUd2Vlbi5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0aWYgKGV2ZW50LnR5cGUgPT0gXCJ0aWNrXCIpIHtcblx0XHRcdHRoaXMudGljayhldmVudC5kZWx0YSwgZXZlbnQucGF1c2VkKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIGV4aXN0aW5nIHR3ZWVucyBmb3IgYSB0YXJnZXQuIFRoaXMgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgbmV3IHR3ZWVucyBpZiB0aGUgYG92ZXJyaWRlYFxuXHQgKiBwcm9wZXJ0eSBpcyBgdHJ1ZWAuXG5cdCAqIEBtZXRob2QgcmVtb3ZlVHdlZW5zXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdG8gcmVtb3ZlIGV4aXN0aW5nIHR3ZWVucyBmcm9tLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUd2Vlbi5yZW1vdmVUd2VlbnMgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRpZiAoIXRhcmdldC50d2VlbmpzX2NvdW50KSB7IHJldHVybjsgfVxuXHRcdHZhciB0d2VlbnMgPSBUd2Vlbi5fdHdlZW5zO1xuXHRcdGZvciAodmFyIGk9dHdlZW5zLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcblx0XHRcdHZhciB0d2VlbiA9IHR3ZWVuc1tpXTtcblx0XHRcdGlmICh0d2Vlbi5fdGFyZ2V0ID09IHRhcmdldCkge1xuXHRcdFx0XHR0d2Vlbi5fcGF1c2VkID0gdHJ1ZTtcblx0XHRcdFx0dHdlZW5zLnNwbGljZShpLCAxKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGFyZ2V0LnR3ZWVuanNfY291bnQgPSAwO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9wIGFuZCByZW1vdmUgYWxsIGV4aXN0aW5nIHR3ZWVucy5cblx0ICogQG1ldGhvZCByZW1vdmVBbGxUd2VlbnNcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC40LjFcblx0ICovXG5cdFR3ZWVuLnJlbW92ZUFsbFR3ZWVucyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0d2VlbnMgPSBUd2Vlbi5fdHdlZW5zO1xuXHRcdGZvciAodmFyIGk9IDAsIGw9dHdlZW5zLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdHZhciB0d2VlbiA9IHR3ZWVuc1tpXTtcblx0XHRcdHR3ZWVuLl9wYXVzZWQgPSB0cnVlO1xuXHRcdFx0dHdlZW4udGFyZ2V0JiYodHdlZW4udGFyZ2V0LnR3ZWVuanNfY291bnQgPSAwKTtcblx0XHR9XG5cdFx0dHdlZW5zLmxlbmd0aCA9IDA7XG5cdH07XG5cblx0LyoqXG5cdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgYWN0aXZlIHR3ZWVucyAoYW5kIGhvdyBtYW55KSBvbiB0aGUgdGFyZ2V0IG9iamVjdCAoaWYgc3BlY2lmaWVkKSBvciBpbiBnZW5lcmFsLlxuXHQgKiBAbWV0aG9kIGhhc0FjdGl2ZVR3ZWVuc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gW3RhcmdldF0gVGhlIHRhcmdldCB0byBjaGVjayBmb3IgYWN0aXZlIHR3ZWVucy4gSWYgbm90IHNwZWNpZmllZCwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGluZGljYXRlXG5cdCAqIGlmIHRoZXJlIGFyZSBhbnkgYWN0aXZlIHR3ZWVucyBvbiBhbnkgdGFyZ2V0LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGVyZSBhcmUgYWN0aXZlIHR3ZWVucy5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VHdlZW4uaGFzQWN0aXZlVHdlZW5zID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0aWYgKHRhcmdldCkgeyByZXR1cm4gdGFyZ2V0LnR3ZWVuanNfY291bnQgIT0gbnVsbCAmJiAhIXRhcmdldC50d2VlbmpzX2NvdW50OyB9XG5cdFx0cmV0dXJuIFR3ZWVuLl90d2VlbnMgJiYgISFUd2Vlbi5fdHdlZW5zLmxlbmd0aDtcblx0fTtcblxuXHQvKipcblx0ICogSW5zdGFsbHMgYSBwbHVnaW4sIHdoaWNoIGNhbiBtb2RpZnkgaG93IGNlcnRhaW4gcHJvcGVydGllcyBhcmUgaGFuZGxlZCB3aGVuIHR3ZWVuZWQuIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiQ1NTUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBhbiBleGFtcGxlIG9mIGhvdyB0byB3cml0ZSBUd2VlbkpTIHBsdWdpbnMuXG5cdCAqIEBtZXRob2QgaW5zdGFsbFBsdWdpblxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gVGhlIHBsdWdpbiBjbGFzcyB0byBpbnN0YWxsXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHByb3BlcnRpZXMgQW4gYXJyYXkgb2YgcHJvcGVydGllcyB0aGF0IHRoZSBwbHVnaW4gd2lsbCBoYW5kbGUuXG5cdCAqL1xuXHRUd2Vlbi5pbnN0YWxsUGx1Z2luID0gZnVuY3Rpb24ocGx1Z2luLCBwcm9wZXJ0aWVzKSB7XG5cdFx0dmFyIHByaW9yaXR5ID0gcGx1Z2luLnByaW9yaXR5O1xuXHRcdGlmIChwcmlvcml0eSA9PSBudWxsKSB7IHBsdWdpbi5wcmlvcml0eSA9IHByaW9yaXR5ID0gMDsgfVxuXHRcdGZvciAodmFyIGk9MCxsPXByb3BlcnRpZXMubGVuZ3RoLHA9VHdlZW4uX3BsdWdpbnM7aTxsO2krKykge1xuXHRcdFx0dmFyIG4gPSBwcm9wZXJ0aWVzW2ldO1xuXHRcdFx0aWYgKCFwW25dKSB7IHBbbl0gPSBbcGx1Z2luXTsgfVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHZhciBhcnIgPSBwW25dO1xuXHRcdFx0XHRmb3IgKHZhciBqPTAsamw9YXJyLmxlbmd0aDtqPGpsO2orKykge1xuXHRcdFx0XHRcdGlmIChwcmlvcml0eSA8IGFycltqXS5wcmlvcml0eSkgeyBicmVhazsgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdHBbbl0uc3BsaWNlKGosMCxwbHVnaW4pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIG9yIHVucmVnaXN0ZXJzIGEgdHdlZW4gd2l0aCB0aGUgdGlja2luZyBzeXN0ZW0uXG5cdCAqIEBtZXRob2QgX3JlZ2lzdGVyXG5cdCAqIEBwYXJhbSB7VHdlZW59IHR3ZWVuIFRoZSB0d2VlbiBpbnN0YW5jZSB0byByZWdpc3RlciBvciB1bnJlZ2lzdGVyLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIElmIGB0cnVlYCwgdGhlIHR3ZWVuIGlzIHJlZ2lzdGVyZWQuIElmIGBmYWxzZWAgdGhlIHR3ZWVuIGlzIHVucmVnaXN0ZXJlZC5cblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRUd2Vlbi5fcmVnaXN0ZXIgPSBmdW5jdGlvbih0d2VlbiwgdmFsdWUpIHtcblx0XHR2YXIgdGFyZ2V0ID0gdHdlZW4uX3RhcmdldDtcblx0XHR2YXIgdHdlZW5zID0gVHdlZW4uX3R3ZWVucztcblx0XHRpZiAodmFsdWUgJiYgIXR3ZWVuLl9yZWdpc3RlcmVkKSB7XG5cdFx0XHQvLyBUT0RPOiB0aGlzIGFwcHJvYWNoIG1pZ2h0IGZhaWwgaWYgYSBkZXYgaXMgdXNpbmcgc2VhbGVkIG9iamVjdHMgaW4gRVM1XG5cdFx0XHRpZiAodGFyZ2V0KSB7IHRhcmdldC50d2VlbmpzX2NvdW50ID0gdGFyZ2V0LnR3ZWVuanNfY291bnQgPyB0YXJnZXQudHdlZW5qc19jb3VudCsxIDogMTsgfVxuXHRcdFx0dHdlZW5zLnB1c2godHdlZW4pO1xuXHRcdFx0aWYgKCFUd2Vlbi5faW5pdGVkICYmIGNyZWF0ZWpzLlRpY2tlcikgeyBjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgVHdlZW4pOyBUd2Vlbi5faW5pdGVkID0gdHJ1ZTsgfVxuXHRcdH0gZWxzZSBpZiAoIXZhbHVlICYmIHR3ZWVuLl9yZWdpc3RlcmVkKSB7XG5cdFx0XHRpZiAodGFyZ2V0KSB7IHRhcmdldC50d2VlbmpzX2NvdW50LS07IH1cblx0XHRcdHZhciBpID0gdHdlZW5zLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0aWYgKHR3ZWVuc1tpXSA9PSB0d2Vlbikge1xuXHRcdFx0XHRcdHR3ZWVucy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dHdlZW4uX3JlZ2lzdGVyZWQgPSB2YWx1ZTtcblx0fTtcblxuXG4vLyBldmVudHM6XG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIHR3ZWVuJ3MgcG9zaXRpb24gY2hhbmdlcy5cblx0ICogQGV2ZW50IGNoYW5nZVxuXHQgKiBAc2luY2UgMC40LjBcblx0ICoqL1xuXHRcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBRdWV1ZXMgYSB3YWl0IChlc3NlbnRpYWxseSBhbiBlbXB0eSB0d2VlbikuXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICpcdFx0Ly9UaGlzIHR3ZWVuIHdpbGwgd2FpdCAxcyBiZWZvcmUgYWxwaGEgaXMgZmFkZWQgdG8gMC5cblx0ICpcdFx0Y3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldCkud2FpdCgxMDAwKS50byh7YWxwaGE6MH0sIDEwMDApO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHdhaXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIFRoZSBkdXJhdGlvbiBvZiB0aGUgd2FpdCBpbiBtaWxsaXNlY29uZHMgKG9yIGluIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgdHJ1ZSkuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Bhc3NpdmVdIFR3ZWVuIHByb3BlcnRpZXMgd2lsbCBub3QgYmUgdXBkYXRlZCBkdXJpbmcgYSBwYXNzaXZlIHdhaXQuIFRoaXNcblx0ICogaXMgbW9zdGx5IHVzZWZ1bCBmb3IgdXNlIHdpdGgge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmVcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2VzIHRoYXQgY29udGFpbiBtdWx0aXBsZSB0d2VlbnNcblx0ICogYWZmZWN0aW5nIHRoZSBzYW1lIHRhcmdldCBhdCBkaWZmZXJlbnQgdGltZXMuXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBUaGlzIHR3ZWVuIGluc3RhbmNlIChmb3IgY2hhaW5pbmcgY2FsbHMpLlxuXHQgKiovXG5cdHAud2FpdCA9IGZ1bmN0aW9uKGR1cmF0aW9uLCBwYXNzaXZlKSB7XG5cdFx0aWYgKGR1cmF0aW9uID09IG51bGwgfHwgZHVyYXRpb24gPD0gMCkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHZhciBvID0gdGhpcy5fY2xvbmVQcm9wcyh0aGlzLl9jdXJRdWV1ZVByb3BzKTtcblx0XHRyZXR1cm4gdGhpcy5fYWRkU3RlcCh7ZDpkdXJhdGlvbiwgcDA6bywgZTp0aGlzLl9saW5lYXJFYXNlLCBwMTpvLCB2OnBhc3NpdmV9KTtcblx0fTtcblxuXHQvKipcblx0ICogUXVldWVzIGEgdHdlZW4gZnJvbSB0aGUgY3VycmVudCB2YWx1ZXMgdG8gdGhlIHRhcmdldCBwcm9wZXJ0aWVzLiBTZXQgZHVyYXRpb24gdG8gMCB0byBqdW1wIHRvIHRoZXNlIHZhbHVlLlxuXHQgKiBOdW1lcmljIHByb3BlcnRpZXMgd2lsbCBiZSB0d2VlbmVkIGZyb20gdGhlaXIgY3VycmVudCB2YWx1ZSBpbiB0aGUgdHdlZW4gdG8gdGhlIHRhcmdldCB2YWx1ZS4gTm9uLW51bWVyaWNcblx0ICogcHJvcGVydGllcyB3aWxsIGJlIHNldCBhdCB0aGUgZW5kIG9mIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24uXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICpcdFx0Y3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldCkudG8oe2FscGhhOjB9LCAxMDAwKTtcblx0ICpcblx0ICogQG1ldGhvZCB0b1xuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQW4gb2JqZWN0IHNwZWNpZnlpbmcgcHJvcGVydHkgdGFyZ2V0IHZhbHVlcyBmb3IgdGhpcyB0d2VlbiAoRXguIGB7eDozMDB9YCB3b3VsZCB0d2VlbiB0aGUgeFxuXHQgKiBwcm9wZXJ0eSBvZiB0aGUgdGFyZ2V0IHRvIDMwMCkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZHVyYXRpb249MF0gVGhlIGR1cmF0aW9uIG9mIHRoZSB3YWl0IGluIG1pbGxpc2Vjb25kcyAob3IgaW4gdGlja3MgaWYgYHVzZVRpY2tzYCBpcyB0cnVlKS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2Vhc2U9XCJsaW5lYXJcIl0gVGhlIGVhc2luZyBmdW5jdGlvbiB0byB1c2UgZm9yIHRoaXMgdHdlZW4uIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiRWFzZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBjbGFzcyBmb3IgYSBsaXN0IG9mIGJ1aWx0LWluIGVhc2UgZnVuY3Rpb25zLlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhpcyB0d2VlbiBpbnN0YW5jZSAoZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICovXG5cdHAudG8gPSBmdW5jdGlvbihwcm9wcywgZHVyYXRpb24sIGVhc2UpIHtcblx0XHRpZiAoaXNOYU4oZHVyYXRpb24pIHx8IGR1cmF0aW9uIDwgMCkgeyBkdXJhdGlvbiA9IDA7IH1cblx0XHRyZXR1cm4gdGhpcy5fYWRkU3RlcCh7ZDpkdXJhdGlvbnx8MCwgcDA6dGhpcy5fY2xvbmVQcm9wcyh0aGlzLl9jdXJRdWV1ZVByb3BzKSwgZTplYXNlLCBwMTp0aGlzLl9jbG9uZVByb3BzKHRoaXMuX2FwcGVuZFF1ZXVlUHJvcHMocHJvcHMpKX0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBRdWV1ZXMgYW4gYWN0aW9uIHRvIGNhbGwgdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgIFx0Ly93b3VsZCBjYWxsIG15RnVuY3Rpb24oKSBhZnRlciAxIHNlY29uZC5cblx0ICogICBcdG15VHdlZW4ud2FpdCgxMDAwKS5jYWxsKG15RnVuY3Rpb24pO1xuXHQgKlxuXHQgKiBAbWV0aG9kIGNhbGxcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtwYXJhbXNdLiBUaGUgcGFyYW1ldGVycyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLiBJZiB0aGlzIGlzIG9taXR0ZWQsIHRoZW4gdGhlIGZ1bmN0aW9uXG5cdCAqICAgICAgd2lsbCBiZSBjYWxsZWQgd2l0aCBhIHNpbmdsZSBwYXJhbSBwb2ludGluZyB0byB0aGlzIHR3ZWVuLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXS4gVGhlIHNjb3BlIHRvIGNhbGwgdGhlIGZ1bmN0aW9uIGluLiBJZiBvbWl0dGVkLCBpdCB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgdGFyZ2V0J3Ncblx0ICogICAgICBzY29wZS5cblx0ICogQHJldHVybiB7VHdlZW59IFRoaXMgdHdlZW4gaW5zdGFuY2UgKGZvciBjaGFpbmluZyBjYWxscykuXG5cdCAqL1xuXHRwLmNhbGwgPSBmdW5jdGlvbihjYWxsYmFjaywgcGFyYW1zLCBzY29wZSkge1xuXHRcdHJldHVybiB0aGlzLl9hZGRBY3Rpb24oe2Y6Y2FsbGJhY2ssIHA6cGFyYW1zID8gcGFyYW1zIDogW3RoaXNdLCBvOnNjb3BlID8gc2NvcGUgOiB0aGlzLl90YXJnZXR9KTtcblx0fTtcblxuXHQvLyBUT0RPOiBhZGQgY2xhcmlmaWNhdGlvbiBiZXR3ZWVuIHRoaXMgYW5kIGEgMCBkdXJhdGlvbiAudG86XG5cdC8qKlxuXHQgKiBRdWV1ZXMgYW4gYWN0aW9uIHRvIHNldCB0aGUgc3BlY2lmaWVkIHByb3BzIG9uIHRoZSBzcGVjaWZpZWQgdGFyZ2V0LiBJZiB0YXJnZXQgaXMgbnVsbCwgaXQgd2lsbCB1c2UgdGhpcyB0d2VlbidzXG5cdCAqIHRhcmdldC5cblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKlx0XHRteVR3ZWVuLndhaXQoMTAwMCkuc2V0KHt2aXNpYmxlOmZhbHNlfSxmb28pO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHNldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgVGhlIHByb3BlcnRpZXMgdG8gc2V0IChleC4gYHt2aXNpYmxlOmZhbHNlfWApLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3RhcmdldF0gVGhlIHRhcmdldCB0byBzZXQgdGhlIHByb3BlcnRpZXMgb24uIElmIG9taXR0ZWQsIHRoZXkgd2lsbCBiZSBzZXQgb24gdGhlIHR3ZWVuJ3MgdGFyZ2V0LlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhpcyB0d2VlbiBpbnN0YW5jZSAoZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICovXG5cdHAuc2V0ID0gZnVuY3Rpb24ocHJvcHMsIHRhcmdldCkge1xuXHRcdHJldHVybiB0aGlzLl9hZGRBY3Rpb24oe2Y6dGhpcy5fc2V0LCBvOnRoaXMsIHA6W3Byb3BzLCB0YXJnZXQgPyB0YXJnZXQgOiB0aGlzLl90YXJnZXRdfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFF1ZXVlcyBhbiBhY3Rpb24gdG8gcGxheSAodW5wYXVzZSkgdGhlIHNwZWNpZmllZCB0d2Vlbi4gVGhpcyBlbmFibGVzIHlvdSB0byBzZXF1ZW5jZSBtdWx0aXBsZSB0d2VlbnMuXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICpcdFx0bXlUd2Vlbi50byh7eDoxMDB9LDUwMCkucGxheShvdGhlclR3ZWVuKTtcblx0ICpcblx0ICogQG1ldGhvZCBwbGF5XG5cdCAqIEBwYXJhbSB7VHdlZW59IHR3ZWVuIFRoZSB0d2VlbiB0byBwbGF5LlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhpcyB0d2VlbiBpbnN0YW5jZSAoZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICovXG5cdHAucGxheSA9IGZ1bmN0aW9uKHR3ZWVuKSB7XG5cdFx0aWYgKCF0d2VlbikgeyB0d2VlbiA9IHRoaXM7IH1cblx0XHRyZXR1cm4gdGhpcy5jYWxsKHR3ZWVuLnNldFBhdXNlZCwgW2ZhbHNlXSwgdHdlZW4pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBRdWV1ZXMgYW4gYWN0aW9uIHRvIHBhdXNlIHRoZSBzcGVjaWZpZWQgdHdlZW4uXG5cdCAqIEBtZXRob2QgcGF1c2Vcblx0ICogQHBhcmFtIHtUd2Vlbn0gdHdlZW4gVGhlIHR3ZWVuIHRvIHBhdXNlLiBJZiBudWxsLCBpdCBwYXVzZXMgdGhpcyB0d2Vlbi5cblx0ICogQHJldHVybiB7VHdlZW59IFRoaXMgdHdlZW4gaW5zdGFuY2UgKGZvciBjaGFpbmluZyBjYWxscylcblx0ICovXG5cdHAucGF1c2UgPSBmdW5jdGlvbih0d2Vlbikge1xuXHRcdGlmICghdHdlZW4pIHsgdHdlZW4gPSB0aGlzOyB9XG5cdFx0cmV0dXJuIHRoaXMuY2FsbCh0d2Vlbi5zZXRQYXVzZWQsIFt0cnVlXSwgdHdlZW4pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZHZhbmNlcyB0aGUgdHdlZW4gdG8gYSBzcGVjaWZpZWQgcG9zaXRpb24uXG5cdCAqIEBtZXRob2Qgc2V0UG9zaXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSBwb3NpdGlvbiB0byBzZWVrIHRvIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgdXNlVGlja3MgaXMgdHJ1ZSkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYWN0aW9uc01vZGU9MV0gU3BlY2lmaWVzIGhvdyBhY3Rpb25zIGFyZSBoYW5kbGVkIChpZS4gY2FsbCwgc2V0LCBwbGF5LCBwYXVzZSk6XG5cdCAqIDx1bD5cblx0ICogICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiVHdlZW4vTk9ORTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSAoMCkgLSBydW4gbm8gYWN0aW9ucy48L2xpPlxuXHQgKiAgICAgIDxsaT57eyNjcm9zc0xpbmsgXCJUd2Vlbi9MT09QOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319ICgxKSAtIGlmIG5ldyBwb3NpdGlvbiBpcyBsZXNzIHRoYW4gb2xkLCB0aGVuIHJ1biBhbGxcblx0ICogICAgICBhY3Rpb25zIGJldHdlZW4gb2xkIGFuZCBkdXJhdGlvbiwgdGhlbiBhbGwgYWN0aW9ucyBiZXR3ZWVuIDAgYW5kIG5ldy48L2xpPlxuXHQgKiAgICAgIDxsaT57eyNjcm9zc0xpbmsgXCJUd2Vlbi9SRVZFUlNFOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319ICgyKSAtIGlmIG5ldyBwb3NpdGlvbiBpcyBsZXNzIHRoYW4gb2xkLCBydW4gYWxsXG5cdCAqICAgICAgYWN0aW9ucyBiZXR3ZWVuIHRoZW0gaW4gcmV2ZXJzZS48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdHdlZW4gaXMgY29tcGxldGUgKGllLiB0aGUgZnVsbCB0d2VlbiBoYXMgcnVuICYge3sjY3Jvc3NMaW5rIFwiVHdlZW4vbG9vcDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpcyBgZmFsc2VgKS5cblx0ICovXG5cdHAuc2V0UG9zaXRpb24gPSBmdW5jdGlvbih2YWx1ZSwgYWN0aW9uc01vZGUpIHtcblx0XHRpZiAodmFsdWUgPCAwKSB7IHZhbHVlID0gMDsgfVxuXHRcdGlmIChhY3Rpb25zTW9kZSA9PSBudWxsKSB7IGFjdGlvbnNNb2RlID0gMTsgfVxuXG5cdFx0Ly8gbm9ybWFsaXplIHBvc2l0aW9uOlxuXHRcdHZhciB0ID0gdmFsdWU7XG5cdFx0dmFyIGVuZCA9IGZhbHNlO1xuXHRcdGlmICh0ID49IHRoaXMuZHVyYXRpb24pIHtcblx0XHRcdGlmICh0aGlzLmxvb3ApIHsgdCA9IHQldGhpcy5kdXJhdGlvbjsgfVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHQgPSB0aGlzLmR1cmF0aW9uO1xuXHRcdFx0XHRlbmQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodCA9PSB0aGlzLl9wcmV2UG9zKSB7IHJldHVybiBlbmQ7IH1cblxuXG5cdFx0dmFyIHByZXZQb3MgPSB0aGlzLl9wcmV2UG9zO1xuXHRcdHRoaXMucG9zaXRpb24gPSB0aGlzLl9wcmV2UG9zID0gdDsgLy8gc2V0IHRoaXMgaW4gYWR2YW5jZSBpbiBjYXNlIGFuIGFjdGlvbiBtb2RpZmllcyBwb3NpdGlvbi5cblx0XHR0aGlzLl9wcmV2UG9zaXRpb24gPSB2YWx1ZTtcblxuXHRcdC8vIGhhbmRsZSB0d2VlbnM6XG5cdFx0aWYgKHRoaXMuX3RhcmdldCkge1xuXHRcdFx0aWYgKGVuZCkge1xuXHRcdFx0XHQvLyBhZGRyZXNzZXMgcHJvYmxlbXMgd2l0aCBhbiBlbmRpbmcgemVybyBsZW5ndGggc3RlcC5cblx0XHRcdFx0dGhpcy5fdXBkYXRlVGFyZ2V0UHJvcHMobnVsbCwxKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fc3RlcHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHQvLyBmaW5kIG91ciBuZXcgdHdlZW4gaW5kZXg6XG5cdFx0XHRcdGZvciAodmFyIGk9MCwgbD10aGlzLl9zdGVwcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX3N0ZXBzW2ldLnQgPiB0KSB7IGJyZWFrOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHN0ZXAgPSB0aGlzLl9zdGVwc1tpLTFdO1xuXHRcdFx0XHR0aGlzLl91cGRhdGVUYXJnZXRQcm9wcyhzdGVwLCh0aGlzLl9zdGVwUG9zaXRpb24gPSB0LXN0ZXAudCkvc3RlcC5kKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBydW4gYWN0aW9uczpcblx0XHRpZiAoYWN0aW9uc01vZGUgIT0gMCAmJiB0aGlzLl9hY3Rpb25zLmxlbmd0aCA+IDApIHtcblx0XHRcdGlmICh0aGlzLl91c2VUaWNrcykge1xuXHRcdFx0XHQvLyBvbmx5IHJ1biB0aGUgYWN0aW9ucyB3ZSBsYW5kZWQgb24uXG5cdFx0XHRcdHRoaXMuX3J1bkFjdGlvbnModCx0KTtcblx0XHRcdH0gZWxzZSBpZiAoYWN0aW9uc01vZGUgPT0gMSAmJiB0PHByZXZQb3MpIHtcblx0XHRcdFx0aWYgKHByZXZQb3MgIT0gdGhpcy5kdXJhdGlvbikgeyB0aGlzLl9ydW5BY3Rpb25zKHByZXZQb3MsIHRoaXMuZHVyYXRpb24pOyB9XG5cdFx0XHRcdHRoaXMuX3J1bkFjdGlvbnMoMCwgdCwgdHJ1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9ydW5BY3Rpb25zKHByZXZQb3MsIHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChlbmQpIHsgdGhpcy5zZXRQYXVzZWQodHJ1ZSk7IH1cblxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjaGFuZ2VcIik7XG5cdFx0cmV0dXJuIGVuZDtcblx0fTtcblxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhpcyB0d2VlbiBieSB0aGUgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWZgdXNlVGlja3NgIGlzIGB0cnVlYCkuXG5cdCAqIFRoaXMgaXMgbm9ybWFsbHkgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIFR3ZWVuIGVuZ2luZSAodmlhIHt7I2Nyb3NzTGluayBcIlR3ZWVuL3RpY2tcIn19e3svY3Jvc3NMaW5rfX0pLCBidXQgaXNcblx0ICogZXhwb3NlZCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCB0aWNrXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YSBUaGUgdGltZSB0byBhZHZhbmNlIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzYCBpcyBgdHJ1ZWApLlxuXHQgKi9cblx0cC50aWNrID0gZnVuY3Rpb24oZGVsdGEpIHtcblx0XHRpZiAodGhpcy5fcGF1c2VkKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuc2V0UG9zaXRpb24odGhpcy5fcHJldlBvc2l0aW9uK2RlbHRhKTtcblx0fTtcblxuXHQvKipcblx0ICogUGF1c2VzIG9yIHBsYXlzIHRoaXMgdHdlZW4uXG5cdCAqIEBtZXRob2Qgc2V0UGF1c2VkXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ZhbHVlPXRydWVdIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0d2VlbiBzaG91bGQgYmUgcGF1c2VkIChgdHJ1ZWApIG9yIHBsYXllZCAoYGZhbHNlYCkuXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBUaGlzIHR3ZWVuIGluc3RhbmNlIChmb3IgY2hhaW5pbmcgY2FsbHMpXG5cdCAqL1xuXHRwLnNldFBhdXNlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMuX3BhdXNlZCA9PT0gISF2YWx1ZSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHRoaXMuX3BhdXNlZCA9ICEhdmFsdWU7XG5cdFx0VHdlZW4uX3JlZ2lzdGVyKHRoaXMsICF2YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0Ly8gdGlueSBhcGkgKHByaW1hcmlseSBmb3IgdG9vbCBvdXRwdXQpOlxuXHRwLncgPSBwLndhaXQ7XG5cdHAudCA9IHAudG87XG5cdHAuYyA9IHAuY2FsbDtcblx0cC5zID0gcC5zZXQ7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1R3ZWVuXVwiO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyhcIlR3ZWVuIGNhbiBub3QgYmUgY2xvbmVkLlwiKVxuXHR9O1xuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF91cGRhdGVUYXJnZXRQcm9wc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gc3RlcFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmF0aW9cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fdXBkYXRlVGFyZ2V0UHJvcHMgPSBmdW5jdGlvbihzdGVwLCByYXRpbykge1xuXHRcdHZhciBwMCxwMSx2LHYwLHYxLGFycjtcblx0XHRpZiAoIXN0ZXAgJiYgcmF0aW8gPT0gMSkge1xuXHRcdFx0Ly8gR0RTOiB3aGVuIGRvZXMgdGhpcyBydW4/IEp1c3QgYXQgdGhlIHZlcnkgZW5kPyBTaG91bGRuJ3QuXG5cdFx0XHR0aGlzLnBhc3NpdmUgPSBmYWxzZTtcblx0XHRcdHAwID0gcDEgPSB0aGlzLl9jdXJRdWV1ZVByb3BzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBhc3NpdmUgPSAhIXN0ZXAudjtcblx0XHRcdGlmICh0aGlzLnBhc3NpdmUpIHsgcmV0dXJuOyB9IC8vIGRvbid0IHVwZGF0ZSBwcm9wcy5cblx0XHRcdC8vIGFwcGx5IGVhc2UgdG8gcmF0aW8uXG5cdFx0XHRpZiAoc3RlcC5lKSB7IHJhdGlvID0gc3RlcC5lKHJhdGlvLDAsMSwxKTsgfVxuXHRcdFx0cDAgPSBzdGVwLnAwO1xuXHRcdFx0cDEgPSBzdGVwLnAxO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIG4gaW4gdGhpcy5faW5pdFF1ZXVlUHJvcHMpIHtcblx0XHRcdGlmICgodjAgPSBwMFtuXSkgPT0gbnVsbCkgeyBwMFtuXSA9IHYwID0gdGhpcy5faW5pdFF1ZXVlUHJvcHNbbl07IH1cblx0XHRcdGlmICgodjEgPSBwMVtuXSkgPT0gbnVsbCkgeyBwMVtuXSA9IHYxID0gdjA7IH1cblx0XHRcdGlmICh2MCA9PSB2MSB8fCByYXRpbyA9PSAwIHx8IHJhdGlvID09IDEgfHwgKHR5cGVvZih2MCkgIT0gXCJudW1iZXJcIikpIHtcblx0XHRcdFx0Ly8gbm8gaW50ZXJwb2xhdGlvbiAtIGVpdGhlciBhdCBzdGFydCwgZW5kLCB2YWx1ZXMgZG9uJ3QgY2hhbmdlLCBvciB0aGUgdmFsdWUgaXMgbm9uLW51bWVyaWMuXG5cdFx0XHRcdHYgPSByYXRpbyA9PSAxID8gdjEgOiB2MDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHYgPSB2MCsodjEtdjApKnJhdGlvO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaWdub3JlID0gZmFsc2U7XG5cdFx0XHRpZiAoYXJyID0gVHdlZW4uX3BsdWdpbnNbbl0pIHtcblx0XHRcdFx0Zm9yICh2YXIgaT0wLGw9YXJyLmxlbmd0aDtpPGw7aSsrKSB7XG5cdFx0XHRcdFx0dmFyIHYyID0gYXJyW2ldLnR3ZWVuKHRoaXMsIG4sIHYsIHAwLCBwMSwgcmF0aW8sICEhc3RlcCYmcDA9PXAxLCAhc3RlcCk7XG5cdFx0XHRcdFx0aWYgKHYyID09IFR3ZWVuLklHTk9SRSkgeyBpZ25vcmUgPSB0cnVlOyB9XG5cdFx0XHRcdFx0ZWxzZSB7IHYgPSB2MjsgfVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWlnbm9yZSkgeyB0aGlzLl90YXJnZXRbbl0gPSB2OyB9XG5cdFx0fVxuXG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3J1bkFjdGlvbnNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0UG9zXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBlbmRQb3Ncblx0ICogQHBhcmFtIHtCb29sZWFufSBpbmNsdWRlU3RhcnRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fcnVuQWN0aW9ucyA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBlbmRQb3MsIGluY2x1ZGVTdGFydCkge1xuXHRcdHZhciBzUG9zID0gc3RhcnRQb3M7XG5cdFx0dmFyIGVQb3MgPSBlbmRQb3M7XG5cdFx0dmFyIGkgPSAtMTtcblx0XHR2YXIgaiA9IHRoaXMuX2FjdGlvbnMubGVuZ3RoO1xuXHRcdHZhciBrID0gMTtcblx0XHRpZiAoc3RhcnRQb3MgPiBlbmRQb3MpIHtcblx0XHRcdC8vIHJ1bm5pbmcgYmFja3dhcmRzLCBmbGlwIGV2ZXJ5dGhpbmc6XG5cdFx0XHRzUG9zID0gZW5kUG9zO1xuXHRcdFx0ZVBvcyA9IHN0YXJ0UG9zO1xuXHRcdFx0aSA9IGo7XG5cdFx0XHRqID0gayA9IC0xO1xuXHRcdH1cblx0XHR3aGlsZSAoKGkrPWspICE9IGopIHtcblx0XHRcdHZhciBhY3Rpb24gPSB0aGlzLl9hY3Rpb25zW2ldO1xuXHRcdFx0dmFyIHBvcyA9IGFjdGlvbi50O1xuXHRcdFx0aWYgKHBvcyA9PSBlUG9zIHx8IChwb3MgPiBzUG9zICYmIHBvcyA8IGVQb3MpIHx8IChpbmNsdWRlU3RhcnQgJiYgcG9zID09IHN0YXJ0UG9zKSApIHtcblx0XHRcdFx0YWN0aW9uLmYuYXBwbHkoYWN0aW9uLm8sIGFjdGlvbi5wKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2FwcGVuZFF1ZXVlUHJvcHNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fYXBwZW5kUXVldWVQcm9wcyA9IGZ1bmN0aW9uKG8pIHtcblx0XHR2YXIgYXJyLG9sZFZhbHVlLGksIGwsIGluamVjdFByb3BzO1xuXHRcdGZvciAodmFyIG4gaW4gbykge1xuXHRcdFx0aWYgKHRoaXMuX2luaXRRdWV1ZVByb3BzW25dID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0b2xkVmFsdWUgPSB0aGlzLl90YXJnZXRbbl07XG5cblx0XHRcdFx0Ly8gaW5pdCBwbHVnaW5zOlxuXHRcdFx0XHRpZiAoYXJyID0gVHdlZW4uX3BsdWdpbnNbbl0pIHtcblx0XHRcdFx0XHRmb3IgKGk9MCxsPWFyci5sZW5ndGg7aTxsO2krKykge1xuXHRcdFx0XHRcdFx0b2xkVmFsdWUgPSBhcnJbaV0uaW5pdCh0aGlzLCBuLCBvbGRWYWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2luaXRRdWV1ZVByb3BzW25dID0gdGhpcy5fY3VyUXVldWVQcm9wc1tuXSA9IChvbGRWYWx1ZT09PXVuZGVmaW5lZCkgPyBudWxsIDogb2xkVmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbGRWYWx1ZSA9IHRoaXMuX2N1clF1ZXVlUHJvcHNbbl07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgbiBpbiBvKSB7XG5cdFx0XHRvbGRWYWx1ZSA9IHRoaXMuX2N1clF1ZXVlUHJvcHNbbl07XG5cdFx0XHRpZiAoYXJyID0gVHdlZW4uX3BsdWdpbnNbbl0pIHtcblx0XHRcdFx0aW5qZWN0UHJvcHMgPSBpbmplY3RQcm9wc3x8e307XG5cdFx0XHRcdGZvciAoaT0wLCBsPWFyci5sZW5ndGg7aTxsO2krKykge1xuXHRcdFx0XHRcdC8vIFRPRE86IHJlbW92ZSB0aGUgY2hlY2sgZm9yIC5zdGVwIGluIHRoZSBuZXh0IHZlcnNpb24uIEl0J3MgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cdFx0XHRcdFx0aWYgKGFycltpXS5zdGVwKSB7IGFycltpXS5zdGVwKHRoaXMsIG4sIG9sZFZhbHVlLCBvW25dLCBpbmplY3RQcm9wcyk7IH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY3VyUXVldWVQcm9wc1tuXSA9IG9bbl07XG5cdFx0fVxuXHRcdGlmIChpbmplY3RQcm9wcykgeyB0aGlzLl9hcHBlbmRRdWV1ZVByb3BzKGluamVjdFByb3BzKTsgfVxuXHRcdHJldHVybiB0aGlzLl9jdXJRdWV1ZVByb3BzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9jbG9uZVByb3BzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9jbG9uZVByb3BzID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHR2YXIgbyA9IHt9O1xuXHRcdGZvciAodmFyIG4gaW4gcHJvcHMpIHtcblx0XHRcdG9bbl0gPSBwcm9wc1tuXTtcblx0XHR9XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2FkZFN0ZXBcblx0ICogQHBhcmFtIHtPYmplY3R9IG9cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fYWRkU3RlcCA9IGZ1bmN0aW9uKG8pIHtcblx0XHRpZiAoby5kID4gMCkge1xuXHRcdFx0dGhpcy5fc3RlcHMucHVzaChvKTtcblx0XHRcdG8udCA9IHRoaXMuZHVyYXRpb247XG5cdFx0XHR0aGlzLmR1cmF0aW9uICs9IG8uZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2FkZEFjdGlvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gb1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9hZGRBY3Rpb24gPSBmdW5jdGlvbihvKSB7XG5cdFx0by50ID0gdGhpcy5kdXJhdGlvbjtcblx0XHR0aGlzLl9hY3Rpb25zLnB1c2gobyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3NldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2V0ID0gZnVuY3Rpb24ocHJvcHMsIG8pIHtcblx0XHRmb3IgKHZhciBuIGluIHByb3BzKSB7XG5cdFx0XHRvW25dID0gcHJvcHNbbl07XG5cdFx0fVxuXHR9O1xuXG5cdGNyZWF0ZWpzLlR3ZWVuID0gY3JlYXRlanMucHJvbW90ZShUd2VlbiwgXCJFdmVudERpc3BhdGNoZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUaW1lbGluZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFxuXG4vLyBjb25zdHJ1Y3Rvclx0XG5cdC8qKlxuXHQgKiBUaGUgVGltZWxpbmUgY2xhc3Mgc3luY2hyb25pemVzIG11bHRpcGxlIHR3ZWVucyBhbmQgYWxsb3dzIHRoZW0gdG8gYmUgY29udHJvbGxlZCBhcyBhIGdyb3VwLiBQbGVhc2Ugbm90ZSB0aGF0IGlmIGFcblx0ICogdGltZWxpbmUgaXMgbG9vcGluZywgdGhlIHR3ZWVucyBvbiBpdCBtYXkgYXBwZWFyIHRvIGxvb3AgZXZlbiBpZiB0aGUgXCJsb29wXCIgcHJvcGVydHkgb2YgdGhlIHR3ZWVuIGlzIGZhbHNlLlxuXHQgKiBAY2xhc3MgVGltZWxpbmVcblx0ICogQHBhcmFtIHtBcnJheX0gdHdlZW5zIEFuIGFycmF5IG9mIFR3ZWVucyB0byBhZGQgdG8gdGhpcyB0aW1lbGluZS4gU2VlIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2FkZFR3ZWVuXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBtb3JlIGluZm8uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBsYWJlbHMgQW4gb2JqZWN0IGRlZmluaW5nIGxhYmVscyBmb3IgdXNpbmcge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX0ve3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvZ290b0FuZFN0b3BcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9zZXRMYWJlbHNcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBUaGUgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIHRvIGFwcGx5IHRvIHRoaXMgdHdlZW4gaW5zdGFuY2UgKGV4LiBge2xvb3A6dHJ1ZX1gKS4gQWxsIHByb3BlcnRpZXNcblx0ICogZGVmYXVsdCB0byBmYWxzZS4gU3VwcG9ydGVkIHByb3BzIGFyZTo8VUw+XG5cdCAqICAgIDxMST4gbG9vcDogc2V0cyB0aGUgbG9vcCBwcm9wZXJ0eSBvbiB0aGlzIHR3ZWVuLjwvTEk+XG5cdCAqICAgIDxMST4gdXNlVGlja3M6IHVzZXMgdGlja3MgZm9yIGFsbCBkdXJhdGlvbnMgaW5zdGVhZCBvZiBtaWxsaXNlY29uZHMuPC9MST5cblx0ICogICAgPExJPiBpZ25vcmVHbG9iYWxQYXVzZTogc2V0cyB0aGUgaWdub3JlR2xvYmFsUGF1c2UgcHJvcGVydHkgb24gdGhpcyB0d2Vlbi48L0xJPlxuXHQgKiAgICA8TEk+IHBhdXNlZDogaW5kaWNhdGVzIHdoZXRoZXIgdG8gc3RhcnQgdGhlIHR3ZWVuIHBhdXNlZC48L0xJPlxuXHQgKiAgICA8TEk+IHBvc2l0aW9uOiBpbmRpY2F0ZXMgdGhlIGluaXRpYWwgcG9zaXRpb24gZm9yIHRoaXMgdGltZWxpbmUuPC9MST5cblx0ICogICAgPExJPiBvbkNoYW5nZTogc3BlY2lmaWVzIGEgbGlzdGVuZXIgdG8gYWRkIGZvciB0aGUge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvY2hhbmdlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50LjwvTEk+XG5cdCAqIDwvVUw+XG5cdCAqIEBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBUaW1lbGluZSh0d2VlbnMsIGxhYmVscywgcHJvcHMpIHtcblx0XHR0aGlzLkV2ZW50RGlzcGF0Y2hlcl9jb25zdHJ1Y3RvcigpO1xuXG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIENhdXNlcyB0aGlzIHRpbWVsaW5lIHRvIGNvbnRpbnVlIHBsYXlpbmcgd2hlbiBhIGdsb2JhbCBwYXVzZSBpcyBhY3RpdmUuXG5cdFx0ICogQHByb3BlcnR5IGlnbm9yZUdsb2JhbFBhdXNlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqKi9cblx0XHR0aGlzLmlnbm9yZUdsb2JhbFBhdXNlID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgdG90YWwgZHVyYXRpb24gb2YgdGhpcyB0aW1lbGluZSBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrcyBgaXMgYHRydWVgKS4gVGhpcyB2YWx1ZSBpcyB1c3VhbGx5XG5cdFx0ICogYXV0b21hdGljYWxseSB1cGRhdGVkIGFzIHlvdSBtb2RpZnkgdGhlIHRpbWVsaW5lLiBTZWUge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvdXBkYXRlRHVyYXRpb25cIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgZHVyYXRpb25cblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMuZHVyYXRpb24gPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogSWYgdHJ1ZSwgdGhlIHRpbWVsaW5lIHdpbGwgbG9vcCB3aGVuIGl0IHJlYWNoZXMgdGhlIGVuZC4gQ2FuIGJlIHNldCB2aWEgdGhlIHByb3BzIHBhcmFtLlxuXHRcdCAqIEBwcm9wZXJ0eSBsb29wXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqKi9cblx0XHR0aGlzLmxvb3AgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IG5vcm1hbGl6ZWQgcG9zaXRpb24gb2YgdGhlIHRpbWVsaW5lLiBUaGlzIHdpbGwgYWx3YXlzIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZFxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2R1cmF0aW9uOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIENoYW5naW5nIHRoaXMgcHJvcGVydHkgZGlyZWN0bHkgd2lsbCBoYXZlIG5vIGVmZmVjdC5cblx0XHQgKiBAcHJvcGVydHkgcG9zaXRpb25cblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5wb3NpdGlvbiA9IG51bGw7XG5cblx0XHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9wYXVzZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfdHdlZW5zXG5cdFx0ICogQHR5cGUgQXJyYXlbVHdlZW5dXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl90d2VlbnMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbGFiZWxzXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9sYWJlbHMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9sYWJlbExpc3Rcblx0XHQgKiBAdHlwZSBBcnJheVtPYmplY3RdXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9sYWJlbExpc3QgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9wcmV2UG9zaXRpb25cblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9wcmV2UG9zaXRpb24gPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9wcmV2UG9zXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgLTFcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3ByZXZQb3MgPSAtMTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfdXNlVGlja3Ncblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3VzZVRpY2tzID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRpbWVsaW5lIGlzIGN1cnJlbnRseSByZWdpc3RlcmVkIHdpdGggVHdlZW4uXG5cdFx0ICogQHByb3BlcnR5IF9yZWdpc3RlcmVkXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fcmVnaXN0ZXJlZCA9IGZhbHNlO1xuXG5cblx0XHRpZiAocHJvcHMpIHtcblx0XHRcdHRoaXMuX3VzZVRpY2tzID0gcHJvcHMudXNlVGlja3M7XG5cdFx0XHR0aGlzLmxvb3AgPSBwcm9wcy5sb29wO1xuXHRcdFx0dGhpcy5pZ25vcmVHbG9iYWxQYXVzZSA9IHByb3BzLmlnbm9yZUdsb2JhbFBhdXNlO1xuXHRcdFx0cHJvcHMub25DaGFuZ2UmJnRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBwcm9wcy5vbkNoYW5nZSk7XG5cdFx0fVxuXHRcdGlmICh0d2VlbnMpIHsgdGhpcy5hZGRUd2Vlbi5hcHBseSh0aGlzLCB0d2VlbnMpOyB9XG5cdFx0dGhpcy5zZXRMYWJlbHMobGFiZWxzKTtcblx0XHRpZiAocHJvcHMmJnByb3BzLnBhdXNlZCkgeyB0aGlzLl9wYXVzZWQ9dHJ1ZTsgfVxuXHRcdGVsc2UgeyBjcmVhdGVqcy5Ud2Vlbi5fcmVnaXN0ZXIodGhpcyx0cnVlKTsgfVxuXHRcdGlmIChwcm9wcyYmcHJvcHMucG9zaXRpb24hPW51bGwpIHsgdGhpcy5zZXRQb3NpdGlvbihwcm9wcy5wb3NpdGlvbiwgY3JlYXRlanMuVHdlZW4uTk9ORSk7IH1cblx0XHRcblx0fTtcblx0XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFRpbWVsaW5lLCBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cdFxuLy8gZXZlbnRzOlxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW5ldmVyIHRoZSB0aW1lbGluZSdzIHBvc2l0aW9uIGNoYW5nZXMuXG5cdCAqIEBldmVudCBjaGFuZ2Vcblx0ICogQHNpbmNlIDAuNS4wXG5cdCAqKi9cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEFkZHMgb25lIG9yIG1vcmUgdHdlZW5zIChvciB0aW1lbGluZXMpIHRvIHRoaXMgdGltZWxpbmUuIFRoZSB0d2VlbnMgd2lsbCBiZSBwYXVzZWQgKHRvIHJlbW92ZSB0aGVtIGZyb20gdGhlXG5cdCAqIG5vcm1hbCB0aWNraW5nIHN5c3RlbSkgYW5kIG1hbmFnZWQgYnkgdGhpcyB0aW1lbGluZS4gQWRkaW5nIGEgdHdlZW4gdG8gbXVsdGlwbGUgdGltZWxpbmVzIHdpbGwgcmVzdWx0IGluXG5cdCAqIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLlxuXHQgKiBAbWV0aG9kIGFkZFR3ZWVuXG5cdCAqIEBwYXJhbSB7VHdlZW59IC4uLnR3ZWVuIFRoZSB0d2VlbihzKSB0byBhZGQuIEFjY2VwdHMgbXVsdGlwbGUgYXJndW1lbnRzLlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhlIGZpcnN0IHR3ZWVuIHRoYXQgd2FzIHBhc3NlZCBpbi5cblx0ICoqL1xuXHRwLmFkZFR3ZWVuID0gZnVuY3Rpb24odHdlZW4pIHtcblx0XHR2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0aWYgKGwgPiAxKSB7XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7IHRoaXMuYWRkVHdlZW4oYXJndW1lbnRzW2ldKTsgfVxuXHRcdFx0cmV0dXJuIGFyZ3VtZW50c1swXTtcblx0XHR9IGVsc2UgaWYgKGwgPT0gMCkgeyByZXR1cm4gbnVsbDsgfVxuXHRcdHRoaXMucmVtb3ZlVHdlZW4odHdlZW4pO1xuXHRcdHRoaXMuX3R3ZWVucy5wdXNoKHR3ZWVuKTtcblx0XHR0d2Vlbi5zZXRQYXVzZWQodHJ1ZSk7XG5cdFx0dHdlZW4uX3BhdXNlZCA9IGZhbHNlO1xuXHRcdHR3ZWVuLl91c2VUaWNrcyA9IHRoaXMuX3VzZVRpY2tzO1xuXHRcdGlmICh0d2Vlbi5kdXJhdGlvbiA+IHRoaXMuZHVyYXRpb24pIHsgdGhpcy5kdXJhdGlvbiA9IHR3ZWVuLmR1cmF0aW9uOyB9XG5cdFx0aWYgKHRoaXMuX3ByZXZQb3MgPj0gMCkgeyB0d2Vlbi5zZXRQb3NpdGlvbih0aGlzLl9wcmV2UG9zLCBjcmVhdGVqcy5Ud2Vlbi5OT05FKTsgfVxuXHRcdHJldHVybiB0d2Vlbjtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBvbmUgb3IgbW9yZSB0d2VlbnMgZnJvbSB0aGlzIHRpbWVsaW5lLlxuXHQgKiBAbWV0aG9kIHJlbW92ZVR3ZWVuXG5cdCAqIEBwYXJhbSB7VHdlZW59IC4uLnR3ZWVuIFRoZSB0d2VlbihzKSB0byByZW1vdmUuIEFjY2VwdHMgbXVsdGlwbGUgYXJndW1lbnRzLlxuXHQgKiBAcmV0dXJuIEJvb2xlYW4gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIG9mIHRoZSB0d2VlbnMgd2VyZSBzdWNjZXNzZnVsbHkgcmVtb3ZlZC5cblx0ICoqL1xuXHRwLnJlbW92ZVR3ZWVuID0gZnVuY3Rpb24odHdlZW4pIHtcblx0XHR2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0aWYgKGwgPiAxKSB7XG5cdFx0XHR2YXIgZ29vZCA9IHRydWU7XG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7IGdvb2QgPSBnb29kICYmIHRoaXMucmVtb3ZlVHdlZW4oYXJndW1lbnRzW2ldKTsgfVxuXHRcdFx0cmV0dXJuIGdvb2Q7XG5cdFx0fSBlbHNlIGlmIChsID09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0XHR2YXIgdHdlZW5zID0gdGhpcy5fdHdlZW5zO1xuXHRcdHZhciBpID0gdHdlZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRpZiAodHdlZW5zW2ldID09IHR3ZWVuKSB7XG5cdFx0XHRcdHR3ZWVucy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdGlmICh0d2Vlbi5kdXJhdGlvbiA+PSB0aGlzLmR1cmF0aW9uKSB7IHRoaXMudXBkYXRlRHVyYXRpb24oKTsgfVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGRzIGEgbGFiZWwgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319L3t7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGFkZExhYmVsXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBUaGUgbGFiZWwgbmFtZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0aGlzIGxhYmVsIHJlcHJlc2VudHMuXG5cdCAqKi9cblx0cC5hZGRMYWJlbCA9IGZ1bmN0aW9uKGxhYmVsLCBwb3NpdGlvbikge1xuXHRcdHRoaXMuX2xhYmVsc1tsYWJlbF0gPSBwb3NpdGlvbjtcblx0XHR2YXIgbGlzdCA9IHRoaXMuX2xhYmVsTGlzdDtcblx0XHRpZiAobGlzdCkge1xuXHRcdFx0Zm9yICh2YXIgaT0gMCxsPWxpc3QubGVuZ3RoOyBpPGw7IGkrKykgeyBpZiAocG9zaXRpb24gPCBsaXN0W2ldLnBvc2l0aW9uKSB7IGJyZWFrOyB9IH1cblx0XHRcdGxpc3Quc3BsaWNlKGksIDAsIHtsYWJlbDpsYWJlbCwgcG9zaXRpb246cG9zaXRpb259KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIERlZmluZXMgbGFiZWxzIGZvciB1c2Ugd2l0aCBnb3RvQW5kUGxheS9TdG9wLiBPdmVyd3JpdGVzIGFueSBwcmV2aW91c2x5IHNldCBsYWJlbHMuXG5cdCAqIEBtZXRob2Qgc2V0TGFiZWxzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvIEFuIG9iamVjdCBkZWZpbmluZyBsYWJlbHMgZm9yIHVzaW5nIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2dvdG9BbmRQbGF5XCJ9fXt7L2Nyb3NzTGlua319L3t7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGluIHRoZSBmb3JtIGB7bGFiZWxOYW1lOnRpbWV9YCB3aGVyZSB0aW1lIGlzIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzYCBpcyBgdHJ1ZWApLlxuXHQgKiovXG5cdHAuc2V0TGFiZWxzID0gZnVuY3Rpb24obykge1xuXHRcdHRoaXMuX2xhYmVscyA9IG8gPyAgbyA6IHt9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGxhYmVscyBkZWZpbmVkIG9uIHRoaXMgdGltZWxpbmUuXG5cdCAqIEBtZXRob2QgZ2V0TGFiZWxzXG5cdCAqIEByZXR1cm4ge0FycmF5W09iamVjdF19IEEgc29ydGVkIGFycmF5IG9mIG9iamVjdHMgd2l0aCBsYWJlbCBhbmQgcG9zaXRpb24gcHJvcGVydGllcy5cblx0ICoqL1xuXHRwLmdldExhYmVscyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsaXN0ID0gdGhpcy5fbGFiZWxMaXN0O1xuXHRcdGlmICghbGlzdCkge1xuXHRcdFx0bGlzdCA9IHRoaXMuX2xhYmVsTGlzdCA9IFtdO1xuXHRcdFx0dmFyIGxhYmVscyA9IHRoaXMuX2xhYmVscztcblx0XHRcdGZvciAodmFyIG4gaW4gbGFiZWxzKSB7XG5cdFx0XHRcdGxpc3QucHVzaCh7bGFiZWw6biwgcG9zaXRpb246bGFiZWxzW25dfSk7XG5cdFx0XHR9XG5cdFx0XHRsaXN0LnNvcnQoZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYS5wb3NpdGlvbi0gYi5wb3NpdGlvbjsgfSk7XG5cdFx0fVxuXHRcdHJldHVybiBsaXN0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBsYWJlbCBvbiBvciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGN1cnJlbnQgcG9zaXRpb24uIEZvciBleGFtcGxlLCBnaXZlbiBhIHRpbWVsaW5lIHdpdGhcblx0ICogdHdvIGxhYmVscywgXCJmaXJzdFwiIG9uIGZyYW1lIGluZGV4IDQsIGFuZCBcInNlY29uZFwiIG9uIGZyYW1lIDgsIGdldEN1cnJlbnRMYWJlbCB3b3VsZCByZXR1cm46XG5cdCAqIDxVTD5cblx0ICogXHRcdDxMST5udWxsIGlmIHRoZSBjdXJyZW50IHBvc2l0aW9uIGlzIDIuPC9MST5cblx0ICogXHRcdDxMST5cImZpcnN0XCIgaWYgdGhlIGN1cnJlbnQgcG9zaXRpb24gaXMgNC48L0xJPlxuXHQgKiBcdFx0PExJPlwiZmlyc3RcIiBpZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpcyA3LjwvTEk+XG5cdCAqIFx0XHQ8TEk+XCJzZWNvbmRcIiBpZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpcyAxNS48L0xJPlxuXHQgKiA8L1VMPlxuXHQgKiBAbWV0aG9kIGdldEN1cnJlbnRMYWJlbFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGxhYmVsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gbGFiZWxcblx0ICoqL1xuXHRwLmdldEN1cnJlbnRMYWJlbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuXHRcdHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uO1xuXHRcdHZhciBsID0gbGFiZWxzLmxlbmd0aDtcblx0XHRpZiAobCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGk8bDsgaSsrKSB7IGlmIChwb3MgPCBsYWJlbHNbaV0ucG9zaXRpb24pIHsgYnJlYWs7IH0gfVxuXHRcdFx0cmV0dXJuIChpPT0wKSA/IG51bGwgOiBsYWJlbHNbaS0xXS5sYWJlbDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVucGF1c2VzIHRoaXMgdGltZWxpbmUgYW5kIGp1bXBzIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gb3IgbGFiZWwuXG5cdCAqIEBtZXRob2QgZ290b0FuZFBsYXlcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBwb3NpdGlvbk9yTGFiZWwgVGhlIHBvc2l0aW9uIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzYCBpcyBgdHJ1ZWApXG5cdCAqIG9yIGxhYmVsIHRvIGp1bXAgdG8uXG5cdCAqKi9cblx0cC5nb3RvQW5kUGxheSA9IGZ1bmN0aW9uKHBvc2l0aW9uT3JMYWJlbCkge1xuXHRcdHRoaXMuc2V0UGF1c2VkKGZhbHNlKTtcblx0XHR0aGlzLl9nb3RvKHBvc2l0aW9uT3JMYWJlbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhdXNlcyB0aGlzIHRpbWVsaW5lIGFuZCBqdW1wcyB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIG9yIGxhYmVsLlxuXHQgKiBAbWV0aG9kIGdvdG9BbmRTdG9wXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gcG9zaXRpb25PckxhYmVsIFRoZSBwb3NpdGlvbiBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgYHRydWVgKSBvciBsYWJlbFxuXHQgKiB0byBqdW1wIHRvLlxuXHQgKiovXG5cdHAuZ290b0FuZFN0b3AgPSBmdW5jdGlvbihwb3NpdGlvbk9yTGFiZWwpIHtcblx0XHR0aGlzLnNldFBhdXNlZCh0cnVlKTtcblx0XHR0aGlzLl9nb3RvKHBvc2l0aW9uT3JMYWJlbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoZSB0aW1lbGluZSB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuXHQgKiBAbWV0aG9kIHNldFBvc2l0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBUaGUgcG9zaXRpb24gdG8gc2VlayB0byBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgYHRydWVgKS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthY3Rpb25zTW9kZV0gcGFyYW1ldGVyIHNwZWNpZnlpbmcgaG93IGFjdGlvbnMgYXJlIGhhbmRsZWQuIFNlZSB0aGUgVHdlZW4ge3sjY3Jvc3NMaW5rIFwiVHdlZW4vc2V0UG9zaXRpb25cIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kIGZvciBtb3JlIGRldGFpbHMuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB0aW1lbGluZSBpcyBjb21wbGV0ZSAoaWUuIHRoZSBmdWxsIHRpbWVsaW5lIGhhcyBydW4gJiB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9sb29wOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGlzIGBmYWxzZWApLlxuXHQgKiovXG5cdHAuc2V0UG9zaXRpb24gPSBmdW5jdGlvbih2YWx1ZSwgYWN0aW9uc01vZGUpIHtcblx0XHR2YXIgdCA9IHRoaXMuX2NhbGNQb3NpdGlvbih2YWx1ZSk7XG5cdFx0dmFyIGVuZCA9ICF0aGlzLmxvb3AgJiYgdmFsdWUgPj0gdGhpcy5kdXJhdGlvbjtcblx0XHRpZiAodCA9PSB0aGlzLl9wcmV2UG9zKSB7IHJldHVybiBlbmQ7IH1cblx0XHR0aGlzLl9wcmV2UG9zaXRpb24gPSB2YWx1ZTtcblx0XHR0aGlzLnBvc2l0aW9uID0gdGhpcy5fcHJldlBvcyA9IHQ7IC8vIGluIGNhc2UgYW4gYWN0aW9uIGNoYW5nZXMgdGhlIGN1cnJlbnQgZnJhbWUuXG5cdFx0Zm9yICh2YXIgaT0wLCBsPXRoaXMuX3R3ZWVucy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR0aGlzLl90d2VlbnNbaV0uc2V0UG9zaXRpb24odCwgYWN0aW9uc01vZGUpO1xuXHRcdFx0aWYgKHQgIT0gdGhpcy5fcHJldlBvcykgeyByZXR1cm4gZmFsc2U7IH0gLy8gYW4gYWN0aW9uIGNoYW5nZWQgdGhpcyB0aW1lbGluZSdzIHBvc2l0aW9uLlxuXHRcdH1cblx0XHRpZiAoZW5kKSB7IHRoaXMuc2V0UGF1c2VkKHRydWUpOyB9XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiY2hhbmdlXCIpO1xuXHRcdHJldHVybiBlbmQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhdXNlcyBvciBwbGF5cyB0aGlzIHRpbWVsaW5lLlxuXHQgKiBAbWV0aG9kIHNldFBhdXNlZFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0d2VlbiBzaG91bGQgYmUgcGF1c2VkIChgdHJ1ZWApIG9yIHBsYXllZCAoYGZhbHNlYCkuXG5cdCAqKi9cblx0cC5zZXRQYXVzZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHRoaXMuX3BhdXNlZCA9ICEhdmFsdWU7IFxuXHRcdGNyZWF0ZWpzLlR3ZWVuLl9yZWdpc3Rlcih0aGlzLCAhdmFsdWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZWNhbGN1bGF0ZXMgdGhlIGR1cmF0aW9uIG9mIHRoZSB0aW1lbGluZS4gVGhlIGR1cmF0aW9uIGlzIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCB3aGVuIHR3ZWVucyBhcmUgYWRkZWQgb3IgcmVtb3ZlZCxcblx0ICogYnV0IHRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBpZiB5b3UgbW9kaWZ5IGEgdHdlZW4gYWZ0ZXIgaXQgd2FzIGFkZGVkIHRvIHRoZSB0aW1lbGluZS5cblx0ICogQG1ldGhvZCB1cGRhdGVEdXJhdGlvblxuXHQgKiovXG5cdHAudXBkYXRlRHVyYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmR1cmF0aW9uID0gMDtcblx0XHRmb3IgKHZhciBpPTAsbD10aGlzLl90d2VlbnMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5fdHdlZW5zW2ldO1xuXHRcdFx0aWYgKHR3ZWVuLmR1cmF0aW9uID4gdGhpcy5kdXJhdGlvbikgeyB0aGlzLmR1cmF0aW9uID0gdHdlZW4uZHVyYXRpb247IH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoaXMgdGltZWxpbmUgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZSBpbiBtaWxsaXNlY29uZHMgKG9yIHRpY2tzIGlmIGB1c2VUaWNrc2AgaXMgYHRydWVgKS5cblx0ICogVGhpcyBpcyBub3JtYWxseSBjYWxsZWQgYXV0b21hdGljYWxseSBieSB0aGUgVHdlZW4gZW5naW5lICh2aWEgdGhlIHt7I2Nyb3NzTGluayBcIlR3ZWVuL3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQpLCBidXQgaXMgZXhwb3NlZCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCB0aWNrXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YSBUaGUgdGltZSB0byBhZHZhbmNlIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgdXNlVGlja3MgaXMgdHJ1ZSkuXG5cdCAqKi9cblx0cC50aWNrID0gZnVuY3Rpb24oZGVsdGEpIHtcblx0XHR0aGlzLnNldFBvc2l0aW9uKHRoaXMuX3ByZXZQb3NpdGlvbitkZWx0YSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIElmIGEgbnVtZXJpYyBwb3NpdGlvbiBpcyBwYXNzZWQsIGl0IGlzIHJldHVybmVkIHVuY2hhbmdlZC4gSWYgYSBzdHJpbmcgaXMgcGFzc2VkLCB0aGUgcG9zaXRpb24gb2YgdGhlXG5cdCAqIGNvcnJlc3BvbmRpbmcgZnJhbWUgbGFiZWwgd2lsbCBiZSByZXR1cm5lZCwgb3IgYG51bGxgIGlmIGEgbWF0Y2hpbmcgbGFiZWwgaXMgbm90IGRlZmluZWQuXG5cdCAqIEBtZXRob2QgcmVzb2x2ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHBvc2l0aW9uT3JMYWJlbCBBIG51bWVyaWMgcG9zaXRpb24gdmFsdWUgb3IgbGFiZWwgc3RyaW5nLlxuXHQgKiovXG5cdHAucmVzb2x2ZSA9IGZ1bmN0aW9uKHBvc2l0aW9uT3JMYWJlbCkge1xuXHRcdHZhciBwb3MgPSBOdW1iZXIocG9zaXRpb25PckxhYmVsKTtcblx0XHRpZiAoaXNOYU4ocG9zKSkgeyBwb3MgPSB0aGlzLl9sYWJlbHNbcG9zaXRpb25PckxhYmVsXTsgfVxuXHRcdHJldHVybiBwb3M7XG5cdH07XG5cblx0LyoqXG5cdCogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0KiBAbWV0aG9kIHRvU3RyaW5nXG5cdCogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1RpbWVsaW5lXVwiO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3coXCJUaW1lbGluZSBjYW4gbm90IGJlIGNsb25lZC5cIilcblx0fTtcblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfZ290b1xuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gcG9zaXRpb25PckxhYmVsXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nb3RvID0gZnVuY3Rpb24ocG9zaXRpb25PckxhYmVsKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMucmVzb2x2ZShwb3NpdGlvbk9yTGFiZWwpO1xuXHRcdGlmIChwb3MgIT0gbnVsbCkgeyB0aGlzLnNldFBvc2l0aW9uKHBvcyk7IH1cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9jYWxjUG9zaXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2NhbGNQb3NpdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlIDwgMCkgeyByZXR1cm4gMDsgfVxuXHRcdGlmICh2YWx1ZSA8IHRoaXMuZHVyYXRpb24pIHsgcmV0dXJuIHZhbHVlOyB9XG5cdFx0cmV0dXJuIHRoaXMubG9vcCA/IHZhbHVlJXRoaXMuZHVyYXRpb24gOiB0aGlzLmR1cmF0aW9uO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLlRpbWVsaW5lID0gY3JlYXRlanMucHJvbW90ZShUaW1lbGluZSwgXCJFdmVudERpc3BhdGNoZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBFYXNlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIFRoZSBFYXNlIGNsYXNzIHByb3ZpZGVzIGEgY29sbGVjdGlvbiBvZiBlYXNpbmcgZnVuY3Rpb25zIGZvciB1c2Ugd2l0aCBUd2VlbkpTLiBJdCBkb2VzIG5vdCB1c2UgdGhlIHN0YW5kYXJkIDQgcGFyYW1cblx0ICogZWFzaW5nIHNpZ25hdHVyZS4gSW5zdGVhZCBpdCB1c2VzIGEgc2luZ2xlIHBhcmFtIHdoaWNoIGluZGljYXRlcyB0aGUgY3VycmVudCBsaW5lYXIgcmF0aW8gKDAgdG8gMSkgb2YgdGhlIHR3ZWVuLlxuXHQgKlxuXHQgKiBNb3N0IG1ldGhvZHMgb24gRWFzZSBjYW4gYmUgcGFzc2VkIGRpcmVjdGx5IGFzIGVhc2luZyBmdW5jdGlvbnM6XG5cdCAqXG5cdCAqICAgICAgVHdlZW4uZ2V0KHRhcmdldCkudG8oe3g6MTAwfSwgNTAwLCBFYXNlLmxpbmVhcik7XG5cdCAqXG5cdCAqIEhvd2V2ZXIsIG1ldGhvZHMgYmVnaW5uaW5nIHdpdGggXCJnZXRcIiB3aWxsIHJldHVybiBhbiBlYXNpbmcgZnVuY3Rpb24gYmFzZWQgb24gcGFyYW1ldGVyIHZhbHVlczpcblx0ICpcblx0ICogICAgICBUd2Vlbi5nZXQodGFyZ2V0KS50byh7eToyMDB9LCA1MDAsIEVhc2UuZ2V0UG93SW4oMi4yKSk7XG5cdCAqXG5cdCAqIFBsZWFzZSBzZWUgdGhlIDxhIGhyZWY9XCJodHRwOi8vd3d3LmNyZWF0ZWpzLmNvbS9EZW1vcy9Ud2VlbkpTL1R3ZWVuX1NwYXJrVGFibGVcIj5zcGFyayB0YWJsZSBkZW1vPC9hPiBmb3IgYW5cblx0ICogb3ZlcnZpZXcgb2YgdGhlIGRpZmZlcmVudCBlYXNlIHR5cGVzIG9uIDxhIGhyZWY9XCJodHRwOi8vdHdlZW5qcy5jb21cIj5Ud2VlbkpTLmNvbTwvYT4uXG5cdCAqXG5cdCAqIDxlbT5FcXVhdGlvbnMgZGVyaXZlZCBmcm9tIHdvcmsgYnkgUm9iZXJ0IFBlbm5lci48L2VtPlxuXHQgKiBAY2xhc3MgRWFzZVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0ZnVuY3Rpb24gRWFzZSgpIHtcblx0XHR0aHJvdyBcIkVhc2UgY2Fubm90IGJlIGluc3RhbnRpYXRlZC5cIjtcblx0fVxuXG5cbi8vIHN0YXRpYyBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGxpbmVhclxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmxpbmVhciA9IGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHQ7IH07XG5cblx0LyoqXG5cdCAqIElkZW50aWNhbCB0byBsaW5lYXIuXG5cdCAqIEBtZXRob2Qgbm9uZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLm5vbmUgPSBFYXNlLmxpbmVhcjtcblxuXHQvKipcblx0ICogTWltaWNzIHRoZSBzaW1wbGUgLTEwMCB0byAxMDAgZWFzaW5nIGluIEZsYXNoIFByby5cblx0ICogQG1ldGhvZCBnZXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCBBIHZhbHVlIGZyb20gLTEgKGVhc2UgaW4pIHRvIDEgKGVhc2Ugb3V0KSBpbmRpY2F0aW5nIHRoZSBzdHJlbmd0aCBhbmQgZGlyZWN0aW9uIG9mIHRoZSBlYXNlLlxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0ID0gZnVuY3Rpb24oYW1vdW50KSB7XG5cdFx0aWYgKGFtb3VudCA8IC0xKSB7IGFtb3VudCA9IC0xOyB9XG5cdFx0aWYgKGFtb3VudCA+IDEpIHsgYW1vdW50ID0gMTsgfVxuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRpZiAoYW1vdW50PT0wKSB7IHJldHVybiB0OyB9XG5cdFx0XHRpZiAoYW1vdW50PDApIHsgcmV0dXJuIHQqKHQqLWFtb3VudCsxK2Ftb3VudCk7IH1cblx0XHRcdHJldHVybiB0KigoMi10KSphbW91bnQrKDEtYW1vdW50KSk7XG5cdFx0fTtcblx0fTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIGV4cG9uZW50aWFsIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0UG93SW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvdyBUaGUgZXhwb25lbnQgdG8gdXNlIChleC4gMyB3b3VsZCByZXR1cm4gYSBjdWJpYyBlYXNlKS5cblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldFBvd0luID0gZnVuY3Rpb24ocG93KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiBNYXRoLnBvdyh0LHBvdyk7XG5cdFx0fTtcblx0fTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIGV4cG9uZW50aWFsIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0UG93T3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3cgVGhlIGV4cG9uZW50IHRvIHVzZSAoZXguIDMgd291bGQgcmV0dXJuIGEgY3ViaWMgZWFzZSkuXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRQb3dPdXQgPSBmdW5jdGlvbihwb3cpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0cmV0dXJuIDEtTWF0aC5wb3coMS10LHBvdyk7XG5cdFx0fTtcblx0fTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIGV4cG9uZW50aWFsIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0UG93SW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvdyBUaGUgZXhwb25lbnQgdG8gdXNlIChleC4gMyB3b3VsZCByZXR1cm4gYSBjdWJpYyBlYXNlKS5cblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldFBvd0luT3V0ID0gZnVuY3Rpb24ocG93KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdGlmICgodCo9Mik8MSkgcmV0dXJuIDAuNSpNYXRoLnBvdyh0LHBvdyk7XG5cdFx0XHRyZXR1cm4gMS0wLjUqTWF0aC5hYnMoTWF0aC5wb3coMi10LHBvdykpO1xuXHRcdH07XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgcXVhZEluXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVhZEluID0gRWFzZS5nZXRQb3dJbigyKTtcblx0LyoqXG5cdCAqIEBtZXRob2QgcXVhZE91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1YWRPdXQgPSBFYXNlLmdldFBvd091dCgyKTtcblx0LyoqXG5cdCAqIEBtZXRob2QgcXVhZEluT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVhZEluT3V0ID0gRWFzZS5nZXRQb3dJbk91dCgyKTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBjdWJpY0luXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuY3ViaWNJbiA9IEVhc2UuZ2V0UG93SW4oMyk7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGN1YmljT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuY3ViaWNPdXQgPSBFYXNlLmdldFBvd091dCgzKTtcblx0LyoqXG5cdCAqIEBtZXRob2QgY3ViaWNJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmN1YmljSW5PdXQgPSBFYXNlLmdldFBvd0luT3V0KDMpO1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1YXJ0SW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWFydEluID0gRWFzZS5nZXRQb3dJbig0KTtcblx0LyoqXG5cdCAqIEBtZXRob2QgcXVhcnRPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWFydE91dCA9IEVhc2UuZ2V0UG93T3V0KDQpO1xuXHQvKipcblx0ICogQG1ldGhvZCBxdWFydEluT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVhcnRJbk91dCA9IEVhc2UuZ2V0UG93SW5PdXQoNCk7XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgcXVpbnRJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1aW50SW4gPSBFYXNlLmdldFBvd0luKDUpO1xuXHQvKipcblx0ICogQG1ldGhvZCBxdWludE91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1aW50T3V0ID0gRWFzZS5nZXRQb3dPdXQoNSk7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1aW50SW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWludEluT3V0ID0gRWFzZS5nZXRQb3dJbk91dCg1KTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBzaW5lSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5zaW5lSW4gPSBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIDEtTWF0aC5jb3ModCpNYXRoLlBJLzIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHNpbmVPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5zaW5lT3V0ID0gZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiBNYXRoLnNpbih0Kk1hdGguUEkvMik7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2Qgc2luZUluT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2Uuc2luZUluT3V0ID0gZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtMC41KihNYXRoLmNvcyhNYXRoLlBJKnQpIC0gMSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBcImJhY2sgaW5cIiBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldEJhY2tJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IFRoZSBzdHJlbmd0aCBvZiB0aGUgZWFzZS5cblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldEJhY2tJbiA9IGZ1bmN0aW9uKGFtb3VudCkge1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRyZXR1cm4gdCp0KigoYW1vdW50KzEpKnQtYW1vdW50KTtcblx0XHR9O1xuXHR9O1xuXHQvKipcblx0ICogQG1ldGhvZCBiYWNrSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5iYWNrSW4gPSBFYXNlLmdldEJhY2tJbigxLjcpO1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgXCJiYWNrIG91dFwiIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0QmFja091dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IFRoZSBzdHJlbmd0aCBvZiB0aGUgZWFzZS5cblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldEJhY2tPdXQgPSBmdW5jdGlvbihhbW91bnQpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0cmV0dXJuICgtLXQqdCooKGFtb3VudCsxKSp0ICsgYW1vdW50KSArIDEpO1xuXHRcdH07XG5cdH07XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGJhY2tPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5iYWNrT3V0ID0gRWFzZS5nZXRCYWNrT3V0KDEuNyk7XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBcImJhY2sgaW4gb3V0XCIgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRCYWNrSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCBUaGUgc3RyZW5ndGggb2YgdGhlIGVhc2UuXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRCYWNrSW5PdXQgPSBmdW5jdGlvbihhbW91bnQpIHtcblx0XHRhbW91bnQqPTEuNTI1O1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRpZiAoKHQqPTIpPDEpIHJldHVybiAwLjUqKHQqdCooKGFtb3VudCsxKSp0LWFtb3VudCkpO1xuXHRcdFx0cmV0dXJuIDAuNSooKHQtPTIpKnQqKChhbW91bnQrMSkqdCthbW91bnQpKzIpO1xuXHRcdH07XG5cdH07XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGJhY2tJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmJhY2tJbk91dCA9IEVhc2UuZ2V0QmFja0luT3V0KDEuNyk7XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgY2lyY0luXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuY2lyY0luID0gZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtKE1hdGguc3FydCgxLXQqdCktIDEpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGNpcmNPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5jaXJjT3V0ID0gZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiBNYXRoLnNxcnQoMS0oLS10KSp0KTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBjaXJjSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5jaXJjSW5PdXQgPSBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKCh0Kj0yKSA8IDEpIHJldHVybiAtMC41KihNYXRoLnNxcnQoMS10KnQpLTEpO1xuXHRcdHJldHVybiAwLjUqKE1hdGguc3FydCgxLSh0LT0yKSp0KSsxKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBib3VuY2VJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmJvdW5jZUluID0gZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAxLUVhc2UuYm91bmNlT3V0KDEtdCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgYm91bmNlT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuYm91bmNlT3V0ID0gZnVuY3Rpb24odCkge1xuXHRcdGlmICh0IDwgMS8yLjc1KSB7XG5cdFx0XHRyZXR1cm4gKDcuNTYyNSp0KnQpO1xuXHRcdH0gZWxzZSBpZiAodCA8IDIvMi43NSkge1xuXHRcdFx0cmV0dXJuICg3LjU2MjUqKHQtPTEuNS8yLjc1KSp0KzAuNzUpO1xuXHRcdH0gZWxzZSBpZiAodCA8IDIuNS8yLjc1KSB7XG5cdFx0XHRyZXR1cm4gKDcuNTYyNSoodC09Mi4yNS8yLjc1KSp0KzAuOTM3NSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAoNy41NjI1Kih0LT0yLjYyNS8yLjc1KSp0ICswLjk4NDM3NSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGJvdW5jZUluT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuYm91bmNlSW5PdXQgPSBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKHQ8MC41KSByZXR1cm4gRWFzZS5ib3VuY2VJbiAodCoyKSAqIC41O1xuXHRcdHJldHVybiBFYXNlLmJvdW5jZU91dCh0KjItMSkqMC41KzAuNTtcblx0fTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIGVsYXN0aWMgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRFbGFzdGljSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFtcGxpdHVkZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGVyaW9kXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRFbGFzdGljSW4gPSBmdW5jdGlvbihhbXBsaXR1ZGUscGVyaW9kKSB7XG5cdFx0dmFyIHBpMiA9IE1hdGguUEkqMjtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0aWYgKHQ9PTAgfHwgdD09MSkgcmV0dXJuIHQ7XG5cdFx0XHR2YXIgcyA9IHBlcmlvZC9waTIqTWF0aC5hc2luKDEvYW1wbGl0dWRlKTtcblx0XHRcdHJldHVybiAtKGFtcGxpdHVkZSpNYXRoLnBvdygyLDEwKih0LT0xKSkqTWF0aC5zaW4oKHQtcykqcGkyL3BlcmlvZCkpO1xuXHRcdH07XG5cdH07XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGVsYXN0aWNJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmVsYXN0aWNJbiA9IEVhc2UuZ2V0RWxhc3RpY0luKDEsMC4zKTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIGVsYXN0aWMgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRFbGFzdGljT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbXBsaXR1ZGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBlcmlvZFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0RWxhc3RpY091dCA9IGZ1bmN0aW9uKGFtcGxpdHVkZSxwZXJpb2QpIHtcblx0XHR2YXIgcGkyID0gTWF0aC5QSSoyO1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRpZiAodD09MCB8fCB0PT0xKSByZXR1cm4gdDtcblx0XHRcdHZhciBzID0gcGVyaW9kL3BpMiAqIE1hdGguYXNpbigxL2FtcGxpdHVkZSk7XG5cdFx0XHRyZXR1cm4gKGFtcGxpdHVkZSpNYXRoLnBvdygyLC0xMCp0KSpNYXRoLnNpbigodC1zKSpwaTIvcGVyaW9kICkrMSk7XG5cdFx0fTtcblx0fTtcblx0LyoqXG5cdCAqIEBtZXRob2QgZWxhc3RpY091dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmVsYXN0aWNPdXQgPSBFYXNlLmdldEVsYXN0aWNPdXQoMSwwLjMpO1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgZWxhc3RpYyBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldEVsYXN0aWNJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW1wbGl0dWRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwZXJpb2Rcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldEVsYXN0aWNJbk91dCA9IGZ1bmN0aW9uKGFtcGxpdHVkZSxwZXJpb2QpIHtcblx0XHR2YXIgcGkyID0gTWF0aC5QSSoyO1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHR2YXIgcyA9IHBlcmlvZC9waTIgKiBNYXRoLmFzaW4oMS9hbXBsaXR1ZGUpO1xuXHRcdFx0aWYgKCh0Kj0yKTwxKSByZXR1cm4gLTAuNSooYW1wbGl0dWRlKk1hdGgucG93KDIsMTAqKHQtPTEpKSpNYXRoLnNpbiggKHQtcykqcGkyL3BlcmlvZCApKTtcblx0XHRcdHJldHVybiBhbXBsaXR1ZGUqTWF0aC5wb3coMiwtMTAqKHQtPTEpKSpNYXRoLnNpbigodC1zKSpwaTIvcGVyaW9kKSowLjUrMTtcblx0XHR9O1xuXHR9O1xuXHQvKipcblx0ICogQG1ldGhvZCBlbGFzdGljSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5lbGFzdGljSW5PdXQgPSBFYXNlLmdldEVsYXN0aWNJbk91dCgxLDAuMyoxLjUpO1xuXG5cdGNyZWF0ZWpzLkVhc2UgPSBFYXNlO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gTW90aW9uR3VpZGVQbHVnaW4uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogQSBUd2VlbkpTIHBsdWdpbiBmb3Igd29ya2luZyB3aXRoIG1vdGlvbiBndWlkZXMuXG5cdCAqXG5cdCAqIFRvIHVzZSwgaW5zdGFsbCB0aGUgcGx1Z2luIGFmdGVyIFR3ZWVuSlMgaGFzIGxvYWRlZC4gTmV4dCB0d2VlbiB0aGUgJ2d1aWRlJyBwcm9wZXJ0eSB3aXRoIGFuIG9iamVjdCBhcyBkZXRhaWxlZCBiZWxvdy5cblx0ICpcblx0ICogICAgICAgY3JlYXRlanMuTW90aW9uR3VpZGVQbHVnaW4uaW5zdGFsbCgpO1xuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgLy8gVXNpbmcgYSBNb3Rpb24gR3VpZGVcblx0ICpcdCAgICBjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0KS50byh7Z3VpZGU6eyBwYXRoOlswLDAsIDAsMjAwLDIwMCwyMDAsIDIwMCwwLDAsMF0gfX0sNzAwMCk7XG5cdCAqXHQgICAgLy8gVmlzdWFsaXppbmcgdGhlIGxpbmVcblx0ICpcdCAgICBncmFwaGljcy5tb3ZlVG8oMCwwKS5jdXJ2ZVRvKDAsMjAwLDIwMCwyMDApLmN1cnZlVG8oMjAwLDAsMCwwKTtcblx0ICpcblx0ICogRWFjaCBwYXRoIG5lZWRzIHByZS1jb21wdXRhdGlvbiB0byBlbnN1cmUgdGhlcmUncyBmYXN0IHBlcmZvcm1hbmNlLiBCZWNhdXNlIG9mIHRoZSBwcmUtY29tcHV0YXRpb24gdGhlcmUncyBub1xuXHQgKiBidWlsdCBpbiBzdXBwb3J0IGZvciBwYXRoIGNoYW5nZXMgbWlkIHR3ZWVuLiBUaGVzZSBhcmUgdGhlIEd1aWRlIE9iamVjdCdzIHByb3BlcnRpZXM6PFVMPlxuXHQgKiAgICAgIDxMST4gcGF0aDogUmVxdWlyZWQsIEFycmF5IDogVGhlIHgveSBwb2ludHMgdXNlZCB0byBkcmF3IHRoZSBwYXRoIHdpdGggYSBtb3ZlVG8gYW5kIDEgdG8gbiBjdXJ2ZVRvIGNhbGxzLjwvTEk+XG5cdCAqICAgICAgPExJPiBzdGFydDogT3B0aW9uYWwsIDAtMSA6IEluaXRpYWwgcG9zaXRpb24sIGRlZmF1bHQgMCBleGNlcHQgZm9yIHdoZW4gY29udGludWluZyBhbG9uZyB0aGUgc2FtZSBwYXRoLjwvTEk+XG5cdCAqICAgICAgPExJPiBlbmQ6IE9wdGlvbmFsLCAwLTEgOiBGaW5hbCBwb3NpdGlvbiwgZGVmYXVsdCAxIGlmIG5vdCBzcGVjaWZpZWQuPC9MST5cblx0ICogICAgICA8TEk+IG9yaWVudDogT3B0aW9uYWwsIHN0cmluZyA6IFwiZml4ZWRcIi9cImF1dG9cIi9cImN3XCIvXCJjY3dcIjxVTD5cblx0ICpcdFx0XHRcdDxMST5cImZpeGVkXCIgZm9yY2VzIHRoZSBvYmplY3QgdG8gZmFjZSBkb3duIHRoZSBwYXRoIGFsbCBtb3ZlbWVudCAocmVsYXRpdmUgdG8gc3RhcnQgcm90YXRpb24pLDwvTEk+XG5cdCAqICAgICAgXHRcdDxMST5cImF1dG9cIiByb3RhdGVzIHRoZSBvYmplY3QgYWxvbmcgdGhlIHBhdGggcmVsYXRpdmUgdG8gdGhlIGxpbmUuPC9MST5cblx0ICogICAgICBcdFx0PExJPlwiY3dcIi9cImNjd1wiIGZvcmNlIGNsb2Nrd2lzZSBvciBjb3VudGVyIGNsb2Nrd2lzZSByb3RhdGlvbnMgaW5jbHVkaW5nIGZsYXNoIGxpa2UgYmVoYXZpb3VyPC9MST5cblx0ICogXHRcdDwvVUw+PC9MST5cblx0ICogPC9VTD5cblx0ICogR3VpZGUgb2JqZWN0cyBzaG91bGQgbm90IGJlIHNoYXJlZCBiZXR3ZWVuIHR3ZWVucyBldmVuIGlmIGFsbCBwcm9wZXJ0aWVzIGFyZSBpZGVudGljYWwsIHRoZSBsaWJyYXJ5IHN0b3Jlc1xuXHQgKiBpbmZvcm1hdGlvbiBvbiB0aGVzZSBvYmplY3RzIGluIHRoZSBiYWNrZ3JvdW5kIGFuZCBzaGFyaW5nIHRoZW0gY2FuIGNhdXNlIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLiBWYWx1ZXNcblx0ICogb3V0c2lkZSAwLTEgcmFuZ2Ugb2YgdHdlZW5zIHdpbGwgYmUgYSBcImJlc3QgZ3Vlc3NcIiBmcm9tIHRoZSBhcHByb3ByaWF0ZSBwYXJ0IG9mIHRoZSBkZWZpbmVkIGN1cnZlLlxuXHQgKlxuXHQgKiBAY2xhc3MgTW90aW9uR3VpZGVQbHVnaW5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gTW90aW9uR3VpZGVQbHVnaW4oKSB7XG5cdFx0dGhyb3coXCJNb3Rpb25HdWlkZVBsdWdpbiBjYW5ub3QgYmUgaW5zdGFudGlhdGVkLlwiKVxuXHR9O1xuXG5cbi8vIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQHByb3BlcnR5IHByaW9yaXR5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLnByaW9yaXR5ID0gMDsgLy8gaGlnaCBwcmlvcml0eSwgc2hvdWxkIHJ1biBzb29uZXJcblxuXHQvKipcblx0ICogQHByb3BlcnR5IHRlbXBvcmFyeSB2YXJpYWJsZSBzdG9yYWdlXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLl9yb3RPZmZTO1xuXHQvKipcblx0ICogQHByb3BlcnR5IHRlbXBvcmFyeSB2YXJpYWJsZSBzdG9yYWdlXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLl9yb3RPZmZFO1xuXHQvKipcblx0ICogQHByb3BlcnR5IHRlbXBvcmFyeSB2YXJpYWJsZSBzdG9yYWdlXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLl9yb3ROb3JtUztcblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB0ZW1wb3JhcnkgdmFyaWFibGUgc3RvcmFnZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRNb3Rpb25HdWlkZVBsdWdpbi5fcm90Tm9ybUU7XG5cblxuLy8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIEluc3RhbGxzIHRoaXMgcGx1Z2luIGZvciB1c2Ugd2l0aCBUd2VlbkpTLiBDYWxsIHRoaXMgb25jZSBhZnRlciBUd2VlbkpTIGlzIGxvYWRlZCB0byBlbmFibGUgdGhpcyBwbHVnaW4uXG5cdCAqIEBtZXRob2QgaW5zdGFsbFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uaW5zdGFsbCA9IGZ1bmN0aW9uKCkge1xuXHRcdGNyZWF0ZWpzLlR3ZWVuLmluc3RhbGxQbHVnaW4oTW90aW9uR3VpZGVQbHVnaW4sIFtcImd1aWRlXCIsIFwieFwiLCBcInlcIiwgXCJyb3RhdGlvblwiXSk7XG5cdFx0cmV0dXJuIGNyZWF0ZWpzLlR3ZWVuLklHTk9SRTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBpbml0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLmluaXQgPSBmdW5jdGlvbih0d2VlbiwgcHJvcCwgdmFsdWUpIHtcblx0XHR2YXIgdGFyZ2V0ID0gdHdlZW4udGFyZ2V0O1xuXHRcdGlmKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoXCJ4XCIpKXsgdGFyZ2V0LnggPSAwOyB9XG5cdFx0aWYoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShcInlcIikpeyB0YXJnZXQueSA9IDA7IH1cblx0XHRpZighdGFyZ2V0Lmhhc093blByb3BlcnR5KFwicm90YXRpb25cIikpeyB0YXJnZXQucm90YXRpb24gPSAwOyB9XG5cblx0XHRpZihwcm9wPT1cInJvdGF0aW9uXCIpeyB0d2Vlbi5fX25lZWRzUm90ID0gdHJ1ZTsgfVxuXHRcdHJldHVybiBwcm9wPT1cImd1aWRlXCI/bnVsbDp2YWx1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBzdGVwXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLnN0ZXAgPSBmdW5jdGlvbih0d2VlbiwgcHJvcCwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGluamVjdFByb3BzKSB7XG5cdFx0Ly8gb3RoZXIgcHJvcHNcblx0XHRpZihwcm9wID09IFwicm90YXRpb25cIil7XG5cdFx0XHR0d2Vlbi5fX3JvdEdsb2JhbFMgPSBzdGFydFZhbHVlO1xuXHRcdFx0dHdlZW4uX19yb3RHbG9iYWxFID0gZW5kVmFsdWU7XG5cdFx0XHRNb3Rpb25HdWlkZVBsdWdpbi50ZXN0Um90RGF0YSh0d2VlbiwgaW5qZWN0UHJvcHMpO1xuXHRcdH1cblx0XHRpZihwcm9wICE9IFwiZ3VpZGVcIil7IHJldHVybiBlbmRWYWx1ZTsgfVxuXG5cdFx0Ly8gZ3VpZGUgb25seSBpbmZvcm1hdGlvbiAtIFN0YXJ0IC1cblx0XHR2YXIgdGVtcCwgZGF0YSA9IGVuZFZhbHVlO1xuXHRcdGlmKCFkYXRhLmhhc093blByb3BlcnR5KFwicGF0aFwiKSl7IGRhdGEucGF0aCA9IFtdOyB9XG5cdFx0dmFyIHBhdGggPSBkYXRhLnBhdGg7XG5cdFx0aWYoIWRhdGEuaGFzT3duUHJvcGVydHkoXCJlbmRcIikpeyBkYXRhLmVuZCA9IDE7IH1cblx0XHRpZighZGF0YS5oYXNPd25Qcm9wZXJ0eShcInN0YXJ0XCIpKXtcblx0XHRcdGRhdGEuc3RhcnQgPSAoc3RhcnRWYWx1ZSYmc3RhcnRWYWx1ZS5oYXNPd25Qcm9wZXJ0eShcImVuZFwiKSYmc3RhcnRWYWx1ZS5wYXRoPT09cGF0aCk/c3RhcnRWYWx1ZS5lbmQ6MDtcblx0XHR9XG5cblx0XHQvLyBGaWd1cmUgb3V0IHN1YmxpbmUgaW5mb3JtYXRpb25cblx0XHRpZihkYXRhLmhhc093blByb3BlcnR5KFwiX3NlZ21lbnRzXCIpICYmIGRhdGEuX2xlbmd0aCl7IHJldHVybiBlbmRWYWx1ZTsgfVxuXHRcdHZhciBsID0gcGF0aC5sZW5ndGg7XG5cdFx0dmFyIGFjY3VyYWN5ID0gMTA7XHRcdC8vIEFkanVzdCB0byBpbXByb3ZlIGxpbmUgZm9sbG93aW5nIHByZWNpc2lvbiBidXQgc2FjcmlmaWNlIHBlcmZvcm1hbmNlICgjIG9mIHNlZylcblx0XHRpZihsID49IDYgJiYgKGwtMikgJSA0ID09IDApe1x0Ly8gRW5vdWdoIHBvaW50cyAmJiBjb250YWlucyBjb3JyZWN0IG51bWJlciBwZXIgZW50cnkgaWdub3Jpbmcgc3RhcnRcblx0XHRcdGRhdGEuX3NlZ21lbnRzID0gW107XG5cdFx0XHRkYXRhLl9sZW5ndGggPSAwO1xuXHRcdFx0Zm9yKHZhciBpPTI7IGk8bDsgaSs9NCl7XG5cdFx0XHRcdHZhciBzeCA9IHBhdGhbaS0yXSwgc3kgPSBwYXRoW2ktMV07XG5cdFx0XHRcdHZhciBjeCA9IHBhdGhbaSswXSwgY3kgPSBwYXRoW2krMV07XG5cdFx0XHRcdHZhciBleCA9IHBhdGhbaSsyXSwgZXkgPSBwYXRoW2krM107XG5cdFx0XHRcdHZhciBvbGRYID0gc3gsIG9sZFkgPSBzeTtcblx0XHRcdFx0dmFyIHRlbXBYLCB0ZW1wWSwgdG90YWwgPSAwO1xuXHRcdFx0XHR2YXIgc3VibGluZXMgPSBbXTtcblx0XHRcdFx0Zm9yKHZhciBqPTE7IGo8PWFjY3VyYWN5OyBqKyspe1xuXHRcdFx0XHRcdHZhciB0ID0gai9hY2N1cmFjeTtcblx0XHRcdFx0XHR2YXIgaW52ID0gMSAtIHQ7XG5cdFx0XHRcdFx0dGVtcFggPSBpbnYqaW52ICogc3ggKyAyICogaW52ICogdCAqIGN4ICsgdCp0ICogZXg7XG5cdFx0XHRcdFx0dGVtcFkgPSBpbnYqaW52ICogc3kgKyAyICogaW52ICogdCAqIGN5ICsgdCp0ICogZXk7XG5cdFx0XHRcdFx0dG90YWwgKz0gc3VibGluZXNbc3VibGluZXMucHVzaChNYXRoLnNxcnQoKHRlbXA9dGVtcFgtb2xkWCkqdGVtcCArICh0ZW1wPXRlbXBZLW9sZFkpKnRlbXApKS0xXTtcblx0XHRcdFx0XHRvbGRYID0gdGVtcFg7XG5cdFx0XHRcdFx0b2xkWSA9IHRlbXBZO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGEuX3NlZ21lbnRzLnB1c2godG90YWwpO1xuXHRcdFx0XHRkYXRhLl9zZWdtZW50cy5wdXNoKHN1YmxpbmVzKTtcblx0XHRcdFx0ZGF0YS5fbGVuZ3RoICs9IHRvdGFsO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyhcImludmFsaWQgJ3BhdGgnIGRhdGEsIHBsZWFzZSBzZWUgZG9jdW1lbnRhdGlvbiBmb3IgdmFsaWQgcGF0aHNcIik7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0dXAgeC95IHR3ZWVuc1xuXHRcdHRlbXAgPSBkYXRhLm9yaWVudDtcblx0XHRkYXRhLm9yaWVudCA9IHRydWU7XG5cdFx0dmFyIG8gPSB7fTtcblx0XHRNb3Rpb25HdWlkZVBsdWdpbi5jYWxjKGRhdGEsIGRhdGEuc3RhcnQsIG8pO1xuXHRcdHR3ZWVuLl9fcm90UGF0aFMgPSBOdW1iZXIoby5yb3RhdGlvbi50b0ZpeGVkKDUpKTtcblx0XHRNb3Rpb25HdWlkZVBsdWdpbi5jYWxjKGRhdGEsIGRhdGEuZW5kLCBvKTtcblx0XHR0d2Vlbi5fX3JvdFBhdGhFID0gTnVtYmVyKG8ucm90YXRpb24udG9GaXhlZCg1KSk7XG5cdFx0ZGF0YS5vcmllbnQgPSBmYWxzZTtcdC8vaGVyZSBhbmQgbm93IHdlIGRvbid0IGtub3cgaWYgd2UgbmVlZCB0b1xuXHRcdE1vdGlvbkd1aWRlUGx1Z2luLmNhbGMoZGF0YSwgZGF0YS5lbmQsIGluamVjdFByb3BzKTtcblx0XHRkYXRhLm9yaWVudCA9IHRlbXA7XG5cblx0XHQvLyBTZXR1cCByb3RhdGlvbiBwcm9wZXJ0aWVzXG5cdFx0aWYoIWRhdGEub3JpZW50KXsgcmV0dXJuIGVuZFZhbHVlOyB9XG5cdFx0dHdlZW4uX19ndWlkZURhdGEgPSBkYXRhO1xuXHRcdE1vdGlvbkd1aWRlUGx1Z2luLnRlc3RSb3REYXRhKHR3ZWVuLCBpbmplY3RQcm9wcyk7XG5cdFx0cmV0dXJuIGVuZFZhbHVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHRlc3RSb3REYXRhXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLnRlc3RSb3REYXRhID0gZnVuY3Rpb24odHdlZW4sIGluamVjdFByb3BzKXtcblxuXHRcdC8vIG5vIHJvdGF0aW9uIGluZm9ybWF0PyBpZiB3ZSBuZWVkIGl0IGNvbWUgYmFjaywgaWYgd2UgZG9uJ3QgdXNlIDAgJiBlbnN1cmUgd2UgaGF2ZSBndWlkZSBkYXRhXG5cdFx0aWYodHdlZW4uX19yb3RHbG9iYWxTID09PSB1bmRlZmluZWQgfHwgdHdlZW4uX19yb3RHbG9iYWxFID09PSB1bmRlZmluZWQpe1xuXHRcdFx0aWYodHdlZW4uX19uZWVkc1JvdCl7IHJldHVybjsgfVxuXHRcdFx0aWYodHdlZW4uX2N1clF1ZXVlUHJvcHMucm90YXRpb24gIT09IHVuZGVmaW5lZCl7XG5cdFx0XHRcdHR3ZWVuLl9fcm90R2xvYmFsUyA9IHR3ZWVuLl9fcm90R2xvYmFsRSA9IHR3ZWVuLl9jdXJRdWV1ZVByb3BzLnJvdGF0aW9uO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uX19yb3RHbG9iYWxTID0gdHdlZW4uX19yb3RHbG9iYWxFID0gaW5qZWN0UHJvcHMucm90YXRpb24gPSB0d2Vlbi50YXJnZXQucm90YXRpb24gfHwgMDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYodHdlZW4uX19ndWlkZURhdGEgPT09IHVuZGVmaW5lZCl7IHJldHVybjsgfVxuXG5cdFx0Ly8gUHJvY2VzcyByb3RhdGlvbiBwcm9wZXJ0aWVzXG5cdFx0dmFyIGRhdGEgPSB0d2Vlbi5fX2d1aWRlRGF0YTtcblx0XHR2YXIgcm90R2xvYmFsRCA9IHR3ZWVuLl9fcm90R2xvYmFsRSAtIHR3ZWVuLl9fcm90R2xvYmFsUztcblx0XHR2YXIgcm90UGF0aEQgPSB0d2Vlbi5fX3JvdFBhdGhFIC0gdHdlZW4uX19yb3RQYXRoUztcblx0XHR2YXIgcm90ID0gcm90R2xvYmFsRCAtIHJvdFBhdGhEO1xuXG5cdFx0aWYoZGF0YS5vcmllbnQgPT0gXCJhdXRvXCIpe1xuXHRcdFx0aWYocm90ID4gMTgwKXtcdFx0XHRyb3QgLT0gMzYwOyB9XG5cdFx0XHRlbHNlIGlmKHJvdCA8IC0xODApe1x0cm90ICs9IDM2MDsgfVxuXG5cdFx0fSBlbHNlIGlmKGRhdGEub3JpZW50ID09IFwiY3dcIil7XG5cdFx0XHR3aGlsZShyb3QgPCAwKXsgcm90ICs9IDM2MDsgfVxuXHRcdFx0aWYocm90ID09IDAgJiYgcm90R2xvYmFsRCA+IDAgJiYgcm90R2xvYmFsRCAhPSAxODApeyByb3QgKz0gMzYwOyB9XG5cblx0XHR9IGVsc2UgaWYoZGF0YS5vcmllbnQgPT0gXCJjY3dcIil7XG5cdFx0XHRyb3QgPSByb3RHbG9iYWxEIC0gKChyb3RQYXRoRCA+IDE4MCk/KDM2MC1yb3RQYXRoRCk6KHJvdFBhdGhEKSk7XHQvLyBzaWduIGZsaXBwaW5nIG9uIHBhdGhcblx0XHRcdHdoaWxlKHJvdCA+IDApeyByb3QgLT0gMzYwOyB9XG5cdFx0XHRpZihyb3QgPT0gMCAmJiByb3RHbG9iYWxEIDwgMCAmJiByb3RHbG9iYWxEICE9IC0xODApeyByb3QgLT0gMzYwOyB9XG5cdFx0fVxuXG5cdFx0ZGF0YS5yb3REZWx0YSA9IHJvdDtcblx0XHRkYXRhLnJvdE9mZlMgPSB0d2Vlbi5fX3JvdEdsb2JhbFMgLSB0d2Vlbi5fX3JvdFBhdGhTO1xuXG5cdFx0Ly8gcmVzZXRcblx0XHR0d2Vlbi5fX3JvdEdsb2JhbFMgPSB0d2Vlbi5fX3JvdEdsb2JhbEUgPSB0d2Vlbi5fX2d1aWRlRGF0YSA9IHR3ZWVuLl9fbmVlZHNSb3QgPSB1bmRlZmluZWQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgdHdlZW5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0TW90aW9uR3VpZGVQbHVnaW4udHdlZW4gPSBmdW5jdGlvbih0d2VlbiwgcHJvcCwgdmFsdWUsIHN0YXJ0VmFsdWVzLCBlbmRWYWx1ZXMsIHJhdGlvLCB3YWl0LCBlbmQpIHtcblx0XHR2YXIgZGF0YSA9IGVuZFZhbHVlcy5ndWlkZTtcblx0XHRpZihkYXRhID09IHVuZGVmaW5lZCB8fCBkYXRhID09PSBzdGFydFZhbHVlcy5ndWlkZSl7IHJldHVybiB2YWx1ZTsgfVxuXHRcdGlmKGRhdGEubGFzdFJhdGlvICE9IHJhdGlvKXtcblx0XHRcdC8vIGZpcnN0IHRpbWUgdGhyb3VnaCBzbyBjYWxjdWxhdGUgd2hhdCBJIG5lZWQgdG9cblx0XHRcdHZhciB0ID0gKChkYXRhLmVuZC1kYXRhLnN0YXJ0KSood2FpdD9kYXRhLmVuZDpyYXRpbykrZGF0YS5zdGFydCk7XG5cdFx0XHRNb3Rpb25HdWlkZVBsdWdpbi5jYWxjKGRhdGEsIHQsIHR3ZWVuLnRhcmdldCk7XG5cdFx0XHRzd2l0Y2goZGF0YS5vcmllbnQpe1xuXHRcdFx0XHRjYXNlIFwiY3dcIjpcdFx0Ly8gbWl4IGluIHRoZSBvcmlnaW5hbCByb3RhdGlvblxuXHRcdFx0XHRjYXNlIFwiY2N3XCI6XG5cdFx0XHRcdGNhc2UgXCJhdXRvXCI6IHR3ZWVuLnRhcmdldC5yb3RhdGlvbiArPSBkYXRhLnJvdE9mZlMgKyBkYXRhLnJvdERlbHRhKnJhdGlvOyBicmVhaztcblx0XHRcdFx0Y2FzZSBcImZpeGVkXCI6XHQvLyBmb2xsb3cgZml4ZWQgYmVoYXZpb3VyIHRvIHNvbHZlIHBvdGVudGlhbCBpc3N1ZXNcblx0XHRcdFx0ZGVmYXVsdDogdHdlZW4udGFyZ2V0LnJvdGF0aW9uICs9IGRhdGEucm90T2ZmUzsgYnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRkYXRhLmxhc3RSYXRpbyA9IHJhdGlvO1xuXHRcdH1cblx0XHRpZihwcm9wID09IFwicm90YXRpb25cIiAmJiAoKCFkYXRhLm9yaWVudCkgfHwgZGF0YS5vcmllbnQgPT0gXCJmYWxzZVwiKSl7IHJldHVybiB2YWx1ZTsgfVxuXHRcdHJldHVybiB0d2Vlbi50YXJnZXRbcHJvcF07XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZSB0aGUgYXBwcm9wcmlhdGUgeC95L3JvdGF0aW9uIGluZm9ybWF0aW9uIGFib3V0IGEgcGF0aCBmb3IgYSBnaXZlbiByYXRpbyBhbG9uZyB0aGUgcGF0aC5cblx0ICogQXNzdW1lcyBhIHBhdGggb2JqZWN0IHdpdGggYWxsIG9wdGlvbmFsIHBhcmFtZXRlcnMgc3BlY2lmaWVkLlxuXHQgKiBAcGFyYW0gZGF0YSBEYXRhIG9iamVjdCB5b3Ugd291bGQgcGFzcyB0byB0aGUgXCJndWlkZTpcIiBwcm9wZXJ0eSBpbiBhIFR3ZWVuXG5cdCAqIEBwYXJhbSByYXRpbyAwLTEgRGlzdGFuY2UgYWxvbmcgcGF0aCwgdmFsdWVzIG91dHNpZGUgMC0xIGFyZSBcImJlc3QgZ3Vlc3NcIlxuXHQgKiBAcGFyYW0gdGFyZ2V0IE9iamVjdCB0byBjb3B5IHRoZSByZXN1bHRzIG9udG8sIHdpbGwgdXNlIGEgbmV3IG9iamVjdCBpZiBub3Qgc3VwcGxpZWQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIHRhcmdldCBvYmplY3Qgb3IgYSBuZXcgb2JqZWN0IHcvIHRoZSB0d2VlbmVkIHByb3BlcnRpZXNcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uY2FsYyA9IGZ1bmN0aW9uKGRhdGEsIHJhdGlvLCB0YXJnZXQpIHtcblx0XHRpZihkYXRhLl9zZWdtZW50cyA9PSB1bmRlZmluZWQpeyBNb3Rpb25HdWlkZVBsdWdpbi52YWxpZGF0ZShkYXRhKTsgfVxuXHRcdGlmKHRhcmdldCA9PSB1bmRlZmluZWQpeyB0YXJnZXQgPSB7eDowLCB5OjAsIHJvdGF0aW9uOjB9OyB9XG5cdFx0dmFyIHNlZyA9IGRhdGEuX3NlZ21lbnRzO1xuXHRcdHZhciBwYXRoID0gZGF0YS5wYXRoO1xuXG5cdFx0Ly8gZmluZCBzZWdtZW50XG5cdFx0dmFyIHBvcyA9IGRhdGEuX2xlbmd0aCAqIHJhdGlvO1xuXHRcdHZhciBjYXAgPSBzZWcubGVuZ3RoIC0gMjtcblx0XHR2YXIgbiA9IDA7XG5cdFx0d2hpbGUocG9zID4gc2VnW25dICYmIG4gPCBjYXApe1xuXHRcdFx0cG9zIC09IHNlZ1tuXTtcblx0XHRcdG4rPTI7XG5cdFx0fVxuXG5cdFx0Ly8gZmluZCBzdWJsaW5lXG5cdFx0dmFyIHN1YmxpbmVzID0gc2VnW24rMV07XG5cdFx0dmFyIGkgPSAwO1xuXHRcdGNhcCA9IHN1YmxpbmVzLmxlbmd0aC0xO1xuXHRcdHdoaWxlKHBvcyA+IHN1YmxpbmVzW2ldICYmIGkgPCBjYXApe1xuXHRcdFx0cG9zIC09IHN1YmxpbmVzW2ldO1xuXHRcdFx0aSsrO1xuXHRcdH1cblx0XHR2YXIgdCA9IChpLysrY2FwKSsocG9zLyhjYXAqc3VibGluZXNbaV0pKTtcblxuXHRcdC8vIGZpbmQgeC95XG5cdFx0biA9IChuKjIpKzI7XG5cdFx0dmFyIGludiA9IDEgLSB0O1xuXHRcdHRhcmdldC54ID0gaW52KmludiAqIHBhdGhbbi0yXSArIDIgKiBpbnYgKiB0ICogcGF0aFtuKzBdICsgdCp0ICogcGF0aFtuKzJdO1xuXHRcdHRhcmdldC55ID0gaW52KmludiAqIHBhdGhbbi0xXSArIDIgKiBpbnYgKiB0ICogcGF0aFtuKzFdICsgdCp0ICogcGF0aFtuKzNdO1xuXG5cdFx0Ly8gb3JpZW50YXRpb25cblx0XHRpZihkYXRhLm9yaWVudCl7XG5cdFx0XHR0YXJnZXQucm90YXRpb24gPSA1Ny4yOTU3Nzk1ICogTWF0aC5hdGFuMihcblx0XHRcdFx0KHBhdGhbbisxXS1wYXRoW24tMV0pKmludiArIChwYXRoW24rM10tcGF0aFtuKzFdKSp0LFxuXHRcdFx0XHQocGF0aFtuKzBdLXBhdGhbbi0yXSkqaW52ICsgKHBhdGhbbisyXS1wYXRoW24rMF0pKnQpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH07XG5cblx0Y3JlYXRlanMuTW90aW9uR3VpZGVQbHVnaW4gPSBNb3Rpb25HdWlkZVBsdWdpbjtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIHZlcnNpb24uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBTdGF0aWMgY2xhc3MgaG9sZGluZyBsaWJyYXJ5IHNwZWNpZmljIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHZlcnNpb24gYW5kIGJ1aWxkRGF0ZSBvZlxuXHQgKiB0aGUgbGlicmFyeS5cblx0ICogQGNsYXNzIFR3ZWVuSlNcblx0ICoqL1xuXHR2YXIgcyA9IGNyZWF0ZWpzLlR3ZWVuSlMgPSBjcmVhdGVqcy5Ud2VlbkpTIHx8IHt9O1xuXG5cdC8qKlxuXHQgKiBUaGUgdmVyc2lvbiBzdHJpbmcgZm9yIHRoaXMgcmVsZWFzZS5cblx0ICogQHByb3BlcnR5IHZlcnNpb25cblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRzLnZlcnNpb24gPSAvKj12ZXJzaW9uKi9cIjAuNi4xXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxuXHQvKipcblx0ICogVGhlIGJ1aWxkIGRhdGUgZm9yIHRoaXMgcmVsZWFzZSBpbiBVVEMgZm9ybWF0LlxuXHQgKiBAcHJvcGVydHkgYnVpbGREYXRlXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy5idWlsZERhdGUgPSAvKj1kYXRlKi9cIlRodSwgMjEgTWF5IDIwMTUgMTY6MTc6MzcgR01UXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxufSkoKTtcbmlmKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSBtb2R1bGUuZXhwb3J0cyA9IHRoaXMuY3JlYXRlanM7IiwiJ3VzZSBzdHJpY3QnXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHN0YWdlLCByZXNpemVkKSB7XHJcblxyXG5cdHZhciBjcmVhdGVqcyA9IHJlcXVpcmUoJ2NyZWF0ZWpzLWNvbGxlY3Rpb24nKTtcclxuXHJcblx0dmFyIHNxdWFyZVdpZHRoLCBzcXVhcmVIZWlnaHQsIHhPZmZzZXQsIHlPZmZzZXQsIHNwYWNpbmc7XHJcblxyXG5cdHNldFN0YWdlU2l6ZSgpO1xyXG5cdGdldFNxdWFyZURpbWVuc2lvbnMoKTtcclxuXHRnZXRPZmZzZXRzKCk7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcblx0XHRpZiAoIXJlc2l6ZWQpXHJcblx0XHRcdGFkZFNxdWFyZSgpO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRyZWRyYXdTcXVhcmUoaSk7XHJcblx0fVxyXG5cclxuXHRzdGFnZS51cGRhdGUoKTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0U3RhZ2VTaXplKCkge1xyXG5cclxuXHRcdHZhciBnYW1lU2VjdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnYW1lU2VjdGlvbicpO1xyXG5cclxuXHRcdC8vIHJlc2l6ZSBjYW52YXMgdG8gYmUgcmVzcG9uc2l2ZSB3aXRoIHNlY3Rpb24gZWxlbWVudFxyXG5cdFx0dmFyIHdpZHRoID0gZ2FtZVNlY3Rpb24ub2Zmc2V0V2lkdGgsXHJcblx0XHRcdGhlaWdodCA9IGdhbWVTZWN0aW9uLm9mZnNldEhlaWdodDtcclxuXHJcblx0XHQvLyB0aGlzIGVuc3VyZXMgdGhlIHNxdWFyZXMgYXJlIGFsd2F5cyBzcXVhcmVzIGFuZCBmaXQgd2l0aGluIHRoZSBzY3JlZW5cclxuXHRcdGlmICh3aWR0aCA+IGhlaWdodCkge1xyXG5cdFx0XHRzdGFnZS5jYW52YXMud2lkdGggPSBoZWlnaHQ7XHJcblx0XHRcdHN0YWdlLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdGFnZS5jYW52YXMud2lkdGggPSB3aWR0aDtcclxuXHRcdFx0c3RhZ2UuY2FudmFzLmhlaWdodCA9IHdpZHRoO1xyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBnZXRTcXVhcmVEaW1lbnNpb25zKCkge1xyXG5cclxuXHRcdC8vIHNxdWFyZSBkaW1lbnNpb25zXHJcblx0XHRzcXVhcmVXaWR0aCA9IHN0YWdlLmNhbnZhcy53aWR0aCAqIDAuNDtcclxuXHRcdHNxdWFyZUhlaWdodCA9IHN0YWdlLmNhbnZhcy5oZWlnaHQgKiAwLjQ7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGdldE9mZnNldHMoKSB7XHJcblxyXG5cdFx0Ly8geCBhbmQgeSBvZmZzZXRzIGZyb20gY2VudGVyIGZvciBzcXVhcmUgcG9zaXRpb25pbmdcclxuXHRcdHhPZmZzZXQgPSAoc3RhZ2UuY2FudmFzLndpZHRoIC8gMikgLSBzcXVhcmVXaWR0aCAtIDU7XHJcblx0XHR5T2Zmc2V0ID0gKHN0YWdlLmNhbnZhcy5oZWlnaHQgLyAyKSAtIHNxdWFyZUhlaWdodCAtIDU7XHJcblxyXG5cdFx0Ly8gc3BhY2luZyBiZXR3ZWVuIHRoZSBzcXVhcmVzXHJcblx0XHRzcGFjaW5nID0gMTA7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGFkZFNxdWFyZSgpIHtcclxuXHJcblx0XHR2YXIgc3F1YXJlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XHJcblx0XHRzcXVhcmUuZ3JhcGhpY3MuYmVnaW5GaWxsKGdldFNxdWFyZUNvbG9yKHNxdWFyZS5pZCkpLmRyYXdSZWN0KDAsIDAsIHNxdWFyZVdpZHRoLCBzcXVhcmVIZWlnaHQpO1xyXG5cdFx0c3F1YXJlLnNoYWRvdyA9IG5ldyBjcmVhdGVqcy5TaGFkb3coXCIjMDAwXCIsIDUsIDUsIDEwKTtcclxuXHRcdHNxdWFyZS54ID0gZ2V0WFBvc2l0aW9uKHNxdWFyZS5pZCk7XHJcblx0XHRzcXVhcmUueSA9IGdldFlQb3NpdGlvbihzcXVhcmUuaWQpO1xyXG5cdFx0c3RhZ2UuYWRkQ2hpbGQoc3F1YXJlKTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gcmVkcmF3U3F1YXJlKHNxdWFyZUluZGV4KSB7XHJcblxyXG5cdFx0dmFyIHNxdWFyZSA9IHN0YWdlLmdldENoaWxkQXQoc3F1YXJlSW5kZXgpO1xyXG5cdFx0c3F1YXJlLmdyYXBoaWNzLmNsZWFyKCk7XHJcblx0XHRzcXVhcmUuZ3JhcGhpY3MuYmVnaW5GaWxsKGdldFNxdWFyZUNvbG9yKHNxdWFyZS5pZCkpLmRyYXdSZWN0KDAsIDAsIHNxdWFyZVdpZHRoLCBzcXVhcmVIZWlnaHQpO1xyXG5cdFx0c3F1YXJlLnNoYWRvdyA9IG5ldyBjcmVhdGVqcy5TaGFkb3coXCIjMDAwXCIsIDUsIDUsIDEwKTtcclxuXHRcdHNxdWFyZS54ID0gZ2V0WFBvc2l0aW9uKHNxdWFyZS5pZCk7XHJcblx0XHRzcXVhcmUueSA9IGdldFlQb3NpdGlvbihzcXVhcmUuaWQpO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBnZXRTcXVhcmVDb2xvcihzcXVhcmVJZCkge1xyXG5cclxuXHRcdGlmIChzcXVhcmVJZCA9PT0gMSkgXHJcblx0XHRcdHJldHVybiBcInJlZFwiO1xyXG5cdFx0ZWxzZSBpZiAoc3F1YXJlSWQgPT09IDIpIFxyXG5cdFx0XHRyZXR1cm4gXCJncmVlblwiO1xyXG5cdFx0ZWxzZSBpZiAoc3F1YXJlSWQgPT09IDMpXHJcblx0XHRcdHJldHVybiBcImJsdWVcIjtcclxuXHRcdGVsc2VcclxuXHRcdFx0cmV0dXJuIFwieWVsbG93XCI7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0WFBvc2l0aW9uKHNxdWFyZUlkKSB7XHJcblxyXG5cdFx0aWYgKHNxdWFyZUlkID09PSAxIHx8IHNxdWFyZUlkID09PSAzKSBcclxuXHRcdFx0cmV0dXJuIHhPZmZzZXQ7XHJcblx0XHRlbHNlIFxyXG5cdFx0XHRyZXR1cm4geE9mZnNldCArIHNxdWFyZVdpZHRoICsgc3BhY2luZztcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gZ2V0WVBvc2l0aW9uKHNxdWFyZUlkKSB7XHJcblxyXG5cdFx0aWYgKHNxdWFyZUlkID09PSAxIHx8IHNxdWFyZUlkID09PSAyKSBcclxuXHRcdFx0cmV0dXJuIHlPZmZzZXQ7XHJcblx0XHRlbHNlIFxyXG5cdFx0XHRyZXR1cm4geU9mZnNldCArIHNxdWFyZUhlaWdodCArIHNwYWNpbmc7XHJcblxyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0XHREcmF3IEZ1bmN0aW9uIFVzZXM6XHJcblx0XHQtIGRyYXdSZWN0XHJcblx0XHQtIGFwcGx5IHNoYWRvd1xyXG5cdFx0LSBhZGQgdGhlIHJlY3RhbmdsZSB0byB0aGUgY2FudmFzXHJcblxyXG5cdC8qIFxyXG5cdFx0LUNoYW5naW5nIHggbW92ZXMgdGhlIHNoYXBlIGhvcml6b25hdGFsbHlcclxuXHRcdC1DaGFuZ2luZyB5IG1vdmVzIHRoZSBzaGFwZSB2ZXJ0aWNhbGx5XHJcblx0XHQtQ2hhbmdpbmcgYWxwaGEgd2lsbCBmYWRlIHRoZSBzaGFwZSBpbiBhbmQgb3V0XHJcblx0Ki9cclxuXHJcblx0LypcclxuXHRcdGNyZWF0ZWpzLlR3ZWVuLmdldChjaXJjbGUsIHsgbG9vcDogdHJ1ZSB9KVxyXG5cdFx0XHQudG8oeyB4OiA0MDAgfSwgMTAwMCwgY3JlYXRlanMuRWFzZS5nZXRQb3dJbk91dCg0KSlcclxuXHRcdFx0LnRvKHsgYWxwaGE6IDAsIHk6IDE3NSB9LCA1MDAsIGNyZWF0ZWpzLkVhc2UuZ2V0UG93SW5PdXQoMikpXHJcblx0XHRcdC50byh7IGFscGhhOiAwLCB5OiAyMjUgfSwgMTAwKVxyXG5cdFx0XHQudG8oeyBhbHBoYTogMSwgeTogMjAwIH0sIDUwMCwgY3JlYXRlanMuRWFzZS5nZXRQb3dJbk91dCgyKSlcclxuXHRcdFx0LnRvKHsgeDogMTAwIH0sIDgwMCwgY3JlYXRlanMuRWFzZS5nZXRQb3dJbk91dCgyKSk7XHJcblxyXG5cdFx0Y3JlYXRlanMuVGlja2VyLnNldEZQUyg2MCk7XHJcblx0XHRjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgc3RhZ2UpO1xyXG5cdCovXHJcblxyXG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHZhciBjcmVhdGVqcyA9IHJlcXVpcmUoJ2NyZWF0ZWpzLWNvbGxlY3Rpb24nKTtcclxuXHJcblx0dmFyIGNhbnZhcywgc3RhZ2U7XHJcblx0XHRcclxuXHRjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2FtZUNhbnZhcycpO1xyXG5cdHN0YWdlID0gbmV3IGNyZWF0ZWpzLlN0YWdlKGNhbnZhcyk7XHJcblxyXG5cdGNyZWF0ZWpzLlRvdWNoLmVuYWJsZShzdGFnZSk7XHJcblxyXG5cdHN0YWdlLmVuYWJsZU1vdXNlT3ZlcigxMCk7XHJcblx0c3RhZ2UubW91c2VNb3ZlT3V0c2lkZSA9IHRydWU7XHJcblxyXG5cdHJldHVybiBzdGFnZTtcclxuXHJcbn07IiwiKGZ1bmN0aW9uKCkge1xyXG5cclxuXHQndXNlIHN0cmljdCdcclxuXHJcblx0dmFyIGluaXQgPSByZXF1aXJlKCcuL2luaXQnKSxcclxuXHRcdGRyYXcgPSByZXF1aXJlKCcuL2RyYXdTcXVhcmVzJyk7XHJcblxyXG5cdC8vIFBvbGxpbmcgZm9yIHRoZSBzYWtlIG9mIG15IGludGVybiB0ZXN0c1xyXG5cdHZhciBpbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xyXG5cdCAgICBpZihkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XHJcblx0ICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcclxuXHQgICAgICAgIGRvbmUoKTtcclxuXHQgICAgfSAgICBcclxuXHR9LCAxMDApO1xyXG5cclxuXHRmdW5jdGlvbiBkb25lKCkge1xyXG5cclxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemUsIGZhbHNlKTtcclxuXHJcblx0XHR2YXIgc3RhZ2UgPSBpbml0KCk7XHJcblx0XHRkcmF3KHN0YWdlLCBmYWxzZSk7XHJcblx0XHRjb25zb2xlLmxvZygnY29tcGxldGUnKTtcclxuXHJcblx0XHRmdW5jdGlvbiByZXNpemUoKSB7XHJcblxyXG5cdFx0XHRkcmF3KHN0YWdlLCB0cnVlKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0XHJcblxyXG5cdHZhciByYW5kb21JbnQgPSByZXF1aXJlKCcuL3JhbmRvbUludEZyb21JbnRlcnZhbCcpO1xyXG5cclxuXHR2YXIgcmFuZG9tU3F1YXJlID0gcmFuZG9tSW50KDEsIDQpO1xyXG5cclxufSkoKTsiLCIndXNlIHN0cmljdCdcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1pbiwgbWF4KSB7XHJcblxyXG5cdHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4LW1pbisxKSArIG1pbik7XHJcblxyXG59Il19
