(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
var createjs = (this.createjs = (this.createjs || {}));
/*!
* EaselJS
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2010 gskinner.com, inc.
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/


//##############################################################################
// extend.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Sets up the prototype chain and constructor property for a new class.
 *
 * This should be called right after creating the class constructor.
 *
 * 	function MySubClass() {}
 * 	createjs.extend(MySubClass, MySuperClass);
 * 	ClassB.prototype.doSomething = function() { }
 *
 * 	var foo = new MySubClass();
 * 	console.log(foo instanceof MySuperClass); // true
 * 	console.log(foo.prototype.constructor === MySubClass); // true
 *
 * @method extend
 * @param {Function} subclass The subclass.
 * @param {Function} superclass The superclass to extend.
 * @return {Function} Returns the subclass's new prototype.
 */
createjs.extend = function(subclass, superclass) {
	"use strict";

	function o() { this.constructor = subclass; }
	o.prototype = superclass.prototype;
	return (subclass.prototype = new o());
};

//##############################################################################
// promote.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.
 * It is recommended to use the super class's name as the prefix.
 * An alias to the super class's constructor is always added in the format `prefix_constructor`.
 * This allows the subclass to call super class methods without using `function.call`, providing better performance.
 *
 * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, "MySuperClass")`
 * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the
 * prototype of `MySubClass` as `MySuperClass_draw`.
 *
 * This should be called after the class's prototype is fully defined.
 *
 * 	function ClassA(name) {
 * 		this.name = name;
 * 	}
 * 	ClassA.prototype.greet = function() {
 * 		return "Hello "+this.name;
 * 	}
 *
 * 	function ClassB(name, punctuation) {
 * 		this.ClassA_constructor(name);
 * 		this.punctuation = punctuation;
 * 	}
 * 	createjs.extend(ClassB, ClassA);
 * 	ClassB.prototype.greet = function() {
 * 		return this.ClassA_greet()+this.punctuation;
 * 	}
 * 	createjs.promote(ClassB, "ClassA");
 *
 * 	var foo = new ClassB("World", "!?!");
 * 	console.log(foo.greet()); // Hello World!?!
 *
 * @method promote
 * @param {Function} subclass The class to promote super class methods on.
 * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.
 * @return {Function} Returns the subclass.
 */
createjs.promote = function(subclass, prefix) {
	"use strict";

	var subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;
	if (supP) {
		subP[(prefix+="_") + "constructor"] = supP.constructor; // constructor is not always innumerable
		for (var n in supP) {
			if (subP.hasOwnProperty(n) && (typeof supP[n] == "function")) { subP[prefix + n] = supP[n]; }
		}
	}
	return subclass;
};

//##############################################################################
// indexOf.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of
 * that value.  Returns -1 if value is not found.
 *
 *      var i = createjs.indexOf(myArray, myElementToFind);
 *
 * @method indexOf
 * @param {Array} array Array to search for searchElement
 * @param searchElement Element to find in array.
 * @return {Number} The first index of searchElement in array.
 */
createjs.indexOf = function (array, searchElement){
	"use strict";

	for (var i = 0,l=array.length; i < l; i++) {
		if (searchElement === array[i]) {
			return i;
		}
	}
	return -1;
};

//##############################################################################
// Event.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

// constructor:
	/**
	 * Contains properties and methods shared by all events for use with
	 * {{#crossLink "EventDispatcher"}}{{/crossLink}}.
	 * 
	 * Note that Event objects are often reused, so you should never
	 * rely on an event object's state outside of the call stack it was received in.
	 * @class Event
	 * @param {String} type The event type.
	 * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
	 * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
	 * @constructor
	 **/
	function Event(type, bubbles, cancelable) {
		
	
	// public properties:
		/**
		 * The type of event.
		 * @property type
		 * @type String
		 **/
		this.type = type;
	
		/**
		 * The object that generated an event.
		 * @property target
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.target = null;
	
		/**
		 * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will
		 * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event
		 * is generated from childObj, then a listener on parentObj would receive the event with
		 * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).
		 * @property currentTarget
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.currentTarget = null;
	
		/**
		 * For bubbling events, this indicates the current event phase:<OL>
		 * 	<LI> capture phase: starting from the top parent to the target</LI>
		 * 	<LI> at target phase: currently being dispatched from the target</LI>
		 * 	<LI> bubbling phase: from the target to the top parent</LI>
		 * </OL>
		 * @property eventPhase
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.eventPhase = 0;
	
		/**
		 * Indicates whether the event will bubble through the display list.
		 * @property bubbles
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.bubbles = !!bubbles;
	
		/**
		 * Indicates whether the default behaviour of this event can be cancelled via
		 * {{#crossLink "Event/preventDefault"}}{{/crossLink}}. This is set via the Event constructor.
		 * @property cancelable
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.cancelable = !!cancelable;
	
		/**
		 * The epoch time at which this event was created.
		 * @property timeStamp
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.timeStamp = (new Date()).getTime();
	
		/**
		 * Indicates if {{#crossLink "Event/preventDefault"}}{{/crossLink}} has been called
		 * on this event.
		 * @property defaultPrevented
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.defaultPrevented = false;
	
		/**
		 * Indicates if {{#crossLink "Event/stopPropagation"}}{{/crossLink}} or
		 * {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called on this event.
		 * @property propagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.propagationStopped = false;
	
		/**
		 * Indicates if {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called
		 * on this event.
		 * @property immediatePropagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.immediatePropagationStopped = false;
		
		/**
		 * Indicates if {{#crossLink "Event/remove"}}{{/crossLink}} has been called on this event.
		 * @property removed
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.removed = false;
	}
	var p = Event.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.

// public methods:
	/**
	 * Sets {{#crossLink "Event/defaultPrevented"}}{{/crossLink}} to true if the event is cancelable.
	 * Mirrors the DOM level 2 event standard. In general, cancelable events that have `preventDefault()` called will
	 * cancel the default behaviour associated with the event.
	 * @method preventDefault
	 **/
	p.preventDefault = function() {
		this.defaultPrevented = this.cancelable&&true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopPropagation
	 **/
	p.stopPropagation = function() {
		this.propagationStopped = true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} and
	 * {{#crossLink "Event/immediatePropagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopImmediatePropagation
	 **/
	p.stopImmediatePropagation = function() {
		this.immediatePropagationStopped = this.propagationStopped = true;
	};
	
	/**
	 * Causes the active listener to be removed via removeEventListener();
	 * 
	 * 		myBtn.addEventListener("click", function(evt) {
	 * 			// do stuff...
	 * 			evt.remove(); // removes this listener.
	 * 		});
	 * 
	 * @method remove
	 **/
	p.remove = function() {
		this.removed = true;
	};
	
	/**
	 * Returns a clone of the Event instance.
	 * @method clone
	 * @return {Event} a clone of the Event instance.
	 **/
	p.clone = function() {
		return new Event(this.type, this.bubbles, this.cancelable);
	};
	
	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the instance.
	 * @return {Event} Returns the instance the method is called on (useful for chaining calls.)
	 * @chainable
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Event (type="+this.type+")]";
	};

	createjs.Event = Event;
}());

//##############################################################################
// EventDispatcher.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * EventDispatcher provides methods for managing queues of event listeners and dispatching events.
	 *
	 * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the
	 * EventDispatcher {{#crossLink "EventDispatcher/initialize"}}{{/crossLink}} method.
	 * 
	 * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the
	 * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports
	 * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.
	 * 
	 * EventDispatcher also exposes a {{#crossLink "EventDispatcher/on"}}{{/crossLink}} method, which makes it easier
	 * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The 
	 * {{#crossLink "EventDispatcher/off"}}{{/crossLink}} method is merely an alias to
	 * {{#crossLink "EventDispatcher/removeEventListener"}}{{/crossLink}}.
	 * 
	 * Another addition to the DOM Level 2 model is the {{#crossLink "EventDispatcher/removeAllEventListeners"}}{{/crossLink}}
	 * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also 
	 * includes a {{#crossLink "Event/remove"}}{{/crossLink}} method which removes the active listener.
	 *
	 * <h4>Example</h4>
	 * Add EventDispatcher capabilities to the "MyClass" class.
	 *
	 *      EventDispatcher.initialize(MyClass.prototype);
	 *
	 * Add an event (see {{#crossLink "EventDispatcher/addEventListener"}}{{/crossLink}}).
	 *
	 *      instance.addEventListener("eventName", handlerMethod);
	 *      function handlerMethod(event) {
	 *          console.log(event.target + " Was Clicked");
	 *      }
	 *
	 * <b>Maintaining proper scope</b><br />
	 * Scope (ie. "this") can be be a challenge with events. Using the {{#crossLink "EventDispatcher/on"}}{{/crossLink}}
	 * method to subscribe to events simplifies this.
	 *
	 *      instance.addEventListener("click", function(event) {
	 *          console.log(instance == this); // false, scope is ambiguous.
	 *      });
	 *      
	 *      instance.on("click", function(event) {
	 *          console.log(instance == this); // true, "on" uses dispatcher scope by default.
	 *      });
	 * 
	 * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage scope.
	 *      
	 *
	 * @class EventDispatcher
	 * @constructor
	 **/
	function EventDispatcher() {
	
	
	// private properties:
		/**
		 * @protected
		 * @property _listeners
		 * @type Object
		 **/
		this._listeners = null;
		
		/**
		 * @protected
		 * @property _captureListeners
		 * @type Object
		 **/
		this._captureListeners = null;
	}
	var p = EventDispatcher.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// static public methods:
	/**
	 * Static initializer to mix EventDispatcher methods into a target object or prototype.
	 * 
	 * 		EventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class
	 * 		EventDispatcher.initialize(myObject); // add to a specific instance
	 * 
	 * @method initialize
	 * @static
	 * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a
	 * prototype.
	 **/
	EventDispatcher.initialize = function(target) {
		target.addEventListener = p.addEventListener;
		target.on = p.on;
		target.removeEventListener = target.off =  p.removeEventListener;
		target.removeAllEventListeners = p.removeAllEventListeners;
		target.hasEventListener = p.hasEventListener;
		target.dispatchEvent = p.dispatchEvent;
		target._dispatchEvent = p._dispatchEvent;
		target.willTrigger = p.willTrigger;
	};
	

// public methods:
	/**
	 * Adds the specified event listener. Note that adding multiple listeners to the same function will result in
	 * multiple callbacks getting fired.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.addEventListener("click", handleClick);
	 *      function handleClick(event) {
	 *         // Click happened.
	 *      }
	 *
	 * @method addEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function | Object} Returns the listener for chaining or assignment.
	 **/
	p.addEventListener = function(type, listener, useCapture) {
		var listeners;
		if (useCapture) {
			listeners = this._captureListeners = this._captureListeners||{};
		} else {
			listeners = this._listeners = this._listeners||{};
		}
		var arr = listeners[type];
		if (arr) { this.removeEventListener(type, listener, useCapture); }
		arr = listeners[type]; // remove may have deleted the array
		if (!arr) { listeners[type] = [listener];  }
		else { arr.push(listener); }
		return listener;
	};
	
	/**
	 * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener
	 * only run once, associate arbitrary data with the listener, and remove the listener.
	 * 
	 * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.
	 * The wrapper function is returned for use with `removeEventListener` (or `off`).
	 * 
	 * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener, or use
	 * {{#crossLink "Event/remove"}}{{/crossLink}}. Likewise, each time you call `on` a NEW wrapper function is subscribed, so multiple calls
	 * to `on` with the same params will create multiple listeners.
	 * 
	 * <h4>Example</h4>
	 * 
	 * 		var listener = myBtn.on("click", handleClick, null, false, {count:3});
	 * 		function handleClick(evt, data) {
	 * 			data.count -= 1;
	 * 			console.log(this == myBtn); // true - scope defaults to the dispatcher
	 * 			if (data.count == 0) {
	 * 				alert("clicked 3 times!");
	 * 				myBtn.off("click", listener);
	 * 				// alternately: evt.remove();
	 * 			}
	 * 		}
	 * 
	 * @method on
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).
	 * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.
	 * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.
	 * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.
	 **/
	p.on = function(type, listener, scope, once, data, useCapture) {
		if (listener.handleEvent) {
			scope = scope||listener;
			listener = listener.handleEvent;
		}
		scope = scope||this;
		return this.addEventListener(type, function(evt) {
				listener.call(scope, evt, data);
				once&&evt.remove();
			}, useCapture);
	};

	/**
	 * Removes the specified event listener.
	 *
	 * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy
	 * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or
	 * closure will not work.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.removeEventListener("click", handleClick);
	 *
	 * @method removeEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.removeEventListener = function(type, listener, useCapture) {
		var listeners = useCapture ? this._captureListeners : this._listeners;
		if (!listeners) { return; }
		var arr = listeners[type];
		if (!arr) { return; }
		for (var i=0,l=arr.length; i<l; i++) {
			if (arr[i] == listener) {
				if (l==1) { delete(listeners[type]); } // allows for faster checks.
				else { arr.splice(i,1); }
				break;
			}
		}
	};
	
	/**
	 * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the
	 * .on method.
	 * 
	 * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener. See 
	 * {{#crossLink "EventDispatcher/on"}}{{/crossLink}} for an example.
	 *
	 * @method off
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.off = p.removeEventListener;

	/**
	 * Removes all listeners for the specified type, or all listeners of all types.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Remove all listeners
	 *      displayObject.removeAllEventListeners();
	 *
	 *      // Remove all click listeners
	 *      displayObject.removeAllEventListeners("click");
	 *
	 * @method removeAllEventListeners
	 * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.
	 **/
	p.removeAllEventListeners = function(type) {
		if (!type) { this._listeners = this._captureListeners = null; }
		else {
			if (this._listeners) { delete(this._listeners[type]); }
			if (this._captureListeners) { delete(this._captureListeners[type]); }
		}
	};

	/**
	 * Dispatches the specified event to all listeners.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Use a string event
	 *      this.dispatchEvent("complete");
	 *
	 *      // Use an Event instance
	 *      var event = new createjs.Event("progress");
	 *      this.dispatchEvent(event);
	 *
	 * @method dispatchEvent
	 * @param {Object | String | Event} eventObj An object with a "type" property, or a string type.
	 * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,
	 * dispatchEvent will construct an Event instance if necessary with the specified type. This latter approach can
	 * be used to avoid event object instantiation for non-bubbling events that may not have any listeners.
	 * @param {Boolean} [bubbles] Specifies the `bubbles` value when a string was passed to eventObj.
	 * @param {Boolean} [cancelable] Specifies the `cancelable` value when a string was passed to eventObj.
	 * @return {Boolean} Returns false if `preventDefault()` was called on a cancelable event, true otherwise.
	 **/
	p.dispatchEvent = function(eventObj, bubbles, cancelable) {
		if (typeof eventObj == "string") {
			// skip everything if there's no listeners and it doesn't bubble:
			var listeners = this._listeners;
			if (!bubbles && (!listeners || !listeners[eventObj])) { return true; }
			eventObj = new createjs.Event(eventObj, bubbles, cancelable);
		} else if (eventObj.target && eventObj.clone) {
			// redispatching an active event object, so clone it:
			eventObj = eventObj.clone();
		}
		
		// TODO: it would be nice to eliminate this. Maybe in favour of evtObj instanceof Event? Or !!evtObj.createEvent
		try { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events

		if (!eventObj.bubbles || !this.parent) {
			this._dispatchEvent(eventObj, 2);
		} else {
			var top=this, list=[top];
			while (top.parent) { list.push(top = top.parent); }
			var i, l=list.length;

			// capture & atTarget
			for (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {
				list[i]._dispatchEvent(eventObj, 1+(i==0));
			}
			// bubbling
			for (i=1; i<l && !eventObj.propagationStopped; i++) {
				list[i]._dispatchEvent(eventObj, 3);
			}
		}
		return !eventObj.defaultPrevented;
	};

	/**
	 * Indicates whether there is at least one listener for the specified event type.
	 * @method hasEventListener
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns true if there is at least one listener for the specified event.
	 **/
	p.hasEventListener = function(type) {
		var listeners = this._listeners, captureListeners = this._captureListeners;
		return !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));
	};
	
	/**
	 * Indicates whether there is at least one listener for the specified event type on this object or any of its
	 * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the
	 * specified type is dispatched from this object, it will trigger at least one listener.
	 * 
	 * This is similar to {{#crossLink "EventDispatcher/hasEventListener"}}{{/crossLink}}, but it searches the entire
	 * event flow for a listener, not just this object.
	 * @method willTrigger
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns `true` if there is at least one listener for the specified event.
	 **/
	p.willTrigger = function(type) {
		var o = this;
		while (o) {
			if (o.hasEventListener(type)) { return true; }
			o = o.parent;
		}
		return false;
	};

	/**
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[EventDispatcher]";
	};


// private methods:
	/**
	 * @method _dispatchEvent
	 * @param {Object | String | Event} eventObj
	 * @param {Object} eventPhase
	 * @protected
	 **/
	p._dispatchEvent = function(eventObj, eventPhase) {
		var l, listeners = (eventPhase==1) ? this._captureListeners : this._listeners;
		if (eventObj && listeners) {
			var arr = listeners[eventObj.type];
			if (!arr||!(l=arr.length)) { return; }
			try { eventObj.currentTarget = this; } catch (e) {}
			try { eventObj.eventPhase = eventPhase; } catch (e) {}
			eventObj.removed = false;
			
			arr = arr.slice(); // to avoid issues with items being removed or added during the dispatch
			for (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {
				var o = arr[i];
				if (o.handleEvent) { o.handleEvent(eventObj); }
				else { o(eventObj); }
				if (eventObj.removed) {
					this.off(eventObj.type, o, eventPhase==1);
					eventObj.removed = false;
				}
			}
		}
	};


	createjs.EventDispatcher = EventDispatcher;
}());

//##############################################################################
// Ticker.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * The Ticker provides a centralized tick or heartbeat broadcast at a set interval. Listeners can subscribe to the tick
	 * event to be notified when a set time interval has elapsed.
	 *
	 * Note that the interval that the tick event is called is a target interval, and may be broadcast at a slower interval
	 * when under high CPU load. The Ticker class uses a static interface (ex. `Ticker.framerate = 30;`) and
	 * can not be instantiated.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.Ticker.addEventListener("tick", handleTick);
	 *      function handleTick(event) {
	 *          // Actions carried out each tick (aka frame)
	 *          if (!event.paused) {
	 *              // Actions carried out when the Ticker is not paused.
	 *          }
	 *      }
	 *
	 * @class Ticker
	 * @uses EventDispatcher
	 * @static
	 **/
	function Ticker() {
		throw "Ticker cannot be instantiated.";
	}


// constants:
	/**
	 * In this mode, Ticker uses the requestAnimationFrame API, but attempts to synch the ticks to target framerate. It
	 * uses a simple heuristic that compares the time of the RAF return to the target time for the current frame and
	 * dispatches the tick when the time is within a certain threshold.
	 *
	 * This mode has a higher variance for time between frames than {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}},
	 * but does not require that content be time based as with {{#crossLink "Ticker/RAF:property"}}{{/crossLink}} while
	 * gaining the benefits of that API (screen synch, background throttling).
	 *
	 * Variance is usually lowest for framerates that are a divisor of the RAF frequency. This is usually 60, so
	 * framerates of 10, 12, 15, 20, and 30 work well.
	 *
	 * Falls back to {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}} if the requestAnimationFrame API is not
	 * supported.
	 * @property RAF_SYNCHED
	 * @static
	 * @type {String}
	 * @default "synched"
	 * @readonly
	 **/
	Ticker.RAF_SYNCHED = "synched";

	/**
	 * In this mode, Ticker passes through the requestAnimationFrame heartbeat, ignoring the target framerate completely.
	 * Because requestAnimationFrame frequency is not deterministic, any content using this mode should be time based.
	 * You can leverage {{#crossLink "Ticker/getTime"}}{{/crossLink}} and the {{#crossLink "Ticker/tick:event"}}{{/crossLink}}
	 * event object's "delta" properties to make this easier.
	 *
	 * Falls back on {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}} if the requestAnimationFrame API is not
	 * supported.
	 * @property RAF
	 * @static
	 * @type {String}
	 * @default "raf"
	 * @readonly
	 **/
	Ticker.RAF = "raf";

	/**
	 * In this mode, Ticker uses the setTimeout API. This provides predictable, adaptive frame timing, but does not
	 * provide the benefits of requestAnimationFrame (screen synch, background throttling).
	 * @property TIMEOUT
	 * @static
	 * @type {String}
	 * @default "timeout"
	 * @readonly
	 **/
	Ticker.TIMEOUT = "timeout";


// static events:
	/**
	 * Dispatched each tick. The event will be dispatched to each listener even when the Ticker has been paused using
	 * {{#crossLink "Ticker/setPaused"}}{{/crossLink}}.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.Ticker.addEventListener("tick", handleTick);
	 *      function handleTick(event) {
	 *          console.log("Paused:", event.paused, event.delta);
	 *      }
	 *
	 * @event tick
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Boolean} paused Indicates whether the ticker is currently paused.
	 * @param {Number} delta The time elapsed in ms since the last tick.
	 * @param {Number} time The total time in ms since Ticker was initialized.
	 * @param {Number} runTime The total time in ms that Ticker was not paused since it was initialized. For example,
	 * 	you could determine the amount of time that the Ticker has been paused since initialization with `time-runTime`.
	 * @since 0.6.0
	 */


// public static properties:
	/**
	 * Deprecated in favour of {{#crossLink "Ticker/timingMode"}}{{/crossLink}}, and will be removed in a future version. If true, timingMode will
	 * use {{#crossLink "Ticker/RAF_SYNCHED"}}{{/crossLink}} by default.
	 * @deprecated Deprecated in favour of {{#crossLink "Ticker/timingMode"}}{{/crossLink}}.
	 * @property useRAF
	 * @static
	 * @type {Boolean}
	 * @default false
	 **/
	Ticker.useRAF = false;

	/**
	 * Specifies the timing api (setTimeout or requestAnimationFrame) and mode to use. See
	 * {{#crossLink "Ticker/TIMEOUT"}}{{/crossLink}}, {{#crossLink "Ticker/RAF"}}{{/crossLink}}, and
	 * {{#crossLink "Ticker/RAF_SYNCHED"}}{{/crossLink}} for mode details.
	 * @property timingMode
	 * @static
	 * @type {String}
	 * @default Ticker.TIMEOUT
	 **/
	Ticker.timingMode = null;

	/**
	 * Specifies a maximum value for the delta property in the tick event object. This is useful when building time
	 * based animations and systems to prevent issues caused by large time gaps caused by background tabs, system sleep,
	 * alert dialogs, or other blocking routines. Double the expected frame duration is often an effective value
	 * (ex. maxDelta=50 when running at 40fps).
	 * 
	 * This does not impact any other values (ex. time, runTime, etc), so you may experience issues if you enable maxDelta
	 * when using both delta and other values.
	 * 
	 * If 0, there is no maximum.
	 * @property maxDelta
	 * @static
	 * @type {number}
	 * @default 0
	 */
	Ticker.maxDelta = 0;
	
	/**
	 * When the ticker is paused, all listeners will still receive a tick event, but the <code>paused</code> property
	 * of the event will be `true`. Also, while paused the `runTime` will not increase. See {{#crossLink "Ticker/tick:event"}}{{/crossLink}},
	 * {{#crossLink "Ticker/getTime"}}{{/crossLink}}, and {{#crossLink "Ticker/getEventTime"}}{{/crossLink}} for more
	 * info.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.Ticker.addEventListener("tick", handleTick);
	 *      createjs.Ticker.paused = true;
	 *      function handleTick(event) {
	 *          console.log(event.paused,
	 *          	createjs.Ticker.getTime(false),
	 *          	createjs.Ticker.getTime(true));
	 *      }
	 *
	 * @property paused
	 * @static
	 * @type {Boolean}
	 * @default false
	 **/
	Ticker.paused = false;


// mix-ins:
	// EventDispatcher methods:
	Ticker.removeEventListener = null;
	Ticker.removeAllEventListeners = null;
	Ticker.dispatchEvent = null;
	Ticker.hasEventListener = null;
	Ticker._listeners = null;
	createjs.EventDispatcher.initialize(Ticker); // inject EventDispatcher methods.
	Ticker._addEventListener = Ticker.addEventListener;
	Ticker.addEventListener = function() {
		!Ticker._inited&&Ticker.init();
		return Ticker._addEventListener.apply(Ticker, arguments);
	};


// private static properties:
	/**
	 * @property _inited
	 * @static
	 * @type {Boolean}
	 * @protected
	 **/
	Ticker._inited = false;

	/**
	 * @property _startTime
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._startTime = 0;

	/**
	 * @property _pausedTime
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._pausedTime=0;

	/**
	 * The number of ticks that have passed
	 * @property _ticks
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._ticks = 0;

	/**
	 * The number of ticks that have passed while Ticker has been paused
	 * @property _pausedTicks
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._pausedTicks = 0;

	/**
	 * @property _interval
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._interval = 50;

	/**
	 * @property _lastTime
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._lastTime = 0;

	/**
	 * @property _times
	 * @static
	 * @type {Array}
	 * @protected
	 **/
	Ticker._times = null;

	/**
	 * @property _tickTimes
	 * @static
	 * @type {Array}
	 * @protected
	 **/
	Ticker._tickTimes = null;

	/**
	 * Stores the timeout or requestAnimationFrame id.
	 * @property _timerId
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._timerId = null;
	
	/**
	 * True if currently using requestAnimationFrame, false if using setTimeout. This may be different than timingMode
	 * if that property changed and a tick hasn't fired.
	 * @property _raf
	 * @static
	 * @type {Boolean}
	 * @protected
	 **/
	Ticker._raf = true;
	

// static getter / setters:
	/**
	 * Use the {{#crossLink "Ticker/interval:property"}}{{/crossLink}} property instead.
	 * @method setInterval
	 * @static
	 * @param {Number} interval
	 * @deprecated
	 **/
	Ticker.setInterval = function(interval) {
		Ticker._interval = interval;
		if (!Ticker._inited) { return; }
		Ticker._setupTick();
	};

	/**
	 * Use the {{#crossLink "Ticker/interval:property"}}{{/crossLink}} property instead.
	 * @method getInterval
	 * @static
	 * @return {Number}
	 * @deprecated
	 **/
	Ticker.getInterval = function() {
		return Ticker._interval;
	};

	/**
	 * Use the {{#crossLink "Ticker/framerate:property"}}{{/crossLink}} property instead.
	 * @method setFPS
	 * @static
	 * @param {Number} value
	 * @deprecated
	 **/
	Ticker.setFPS = function(value) {
		Ticker.setInterval(1000/value);
	};

	/**
	 * Use the {{#crossLink "Ticker/framerate:property"}}{{/crossLink}} property instead.
	 * @method getFPS
	 * @static
	 * @return {Number}
	 * @deprecated
	 **/
	Ticker.getFPS = function() {
		return 1000/Ticker._interval;
	};

	/**
	 * Indicates the target time (in milliseconds) between ticks. Default is 50 (20 FPS).
	 * Note that actual time between ticks may be more than specified depending on CPU load.
	 * This property is ignored if the ticker is using the `RAF` timing mode.
	 * @property interval
	 * @static
	 * @type {Number}
	 **/
	 
	/**
	 * Indicates the target frame rate in frames per second (FPS). Effectively just a shortcut to `interval`, where
	 * `framerate == 1000/interval`.
	 * @property framerate
	 * @static
	 * @type {Number}
	 **/
	try {
		Object.defineProperties(Ticker, {
			interval: { get: Ticker.getInterval, set: Ticker.setInterval },
			framerate: { get: Ticker.getFPS, set: Ticker.setFPS }
		});
	} catch (e) { console.log(e); }


// public static methods:
	/**
	 * Starts the tick. This is called automatically when the first listener is added.
	 * @method init
	 * @static
	 **/
	Ticker.init = function() {
		if (Ticker._inited) { return; }
		Ticker._inited = true;
		Ticker._times = [];
		Ticker._tickTimes = [];
		Ticker._startTime = Ticker._getTime();
		Ticker._times.push(Ticker._lastTime = 0);
		Ticker.interval = Ticker._interval;
	};
	
	/**
	 * Stops the Ticker and removes all listeners. Use init() to restart the Ticker.
	 * @method reset
	 * @static
	 **/
	Ticker.reset = function() {
		if (Ticker._raf) {
			var f = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;
			f&&f(Ticker._timerId);
		} else {
			clearTimeout(Ticker._timerId);
		}
		Ticker.removeAllEventListeners("tick");
		Ticker._timerId = Ticker._times = Ticker._tickTimes = null;
		Ticker._startTime = Ticker._lastTime = Ticker._ticks = 0;
		Ticker._inited = false;
	};

	/**
	 * Returns the average time spent within a tick. This can vary significantly from the value provided by getMeasuredFPS
	 * because it only measures the time spent within the tick execution stack. 
	 * 
	 * Example 1: With a target FPS of 20, getMeasuredFPS() returns 20fps, which indicates an average of 50ms between 
	 * the end of one tick and the end of the next. However, getMeasuredTickTime() returns 15ms. This indicates that 
	 * there may be up to 35ms of "idle" time between the end of one tick and the start of the next.
	 *
	 * Example 2: With a target FPS of 30, getFPS() returns 10fps, which indicates an average of 100ms between the end of
	 * one tick and the end of the next. However, getMeasuredTickTime() returns 20ms. This would indicate that something
	 * other than the tick is using ~80ms (another script, DOM rendering, etc).
	 * @method getMeasuredTickTime
	 * @static
	 * @param {Number} [ticks] The number of previous ticks over which to measure the average time spent in a tick.
	 * Defaults to the number of ticks per second. To get only the last tick's time, pass in 1.
	 * @return {Number} The average time spent in a tick in milliseconds.
	 **/
	Ticker.getMeasuredTickTime = function(ticks) {
		var ttl=0, times=Ticker._tickTimes;
		if (!times || times.length < 1) { return -1; }

		// by default, calculate average for the past ~1 second:
		ticks = Math.min(times.length, ticks||(Ticker.getFPS()|0));
		for (var i=0; i<ticks; i++) { ttl += times[i]; }
		return ttl/ticks;
	};

	/**
	 * Returns the actual frames / ticks per second.
	 * @method getMeasuredFPS
	 * @static
	 * @param {Number} [ticks] The number of previous ticks over which to measure the actual frames / ticks per second.
	 * Defaults to the number of ticks per second.
	 * @return {Number} The actual frames / ticks per second. Depending on performance, this may differ
	 * from the target frames per second.
	 **/
	Ticker.getMeasuredFPS = function(ticks) {
		var times = Ticker._times;
		if (!times || times.length < 2) { return -1; }

		// by default, calculate fps for the past ~1 second:
		ticks = Math.min(times.length-1, ticks||(Ticker.getFPS()|0));
		return 1000/((times[0]-times[ticks])/ticks);
	};

	/**
	 * Use the {{#crossLink "Ticker/paused:property"}}{{/crossLink}} property instead.
	 * @method setPaused
	 * @static
	 * @param {Boolean} value
	 * @deprecated
	 **/
	Ticker.setPaused = function(value) {
		// TODO: deprecated.
		Ticker.paused = value;
	};

	/**
	 * Use the {{#crossLink "Ticker/paused:property"}}{{/crossLink}} property instead.
	 * @method getPaused
	 * @static
	 * @return {Boolean}
	 * @deprecated
	 **/
	Ticker.getPaused = function() {
		// TODO: deprecated.
		return Ticker.paused;
	};

	/**
	 * Returns the number of milliseconds that have elapsed since Ticker was initialized via {{#crossLink "Ticker/init"}}.
	 * Returns -1 if Ticker has not been initialized. For example, you could use
	 * this in a time synchronized animation to determine the exact amount of time that has elapsed.
	 * @method getTime
	 * @static
	 * @param {Boolean} [runTime=false] If true only time elapsed while Ticker was not paused will be returned.
	 * If false, the value returned will be total time elapsed since the first tick event listener was added.
	 * @return {Number} Number of milliseconds that have elapsed since Ticker was initialized or -1.
	 **/
	Ticker.getTime = function(runTime) {
		return Ticker._startTime ? Ticker._getTime() - (runTime ? Ticker._pausedTime : 0) : -1;
	};

	/**
	 * Similar to the {{#crossLink "Ticker/getTime"}}{{/crossLink}} method, but returns the time on the most recent {{#crossLink "Ticker/tick:event"}}{{/crossLink}}
	 * event object.
	 * @method getEventTime
	 * @static
	 * @param runTime {Boolean} [runTime=false] If true, the runTime property will be returned instead of time.
	 * @returns {number} The time or runTime property from the most recent tick event or -1.
	 */
	Ticker.getEventTime = function(runTime) {
		return Ticker._startTime ? (Ticker._lastTime || Ticker._startTime) - (runTime ? Ticker._pausedTime : 0) : -1;
	};
	
	/**
	 * Returns the number of ticks that have been broadcast by Ticker.
	 * @method getTicks
	 * @static
	 * @param {Boolean} pauseable Indicates whether to include ticks that would have been broadcast
	 * while Ticker was paused. If true only tick events broadcast while Ticker is not paused will be returned.
	 * If false, tick events that would have been broadcast while Ticker was paused will be included in the return
	 * value. The default value is false.
	 * @return {Number} of ticks that have been broadcast.
	 **/
	Ticker.getTicks = function(pauseable) {
		return  Ticker._ticks - (pauseable ? Ticker._pausedTicks : 0);
	};


// private static methods:
	/**
	 * @method _handleSynch
	 * @static
	 * @protected
	 **/
	Ticker._handleSynch = function() {
		Ticker._timerId = null;
		Ticker._setupTick();

		// run if enough time has elapsed, with a little bit of flexibility to be early:
		if (Ticker._getTime() - Ticker._lastTime >= (Ticker._interval-1)*0.97) {
			Ticker._tick();
		}
	};

	/**
	 * @method _handleRAF
	 * @static
	 * @protected
	 **/
	Ticker._handleRAF = function() {
		Ticker._timerId = null;
		Ticker._setupTick();
		Ticker._tick();
	};

	/**
	 * @method _handleTimeout
	 * @static
	 * @protected
	 **/
	Ticker._handleTimeout = function() {
		Ticker._timerId = null;
		Ticker._setupTick();
		Ticker._tick();
	};

	/**
	 * @method _setupTick
	 * @static
	 * @protected
	 **/
	Ticker._setupTick = function() {
		if (Ticker._timerId != null) { return; } // avoid duplicates

		var mode = Ticker.timingMode||(Ticker.useRAF&&Ticker.RAF_SYNCHED);
		if (mode == Ticker.RAF_SYNCHED || mode == Ticker.RAF) {
			var f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
			if (f) {
				Ticker._timerId = f(mode == Ticker.RAF ? Ticker._handleRAF : Ticker._handleSynch);
				Ticker._raf = true;
				return;
			}
		}
		Ticker._raf = false;
		Ticker._timerId = setTimeout(Ticker._handleTimeout, Ticker._interval);
	};

	/**
	 * @method _tick
	 * @static
	 * @protected
	 **/
	Ticker._tick = function() {
		var paused = Ticker.paused;
		var time = Ticker._getTime();
		var elapsedTime = time-Ticker._lastTime;
		Ticker._lastTime = time;
		Ticker._ticks++;
		
		if (paused) {
			Ticker._pausedTicks++;
			Ticker._pausedTime += elapsedTime;
		}
		
		if (Ticker.hasEventListener("tick")) {
			var event = new createjs.Event("tick");
			var maxDelta = Ticker.maxDelta;
			event.delta = (maxDelta && elapsedTime > maxDelta) ? maxDelta : elapsedTime;
			event.paused = paused;
			event.time = time;
			event.runTime = time-Ticker._pausedTime;
			Ticker.dispatchEvent(event);
		}
		
		Ticker._tickTimes.unshift(Ticker._getTime()-time);
		while (Ticker._tickTimes.length > 100) { Ticker._tickTimes.pop(); }

		Ticker._times.unshift(time);
		while (Ticker._times.length > 100) { Ticker._times.pop(); }
	};

	/**
	 * @method _getTime
	 * @static
	 * @protected
	 **/
	var now = window.performance && (performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow);
	Ticker._getTime = function() {
		return ((now&&now.call(performance))||(new Date().getTime())) - Ticker._startTime;
	};


	createjs.Ticker = Ticker;
}());

//##############################################################################
// UID.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Global utility for generating sequential unique ID numbers. The UID class uses a static interface (ex. <code>UID.get()</code>)
	 * and should not be instantiated.
	 * @class UID
	 * @static
	 **/
	function UID() {
		throw "UID cannot be instantiated";
	}


// private static properties:
	/**
	 * @property _nextID
	 * @type Number
	 * @protected
	 **/
	UID._nextID = 0;


// public static methods:
	/**
	 * Returns the next unique id.
	 * @method get
	 * @return {Number} The next unique id
	 * @static
	 **/
	UID.get = function() {
		return UID._nextID++;
	};


	createjs.UID = UID;
}());

//##############################################################################
// MouseEvent.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Passed as the parameter to all mouse/pointer/touch related events. For a listing of mouse events and their properties,
	 * see the {{#crossLink "DisplayObject"}}{{/crossLink}} and {{#crossLink "Stage"}}{{/crossLink}} event listings.
	 * @class MouseEvent
	 * @param {String} type The event type.
	 * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
	 * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
	 * @param {Number} stageX The normalized x position relative to the stage.
	 * @param {Number} stageY The normalized y position relative to the stage.
	 * @param {MouseEvent} nativeEvent The native DOM event related to this mouse event.
	 * @param {Number} pointerID The unique id for the pointer.
	 * @param {Boolean} primary Indicates whether this is the primary pointer in a multitouch environment.
	 * @param {Number} rawX The raw x position relative to the stage.
	 * @param {Number} rawY The raw y position relative to the stage.
	 * @param {DisplayObject} relatedTarget The secondary target for the event.
	 * @extends Event
	 * @constructor
	 **/
	function MouseEvent(type, bubbles, cancelable, stageX, stageY, nativeEvent, pointerID, primary, rawX, rawY, relatedTarget) {
		this.Event_constructor(type, bubbles, cancelable);
		
		
	// public properties:
		/**
		 * The normalized x position on the stage. This will always be within the range 0 to stage width.
		 * @property stageX
		 * @type Number
		*/
		this.stageX = stageX;
	
		/**
		 * The normalized y position on the stage. This will always be within the range 0 to stage height.
		 * @property stageY
		 * @type Number
		 **/
		this.stageY = stageY;
	
		/**
		 * The raw x position relative to the stage. Normally this will be the same as the stageX value, unless
		 * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.
		 * @property rawX
		 * @type Number
		*/
		this.rawX = (rawX==null)?stageX:rawX;
	
		/**
		 * The raw y position relative to the stage. Normally this will be the same as the stageY value, unless
		 * stage.mouseMoveOutside is true and the pointer is outside of the stage bounds.
		 * @property rawY
		 * @type Number
		*/
		this.rawY = (rawY==null)?stageY:rawY;
	
		/**
		 * The native MouseEvent generated by the browser. The properties and API for this
		 * event may differ between browsers. This property will be null if the
		 * EaselJS property was not directly generated from a native MouseEvent.
		 * @property nativeEvent
		 * @type HtmlMouseEvent
		 * @default null
		 **/
		this.nativeEvent = nativeEvent;
	
		/**
		 * The unique id for the pointer (touch point or cursor). This will be either -1 for the mouse, or the system
		 * supplied id value.
		 * @property pointerID
		 * @type {Number}
		 */
		this.pointerID = pointerID;
	
		/**
		 * Indicates whether this is the primary pointer in a multitouch environment. This will always be true for the mouse.
		 * For touch pointers, the first pointer in the current stack will be considered the primary pointer.
		 * @property primary
		 * @type {Boolean}
		 */
		this.primary = !!primary;
		
		/**
		 * The secondary target for the event, if applicable. This is used for mouseout/rollout
		 * events to indicate the object that the mouse entered from, mouseover/rollover for the object the mouse exited,
		 * and stagemousedown/stagemouseup events for the object that was the under the cursor, if any.
		 * 
		 * Only valid interaction targets will be returned (ie. objects with mouse listeners or a cursor set).
		 * @property relatedTarget
		 * @type {DisplayObject}
		 */
		this.relatedTarget = relatedTarget;
	}
	var p = createjs.extend(MouseEvent, createjs.Event);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
	
// getter / setters:
	/**
	 * Returns the x position of the mouse in the local coordinate system of the current target (ie. the dispatcher).
	 * @property localX
	 * @type {Number}
	 * @readonly
	 */
	p._get_localX = function() {
		return this.currentTarget.globalToLocal(this.rawX, this.rawY).x;
	};
	
	/**
	 * Returns the y position of the mouse in the local coordinate system of the current target (ie. the dispatcher).
	 * @property localY
	 * @type {Number}
	 * @readonly
	 */
	p._get_localY = function() {
		return this.currentTarget.globalToLocal(this.rawX, this.rawY).y;
	};
	
	/**
	 * Indicates whether the event was generated by a touch input (versus a mouse input).
	 * @property isTouch
	 * @type {Boolean}
	 * @readonly
	 */
	p._get_isTouch = function() {
		return this.pointerID !== -1;
	};
	
	
	try {
		Object.defineProperties(p, {
			localX: { get: p._get_localX },
			localY: { get: p._get_localY },
			isTouch: { get: p._get_isTouch }
		});
	} catch (e) {} // TODO: use Log


// public methods:
	/**
	 * Returns a clone of the MouseEvent instance.
	 * @method clone
	 * @return {MouseEvent} a clone of the MouseEvent instance.
	 **/
	p.clone = function() {
		return new MouseEvent(this.type, this.bubbles, this.cancelable, this.stageX, this.stageY, this.nativeEvent, this.pointerID, this.primary, this.rawX, this.rawY);
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[MouseEvent (type="+this.type+" stageX="+this.stageX+" stageY="+this.stageY+")]";
	};


	createjs.MouseEvent = createjs.promote(MouseEvent, "Event");
}());

//##############################################################################
// Matrix2D.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Represents an affine transformation matrix, and provides tools for constructing and concatenating matrices.
	 *
	 * This matrix can be visualized as:
	 *
	 * 	[ a  c  tx
	 * 	  b  d  ty
	 * 	  0  0  1  ]
	 *
	 * Note the locations of b and c.
	 *
	 * @class Matrix2D
	 * @param {Number} [a=1] Specifies the a property for the new matrix.
	 * @param {Number} [b=0] Specifies the b property for the new matrix.
	 * @param {Number} [c=0] Specifies the c property for the new matrix.
	 * @param {Number} [d=1] Specifies the d property for the new matrix.
	 * @param {Number} [tx=0] Specifies the tx property for the new matrix.
	 * @param {Number} [ty=0] Specifies the ty property for the new matrix.
	 * @constructor
	 **/
	function Matrix2D(a, b, c, d, tx, ty) {
		this.setValues(a,b,c,d,tx,ty);
		
	// public properties:
		// assigned in the setValues method.
		/**
		 * Position (0, 0) in a 3x3 affine transformation matrix.
		 * @property a
		 * @type Number
		 **/
	
		/**
		 * Position (0, 1) in a 3x3 affine transformation matrix.
		 * @property b
		 * @type Number
		 **/
	
		/**
		 * Position (1, 0) in a 3x3 affine transformation matrix.
		 * @property c
		 * @type Number
		 **/
	
		/**
		 * Position (1, 1) in a 3x3 affine transformation matrix.
		 * @property d
		 * @type Number
		 **/
	
		/**
		 * Position (2, 0) in a 3x3 affine transformation matrix.
		 * @property tx
		 * @type Number
		 **/
	
		/**
		 * Position (2, 1) in a 3x3 affine transformation matrix.
		 * @property ty
		 * @type Number
		 **/
	}
	var p = Matrix2D.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// constants:
	/**
	 * Multiplier for converting degrees to radians. Used internally by Matrix2D.
	 * @property DEG_TO_RAD
	 * @static
	 * @final
	 * @type Number
	 * @readonly
	 **/
	Matrix2D.DEG_TO_RAD = Math.PI/180;


// static public properties:
	/**
	 * An identity matrix, representing a null transformation.
	 * @property identity
	 * @static
	 * @type Matrix2D
	 * @readonly
	 **/
	Matrix2D.identity = null; // set at bottom of class definition.
	

// public methods:
	/**
	 * Sets the specified values on this instance. 
	 * @method setValues
	 * @param {Number} [a=1] Specifies the a property for the new matrix.
	 * @param {Number} [b=0] Specifies the b property for the new matrix.
	 * @param {Number} [c=0] Specifies the c property for the new matrix.
	 * @param {Number} [d=1] Specifies the d property for the new matrix.
	 * @param {Number} [tx=0] Specifies the tx property for the new matrix.
	 * @param {Number} [ty=0] Specifies the ty property for the new matrix.
	 * @return {Matrix2D} This instance. Useful for chaining method calls.
	*/
	p.setValues = function(a, b, c, d, tx, ty) {
		// don't forget to update docs in the constructor if these change:
		this.a = (a == null) ? 1 : a;
		this.b = b || 0;
		this.c = c || 0;
		this.d = (d == null) ? 1 : d;
		this.tx = tx || 0;
		this.ty = ty || 0;
		return this;
	};

	/**
	 * Appends the specified matrix properties to this matrix. All parameters are required.
	 * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.
	 * @method append
	 * @param {Number} a
	 * @param {Number} b
	 * @param {Number} c
	 * @param {Number} d
	 * @param {Number} tx
	 * @param {Number} ty
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.append = function(a, b, c, d, tx, ty) {
		var a1 = this.a;
		var b1 = this.b;
		var c1 = this.c;
		var d1 = this.d;
		if (a != 1 || b != 0 || c != 0 || d != 1) {
			this.a  = a1*a+c1*b;
			this.b  = b1*a+d1*b;
			this.c  = a1*c+c1*d;
			this.d  = b1*c+d1*d;
		}
		this.tx = a1*tx+c1*ty+this.tx;
		this.ty = b1*tx+d1*ty+this.ty;
		return this;
	};

	/**
	 * Prepends the specified matrix properties to this matrix.
	 * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.
	 * All parameters are required.
	 * @method prepend
	 * @param {Number} a
	 * @param {Number} b
	 * @param {Number} c
	 * @param {Number} d
	 * @param {Number} tx
	 * @param {Number} ty
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.prepend = function(a, b, c, d, tx, ty) {
		var a1 = this.a;
		var c1 = this.c;
		var tx1 = this.tx;

		this.a  = a*a1+c*this.b;
		this.b  = b*a1+d*this.b;
		this.c  = a*c1+c*this.d;
		this.d  = b*c1+d*this.d;
		this.tx = a*tx1+c*this.ty+tx;
		this.ty = b*tx1+d*this.ty+ty;
		return this;
	};

	/**
	 * Appends the specified matrix to this matrix.
	 * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.
	 * @method appendMatrix
	 * @param {Matrix2D} matrix
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.appendMatrix = function(matrix) {
		return this.append(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
	};

	/**
	 * Prepends the specified matrix to this matrix.
	 * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.
	 * For example, you could calculate the combined transformation for a child object using:
	 * 
	 * 	var o = myDisplayObject;
	 * 	var mtx = o.getMatrix();
	 * 	while (o = o.parent) {
	 * 		// prepend each parent's transformation in turn:
	 * 		o.prependMatrix(o.getMatrix());
	 * 	}
	 * @method prependMatrix
	 * @param {Matrix2D} matrix
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.prependMatrix = function(matrix) {
		return this.prepend(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
	};

	/**
	 * Generates matrix properties from the specified display object transform properties, and appends them to this matrix.
	 * For example, you can use this to generate a matrix representing the transformations of a display object:
	 * 
	 * 	var mtx = new Matrix2D();
	 * 	mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);
	 * @method appendTransform
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} scaleX
	 * @param {Number} scaleY
	 * @param {Number} rotation
	 * @param {Number} skewX
	 * @param {Number} skewY
	 * @param {Number} regX Optional.
	 * @param {Number} regY Optional.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.appendTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
		if (rotation%360) {
			var r = rotation*Matrix2D.DEG_TO_RAD;
			var cos = Math.cos(r);
			var sin = Math.sin(r);
		} else {
			cos = 1;
			sin = 0;
		}

		if (skewX || skewY) {
			// TODO: can this be combined into a single append operation?
			skewX *= Matrix2D.DEG_TO_RAD;
			skewY *= Matrix2D.DEG_TO_RAD;
			this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
			this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
		} else {
			this.append(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
		}
		
		if (regX || regY) {
			// append the registration offset:
			this.tx -= regX*this.a+regY*this.c; 
			this.ty -= regX*this.b+regY*this.d;
		}
		return this;
	};

	/**
	 * Generates matrix properties from the specified display object transform properties, and prepends them to this matrix.
	 * For example, you could calculate the combined transformation for a child object using:
	 * 
	 * 	var o = myDisplayObject;
	 * 	var mtx = new createjs.Matrix2D();
	 * 	do  {
	 * 		// prepend each parent's transformation in turn:
	 * 		mtx.prependTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);
	 * 	} while (o = o.parent);
	 * 	
	 * 	Note that the above example would not account for {{#crossLink "DisplayObject/transformMatrix:property"}}{{/crossLink}}
	 * 	values. See {{#crossLink "Matrix2D/prependMatrix"}}{{/crossLink}} for an example that does.
	 * @method prependTransform
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} scaleX
	 * @param {Number} scaleY
	 * @param {Number} rotation
	 * @param {Number} skewX
	 * @param {Number} skewY
	 * @param {Number} regX Optional.
	 * @param {Number} regY Optional.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.prependTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
		if (rotation%360) {
			var r = rotation*Matrix2D.DEG_TO_RAD;
			var cos = Math.cos(r);
			var sin = Math.sin(r);
		} else {
			cos = 1;
			sin = 0;
		}

		if (regX || regY) {
			// prepend the registration offset:
			this.tx -= regX; this.ty -= regY;
		}
		if (skewX || skewY) {
			// TODO: can this be combined into a single prepend operation?
			skewX *= Matrix2D.DEG_TO_RAD;
			skewY *= Matrix2D.DEG_TO_RAD;
			this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, 0, 0);
			this.prepend(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);
		} else {
			this.prepend(cos*scaleX, sin*scaleX, -sin*scaleY, cos*scaleY, x, y);
		}
		return this;
	};

	/**
	 * Applies a clockwise rotation transformation to the matrix.
	 * @method rotate
	 * @param {Number} angle The angle to rotate by, in degrees. To use a value in radians, multiply it by `180/Math.PI`.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.rotate = function(angle) {
		angle = angle*Matrix2D.DEG_TO_RAD;
		var cos = Math.cos(angle);
		var sin = Math.sin(angle);

		var a1 = this.a;
		var b1 = this.b;

		this.a = a1*cos+this.c*sin;
		this.b = b1*cos+this.d*sin;
		this.c = -a1*sin+this.c*cos;
		this.d = -b1*sin+this.d*cos;
		return this;
	};

	/**
	 * Applies a skew transformation to the matrix.
	 * @method skew
	 * @param {Number} skewX The amount to skew horizontally in degrees. To use a value in radians, multiply it by `180/Math.PI`.
	 * @param {Number} skewY The amount to skew vertically in degrees.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	*/
	p.skew = function(skewX, skewY) {
		skewX = skewX*Matrix2D.DEG_TO_RAD;
		skewY = skewY*Matrix2D.DEG_TO_RAD;
		this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), 0, 0);
		return this;
	};

	/**
	 * Applies a scale transformation to the matrix.
	 * @method scale
	 * @param {Number} x The amount to scale horizontally. E.G. a value of 2 will double the size in the X direction, and 0.5 will halve it.
	 * @param {Number} y The amount to scale vertically.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.scale = function(x, y) {
		this.a *= x;
		this.b *= x;
		this.c *= y;
		this.d *= y;
		//this.tx *= x;
		//this.ty *= y;
		return this;
	};

	/**
	 * Translates the matrix on the x and y axes.
	 * @method translate
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.translate = function(x, y) {
		this.tx += this.a*x + this.c*y;
		this.ty += this.b*x + this.d*y;
		return this;
	};

	/**
	 * Sets the properties of the matrix to those of an identity matrix (one that applies a null transformation).
	 * @method identity
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.identity = function() {
		this.a = this.d = 1;
		this.b = this.c = this.tx = this.ty = 0;
		return this;
	};

	/**
	 * Inverts the matrix, causing it to perform the opposite transformation.
	 * @method invert
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	 **/
	p.invert = function() {
		var a1 = this.a;
		var b1 = this.b;
		var c1 = this.c;
		var d1 = this.d;
		var tx1 = this.tx;
		var n = a1*d1-b1*c1;

		this.a = d1/n;
		this.b = -b1/n;
		this.c = -c1/n;
		this.d = a1/n;
		this.tx = (c1*this.ty-d1*tx1)/n;
		this.ty = -(a1*this.ty-b1*tx1)/n;
		return this;
	};

	/**
	 * Returns true if the matrix is an identity matrix.
	 * @method isIdentity
	 * @return {Boolean}
	 **/
	p.isIdentity = function() {
		return this.tx === 0 && this.ty === 0 && this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1;
	};
	
	/**
	 * Returns true if this matrix is equal to the specified matrix (all property values are equal).
	 * @method equals
	 * @param {Matrix2D} matrix The matrix to compare.
	 * @return {Boolean}
	 **/
	p.equals = function(matrix) {
		return this.tx === matrix.tx && this.ty === matrix.ty && this.a === matrix.a && this.b === matrix.b && this.c === matrix.c && this.d === matrix.d;
	};

	/**
	 * Transforms a point according to this matrix.
	 * @method transformPoint
	 * @param {Number} x The x component of the point to transform.
	 * @param {Number} y The y component of the point to transform.
	 * @param {Point | Object} [pt] An object to copy the result into. If omitted a generic object with x/y properties will be returned.
	 * @return {Point} This matrix. Useful for chaining method calls.
	 **/
	p.transformPoint = function(x, y, pt) {
		pt = pt||{};
		pt.x = x*this.a+y*this.c+this.tx;
		pt.y = x*this.b+y*this.d+this.ty;
		return pt;
	};

	/**
	 * Decomposes the matrix into transform properties (x, y, scaleX, scaleY, and rotation). Note that these values
	 * may not match the transform properties you used to generate the matrix, though they will produce the same visual
	 * results.
	 * @method decompose
	 * @param {Object} target The object to apply the transform properties to. If null, then a new object will be returned.
	 * @return {Object} The target, or a new generic object with the transform properties applied.
	*/
	p.decompose = function(target) {
		// TODO: it would be nice to be able to solve for whether the matrix can be decomposed into only scale/rotation even when scale is negative
		if (target == null) { target = {}; }
		target.x = this.tx;
		target.y = this.ty;
		target.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);
		target.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);

		var skewX = Math.atan2(-this.c, this.d);
		var skewY = Math.atan2(this.b, this.a);

		var delta = Math.abs(1-skewX/skewY);
		if (delta < 0.00001) { // effectively identical, can use rotation:
			target.rotation = skewY/Matrix2D.DEG_TO_RAD;
			if (this.a < 0 && this.d >= 0) {
				target.rotation += (target.rotation <= 0) ? 180 : -180;
			}
			target.skewX = target.skewY = 0;
		} else {
			target.skewX = skewX/Matrix2D.DEG_TO_RAD;
			target.skewY = skewY/Matrix2D.DEG_TO_RAD;
		}
		return target;
	};
	
	/**
	 * Copies all properties from the specified matrix to this matrix.
	 * @method copy
	 * @param {Matrix2D} matrix The matrix to copy properties from.
	 * @return {Matrix2D} This matrix. Useful for chaining method calls.
	*/
	p.copy = function(matrix) {
		return this.setValues(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
	};

	/**
	 * Returns a clone of the Matrix2D instance.
	 * @method clone
	 * @return {Matrix2D} a clone of the Matrix2D instance.
	 **/
	p.clone = function() {
		return new Matrix2D(this.a, this.b, this.c, this.d, this.tx, this.ty);
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Matrix2D (a="+this.a+" b="+this.b+" c="+this.c+" d="+this.d+" tx="+this.tx+" ty="+this.ty+")]";
	};

	// this has to be populated after the class is defined:
	Matrix2D.identity = new Matrix2D();


	createjs.Matrix2D = Matrix2D;
}());

//##############################################################################
// DisplayProps.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

	/**
	 * Used for calculating and encapsulating display related properties.
	 * @class DisplayProps
	 * @param {Number} [visible=true] Visible value.
	 * @param {Number} [alpha=0] Alpha value.
	 * @param {Number} [shadow=null] A Shadow instance or null.
	 * @param {Number} [compositeOperation=null] A compositeOperation value or null.
	 * @param {Number} [matrix] A transformation matrix. Defaults to a new identity matrix.
	 * @constructor
	 **/
	function DisplayProps(visible, alpha, shadow, compositeOperation, matrix) {
		this.setValues(visible, alpha, shadow, compositeOperation, matrix);
		
	// public properties:
		// assigned in the setValues method.
		/**
		 * Property representing the alpha that will be applied to a display object.
		 * @property alpha
		 * @type Number
		 **/
	
		/**
		 * Property representing the shadow that will be applied to a display object.
		 * @property shadow
		 * @type Shadow
		 **/
	
		/**
		 * Property representing the compositeOperation that will be applied to a display object.
		 * You can find a list of valid composite operations at:
		 * <a href="https://developer.mozilla.org/en/Canvas_tutorial/Compositing">https://developer.mozilla.org/en/Canvas_tutorial/Compositing</a>
		 * @property compositeOperation
		 * @type String
		 **/
		
		/**
		 * Property representing the value for visible that will be applied to a display object.
		 * @property visible
		 * @type Boolean
		 **/
		
		/**
		 * The transformation matrix that will be applied to a display object.
		 * @property matrix
		 * @type Matrix2D
		 **/
	}
	var p = DisplayProps.prototype;

// initialization:
	/**
	 * Reinitializes the instance with the specified values.
	 * @method setValues
	 * @param {Number} [visible=true] Visible value.
	 * @param {Number} [alpha=1] Alpha value.
	 * @param {Number} [shadow=null] A Shadow instance or null.
	 * @param {Number} [compositeOperation=null] A compositeOperation value or null.
	 * @param {Number} [matrix] A transformation matrix. Defaults to an identity matrix.
	 * @return {DisplayProps} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.setValues = function (visible, alpha, shadow, compositeOperation, matrix) {
		this.visible = visible == null ? true : !!visible;
		this.alpha = alpha == null ? 1 : alpha;
		this.shadow = shadow;
		this.compositeOperation = shadow;
		this.matrix = matrix || (this.matrix&&this.matrix.identity()) || new createjs.Matrix2D();
		return this;
	};

// public methods:
	/**
	 * Appends the specified display properties. This is generally used to apply a child's properties its parent's.
	 * @method append
	 * @param {Boolean} visible desired visible value
	 * @param {Number} alpha desired alpha value
	 * @param {Shadow} shadow desired shadow value
	 * @param {String} compositeOperation desired composite operation value
	 * @param {Matrix2D} [matrix] a Matrix2D instance
	 * @return {DisplayProps} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.append = function(visible, alpha, shadow, compositeOperation, matrix) {
		this.alpha *= alpha;
		this.shadow = shadow || this.shadow;
		this.compositeOperation = compositeOperation || this.compositeOperation;
		this.visible = this.visible && visible;
		matrix&&this.matrix.appendMatrix(matrix);
		return this;
	};
	
	/**
	 * Prepends the specified display properties. This is generally used to apply a parent's properties to a child's.
	 * For example, to get the combined display properties that would be applied to a child, you could use:
	 * 
	 * 	var o = myDisplayObject;
	 * 	var props = new createjs.DisplayProps();
	 * 	do {
	 * 		// prepend each parent's props in turn:
	 * 		props.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation, o.getMatrix());
	 * 	} while (o = o.parent);
	 * 	
	 * @method prepend
	 * @param {Boolean} visible desired visible value
	 * @param {Number} alpha desired alpha value
	 * @param {Shadow} shadow desired shadow value
	 * @param {String} compositeOperation desired composite operation value
	 * @param {Matrix2D} [matrix] a Matrix2D instance
	 * @return {DisplayProps} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.prepend = function(visible, alpha, shadow, compositeOperation, matrix) {
		this.alpha *= alpha;
		this.shadow = this.shadow || shadow;
		this.compositeOperation = this.compositeOperation || compositeOperation;
		this.visible = this.visible && visible;
		matrix&&this.matrix.prependMatrix(matrix);
		return this;
	};
	
	/**
	 * Resets this instance and its matrix to default values.
	 * @method identity
	 * @return {DisplayProps} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.identity = function() {
		this.visible = true;
		this.alpha = 1;
		this.shadow = this.compositeOperation = null;
		this.matrix.identity();
		return this;
	};
	
	/**
	 * Returns a clone of the DisplayProps instance. Clones the associated matrix.
	 * @method clone
	 * @return {DisplayProps} a clone of the DisplayProps instance.
	 **/
	p.clone = function() {
		return new DisplayProps(this.alpha, this.shadow, this.compositeOperation, this.visible, this.matrix.clone());
	};

// private methods:

	createjs.DisplayProps = DisplayProps;
})();

//##############################################################################
// Point.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Represents a point on a 2 dimensional x / y coordinate system.
	 *
	 * <h4>Example</h4>
	 * 
	 *      var point = new createjs.Point(0, 100);
	 * 
	 * @class Point
	 * @param {Number} [x=0] X position.
	 * @param {Number} [y=0] Y position.
	 * @constructor
	 **/
	function Point(x, y) {
	 	this.setValues(x, y);
	 	
	 	
	// public properties:
		// assigned in the setValues method.
		/**
		 * X position.
		 * @property x
		 * @type Number
		 **/
	
		/**
		 * Y position.
		 * @property y
		 * @type Number
		 **/
	}
	var p = Point.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.

	
// public methods:
	/** 
	 * Sets the specified values on this instance.
	 * @method setValues
	 * @param {Number} [x=0] X position.
	 * @param {Number} [y=0] Y position.
	 * @return {Point} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.setValues = function(x, y) {
		this.x = x||0;
		this.y = y||0;
		return this;
	};
	
	/**
	 * Copies all properties from the specified point to this point.
	 * @method copy
	 * @param {Point} point The point to copy properties from.
	 * @return {Point} This point. Useful for chaining method calls.
	 * @chainable
	*/
	p.copy = function(point) {
		this.x = point.x;
		this.y = point.y;
		return this;
	};
	
	/**
	 * Returns a clone of the Point instance.
	 * @method clone
	 * @return {Point} a clone of the Point instance.
	 **/
	p.clone = function() {
		return new Point(this.x, this.y);
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Point (x="+this.x+" y="+this.y+")]";
	};
	
	
	createjs.Point = Point;
}());

//##############################################################################
// Rectangle.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Represents a rectangle as defined by the points (x, y) and (x+width, y+height).
	 *
	 * <h4>Example</h4>
	 *
	 *      var rect = new createjs.Rectangle(0, 0, 100, 100);
	 *
	 * @class Rectangle
	 * @param {Number} [x=0] X position.
	 * @param {Number} [y=0] Y position.
	 * @param {Number} [width=0] The width of the Rectangle.
	 * @param {Number} [height=0] The height of the Rectangle.
	 * @constructor
	 **/
	function Rectangle(x, y, width, height) {
		this.setValues(x, y, width, height);
		
		
	// public properties:
		// assigned in the setValues method.
		/**
		 * X position.
		 * @property x
		 * @type Number
		 **/
	
		/**
		 * Y position.
		 * @property y
		 * @type Number
		 **/
	
		/**
		 * Width.
		 * @property width
		 * @type Number
		 **/
	
		/**
		 * Height.
		 * @property height
		 * @type Number
		 **/
	}
	var p = Rectangle.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// public methods:
	/** 
	 * Sets the specified values on this instance.
	 * @method setValues
	 * @param {Number} [x=0] X position.
	 * @param {Number} [y=0] Y position.
	 * @param {Number} [width=0] The width of the Rectangle.
	 * @param {Number} [height=0] The height of the Rectangle.
	 * @return {Rectangle} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.setValues = function(x, y, width, height) {
		// don't forget to update docs in the constructor if these change:
		this.x = x||0;
		this.y = y||0;
		this.width = width||0;
		this.height = height||0;
		return this;
	};
	
	/** 
	 * Extends the rectangle's bounds to include the described point or rectangle.
	 * @method extend
	 * @param {Number} x X position of the point or rectangle.
	 * @param {Number} y Y position of the point or rectangle.
	 * @param {Number} [width=0] The width of the rectangle.
	 * @param {Number} [height=0] The height of the rectangle.
	 * @return {Rectangle} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.extend = function(x, y, width, height) {
		width = width||0;
		height = height||0;
		if (x+width > this.x+this.width) { this.width = x+width-this.x; }
		if (y+height > this.y+this.height) { this.height = y+height-this.y; }
		if (x < this.x) { this.width += this.x-x; this.x = x; }
		if (y < this.y) { this.height += this.y-y; this.y = y; }
		return this;
	};
	
	/** 
	 * Adds the specified padding to the rectangle's bounds.
	 * @method extend
	 * @param {Number} [top=0]
	 * @param {Number} [left=0]
	 * @param {Number} [right=0]
	 * @param {Number} [bottom=0]
	 * @return {Rectangle} This instance. Useful for chaining method calls.
	 * @chainable
	*/
	p.pad = function(top, left, bottom, right) {
		this.x -= left;
		this.y -= top;
		this.width += left+right;
		this.height += top+bottom;
		return this;
	};
	
	/**
	 * Copies all properties from the specified rectangle to this rectangle.
	 * @method copy
	 * @param {Rectangle} rectangle The rectangle to copy properties from.
	 * @return {Rectangle} This rectangle. Useful for chaining method calls.
	 * @chainable
	*/
	p.copy = function(rectangle) {
		return this.setValues(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
	};
	
	/** 
	 * Returns true if this rectangle fully encloses the described point or rectangle.
	 * @method contains
	 * @param {Number} x X position of the point or rectangle.
	 * @param {Number} y Y position of the point or rectangle.
	 * @param {Number} [width=0] The width of the rectangle.
	 * @param {Number} [height=0] The height of the rectangle.
	 * @return {Boolean} True if the described point or rectangle is contained within this rectangle.
	*/
	p.contains = function(x, y, width, height) {
		width = width||0;
		height = height||0;
		return (x >= this.x && x+width <= this.x+this.width && y >= this.y && y+height <= this.y+this.height);
	};
	
	/** 
	 * Returns a new rectangle which contains this rectangle and the specified rectangle.
	 * @method union
	 * @param {Rectangle} rect The rectangle to calculate a union with.
	 * @return {Rectangle} A new rectangle describing the union.
	*/
	p.union = function(rect) {
		return this.clone().extend(rect.x, rect.y, rect.width, rect.height);
	};
	
	/** 
	 * Returns a new rectangle which describes the intersection (overlap) of this rectangle and the specified rectangle,
	 * or null if they do not intersect.
	 * @method intersection
	 * @param {Rectangle} rect The rectangle to calculate an intersection with.
	 * @return {Rectangle} A new rectangle describing the intersection or null.
	*/
	p.intersection = function(rect) {
		var x1 = rect.x, y1 = rect.y, x2 = x1+rect.width, y2 = y1+rect.height;
		if (this.x > x1) { x1 = this.x; }
		if (this.y > y1) { y1 = this.y; }
		if (this.x + this.width < x2) { x2 = this.x + this.width; }
		if (this.y + this.height < y2) { y2 = this.y + this.height; }
		return (x2 <= x1 || y2 <= y1) ? null : new Rectangle(x1, y1, x2-x1, y2-y1);
	};
	
	/** 
	 * Returns true if the specified rectangle intersects (has any overlap) with this rectangle.
	 * @method intersects
	 * @param {Rectangle} rect The rectangle to compare.
	 * @return {Boolean} True if the rectangles intersect.
	*/
	p.intersects = function(rect) {
		return (rect.x <= this.x+this.width && this.x <= rect.x+rect.width && rect.y <= this.y+this.height && this.y <= rect.y + rect.height);
	};
	
	/** 
	 * Returns true if the width or height are equal or less than 0.
	 * @method isEmpty
	 * @return {Boolean} True if the rectangle is empty.
	*/
	p.isEmpty = function() {
		return this.width <= 0 || this.height <= 0;
	};
	
	/**
	 * Returns a clone of the Rectangle instance.
	 * @method clone
	 * @return {Rectangle} a clone of the Rectangle instance.
	 **/
	p.clone = function() {
		return new Rectangle(this.x, this.y, this.width, this.height);
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Rectangle (x="+this.x+" y="+this.y+" width="+this.width+" height="+this.height+")]";
	};
	
	
	createjs.Rectangle = Rectangle;
}());

//##############################################################################
// ButtonHelper.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * The ButtonHelper is a helper class to create interactive buttons from {{#crossLink "MovieClip"}}{{/crossLink}} or
	 * {{#crossLink "Sprite"}}{{/crossLink}} instances. This class will intercept mouse events from an object, and
	 * automatically call {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} or {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}},
	 * to the respective animation labels, add a pointer cursor, and allows the user to define a hit state frame.
	 *
	 * The ButtonHelper instance does not need to be added to the stage, but a reference should be maintained to prevent
	 * garbage collection.
	 * 
	 * Note that over states will not work unless you call {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}.
	 *
	 * <h4>Example</h4>
	 *
	 *      var helper = new createjs.ButtonHelper(myInstance, "out", "over", "down", false, myInstance, "hit");
	 *      myInstance.addEventListener("click", handleClick);
	 *      function handleClick(event) {
	 *          // Click Happened.
	 *      }
	 *
	 * @class ButtonHelper
	 * @param {Sprite|MovieClip} target The instance to manage.
	 * @param {String} [outLabel="out"] The label or animation to go to when the user rolls out of the button.
	 * @param {String} [overLabel="over"] The label or animation to go to when the user rolls over the button.
	 * @param {String} [downLabel="down"] The label or animation to go to when the user presses the button.
	 * @param {Boolean} [play=false] If the helper should call "gotoAndPlay" or "gotoAndStop" on the button when changing
	 * states.
	 * @param {DisplayObject} [hitArea] An optional item to use as the hit state for the button. If this is not defined,
	 * then the button's visible states will be used instead. Note that the same instance as the "target" argument can be
	 * used for the hitState.
	 * @param {String} [hitLabel] The label or animation on the hitArea instance that defines the hitArea bounds. If this is
	 * null, then the default state of the hitArea will be used. *
	 * @constructor
	 */
	function ButtonHelper(target, outLabel, overLabel, downLabel, play, hitArea, hitLabel) {
		if (!target.addEventListener) { return; }
	
	
	// public properties:
		/**
		 * The target for this button helper.
		 * @property target
		 * @type MovieClip | Sprite
		 * @readonly
		 **/
		this.target = target;
	
		/**
		 * The label name or frame number to display when the user mouses out of the target. Defaults to "over".
		 * @property overLabel
		 * @type String | Number
		 **/
		this.overLabel = overLabel == null ? "over" : overLabel;
	
		/**
		 * The label name or frame number to display when the user mouses over the target. Defaults to "out".
		 * @property outLabel
		 * @type String | Number
		 **/
		this.outLabel = outLabel == null ? "out" : outLabel;
	
		/**
		 * The label name or frame number to display when the user presses on the target. Defaults to "down".
		 * @property downLabel
		 * @type String | Number
		 **/
		this.downLabel = downLabel == null ? "down" : downLabel;
	
		/**
		 * If true, then ButtonHelper will call gotoAndPlay, if false, it will use gotoAndStop. Default is false.
		 * @property play
		 * @default false
		 * @type Boolean
		 **/
		this.play = play;
		
		
	//  private properties
		/**
		 * @property _isPressed
		 * @type Boolean
		 * @protected
		 **/
		this._isPressed = false;
	
		/**
		 * @property _isOver
		 * @type Boolean
		 * @protected
		 **/
		this._isOver = false;
	
		/**
		 * @property _enabled
		 * @type Boolean
		 * @protected
		 **/
		this._enabled = false;
		
	// setup:
		target.mouseChildren = false; // prevents issues when children are removed from the display list when state changes.
		this.enabled = true;
		this.handleEvent({});
		if (hitArea) {
			if (hitLabel) {
				hitArea.actionsEnabled = false;
				hitArea.gotoAndStop&&hitArea.gotoAndStop(hitLabel);
			}
			target.hitArea = hitArea;
		}
	}
	var p = ButtonHelper.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.

	
// getter / setters:
	/**
	 * Use the {{#crossLink "ButtonHelper/enabled:property"}}{{/crossLink}} property instead.
	 * @method setEnabled
	 * @param {Boolean} value
	 * @deprecated
	 **/
	p.setEnabled = function(value) { // TODO: deprecated.
		if (value == this._enabled) { return; }
		var o = this.target;
		this._enabled = value;
		if (value) {
			o.cursor = "pointer";
			o.addEventListener("rollover", this);
			o.addEventListener("rollout", this);
			o.addEventListener("mousedown", this);
			o.addEventListener("pressup", this);
			if (o._reset) { o.__reset = o._reset; o._reset = this._reset;}
		} else {
			o.cursor = null;
			o.removeEventListener("rollover", this);
			o.removeEventListener("rollout", this);
			o.removeEventListener("mousedown", this);
			o.removeEventListener("pressup", this);
			if (o.__reset) { o._reset = o.__reset; delete(o.__reset); }
		}
	};
	/**
	 * Use the {{#crossLink "ButtonHelper/enabled:property"}}{{/crossLink}} property instead.
	 * @method getEnabled
	 * @return {Boolean}
	 * @deprecated
	 **/
	p.getEnabled = function() {
		return this._enabled;
	};

	/**
	 * Enables or disables the button functionality on the target.
	 * @property enabled
	 * @type {Boolean}
	 **/
	try {
		Object.defineProperties(p, {
			enabled: { get: p.getEnabled, set: p.setEnabled }
		});
	} catch (e) {} // TODO: use Log


// public methods:
	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[ButtonHelper]";
	};


// private methods:
	/**
	 * @method handleEvent
	 * @param {Object} evt The mouse event to handle.
	 * @protected
	 **/
	p.handleEvent = function(evt) {
		var label, t = this.target, type = evt.type;
		if (type == "mousedown") {
			this._isPressed = true;
			label = this.downLabel;
		} else if (type == "pressup") {
			this._isPressed = false;
			label = this._isOver ? this.overLabel : this.outLabel;
		} else if (type == "rollover") {
			this._isOver = true;
			label = this._isPressed ? this.downLabel : this.overLabel;
		} else { // rollout and default
			this._isOver = false;
			label = this._isPressed ? this.overLabel : this.outLabel;
		}
		if (this.play) {
			t.gotoAndPlay&&t.gotoAndPlay(label);
		} else {
			t.gotoAndStop&&t.gotoAndStop(label);
		}
	};
	
	/**
	 * Injected into target. Preserves the paused state through a reset.
	 * @method _reset
	 * @protected
	 **/
	p._reset = function() {
		// TODO: explore better ways to handle this issue. This is hacky & disrupts object signatures.
		var p = this.paused;
		this.__reset();
		this.paused = p;
	};


	createjs.ButtonHelper = ButtonHelper;
}());

//##############################################################################
// Shadow.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * This class encapsulates the properties required to define a shadow to apply to a {{#crossLink "DisplayObject"}}{{/crossLink}}
	 * via its <code>shadow</code> property.
	 *
	 * <h4>Example</h4>
	 *
	 *      myImage.shadow = new createjs.Shadow("#000000", 5, 5, 10);
	 *
	 * @class Shadow
	 * @constructor
	 * @param {String} color The color of the shadow. This can be any valid CSS color value.
	 * @param {Number} offsetX The x offset of the shadow in pixels.
	 * @param {Number} offsetY The y offset of the shadow in pixels.
	 * @param {Number} blur The size of the blurring effect.
	 **/
	function Shadow(color, offsetX, offsetY, blur) {
		
		
	// public properties:
		/** 
		 * The color of the shadow. This can be any valid CSS color value.
		 * @property color
		 * @type String
		 * @default null
		 */
		this.color = color||"black";
	
		/** The x offset of the shadow.
		 * @property offsetX
		 * @type Number
		 * @default 0
		 */
		this.offsetX = offsetX||0;
	
		/** The y offset of the shadow.
		 * @property offsetY
		 * @type Number
		 * @default 0
		 */
		this.offsetY = offsetY||0;
	
		/** The blur of the shadow.
		 * @property blur
		 * @type Number
		 * @default 0
		 */
		this.blur = blur||0;
	}
	var p = Shadow.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// static public properties:
	/**
	 * An identity shadow object (all properties are set to 0).
	 * @property identity
	 * @type Shadow
	 * @static
	 * @final
	 * @readonly
	 **/
	Shadow.identity = new Shadow("transparent", 0, 0, 0);


// public methods:
	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Shadow]";
	};

	/**
	 * Returns a clone of this Shadow instance.
	 * @method clone
	 * @return {Shadow} A clone of the current Shadow instance.
	 **/
	p.clone = function() {
		return new Shadow(this.color, this.offsetX, this.offsetY, this.blur);
	};
	

	createjs.Shadow = Shadow;
}());

//##############################################################################
// SpriteSheet.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Encapsulates the properties and methods associated with a sprite sheet. A sprite sheet is a series of images (usually
	 * animation frames) combined into a larger image (or images). For example, an animation consisting of eight 100x100
	 * images could be combined into a single 400x200 sprite sheet (4 frames across by 2 high).
	 *
	 * The data passed to the SpriteSheet constructor defines:<ol>
	 * 	<li> The source image or images to use.</li>
	 * 	<li> The positions of individual image frames.</li>
	 * 	<li> Sequences of frames that form named animations. Optional.</li>
	 * 	<li> The target playback framerate. Optional.</li>
	 * </OL>
	 *
	 * <h3>SpriteSheet Format</h3>
	 *
	 * SpriteSheets are an object with two required properties (`images` and `frames`), and two optional properties
	 * (`framerate` and `animations`). This makes them easy to define in javascript code, or in JSON.
	 *
	 * <h4>images</h4>
	 * An array of source images. Images can be either an HTMLImage
	 * instance, or a uri to an image. The former is recommended to control preloading.
	 *
	 * 	images: [image1, "path/to/image2.png"],
	 *
	 * <h4>frames</h4>
	 * Defines the individual frames. There are two supported formats for frame data:<OL>
	 * <LI> when all of the frames are the same size (in a grid), use an object with `width`, `height`, `regX`, `regY`, and `count` properties.
	 * `width` & `height` are required and specify the dimensions of the frames.
	 * `regX` & `regY` indicate the registration point or "origin" of the frames.
	 * `spacing` indicate the spacing between frames.
	 * `margin` specify the margin around the image(s).
	 * `count` allows you to specify the total number of frames in the spritesheet; if omitted, this will be calculated
	 * based on the dimensions of the source images and the frames. Frames will be assigned indexes based on their position
	 * in the source images (left to right, top to bottom).
	 *
	 * 	frames: {width:64, height:64, count:20, regX: 32, regY:64, spacing:0, margin:0}
	 *
	 * <LI> if the frames are of different sizes, use an array of frame definitions. Each definition is itself an array
	 * with 4 required and 3 optional entries, in the order: `x`, `y`, `width`, `height`, `imageIndex`, `regX`, `regY`. The first
	 * four entries are required and define the frame rectangle. The fifth specifies the index of the source image (defaults to 0). The
	 * last two specify the registration point of the frame.
	 *
	 * 	frames: [
	 * 		// x, y, width, height, imageIndex*, regX*, regY*
	 * 		[64, 0, 96, 64],
	 * 		[0, 0, 64, 64, 1, 32, 32]
	 * 		// etc.
	 * 	]
	 *
	 * </OL>
	 *
	 * <h4>animations</h4>
	 * Optional. An object defining sequences of frames to play as named animations. Each property corresponds to an
	 * animation of the same name. Each animation must specify the frames to play, and may
	 * also include a relative playback `speed` (ex. 2 would playback at double speed, 0.5 at half), and
	 * the name of the `next` animation to sequence to after it completes.
	 *
	 * There are three formats supported for defining the frames in an animation, which can be mixed and matched as appropriate:<OL>
	 * <LI> for a single frame animation, you can simply specify the frame index
	 *
	 * 	animations: {
	 * 		sit: 7
	 * 	}
	 *
	 * <LI> for an animation of consecutive frames, you can use an array with two required, and two optional entries
	 * in the order: `start`, `end`, `next`, and `speed`. This will play the frames from start to end inclusive.
	 *
	 * 	animations: {
	 * 		// start, end, next*, speed*
	 * 		run: [0, 8],
	 * 		jump: [9, 12, "run", 2]
	 * 	}
	 *
	 * <LI> for non-consecutive frames, you can use an object with a `frames` property defining an array of frame indexes to
	 * play in order. The object can also specify `next` and `speed` properties.
	 *
	 * 	animations: {
	 * 		walk: {
	 * 			frames: [1,2,3,3,2,1]
	 * 		},
	 * 		shoot: {
	 * 			frames: [1,4,5,6],
	 * 			next: "walk",
	 * 			speed: 0.5
	 * 		}
	 * 	}
	 *
	 * </OL>
	 * <strong>Note:</strong> the `speed` property was added in EaselJS 0.7.0. Earlier versions had a `frequency`
	 * property instead, which was the inverse of `speed`. For example, a value of "4" would be 1/4 normal speed in earlier
	 * versions, but is 4x normal speed in 0.7.0+.
	 *
	 * <h4>framerate</h4>
	 * Optional. Indicates the default framerate to play this spritesheet at in frames per second.
	 * See {{#crossLink "SpriteSheet/framerate:property"}}{{/crossLink}} for more information.
	 *
	 * 	framerate: 20
	 *
	 * <h4>Example</h4>
	 * To define a simple sprite sheet, with a single image "sprites.jpg" arranged in a regular 50x50 grid with three
	 * animations: "stand" showing the first frame, "run" looping frame 1-5 inclusive, and "jump" playing  frame 6-8 and sequencing back to run.
	 *
	 * 	var data = {
	 * 		images: ["sprites.jpg"],
	 * 		frames: {width:50, height:50},
	 * 		animations: {
	 * 			stand:0,
	 * 			run:[1,5],
	 * 			jump:[6,8,"run"]
	 * 		}
	 * 	};
	 * 	var spriteSheet = new createjs.SpriteSheet(data);
	 * 	var animation = new createjs.Sprite(spriteSheet, "run");
	 *
	 *
	 * <strong>Warning:</strong> Images loaded cross-origin will throw cross-origin security errors when interacted with
	 * using a mouse, using methods such as `getObjectUnderPoint`, using filters, or caching. You can get around this by
	 * setting `crossOrigin` flags on your images before passing them to EaselJS, eg: `img.crossOrigin="Anonymous";`
	 *
	 * @class SpriteSheet
	 * @constructor
	 * @param {Object} data An object describing the SpriteSheet data.
	 * @extends EventDispatcher
	 **/
	function SpriteSheet(data) {
		this.EventDispatcher_constructor();


		// public properties:
		/**
		 * Indicates whether all images are finished loading.
		 * @property complete
		 * @type Boolean
		 * @readonly
		 **/
		this.complete = true;

		/**
		 * Specifies the framerate to use by default for Sprite instances using the SpriteSheet. See
		 * Sprite.framerate for more information.
		 * @property framerate
		 * @type Number
		 **/
		this.framerate = 0;


		// private properties:
		/**
		 * @property _animations
		 * @protected
		 * @type Array
		 **/
		this._animations = null;

		/**
		 * @property _frames
		 * @protected
		 * @type Array
		 **/
		this._frames = null;

		/**
		 * @property _images
		 * @protected
		 * @type Array
		 **/
		this._images = null;

		/**
		 * @property _data
		 * @protected
		 * @type Object
		 **/
		this._data = null;

		/**
		 * @property _loadCount
		 * @protected
		 * @type Number
		 **/
		this._loadCount = 0;

		// only used for simple frame defs:
		/**
		 * @property _frameHeight
		 * @protected
		 * @type Number
		 **/
		this._frameHeight = 0;

		/**
		 * @property _frameWidth
		 * @protected
		 * @type Number
		 **/
		this._frameWidth = 0;

		/**
		 * @property _numFrames
		 * @protected
		 * @type Number
		 **/
		this._numFrames = 0;

		/**
		 * @property _regX
		 * @protected
		 * @type Number
		 **/
		this._regX = 0;

		/**
		 * @property _regY
		 * @protected
		 * @type Number
		 **/
		this._regY = 0;

		/**
		 * @property _spacing
		 * @protected
		 * @type Number
		 **/
		this._spacing = 0;

		/**
		 * @property _margin
		 * @protected
		 * @type Number
		 **/
		this._margin = 0;

		// setup:
		this._parseData(data);
	}
	var p = createjs.extend(SpriteSheet, createjs.EventDispatcher);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// events:
	/**
	 * Dispatched when all images are loaded.  Note that this only fires if the images
	 * were not fully loaded when the sprite sheet was initialized. You should check the complete property
	 * to prior to adding a listener. Ex.
	 *
	 * 	var sheet = new SpriteSheet(data);
	 * 	if (!sheet.complete) {
	 * 		// not preloaded, listen for the complete event:
	 * 		sheet.addEventListener("complete", handler);
	 * 	}
	 *
	 * @event complete
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @since 0.6.0
	 */

	/**
	 * Dispatched when getFrame is called with a valid frame index. This is primarily intended for use by {{#crossLink "SpriteSheetBuilder"}}{{/crossLink}}
	 * when doing on-demand rendering.
	 * @event getframe
	 * @param {Number} index The frame index.
	 * @param {Object} frame The frame object that getFrame will return.
	 */


// getter / setters:
	/**
	 * Use the {{#crossLink "SpriteSheet/animations:property"}}{{/crossLink}} property instead.
	 * @method getAnimations
	 * @return {Array}
	 * @deprecated
	 **/
	p.getAnimations = function() {
		return this._animations.slice();
	};

	/**
	 * Returns an array of all available animation names available on this sprite sheet as strings.
	 * @property animations
	 * @type {Array}
	 * @readonly
	 **/
	try {
		Object.defineProperties(p, {
			animations: { get: p.getAnimations }
		});
	} catch (e) {}


// public methods:
	/**
	 * Returns the total number of frames in the specified animation, or in the whole sprite
	 * sheet if the animation param is omitted. Returns 0 if the spritesheet relies on calculated frame counts, and
	 * the images have not been fully loaded.
	 * @method getNumFrames
	 * @param {String} animation The name of the animation to get a frame count for.
	 * @return {Number} The number of frames in the animation, or in the entire sprite sheet if the animation param is omitted.
	 */
	p.getNumFrames = function(animation) {
		if (animation == null) {
			return this._frames ? this._frames.length : this._numFrames || 0;
		} else {
			var data = this._data[animation];
			if (data == null) { return 0; }
			else { return data.frames.length; }
		}
	};

	/**
	 * Returns an object defining the specified animation. The returned object contains:<UL>
	 * 	<LI>frames: an array of the frame ids in the animation</LI>
	 * 	<LI>speed: the playback speed for this animation</LI>
	 * 	<LI>name: the name of the animation</LI>
	 * 	<LI>next: the default animation to play next. If the animation loops, the name and next property will be the
	 * 	same.</LI>
	 * </UL>
	 * @method getAnimation
	 * @param {String} name The name of the animation to get.
	 * @return {Object} a generic object with frames, speed, name, and next properties.
	 **/
	p.getAnimation = function(name) {
		return this._data[name];
	};

	/**
	 * Returns an object specifying the image and source rect of the specified frame. The returned object has:<UL>
	 * 	<LI>an image property holding a reference to the image object in which the frame is found</LI>
	 * 	<LI>a rect property containing a Rectangle instance which defines the boundaries for the frame within that
	 * 	image.</LI>
	 * 	<LI> A regX and regY property corresponding to the regX/Y values for the frame.
	 * </UL>
	 * @method getFrame
	 * @param {Number} frameIndex The index of the frame.
	 * @return {Object} a generic object with image and rect properties. Returns null if the frame does not exist.
	 **/
	p.getFrame = function(frameIndex) {
		var frame;
		if (this._frames && (frame=this._frames[frameIndex])) { return frame; }
		return null;
	};

	/**
	 * Returns a {{#crossLink "Rectangle"}}{{/crossLink}} instance defining the bounds of the specified frame relative
	 * to the origin. For example, a 90 x 70 frame with a regX of 50 and a regY of 40 would return:
	 *
	 * 	[x=-50, y=-40, width=90, height=70]
	 *
	 * @method getFrameBounds
	 * @param {Number} frameIndex The index of the frame.
	 * @param {Rectangle} [rectangle] A Rectangle instance to copy the values into. By default a new instance is created.
	 * @return {Rectangle} A Rectangle instance. Returns null if the frame does not exist, or the image is not fully loaded.
	 **/
	p.getFrameBounds = function(frameIndex, rectangle) {
		var frame = this.getFrame(frameIndex);
		return frame ? (rectangle||new createjs.Rectangle()).setValues(-frame.regX, -frame.regY, frame.rect.width, frame.rect.height) : null;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[SpriteSheet]";
	};

	/**
	 * SpriteSheet cannot be cloned. A SpriteSheet can be shared by multiple Sprite instances without cloning it.
	 * @method clone
	 **/
	p.clone = function() {
		throw("SpriteSheet cannot be cloned.")
	};

// private methods:
	/**
	 * @method _parseData
	 * @param {Object} data An object describing the SpriteSheet data.
	 * @protected
	 **/
	p._parseData = function(data) {
		var i,l,o,a;
		if (data == null) { return; }

		this.framerate = data.framerate||0;

		// parse images:
		if (data.images && (l=data.images.length) > 0) {
			a = this._images = [];
			for (i=0; i<l; i++) {
				var img = data.images[i];
				if (typeof img == "string") {
					var src = img;
					img = document.createElement("img");
					img.src = src;
				}
				a.push(img);
				if (!img.getContext && !img.naturalWidth) {
					this._loadCount++;
					this.complete = false;
					(function(o) { img.onload = function() { o._handleImageLoad(); } })(this);
				}
			}
		}

		// parse frames:
		if (data.frames == null) { // nothing
		} else if (data.frames instanceof Array) {
			this._frames = [];
			a = data.frames;
			for (i=0,l=a.length;i<l;i++) {
				var arr = a[i];
				this._frames.push({image:this._images[arr[4]?arr[4]:0], rect:new createjs.Rectangle(arr[0],arr[1],arr[2],arr[3]), regX:arr[5]||0, regY:arr[6]||0 });
			}
		} else {
			o = data.frames;
			this._frameWidth = o.width;
			this._frameHeight = o.height;
			this._regX = o.regX||0;
			this._regY = o.regY||0;
			this._spacing = o.spacing||0;
			this._margin = o.margin||0;
			this._numFrames = o.count;
			if (this._loadCount == 0) { this._calculateFrames(); }
		}

		// parse animations:
		this._animations = [];
		if ((o=data.animations) != null) {
			this._data = {};
			var name;
			for (name in o) {
				var anim = {name:name};
				var obj = o[name];
				if (typeof obj == "number") { // single frame
					a = anim.frames = [obj];
				} else if (obj instanceof Array) { // simple
					if (obj.length == 1) { anim.frames = [obj[0]]; }
					else {
						anim.speed = obj[3];
						anim.next = obj[2];
						a = anim.frames = [];
						for (i=obj[0];i<=obj[1];i++) {
							a.push(i);
						}
					}
				} else { // complex
					anim.speed = obj.speed;
					anim.next = obj.next;
					var frames = obj.frames;
					a = anim.frames = (typeof frames == "number") ? [frames] : frames.slice(0);
				}
				if (anim.next === true || anim.next === undefined) { anim.next = name; } // loop
				if (anim.next === false || (a.length < 2 && anim.next == name)) { anim.next = null; } // stop
				if (!anim.speed) { anim.speed = 1; }
				this._animations.push(name);
				this._data[name] = anim;
			}
		}
	};

	/**
	 * @method _handleImageLoad
	 * @protected
	 **/
	p._handleImageLoad = function() {
		if (--this._loadCount == 0) {
			this._calculateFrames();
			this.complete = true;
			this.dispatchEvent("complete");
		}
	};

	/**
	 * @method _calculateFrames
	 * @protected
	 **/
	p._calculateFrames = function() {
		if (this._frames || this._frameWidth == 0) { return; }

		this._frames = [];

		var maxFrames = this._numFrames || 100000; // if we go over this, something is wrong.
		var frameCount = 0, frameWidth = this._frameWidth, frameHeight = this._frameHeight;
		var spacing = this._spacing, margin = this._margin;
		
		imgLoop:
		for (var i=0, imgs=this._images; i<imgs.length; i++) {
			var img = imgs[i], imgW = img.width, imgH = img.height;

			var y = margin;
			while (y <= imgH-margin-frameHeight) {
				var x = margin;
				while (x <= imgW-margin-frameWidth) {
					if (frameCount >= maxFrames) { break imgLoop; }
					frameCount++;
					this._frames.push({
							image: img,
							rect: new createjs.Rectangle(x, y, frameWidth, frameHeight),
							regX: this._regX,
							regY: this._regY
						});
					x += frameWidth+spacing;
				}
				y += frameHeight+spacing;
			}
		}
		this._numFrames = frameCount;
	};


	createjs.SpriteSheet = createjs.promote(SpriteSheet, "EventDispatcher");
}());

//##############################################################################
// Graphics.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * The Graphics class exposes an easy to use API for generating vector drawing instructions and drawing them to a
	 * specified context. Note that you can use Graphics without any dependency on the EaselJS framework by calling {{#crossLink "Graphics/draw"}}{{/crossLink}}
	 * directly, or it can be used with the {{#crossLink "Shape"}}{{/crossLink}} object to draw vector graphics within the
	 * context of an EaselJS display list.
	 *
	 * There are two approaches to working with Graphics object: calling methods on a Graphics instance (the "Graphics API"), or
	 * instantiating Graphics command objects and adding them to the graphics queue via {{#crossLink "Graphics/append"}}{{/crossLink}}.
	 * The former abstracts the latter, simplifying beginning and ending paths, fills, and strokes.
	 *
	 *      var g = new createjs.Graphics();
	 *      g.setStrokeStyle(1);
	 *      g.beginStroke("#000000");
	 *      g.beginFill("red");
	 *      g.drawCircle(0,0,30);
	 *
	 * All drawing methods in Graphics return the Graphics instance, so they can be chained together. For example,
	 * the following line of code would generate the instructions to draw a rectangle with a red stroke and blue fill:
	 *
	 *      myGraphics.beginStroke("red").beginFill("blue").drawRect(20, 20, 100, 50);
	 *
	 * Each graphics API call generates a command object (see below). The last command to be created can be accessed via
	 * {{#crossLink "Graphics/command:property"}}{{/crossLink}}:
	 *
	 *      var fillCommand = myGraphics.beginFill("red").command;
	 *      // ... later, update the fill style/color:
	 *      fillCommand.style = "blue";
	 *      // or change it to a bitmap fill:
	 *      fillCommand.bitmap(myImage);
	 *
	 * For more direct control of rendering, you can instantiate and append command objects to the graphics queue directly. In this case, you
	 * need to manage path creation manually, and ensure that fill/stroke is applied to a defined path:
	 *
	 *      // start a new path. Graphics.beginCmd is a reusable BeginPath instance:
	 *      myGraphics.append(createjs.Graphics.beginCmd);
	 *      // we need to define the path before applying the fill:
	 *      var circle = new createjs.Graphics.Circle(0,0,30);
	 *      myGraphics.append(circle);
	 *      // fill the path we just defined:
	 *      var fill = new createjs.Graphics.Fill("red");
	 *      myGraphics.append(fill);
	 *
	 * These approaches can be used together, for example to insert a custom command:
	 *
	 *      myGraphics.beginFill("red");
	 *      var customCommand = new CustomSpiralCommand(etc);
	 *      myGraphics.append(customCommand);
	 *      myGraphics.beginFill("blue");
	 *      myGraphics.drawCircle(0, 0, 30);
	 *
	 * See {{#crossLink "Graphics/append"}}{{/crossLink}} for more info on creating custom commands.
	 *
	 * <h4>Tiny API</h4>
	 * The Graphics class also includes a "tiny API", which is one or two-letter methods that are shortcuts for all of the
	 * Graphics methods. These methods are great for creating compact instructions, and is used by the Toolkit for CreateJS
	 * to generate readable code. All tiny methods are marked as protected, so you can view them by enabling protected
	 * descriptions in the docs.
	 *
	 * <table>
	 *     <tr><td><b>Tiny</b></td><td><b>Method</b></td><td><b>Tiny</b></td><td><b>Method</b></td></tr>
	 *     <tr><td>mt</td><td>{{#crossLink "Graphics/moveTo"}}{{/crossLink}} </td>
	 *     <td>lt</td> <td>{{#crossLink "Graphics/lineTo"}}{{/crossLink}}</td></tr>
	 *     <tr><td>a/at</td><td>{{#crossLink "Graphics/arc"}}{{/crossLink}} / {{#crossLink "Graphics/arcTo"}}{{/crossLink}} </td>
	 *     <td>bt</td><td>{{#crossLink "Graphics/bezierCurveTo"}}{{/crossLink}} </td></tr>
	 *     <tr><td>qt</td><td>{{#crossLink "Graphics/quadraticCurveTo"}}{{/crossLink}} (also curveTo)</td>
	 *     <td>r</td><td>{{#crossLink "Graphics/rect"}}{{/crossLink}} </td></tr>
	 *     <tr><td>cp</td><td>{{#crossLink "Graphics/closePath"}}{{/crossLink}} </td>
	 *     <td>c</td><td>{{#crossLink "Graphics/clear"}}{{/crossLink}} </td></tr>
	 *     <tr><td>f</td><td>{{#crossLink "Graphics/beginFill"}}{{/crossLink}} </td>
	 *     <td>lf</td><td>{{#crossLink "Graphics/beginLinearGradientFill"}}{{/crossLink}} </td></tr>
	 *     <tr><td>rf</td><td>{{#crossLink "Graphics/beginRadialGradientFill"}}{{/crossLink}} </td>
	 *     <td>bf</td><td>{{#crossLink "Graphics/beginBitmapFill"}}{{/crossLink}} </td></tr>
	 *     <tr><td>ef</td><td>{{#crossLink "Graphics/endFill"}}{{/crossLink}} </td>
	 *     <td>ss / sd</td><td>{{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} / {{#crossLink "Graphics/setStrokeDash"}}{{/crossLink}} </td></tr>
	 *     <tr><td>s</td><td>{{#crossLink "Graphics/beginStroke"}}{{/crossLink}} </td>
	 *     <td>ls</td><td>{{#crossLink "Graphics/beginLinearGradientStroke"}}{{/crossLink}} </td></tr>
	 *     <tr><td>rs</td><td>{{#crossLink "Graphics/beginRadialGradientStroke"}}{{/crossLink}} </td>
	 *     <td>bs</td><td>{{#crossLink "Graphics/beginBitmapStroke"}}{{/crossLink}} </td></tr>
	 *     <tr><td>es</td><td>{{#crossLink "Graphics/endStroke"}}{{/crossLink}} </td>
	 *     <td>dr</td><td>{{#crossLink "Graphics/drawRect"}}{{/crossLink}} </td></tr>
	 *     <tr><td>rr</td><td>{{#crossLink "Graphics/drawRoundRect"}}{{/crossLink}} </td>
	 *     <td>rc</td><td>{{#crossLink "Graphics/drawRoundRectComplex"}}{{/crossLink}} </td></tr>
	 *     <tr><td>dc</td><td>{{#crossLink "Graphics/drawCircle"}}{{/crossLink}} </td>
	 *     <td>de</td><td>{{#crossLink "Graphics/drawEllipse"}}{{/crossLink}} </td></tr>
	 *     <tr><td>dp</td><td>{{#crossLink "Graphics/drawPolyStar"}}{{/crossLink}} </td>
	 *     <td>p</td><td>{{#crossLink "Graphics/decodePath"}}{{/crossLink}} </td></tr>
	 * </table>
	 *
	 * Here is the above example, using the tiny API instead.
	 *
	 *      myGraphics.s("red").f("blue").r(20, 20, 100, 50);
	 *
	 * @class Graphics
	 * @constructor
	 **/
	function Graphics() {


	// public properties
		/**
		 * Holds a reference to the last command that was created or appended. For example, you could retain a reference
		 * to a Fill command in order to dynamically update the color later by using:
		 * 		myFill = myGraphics.beginFill("red").command;
		 * 		// update color later:
		 * 		myFill.style = "yellow";
		 * @property command
		 * @type Object
		 **/
		this.command = null;


	// private properties
		/**
		 * @property _stroke
		 * @protected
		 * @type {Stroke}
		 **/
		this._stroke = null;

		/**
		 * @property _strokeStyle
		 * @protected
		 * @type {StrokeStyle}
		 **/
		this._strokeStyle = null;
		
		/**
		 * @property _oldStrokeStyle
		 * @protected
		 * @type {StrokeStyle}
		 **/
		this._oldStrokeStyle = null;
		
		/**
		 * @property _strokeDash
		 * @protected
		 * @type {StrokeDash}
		 **/
		this._strokeDash = null;
		
		/**
		 * @property _oldStrokeDash
		 * @protected
		 * @type {StrokeDash}
		 **/
		this._oldStrokeDash = null;

		/**
		 * @property _strokeIgnoreScale
		 * @protected
		 * @type Boolean
		 **/
		this._strokeIgnoreScale = false;

		/**
		 * @property _fill
		 * @protected
		 * @type {Fill}
		 **/
		this._fill = null;

		/**
		 * @property _instructions
		 * @protected
		 * @type {Array}
		 **/
		this._instructions = [];

		/**
		 * Indicates the last instruction index that was committed.
		 * @property _commitIndex
		 * @protected
		 * @type {Number}
		 **/
		this._commitIndex = 0;

		/**
		 * Uncommitted instructions.
		 * @property _activeInstructions
		 * @protected
		 * @type {Array}
		 **/
		this._activeInstructions = [];

		/**
		 * This indicates that there have been changes to the activeInstruction list since the last updateInstructions call.
		 * @property _dirty
		 * @protected
		 * @type {Boolean}
		 * @default false
		 **/
		this._dirty = false;

		/**
		 * Index to draw from if a store operation has happened.
		 * @property _storeIndex
		 * @protected
		 * @type {Number}
		 * @default 0
		 **/
		this._storeIndex = 0;

	// setup:
		this.clear();
	}
	var p = Graphics.prototype;
	var G = Graphics; // shortcut

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// static public methods:
	/**
	 * Returns a CSS compatible color string based on the specified RGB numeric color values in the format
	 * "rgba(255,255,255,1.0)", or if alpha is null then in the format "rgb(255,255,255)". For example,
	 *
	 *      createjs.Graphics.getRGB(50, 100, 150, 0.5);
	 *      // Returns "rgba(50,100,150,0.5)"
	 *
	 * It also supports passing a single hex color value as the first param, and an optional alpha value as the second
	 * param. For example,
	 *
	 *      createjs.Graphics.getRGB(0xFF00FF, 0.2);
	 *      // Returns "rgba(255,0,255,0.2)"
	 *
	 * @method getRGB
	 * @static
	 * @param {Number} r The red component for the color, between 0 and 0xFF (255).
	 * @param {Number} g The green component for the color, between 0 and 0xFF (255).
	 * @param {Number} b The blue component for the color, between 0 and 0xFF (255).
	 * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.
	 * @return {String} A CSS compatible color string based on the specified RGB numeric color values in the format
	 * "rgba(255,255,255,1.0)", or if alpha is null then in the format "rgb(255,255,255)".
	 **/
	Graphics.getRGB = function(r, g, b, alpha) {
		if (r != null && b == null) {
			alpha = g;
			b = r&0xFF;
			g = r>>8&0xFF;
			r = r>>16&0xFF;
		}
		if (alpha == null) {
			return "rgb("+r+","+g+","+b+")";
		} else {
			return "rgba("+r+","+g+","+b+","+alpha+")";
		}
	};

	/**
	 * Returns a CSS compatible color string based on the specified HSL numeric color values in the format "hsla(360,100,100,1.0)",
	 * or if alpha is null then in the format "hsl(360,100,100)".
	 *
	 *      createjs.Graphics.getHSL(150, 100, 70);
	 *      // Returns "hsl(150,100,70)"
	 *
	 * @method getHSL
	 * @static
	 * @param {Number} hue The hue component for the color, between 0 and 360.
	 * @param {Number} saturation The saturation component for the color, between 0 and 100.
	 * @param {Number} lightness The lightness component for the color, between 0 and 100.
	 * @param {Number} [alpha] The alpha component for the color where 0 is fully transparent and 1 is fully opaque.
	 * @return {String} A CSS compatible color string based on the specified HSL numeric color values in the format
	 * "hsla(360,100,100,1.0)", or if alpha is null then in the format "hsl(360,100,100)".
	 **/
	Graphics.getHSL = function(hue, saturation, lightness, alpha) {
		if (alpha == null) {
			return "hsl("+(hue%360)+","+saturation+"%,"+lightness+"%)";
		} else {
			return "hsla("+(hue%360)+","+saturation+"%,"+lightness+"%,"+alpha+")";
		}
	};


// static properties:
	/**
	 * A reusable instance of {{#crossLink "Graphics/BeginPath"}}{{/crossLink}} to avoid
	 * unnecessary instantiation.
	 * @property beginCmd
	 * @type {Graphics.BeginPath}
	 * @static
	 **/
	 // defined at the bottom of this file.

	/**
	 * Map of Base64 characters to values. Used by {{#crossLink "Graphics/decodePath"}}{{/crossLink}}.
	 * @property BASE_64
	 * @static
	 * @final
	 * @readonly
	 * @type {Object}
	 **/
	Graphics.BASE_64 = {"A":0,"B":1,"C":2,"D":3,"E":4,"F":5,"G":6,"H":7,"I":8,"J":9,"K":10,"L":11,"M":12,"N":13,"O":14,"P":15,"Q":16,"R":17,"S":18,"T":19,"U":20,"V":21,"W":22,"X":23,"Y":24,"Z":25,"a":26,"b":27,"c":28,"d":29,"e":30,"f":31,"g":32,"h":33,"i":34,"j":35,"k":36,"l":37,"m":38,"n":39,"o":40,"p":41,"q":42,"r":43,"s":44,"t":45,"u":46,"v":47,"w":48,"x":49,"y":50,"z":51,"0":52,"1":53,"2":54,"3":55,"4":56,"5":57,"6":58,"7":59,"8":60,"9":61,"+":62,"/":63};

	/**
	 * Maps numeric values for the caps parameter of {{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} to
	 * corresponding string values. This is primarily for use with the tiny API. The mappings are as follows: 0 to
	 * "butt", 1 to "round", and 2 to "square".
	 * For example, to set the line caps to "square":
	 *
	 *      myGraphics.ss(16, 2);
	 *
	 * @property STROKE_CAPS_MAP
	 * @static
	 * @final
	 * @readonly
	 * @type {Array}
	 **/
	Graphics.STROKE_CAPS_MAP = ["butt", "round", "square"];

	/**
	 * Maps numeric values for the joints parameter of {{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} to
	 * corresponding string values. This is primarily for use with the tiny API. The mappings are as follows: 0 to
	 * "miter", 1 to "round", and 2 to "bevel".
	 * For example, to set the line joints to "bevel":
	 *
	 *      myGraphics.ss(16, 0, 2);
	 *
	 * @property STROKE_JOINTS_MAP
	 * @static
	 * @final
	 * @readonly
	 * @type {Array}
	 **/
	Graphics.STROKE_JOINTS_MAP = ["miter", "round", "bevel"];

	/**
	 * @property _ctx
	 * @static
	 * @protected
	 * @type {CanvasRenderingContext2D}
	 **/
	var canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"));
	if (canvas.getContext) {
		Graphics._ctx = canvas.getContext("2d");
		canvas.width = canvas.height = 1;
	}


// getter / setters:
	/**
	 * Use the {{#crossLink "Graphics/instructions:property"}}{{/crossLink}} property instead.
	 * @method getInstructions
	 * @return {Array}
	 * @deprecated
	 **/
	p.getInstructions = function() {
		this._updateInstructions();
		return this._instructions;
	};

	/**
	 * Returns the graphics instructions array. Each entry is a graphics command object (ex. Graphics.Fill, Graphics.Rect)
	 * Modifying the returned array directly is not recommended, and is likely to result in unexpected behaviour.
	 *
	 * This property is mainly intended for introspection of the instructions (ex. for graphics export).
	 * @property instructions
	 * @type {Array}
	 * @readonly
	 **/
	try {
		Object.defineProperties(p, {
			instructions: { get: p.getInstructions }
		});
	} catch (e) {}


// public methods:
	/**
	 * Returns true if this Graphics instance has no drawing commands.
	 * @method isEmpty
	 * @return {Boolean} Returns true if this Graphics instance has no drawing commands.
	 **/
	p.isEmpty = function() {
		return !(this._instructions.length || this._activeInstructions.length);
	};

	/**
	 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
	 * Returns true if the draw was handled (useful for overriding functionality).
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Object} data Optional data that is passed to graphics command exec methods. When called from a Shape instance, the shape passes itself as the data parameter. This can be used by custom graphic commands to insert contextual data.
	 **/
	p.draw = function(ctx, data) {
		this._updateInstructions();
		var instr = this._instructions;
		for (var i=this._storeIndex, l=instr.length; i<l; i++) {
			instr[i].exec(ctx, data);
		}
	};

	/**
	 * Draws only the path described for this Graphics instance, skipping any non-path instructions, including fill and
	 * stroke descriptions. Used for <code>DisplayObject.mask</code> to draw the clipping path, for example.
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method drawAsPath
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 **/
	p.drawAsPath = function(ctx) {
		this._updateInstructions();
		var instr, instrs = this._instructions;
		for (var i=this._storeIndex, l=instrs.length; i<l; i++) {
			// the first command is always a beginPath command.
			if ((instr = instrs[i]).path !== false) { instr.exec(ctx); }
		}
	};


// public methods that map directly to context 2D calls:
	/**
	 * Moves the drawing point to the specified position. A tiny API method "mt" also exists.
	 * @method moveTo
	 * @param {Number} x The x coordinate the drawing point should move to.
	 * @param {Number} y The y coordinate the drawing point should move to.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls).
	 * @chainable
	 **/
	p.moveTo = function(x, y) {
		return this.append(new G.MoveTo(x,y), true);
	};

	/**
	 * Draws a line from the current drawing point to the specified position, which become the new current drawing
	 * point. A tiny API method "lt" also exists.
	 *
	 * For detailed information, read the
	 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#complex-shapes-(paths)">
	 * whatwg spec</a>.
	 * @method lineTo
	 * @param {Number} x The x coordinate the drawing point should draw to.
	 * @param {Number} y The y coordinate the drawing point should draw to.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.lineTo = function(x, y) {
		return this.append(new G.LineTo(x,y));
	};

	/**
	 * Draws an arc with the specified control points and radius.  For detailed information, read the
	 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arcto">
	 * whatwg spec</a>. A tiny API method "at" also exists.
	 * @method arcTo
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} radius
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.arcTo = function(x1, y1, x2, y2, radius) {
		return this.append(new G.ArcTo(x1, y1, x2, y2, radius));
	};

	/**
	 * Draws an arc defined by the radius, startAngle and endAngle arguments, centered at the position (x, y). For
	 * example, to draw a full circle with a radius of 20 centered at (100, 100):
	 *
	 *      arc(100, 100, 20, 0, Math.PI*2);
	 *
	 * For detailed information, read the
	 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc">whatwg spec</a>.
	 * A tiny API method "a" also exists.
	 * @method arc
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} radius
	 * @param {Number} startAngle Measured in radians.
	 * @param {Number} endAngle Measured in radians.
	 * @param {Boolean} anticlockwise
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {
		return this.append(new G.Arc(x, y, radius, startAngle, endAngle, anticlockwise));
	};

	/**
	 * Draws a quadratic curve from the current drawing point to (x, y) using the control point (cpx, cpy). For detailed
	 * information, read the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto">
	 * whatwg spec</a>. A tiny API method "qt" also exists.
	 * @method quadraticCurveTo
	 * @param {Number} cpx
	 * @param {Number} cpy
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.quadraticCurveTo = function(cpx, cpy, x, y) {
		return this.append(new G.QuadraticCurveTo(cpx, cpy, x, y));
	};

	/**
	 * Draws a bezier curve from the current drawing point to (x, y) using the control points (cp1x, cp1y) and (cp2x,
	 * cp2y). For detailed information, read the
	 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-beziercurveto">
	 * whatwg spec</a>. A tiny API method "bt" also exists.
	 * @method bezierCurveTo
	 * @param {Number} cp1x
	 * @param {Number} cp1y
	 * @param {Number} cp2x
	 * @param {Number} cp2y
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
		return this.append(new G.BezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y));
	};

	/**
	 * Draws a rectangle at (x, y) with the specified width and height using the current fill and/or stroke.
	 * For detailed information, read the
	 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-rect">
	 * whatwg spec</a>. A tiny API method "r" also exists.
	 * @method rect
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w Width of the rectangle
	 * @param {Number} h Height of the rectangle
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.rect = function(x, y, w, h) {
		return this.append(new G.Rect(x, y, w, h));
	};

	/**
	 * Closes the current path, effectively drawing a line from the current drawing point to the first drawing point specified
	 * since the fill or stroke was last set. A tiny API method "cp" also exists.
	 * @method closePath
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.closePath = function() {
		return this._activeInstructions.length ? this.append(new G.ClosePath()) : this;
	};


// public methods that roughly map to Flash graphics APIs:
	/**
	 * Clears all drawing instructions, effectively resetting this Graphics instance. Any line and fill styles will need
	 * to be redefined to draw shapes following a clear call. A tiny API method "c" also exists.
	 * @method clear
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.clear = function() {
		this._instructions.length = this._activeInstructions.length = this._commitIndex = 0;
		this._strokeStyle = this._oldStrokeStyle = this._stroke = this._fill = this._strokeDash = this._oldStrokeDash = null;
		this._dirty = this._strokeIgnoreScale = false;
		return this;
	};

	/**
	 * Begins a fill with the specified color. This ends the current sub-path. A tiny API method "f" also exists.
	 * @method beginFill
	 * @param {String} color A CSS compatible color value (ex. "red", "#FF0000", or "rgba(255,0,0,0.5)"). Setting to
	 * null will result in no fill.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginFill = function(color) {
		return this._setFill(color ? new G.Fill(color) : null);
	};

	/**
	 * Begins a linear gradient fill defined by the line (x0, y0) to (x1, y1). This ends the current sub-path. For
	 * example, the following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a
	 * square to display it:
	 *
	 *      myGraphics.beginLinearGradientFill(["#000","#FFF"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);
	 *
	 * A tiny API method "lf" also exists.
	 * @method beginLinearGradientFill
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define a gradient
	 * drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw
	 * the first color to 10% then interpolating to the second color at 90%.
	 * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
	 * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginLinearGradientFill = function(colors, ratios, x0, y0, x1, y1) {
		return this._setFill(new G.Fill().linearGradient(colors, ratios, x0, y0, x1, y1));
	};

	/**
	 * Begins a radial gradient fill. This ends the current sub-path. For example, the following code defines a red to
	 * blue radial gradient centered at (100, 100), with a radius of 50, and draws a circle to display it:
	 *
	 *      myGraphics.beginRadialGradientFill(["#F00","#00F"], [0, 1], 100, 100, 0, 100, 100, 50).drawCircle(100, 100, 50);
	 *
	 * A tiny API method "rf" also exists.
	 * @method beginRadialGradientFill
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
	 * a gradient drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
	 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
	 * @param {Number} x0 Center position of the inner circle that defines the gradient.
	 * @param {Number} y0 Center position of the inner circle that defines the gradient.
	 * @param {Number} r0 Radius of the inner circle that defines the gradient.
	 * @param {Number} x1 Center position of the outer circle that defines the gradient.
	 * @param {Number} y1 Center position of the outer circle that defines the gradient.
	 * @param {Number} r1 Radius of the outer circle that defines the gradient.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginRadialGradientFill = function(colors, ratios, x0, y0, r0, x1, y1, r1) {
		return this._setFill(new G.Fill().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));
	};

	/**
	 * Begins a pattern fill using the specified image. This ends the current sub-path. A tiny API method "bf" also
	 * exists.
	 * @method beginBitmapFill
	 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
	 * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.
	 * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of "repeat",
	 * "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat". Note that Firefox does not support "repeat-x" or
	 * "repeat-y" (latest tests were in FF 20.0), and will default to "repeat".
	 * @param {Matrix2D} matrix Optional. Specifies a transformation matrix for the bitmap fill. This transformation
	 * will be applied relative to the parent transform.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginBitmapFill = function(image, repetition, matrix) {
		return this._setFill(new G.Fill(null,matrix).bitmap(image, repetition));
	};

	/**
	 * Ends the current sub-path, and begins a new one with no fill. Functionally identical to <code>beginFill(null)</code>.
	 * A tiny API method "ef" also exists.
	 * @method endFill
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.endFill = function() {
		return this.beginFill();
	};

	/**
	 * Sets the stroke style. Like all drawing methods, this can be chained, so you can define
	 * the stroke style and color in a single line of code like so:
	 *
	 * 	myGraphics.setStrokeStyle(8,"round").beginStroke("#F00");
	 *
	 * A tiny API method "ss" also exists.
	 * @method setStrokeStyle
	 * @param {Number} thickness The width of the stroke.
	 * @param {String | Number} [caps=0] Indicates the type of caps to use at the end of lines. One of butt,
	 * round, or square. Defaults to "butt". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with
	 * the tiny API.
	 * @param {String | Number} [joints=0] Specifies the type of joints that should be used where two lines meet.
	 * One of bevel, round, or miter. Defaults to "miter". Also accepts the values 0 (miter), 1 (round), and 2 (bevel)
	 * for use with the tiny API.
	 * @param {Number} [miterLimit=10] If joints is set to "miter", then you can specify a miter limit ratio which
	 * controls at what point a mitered joint will be clipped.
	 * @param {Boolean} [ignoreScale=false] If true, the stroke will be drawn at the specified thickness regardless
	 * of active transformations.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.setStrokeStyle = function(thickness, caps, joints, miterLimit, ignoreScale) {
		this._updateInstructions(true);
		this._strokeStyle = this.command = new G.StrokeStyle(thickness, caps, joints, miterLimit, ignoreScale);

		// ignoreScale lives on Stroke, not StrokeStyle, so we do a little trickery:
		if (this._stroke) { this._stroke.ignoreScale = ignoreScale; }
		this._strokeIgnoreScale = ignoreScale;
		return this;
	};
	
	/**
	 * Sets or clears the stroke dash pattern.
	 *
	 * 	myGraphics.setStrokeDash([20, 10], 0);
	 *
	 * A tiny API method `sd` also exists.
	 * @method setStrokeDash
	 * @param {Array} [segments] An array specifying the dash pattern, alternating between line and gap.
	 * For example, `[20,10]` would create a pattern of 20 pixel lines with 10 pixel gaps between them.
	 * Passing null or an empty array will clear the existing stroke dash.
	 * @param {Number} [offset=0] The offset of the dash pattern. For example, you could increment this value to create a "marching ants" effect.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.setStrokeDash = function(segments, offset) {
		this._updateInstructions(true);
		this._strokeDash = this.command = new G.StrokeDash(segments, offset);
		return this;
	};

	/**
	 * Begins a stroke with the specified color. This ends the current sub-path. A tiny API method "s" also exists.
	 * @method beginStroke
	 * @param {String} color A CSS compatible color value (ex. "#FF0000", "red", or "rgba(255,0,0,0.5)"). Setting to
	 * null will result in no stroke.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginStroke = function(color) {
		return this._setStroke(color ? new G.Stroke(color) : null);
	};

	/**
	 * Begins a linear gradient stroke defined by the line (x0, y0) to (x1, y1). This ends the current sub-path. For
	 * example, the following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a
	 * square to display it:
	 *
	 *      myGraphics.setStrokeStyle(10).
	 *          beginLinearGradientStroke(["#000","#FFF"], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);
	 *
	 * A tiny API method "ls" also exists.
	 * @method beginLinearGradientStroke
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
	 * a gradient drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
	 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
	 * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
	 * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginLinearGradientStroke = function(colors, ratios, x0, y0, x1, y1) {
		return this._setStroke(new G.Stroke().linearGradient(colors, ratios, x0, y0, x1, y1));
	};

	/**
	 * Begins a radial gradient stroke. This ends the current sub-path. For example, the following code defines a red to
	 * blue radial gradient centered at (100, 100), with a radius of 50, and draws a rectangle to display it:
	 *
	 *      myGraphics.setStrokeStyle(10)
	 *          .beginRadialGradientStroke(["#F00","#00F"], [0, 1], 100, 100, 0, 100, 100, 50)
	 *          .drawRect(50, 90, 150, 110);
	 *
	 * A tiny API method "rs" also exists.
	 * @method beginRadialGradientStroke
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
	 * a gradient drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
	 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color
	 * to 100%.
	 * @param {Number} x0 Center position of the inner circle that defines the gradient.
	 * @param {Number} y0 Center position of the inner circle that defines the gradient.
	 * @param {Number} r0 Radius of the inner circle that defines the gradient.
	 * @param {Number} x1 Center position of the outer circle that defines the gradient.
	 * @param {Number} y1 Center position of the outer circle that defines the gradient.
	 * @param {Number} r1 Radius of the outer circle that defines the gradient.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginRadialGradientStroke = function(colors, ratios, x0, y0, r0, x1, y1, r1) {
		return this._setStroke(new G.Stroke().radialGradient(colors, ratios, x0, y0, r0, x1, y1, r1));
	};

	/**
	 * Begins a pattern fill using the specified image. This ends the current sub-path. Note that unlike bitmap fills,
	 * strokes do not currently support a matrix parameter due to limitations in the canvas API. A tiny API method "bs"
	 * also exists.
	 * @method beginBitmapStroke
	 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
	 * as the pattern. Must be loaded prior to creating a bitmap fill, or the fill will be empty.
	 * @param {String} [repetition=repeat] Optional. Indicates whether to repeat the image in the fill area. One of
	 * "repeat", "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat".
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.beginBitmapStroke = function(image, repetition) {
		// NOTE: matrix is not supported for stroke because transforms on strokes also affect the drawn stroke width.
		return this._setStroke(new G.Stroke().bitmap(image, repetition));
	};

	/**
	 * Ends the current sub-path, and begins a new one with no stroke. Functionally identical to <code>beginStroke(null)</code>.
	 * A tiny API method "es" also exists.
	 * @method endStroke
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.endStroke = function() {
		return this.beginStroke();
	};

	/**
	 * Maps the familiar ActionScript <code>curveTo()</code> method to the functionally similar {{#crossLink "Graphics/quadraticCurveTo"}}{{/crossLink}}
	 * method.
	 * @method quadraticCurveTo
	 * @param {Number} cpx
	 * @param {Number} cpy
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.curveTo = p.quadraticCurveTo;

	/**
	 *
	 * Maps the familiar ActionScript <code>drawRect()</code> method to the functionally similar {{#crossLink "Graphics/rect"}}{{/crossLink}}
	 * method.
	 * @method drawRect
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w Width of the rectangle
	 * @param {Number} h Height of the rectangle
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.drawRect = p.rect;

	/**
	 * Draws a rounded rectangle with all corners with the specified radius.
	 * @method drawRoundRect
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w
	 * @param {Number} h
	 * @param {Number} radius Corner radius.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.drawRoundRect = function(x, y, w, h, radius) {
		return this.drawRoundRectComplex(x, y, w, h, radius, radius, radius, radius);
	};

	/**
	 * Draws a rounded rectangle with different corner radii. Supports positive and negative corner radii. A tiny API
	 * method "rc" also exists.
	 * @method drawRoundRectComplex
	 * @param {Number} x The horizontal coordinate to draw the round rect.
	 * @param {Number} y The vertical coordinate to draw the round rect.
	 * @param {Number} w The width of the round rect.
	 * @param {Number} h The height of the round rect.
	 * @param {Number} radiusTL Top left corner radius.
	 * @param {Number} radiusTR Top right corner radius.
	 * @param {Number} radiusBR Bottom right corner radius.
	 * @param {Number} radiusBL Bottom left corner radius.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.drawRoundRectComplex = function(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {
		return this.append(new G.RoundRect(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL));
	};

	/**
	 * Draws a circle with the specified radius at (x, y).
	 *
	 *      var g = new createjs.Graphics();
	 *	    g.setStrokeStyle(1);
	 *	    g.beginStroke(createjs.Graphics.getRGB(0,0,0));
	 *	    g.beginFill(createjs.Graphics.getRGB(255,0,0));
	 *	    g.drawCircle(0,0,3);
	 *
	 *	    var s = new createjs.Shape(g);
	 *		s.x = 100;
	 *		s.y = 100;
	 *
	 *	    stage.addChild(s);
	 *	    stage.update();
	 *
	 * A tiny API method "dc" also exists.
	 * @method drawCircle
	 * @param {Number} x x coordinate center point of circle.
	 * @param {Number} y y coordinate center point of circle.
	 * @param {Number} radius Radius of circle.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.drawCircle = function(x, y, radius) {
		return this.append(new G.Circle(x, y, radius));
	};

	/**
	 * Draws an ellipse (oval) with a specified width (w) and height (h). Similar to {{#crossLink "Graphics/drawCircle"}}{{/crossLink}},
	 * except the width and height can be different. A tiny API method "de" also exists.
	 * @method drawEllipse
	 * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}
	 * which draws from center.
	 * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}
	 * which draws from the center.
	 * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this
	 * number.
	 * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.drawEllipse = function(x, y, w, h) {
		return this.append(new G.Ellipse(x, y, w, h));
	};

	/**
	 * Draws a star if pointSize is greater than 0, or a regular polygon if pointSize is 0 with the specified number of
	 * points. For example, the following code will draw a familiar 5 pointed star shape centered at 100, 100 and with a
	 * radius of 50:
	 *
	 *      myGraphics.beginFill("#FF0").drawPolyStar(100, 100, 50, 5, 0.6, -90);
	 *      // Note: -90 makes the first point vertical
	 *
	 * A tiny API method "dp" also exists.
	 *
	 * @method drawPolyStar
	 * @param {Number} x Position of the center of the shape.
	 * @param {Number} y Position of the center of the shape.
	 * @param {Number} radius The outer radius of the shape.
	 * @param {Number} sides The number of points on the star or sides on the polygon.
	 * @param {Number} pointSize The depth or "pointy-ness" of the star points. A pointSize of 0 will draw a regular
	 * polygon (no points), a pointSize of 1 will draw nothing because the points are infinitely pointy.
	 * @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point
	 * directly to the right of the center.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.drawPolyStar = function(x, y, radius, sides, pointSize, angle) {
		return this.append(new G.PolyStar(x, y, radius, sides, pointSize, angle));
	};

	// TODO: deprecated.
	/**
	 * Removed in favour of using custom command objects with {{#crossLink "Graphics/append"}}{{/crossLink}}.
	 * @method inject
	 * @deprecated
	 **/

	/**
	 * Appends a graphics command object to the graphics queue. Command objects expose an "exec" method
	 * that accepts two parameters: the Context2D to operate on, and an arbitrary data object passed into
	 * {{#crossLink "Graphics/draw"}}{{/crossLink}}. The latter will usually be the Shape instance that called draw.
	 *
	 * This method is used internally by Graphics methods, such as drawCircle, but can also be used directly to insert
	 * built-in or custom graphics commands. For example:
	 *
	 * 		// attach data to our shape, so we can access it during the draw:
	 * 		myShape.color = "red";
	 *
	 * 		// append a Circle command object:
	 * 		myShape.graphics.append(new Graphics.Circle(50, 50, 30));
	 *
	 * 		// append a custom command object with an exec method that sets the fill style
	 * 		// based on the shape's data, and then fills the circle.
	 * 		myShape.graphics.append({exec:function(ctx, shape) {
	 * 			ctx.fillStyle = shape.color;
	 * 			ctx.fill();
	 * 		}});
	 *
	 * @method append
	 * @param {Object} command A graphics command object exposing an "exec" method.
	 * @param {boolean} clean The clean param is primarily for internal use. A value of true indicates that a command does not generate a path that should be stroked or filled.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.append = function(command, clean) {
		this._activeInstructions.push(command);
		this.command = command;
		if (!clean) { this._dirty = true; }
		return this;
	};

	/**
	 * Decodes a compact encoded path string into a series of draw instructions.
	 * This format is not intended to be human readable, and is meant for use by authoring tools.
	 * The format uses a base64 character set, with each character representing 6 bits, to define a series of draw
	 * commands.
	 *
	 * Each command is comprised of a single "header" character followed by a variable number of alternating x and y
	 * position values. Reading the header bits from left to right (most to least significant): bits 1 to 3 specify the
	 * type of operation (0-moveTo, 1-lineTo, 2-quadraticCurveTo, 3-bezierCurveTo, 4-closePath, 5-7 unused). Bit 4
	 * indicates whether position values use 12 bits (2 characters) or 18 bits (3 characters), with a one indicating the
	 * latter. Bits 5 and 6 are currently unused.
	 *
	 * Following the header is a series of 0 (closePath), 2 (moveTo, lineTo), 4 (quadraticCurveTo), or 6 (bezierCurveTo)
	 * parameters. These parameters are alternating x/y positions represented by 2 or 3 characters (as indicated by the
	 * 4th bit in the command char). These characters consist of a 1 bit sign (1 is negative, 0 is positive), followed
	 * by an 11 (2 char) or 17 (3 char) bit integer value. All position values are in tenths of a pixel. Except in the
	 * case of move operations which are absolute, this value is a delta from the previous x or y position (as
	 * appropriate).
	 *
	 * For example, the string "A3cAAMAu4AAA" represents a line starting at -150,0 and ending at 150,0.
	 * <br />A - bits 000000. First 3 bits (000) indicate a moveTo operation. 4th bit (0) indicates 2 chars per
	 * parameter.
	 * <br />n0 - 110111011100. Absolute x position of -150.0px. First bit indicates a negative value, remaining bits
	 * indicate 1500 tenths of a pixel.
	 * <br />AA - 000000000000. Absolute y position of 0.
	 * <br />I - 001100. First 3 bits (001) indicate a lineTo operation. 4th bit (1) indicates 3 chars per parameter.
	 * <br />Au4 - 000000101110111000. An x delta of 300.0px, which is added to the previous x value of -150.0px to
	 * provide an absolute position of +150.0px.
	 * <br />AAA - 000000000000000000. A y delta value of 0.
	 *
	 * A tiny API method "p" also exists.
	 * @method decodePath
	 * @param {String} str The path string to decode.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.decodePath = function(str) {
		var instructions = [this.moveTo, this.lineTo, this.quadraticCurveTo, this.bezierCurveTo, this.closePath];
		var paramCount = [2, 2, 4, 6, 0];
		var i=0, l=str.length;
		var params = [];
		var x=0, y=0;
		var base64 = Graphics.BASE_64;

		while (i<l) {
			var c = str.charAt(i);
			var n = base64[c];
			var fi = n>>3; // highest order bits 1-3 code for operation.
			var f = instructions[fi];
			// check that we have a valid instruction & that the unused bits are empty:
			if (!f || (n&3)) { throw("bad path data (@"+i+"): "+c); }
			var pl = paramCount[fi];
			if (!fi) { x=y=0; } // move operations reset the position.
			params.length = 0;
			i++;
			var charCount = (n>>2&1)+2;  // 4th header bit indicates number size for this operation.
			for (var p=0; p<pl; p++) {
				var num = base64[str.charAt(i)];
				var sign = (num>>5) ? -1 : 1;
				num = ((num&31)<<6)|(base64[str.charAt(i+1)]);
				if (charCount == 3) { num = (num<<6)|(base64[str.charAt(i+2)]); }
				num = sign*num/10;
				if (p%2) { x = (num += x); }
				else { y = (num += y); }
				params[p] = num;
				i += charCount;
			}
			f.apply(this,params);
		}
		return this;
	};

	/**
	 * Stores all graphics commands so they won't be executed in future draws. Calling store() a second time adds to
	 * the existing store. This also affects `drawAsPath()`.
	 *
	 * This is useful in cases where you are creating vector graphics in an iterative manner (ex. generative art), so
	 * that only new graphics need to be drawn (which can provide huge performance benefits), but you wish to retain all
	 * of the vector instructions for later use (ex. scaling, modifying, or exporting).
	 *
	 * Note that calling store() will force the active path (if any) to be ended in a manner similar to changing
	 * the fill or stroke.
	 *
	 * For example, consider a application where the user draws lines with the mouse. As each line segment (or collection of
	 * segments) are added to a Shape, it can be rasterized using {{#crossLink "DisplayObject/updateCache"}}{{/crossLink}},
	 * and then stored, so that it can be redrawn at a different scale when the application is resized, or exported to SVG.
	 *
	 * 	// set up cache:
	 * 	myShape.cache(0,0,500,500,scale);
	 *
	 * 	// when the user drags, draw a new line:
	 * 	myShape.graphics.moveTo(oldX,oldY).lineTo(newX,newY);
	 * 	// then draw it into the existing cache:
	 * 	myShape.updateCache("source-over");
	 * 	// store the new line, so it isn't redrawn next time:
	 * 	myShape.store();
	 *
	 * 	// then, when the window resizes, we can re-render at a different scale:
	 * 	// first, unstore all our lines:
	 * 	myShape.unstore();
	 * 	// then cache using the new scale:
	 * 	myShape.cache(0,0,500,500,newScale);
	 * 	// finally, store the existing commands again:
	 * 	myShape.store();
	 *
	 * @method store
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.store = function() {
		this._updateInstructions(true);
		this._storeIndex = this._instructions.length;
		return this;
	};

	/**
	 * Unstores any graphics commands that were previously stored using {{#crossLink "Graphics/store"}}{{/crossLink}}
	 * so that they will be executed in subsequent draw calls.
	 *
	 * @method unstore
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.unstore = function() {
		this._storeIndex = 0;
		return this;
	};

	/**
	 * Returns a clone of this Graphics instance. Note that the individual command objects are not cloned.
	 * @method clone
	 * @return {Graphics} A clone of the current Graphics instance.
	 **/
	p.clone = function() {
		var o = new Graphics();
		o.command = this.command;
		o._stroke = this._stroke;
		o._strokeStyle = this._strokeStyle;
		o._strokeDash = this._strokeDash;
		o._strokeIgnoreScale = this._strokeIgnoreScale;
		o._fill = this._fill;
		o._instructions = this._instructions.slice();
		o._commitIndex = this._commitIndex;
		o._activeInstructions = this._activeInstructions.slice();
		o._dirty = this._dirty;
		o._storeIndex = this._storeIndex;
		return o;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Graphics]";
	};


// tiny API:
	/**
	 * Shortcut to moveTo.
	 * @method mt
	 * @param {Number} x The x coordinate the drawing point should move to.
	 * @param {Number} y The y coordinate the drawing point should move to.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls).
	 * @chainable
	 * @protected
	 **/
	p.mt = p.moveTo;

	/**
	 * Shortcut to lineTo.
	 * @method lt
	 * @param {Number} x The x coordinate the drawing point should draw to.
	 * @param {Number} y The y coordinate the drawing point should draw to.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.lt = p.lineTo;

	/**
	 * Shortcut to arcTo.
	 * @method at
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} radius
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.at = p.arcTo;

	/**
	 * Shortcut to bezierCurveTo.
	 * @method bt
	 * @param {Number} cp1x
	 * @param {Number} cp1y
	 * @param {Number} cp2x
	 * @param {Number} cp2y
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.bt = p.bezierCurveTo;

	/**
	 * Shortcut to quadraticCurveTo / curveTo.
	 * @method qt
	 * @param {Number} cpx
	 * @param {Number} cpy
	 * @param {Number} x
	 * @param {Number} y
	 * @protected
	 * @chainable
	 **/
	p.qt = p.quadraticCurveTo;

	/**
	 * Shortcut to arc.
	 * @method a
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} radius
	 * @param {Number} startAngle Measured in radians.
	 * @param {Number} endAngle Measured in radians.
	 * @param {Boolean} anticlockwise
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @protected
	 * @chainable
	 **/
	p.a = p.arc;

	/**
	 * Shortcut to rect.
	 * @method r
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w Width of the rectangle
	 * @param {Number} h Height of the rectangle
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.r = p.rect;

	/**
	 * Shortcut to closePath.
	 * @method cp
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.cp = p.closePath;

	/**
	 * Shortcut to clear.
	 * @method c
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.c = p.clear;

	/**
	 * Shortcut to beginFill.
	 * @method f
	 * @param {String} color A CSS compatible color value (ex. "red", "#FF0000", or "rgba(255,0,0,0.5)"). Setting to
	 * null will result in no fill.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.f = p.beginFill;

	/**
	 * Shortcut to beginLinearGradientFill.
	 * @method lf
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define a gradient
	 * drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw
	 * the first color to 10% then interpolating to the second color at 90%.
	 * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
	 * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.lf = p.beginLinearGradientFill;

	/**
	 * Shortcut to beginRadialGradientFill.
	 * @method rf
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
	 * a gradient drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
	 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
	 * @param {Number} x0 Center position of the inner circle that defines the gradient.
	 * @param {Number} y0 Center position of the inner circle that defines the gradient.
	 * @param {Number} r0 Radius of the inner circle that defines the gradient.
	 * @param {Number} x1 Center position of the outer circle that defines the gradient.
	 * @param {Number} y1 Center position of the outer circle that defines the gradient.
	 * @param {Number} r1 Radius of the outer circle that defines the gradient.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.rf = p.beginRadialGradientFill;

	/**
	 * Shortcut to beginBitmapFill.
	 * @method bf
	 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
	 * as the pattern.
	 * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of "repeat",
	 * "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat". Note that Firefox does not support "repeat-x" or
	 * "repeat-y" (latest tests were in FF 20.0), and will default to "repeat".
	 * @param {Matrix2D} matrix Optional. Specifies a transformation matrix for the bitmap fill. This transformation
	 * will be applied relative to the parent transform.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.bf = p.beginBitmapFill;

	/**
	 * Shortcut to endFill.
	 * @method ef
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.ef = p.endFill;

	/**
	 * Shortcut to setStrokeStyle.
	 * @method ss
	 * @param {Number} thickness The width of the stroke.
	 * @param {String | Number} [caps=0] Indicates the type of caps to use at the end of lines. One of butt,
	 * round, or square. Defaults to "butt". Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with
	 * the tiny API.
	 * @param {String | Number} [joints=0] Specifies the type of joints that should be used where two lines meet.
	 * One of bevel, round, or miter. Defaults to "miter". Also accepts the values 0 (miter), 1 (round), and 2 (bevel)
	 * for use with the tiny API.
	 * @param {Number} [miterLimit=10] If joints is set to "miter", then you can specify a miter limit ratio which
	 * controls at what point a mitered joint will be clipped.
	 * @param {Boolean} [ignoreScale=false] If true, the stroke will be drawn at the specified thickness regardless
	 * of active transformations.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.ss = p.setStrokeStyle;
	
	/**
	 * Shortcut to setStrokeDash.
	 * @method sd
	 * @param {Array} [segments] An array specifying the dash pattern, alternating between line and gap.
	 * For example, [20,10] would create a pattern of 20 pixel lines with 10 pixel gaps between them.
	 * Passing null or an empty array will clear any existing dash.
	 * @param {Number} [offset=0] The offset of the dash pattern. For example, you could increment this value to create a "marching ants" effect.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.sd = p.setStrokeDash;

	/**
	 * Shortcut to beginStroke.
	 * @method s
	 * @param {String} color A CSS compatible color value (ex. "#FF0000", "red", or "rgba(255,0,0,0.5)"). Setting to
	 * null will result in no stroke.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.s = p.beginStroke;

	/**
	 * Shortcut to beginLinearGradientStroke.
	 * @method ls
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
	 * a gradient drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
	 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
	 * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
	 * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.ls = p.beginLinearGradientStroke;

	/**
	 * Shortcut to beginRadialGradientStroke.
	 * @method rs
	 * @param {Array} colors An array of CSS compatible color values. For example, ["#F00","#00F"] would define
	 * a gradient drawing from red to blue.
	 * @param {Array} ratios An array of gradient positions which correspond to the colors. For example, [0.1,
	 * 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color
	 * to 100%.
	 * @param {Number} x0 Center position of the inner circle that defines the gradient.
	 * @param {Number} y0 Center position of the inner circle that defines the gradient.
	 * @param {Number} r0 Radius of the inner circle that defines the gradient.
	 * @param {Number} x1 Center position of the outer circle that defines the gradient.
	 * @param {Number} y1 Center position of the outer circle that defines the gradient.
	 * @param {Number} r1 Radius of the outer circle that defines the gradient.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.rs = p.beginRadialGradientStroke;

	/**
	 * Shortcut to beginBitmapStroke.
	 * @method bs
	 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use
	 * as the pattern.
	 * @param {String} [repetition=repeat] Optional. Indicates whether to repeat the image in the fill area. One of
	 * "repeat", "repeat-x", "repeat-y", or "no-repeat". Defaults to "repeat".
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.bs = p.beginBitmapStroke;

	/**
	 * Shortcut to endStroke.
	 * @method es
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.es = p.endStroke;

	/**
	 * Shortcut to drawRect.
	 * @method dr
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w Width of the rectangle
	 * @param {Number} h Height of the rectangle
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.dr = p.drawRect;

	/**
	 * Shortcut to drawRoundRect.
	 * @method rr
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w
	 * @param {Number} h
	 * @param {Number} radius Corner radius.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.rr = p.drawRoundRect;

	/**
	 * Shortcut to drawRoundRectComplex.
	 * @method rc
	 * @param {Number} x The horizontal coordinate to draw the round rect.
	 * @param {Number} y The vertical coordinate to draw the round rect.
	 * @param {Number} w The width of the round rect.
	 * @param {Number} h The height of the round rect.
	 * @param {Number} radiusTL Top left corner radius.
	 * @param {Number} radiusTR Top right corner radius.
	 * @param {Number} radiusBR Bottom right corner radius.
	 * @param {Number} radiusBL Bottom left corner radius.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.rc = p.drawRoundRectComplex;

	/**
	 * Shortcut to drawCircle.
	 * @method dc
	 * @param {Number} x x coordinate center point of circle.
	 * @param {Number} y y coordinate center point of circle.
	 * @param {Number} radius Radius of circle.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.dc = p.drawCircle;

	/**
	 * Shortcut to drawEllipse.
	 * @method de
	 * @param {Number} x The left coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}
	 * which draws from center.
	 * @param {Number} y The top coordinate point of the ellipse. Note that this is different from {{#crossLink "Graphics/drawCircle"}}{{/crossLink}}
	 * which draws from the center.
	 * @param {Number} w The height (horizontal diameter) of the ellipse. The horizontal radius will be half of this
	 * number.
	 * @param {Number} h The width (vertical diameter) of the ellipse. The vertical radius will be half of this number.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.de = p.drawEllipse;

	/**
	 * Shortcut to drawPolyStar.
	 * @method dp
	 * @param {Number} x Position of the center of the shape.
	 * @param {Number} y Position of the center of the shape.
	 * @param {Number} radius The outer radius of the shape.
	 * @param {Number} sides The number of points on the star or sides on the polygon.
	 * @param {Number} pointSize The depth or "pointy-ness" of the star points. A pointSize of 0 will draw a regular
	 * polygon (no points), a pointSize of 1 will draw nothing because the points are infinitely pointy.
	 * @param {Number} angle The angle of the first point / corner. For example a value of 0 will draw the first point
	 * directly to the right of the center.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.dp = p.drawPolyStar;

	/**
	 * Shortcut to decodePath.
	 * @method p
	 * @param {String} str The path string to decode.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 * @chainable
	 * @protected
	 **/
	p.p = p.decodePath;


// private methods:
	/**
	 * @method _updateInstructions
	 * @param commit
	 * @protected
	 **/
	p._updateInstructions = function(commit) {
		var instr = this._instructions, active = this._activeInstructions, commitIndex = this._commitIndex;

		if (this._dirty && active.length) {
			instr.length = commitIndex; // remove old, uncommitted commands
			instr.push(Graphics.beginCmd);

			var l = active.length, ll = instr.length;
			instr.length = ll+l;
			for (var i=0; i<l; i++) { instr[i+ll] = active[i]; }

			if (this._fill) { instr.push(this._fill); }
			if (this._stroke) {
				// doesn't need to be re-applied if it hasn't changed.
				if (this._strokeDash !== this._oldStrokeDash) {
					this._oldStrokeDash = this._strokeDash;
					instr.push(this._strokeDash);
				}
				if (this._strokeStyle !== this._oldStrokeStyle) {
					this._oldStrokeStyle = this._strokeStyle;
					instr.push(this._strokeStyle);
				}
				instr.push(this._stroke);
			}

			this._dirty = false;
		}

		if (commit) {
			active.length = 0;
			this._commitIndex = instr.length;
		}
	};

	/**
	 * @method _setFill
	 * @param fill
	 * @protected
	 **/
	p._setFill = function(fill) {
		this._updateInstructions(true);
		this.command = this._fill = fill;
		return this;
	};

	/**
	 * @method _setStroke
	 * @param stroke
	 * @protected
	 **/
	p._setStroke = function(stroke) {
		this._updateInstructions(true);
		if (this.command = this._stroke = stroke) {
			stroke.ignoreScale = this._strokeIgnoreScale;
		}
		return this;
	};

// Command Objects:
	/**
	 * @namespace Graphics
	 */
	/**
	 * Graphics command object. See {{#crossLink "Graphics/lineTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information. See {{#crossLink "Graphics"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class LineTo
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.LineTo = function(x, y) {
		this.x = x; this.y = y;
	}).prototype.exec = function(ctx) { ctx.lineTo(this.x,this.y); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/moveTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class MoveTo
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.MoveTo = function(x, y) {
		this.x = x; this.y = y;
	}).prototype.exec = function(ctx) { ctx.moveTo(this.x, this.y); };


	/**
	 * Graphics command object. See {{#crossLink "Graphics/arcTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class ArcTo
	 * @constructor
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} radius
	 **/
	/**
	 * @property x1
	 * @type Number
	 */
	/**
	 * @property y1
	 * @type Number
	 */
	/**
	 * @property x2
	 * @type Number
	 */
	/**
	 * @property y2
	 * @type Number
	 */
	/**
	 * @property radius
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.ArcTo = function(x1, y1, x2, y2, radius) {
		this.x1 = x1; this.y1 = y1;
		this.x2 = x2; this.y2 = y2;
		this.radius = radius;
	}).prototype.exec = function(ctx) { ctx.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/arc"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class Arc
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} radius
	 * @param {Number} startAngle
	 * @param {Number} endAngle
	 * @param {Number} anticlockwise
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @property radius
	 * @type Number
	 */
	/**
	 * @property startAngle
	 * @type Number
	 */
	/**
	 * @property endAngle
	 * @type Number
	 */
	/**
	 * @property anticlockwise
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.Arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {
		this.x = x; this.y = y;
		this.radius = radius;
		this.startAngle = startAngle; this.endAngle = endAngle;
		this.anticlockwise = !!anticlockwise;
	}).prototype.exec = function(ctx) { ctx.arc(this.x, this.y, this.radius, this.startAngle, this.endAngle, this.anticlockwise); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/quadraticCurveTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class QuadraticCurveTo
	 * @constructor
	 * @param {Number} cpx
	 * @param {Number} cpy
	 * @param {Number} x
	 * @param {Number} y
	 **/
	/**
	 * @property cpx
	 * @type Number
	 */
	/**
	 * @property cpy
	 * @type Number
	 */
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.QuadraticCurveTo = function(cpx, cpy, x, y) {
		this.cpx = cpx; this.cpy = cpy;
		this.x = x; this.y = y;
	}).prototype.exec = function(ctx) { ctx.quadraticCurveTo(this.cpx, this.cpy, this.x, this.y); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/bezierCurveTo"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class BezierCurveTo
	 * @constructor
	 * @param {Number} cp1x
	 * @param {Number} cp1y
	 * @param {Number} cp2x
	 * @param {Number} cp2y
	 * @param {Number} x
	 * @param {Number} y
	 **/
	/**
	 * @property cp1x
	 * @type Number
	 */
	/**
	 * @property cp1y
	 * @type Number
	 */
	/**
	 * @property cp2x
	 * @type Number
	 */
	/**
	 * @property cp2y
	 * @type Number
	 */
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.BezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
		this.cp1x = cp1x; this.cp1y = cp1y;
		this.cp2x = cp2x; this.cp2y = cp2y;
		this.x = x; this.y = y;
	}).prototype.exec = function(ctx) { ctx.bezierCurveTo(this.cp1x, this.cp1y, this.cp2x, this.cp2y, this.x, this.y); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/rect"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class Rect
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w
	 * @param {Number} h
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @property w
	 * @type Number
	 */
	/**
	 * @property h
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.Rect = function(x, y, w, h) {
		this.x = x; this.y = y;
		this.w = w; this.h = h;
	}).prototype.exec = function(ctx) { ctx.rect(this.x, this.y, this.w, this.h); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/closePath"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class ClosePath
	 * @constructor
	 **/
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.ClosePath = function() {
	}).prototype.exec = function(ctx) { ctx.closePath(); };

	/**
	 * Graphics command object to begin a new path. See {{#crossLink "Graphics"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class BeginPath
	 * @constructor
	 **/
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.BeginPath = function() {
	}).prototype.exec = function(ctx) { ctx.beginPath(); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/beginFill"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class Fill
	 * @constructor
	 * @param {Object} style A valid Context2D fillStyle.
	 * @param {Matrix2D} matrix
	 **/
	/**
	 * A valid Context2D fillStyle.
	 * @property style
	 * @type Object
	 */
	/**
	 * @property matrix
	 * @type Matrix2D
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	p = (G.Fill = function(style, matrix) {
		this.style = style;
		this.matrix = matrix;
	}).prototype;
	p.exec = function(ctx) {
		if (!this.style) { return; }
		ctx.fillStyle = this.style;
		var mtx = this.matrix;
		if (mtx) { ctx.save(); ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty); }
		ctx.fill();
		if (mtx) { ctx.restore(); }
	};
	/**
	 * Creates a linear gradient style and assigns it to {{#crossLink "Fill/style:property"}}{{/crossLink}}.
	 * See {{#crossLink "Graphics/beginLinearGradientFill"}}{{/crossLink}} for more information.
	 * @method linearGradient
	 * @param {Array} colors
	 * @param {Array} ratios
	 * @param {Number} x0
	 * @param {Number} y0
	 * @param {Number} x1
	 * @param {Number} y1
	 * @return {Fill} Returns this Fill object for chaining or assignment.
	 */
	p.linearGradient = function(colors, ratios, x0, y0, x1, y1) {
		var o = this.style =  Graphics._ctx.createLinearGradient(x0, y0, x1, y1);
		for (var i=0, l=colors.length; i<l; i++) { o.addColorStop(ratios[i], colors[i]); }
		o.props = {colors:colors, ratios:ratios, x0:x0, y0:y0, x1:x1, y1:y1, type:"linear"};
		return this;
	};
	/**
	 * Creates a radial gradient style and assigns it to {{#crossLink "Fill/style:property"}}{{/crossLink}}.
	 * See {{#crossLink "Graphics/beginRadialGradientFill"}}{{/crossLink}} for more information.
	 * @method radialGradient
	 * @param {Array} colors
	 * @param {Array} ratios
	 * @param {Number} x0
	 * @param {Number} y0
	 * @param {Number} r0
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} r1
	 * @return {Fill} Returns this Fill object for chaining or assignment.
	 */
	p.radialGradient = function(colors, ratios, x0, y0, r0, x1, y1, r1) {
		var o = this.style =  Graphics._ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
		for (var i=0, l=colors.length; i<l; i++) { o.addColorStop(ratios[i], colors[i]); }
		o.props = {colors:colors, ratios:ratios, x0:x0, y0:y0, r0:r0, x1:x1, y1:y1, r1:r1, type:"radial"};
		return this;
	};
	/**
	 * Creates a bitmap fill style and assigns it to the {{#crossLink "Fill/style:property"}}{{/crossLink}}.
	 * See {{#crossLink "Graphics/beginBitmapFill"}}{{/crossLink}} for more information.
	 * @method bitmap
	 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement} image  Must be loaded prior to creating a bitmap fill, or the fill will be empty.
	 * @param {String} [repetition] One of: repeat, repeat-x, repeat-y, or no-repeat.
	 * @return {Fill} Returns this Fill object for chaining or assignment.
	 */
	p.bitmap = function(image, repetition) {
		if (image.naturalWidth || image.getContext || image.readyState >= 2) {
			var o = this.style = Graphics._ctx.createPattern(image, repetition || "");
			o.props = {image: image, repetition: repetition, type: "bitmap"};
		}
		return this;
	};
	p.path = false;

	/**
	 * Graphics command object. See {{#crossLink "Graphics/beginStroke"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class Stroke
	 * @constructor
	 * @param {Object} style A valid Context2D fillStyle.
	 * @param {Boolean} ignoreScale
	 **/
	/**
	 * A valid Context2D strokeStyle.
	 * @property style
	 * @type Object
	 */
	/**
	 * @property ignoreScale
	 * @type Boolean
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	p = (G.Stroke = function(style, ignoreScale) {
		this.style = style;
		this.ignoreScale = ignoreScale;
	}).prototype;
	p.exec = function(ctx) {
		if (!this.style) { return; }
		ctx.strokeStyle = this.style;
		if (this.ignoreScale) { ctx.save(); ctx.setTransform(1,0,0,1,0,0); }
		ctx.stroke();
		if (this.ignoreScale) { ctx.restore(); }
	};
	/**
	 * Creates a linear gradient style and assigns it to {{#crossLink "Stroke/style:property"}}{{/crossLink}}.
	 * See {{#crossLink "Graphics/beginLinearGradientStroke"}}{{/crossLink}} for more information.
	 * @method linearGradient
	 * @param {Array} colors
	 * @param {Array} ratios
	 * @param {Number} x0
	 * @param {Number} y0
	 * @param {Number} x1
	 * @param {Number} y1
	 * @return {Fill} Returns this Stroke object for chaining or assignment.
	 */
	p.linearGradient = G.Fill.prototype.linearGradient;
	/**
	 * Creates a radial gradient style and assigns it to {{#crossLink "Stroke/style:property"}}{{/crossLink}}.
	 * See {{#crossLink "Graphics/beginRadialGradientStroke"}}{{/crossLink}} for more information.
	 * @method radialGradient
	 * @param {Array} colors
	 * @param {Array} ratios
	 * @param {Number} x0
	 * @param {Number} y0
	 * @param {Number} r0
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} r1
	 * @return {Fill} Returns this Stroke object for chaining or assignment.
	 */
	p.radialGradient = G.Fill.prototype.radialGradient;
	/**
	 * Creates a bitmap fill style and assigns it to {{#crossLink "Stroke/style:property"}}{{/crossLink}}.
	 * See {{#crossLink "Graphics/beginBitmapStroke"}}{{/crossLink}} for more information.
	 * @method bitmap
	 * @param {HTMLImageElement} image
	 * @param {String} [repetition] One of: repeat, repeat-x, repeat-y, or no-repeat.
	 * @return {Fill} Returns this Stroke object for chaining or assignment.
	 */
	p.bitmap = G.Fill.prototype.bitmap;
	p.path = false;

	/**
	 * Graphics command object. See {{#crossLink "Graphics/setStrokeStyle"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class StrokeStyle
	 * @constructor
	 * @param {Number} width
	 * @param {String} [caps]
	 * @param {String} [joints]
	 * @param {Number} [miterLimit]
	 **/
	/**
	 * @property width
	 * @type Number
	 */
	/**
	 * One of: butt, round, square
	 * @property caps
	 * @type String
	 */
	/**
	 * One of: round, bevel, miter
	 * @property joints
	 * @type String
	 */
	/**
	 * @property miterLimit
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	p = (G.StrokeStyle = function(width, caps, joints, miterLimit) {
		this.width = width;
		this.caps = caps;
		this.joints = joints;
		this.miterLimit = miterLimit;
	}).prototype;
	p.exec = function(ctx) {
		ctx.lineWidth = (this.width == null ? "1" : this.width);
		ctx.lineCap = (this.caps == null ? "butt" : (isNaN(this.caps) ? this.caps : Graphics.STROKE_CAPS_MAP[this.caps]));
		ctx.lineJoin = (this.joints == null ? "miter" : (isNaN(this.joints) ? this.joints : Graphics.STROKE_JOINTS_MAP[this.joints]));
		ctx.miterLimit = (this.miterLimit == null ? "10" : this.miterLimit);
	};
	p.path = false;
	
	/**
	 * Graphics command object. See {{#crossLink "Graphics/setStrokeDash"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class StrokeDash
	 * @constructor
	 * @param {Array} [segments]
	 * @param {Number} [offset=0]
	 **/
	/**
	 * @property segments
	 * @type Array
	 */
	/**
	 * @property offset
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.StrokeDash = function(segments, offset) {
		this.segments = segments;
		this.offset = offset||0;
	}).prototype.exec = function(ctx) {
		if (ctx.setLineDash) { // feature detection.
			ctx.setLineDash(this.segments|| G.StrokeDash.EMPTY_SEGMENTS); // instead of [] to reduce churn.
			ctx.lineDashOffset = this.offset||0;
		}
	};
	/**
	 * The default value for segments (ie. no dash).
	 * @property EMPTY_SEGMENTS
	 * @static
	 * @final
	 * @readonly
	 * @protected
	 * @type {Array}
	 **/
	G.StrokeDash.EMPTY_SEGMENTS = [];

	/**
	 * Graphics command object. See {{#crossLink "Graphics/drawRoundRectComplex"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class RoundRect
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w
	 * @param {Number} h
	 * @param {Number} radiusTL
	 * @param {Number} radiusTR
	 * @param {Number} radiusBR
	 * @param {Number} radiusBL
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @property w
	 * @type Number
	 */
	/**
	 * @property h
	 * @type Number
	 */
	/**
	 * @property radiusTL
	 * @type Number
	 */
	/**
	 * @property radiusTR
	 * @type Number
	 */
	/**
	 * @property radiusBR
	 * @type Number
	 */
	/**
	 * @property radiusBL
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.RoundRect = function(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {
		this.x = x; this.y = y;
		this.w = w; this.h = h;
		this.radiusTL = radiusTL; this.radiusTR = radiusTR;
		this.radiusBR = radiusBR; this.radiusBL = radiusBL;
	}).prototype.exec = function(ctx) {
		var max = (w<h?w:h)/2;
		var mTL=0, mTR=0, mBR=0, mBL=0;
		var x = this.x, y = this.y, w = this.w, h = this.h;
		var rTL = this.radiusTL, rTR = this.radiusTR, rBR = this.radiusBR, rBL = this.radiusBL;

		if (rTL < 0) { rTL *= (mTL=-1); }
		if (rTL > max) { rTL = max; }
		if (rTR < 0) { rTR *= (mTR=-1); }
		if (rTR > max) { rTR = max; }
		if (rBR < 0) { rBR *= (mBR=-1); }
		if (rBR > max) { rBR = max; }
		if (rBL < 0) { rBL *= (mBL=-1); }
		if (rBL > max) { rBL = max; }

		ctx.moveTo(x+w-rTR, y);
		ctx.arcTo(x+w+rTR*mTR, y-rTR*mTR, x+w, y+rTR, rTR);
		ctx.lineTo(x+w, y+h-rBR);
		ctx.arcTo(x+w+rBR*mBR, y+h+rBR*mBR, x+w-rBR, y+h, rBR);
		ctx.lineTo(x+rBL, y+h);
		ctx.arcTo(x-rBL*mBL, y+h+rBL*mBL, x, y+h-rBL, rBL);
		ctx.lineTo(x, y+rTL);
		ctx.arcTo(x-rTL*mTL, y-rTL*mTL, x+rTL, y, rTL);
		ctx.closePath();
	};

	/**
	 * Graphics command object. See {{#crossLink "Graphics/drawCircle"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class Circle
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} radius
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @property radius
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.Circle = function(x, y, radius) {
		this.x = x; this.y = y;
		this.radius = radius;
	}).prototype.exec = function(ctx) { ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); };

	/**
	 * Graphics command object. See {{#crossLink "Graphics/drawEllipse"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class Ellipse
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w
	 * @param {Number} h
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @property w
	 * @type Number
	 */
	/**
	 * @property h
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.Ellipse = function(x, y, w, h) {
		this.x = x; this.y = y;
		this.w = w; this.h = h;
	}).prototype.exec = function(ctx) {
		var x = this.x, y = this.y;
		var w = this.w, h = this.h;

		var k = 0.5522848;
		var ox = (w / 2) * k;
		var oy = (h / 2) * k;
		var xe = x + w;
		var ye = y + h;
		var xm = x + w / 2;
		var ym = y + h / 2;

		ctx.moveTo(x, ym);
		ctx.bezierCurveTo(x, ym-oy, xm-ox, y, xm, y);
		ctx.bezierCurveTo(xm+ox, y, xe, ym-oy, xe, ym);
		ctx.bezierCurveTo(xe, ym+oy, xm+ox, ye, xm, ye);
		ctx.bezierCurveTo(xm-ox, ye, x, ym+oy, x, ym);
	};

	/**
	 * Graphics command object. See {{#crossLink "Graphics/drawPolyStar"}}{{/crossLink}} and {{#crossLink "Graphics/append"}}{{/crossLink}} for more information.
	 * @class PolyStar
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} radius
	 * @param {Number} sides
	 * @param {Number} pointSize
	 * @param {Number} angle
	 **/
	/**
	 * @property x
	 * @type Number
	 */
	/**
	 * @property y
	 * @type Number
	 */
	/**
	 * @property radius
	 * @type Number
	 */
	/**
	 * @property sides
	 * @type Number
	 */
	/**
	 * @property pointSize
	 * @type Number
	 */
	/**
	 * @property angle
	 * @type Number
	 */
	/**
	 * @method exec
	 * @param {CanvasRenderingContext2D} ctx
	 */
	(G.PolyStar = function(x, y, radius, sides, pointSize, angle) {
		this.x = x; this.y = y;
		this.radius = radius;
		this.sides = sides;
		this.pointSize = pointSize;
		this.angle = angle;
	}).prototype.exec = function(ctx) {
		var x = this.x, y = this.y;
		var radius = this.radius;
		var angle = (this.angle||0)/180*Math.PI;
		var sides = this.sides;
		var ps = 1-(this.pointSize||0);
		var a = Math.PI/sides;

		ctx.moveTo(x+Math.cos(angle)*radius, y+Math.sin(angle)*radius);
		for (var i=0; i<sides; i++) {
			angle += a;
			if (ps != 1) {
				ctx.lineTo(x+Math.cos(angle)*radius*ps, y+Math.sin(angle)*radius*ps);
			}
			angle += a;
			ctx.lineTo(x+Math.cos(angle)*radius, y+Math.sin(angle)*radius);
		}
		ctx.closePath();
	};

	// docced above.
	Graphics.beginCmd = new G.BeginPath(); // so we don't have to instantiate multiple instances.


	createjs.Graphics = Graphics;
}());

//##############################################################################
// DisplayObject.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * DisplayObject is an abstract class that should not be constructed directly. Instead construct subclasses such as
	 * {{#crossLink "Container"}}{{/crossLink}}, {{#crossLink "Bitmap"}}{{/crossLink}}, and {{#crossLink "Shape"}}{{/crossLink}}.
	 * DisplayObject is the base class for all display classes in the EaselJS library. It defines the core properties and
	 * methods that are shared between all display objects, such as transformation properties (x, y, scaleX, scaleY, etc),
	 * caching, and mouse handlers.
	 * @class DisplayObject
	 * @extends EventDispatcher
	 * @constructor
	 **/
	function DisplayObject() {
		this.EventDispatcher_constructor();
		
		
	// public properties:
		/**
		 * The alpha (transparency) for this display object. 0 is fully transparent, 1 is fully opaque.
		 * @property alpha
		 * @type {Number}
		 * @default 1
		 **/
		this.alpha = 1;
	
		/**
		 * If a cache is active, this returns the canvas that holds the cached version of this display object. See {{#crossLink "cache"}}{{/crossLink}}
		 * for more information.
		 * @property cacheCanvas
		 * @type {HTMLCanvasElement | Object}
		 * @default null
		 * @readonly
		 **/
		this.cacheCanvas = null;
	
		/**
		 * Returns an ID number that uniquely identifies the current cache for this display object. This can be used to
		 * determine if the cache has changed since a previous check.
		 * @property cacheID
		 * @type {Number}
		 * @default 0
		 */
		this.cacheID = 0;
	
		/**
		 * Unique ID for this display object. Makes display objects easier for some uses.
		 * @property id
		 * @type {Number}
		 * @default -1
		 **/
		this.id = createjs.UID.get();
	
		/**
		 * Indicates whether to include this object when running mouse interactions. Setting this to `false` for children
		 * of a {{#crossLink "Container"}}{{/crossLink}} will cause events on the Container to not fire when that child is
		 * clicked. Setting this property to `false` does not prevent the {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}}
		 * method from returning the child.
		 *
		 * <strong>Note:</strong> In EaselJS 0.7.0, the mouseEnabled property will not work properly with nested Containers. Please
		 * check out the latest NEXT version in <a href="https://github.com/CreateJS/EaselJS/tree/master/lib">GitHub</a> for an updated version with this issue resolved. The fix will be
		 * provided in the next release of EaselJS.
		 * @property mouseEnabled
		 * @type {Boolean}
		 * @default true
		 **/
		this.mouseEnabled = true;
		
		/**
		 * If false, the tick will not run on this display object (or its children). This can provide some performance benefits.
		 * In addition to preventing the "tick" event from being dispatched, it will also prevent tick related updates
		 * on some display objects (ex. Sprite & MovieClip frame advancing, DOMElement visibility handling).
		 * @property tickEnabled
		 * @type Boolean
		 * @default true
		 **/
		this.tickEnabled = true;
	
		/**
		 * An optional name for this display object. Included in {{#crossLink "DisplayObject/toString"}}{{/crossLink}} . Useful for
		 * debugging.
		 * @property name
		 * @type {String}
		 * @default null
		 **/
		this.name = null;
	
		/**
		 * A reference to the {{#crossLink "Container"}}{{/crossLink}} or {{#crossLink "Stage"}}{{/crossLink}} object that
		 * contains this display object, or null if it has not been added
		 * to one.
		 * @property parent
		 * @final
		 * @type {Container}
		 * @default null
		 * @readonly
		 **/
		this.parent = null;
	
		/**
		 * The left offset for this display object's registration point. For example, to make a 100x100px Bitmap rotate
		 * around its center, you would set regX and {{#crossLink "DisplayObject/regY:property"}}{{/crossLink}} to 50.
		 * @property regX
		 * @type {Number}
		 * @default 0
		 **/
		this.regX = 0;
	
		/**
		 * The y offset for this display object's registration point. For example, to make a 100x100px Bitmap rotate around
		 * its center, you would set {{#crossLink "DisplayObject/regX:property"}}{{/crossLink}} and regY to 50.
		 * @property regY
		 * @type {Number}
		 * @default 0
		 **/
		this.regY = 0;
	
		/**
		 * The rotation in degrees for this display object.
		 * @property rotation
		 * @type {Number}
		 * @default 0
		 **/
		this.rotation = 0;
	
		/**
		 * The factor to stretch this display object horizontally. For example, setting scaleX to 2 will stretch the display
		 * object to twice its nominal width. To horizontally flip an object, set the scale to a negative number.
		 * @property scaleX
		 * @type {Number}
		 * @default 1
		 **/
		this.scaleX = 1;
	
		/**
		 * The factor to stretch this display object vertically. For example, setting scaleY to 0.5 will stretch the display
		 * object to half its nominal height. To vertically flip an object, set the scale to a negative number.
		 * @property scaleY
		 * @type {Number}
		 * @default 1
		 **/
		this.scaleY = 1;
	
		/**
		 * The factor to skew this display object horizontally.
		 * @property skewX
		 * @type {Number}
		 * @default 0
		 **/
		this.skewX = 0;
	
		/**
		 * The factor to skew this display object vertically.
		 * @property skewY
		 * @type {Number}
		 * @default 0
		 **/
		this.skewY = 0;
	
		/**
		 * A shadow object that defines the shadow to render on this display object. Set to `null` to remove a shadow. If
		 * null, this property is inherited from the parent container.
		 * @property shadow
		 * @type {Shadow}
		 * @default null
		 **/
		this.shadow = null;
	
		/**
		 * Indicates whether this display object should be rendered to the canvas and included when running the Stage
		 * {{#crossLink "Stage/getObjectsUnderPoint"}}{{/crossLink}} method.
		 * @property visible
		 * @type {Boolean}
		 * @default true
		 **/
		this.visible = true;
	
		/**
		 * The x (horizontal) position of the display object, relative to its parent.
		 * @property x
		 * @type {Number}
		 * @default 0
		 **/
		this.x = 0;
	
		/** The y (vertical) position of the display object, relative to its parent.
		 * @property y
		 * @type {Number}
		 * @default 0
		 **/
		this.y = 0;
		
		/**
		 * If set, defines the transformation for this display object, overriding all other transformation properties
		 * (x, y, rotation, scale, skew).
		 * @property transformMatrix
		 * @type {Matrix2D}
		 * @default null
		 **/
		this.transformMatrix = null;
		
		/**
		 * The composite operation indicates how the pixels of this display object will be composited with the elements
		 * behind it. If `null`, this property is inherited from the parent container. For more information, read the
		 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#compositing">
		 * whatwg spec on compositing</a>.
		 * @property compositeOperation
		 * @type {String}
		 * @default null
		 **/
		this.compositeOperation = null;
	
		/**
		 * Indicates whether the display object should be drawn to a whole pixel when
		 * {{#crossLink "Stage/snapToPixelEnabled"}}{{/crossLink}} is true. To enable/disable snapping on whole
		 * categories of display objects, set this value on the prototype (Ex. Text.prototype.snapToPixel = true).
		 * @property snapToPixel
		 * @type {Boolean}
		 * @default true
		 **/
		this.snapToPixel = true;
	
		/**
		 * An array of Filter objects to apply to this display object. Filters are only applied / updated when {{#crossLink "cache"}}{{/crossLink}}
		 * or {{#crossLink "updateCache"}}{{/crossLink}} is called on the display object, and only apply to the area that is
		 * cached.
		 * @property filters
		 * @type {Array}
		 * @default null
		 **/
		this.filters = null;
		
		/**
		 * A Shape instance that defines a vector mask (clipping path) for this display object.  The shape's transformation
		 * will be applied relative to the display object's parent coordinates (as if it were a child of the parent).
		 * @property mask
		 * @type {Shape}
		 * @default null
		 */
		this.mask = null;
		
		/**
		 * A display object that will be tested when checking mouse interactions or testing {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}}.
		 * The hit area will have its transformation applied relative to this display object's coordinate space (as though
		 * the hit test object were a child of this display object and relative to its regX/Y). The hitArea will be tested
		 * using only its own `alpha` value regardless of the alpha value on the target display object, or the target's
		 * ancestors (parents).
		 * 
		 * If set on a {{#crossLink "Container"}}{{/crossLink}}, children of the Container will not receive mouse events.
		 * This is similar to setting {{#crossLink "mouseChildren"}}{{/crossLink}} to false.
		 *
		 * Note that hitArea is NOT currently used by the `hitTest()` method, nor is it supported for {{#crossLink "Stage"}}{{/crossLink}}.
		 * @property hitArea
		 * @type {DisplayObject}
		 * @default null
		 */
		this.hitArea = null;
		
		/**
		 * A CSS cursor (ex. "pointer", "help", "text", etc) that will be displayed when the user hovers over this display
		 * object. You must enable mouseover events using the {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}} method to
		 * use this property. Setting a non-null cursor on a Container will override the cursor set on its descendants.
		 * @property cursor
		 * @type {String}
		 * @default null
		 */
		this.cursor = null;
	
	
	// private properties:
		/**
		 * @property _cacheOffsetX
		 * @protected
		 * @type {Number}
		 * @default 0
		 **/
		this._cacheOffsetX = 0;
	
		/**
		 * @property _cacheOffsetY
		 * @protected
		 * @type {Number}
		 * @default 0
		 **/
		this._cacheOffsetY = 0;
		
		/**
		 * @property _filterOffsetX
		 * @protected
		 * @type {Number}
		 * @default 0
		 **/
		this._filterOffsetX = 0;
		
		/**
		 * @property _filterOffsetY
		 * @protected
		 * @type {Number}
		 * @default 0
		 **/
		this._filterOffsetY = 0;
		
		/**
		 * @property _cacheScale
		 * @protected
		 * @type {Number}
		 * @default 1
		 **/
		this._cacheScale = 1;
	
		/**
		* @property _cacheDataURLID
		* @protected
		* @type {Number}
		* @default 0
		*/
		this._cacheDataURLID = 0;
		
		/**
		* @property _cacheDataURL
		* @protected
		* @type {String}
		* @default null
		*/
		this._cacheDataURL = null;
	
		/**
		 * @property _props
		 * @protected
		 * @type {DisplayObject}
		 * @default null
		 **/
		this._props = new createjs.DisplayProps();
	
		/**
		 * @property _rectangle
		 * @protected
		 * @type {Rectangle}
		 * @default null
		 **/
		this._rectangle = new createjs.Rectangle();
	
		/**
		 * @property _bounds
		 * @protected
		 * @type {Rectangle}
		 * @default null
		 **/
		this._bounds = null;
	}
	var p = createjs.extend(DisplayObject, createjs.EventDispatcher);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	
// static properties:
	/**
	 * Listing of mouse event names. Used in _hasMouseEventListener.
	 * @property _MOUSE_EVENTS
	 * @protected
	 * @static
	 * @type {Array}
	 **/
	DisplayObject._MOUSE_EVENTS = ["click","dblclick","mousedown","mouseout","mouseover","pressmove","pressup","rollout","rollover"];

	/**
	 * Suppresses errors generated when using features like hitTest, mouse events, and {{#crossLink "getObjectsUnderPoint"}}{{/crossLink}}
	 * with cross domain content.
	 * @property suppressCrossDomainErrors
	 * @static
	 * @type {Boolean}
	 * @default false
	 **/
	DisplayObject.suppressCrossDomainErrors = false;
	
	/**
	 * @property _snapToPixelEnabled
	 * @protected
	 * @static
	 * @type {Boolean}
	 * @default false
	 **/
	DisplayObject._snapToPixelEnabled = false; // stage.snapToPixelEnabled is temporarily copied here during a draw to provide global access.

	/**
	 * @property _hitTestCanvas
	 * @type {HTMLCanvasElement | Object}
	 * @static
	 * @protected
	 **/
	/**
	 * @property _hitTestContext
	 * @type {CanvasRenderingContext2D}
	 * @static
	 * @protected
	 **/
	var canvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"); // prevent errors on load in browsers without canvas.
	if (canvas.getContext) {
		DisplayObject._hitTestCanvas = canvas;
		DisplayObject._hitTestContext = canvas.getContext("2d");
		canvas.width = canvas.height = 1;
	}

	/**
	 * @property _nextCacheID
	 * @type {Number}
	 * @static
	 * @protected
	 **/
	DisplayObject._nextCacheID = 1;


// events:
	/**
	 * Dispatched when the user presses their left mouse button over the display object. See the 
	 * {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event mousedown
	 * @since 0.6.0
	 */
	 
	/**
	 * Dispatched when the user presses their left mouse button and then releases it while over the display object.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event click
	 * @since 0.6.0
	 */
	 
	/**
	 * Dispatched when the user double clicks their left mouse button over this display object.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event dblclick
	 * @since 0.6.0
	 */
	 
	/**
	 * Dispatched when the user's mouse enters this display object. This event must be enabled using 
	 * {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}. See also {{#crossLink "DisplayObject/rollover:event"}}{{/crossLink}}.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event mouseover
	 * @since 0.6.0
	 */

	/**
	 * Dispatched when the user's mouse leaves this display object. This event must be enabled using 
	 * {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}. See also {{#crossLink "DisplayObject/rollout:event"}}{{/crossLink}}.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event mouseout
	 * @since 0.6.0
	 */
	 
	/**
	 * This event is similar to {{#crossLink "DisplayObject/mouseover:event"}}{{/crossLink}}, with the following
	 * differences: it does not bubble, and it considers {{#crossLink "Container"}}{{/crossLink}} instances as an
	 * aggregate of their content.
	 * 
	 * For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over
	 * shapeA and then directly on to shapeB. With a listener for {{#crossLink "mouseover:event"}}{{/crossLink}} on
	 * myContainer, two events would be received, each targeting a child element:<OL>
	 * <LI>when the mouse enters shapeA (target=shapeA)</LI>
	 * <LI>when the mouse enters shapeB (target=shapeB)</LI>
	 * </OL>
	 * However, with a listener for "rollover" instead, only a single event is received when the mouse first enters
	 * the aggregate myContainer content (target=myContainer).
	 * 
	 * This event must be enabled using {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event rollover
	 * @since 0.7.0
	 */
	 
	/**
	 * This event is similar to {{#crossLink "DisplayObject/mouseout:event"}}{{/crossLink}}, with the following
	 * differences: it does not bubble, and it considers {{#crossLink "Container"}}{{/crossLink}} instances as an
	 * aggregate of their content.
	 * 
	 * For example, myContainer contains two overlapping children: shapeA and shapeB. The user moves their mouse over
	 * shapeA, then directly on to shapeB, then off both. With a listener for {{#crossLink "mouseout:event"}}{{/crossLink}}
	 * on myContainer, two events would be received, each targeting a child element:<OL>
	 * <LI>when the mouse leaves shapeA (target=shapeA)</LI>
	 * <LI>when the mouse leaves shapeB (target=shapeB)</LI>
	 * </OL>
	 * However, with a listener for "rollout" instead, only a single event is received when the mouse leaves
	 * the aggregate myContainer content (target=myContainer).
	 * 
	 * This event must be enabled using {{#crossLink "Stage/enableMouseOver"}}{{/crossLink}}.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event rollout
	 * @since 0.7.0
	 */
	 
	/**
	 * After a {{#crossLink "DisplayObject/mousedown:event"}}{{/crossLink}} occurs on a display object, a pressmove
	 * event will be generated on that object whenever the mouse moves until the mouse press is released. This can be
	 * useful for dragging and similar operations.
	 * @event pressmove
	 * @since 0.7.0
	 */
	 
	/**
	 * After a {{#crossLink "DisplayObject/mousedown:event"}}{{/crossLink}} occurs on a display object, a pressup event
	 * will be generated on that object when that mouse press is released. This can be useful for dragging and similar
	 * operations.
	 * @event pressup
	 * @since 0.7.0
	 */
	 
	/**
	 * Dispatched when the display object is added to a parent container.
	 * @event added
	 */
	 
	/**
	 * Dispatched when the display object is removed from its parent container.
	 * @event removed
	 */
	 
	/**
	 * Dispatched on each display object on a stage whenever the stage updates. This occurs immediately before the
	 * rendering (draw) pass. When {{#crossLink "Stage/update"}}{{/crossLink}} is called, first all display objects on
	 * the stage dispatch the tick event, then all of the display objects are drawn to stage. Children will have their
	 * {{#crossLink "tick:event"}}{{/crossLink}} event dispatched in order of their depth prior to the event being
	 * dispatched on their parent.
	 * @event tick
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Array} params An array containing any arguments that were passed to the Stage.update() method. For
	 *      example if you called stage.update("hello"), then the params would be ["hello"].
	 * @since 0.6.0
	 */
	
	
// getter / setters:
	/**
	 * Use the {{#crossLink "DisplayObject/stage:property"}}{{/crossLink}} property instead.
	 * @method getStage
	 * @return {Stage}
	 * @deprecated
	 **/
	p.getStage = function() {
		// uses dynamic access to avoid circular dependencies;
		var o = this, _Stage = createjs["Stage"];
		while (o.parent) { o = o.parent; }
		if (o instanceof _Stage) { return o; }
		return null;
	};

	/**
	 * Returns the Stage instance that this display object will be rendered on, or null if it has not been added to one.
	 * @property stage
	 * @type {Stage}
	 * @readonly
	 **/
	try {
		Object.defineProperties(p, {
			stage: { get: p.getStage }
		});
	} catch (e) {}


// public methods:
	/**
	 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
	 **/
	p.isVisible = function() {
		return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0);
	};

	/**
	 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
	 * Returns <code>true</code> if the draw was handled (useful for overriding functionality).
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,
	 * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).
	 * @return {Boolean}
	 **/
	p.draw = function(ctx, ignoreCache) {
		var cacheCanvas = this.cacheCanvas;
		if (ignoreCache || !cacheCanvas) { return false; }
		var scale = this._cacheScale;
		ctx.drawImage(cacheCanvas, this._cacheOffsetX+this._filterOffsetX, this._cacheOffsetY+this._filterOffsetY, cacheCanvas.width/scale, cacheCanvas.height/scale);
		return true;
	};
	
	/**
	 * Applies this display object's transformation, alpha, globalCompositeOperation, clipping path (mask), and shadow
	 * to the specified context. This is typically called prior to {{#crossLink "DisplayObject/draw"}}{{/crossLink}}.
	 * @method updateContext
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D to update.
	 **/
	p.updateContext = function(ctx) {
		var o=this, mask=o.mask, mtx= o._props.matrix;
		
		if (mask && mask.graphics && !mask.graphics.isEmpty()) {
			mask.getMatrix(mtx);
			ctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);
			
			mask.graphics.drawAsPath(ctx);
			ctx.clip();
			
			mtx.invert();
			ctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);
		}
		
		this.getMatrix(mtx);
		var tx = mtx.tx, ty = mtx.ty;
		if (DisplayObject._snapToPixelEnabled && o.snapToPixel) {
			tx = tx + (tx < 0 ? -0.5 : 0.5) | 0;
			ty = ty + (ty < 0 ? -0.5 : 0.5) | 0;
		}
		ctx.transform(mtx.a,  mtx.b, mtx.c, mtx.d, tx, ty);
		ctx.globalAlpha *= o.alpha;
		if (o.compositeOperation) { ctx.globalCompositeOperation = o.compositeOperation; }
		if (o.shadow) { this._applyShadow(ctx, o.shadow); }
	};

	/**
	 * Draws the display object into a new canvas, which is then used for subsequent draws. For complex content
	 * that does not change frequently (ex. a Container with many children that do not move, or a complex vector Shape),
	 * this can provide for much faster rendering because the content does not need to be re-rendered each tick. The
	 * cached display object can be moved, rotated, faded, etc freely, however if its content changes, you must
	 * manually update the cache by calling <code>updateCache()</code> or <code>cache()</code> again. You must specify
	 * the cache area via the x, y, w, and h parameters. This defines the rectangle that will be rendered and cached
	 * using this display object's coordinates.
	 *
	 * <h4>Example</h4>
	 * For example if you defined a Shape that drew a circle at 0, 0 with a radius of 25:
	 *
	 *      var shape = new createjs.Shape();
	 *      shape.graphics.beginFill("#ff0000").drawCircle(0, 0, 25);
	 *      myShape.cache(-25, -25, 50, 50);
	 *
	 * Note that filters need to be defined <em>before</em> the cache is applied. Check out the {{#crossLink "Filter"}}{{/crossLink}}
	 * class for more information. Some filters (ex. BlurFilter) will not work as expected in conjunction with the scale param.
	 * 
	 * Usually, the resulting cacheCanvas will have the dimensions width*scale by height*scale, however some filters (ex. BlurFilter)
	 * will add padding to the canvas dimensions.
	 *
	 * @method cache
	 * @param {Number} x The x coordinate origin for the cache region.
	 * @param {Number} y The y coordinate origin for the cache region.
	 * @param {Number} width The width of the cache region.
	 * @param {Number} height The height of the cache region.
	 * @param {Number} [scale=1] The scale at which the cache will be created. For example, if you cache a vector shape using
	 * 	myShape.cache(0,0,100,100,2) then the resulting cacheCanvas will be 200x200 px. This lets you scale and rotate
	 * 	cached elements with greater fidelity. Default is 1.
	 **/
	p.cache = function(x, y, width, height, scale) {
		// draw to canvas.
		scale = scale||1;
		if (!this.cacheCanvas) { this.cacheCanvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"); }
		this._cacheWidth = width;
		this._cacheHeight = height;
		this._cacheOffsetX = x;
		this._cacheOffsetY = y;
		this._cacheScale = scale;
		this.updateCache();
	};

	/**
	 * Redraws the display object to its cache. Calling updateCache without an active cache will throw an error.
	 * If compositeOperation is null the current cache will be cleared prior to drawing. Otherwise the display object
	 * will be drawn over the existing cache using the specified compositeOperation.
	 *
	 * <h4>Example</h4>
	 * Clear the current graphics of a cached shape, draw some new instructions, and then update the cache. The new line
	 * will be drawn on top of the old one.
	 *
	 *      // Not shown: Creating the shape, and caching it.
	 *      shapeInstance.clear();
	 *      shapeInstance.setStrokeStyle(3).beginStroke("#ff0000").moveTo(100, 100).lineTo(200,200);
	 *      shapeInstance.updateCache();
	 *
	 * @method updateCache
	 * @param {String} compositeOperation The compositeOperation to use, or null to clear the cache and redraw it.
	 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#compositing">
	 * whatwg spec on compositing</a>.
	 **/
	p.updateCache = function(compositeOperation) {
		var cacheCanvas = this.cacheCanvas;
		if (!cacheCanvas) { throw "cache() must be called before updateCache()"; }
		var scale = this._cacheScale, offX = this._cacheOffsetX*scale, offY = this._cacheOffsetY*scale;
		var w = this._cacheWidth, h = this._cacheHeight, ctx = cacheCanvas.getContext("2d");
		
		var fBounds = this._getFilterBounds();
		offX += (this._filterOffsetX = fBounds.x);
		offY += (this._filterOffsetY = fBounds.y);
		
		w = Math.ceil(w*scale) + fBounds.width;
		h = Math.ceil(h*scale) + fBounds.height;
		if (w != cacheCanvas.width || h != cacheCanvas.height) {
			// TODO: it would be nice to preserve the content if there is a compositeOperation.
			cacheCanvas.width = w;
			cacheCanvas.height = h;
		} else if (!compositeOperation) {
			ctx.clearRect(0, 0, w+1, h+1);
		}
		
		ctx.save();
		ctx.globalCompositeOperation = compositeOperation;
		ctx.setTransform(scale, 0, 0, scale, -offX, -offY);
		this.draw(ctx, true);
		// TODO: filters and cache scale don't play well together at present.
		this._applyFilters();
		ctx.restore();
		this.cacheID = DisplayObject._nextCacheID++;
	};

	/**
	 * Clears the current cache. See {{#crossLink "DisplayObject/cache"}}{{/crossLink}} for more information.
	 * @method uncache
	 **/
	p.uncache = function() {
		this._cacheDataURL = this.cacheCanvas = null;
		this.cacheID = this._cacheOffsetX = this._cacheOffsetY = this._filterOffsetX = this._filterOffsetY = 0;
		this._cacheScale = 1;
	};
	
	/**
	 * Returns a data URL for the cache, or null if this display object is not cached.
	 * Uses cacheID to ensure a new data URL is not generated if the cache has not changed.
	 * @method getCacheDataURL
	 * @return {String} The image data url for the cache.
	 **/
	p.getCacheDataURL = function() {
		if (!this.cacheCanvas) { return null; }
		if (this.cacheID != this._cacheDataURLID) { this._cacheDataURL = this.cacheCanvas.toDataURL(); }
		return this._cacheDataURL;
	};

	/**
	 * Transforms the specified x and y position from the coordinate space of the display object
	 * to the global (stage) coordinate space. For example, this could be used to position an HTML label
	 * over a specific point on a nested display object. Returns a Point instance with x and y properties
	 * correlating to the transformed coordinates on the stage.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.x = 300;
	 *      displayObject.y = 200;
	 *      stage.addChild(displayObject);
	 *      var point = myDisplayObject.localToGlobal(100, 100);
	 *      // Results in x=400, y=300
	 *
	 * @method localToGlobal
	 * @param {Number} x The x position in the source display object to transform.
	 * @param {Number} y The y position in the source display object to transform.
	 * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. 
	 * @return {Point} A Point instance with x and y properties correlating to the transformed coordinates
	 * on the stage.
	 **/
	p.localToGlobal = function(x, y, pt) {
		return this.getConcatenatedMatrix(this._props.matrix).transformPoint(x,y, pt||new createjs.Point());
	};

	/**
	 * Transforms the specified x and y position from the global (stage) coordinate space to the
	 * coordinate space of the display object. For example, this could be used to determine
	 * the current mouse position within the display object. Returns a Point instance with x and y properties
	 * correlating to the transformed position in the display object's coordinate space.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.x = 300;
	 *      displayObject.y = 200;
	 *      stage.addChild(displayObject);
	 *      var point = myDisplayObject.globalToLocal(100, 100);
	 *      // Results in x=-200, y=-100
	 *
	 * @method globalToLocal
	 * @param {Number} x The x position on the stage to transform.
	 * @param {Number} y The y position on the stage to transform.
	 * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. 
	 * @return {Point} A Point instance with x and y properties correlating to the transformed position in the
	 * display object's coordinate space.
	 **/
	p.globalToLocal = function(x, y, pt) {
		return this.getConcatenatedMatrix(this._props.matrix).invert().transformPoint(x,y, pt||new createjs.Point());
	};

	/**
	 * Transforms the specified x and y position from the coordinate space of this display object to the coordinate
	 * space of the target display object. Returns a Point instance with x and y properties correlating to the
	 * transformed position in the target's coordinate space. Effectively the same as using the following code with
	 * {{#crossLink "DisplayObject/localToGlobal"}}{{/crossLink}} and {{#crossLink "DisplayObject/globalToLocal"}}{{/crossLink}}.
	 *
	 *      var pt = this.localToGlobal(x, y);
	 *      pt = target.globalToLocal(pt.x, pt.y);
	 *
	 * @method localToLocal
	 * @param {Number} x The x position in the source display object to transform.
	 * @param {Number} y The y position on the source display object to transform.
	 * @param {DisplayObject} target The target display object to which the coordinates will be transformed.
	 * @param {Point | Object} [pt] An object to copy the result into. If omitted a new Point object with x/y properties will be returned. 
	 * @return {Point} Returns a Point instance with x and y properties correlating to the transformed position
	 * in the target's coordinate space.
	 **/
	p.localToLocal = function(x, y, target, pt) {
		pt = this.localToGlobal(x, y, pt);
		return target.globalToLocal(pt.x, pt.y, pt);
	};

	/**
	 * Shortcut method to quickly set the transform properties on the display object. All parameters are optional.
	 * Omitted parameters will have the default value set.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.setTransform(100, 100, 2, 2);
	 *
	 * @method setTransform
	 * @param {Number} [x=0] The horizontal translation (x position) in pixels
	 * @param {Number} [y=0] The vertical translation (y position) in pixels
	 * @param {Number} [scaleX=1] The horizontal scale, as a percentage of 1
	 * @param {Number} [scaleY=1] the vertical scale, as a percentage of 1
	 * @param {Number} [rotation=0] The rotation, in degrees
	 * @param {Number} [skewX=0] The horizontal skew factor
	 * @param {Number} [skewY=0] The vertical skew factor
	 * @param {Number} [regX=0] The horizontal registration point in pixels
	 * @param {Number} [regY=0] The vertical registration point in pixels
	 * @return {DisplayObject} Returns this instance. Useful for chaining commands.
	 * @chainable
	*/
	p.setTransform = function(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {
		this.x = x || 0;
		this.y = y || 0;
		this.scaleX = scaleX == null ? 1 : scaleX;
		this.scaleY = scaleY == null ? 1 : scaleY;
		this.rotation = rotation || 0;
		this.skewX = skewX || 0;
		this.skewY = skewY || 0;
		this.regX = regX || 0;
		this.regY = regY || 0;
		return this;
	};
	
	/**
	 * Returns a matrix based on this object's current transform.
	 * @method getMatrix
	 * @param {Matrix2D} matrix Optional. A Matrix2D object to populate with the calculated values. If null, a new
	 * Matrix object is returned.
	 * @return {Matrix2D} A matrix representing this display object's transform.
	 **/
	p.getMatrix = function(matrix) {
		var o = this, mtx = matrix&&matrix.identity() || new createjs.Matrix2D();
		return o.transformMatrix ?  mtx.copy(o.transformMatrix) : mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);
	};
	
	/**
	 * Generates a Matrix2D object representing the combined transform of the display object and all of its
	 * parent Containers up to the highest level ancestor (usually the {{#crossLink "Stage"}}{{/crossLink}}). This can
	 * be used to transform positions between coordinate spaces, such as with {{#crossLink "DisplayObject/localToGlobal"}}{{/crossLink}}
	 * and {{#crossLink "DisplayObject/globalToLocal"}}{{/crossLink}}.
	 * @method getConcatenatedMatrix
	 * @param {Matrix2D} [matrix] A {{#crossLink "Matrix2D"}}{{/crossLink}} object to populate with the calculated values.
	 * If null, a new Matrix2D object is returned.
	 * @return {Matrix2D} The combined matrix.
	 **/
	p.getConcatenatedMatrix = function(matrix) {
		var o = this, mtx = this.getMatrix(matrix);
		while (o = o.parent) {
			mtx.prependMatrix(o.getMatrix(o._props.matrix));
		}
		return mtx;
	};
	
	/**
	 * Generates a DisplayProps object representing the combined display properties of the  object and all of its
	 * parent Containers up to the highest level ancestor (usually the {{#crossLink "Stage"}}{{/crossLink}}).
	 * @method getConcatenatedDisplayProps
	 * @param {DisplayProps} [props] A {{#crossLink "DisplayProps"}}{{/crossLink}} object to populate with the calculated values.
	 * If null, a new DisplayProps object is returned.
	 * @return {DisplayProps} The combined display properties.
	 **/
	p.getConcatenatedDisplayProps = function(props) {
		props = props ? props.identity() : new createjs.DisplayProps();
		var o = this, mtx = o.getMatrix(props.matrix); 
		do {
			props.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation);
			
			// we do this to avoid problems with the matrix being used for both operations when o._props.matrix is passed in as the props param.
			// this could be simplified (ie. just done as part of the prepend above) if we switched to using a pool.
			if (o != this) { mtx.prependMatrix(o.getMatrix(o._props.matrix)); }
		} while (o = o.parent);
		return props;
	};

	/**
	 * Tests whether the display object intersects the specified point in local coordinates (ie. draws a pixel with alpha > 0 at
	 * the specified position). This ignores the alpha, shadow, hitArea, mask, and compositeOperation of the display object.
	 *
	 * <h4>Example</h4>
	 *
	 *      stage.addEventListener("stagemousedown", handleMouseDown);
	 *      function handleMouseDown(event) {
	 *          var hit = myShape.hitTest(event.stageX, event.stageY);
	 *      }
	 *
	 * Please note that shape-to-shape collision is not currently supported by EaselJS.
	 * @method hitTest
	 * @param {Number} x The x position to check in the display object's local coordinates.
	 * @param {Number} y The y position to check in the display object's local coordinates.
	 * @return {Boolean} A Boolean indicating whether a visible portion of the DisplayObject intersect the specified
	 * local Point.
	*/
	p.hitTest = function(x, y) {
		var ctx = DisplayObject._hitTestContext;
		ctx.setTransform(1, 0, 0, 1, -x, -y);
		this.draw(ctx);

		var hit = this._testHit(ctx);
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		ctx.clearRect(0, 0, 2, 2);
		return hit;
	};
	
	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * <h4>Example</h4>
	 *
	 *      var myGraphics = new createjs.Graphics().beginFill("#ff0000").drawCircle(0, 0, 25);
	 *      var shape = stage.addChild(new Shape()).set({graphics:myGraphics, x:100, y:100, alpha:0.5});
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the DisplayObject instance.
	 * @return {DisplayObject} Returns the instance the method is called on (useful for chaining calls.)
	 * @chainable
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};
	
	/**
	 * Returns a rectangle representing this object's bounds in its local coordinate system (ie. with no transformation).
	 * Objects that have been cached will return the bounds of the cache.
	 * 
	 * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use 
	 * {{#crossLink "DisplayObject/setBounds"}}{{/crossLink}} so that they are included when calculating Container
	 * bounds.
	 * 
	 * <table>
	 * 	<tr><td><b>All</b></td><td>
	 * 		All display objects support setting bounds manually using setBounds(). Likewise, display objects that
	 * 		have been cached using cache() will return the bounds of their cache. Manual and cache bounds will override
	 * 		the automatic calculations listed below.
	 * 	</td></tr>
	 * 	<tr><td><b>Bitmap</b></td><td>
	 * 		Returns the width and height of the sourceRect (if specified) or image, extending from (x=0,y=0).
	 * 	</td></tr>
	 * 	<tr><td><b>Sprite</b></td><td>
	 * 		Returns the bounds of the current frame. May have non-zero x/y if a frame registration point was specified
	 * 		in the spritesheet data. See also {{#crossLink "SpriteSheet/getFrameBounds"}}{{/crossLink}}
	 * 	</td></tr>
	 * 	<tr><td><b>Container</b></td><td>
	 * 		Returns the aggregate (combined) bounds of all children that return a non-null value from getBounds().
	 * 	</td></tr>
	 * 	<tr><td><b>Shape</b></td><td>
	 * 		Does not currently support automatic bounds calculations. Use setBounds() to manually define bounds.
	 * 	</td></tr>
	 * 	<tr><td><b>Text</b></td><td>
	 * 		Returns approximate bounds. Horizontal values (x/width) are quite accurate, but vertical values (y/height) are
	 * 		not, especially when using textBaseline values other than "top".
	 * 	</td></tr>
	 * 	<tr><td><b>BitmapText</b></td><td>
	 * 		Returns approximate bounds. Values will be more accurate if spritesheet frame registration points are close
	 * 		to (x=0,y=0).
	 * 	</td></tr>
	* </table>
	 * 
	 * Bounds can be expensive to calculate for some objects (ex. text, or containers with many children), and
	 * are recalculated each time you call getBounds(). You can prevent recalculation on static objects by setting the
	 * bounds explicitly:
	 * 
	 * 	var bounds = obj.getBounds();
	 * 	obj.setBounds(bounds.x, bounds.y, bounds.width, bounds.height);
	 * 	// getBounds will now use the set values, instead of recalculating
	 * 
	 * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its
	 * values if you need to retain it.
	 * 
	 * 	var myBounds = obj.getBounds().clone();
	 * 	// OR:
	 * 	myRect.copy(obj.getBounds());
	 * 
	 * @method getBounds
	 * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this
	 * object.
	 **/
	p.getBounds = function() {
		if (this._bounds) { return this._rectangle.copy(this._bounds); }
		var cacheCanvas = this.cacheCanvas;
		if (cacheCanvas) {
			var scale = this._cacheScale;
			return this._rectangle.setValues(this._cacheOffsetX, this._cacheOffsetY, cacheCanvas.width/scale, cacheCanvas.height/scale);
		}
		return null;
	};
	
	/**
	 * Returns a rectangle representing this object's bounds in its parent's coordinate system (ie. with transformations applied).
	 * Objects that have been cached will return the transformed bounds of the cache.
	 * 
	 * Not all display objects can calculate their own bounds (ex. Shape). For these objects, you can use 
	 * {{#crossLink "DisplayObject/setBounds"}}{{/crossLink}} so that they are included when calculating Container
	 * bounds.
	 * 
	 * To reduce memory impact, the returned Rectangle instance may be reused internally; clone the instance or copy its
	 * values if you need to retain it.
	 * 
	 * Container instances calculate aggregate bounds for all children that return bounds via getBounds.
	 * @method getTransformedBounds
	 * @return {Rectangle} A Rectangle instance representing the bounds, or null if bounds are not available for this object.
	 **/
	p.getTransformedBounds = function() {
		return this._getBounds();
	};
	
	/**
	 * Allows you to manually specify the bounds of an object that either cannot calculate their own bounds (ex. Shape &
	 * Text) for future reference, or so the object can be included in Container bounds. Manually set bounds will always
	 * override calculated bounds.
	 * 
	 * The bounds should be specified in the object's local (untransformed) coordinates. For example, a Shape instance
	 * with a 25px radius circle centered at 0,0 would have bounds of (-25, -25, 50, 50).
	 * @method setBounds
	 * @param {Number} x The x origin of the bounds. Pass null to remove the manual bounds.
	 * @param {Number} y The y origin of the bounds.
	 * @param {Number} width The width of the bounds.
	 * @param {Number} height The height of the bounds.
	 **/
	p.setBounds = function(x, y, width, height) {
		if (x == null) { this._bounds = x; }
		this._bounds = (this._bounds || new createjs.Rectangle()).setValues(x, y, width, height);
	};

	/**
	 * Returns a clone of this DisplayObject. Some properties that are specific to this instance's current context are
	 * reverted to their defaults (for example .parent). Caches are not maintained across clones, and some elements
	 * are copied by reference (masks, individual filter instances, hit area)
	 * @method clone
	 * @return {DisplayObject} A clone of the current DisplayObject instance.
	 **/
	p.clone = function() {
		return this._cloneProps(new DisplayObject());
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[DisplayObject (name="+  this.name +")]";
	};


// private methods:
	// separated so it can be used more easily in subclasses:
	/**
	 * @method _cloneProps
	 * @param {DisplayObject} o The DisplayObject instance which will have properties from the current DisplayObject
	 * instance copied into.
	 * @return {DisplayObject} o
	 * @protected
	 **/
	p._cloneProps = function(o) {
		o.alpha = this.alpha;
		o.mouseEnabled = this.mouseEnabled;
		o.tickEnabled = this.tickEnabled;
		o.name = this.name;
		o.regX = this.regX;
		o.regY = this.regY;
		o.rotation = this.rotation;
		o.scaleX = this.scaleX;
		o.scaleY = this.scaleY;
		o.shadow = this.shadow;
		o.skewX = this.skewX;
		o.skewY = this.skewY;
		o.visible = this.visible;
		o.x  = this.x;
		o.y = this.y;
		o.compositeOperation = this.compositeOperation;
		o.snapToPixel = this.snapToPixel;
		o.filters = this.filters==null?null:this.filters.slice(0);
		o.mask = this.mask;
		o.hitArea = this.hitArea;
		o.cursor = this.cursor;
		o._bounds = this._bounds;
		return o;
	};

	/**
	 * @method _applyShadow
	 * @protected
	 * @param {CanvasRenderingContext2D} ctx
	 * @param {Shadow} shadow
	 **/
	p._applyShadow = function(ctx, shadow) {
		shadow = shadow || Shadow.identity;
		ctx.shadowColor = shadow.color;
		ctx.shadowOffsetX = shadow.offsetX;
		ctx.shadowOffsetY = shadow.offsetY;
		ctx.shadowBlur = shadow.blur;
	};
	
	
	/**
	 * @method _tick
	 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
	 * @protected
	 **/
	p._tick = function(evtObj) {
		// because tick can be really performance sensitive, check for listeners before calling dispatchEvent.
		var ls = this._listeners;
		if (ls && ls["tick"]) {
			// reset & reuse the event object to avoid construction / GC costs:
			evtObj.target = null;
			evtObj.propagationStopped = evtObj.immediatePropagationStopped = false;
			this.dispatchEvent(evtObj);
		}
	};

	/**
	 * @method _testHit
	 * @protected
	 * @param {CanvasRenderingContext2D} ctx
	 * @return {Boolean}
	 **/
	p._testHit = function(ctx) {
		try {
			var hit = ctx.getImageData(0, 0, 1, 1).data[3] > 1;
		} catch (e) {
			if (!DisplayObject.suppressCrossDomainErrors) {
				throw "An error has occurred. This is most likely due to security restrictions on reading canvas pixel data with local or cross-domain images.";
			}
		}
		return hit;
	};

	/**
	 * @method _applyFilters
	 * @protected
	 **/
	p._applyFilters = function() {
		if (!this.filters || this.filters.length == 0 || !this.cacheCanvas) { return; }
		var l = this.filters.length;
		var ctx = this.cacheCanvas.getContext("2d");
		var w = this.cacheCanvas.width;
		var h = this.cacheCanvas.height;
		for (var i=0; i<l; i++) {
			this.filters[i].applyFilter(ctx, 0, 0, w, h);
		}
	};
	
	/**
	 * @method _getFilterBounds
	 * @return {Rectangle}
	 * @protected
	 **/
	p._getFilterBounds = function(rect) {
		var l, filters = this.filters, bounds = this._rectangle.setValues(0,0,0,0);
		if (!filters || !(l=filters.length)) { return bounds; }
		
		for (var i=0; i<l; i++) {
			var f = this.filters[i];
			f.getBounds&&f.getBounds(bounds);
		}
		return bounds;
	};
	
	/**
	 * @method _getBounds
	 * @param {Matrix2D} matrix
	 * @param {Boolean} ignoreTransform If true, does not apply this object's transform.
	 * @return {Rectangle}
	 * @protected
	 **/
	p._getBounds = function(matrix, ignoreTransform){
		return this._transformBounds(this.getBounds(), matrix, ignoreTransform);
	};
	
	/**
	 * @method _transformBounds
	 * @param {Rectangle} bounds
	 * @param {Matrix2D} matrix
	 * @param {Boolean} ignoreTransform
	 * @return {Rectangle}
	 * @protected
	 **/
	p._transformBounds = function(bounds, matrix, ignoreTransform) {
		if (!bounds) { return bounds; }
		var x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height, mtx = this._props.matrix;
		mtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);
		
		if (x || y) { mtx.appendTransform(0,0,1,1,0,0,0,-x,-y); } // TODO: simplify this.
		if (matrix) { mtx.prependMatrix(matrix); }
		
		var x_a = width*mtx.a, x_b = width*mtx.b;
		var y_c = height*mtx.c, y_d = height*mtx.d;
		var tx = mtx.tx, ty = mtx.ty;
		
		var minX = tx, maxX = tx, minY = ty, maxY = ty;

		if ((x = x_a + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }
		if ((x = x_a + y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }
		if ((x = y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }
		
		if ((y = x_b + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }
		if ((y = x_b + y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }
		if ((y = y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }
		
		return bounds.setValues(minX, minY, maxX-minX, maxY-minY);
	};
	
	/**
	 * Indicates whether the display object has any mouse event listeners or a cursor.
	 * @method _isMouseOpaque
	 * @return {Boolean}
	 * @protected
	 **/
	p._hasMouseEventListener = function() {
		var evts = DisplayObject._MOUSE_EVENTS;
		for (var i= 0, l=evts.length; i<l; i++) {
			if (this.hasEventListener(evts[i])) { return true; }
		}
		return !!this.cursor;
	};

	createjs.DisplayObject = createjs.promote(DisplayObject, "EventDispatcher");
}());

//##############################################################################
// Container.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";
	

// constructor:
/**
 * A Container is a nestable display list that allows you to work with compound display elements. For  example you could
 * group arm, leg, torso and head {{#crossLink "Bitmap"}}{{/crossLink}} instances together into a Person Container, and
 * transform them as a group, while still being able to move the individual parts relative to each other. Children of
 * containers have their <code>transform</code> and <code>alpha</code> properties concatenated with their parent
 * Container.
 *
 * For example, a {{#crossLink "Shape"}}{{/crossLink}} with x=100 and alpha=0.5, placed in a Container with <code>x=50</code>
 * and <code>alpha=0.7</code> will be rendered to the canvas at <code>x=150</code> and <code>alpha=0.35</code>.
 * Containers have some overhead, so you generally shouldn't create a Container to hold a single child.
 *
 * <h4>Example</h4>
 *
 *      var container = new createjs.Container();
 *      container.addChild(bitmapInstance, shapeInstance);
 *      container.x = 100;
 *
 * @class Container
 * @extends DisplayObject
 * @constructor
 **/
	function Container() {
		this.DisplayObject_constructor();
		
	// public properties:
		/**
		 * The array of children in the display list. You should usually use the child management methods such as
		 * {{#crossLink "Container/addChild"}}{{/crossLink}}, {{#crossLink "Container/removeChild"}}{{/crossLink}},
		 * {{#crossLink "Container/swapChildren"}}{{/crossLink}}, etc, rather than accessing this directly, but it is
		 * included for advanced uses.
		 * @property children
		 * @type Array
		 * @default null
		 **/
		this.children = [];
		
		/**
		 * Indicates whether the children of this container are independently enabled for mouse/pointer interaction.
		 * If false, the children will be aggregated under the container - for example, a click on a child shape would
		 * trigger a click event on the container.
		 * @property mouseChildren
		 * @type Boolean
		 * @default true
		 **/
		this.mouseChildren = true;
		
		/**
		 * If false, the tick will not be propagated to children of this Container. This can provide some performance benefits.
		 * In addition to preventing the "tick" event from being dispatched, it will also prevent tick related updates
		 * on some display objects (ex. Sprite & MovieClip frame advancing, DOMElement visibility handling).
		 * @property tickChildren
		 * @type Boolean
		 * @default true
		 **/
		this.tickChildren = true;
	}
	var p = createjs.extend(Container, createjs.DisplayObject);
	
	
// getter / setters:
	/**
	 * Use the {{#crossLink "Container/numChildren:property"}}{{/crossLink}} property instead.
	 * @method getNumChildren
	 * @return {Number}
	 * @deprecated
	 **/
	p.getNumChildren = function() {
		return this.children.length;
	};

	/**
	 * Returns the number of children in the container.
	 * @property numChildren
	 * @type {Number}
	 * @readonly
	 **/
	try {
		Object.defineProperties(p, {
			numChildren: { get: p.getNumChildren }
		});
	} catch (e) {}
	

// public methods:
	/**
	 * Constructor alias for backwards compatibility. This method will be removed in future versions.
	 * Subclasses should be updated to use {{#crossLink "Utility Methods/extends"}}{{/crossLink}}.
	 * @method initialize
	 * @deprecated in favour of `createjs.promote()`
	 **/
	p.initialize = Container; // TODO: deprecated.
	
	/**
	 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
	 **/
	p.isVisible = function() {
		var hasContent = this.cacheCanvas || this.children.length;
		return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
	};

	/**
	 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
	 * Returns true if the draw was handled (useful for overriding functionality).
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache.
	 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
	 * into itself).
	 **/
	p.draw = function(ctx, ignoreCache) {
		if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
		
		// this ensures we don't have issues with display list changes that occur during a draw:
		var list = this.children.slice();
		for (var i=0,l=list.length; i<l; i++) {
			var child = list[i];
			if (!child.isVisible()) { continue; }
			
			// draw the child:
			ctx.save();
			child.updateContext(ctx);
			child.draw(ctx);
			ctx.restore();
		}
		return true;
	};
	
	/**
	 * Adds a child to the top of the display list.
	 *
	 * <h4>Example</h4>
	 *
	 * 		container.addChild(bitmapInstance);
	 *
	 * You can also add multiple children at once:
	 *
	 * 		container.addChild(bitmapInstance, shapeInstance, textInstance);
	 *
	 * @method addChild
	 * @param {DisplayObject} child The display object to add.
	 * @return {DisplayObject} The child that was added, or the last child if multiple children were added.
	 **/
	p.addChild = function(child) {
		if (child == null) { return child; }
		var l = arguments.length;
		if (l > 1) {
			for (var i=0; i<l; i++) { this.addChild(arguments[i]); }
			return arguments[l-1];
		}
		if (child.parent) { child.parent.removeChild(child); }
		child.parent = this;
		this.children.push(child);
		child.dispatchEvent("added");
		return child;
	};

	/**
	 * Adds a child to the display list at the specified index, bumping children at equal or greater indexes up one, and
	 * setting its parent to this Container.
	 *
	 * <h4>Example</h4>
	 *
	 *      addChildAt(child1, index);
	 *
	 * You can also add multiple children, such as:
	 *
	 *      addChildAt(child1, child2, ..., index);
	 *
	 * The index must be between 0 and numChildren. For example, to add myShape under otherShape in the display list,
	 * you could use:
	 *
	 *      container.addChildAt(myShape, container.getChildIndex(otherShape));
	 *
	 * This would also bump otherShape's index up by one. Fails silently if the index is out of range.
	 *
	 * @method addChildAt
	 * @param {DisplayObject} child The display object to add.
	 * @param {Number} index The index to add the child at.
	 * @return {DisplayObject} Returns the last child that was added, or the last child if multiple children were added.
	 **/
	p.addChildAt = function(child, index) {
		var l = arguments.length;
		var indx = arguments[l-1]; // can't use the same name as the index param or it replaces arguments[1]
		if (indx < 0 || indx > this.children.length) { return arguments[l-2]; }
		if (l > 2) {
			for (var i=0; i<l-1; i++) { this.addChildAt(arguments[i], indx+i); }
			return arguments[l-2];
		}
		if (child.parent) { child.parent.removeChild(child); }
		child.parent = this;
		this.children.splice(index, 0, child);
		child.dispatchEvent("added");
		return child;
	};

	/**
	 * Removes the specified child from the display list. Note that it is faster to use removeChildAt() if the index is
	 * already known.
	 *
	 * <h4>Example</h4>
	 *
	 *      container.removeChild(child);
	 *
	 * You can also remove multiple children:
	 *
	 *      removeChild(child1, child2, ...);
	 *
	 * Returns true if the child (or children) was removed, or false if it was not in the display list.
	 * @method removeChild
	 * @param {DisplayObject} child The child to remove.
	 * @return {Boolean} true if the child (or children) was removed, or false if it was not in the display list.
	 **/
	p.removeChild = function(child) {
		var l = arguments.length;
		if (l > 1) {
			var good = true;
			for (var i=0; i<l; i++) { good = good && this.removeChild(arguments[i]); }
			return good;
		}
		return this.removeChildAt(createjs.indexOf(this.children, child));
	};

	/**
	 * Removes the child at the specified index from the display list, and sets its parent to null.
	 *
	 * <h4>Example</h4>
	 *
	 *      container.removeChildAt(2);
	 *
	 * You can also remove multiple children:
	 *
	 *      container.removeChild(2, 7, ...)
	 *
	 * Returns true if the child (or children) was removed, or false if any index was out of range.
	 * @method removeChildAt
	 * @param {Number} index The index of the child to remove.
	 * @return {Boolean} true if the child (or children) was removed, or false if any index was out of range.
	 **/
	p.removeChildAt = function(index) {
		var l = arguments.length;
		if (l > 1) {
			var a = [];
			for (var i=0; i<l; i++) { a[i] = arguments[i]; }
			a.sort(function(a, b) { return b-a; });
			var good = true;
			for (var i=0; i<l; i++) { good = good && this.removeChildAt(a[i]); }
			return good;
		}
		if (index < 0 || index > this.children.length-1) { return false; }
		var child = this.children[index];
		if (child) { child.parent = null; }
		this.children.splice(index, 1);
		child.dispatchEvent("removed");
		return true;
	};

	/**
	 * Removes all children from the display list.
	 *
	 * <h4>Example</h4>
	 *
	 * 	container.removeAllChildren();
	 *
	 * @method removeAllChildren
	 **/
	p.removeAllChildren = function() {
		var kids = this.children;
		while (kids.length) { this.removeChildAt(0); }
	};

	/**
	 * Returns the child at the specified index.
	 *
	 * <h4>Example</h4>
	 *
	 *      container.getChildAt(2);
	 *
	 * @method getChildAt
	 * @param {Number} index The index of the child to return.
	 * @return {DisplayObject} The child at the specified index. Returns null if there is no child at the index.
	 **/
	p.getChildAt = function(index) {
		return this.children[index];
	};
	
	/**
	 * Returns the child with the specified name.
	 * @method getChildByName
	 * @param {String} name The name of the child to return.
	 * @return {DisplayObject} The child with the specified name.
	 **/
	p.getChildByName = function(name) {
		var kids = this.children;
		for (var i=0,l=kids.length;i<l;i++) {
			if(kids[i].name == name) { return kids[i]; }
		}
		return null;
	};

	/**
	 * Performs an array sort operation on the child list.
	 *
	 * <h4>Example: Display children with a higher y in front.</h4>
	 * 
	 *      var sortFunction = function(obj1, obj2, options) {
	 *          if (obj1.y > obj2.y) { return 1; }
	 *          if (obj1.y < obj2.y) { return -1; }
	 *          return 0;
	 *      }
	 *      container.sortChildren(sortFunction);
	 *
	 * @method sortChildren
	 * @param {Function} sortFunction the function to use to sort the child list. See JavaScript's <code>Array.sort</code>
	 * documentation for details.
	 **/
	p.sortChildren = function(sortFunction) {
		this.children.sort(sortFunction);
	};

	/**
	 * Returns the index of the specified child in the display list, or -1 if it is not in the display list.
	 *
	 * <h4>Example</h4>
	 *
	 *      var index = container.getChildIndex(child);
	 *
	 * @method getChildIndex
	 * @param {DisplayObject} child The child to return the index of.
	 * @return {Number} The index of the specified child. -1 if the child is not found.
	 **/
	p.getChildIndex = function(child) {
		return createjs.indexOf(this.children, child);
	};
	
	/**
	 * Swaps the children at the specified indexes. Fails silently if either index is out of range.
	 * @method swapChildrenAt
	 * @param {Number} index1
	 * @param {Number} index2
	 **/
	p.swapChildrenAt = function(index1, index2) {
		var kids = this.children;
		var o1 = kids[index1];
		var o2 = kids[index2];
		if (!o1 || !o2) { return; }
		kids[index1] = o2;
		kids[index2] = o1;
	};
	
	/**
	 * Swaps the specified children's depth in the display list. Fails silently if either child is not a child of this
	 * Container.
	 * @method swapChildren
	 * @param {DisplayObject} child1
	 * @param {DisplayObject} child2
	 **/
	p.swapChildren = function(child1, child2) {
		var kids = this.children;
		var index1,index2;
		for (var i=0,l=kids.length;i<l;i++) {
			if (kids[i] == child1) { index1 = i; }
			if (kids[i] == child2) { index2 = i; }
			if (index1 != null && index2 != null) { break; }
		}
		if (i==l) { return; } // TODO: throw error?
		kids[index1] = child2;
		kids[index2] = child1;
	};
	
	/**
	 * Changes the depth of the specified child. Fails silently if the child is not a child of this container, or the index is out of range.
	 * @param {DisplayObject} child
	 * @param {Number} index  
	 * @method setChildIndex
	 **/
	p.setChildIndex = function(child, index) {
		var kids = this.children, l=kids.length;
		if (child.parent != this || index < 0 || index >= l) { return; }
		for (var i=0;i<l;i++) {
			if (kids[i] == child) { break; }
		}
		if (i==l || i == index) { return; }
		kids.splice(i,1);
		kids.splice(index,0,child);
	};

	/**
	 * Returns true if the specified display object either is this container or is a descendent (child, grandchild, etc)
	 * of this container.
	 * @method contains
	 * @param {DisplayObject} child The DisplayObject to be checked.
	 * @return {Boolean} true if the specified display object either is this container or is a descendent.
	 **/
	p.contains = function(child) {
		while (child) {
			if (child == this) { return true; }
			child = child.parent;
		}
		return false;
	};

	/**
	 * Tests whether the display object intersects the specified local point (ie. draws a pixel with alpha > 0 at the
	 * specified position). This ignores the alpha, shadow and compositeOperation of the display object, and all
	 * transform properties including regX/Y.
	 * @method hitTest
	 * @param {Number} x The x position to check in the display object's local coordinates.
	 * @param {Number} y The y position to check in the display object's local coordinates.
	 * @return {Boolean} A Boolean indicating whether there is a visible section of a DisplayObject that overlaps the specified
	 * coordinates.
	 **/
	p.hitTest = function(x, y) {
		// TODO: optimize to use the fast cache check where possible.
		return (this.getObjectUnderPoint(x, y) != null);
	};

	/**
	 * Returns an array of all display objects under the specified coordinates that are in this container's display
	 * list. This routine ignores any display objects with {{#crossLink "DisplayObject/mouseEnabled:property"}}{{/crossLink}}
	 * set to `false`. The array will be sorted in order of visual depth, with the top-most display object at index 0.
	 * This uses shape based hit detection, and can be an expensive operation to run, so it is best to use it carefully.
	 * For example, if testing for objects under the mouse, test on tick (instead of on {{#crossLink "DisplayObject/mousemove:event"}}{{/crossLink}}),
	 * and only if the mouse's position has changed.
	 * 
	 * <ul>
	 *     <li>By default (mode=0) this method evaluates all display objects.</li>
	 *     <li>By setting the `mode` parameter to `1`, the {{#crossLink "DisplayObject/mouseEnabled:property"}}{{/crossLink}}
	 * 		and {{#crossLink "mouseChildren:property"}}{{/crossLink}} properties will be respected.</li>
	 * 	   <li>Setting the `mode` to `2` additionally excludes display objects that do not have active mouse event
	 * 	   	listeners or a {{#crossLink "DisplayObject:cursor:property"}}{{/crossLink}} property. That is, only objects
	 * 	   	that would normally intercept mouse interaction will be included. This can significantly improve performance
	 * 	   	in some cases by reducing the number of display objects that need to be tested.</li>
	 * </li>
	 * 
	 * This method accounts for both {{#crossLink "DisplayObject/hitArea:property"}}{{/crossLink}} and {{#crossLink "DisplayObject/mask:property"}}{{/crossLink}}.
	 * @method getObjectsUnderPoint
	 * @param {Number} x The x position in the container to test.
	 * @param {Number} y The y position in the container to test.
	 * @param {Number} [mode=0] The mode to use to determine which display objects to include. 0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.
	 * @return {Array} An Array of DisplayObjects under the specified coordinates.
	 **/
	p.getObjectsUnderPoint = function(x, y, mode) {
		var arr = [];
		var pt = this.localToGlobal(x, y);
		this._getObjectsUnderPoint(pt.x, pt.y, arr, mode>0, mode==1);
		return arr;
	};

	/**
	 * Similar to {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}}, but returns only the top-most display
	 * object. This runs significantly faster than <code>getObjectsUnderPoint()</code>, but is still potentially an expensive
	 * operation. See {{#crossLink "Container/getObjectsUnderPoint"}}{{/crossLink}} for more information.
	 * @method getObjectUnderPoint
	 * @param {Number} x The x position in the container to test.
	 * @param {Number} y The y position in the container to test.
	 * @param {Number} mode The mode to use to determine which display objects to include.  0-all, 1-respect mouseEnabled/mouseChildren, 2-only mouse opaque objects.
	 * @return {DisplayObject} The top-most display object under the specified coordinates.
	 **/
	p.getObjectUnderPoint = function(x, y, mode) {
		var pt = this.localToGlobal(x, y);
		return this._getObjectsUnderPoint(pt.x, pt.y, null, mode>0, mode==1);
	};
	
	/**
	 * Docced in superclass.
	 */
	p.getBounds = function() {
		return this._getBounds(null, true);
	};
	
	
	/**
	 * Docced in superclass.
	 */
	p.getTransformedBounds = function() {
		return this._getBounds();
	};

	/**
	 * Returns a clone of this Container. Some properties that are specific to this instance's current context are
	 * reverted to their defaults (for example .parent).
	 * @method clone
	 * @param {Boolean} [recursive=false] If true, all of the descendants of this container will be cloned recursively. If false, the
	 * properties of the container will be cloned, but the new instance will not have any children.
	 * @return {Container} A clone of the current Container instance.
	 **/
	p.clone = function(recursive) {
		var o = this._cloneProps(new Container());
		if (recursive) { this._cloneChildren(o); }
		return o;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Container (name="+  this.name +")]";
	};


// private methods:
	/**
	 * @method _tick
	 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
	 * @protected
	 **/
	p._tick = function(evtObj) {
		if (this.tickChildren) {
			for (var i=this.children.length-1; i>=0; i--) {
				var child = this.children[i];
				if (child.tickEnabled && child._tick) { child._tick(evtObj); }
			}
		}
		this.DisplayObject__tick(evtObj);
	};
	
	/**
	 * Recursively clones all children of this container, and adds them to the target container.
	 * @method cloneChildren
	 * @protected
	 * @param {Container} o The target container.
	 **/
	p._cloneChildren = function(o) {
		if (o.children.length) { o.removeAllChildren(); }
		var arr = o.children;
		for (var i=0, l=this.children.length; i<l; i++) {
			var clone = this.children[i].clone(true);
			clone.parent = o;
			arr.push(clone);
		}
	};

	/**
	 * @method _getObjectsUnderPoint
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Array} arr
	 * @param {Boolean} mouse If true, it will respect mouse interaction properties like mouseEnabled, mouseChildren, and active listeners.
	 * @param {Boolean} activeListener If true, there is an active mouse event listener on a parent object.
	 * @param {Number} currentDepth Indicates the current depth of the search.
	 * @return {DisplayObject}
	 * @protected
	 **/
	p._getObjectsUnderPoint = function(x, y, arr, mouse, activeListener, currentDepth) {
		currentDepth = currentDepth || 0;
		if (!currentDepth && !this._testMask(this, x, y)) { return null; }
		var mtx, ctx = createjs.DisplayObject._hitTestContext;
		activeListener = activeListener || (mouse&&this._hasMouseEventListener());

		// draw children one at a time, and check if we get a hit:
		var children = this.children, l = children.length;
		for (var i=l-1; i>=0; i--) {
			var child = children[i];
			var hitArea = child.hitArea;
			if (!child.visible || (!hitArea && !child.isVisible()) || (mouse && !child.mouseEnabled)) { continue; }
			if (!hitArea && !this._testMask(child, x, y)) { continue; }
			
			// if a child container has a hitArea then we only need to check its hitArea, so we can treat it as a normal DO:
			if (!hitArea && child instanceof Container) {
				var result = child._getObjectsUnderPoint(x, y, arr, mouse, activeListener, currentDepth+1);
				if (!arr && result) { return (mouse && !this.mouseChildren) ? this : result; }
			} else {
				if (mouse && !activeListener && !child._hasMouseEventListener()) { continue; }
				
				// TODO: can we pass displayProps forward, to avoid having to calculate this backwards every time? It's kind of a mixed bag. When we're only hunting for DOs with event listeners, it may not make sense.
				var props = child.getConcatenatedDisplayProps(child._props);
				mtx = props.matrix;
				
				if (hitArea) {
					mtx.appendMatrix(hitArea.getMatrix(hitArea._props.matrix));
					props.alpha = hitArea.alpha;
				}
				
				ctx.globalAlpha = props.alpha;
				ctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);
				(hitArea||child).draw(ctx);
				if (!this._testHit(ctx)) { continue; }
				ctx.setTransform(1, 0, 0, 1, 0, 0);
				ctx.clearRect(0, 0, 2, 2);
				if (arr) { arr.push(child); }
				else { return (mouse && !this.mouseChildren) ? this : child; }
			}
		}
		return null;
	};
	
	/**
	 * @method _testMask
	 * @param {DisplayObject} target
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Boolean} Indicates whether the x/y is within the masked region.
	 * @protected
	 **/
	p._testMask = function(target, x, y) {
		var mask = target.mask;
		if (!mask || !mask.graphics || mask.graphics.isEmpty()) { return true; }
		
		var mtx = this._props.matrix, parent = target.parent;
		mtx = parent ? parent.getConcatenatedMatrix(mtx) : mtx.identity();
		mtx = mask.getMatrix(mask._props.matrix).prependMatrix(mtx);
		
		var ctx = createjs.DisplayObject._hitTestContext;
		ctx.setTransform(mtx.a,  mtx.b, mtx.c, mtx.d, mtx.tx-x, mtx.ty-y);
		
		// draw the mask as a solid fill:
		mask.graphics.drawAsPath(ctx);
		ctx.fillStyle = "#000";
		ctx.fill();
		
		if (!this._testHit(ctx)) { return false; }
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		ctx.clearRect(0, 0, 2, 2);
		
		return true;
	};
	
	/**
	 * @method _getBounds
	 * @param {Matrix2D} matrix
	 * @param {Boolean} ignoreTransform If true, does not apply this object's transform.
	 * @return {Rectangle}
	 * @protected
	 **/
	p._getBounds = function(matrix, ignoreTransform) {
		var bounds = this.DisplayObject_getBounds();
		if (bounds) { return this._transformBounds(bounds, matrix, ignoreTransform); }
		
		var mtx = this._props.matrix;
		mtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);
		if (matrix) { mtx.prependMatrix(matrix); }
		
		var l = this.children.length, rect=null;
		for (var i=0; i<l; i++) {
			var child = this.children[i];
			if (!child.visible || !(bounds = child._getBounds(mtx))) { continue; }
			if (rect) { rect.extend(bounds.x, bounds.y, bounds.width, bounds.height); }
			else { rect = bounds.clone(); }
		}
		return rect;
	};


	createjs.Container = createjs.promote(Container, "DisplayObject");
}());

//##############################################################################
// Stage.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * A stage is the root level {{#crossLink "Container"}}{{/crossLink}} for a display list. Each time its {{#crossLink "Stage/tick"}}{{/crossLink}}
	 * method is called, it will render its display list to its target canvas.
	 *
	 * <h4>Example</h4>
	 * This example creates a stage, adds a child to it, then uses {{#crossLink "Ticker"}}{{/crossLink}} to update the child
	 * and redraw the stage using {{#crossLink "Stage/update"}}{{/crossLink}}.
	 *
	 *      var stage = new createjs.Stage("canvasElementId");
	 *      var image = new createjs.Bitmap("imagePath.png");
	 *      stage.addChild(image);
	 *      createjs.Ticker.addEventListener("tick", handleTick);
	 *      function handleTick(event) {
	 *          image.x += 10;
	 *          stage.update();
	 *      }
	 *
	 * @class Stage
	 * @extends Container
	 * @constructor
	 * @param {HTMLCanvasElement | String | Object} canvas A canvas object that the Stage will render to, or the string id
	 * of a canvas object in the current document.
	 **/
	function Stage(canvas) {
		this.Container_constructor();
	
	
	// public properties:
		/**
		 * Indicates whether the stage should automatically clear the canvas before each render. You can set this to <code>false</code>
		 * to manually control clearing (for generative art, or when pointing multiple stages at the same canvas for
		 * example).
		 *
		 * <h4>Example</h4>
		 *
		 *      var stage = new createjs.Stage("canvasId");
		 *      stage.autoClear = false;
		 *
		 * @property autoClear
		 * @type Boolean
		 * @default true
		 **/
		this.autoClear = true;
	
		/**
		 * The canvas the stage will render to. Multiple stages can share a single canvas, but you must disable autoClear for all but the
		 * first stage that will be ticked (or they will clear each other's render).
		 *
		 * When changing the canvas property you must disable the events on the old canvas, and enable events on the
		 * new canvas or mouse events will not work as expected. For example:
		 *
		 *      myStage.enableDOMEvents(false);
		 *      myStage.canvas = anotherCanvas;
		 *      myStage.enableDOMEvents(true);
		 *
		 * @property canvas
		 * @type HTMLCanvasElement | Object
		 **/
		this.canvas = (typeof canvas == "string") ? document.getElementById(canvas) : canvas;
	
		/**
		 * The current mouse X position on the canvas. If the mouse leaves the canvas, this will indicate the most recent
		 * position over the canvas, and mouseInBounds will be set to false.
		 * @property mouseX
		 * @type Number
		 * @readonly
		 **/
		this.mouseX = 0;
	
		/**
		 * The current mouse Y position on the canvas. If the mouse leaves the canvas, this will indicate the most recent
		 * position over the canvas, and mouseInBounds will be set to false.
		 * @property mouseY
		 * @type Number
		 * @readonly
		 **/
		this.mouseY = 0;
	
		/**
		 * Specifies the area of the stage to affect when calling update. This can be use to selectively
		 * re-draw specific regions of the canvas. If null, the whole canvas area is drawn.
		 * @property drawRect
		 * @type {Rectangle}
		 */
		this.drawRect = null;
	
		/**
		 * Indicates whether display objects should be rendered on whole pixels. You can set the
		 * {{#crossLink "DisplayObject/snapToPixel"}}{{/crossLink}} property of
		 * display objects to false to enable/disable this behaviour on a per instance basis.
		 * @property snapToPixelEnabled
		 * @type Boolean
		 * @default false
		 **/
		this.snapToPixelEnabled = false;
	
		/**
		 * Indicates whether the mouse is currently within the bounds of the canvas.
		 * @property mouseInBounds
		 * @type Boolean
		 * @default false
		 **/
		this.mouseInBounds = false;
	
		/**
		 * If true, tick callbacks will be called on all display objects on the stage prior to rendering to the canvas.
		 * @property tickOnUpdate
		 * @type Boolean
		 * @default true
		 **/
		this.tickOnUpdate = true;
	
		/**
		 * If true, mouse move events will continue to be called when the mouse leaves the target canvas. See
		 * {{#crossLink "Stage/mouseInBounds:property"}}{{/crossLink}}, and {{#crossLink "MouseEvent"}}{{/crossLink}}
		 * x/y/rawX/rawY.
		 * @property mouseMoveOutside
		 * @type Boolean
		 * @default false
		 **/
		this.mouseMoveOutside = false;
		
		
		/**
		 * Prevents selection of other elements in the html page if the user clicks and drags, or double clicks on the canvas.
		 * This works by calling `preventDefault()` on any mousedown events (or touch equivalent) originating on the canvas.
		 * @property preventSelection
		 * @type Boolean
		 * @default true
		 **/
		this.preventSelection = true;
	
		/**
		 * The hitArea property is not supported for Stage.
		 * @property hitArea
		 * @type {DisplayObject}
		 * @default null
		 */
		 
		 
	// private properties:
		/**
		 * Holds objects with data for each active pointer id. Each object has the following properties:
		 * x, y, event, target, overTarget, overX, overY, inBounds, posEvtObj (native event that last updated position)
		 * @property _pointerData
		 * @type {Object}
		 * @private
		 */
		this._pointerData = {};
	
		/**
		 * Number of active pointers.
		 * @property _pointerCount
		 * @type {Object}
		 * @private
		 */
		this._pointerCount = 0;
	
		/**
		 * The ID of the primary pointer.
		 * @property _primaryPointerID
		 * @type {Object}
		 * @private
		 */
		this._primaryPointerID = null;
	
		/**
		 * @property _mouseOverIntervalID
		 * @protected
		 * @type Number
		 **/
		this._mouseOverIntervalID = null;
		
		/**
		 * @property _nextStage
		 * @protected
		 * @type Stage
		 **/
		this._nextStage = null;
		
		/**
		 * @property _prevStage
		 * @protected
		 * @type Stage
		 **/
		this._prevStage = null;
		
		
	// initialize:
		this.enableDOMEvents(true);
	}
	var p = createjs.extend(Stage, createjs.Container);

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// events:
	/**
	 * Dispatched when the user moves the mouse over the canvas.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event stagemousemove
	 * @since 0.6.0
	 */

	/**
	 * Dispatched when the user presses their left mouse button on the canvas. See the {{#crossLink "MouseEvent"}}{{/crossLink}}
	 * class for a listing of event properties.
	 * @event stagemousedown
	 * @since 0.6.0
	 */

	/**
	 * Dispatched when the user the user presses somewhere on the stage, then releases the mouse button anywhere that the page can detect it (this varies slightly between browsers).
	 * You can use {{#crossLink "Stage/mouseInBounds:property"}}{{/crossLink}} to check whether the mouse is currently within the stage bounds.
	 * See the {{#crossLink "MouseEvent"}}{{/crossLink}} class for a listing of event properties.
	 * @event stagemouseup
	 * @since 0.6.0
	 */

	/**
	 * Dispatched when the mouse moves from within the canvas area (mouseInBounds == true) to outside it (mouseInBounds == false).
	 * This is currently only dispatched for mouse input (not touch). See the {{#crossLink "MouseEvent"}}{{/crossLink}}
	 * class for a listing of event properties.
	 * @event mouseleave
	 * @since 0.7.0
	 */

	/**
	 * Dispatched when the mouse moves into the canvas area (mouseInBounds == false) from outside it (mouseInBounds == true).
	 * This is currently only dispatched for mouse input (not touch). See the {{#crossLink "MouseEvent"}}{{/crossLink}}
	 * class for a listing of event properties.
	 * @event mouseenter
	 * @since 0.7.0
	 */
	 
	/**
	 * Dispatched each update immediately before the tick event is propagated through the display list.
	 * You can call preventDefault on the event object to cancel propagating the tick event.
	 * @event tickstart
	 * @since 0.7.0
	 */
	 
	/**
	 * Dispatched each update immediately after the tick event is propagated through the display list. Does not fire if
	 * tickOnUpdate is false. Precedes the "drawstart" event.
	 * @event tickend
	 * @since 0.7.0
	 */
	 
	/**
	 * Dispatched each update immediately before the canvas is cleared and the display list is drawn to it.
	 * You can call preventDefault on the event object to cancel the draw.
	 * @event drawstart
	 * @since 0.7.0
	 */
	 
	/**
	 * Dispatched each update immediately after the display list is drawn to the canvas and the canvas context is restored.
	 * @event drawend
	 * @since 0.7.0
	 */

	 
// getter / setters:
	/**
	 * Specifies a target stage that will have mouse / touch interactions relayed to it after this stage handles them.
	 * This can be useful in cases where you have multiple layered canvases and want user interactions
	 * events to pass through. For example, this would relay mouse events from topStage to bottomStage:
	 *
	 *      topStage.nextStage = bottomStage;
	 *
	 * To disable relaying, set nextStage to null.
	 * 
	 * MouseOver, MouseOut, RollOver, and RollOut interactions are also passed through using the mouse over settings
	 * of the top-most stage, but are only processed if the target stage has mouse over interactions enabled.
	 * Considerations when using roll over in relay targets:<OL>
	 * <LI> The top-most (first) stage must have mouse over interactions enabled (via enableMouseOver)</LI>
	 * <LI> All stages that wish to participate in mouse over interaction must enable them via enableMouseOver</LI>
	 * <LI> All relay targets will share the frequency value of the top-most stage</LI>
	 * </OL>
	 * To illustrate, in this example the targetStage would process mouse over interactions at 10hz (despite passing
	 * 30 as it's desired frequency):
	 * 	topStage.nextStage = targetStage;
	 * 	topStage.enableMouseOver(10);
	 * 	targetStage.enableMouseOver(30);
	 * 
	 * If the target stage's canvas is completely covered by this stage's canvas, you may also want to disable its
	 * DOM events using:
	 * 
	 *	targetStage.enableDOMEvents(false);
	 * 
	 * @property nextStage
	 * @type {Stage}
	 **/
	p._get_nextStage = function() {
		return this._nextStage;
	};
	p._set_nextStage = function(value) {
		if (this._nextStage) { this._nextStage._prevStage = null; }
		if (value) { value._prevStage = this; }
		this._nextStage = value;
	};
	
	try {
		Object.defineProperties(p, {
			nextStage: { get: p._get_nextStage, set: p._set_nextStage }
		});
	} catch (e) {} // TODO: use Log


// public methods:
	/**
	 * Each time the update method is called, the stage will call {{#crossLink "Stage/tick"}}{{/crossLink}}
	 * unless {{#crossLink "Stage/tickOnUpdate:property"}}{{/crossLink}} is set to false,
	 * and then render the display list to the canvas.
	 *
	 * @method update
	 * @param {Object} [props] Props object to pass to `tick()`. Should usually be a {{#crossLink "Ticker"}}{{/crossLink}} event object, or similar object with a delta property.
	 **/
	p.update = function(props) {
		if (!this.canvas) { return; }
		if (this.tickOnUpdate) { this.tick(props); }
		if (this.dispatchEvent("drawstart", false, true) === false) { return; }
		createjs.DisplayObject._snapToPixelEnabled = this.snapToPixelEnabled;
		var r = this.drawRect, ctx = this.canvas.getContext("2d");
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		if (this.autoClear) {
			if (r) { ctx.clearRect(r.x, r.y, r.width, r.height); }
			else { ctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1); }
		}
		ctx.save();
		if (this.drawRect) {
			ctx.beginPath();
			ctx.rect(r.x, r.y, r.width, r.height);
			ctx.clip();
		}
		this.updateContext(ctx);
		this.draw(ctx, false);
		ctx.restore();
		this.dispatchEvent("drawend");
	};
	
	/**
	 * Propagates a tick event through the display list. This is automatically called by {{#crossLink "Stage/update"}}{{/crossLink}}
	 * unless {{#crossLink "Stage/tickOnUpdate:property"}}{{/crossLink}} is set to false.
	 *
	 * If a props object is passed to `tick()`, then all of its properties will be copied to the event object that is
	 * propagated to listeners.
	 *
	 * Some time-based features in EaselJS (for example {{#crossLink "Sprite/framerate"}}{{/crossLink}} require that
	 * a {{#crossLink "Ticker/tick:event"}}{{/crossLink}} event object (or equivalent object with a delta property) be
	 * passed as the `props` parameter to `tick()`. For example:
	 *
	 * 	Ticker.on("tick", handleTick);
	 * 	function handleTick(evtObj) {
	 * 		// clone the event object from Ticker, and add some custom data to it:
	 * 		var evt = evtObj.clone().set({greeting:"hello", name:"world"});
	 * 		
	 * 		// pass it to stage.update():
	 * 		myStage.update(evt); // subsequently calls tick() with the same param
	 * 	}
	 * 	
	 * 	// ...
	 * 	myDisplayObject.on("tick", handleDisplayObjectTick);
	 * 	function handleDisplayObjectTick(evt) {
	 * 		console.log(evt.delta); // the delta property from the Ticker tick event object
	 * 		console.log(evt.greeting, evt.name); // custom data: "hello world"
	 * 	}
	 * 
	 * @method tick
	 * @param {Object} [props] An object with properties that should be copied to the event object. Should usually be a Ticker event object, or similar object with a delta property.
	 **/
	p.tick = function(props) {
		if (!this.tickEnabled || this.dispatchEvent("tickstart", false, true) === false) { return; }
		var evtObj = new createjs.Event("tick");
		if (props) {
			for (var n in props) {
				if (props.hasOwnProperty(n)) { evtObj[n] = props[n]; }
			}
		}
		this._tick(evtObj);
		this.dispatchEvent("tickend");
	};

	/**
	 * Default event handler that calls the Stage {{#crossLink "Stage/update"}}{{/crossLink}} method when a {{#crossLink "DisplayObject/tick:event"}}{{/crossLink}}
	 * event is received. This allows you to register a Stage instance as a event listener on {{#crossLink "Ticker"}}{{/crossLink}}
	 * directly, using:
	 *
	 *      Ticker.addEventListener("tick", myStage");
	 *
	 * Note that if you subscribe to ticks using this pattern, then the tick event object will be passed through to
	 * display object tick handlers, instead of <code>delta</code> and <code>paused</code> parameters.
	 * @property handleEvent
	 * @type Function
	 **/
	p.handleEvent = function(evt) {
		if (evt.type == "tick") { this.update(evt); }
	};

	/**
	 * Clears the target canvas. Useful if {{#crossLink "Stage/autoClear:property"}}{{/crossLink}} is set to `false`.
	 * @method clear
	 **/
	p.clear = function() {
		if (!this.canvas) { return; }
		var ctx = this.canvas.getContext("2d");
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		ctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1);
	};

	/**
	 * Returns a data url that contains a Base64-encoded image of the contents of the stage. The returned data url can
	 * be specified as the src value of an image element.
	 * @method toDataURL
	 * @param {String} [backgroundColor] The background color to be used for the generated image. Any valid CSS color
	 * value is allowed. The default value is a transparent background.
	 * @param {String} [mimeType="image/png"] The MIME type of the image format to be create. The default is "image/png". If an unknown MIME type
	 * is passed in, or if the browser does not support the specified MIME type, the default value will be used.
	 * @return {String} a Base64 encoded image.
	 **/
	p.toDataURL = function(backgroundColor, mimeType) {
		var data, ctx = this.canvas.getContext('2d'), w = this.canvas.width, h = this.canvas.height;

		if (backgroundColor) {
			data = ctx.getImageData(0, 0, w, h);
			var compositeOperation = ctx.globalCompositeOperation;
			ctx.globalCompositeOperation = "destination-over";
			
			ctx.fillStyle = backgroundColor;
			ctx.fillRect(0, 0, w, h);
		}

		var dataURL = this.canvas.toDataURL(mimeType||"image/png");

		if(backgroundColor) {
			ctx.putImageData(data, 0, 0);
			ctx.globalCompositeOperation = compositeOperation;
		}

		return dataURL;
	};

	/**
	 * Enables or disables (by passing a frequency of 0) mouse over ({{#crossLink "DisplayObject/mouseover:event"}}{{/crossLink}}
	 * and {{#crossLink "DisplayObject/mouseout:event"}}{{/crossLink}}) and roll over events ({{#crossLink "DisplayObject/rollover:event"}}{{/crossLink}}
	 * and {{#crossLink "DisplayObject/rollout:event"}}{{/crossLink}}) for this stage's display list. These events can
	 * be expensive to generate, so they are disabled by default. The frequency of the events can be controlled
	 * independently of mouse move events via the optional `frequency` parameter.
	 *
	 * <h4>Example</h4>
	 *
	 *      var stage = new createjs.Stage("canvasId");
	 *      stage.enableMouseOver(10); // 10 updates per second
	 *
	 * @method enableMouseOver
	 * @param {Number} [frequency=20] Optional param specifying the maximum number of times per second to broadcast
	 * mouse over/out events. Set to 0 to disable mouse over events completely. Maximum is 50. A lower frequency is less
	 * responsive, but uses less CPU.
	 **/
	p.enableMouseOver = function(frequency) {
		if (this._mouseOverIntervalID) {
			clearInterval(this._mouseOverIntervalID);
			this._mouseOverIntervalID = null;
			if (frequency == 0) {
				this._testMouseOver(true);
			}
		}
		if (frequency == null) { frequency = 20; }
		else if (frequency <= 0) { return; }
		var o = this;
		this._mouseOverIntervalID = setInterval(function(){ o._testMouseOver(); }, 1000/Math.min(50,frequency));
	};

	/**
	 * Enables or disables the event listeners that stage adds to DOM elements (window, document and canvas). It is good
	 * practice to disable events when disposing of a Stage instance, otherwise the stage will continue to receive
	 * events from the page.
	 *
	 * When changing the canvas property you must disable the events on the old canvas, and enable events on the
	 * new canvas or mouse events will not work as expected. For example:
	 *
	 *      myStage.enableDOMEvents(false);
	 *      myStage.canvas = anotherCanvas;
	 *      myStage.enableDOMEvents(true);
	 *
	 * @method enableDOMEvents
	 * @param {Boolean} [enable=true] Indicates whether to enable or disable the events. Default is true.
	 **/
	p.enableDOMEvents = function(enable) {
		if (enable == null) { enable = true; }
		var n, o, ls = this._eventListeners;
		if (!enable && ls) {
			for (n in ls) {
				o = ls[n];
				o.t.removeEventListener(n, o.f, false);
			}
			this._eventListeners = null;
		} else if (enable && !ls && this.canvas) {
			var t = window.addEventListener ? window : document;
			var _this = this;
			ls = this._eventListeners = {};
			ls["mouseup"] = {t:t, f:function(e) { _this._handleMouseUp(e)} };
			ls["mousemove"] = {t:t, f:function(e) { _this._handleMouseMove(e)} };
			ls["dblclick"] = {t:this.canvas, f:function(e) { _this._handleDoubleClick(e)} };
			ls["mousedown"] = {t:this.canvas, f:function(e) { _this._handleMouseDown(e)} };

			for (n in ls) {
				o = ls[n];
				o.t.addEventListener(n, o.f, false);
			}
		}
	};

	/**
	 * Stage instances cannot be cloned.
	 * @method clone
	 **/
	p.clone = function() {
		throw("Stage cannot be cloned.");
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Stage (name="+  this.name +")]";
	};


// private methods:
	/**
	 * @method _getElementRect
	 * @protected
	 * @param {HTMLElement} e
	 **/
	p._getElementRect = function(e) {
		var bounds;
		try { bounds = e.getBoundingClientRect(); } // this can fail on disconnected DOM elements in IE9
		catch (err) { bounds = {top: e.offsetTop, left: e.offsetLeft, width:e.offsetWidth, height:e.offsetHeight}; }

		var offX = (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || document.body.clientLeft || 0);
		var offY = (window.pageYOffset || document.scrollTop || 0) - (document.clientTop  || document.body.clientTop  || 0);

		var styles = window.getComputedStyle ? getComputedStyle(e,null) : e.currentStyle; // IE <9 compatibility.
		var padL = parseInt(styles.paddingLeft)+parseInt(styles.borderLeftWidth);
		var padT = parseInt(styles.paddingTop)+parseInt(styles.borderTopWidth);
		var padR = parseInt(styles.paddingRight)+parseInt(styles.borderRightWidth);
		var padB = parseInt(styles.paddingBottom)+parseInt(styles.borderBottomWidth);

		// note: in some browsers bounds properties are read only.
		return {
			left: bounds.left+offX+padL,
			right: bounds.right+offX-padR,
			top: bounds.top+offY+padT,
			bottom: bounds.bottom+offY-padB
		}
	};

	/**
	 * @method _getPointerData
	 * @protected
	 * @param {Number} id
	 **/
	p._getPointerData = function(id) {
		var data = this._pointerData[id];
		if (!data) { data = this._pointerData[id] = {x:0,y:0}; }
		return data;
	};

	/**
	 * @method _handleMouseMove
	 * @protected
	 * @param {MouseEvent} e
	 **/
	p._handleMouseMove = function(e) {
		if(!e){ e = window.event; }
		this._handlePointerMove(-1, e, e.pageX, e.pageY);
	};

	/**
	 * @method _handlePointerMove
	 * @protected
	 * @param {Number} id
	 * @param {Event} e
	 * @param {Number} pageX
	 * @param {Number} pageY
	 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
	 **/
	p._handlePointerMove = function(id, e, pageX, pageY, owner) {
		if (this._prevStage && owner === undefined) { return; } // redundant listener.
		if (!this.canvas) { return; }
		var nextStage=this._nextStage, o=this._getPointerData(id);

		var inBounds = o.inBounds;
		this._updatePointerPosition(id, e, pageX, pageY);
		if (inBounds || o.inBounds || this.mouseMoveOutside) {
			if (id === -1 && o.inBounds == !inBounds) {
				this._dispatchMouseEvent(this, (inBounds ? "mouseleave" : "mouseenter"), false, id, o, e);
			}
			
			this._dispatchMouseEvent(this, "stagemousemove", false, id, o, e);
			this._dispatchMouseEvent(o.target, "pressmove", true, id, o, e);
		}
		
		nextStage&&nextStage._handlePointerMove(id, e, pageX, pageY, null);
	};

	/**
	 * @method _updatePointerPosition
	 * @protected
	 * @param {Number} id
	 * @param {Event} e
	 * @param {Number} pageX
	 * @param {Number} pageY
	 **/
	p._updatePointerPosition = function(id, e, pageX, pageY) {
		var rect = this._getElementRect(this.canvas);
		pageX -= rect.left;
		pageY -= rect.top;

		var w = this.canvas.width;
		var h = this.canvas.height;
		pageX /= (rect.right-rect.left)/w;
		pageY /= (rect.bottom-rect.top)/h;
		var o = this._getPointerData(id);
		if (o.inBounds = (pageX >= 0 && pageY >= 0 && pageX <= w-1 && pageY <= h-1)) {
			o.x = pageX;
			o.y = pageY;
		} else if (this.mouseMoveOutside) {
			o.x = pageX < 0 ? 0 : (pageX > w-1 ? w-1 : pageX);
			o.y = pageY < 0 ? 0 : (pageY > h-1 ? h-1 : pageY);
		}

		o.posEvtObj = e;
		o.rawX = pageX;
		o.rawY = pageY;

		if (id === this._primaryPointerID || id === -1) {
			this.mouseX = o.x;
			this.mouseY = o.y;
			this.mouseInBounds = o.inBounds;
		}
	};

	/**
	 * @method _handleMouseUp
	 * @protected
	 * @param {MouseEvent} e
	 **/
	p._handleMouseUp = function(e) {
		this._handlePointerUp(-1, e, false);
	};

	/**
	 * @method _handlePointerUp
	 * @protected
	 * @param {Number} id
	 * @param {Event} e
	 * @param {Boolean} clear
	 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
	 **/
	p._handlePointerUp = function(id, e, clear, owner) {
		var nextStage = this._nextStage, o = this._getPointerData(id);
		if (this._prevStage && owner === undefined) { return; } // redundant listener.
		
		var target=null, oTarget = o.target;
		if (!owner && (oTarget || nextStage)) { target = this._getObjectsUnderPoint(o.x, o.y, null, true); }
		
		if (o.down) { this._dispatchMouseEvent(this, "stagemouseup", false, id, o, e, target); o.down = false; }
		
		if (target == oTarget) { this._dispatchMouseEvent(oTarget, "click", true, id, o, e); }
		this._dispatchMouseEvent(oTarget, "pressup", true, id, o, e);
		
		if (clear) {
			if (id==this._primaryPointerID) { this._primaryPointerID = null; }
			delete(this._pointerData[id]);
		} else { o.target = null; }
		
		nextStage&&nextStage._handlePointerUp(id, e, clear, owner || target && this);
	};

	/**
	 * @method _handleMouseDown
	 * @protected
	 * @param {MouseEvent} e
	 **/
	p._handleMouseDown = function(e) {
		this._handlePointerDown(-1, e, e.pageX, e.pageY);
	};

	/**
	 * @method _handlePointerDown
	 * @protected
	 * @param {Number} id
	 * @param {Event} e
	 * @param {Number} pageX
	 * @param {Number} pageY
	 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
	 **/
	p._handlePointerDown = function(id, e, pageX, pageY, owner) {
		if (this.preventSelection) { e.preventDefault(); }
		if (this._primaryPointerID == null || id === -1) { this._primaryPointerID = id; } // mouse always takes over.
		
		if (pageY != null) { this._updatePointerPosition(id, e, pageX, pageY); }
		var target = null, nextStage = this._nextStage, o = this._getPointerData(id);
		if (!owner) { target = o.target = this._getObjectsUnderPoint(o.x, o.y, null, true); }

		if (o.inBounds) { this._dispatchMouseEvent(this, "stagemousedown", false, id, o, e, target); o.down = true; }
		this._dispatchMouseEvent(target, "mousedown", true, id, o, e);
		
		nextStage&&nextStage._handlePointerDown(id, e, pageX, pageY, owner || target && this);
	};

	/**
	 * @method _testMouseOver
	 * @param {Boolean} clear If true, clears the mouseover / rollover (ie. no target)
	 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
	 * @param {Stage} eventTarget The stage that the cursor is actively over.
	 * @protected
	 **/
	p._testMouseOver = function(clear, owner, eventTarget) {
		if (this._prevStage && owner === undefined) { return; } // redundant listener.
		
		var nextStage = this._nextStage;
		if (!this._mouseOverIntervalID) {
			// not enabled for mouseover, but should still relay the event.
			nextStage&&nextStage._testMouseOver(clear, owner, eventTarget);
			return;
		}
		var o = this._getPointerData(-1);
		// only update if the mouse position has changed. This provides a lot of optimization, but has some trade-offs.
		if (!o || (!clear && this.mouseX == this._mouseOverX && this.mouseY == this._mouseOverY && this.mouseInBounds)) { return; }
		
		var e = o.posEvtObj;
		var isEventTarget = eventTarget || e&&(e.target == this.canvas);
		var target=null, common = -1, cursor="", t, i, l;
		
		if (!owner && (clear || this.mouseInBounds && isEventTarget)) {
			target = this._getObjectsUnderPoint(this.mouseX, this.mouseY, null, true);
			this._mouseOverX = this.mouseX;
			this._mouseOverY = this.mouseY;
		}

		var oldList = this._mouseOverTarget||[];
		var oldTarget = oldList[oldList.length-1];
		var list = this._mouseOverTarget = [];

		// generate ancestor list and check for cursor:
		t = target;
		while (t) {
			list.unshift(t);
			if (!cursor) { cursor = t.cursor; }
			t = t.parent;
		}
		this.canvas.style.cursor = cursor;
		if (!owner && eventTarget) { eventTarget.canvas.style.cursor = cursor; }

		// find common ancestor:
		for (i=0,l=list.length; i<l; i++) {
			if (list[i] != oldList[i]) { break; }
			common = i;
		}

		if (oldTarget != target) {
			this._dispatchMouseEvent(oldTarget, "mouseout", true, -1, o, e, target);
		}

		for (i=oldList.length-1; i>common; i--) {
			this._dispatchMouseEvent(oldList[i], "rollout", false, -1, o, e, target);
		}

		for (i=list.length-1; i>common; i--) {
			this._dispatchMouseEvent(list[i], "rollover", false, -1, o, e, oldTarget);
		}

		if (oldTarget != target) {
			this._dispatchMouseEvent(target, "mouseover", true, -1, o, e, oldTarget);
		}
		
		nextStage&&nextStage._testMouseOver(clear, owner || target && this, eventTarget || isEventTarget && this);
	};

	/**
	 * @method _handleDoubleClick
	 * @protected
	 * @param {MouseEvent} e
	 * @param {Stage} owner Indicates that the event has already been captured & handled by the indicated stage.
	 **/
	p._handleDoubleClick = function(e, owner) {
		var target=null, nextStage=this._nextStage, o=this._getPointerData(-1);
		if (!owner) {
			target = this._getObjectsUnderPoint(o.x, o.y, null, true);
			this._dispatchMouseEvent(target, "dblclick", true, -1, o, e);
		}
		nextStage&&nextStage._handleDoubleClick(e, owner || target && this);
	};

	/**
	 * @method _dispatchMouseEvent
	 * @protected
	 * @param {DisplayObject} target
	 * @param {String} type
	 * @param {Boolean} bubbles
	 * @param {Number} pointerId
	 * @param {Object} o
	 * @param {MouseEvent} [nativeEvent]
	 * @param {DisplayObject} [relatedTarget]
	 **/
	p._dispatchMouseEvent = function(target, type, bubbles, pointerId, o, nativeEvent, relatedTarget) {
		// TODO: might be worth either reusing MouseEvent instances, or adding a willTrigger method to avoid GC.
		if (!target || (!bubbles && !target.hasEventListener(type))) { return; }
		/*
		// TODO: account for stage transformations?
		this._mtx = this.getConcatenatedMatrix(this._mtx).invert();
		var pt = this._mtx.transformPoint(o.x, o.y);
		var evt = new createjs.MouseEvent(type, bubbles, false, pt.x, pt.y, nativeEvent, pointerId, pointerId==this._primaryPointerID || pointerId==-1, o.rawX, o.rawY);
		*/
		var evt = new createjs.MouseEvent(type, bubbles, false, o.x, o.y, nativeEvent, pointerId, pointerId === this._primaryPointerID || pointerId === -1, o.rawX, o.rawY, relatedTarget);
		target.dispatchEvent(evt);
	};


	createjs.Stage = createjs.promote(Stage, "Container");
}());

//##############################################################################
// Bitmap.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	
	/**
	 * A Bitmap represents an Image, Canvas, or Video in the display list. A Bitmap can be instantiated using an existing
	 * HTML element, or a string.
	 *
	 * <h4>Example</h4>
	 *
	 *      var bitmap = new createjs.Bitmap("imagePath.jpg");
	 *
	 * <strong>Notes:</strong>
	 * <ol>
	 *     <li>When a string path or image tag that is not yet loaded is used, the stage may need to be redrawn before it
	 *      will be displayed.</li>
	 *     <li>Bitmaps with an SVG source currently will not respect an alpha value other than 0 or 1. To get around this,
	 *     the Bitmap can be cached.</li>
	 *     <li>Bitmaps with an SVG source will taint the canvas with cross-origin data, which prevents interactivity. This
	 *     happens in all browsers except recent Firefox builds.</li>
	 *     <li>Images loaded cross-origin will throw cross-origin security errors when interacted with using a mouse, using
	 *     methods such as `getObjectUnderPoint`, or using filters, or caching. You can get around this by setting
	 *     `crossOrigin` flags on your images before passing them to EaselJS, eg: `img.crossOrigin="Anonymous";`</li>
	 * </ol>
	 *
	 * @class Bitmap
	 * @extends DisplayObject
	 * @constructor
	 * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | String} imageOrUri The source object or URI to an image to
	 * display. This can be either an Image, Canvas, or Video object, or a string URI to an image file to load and use.
	 * If it is a URI, a new Image object will be constructed and assigned to the .image property.
	 **/
	function Bitmap(imageOrUri) {
		this.DisplayObject_constructor();
		
		
	// public properties:
		/**
		 * The image to render. This can be an Image, a Canvas, or a Video. Not all browsers (especially
		 * mobile browsers) support drawing video to a canvas.
		 * @property image
		 * @type HTMLImageElement | HTMLCanvasElement | HTMLVideoElement
		 **/
		if (typeof imageOrUri == "string") {
			this.image = document.createElement("img");
			this.image.src = imageOrUri;
		} else {
			this.image = imageOrUri;
		}
	
		/**
		 * Specifies an area of the source image to draw. If omitted, the whole image will be drawn.
		 * Note that video sources must have a width / height set to work correctly with `sourceRect`.
		 * @property sourceRect
		 * @type Rectangle
		 * @default null
		 */
		this.sourceRect = null;
	}
	var p = createjs.extend(Bitmap, createjs.DisplayObject);
	
	
// public methods:
	/**
	 * Constructor alias for backwards compatibility. This method will be removed in future versions.
	 * Subclasses should be updated to use {{#crossLink "Utility Methods/extends"}}{{/crossLink}}.
	 * @method initialize
	 * @deprecated in favour of `createjs.promote()`
	 **/
	p.initialize = Bitmap; // TODO: deprecated.

	/**
	 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
	 **/
	p.isVisible = function() {
		var image = this.image;
		var hasContent = this.cacheCanvas || (image && (image.naturalWidth || image.getContext || image.readyState >= 2));
		return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
	};

	/**
	 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
	 * Returns true if the draw was handled (useful for overriding functionality).
	 *
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache.
	 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
	 * into itself).
	 * @return {Boolean}
	 **/
	p.draw = function(ctx, ignoreCache) {
		if (this.DisplayObject_draw(ctx, ignoreCache) || !this.image) { return true; }
		var img = this.image, rect = this.sourceRect;
		if (rect) {
			// some browsers choke on out of bound values, so we'll fix them:
			var x1 = rect.x, y1 = rect.y, x2 = x1 + rect.width, y2 = y1 + rect.height, x = 0, y = 0, w = img.width, h = img.height;
			if (x1 < 0) { x -= x1; x1 = 0; }
			if (x2 > w) { x2 = w; }
			if (y1 < 0) { y -= y1; y1 = 0; }
			if (y2 > h) { y2 = h; }
			ctx.drawImage(img, x1, y1, x2-x1, y2-y1, x, y, x2-x1, y2-y1);
		} else {
			ctx.drawImage(img, 0, 0);
		}
		return true;
	};
	
	//Note, the doc sections below document using the specified APIs (from DisplayObject)  from
	//Bitmap. This is why they have no method implementations.
	
	/**
	 * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.
	 * You should <b>not</b> cache Bitmap instances as it can degrade performance.
	 *
	 * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>
	 * To see the API for caching, please visit the DisplayObject {{#crossLink "DisplayObject/cache"}}{{/crossLink}}
	 * method.
	 * @method cache
	 **/
	
	/**
	 * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.
	 * You should <b>not</b> cache Bitmap instances as it can degrade performance.
	 *
	 * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>
	 * To see the API for caching, please visit the DisplayObject {{#crossLink "DisplayObject/cache"}}{{/crossLink}}
	 * method.
	 * @method updateCache
	 **/
	
	/**
	 * Because the content of a Bitmap is already in a simple format, cache is unnecessary for Bitmap instances.
	 * You should <b>not</b> cache Bitmap instances as it can degrade performance.
	 *
	 * <strong>However: If you want to use a filter on a Bitmap, you <em>MUST</em> cache it, or it will not work.</strong>
	 * To see the API for caching, please visit the DisplayObject {{#crossLink "DisplayObject/cache"}}{{/crossLink}}
	 * method.
	 * @method uncache
	 **/

	/**
	 * Docced in superclass.
	 */
	p.getBounds = function() {
		var rect = this.DisplayObject_getBounds();
		if (rect) { return rect; }
		var image = this.image, o = this.sourceRect || image;
		var hasContent = (image && (image.naturalWidth || image.getContext || image.readyState >= 2));
		return hasContent ? this._rectangle.setValues(0, 0, o.width, o.height) : null;
	};
	
	/**
	 * Returns a clone of the Bitmap instance.
	 * @method clone
	 * @return {Bitmap} a clone of the Bitmap instance.
	 **/
	p.clone = function() {
		var o = new Bitmap(this.image);
		if (this.sourceRect) { o.sourceRect = this.sourceRect.clone(); }
		this._cloneProps(o);
		return o;
	};
	
	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Bitmap (name="+  this.name +")]";
	};

	
	createjs.Bitmap = createjs.promote(Bitmap, "DisplayObject");
}());

//##############################################################################
// Sprite.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Displays a frame or sequence of frames (ie. an animation) from a SpriteSheet instance. A sprite sheet is a series of
	 * images (usually animation frames) combined into a single image. For example, an animation consisting of 8 100x100
	 * images could be combined into a 400x200 sprite sheet (4 frames across by 2 high). You can display individual frames,
	 * play frames as an animation, and even sequence animations together.
	 *
	 * See the {{#crossLink "SpriteSheet"}}{{/crossLink}} class for more information on setting up frames and animations.
	 *
	 * <h4>Example</h4>
	 *
	 *      var instance = new createjs.Sprite(spriteSheet);
	 *      instance.gotoAndStop("frameName");
	 *
	 * Until {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} or {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}} is called,
	 * only the first defined frame defined in the sprite sheet will be displayed.
	 *
	 * @class Sprite
	 * @extends DisplayObject
	 * @constructor
	 * @param {SpriteSheet} spriteSheet The SpriteSheet instance to play back. This includes the source image(s), frame
	 * dimensions, and frame data. See {{#crossLink "SpriteSheet"}}{{/crossLink}} for more information.
	 * @param {String|Number} [frameOrAnimation] The frame number or animation to play initially.
	 **/
	function Sprite(spriteSheet, frameOrAnimation) {
		this.DisplayObject_constructor();
		
		
	// public properties:
		/**
		 * The frame index that will be drawn when draw is called. Note that with some {{#crossLink "SpriteSheet"}}{{/crossLink}}
		 * definitions, this will advance non-sequentially. This will always be an integer value.
		 * @property currentFrame
		 * @type {Number}
		 * @default 0
		 * @readonly
		 **/
		this.currentFrame = 0;
	
		/**
		 * Returns the name of the currently playing animation.
		 * @property currentAnimation
		 * @type {String}
		 * @final
		 * @readonly
		 **/
		this.currentAnimation = null;
	
		/**
		 * Prevents the animation from advancing each tick automatically. For example, you could create a sprite
		 * sheet of icons, set paused to true, and display the appropriate icon by setting <code>currentFrame</code>.
		 * @property paused
		 * @type {Boolean}
		 * @default false
		 **/
		this.paused = true;
	
		/**
		 * The SpriteSheet instance to play back. This includes the source image, frame dimensions, and frame
		 * data. See {{#crossLink "SpriteSheet"}}{{/crossLink}} for more information.
		 * @property spriteSheet
		 * @type {SpriteSheet}
		 * @readonly
		 **/
		this.spriteSheet = spriteSheet;
	
		/**
		 * Specifies the current frame index within the currently playing animation. When playing normally, this will increase
		 * from 0 to n-1, where n is the number of frames in the current animation.
		 *
		 * This could be a non-integer value if
		 * using time-based playback (see {{#crossLink "Sprite/framerate"}}{{/crossLink}}, or if the animation's speed is
		 * not an integer.
		 * @property currentAnimationFrame
		 * @type {Number}
		 * @default 0
		 **/
		this.currentAnimationFrame = 0;
	
		/**
		 * By default Sprite instances advance one frame per tick. Specifying a framerate for the Sprite (or its related
		 * SpriteSheet) will cause it to advance based on elapsed time between ticks as appropriate to maintain the target
		 * framerate.
		 *
		 * For example, if a Sprite with a framerate of 10 is placed on a Stage being updated at 40fps, then the Sprite will
		 * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will
		 * vary slightly between frames.
		 *
		 * This feature is dependent on the tick event object (or an object with an appropriate "delta" property) being
		 * passed into {{#crossLink "Stage/update"}}{{/crossLink}}.
		 * @property framerate
		 * @type {Number}
		 * @default 0
		 **/
		this.framerate = 0;
	
	
	// private properties:
		/**
		 * Current animation object.
		 * @property _animation
		 * @protected
		 * @type {Object}
		 * @default null
		 **/
		this._animation = null;
	
		/**
		 * Current frame index.
		 * @property _currentFrame
		 * @protected
		 * @type {Number}
		 * @default null
		 **/
		this._currentFrame = null;
		
		/**
		 * Skips the next auto advance. Used by gotoAndPlay to avoid immediately jumping to the next frame
		 * @property _skipAdvance
		 * @protected
		 * @type {Boolean}
		 * @default false
		 **/
		this._skipAdvance = false;
		
		
		if (frameOrAnimation != null) { this.gotoAndPlay(frameOrAnimation); }
	}
	var p = createjs.extend(Sprite, createjs.DisplayObject);

	/**
	 * Constructor alias for backwards compatibility. This method will be removed in future versions.
	 * Subclasses should be updated to use {{#crossLink "Utility Methods/extends"}}{{/crossLink}}.
	 * @method initialize
	 * @deprecated in favour of `createjs.promote()`
	 **/
	p.initialize = Sprite; // TODO: Deprecated. This is for backwards support of FlashCC spritesheet export.


// events:
	/**
	 * Dispatched when an animation reaches its ends.
	 * @event animationend
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {String} name The name of the animation that just ended.
	 * @param {String} next The name of the next animation that will be played, or null. This will be the same as name if the animation is looping.
	 * @since 0.6.0
	 */
	 
	/**
	 * Dispatched any time the current frame changes. For example, this could be due to automatic advancement on a tick,
	 * or calling gotoAndPlay() or gotoAndStop().
	 * @event change
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 */


// public methods:
	/**
	 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
	 **/
	p.isVisible = function() {
		var hasContent = this.cacheCanvas || this.spriteSheet.complete;
		return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
	};

	/**
	 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
	 * Returns true if the draw was handled (useful for overriding functionality).
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.
	 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
	 * into itself).
	 **/
	p.draw = function(ctx, ignoreCache) {
		if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
		this._normalizeFrame();
		var o = this.spriteSheet.getFrame(this._currentFrame|0);
		if (!o) { return false; }
		var rect = o.rect;
		if (rect.width && rect.height) { ctx.drawImage(o.image, rect.x, rect.y, rect.width, rect.height, -o.regX, -o.regY, rect.width, rect.height); }
		return true;
	};

	//Note, the doc sections below document using the specified APIs (from DisplayObject)  from
	//Bitmap. This is why they have no method implementations.

	/**
	 * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.
	 * You should not cache Sprite instances as it can degrade performance.
	 * @method cache
	 **/

	/**
	 * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.
	 * You should not cache Sprite instances as it can degrade performance.
	 * @method updateCache
	 **/

	/**
	 * Because the content of a Sprite is already in a raster format, cache is unnecessary for Sprite instances.
	 * You should not cache Sprite instances as it can degrade performance.
	 * @method uncache
	 **/

	/**
	 * Play (unpause) the current animation. The Sprite will be paused if either {{#crossLink "Sprite/stop"}}{{/crossLink}}
	 * or {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} is called. Single frame animations will remain
	 * unchanged.
	 * @method play
	 **/
	p.play = function() {
		this.paused = false;
	};

	/**
	 * Stop playing a running animation. The Sprite will be playing if {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}}
	 * is called. Note that calling {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}} or {{#crossLink "Sprite/play"}}{{/crossLink}}
	 * will resume playback.
	 * @method stop
	 **/
	p.stop = function() {
		this.paused = true;
	};

	/**
	 * Sets paused to false and plays the specified animation name, named frame, or frame number.
	 * @method gotoAndPlay
	 * @param {String|Number} frameOrAnimation The frame number or animation name that the playhead should move to
	 * and begin playing.
	 **/
	p.gotoAndPlay = function(frameOrAnimation) {
		this.paused = false;
		this._skipAdvance = true;
		this._goto(frameOrAnimation);
	};

	/**
	 * Sets paused to true and seeks to the specified animation name, named frame, or frame number.
	 * @method gotoAndStop
	 * @param {String|Number} frameOrAnimation The frame number or animation name that the playhead should move to
	 * and stop.
	 **/
	p.gotoAndStop = function(frameOrAnimation) {
		this.paused = true;
		this._goto(frameOrAnimation);
	};

	/**
	 * Advances the playhead. This occurs automatically each tick by default.
	 * @param [time] {Number} The amount of time in ms to advance by. Only applicable if framerate is set on the Sprite
	 * or its SpriteSheet.
	 * @method advance
	*/
	p.advance = function(time) {
		var fps = this.framerate || this.spriteSheet.framerate;
		var t = (fps && time != null) ? time/(1000/fps) : 1;
		this._normalizeFrame(t);
	};
	
	/**
	 * Returns a {{#crossLink "Rectangle"}}{{/crossLink}} instance defining the bounds of the current frame relative to
	 * the origin. For example, a 90 x 70 frame with <code>regX=50</code> and <code>regY=40</code> would return a
	 * rectangle with [x=-50, y=-40, width=90, height=70]. This ignores transformations on the display object.
	 *
	 * Also see the SpriteSheet {{#crossLink "SpriteSheet/getFrameBounds"}}{{/crossLink}} method.
	 * @method getBounds
	 * @return {Rectangle} A Rectangle instance. Returns null if the frame does not exist, or the image is not fully
	 * loaded.
	 **/
	p.getBounds = function() {
		// TODO: should this normalizeFrame?
		return this.DisplayObject_getBounds() || this.spriteSheet.getFrameBounds(this.currentFrame, this._rectangle);
	};

	/**
	 * Returns a clone of the Sprite instance. Note that the same SpriteSheet is shared between cloned
	 * instances.
	 * @method clone
	 * @return {Sprite} a clone of the Sprite instance.
	 **/
	p.clone = function() {
		return this._cloneProps(new Sprite(this.spriteSheet));
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Sprite (name="+  this.name +")]";
	};

// private methods:
	/**
	 * @method _cloneProps
	 * @param {Sprite} o
	 * @return {Sprite} o
	 * @protected
	 **/
	p._cloneProps = function(o) {
		this.DisplayObject__cloneProps(o);
		o.currentFrame = this.currentFrame;
		o.currentAnimation = this.currentAnimation;
		o.paused = this.paused;
		o.currentAnimationFrame = this.currentAnimationFrame;
		o.framerate = this.framerate;
		
		o._animation = this._animation;
		o._currentFrame = this._currentFrame;
		o._skipAdvance = this._skipAdvance;
		return o;
	};
	
	/**
	 * Advances the <code>currentFrame</code> if paused is not true. This is called automatically when the {{#crossLink "Stage"}}{{/crossLink}}
	 * ticks.
	 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
	 * @protected
	 * @method _tick
	 **/
	p._tick = function(evtObj) {
		if (!this.paused) {
			if (!this._skipAdvance) { this.advance(evtObj&&evtObj.delta); }
			this._skipAdvance = false;
		}
		this.DisplayObject__tick(evtObj);
	};


	/**
	 * Normalizes the current frame, advancing animations and dispatching callbacks as appropriate.
	 * @protected
	 * @method _normalizeFrame
	 **/
	p._normalizeFrame = function(frameDelta) {
		frameDelta = frameDelta || 0;
		var animation = this._animation;
		var paused = this.paused;
		var frame = this._currentFrame;
		var l;
		
		if (animation) {
			var speed = animation.speed || 1;
			var animFrame = this.currentAnimationFrame;
			l = animation.frames.length;
			if (animFrame + frameDelta * speed >= l) {
				var next = animation.next;
				if (this._dispatchAnimationEnd(animation, frame, paused, next, l - 1)) {
					// something changed in the event stack, so we shouldn't make any more changes here.
					return;
				} else if (next) {
					// sequence. Automatically calls _normalizeFrame again with the remaining frames.
					return this._goto(next, frameDelta - (l - animFrame) / speed);
				} else {
					// end.
					this.paused = true;
					animFrame = animation.frames.length - 1;
				}
			} else {
				animFrame += frameDelta * speed;
			}
			this.currentAnimationFrame = animFrame;
			this._currentFrame = animation.frames[animFrame | 0]
		} else {
			frame = (this._currentFrame += frameDelta);
			l = this.spriteSheet.getNumFrames();
			if (frame >= l && l > 0) {
				if (!this._dispatchAnimationEnd(animation, frame, paused, l - 1)) {
					// looped.
					if ((this._currentFrame -= l) >= l) { return this._normalizeFrame(); }
				}
			}
		}
		frame = this._currentFrame | 0;
		if (this.currentFrame != frame) {
			this.currentFrame = frame;
			this.dispatchEvent("change");
		}
	};

	/**
	 * Dispatches the "animationend" event. Returns true if a handler changed the animation (ex. calling {{#crossLink "Sprite/stop"}}{{/crossLink}},
	 * {{#crossLink "Sprite/gotoAndPlay"}}{{/crossLink}}, etc.)
	 * @property _dispatchAnimationEnd
	 * @private
	 * @type {Function}
	 **/
	p._dispatchAnimationEnd = function(animation, frame, paused, next, end) {
		var name = animation ? animation.name : null;
		if (this.hasEventListener("animationend")) {
			var evt = new createjs.Event("animationend");
			evt.name = name;
			evt.next = next;
			this.dispatchEvent(evt);
		}
		// did the animation get changed in the event stack?:
		var changed = (this._animation != animation || this._currentFrame != frame);
		// if the animation hasn't changed, but the sprite was paused, then we want to stick to the last frame:
		if (!changed && !paused && this.paused) { this.currentAnimationFrame = end; changed = true; }
		return changed;
	};

	/**
	 * Moves the playhead to the specified frame number or animation.
	 * @method _goto
	 * @param {String|Number} frameOrAnimation The frame number or animation that the playhead should move to.
	 * @param {Boolean} [frame] The frame of the animation to go to. Defaults to 0.
	 * @protected
	 **/
	p._goto = function(frameOrAnimation, frame) {
		this.currentAnimationFrame = 0;
		if (isNaN(frameOrAnimation)) {
			var data = this.spriteSheet.getAnimation(frameOrAnimation);
			if (data) {
				this._animation = data;
				this.currentAnimation = frameOrAnimation;
				this._normalizeFrame(frame);
			}
		} else {
			this.currentAnimation = this._animation = null;
			this._currentFrame = frameOrAnimation;
			this._normalizeFrame();
		}
	};


	createjs.Sprite = createjs.promote(Sprite, "DisplayObject");
}());

//##############################################################################
// Shape.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * A Shape allows you to display vector art in the display list. It composites a {{#crossLink "Graphics"}}{{/crossLink}}
	 * instance which exposes all of the vector drawing methods. The Graphics instance can be shared between multiple Shape
	 * instances to display the same vector graphics with different positions or transforms.
	 *
	 * If the vector art will not
	 * change between draws, you may want to use the {{#crossLink "DisplayObject/cache"}}{{/crossLink}} method to reduce the
	 * rendering cost.
	 *
	 * <h4>Example</h4>
	 *
	 *      var graphics = new createjs.Graphics().beginFill("#ff0000").drawRect(0, 0, 100, 100);
	 *      var shape = new createjs.Shape(graphics);
	 *
	 *      //Alternatively use can also use the graphics property of the Shape class to renderer the same as above.
	 *      var shape = new createjs.Shape();
	 *      shape.graphics.beginFill("#ff0000").drawRect(0, 0, 100, 100);
	 *
	 * @class Shape
	 * @extends DisplayObject
	 * @constructor
	 * @param {Graphics} graphics Optional. The graphics instance to display. If null, a new Graphics instance will be created.
	 **/
	function Shape(graphics) {
		this.DisplayObject_constructor();
		
		
	// public properties:
		/**
		 * The graphics instance to display.
		 * @property graphics
		 * @type Graphics
		 **/
		this.graphics = graphics ? graphics : new createjs.Graphics();
	}
	var p = createjs.extend(Shape, createjs.DisplayObject);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// public methods:
	/**
	 * Returns true or false indicating whether the Shape would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Boolean indicating whether the Shape would be visible if drawn to a canvas
	 **/
	p.isVisible = function() {
		var hasContent = this.cacheCanvas || (this.graphics && !this.graphics.isEmpty());
		return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
	};

	/**
	 * Draws the Shape into the specified context ignoring its visible, alpha, shadow, and transform. Returns true if
	 * the draw was handled (useful for overriding functionality).
	 *
	 * <i>NOTE: This method is mainly for internal use, though it may be useful for advanced uses.</i>
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Boolean} [ignoreCache=false] Indicates whether the draw operation should ignore any current cache. For example,
	 * used for drawing the cache (to prevent it from simply drawing an existing cache back into itself).
	 * @return {Boolean}
	 **/
	p.draw = function(ctx, ignoreCache) {
		if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }
		this.graphics.draw(ctx, this);
		return true;
	};

	/**
	 * Returns a clone of this Shape. Some properties that are specific to this instance's current context are reverted to
	 * their defaults (for example .parent).
	 * @method clone
	 * @param {Boolean} recursive If true, this Shape's {{#crossLink "Graphics"}}{{/crossLink}} instance will also be
	 * cloned. If false, the Graphics instance will be shared with the new Shape.
	 **/
	p.clone = function(recursive) {
		var g = (recursive && this.graphics) ? this.graphics.clone() : this.graphics;
		return  this._cloneProps(new Shape(g));
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Shape (name="+  this.name +")]";
	};


	createjs.Shape = createjs.promote(Shape, "DisplayObject");
}());

//##############################################################################
// Text.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Display one or more lines of dynamic text (not user editable) in the display list. Line wrapping support (using the
	 * lineWidth) is very basic, wrapping on spaces and tabs only. Note that as an alternative to Text, you can position HTML
	 * text above or below the canvas relative to items in the display list using the {{#crossLink "DisplayObject/localToGlobal"}}{{/crossLink}}
	 * method, or using {{#crossLink "DOMElement"}}{{/crossLink}}.
	 *
	 * <b>Please note that Text does not support HTML text, and can only display one font style at a time.</b> To use
	 * multiple font styles, you will need to create multiple text instances, and position them manually.
	 *
	 * <h4>Example</h4>
	 *
	 *      var text = new createjs.Text("Hello World", "20px Arial", "#ff7700");
	 *      text.x = 100;
	 *      text.textBaseline = "alphabetic";
	 *
	 * CreateJS Text supports web fonts (the same rules as Canvas). The font must be loaded and supported by the browser
	 * before it can be displayed.
	 *
	 * <strong>Note:</strong> Text can be expensive to generate, so cache instances where possible. Be aware that not all
	 * browsers will render Text exactly the same.
	 * @class Text
	 * @extends DisplayObject
	 * @constructor
	 * @param {String} [text] The text to display.
	 * @param {String} [font] The font style to use. Any valid value for the CSS font attribute is acceptable (ex. "bold
	 * 36px Arial").
	 * @param {String} [color] The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex.
	 * "#F00", "red", or "#FF0000").
	 **/
	function Text(text, font, color) {
		this.DisplayObject_constructor();
		
		
	// public properties:
		/**
		 * The text to display.
		 * @property text
		 * @type String
		 **/
		this.text = text;
	
		/**
		 * The font style to use. Any valid value for the CSS font attribute is acceptable (ex. "bold 36px Arial").
		 * @property font
		 * @type String
		 **/
		this.font = font;
	
		/**
		 * The color to draw the text in. Any valid value for the CSS color attribute is acceptable (ex. "#F00"). Default is "#000".
		 * It will also accept valid canvas fillStyle values.
		 * @property color
		 * @type String
		 **/
		this.color = color;
	
		/**
		 * The horizontal text alignment. Any of "start", "end", "left", "right", and "center". For detailed
		 * information view the
		 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles">
		 * whatwg spec</a>. Default is "left".
		 * @property textAlign
		 * @type String
		 **/
		this.textAlign = "left";
	
		/**
		 * The vertical alignment point on the font. Any of "top", "hanging", "middle", "alphabetic", "ideographic", or
		 * "bottom". For detailed information view the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles">
		 * whatwg spec</a>. Default is "top".
		 * @property textBaseline
		 * @type String
		*/
		this.textBaseline = "top";
	
		/**
		 * The maximum width to draw the text. If maxWidth is specified (not null), the text will be condensed or
		 * shrunk to make it fit in this width. For detailed information view the
		 * <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles">
		 * whatwg spec</a>.
		 * @property maxWidth
		 * @type Number
		*/
		this.maxWidth = null;
	
		/**
		 * If greater than 0, the text will be drawn as a stroke (outline) of the specified width.
		 * @property outline
		 * @type Number
		 **/
		this.outline = 0;
	
		/**
		 * Indicates the line height (vertical distance between baselines) for multi-line text. If null or 0,
		 * the value of getMeasuredLineHeight is used.
		 * @property lineHeight
		 * @type Number
		 **/
		this.lineHeight = 0;
	
		/**
		 * Indicates the maximum width for a line of text before it is wrapped to multiple lines. If null,
		 * the text will not be wrapped.
		 * @property lineWidth
		 * @type Number
		 **/
		this.lineWidth = null;
	}
	var p = createjs.extend(Text, createjs.DisplayObject);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.

	
// static properties:
	/**
	 * @property _workingContext
	 * @type CanvasRenderingContext2D
	 * @private
	 **/
	var canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"));
	if (canvas.getContext) { Text._workingContext = canvas.getContext("2d"); canvas.width = canvas.height = 1; }
	
	
// constants:
	/**
	 * Lookup table for the ratio to offset bounds x calculations based on the textAlign property.
	 * @property H_OFFSETS
	 * @type Object
	 * @protected
	 * @static
	 **/
	Text.H_OFFSETS = {start: 0, left: 0, center: -0.5, end: -1, right: -1};
	
	/**
	 * Lookup table for the ratio to offset bounds y calculations based on the textBaseline property.
	 * @property H_OFFSETS
	 * @type Object
	 * @protected
	 * @static
	 **/
	Text.V_OFFSETS = {top: 0, hanging: -0.01, middle: -0.4, alphabetic: -0.8, ideographic: -0.85, bottom: -1};


// public methods:
	/**
	 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Whether the display object would be visible if drawn to a canvas
	 **/
	p.isVisible = function() {
		var hasContent = this.cacheCanvas || (this.text != null && this.text !== "");
		return !!(this.visible && this.alpha > 0 && this.scaleX != 0 && this.scaleY != 0 && hasContent);
	};

	/**
	 * Draws the Text into the specified context ignoring its visible, alpha, shadow, and transform.
	 * Returns true if the draw was handled (useful for overriding functionality).
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.
	 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
	 * into itself).
	 **/
	p.draw = function(ctx, ignoreCache) {
		if (this.DisplayObject_draw(ctx, ignoreCache)) { return true; }

		var col = this.color || "#000";
		if (this.outline) { ctx.strokeStyle = col; ctx.lineWidth = this.outline*1; }
		else { ctx.fillStyle = col; }
		
		this._drawText(this._prepContext(ctx));
		return true;
	};

	/**
	 * Returns the measured, untransformed width of the text without wrapping. Use getBounds for a more robust value.
	 * @method getMeasuredWidth
	 * @return {Number} The measured, untransformed width of the text.
	 **/
	p.getMeasuredWidth = function() {
		return this._getMeasuredWidth(this.text);
	};

	/**
	 * Returns an approximate line height of the text, ignoring the lineHeight property. This is based on the measured
	 * width of a "M" character multiplied by 1.2, which provides an approximate line height for most fonts.
	 * @method getMeasuredLineHeight
	 * @return {Number} an approximate line height of the text, ignoring the lineHeight property. This is
	 * based on the measured width of a "M" character multiplied by 1.2, which approximates em for most fonts.
	 **/
	p.getMeasuredLineHeight = function() {
		return this._getMeasuredWidth("M")*1.2;
	};

	/**
	 * Returns the approximate height of multi-line text by multiplying the number of lines against either the
	 * <code>lineHeight</code> (if specified) or {{#crossLink "Text/getMeasuredLineHeight"}}{{/crossLink}}. Note that
	 * this operation requires the text flowing logic to run, which has an associated CPU cost.
	 * @method getMeasuredHeight
	 * @return {Number} The approximate height of the untransformed multi-line text.
	 **/
	p.getMeasuredHeight = function() {
		return this._drawText(null,{}).height;
	};

	/**
	 * Docced in superclass.
	 */
	p.getBounds = function() {
		var rect = this.DisplayObject_getBounds();
		if (rect) { return rect; }
		if (this.text == null || this.text === "") { return null; }
		var o = this._drawText(null, {});
		var w = (this.maxWidth && this.maxWidth < o.width) ? this.maxWidth : o.width;
		var x = w * Text.H_OFFSETS[this.textAlign||"left"];
		var lineHeight = this.lineHeight||this.getMeasuredLineHeight();
		var y = lineHeight * Text.V_OFFSETS[this.textBaseline||"top"];
		return this._rectangle.setValues(x, y, w, o.height);
	};
	
	/**
	 * Returns an object with width, height, and lines properties. The width and height are the visual width and height
	 * of the drawn text. The lines property contains an array of strings, one for
	 * each line of text that will be drawn, accounting for line breaks and wrapping. These strings have trailing
	 * whitespace removed.
	 * @method getMetrics
	 * @return {Object} An object with width, height, and lines properties.
	 **/
	p.getMetrics = function() {
		var o = {lines:[]};
		o.lineHeight = this.lineHeight || this.getMeasuredLineHeight();
		o.vOffset = o.lineHeight * Text.V_OFFSETS[this.textBaseline||"top"];
		return this._drawText(null, o, o.lines);
	};

	/**
	 * Returns a clone of the Text instance.
	 * @method clone
	 * @return {Text} a clone of the Text instance.
	 **/
	p.clone = function() {
		return this._cloneProps(new Text(this.text, this.font, this.color));
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Text (text="+  (this.text.length > 20 ? this.text.substr(0, 17)+"..." : this.text) +")]";
	};


// private methods:
	/**
	 * @method _cloneProps
	 * @param {Text} o
	 * @protected
	 * @return {Text} o
	 **/
	p._cloneProps = function(o) {
		this.DisplayObject__cloneProps(o);
		o.textAlign = this.textAlign;
		o.textBaseline = this.textBaseline;
		o.maxWidth = this.maxWidth;
		o.outline = this.outline;
		o.lineHeight = this.lineHeight;
		o.lineWidth = this.lineWidth;
		return o;
	};

	/**
	 * @method _getWorkingContext
	 * @param {CanvasRenderingContext2D} ctx
	 * @return {CanvasRenderingContext2D}
	 * @protected
	 **/
	p._prepContext = function(ctx) {
		ctx.font = this.font||"10px sans-serif";
		ctx.textAlign = this.textAlign||"left";
		ctx.textBaseline = this.textBaseline||"top";
		return ctx;
	};

	/**
	 * Draws multiline text.
	 * @method _drawText
	 * @param {CanvasRenderingContext2D} ctx
	 * @param {Object} o
	 * @param {Array} lines
	 * @return {Object}
	 * @protected
	 **/
	p._drawText = function(ctx, o, lines) {
		var paint = !!ctx;
		if (!paint) {
			ctx = Text._workingContext;
			ctx.save();
			this._prepContext(ctx);
		}
		var lineHeight = this.lineHeight||this.getMeasuredLineHeight();
		
		var maxW = 0, count = 0;
		var hardLines = String(this.text).split(/(?:\r\n|\r|\n)/);
		for (var i=0, l=hardLines.length; i<l; i++) {
			var str = hardLines[i];
			var w = null;
			
			if (this.lineWidth != null && (w = ctx.measureText(str).width) > this.lineWidth) {
				// text wrapping:
				var words = str.split(/(\s)/);
				str = words[0];
				w = ctx.measureText(str).width;
				
				for (var j=1, jl=words.length; j<jl; j+=2) {
					// Line needs to wrap:
					var wordW = ctx.measureText(words[j] + words[j+1]).width;
					if (w + wordW > this.lineWidth) {
						if (paint) { this._drawTextLine(ctx, str, count*lineHeight); }
						if (lines) { lines.push(str); }
						if (w > maxW) { maxW = w; }
						str = words[j+1];
						w = ctx.measureText(str).width;
						count++;
					} else {
						str += words[j] + words[j+1];
						w += wordW;
					}
				}
			}
			
			if (paint) { this._drawTextLine(ctx, str, count*lineHeight); }
			if (lines) { lines.push(str); }
			if (o && w == null) { w = ctx.measureText(str).width; }
			if (w > maxW) { maxW = w; }
			count++;
		}
		
		if (o) {
			o.width = maxW;
			o.height = count*lineHeight;
		}
		if (!paint) { ctx.restore(); }
		return o;
	};

	/**
	 * @method _drawTextLine
	 * @param {CanvasRenderingContext2D} ctx
	 * @param {String} text
	 * @param {Number} y
	 * @protected
	 **/
	p._drawTextLine = function(ctx, text, y) {
		// Chrome 17 will fail to draw the text if the last param is included but null, so we feed it a large value instead:
		if (this.outline) { ctx.strokeText(text, 0, y, this.maxWidth||0xFFFF); }
		else { ctx.fillText(text, 0, y, this.maxWidth||0xFFFF); }
	};
	
	
	/**
	 * @method _getMeasuredWidth
	 * @param {String} text
	 * @protected
	 **/
	p._getMeasuredWidth = function(text) {
		var ctx = Text._workingContext;
		ctx.save();
		var w = this._prepContext(ctx).measureText(text).width;
		ctx.restore();
		return w;
	};


	createjs.Text = createjs.promote(Text, "DisplayObject");
}());

//##############################################################################
// BitmapText.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";


// constructor:
	/**
	 * Displays text using bitmap glyphs defined in a sprite sheet. Multi-line text is supported
	 * using new line characters, but automatic wrapping is not supported. See the 
	 * {{#crossLink "BitmapText/spriteSheet:property"}}{{/crossLink}}
	 * property for more information on defining glyphs.
	 * 
	 * <strong>Important:</strong> BitmapText extends Container, but is not designed to be used as one.
	 * As such, methods like addChild and removeChild are disabled.
	 * @class BitmapText
	 * @extends DisplayObject
	 * @param {String} [text=""] The text to display.
	 * @param {SpriteSheet} [spriteSheet=null] The spritesheet that defines the character glyphs.
	 * @constructor
	 **/
	function BitmapText(text, spriteSheet) {
		this.Container_constructor();
		
		
	// public properties:
		/**
		 * The text to display.
		 * @property text
		 * @type String
		 * @default ""
		 **/
		this.text = text||"";
		
		/**
		 * A SpriteSheet instance that defines the glyphs for this bitmap text. Each glyph/character
		 * should have a single frame animation defined in the sprite sheet named the same as
		 * corresponding character. For example, the following animation definition:
		 *
		 * 		"A": {frames: [0]}
		 *
		 * would indicate that the frame at index 0 of the spritesheet should be drawn for the "A" character. The short form
		 * is also acceptable:
		 * 
		 * 		"A": 0
		 *
		 * Note that if a character in the text is not found in the sprite sheet, it will also
		 * try to use the alternate case (upper or lower).
		 *
		 * See SpriteSheet for more information on defining sprite sheet data.
		 * @property spriteSheet
		 * @type SpriteSheet
		 * @default null
		 **/
		this.spriteSheet = spriteSheet;
	
		/**
		 * The height of each line of text. If 0, then it will use a line height calculated
		 * by checking for the height of the "1", "T", or "L" character (in that order). If
		 * those characters are not defined, it will use the height of the first frame of the
		 * sprite sheet.
		 * @property lineHeight
		 * @type Number
		 * @default 0
		 **/
		this.lineHeight = 0;
	
		/**
		 * This spacing (in pixels) will be added after each character in the output.
		 * @property letterSpacing
		 * @type Number
		 * @default 0
		 **/
		this.letterSpacing = 0;
	
		/**
		 * If a space character is not defined in the sprite sheet, then empty pixels equal to
		 * spaceWidth will be inserted instead. If 0, then it will use a value calculated
		 * by checking for the width of the "1", "l", "E", or "A" character (in that order). If
		 * those characters are not defined, it will use the width of the first frame of the
		 * sprite sheet.
		 * @property spaceWidth
		 * @type Number
		 * @default 0
		 **/
		this.spaceWidth = 0;
		
		
	// private properties:
	 	/**
		 * @property _oldProps
		 * @type Object
		 * @protected
		 **/
		this._oldProps = {text:0,spriteSheet:0,lineHeight:0,letterSpacing:0,spaceWidth:0};
	}
	var p = createjs.extend(BitmapText, createjs.Container);

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.

// static properties:
	/**
	 * BitmapText uses Sprite instances to draw text. To reduce the creation and destruction of instances (and thus garbage collection), it maintains
	 * an internal object pool of sprite instances to reuse. Increasing this value can cause more sprites to be
	 * retained, slightly increasing memory use, but reducing instantiation.
	 * @property maxPoolSize
	 * @type Number
	 * @static
	 * @default 100
	 **/
	BitmapText.maxPoolSize = 100;
	
	/**
	 * Sprite object pool.
	 * @type {Array}
	 * @static
	 * @private
	 */
	BitmapText._spritePool = [];

	
// public methods:
	/**
	 * Docced in superclass.
	 **/
	p.draw = function(ctx, ignoreCache) {
		if (this.DisplayObject_draw(ctx, ignoreCache)) { return; }
		this._updateText();
		this.Container_draw(ctx, ignoreCache);
	};
	
	/**
	 * Docced in superclass.
	 **/
	p.getBounds = function() {
		this._updateText();
		return this.Container_getBounds();
	};
	
	/**
	 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
	 **/
	p.isVisible = function() {
		var hasContent = this.cacheCanvas || (this.spriteSheet && this.spriteSheet.complete && this.text);
		return !!(this.visible && this.alpha > 0 && this.scaleX !== 0 && this.scaleY !== 0 && hasContent);
	};
	
	p.clone = function() {
		return this._cloneProps(new BitmapText(this.text, this.spriteSheet));
	};
	
	/**
	 * <strong>Disabled in BitmapText.</strong>
	 * @method addChild
	 **/
	/**
	 * <strong>Disabled in BitmapText.</strong>
	 * @method addChildAt
	 **/
	/**
	 * <strong>Disabled in BitmapText.</strong>
	 * @method removeChild
	 **/
	/**
	 * <strong>Disabled in BitmapText.</strong>
	 * @method removeChildAt
	 **/
	/**
	 * <strong>Disabled in BitmapText.</strong>
	 * @method removeAllChildren
	 **/
	p.addChild = p.addChildAt = p.removeChild = p.removeChildAt = p.removeAllChildren = function() {};


// private methods:
 	/**
	 * @method _cloneProps
	 * @param {BitmapText} o
	 * @return {BitmapText} o
	 * @protected
	 **/
	p._cloneProps = function(o) {
		this.Container__cloneProps(o);
		o.lineHeight = this.lineHeight;
		o.letterSpacing = this.letterSpacing;
		o.spaceWidth = this.spaceWidth;
		return o;
	};
	
	/**
	 * @method _getFrameIndex
	 * @param {String} character
	 * @param {SpriteSheet} spriteSheet
	 * @return {Number}
	 * @protected
	 **/
	p._getFrameIndex = function(character, spriteSheet) {
		var c, o = spriteSheet.getAnimation(character);
		if (!o) {
			(character != (c = character.toUpperCase())) || (character != (c = character.toLowerCase())) || (c=null);
			if (c) { o = spriteSheet.getAnimation(c); }
		}
		return o && o.frames[0];
	};
	
	/**
	 * @method _getFrame
	 * @param {String} character
	 * @param {SpriteSheet} spriteSheet
	 * @return {Object}
	 * @protected
	 **/
	p._getFrame = function(character, spriteSheet) {
		var index = this._getFrameIndex(character, spriteSheet);
		return index == null ? index : spriteSheet.getFrame(index);
	};
	
	/**
	 * @method _getLineHeight
	 * @param {SpriteSheet} ss
	 * @return {Number}
	 * @protected
	 **/
	p._getLineHeight = function(ss) {
		var frame = this._getFrame("1",ss) || this._getFrame("T",ss) || this._getFrame("L",ss) || ss.getFrame(0);
		return frame ? frame.rect.height : 1;
	};
	/**
	 * @method _getSpaceWidth
	 * @param {SpriteSheet} ss
	 * @return {Number}
	 * @protected
	 **/
	p._getSpaceWidth = function(ss) {
		var frame = this._getFrame("1",ss) || this._getFrame("l",ss) || this._getFrame("e",ss) || this._getFrame("a",ss) || ss.getFrame(0);
		return frame ? frame.rect.width : 1;
	};
	
	/**
	 * @method _drawText
	 * @protected
	 **/
	p._updateText = function() {
		var x=0, y=0, o=this._oldProps, change=false, spaceW=this.spaceWidth, lineH=this.lineHeight, ss=this.spriteSheet;
		var pool=BitmapText._spritePool, kids=this.children, childIndex=0, numKids=kids.length, sprite;
		
		for (var n in o) {
			if (o[n] != this[n]) {
				o[n] = this[n];
				change = true;
			}
		}
		if (!change) { return; }
		
		var hasSpace = !!this._getFrame(" ", ss);
		if (!hasSpace && !spaceW) { spaceW = this._getSpaceWidth(ss); }
		if (!lineH) { lineH = this._getLineHeight(ss); }
		
		for(var i=0, l=this.text.length; i<l; i++) {
			var character = this.text.charAt(i);
			if (character == " " && !hasSpace) {
				x += spaceW;
				continue;
			} else if (character=="\n" || character=="\r") {
				if (character=="\r" && this.text.charAt(i+1) == "\n") { i++; } // crlf
				x = 0;
				y += lineH;
				continue;
			}

			var index = this._getFrameIndex(character, ss);
			if (index == null) { continue; }
			
			if (childIndex < numKids) {
				sprite = kids[childIndex];
			} else {
				kids.push(sprite = pool.length ? pool.pop() : new createjs.Sprite());
				sprite.parent = this;
				numKids++;
			}
			sprite.spriteSheet = ss;
			sprite.gotoAndStop(index);
			sprite.x = x;
			sprite.y = y;
			childIndex++;
			
			x += sprite.getBounds().width + this.letterSpacing;
		}
		while (numKids > childIndex) {
			 // faster than removeChild.
			pool.push(sprite = kids.pop());
			sprite.parent = null;
			numKids--;
		}
		if (pool.length > BitmapText.maxPoolSize) { pool.length = BitmapText.maxPoolSize; }
	};


	createjs.BitmapText = createjs.promote(BitmapText, "Container");
}());

//##############################################################################
// SpriteSheetUtils.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";
	
	
// constructor:
	/**
	 * The SpriteSheetUtils class is a collection of static methods for working with {{#crossLink "SpriteSheet"}}{{/crossLink}}s.
	 * A sprite sheet is a series of images (usually animation frames) combined into a single image on a regular grid. For
	 * example, an animation consisting of 8 100x100 images could be combined into a 400x200 sprite sheet (4 frames across
	 * by 2 high). The SpriteSheetUtils class uses a static interface and should not be instantiated.
	 * @class SpriteSheetUtils
	 * @static
	 **/
	function SpriteSheetUtils() {
		throw "SpriteSheetUtils cannot be instantiated";
	}


// private static properties:
	/**
	 * @property _workingCanvas
	 * @static
	 * @type HTMLCanvasElement | Object
	 * @protected
	*/
	/**
	 * @property _workingContext
	 * @static
	 * @type CanvasRenderingContext2D
	 * @protected
	*/
	var canvas = (createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"));
	if (canvas.getContext) {
		SpriteSheetUtils._workingCanvas = canvas;
		SpriteSheetUtils._workingContext = canvas.getContext("2d");
		canvas.width = canvas.height = 1;
	}


// public static methods:
	/**
	 * <b>This is an experimental method, and may be buggy. Please report issues.</b><br/><br/>
	 * Extends the existing sprite sheet by flipping the original frames horizontally, vertically, or both,
	 * and adding appropriate animation & frame data. The flipped animations will have a suffix added to their names
	 * (_h, _v, _hv as appropriate). Make sure the sprite sheet images are fully loaded before using this method.
	 * <br/><br/>
	 * For example:<br/>
	 * SpriteSheetUtils.addFlippedFrames(mySpriteSheet, true, true);
	 * The above would add frames that are flipped horizontally AND frames that are flipped vertically.
	 * <br/><br/>
	 * Note that you can also flip any display object by setting its scaleX or scaleY to a negative value. On some
	 * browsers (especially those without hardware accelerated canvas) this can result in slightly degraded performance,
	 * which is why addFlippedFrames is available.
	 * @method addFlippedFrames
	 * @static
	 * @param {SpriteSheet} spriteSheet
	 * @param {Boolean} horizontal If true, horizontally flipped frames will be added.
	 * @param {Boolean} vertical If true, vertically flipped frames will be added.
	 * @param {Boolean} both If true, frames that are flipped both horizontally and vertically will be added.
	 * @deprecated Modern browsers perform better when flipping via a transform (ex. scaleX=-1) rendering this obsolete.
	 **/
	SpriteSheetUtils.addFlippedFrames = function(spriteSheet, horizontal, vertical, both) {
		if (!horizontal && !vertical && !both) { return; }

		var count = 0;
		if (horizontal) { SpriteSheetUtils._flip(spriteSheet,++count,true,false); }
		if (vertical) { SpriteSheetUtils._flip(spriteSheet,++count,false,true); }
		if (both) { SpriteSheetUtils._flip(spriteSheet,++count,true,true); }
	};

	/**
	 * Returns a single frame of the specified sprite sheet as a new PNG image. An example of when this may be useful is
	 * to use a spritesheet frame as the source for a bitmap fill.
	 *
	 * <strong>WARNING:</strong> In almost all cases it is better to display a single frame using a {{#crossLink "Sprite"}}{{/crossLink}}
	 * with a {{#crossLink "Sprite/gotoAndStop"}}{{/crossLink}} call than it is to slice out a frame using this
	 * method and display it with a Bitmap instance. You can also crop an image using the {{#crossLink "Bitmap/sourceRect"}}{{/crossLink}}
	 * property of {{#crossLink "Bitmap"}}{{/crossLink}}.
	 *
	 * The extractFrame method may cause cross-domain warnings since it accesses pixels directly on the canvas.
	 * @method extractFrame
	 * @static
	 * @param {SpriteSheet} spriteSheet The SpriteSheet instance to extract a frame from.
	 * @param {Number|String} frameOrAnimation The frame number or animation name to extract. If an animation
	 * name is specified, only the first frame of the animation will be extracted.
	 * @return {HTMLImageElement} a single frame of the specified sprite sheet as a new PNG image.
	*/
	SpriteSheetUtils.extractFrame = function(spriteSheet, frameOrAnimation) {
		if (isNaN(frameOrAnimation)) {
			frameOrAnimation = spriteSheet.getAnimation(frameOrAnimation).frames[0];
		}
		var data = spriteSheet.getFrame(frameOrAnimation);
		if (!data) { return null; }
		var r = data.rect;
		var canvas = SpriteSheetUtils._workingCanvas;
		canvas.width = r.width;
		canvas.height = r.height;
		SpriteSheetUtils._workingContext.drawImage(data.image, r.x, r.y, r.width, r.height, 0, 0, r.width, r.height);
		var img = document.createElement("img");
		img.src = canvas.toDataURL("image/png");
		return img;
	};

	/**
	 * Merges the rgb channels of one image with the alpha channel of another. This can be used to combine a compressed
	 * JPEG image containing color data with a PNG32 monochromatic image containing alpha data. With certain types of
	 * images (those with detail that lend itself to JPEG compression) this can provide significant file size savings
	 * versus a single RGBA PNG32. This method is very fast (generally on the order of 1-2 ms to run).
	 * @method mergeAlpha
	 * @static
	 * @param {HTMLImageElement} rbgImage The image (or canvas) containing the RGB channels to use.
	 * @param {HTMLImageElement} alphaImage The image (or canvas) containing the alpha channel to use.
	 * @param {HTMLCanvasElement} canvas Optional. If specified, this canvas will be used and returned. If not, a new canvas will be created.
	 * @return {HTMLCanvasElement} A canvas with the combined image data. This can be used as a source for Bitmap or SpriteSheet.
	 * @deprecated Tools such as ImageAlpha generally provide better results. This will be moved to sandbox in the future.
	*/
	SpriteSheetUtils.mergeAlpha = function(rgbImage, alphaImage, canvas) {
		if (!canvas) { canvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"); }
		canvas.width = Math.max(alphaImage.width, rgbImage.width);
		canvas.height = Math.max(alphaImage.height, rgbImage.height);
		var ctx = canvas.getContext("2d");
		ctx.save();
		ctx.drawImage(rgbImage,0,0);
		ctx.globalCompositeOperation = "destination-in";
		ctx.drawImage(alphaImage,0,0);
		ctx.restore();
		return canvas;
	};


// private static methods:
	SpriteSheetUtils._flip = function(spriteSheet, count, h, v) {
		var imgs = spriteSheet._images;
		var canvas = SpriteSheetUtils._workingCanvas;
		var ctx = SpriteSheetUtils._workingContext;
		var il = imgs.length/count;
		for (var i=0;i<il;i++) {
			var src = imgs[i];
			src.__tmp = i; // a bit hacky, but faster than doing indexOf below.
			ctx.setTransform(1,0,0,1,0,0);
			ctx.clearRect(0,0,canvas.width+1,canvas.height+1);
			canvas.width = src.width;
			canvas.height = src.height;
			ctx.setTransform(h?-1:1, 0, 0, v?-1:1, h?src.width:0, v?src.height:0);
			ctx.drawImage(src,0,0);
			var img = document.createElement("img");
			img.src = canvas.toDataURL("image/png");
			// work around a strange bug in Safari:
			img.width = src.width;
			img.height = src.height;
			imgs.push(img);
		}

		var frames = spriteSheet._frames;
		var fl = frames.length/count;
		for (i=0;i<fl;i++) {
			src = frames[i];
			var rect = src.rect.clone();
			img = imgs[src.image.__tmp+il*count];

			var frame = {image:img,rect:rect,regX:src.regX,regY:src.regY};
			if (h) {
				rect.x = img.width-rect.x-rect.width; // update rect
				frame.regX = rect.width-src.regX; // update registration point
			}
			if (v) {
				rect.y = img.height-rect.y-rect.height;  // update rect
				frame.regY = rect.height-src.regY; // update registration point
			}
			frames.push(frame);
		}

		var sfx = "_"+(h?"h":"")+(v?"v":"");
		var names = spriteSheet._animations;
		var data = spriteSheet._data;
		var al = names.length/count;
		for (i=0;i<al;i++) {
			var name = names[i];
			src = data[name];
			var anim = {name:name+sfx,speed:src.speed,next:src.next,frames:[]};
			if (src.next) { anim.next += sfx; }
			frames = src.frames;
			for (var j=0,l=frames.length;j<l;j++) {
				anim.frames.push(frames[j]+fl*count);
			}
			data[anim.name] = anim;
			names.push(anim.name);
		}
	};


	createjs.SpriteSheetUtils = SpriteSheetUtils;
}());

//##############################################################################
// SpriteSheetBuilder.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * The SpriteSheetBuilder allows you to generate sprite sheets at run time from any display object. This can allow
	 * you to maintain your assets as vector graphics (for low file size), and render them at run time as sprite sheets
	 * for better performance.
	 *
	 * Sprite sheets can be built either synchronously, or asynchronously, so that large sprite sheets can be generated
	 * without locking the UI.
	 *
	 * Note that the "images" used in the generated sprite sheet are actually canvas elements, and that they will be sized
	 * to the nearest power of 2 up to the value of <code>maxWidth</code> or <code>maxHeight</code>.
	 * @class SpriteSheetBuilder
	 * @extends EventDispatcher
	 * @constructor
	 **/
	function SpriteSheetBuilder() {
		this.EventDispatcher_constructor();
		
	// public properties:
		/**
		 * The maximum width for the images (not individual frames) in the generated sprite sheet. It is recommended to use
		 * a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max dimensions, then
		 * additional images will be created as needed.
		 * @property maxWidth
		 * @type Number
		 * @default 2048
		*/
		this.maxWidth = 2048;
	
		/**
		 * The maximum height for the images (not individual frames) in the generated sprite sheet. It is recommended to use
		 * a power of 2 for this value (ex. 1024, 2048, 4096). If the frames cannot all fit within the max dimensions, then
		 * additional images will be created as needed.
		 * @property maxHeight
		 * @type Number
		 * @default 2048
		 **/
		this.maxHeight = 2048;
	
		/**
		 * The sprite sheet that was generated. This will be null before a build is completed successfully.
		 * @property spriteSheet
		 * @type SpriteSheet
		 **/
		this.spriteSheet = null;
	
		/**
		 * The scale to apply when drawing all frames to the sprite sheet. This is multiplied against any scale specified
		 * in the addFrame call. This can be used, for example, to generate a sprite sheet at run time that is tailored to
		 * the a specific device resolution (ex. tablet vs mobile).
		 * @property scale
		 * @type Number
		 * @default 1
		 **/
		this.scale = 1;
	
		/**
		* The padding to use between frames. This is helpful to preserve antialiasing on drawn vector content.
		* @property padding
		* @type Number
		* @default 1
		**/
		this.padding = 1;
	
		/**
		 * A number from 0.01 to 0.99 that indicates what percentage of time the builder can use. This can be
		 * thought of as the number of seconds per second the builder will use. For example, with a timeSlice value of 0.3,
		 * the builder will run 20 times per second, using approximately 15ms per build (30% of available time, or 0.3s per second).
		 * Defaults to 0.3.
		 * @property timeSlice
		 * @type Number
		 * @default 0.3
		 **/
		this.timeSlice = 0.3;
	
		/**
		 * A value between 0 and 1 that indicates the progress of a build, or -1 if a build has not
		 * been initiated.
		 * @property progress
		 * @type Number
		 * @default -1
		 * @readonly
		 **/
		this.progress = -1;
	
	
	// private properties:
		/**
		 * @property _frames
		 * @protected
		 * @type Array
		 **/
		this._frames = [];
	
		/**
		 * @property _animations
		 * @protected
		 * @type Array
		 **/
		this._animations = {};
	
		/**
		 * @property _data
		 * @protected
		 * @type Array
		 **/
		this._data = null;
	
		/**
		 * @property _nextFrameIndex
		 * @protected
		 * @type Number
		 **/
		this._nextFrameIndex = 0;
	
		/**
		 * @property _index
		 * @protected
		 * @type Number
		 **/
		this._index = 0;
	
		/**
		 * @property _timerID
		 * @protected
		 * @type Number
		 **/
		this._timerID = null;
	
		/**
		 * @property _scale
		 * @protected
		 * @type Number
		 **/
		this._scale = 1;
	}
	var p = createjs.extend(SpriteSheetBuilder, createjs.EventDispatcher);

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// constants:
	SpriteSheetBuilder.ERR_DIMENSIONS = "frame dimensions exceed max spritesheet dimensions";
	SpriteSheetBuilder.ERR_RUNNING = "a build is already running";

// events:
	/**
	 * Dispatched when a build completes.
	 * @event complete
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @since 0.6.0
	 */

	/**
	 * Dispatched when an asynchronous build has progress.
	 * @event progress
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Number} progress The current progress value (0-1).
	 * @since 0.6.0
	 */


// public methods:
	/**
	 * Adds a frame to the {{#crossLink "SpriteSheet"}}{{/crossLink}}. Note that the frame will not be drawn until you
	 * call {{#crossLink "SpriteSheetBuilder/build"}}{{/crossLink}} method. The optional setup params allow you to have
	 * a function run immediately before the draw occurs. For example, this allows you to add a single source multiple
	 * times, but manipulate it or its children to change it to generate different frames.
	 *
	 * Note that the source's transformations (x, y, scale, rotate, alpha) will be ignored, except for regX/Y. To apply
	 * transforms to a source object and have them captured in the sprite sheet, simply place it into a {{#crossLink "Container"}}{{/crossLink}}
	 * and pass in the Container as the source.
	 * @method addFrame
	 * @param {DisplayObject} source The source {{#crossLink "DisplayObject"}}{{/crossLink}}  to draw as the frame.
	 * @param {Rectangle} [sourceRect] A {{#crossLink "Rectangle"}}{{/crossLink}} defining the portion of the
	 * source to draw to the frame. If not specified, it will look for a <code>getBounds</code> method, bounds property,
	 * or <code>nominalBounds</code> property on the source to use. If one is not found, the frame will be skipped.
	 * @param {Number} [scale=1] Optional. The scale to draw this frame at. Default is 1.
	 * @param {Function} [setupFunction] A function to call immediately before drawing this frame. It will be called with two parameters: the source, and setupData.
	 * @param {Object} [setupData] Arbitrary setup data to pass to setupFunction as the second parameter.
	 * @return {Number} The index of the frame that was just added, or null if a sourceRect could not be determined.
	 **/
	p.addFrame = function(source, sourceRect, scale, setupFunction, setupData) {
		if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
		var rect = sourceRect||source.bounds||source.nominalBounds;
		if (!rect&&source.getBounds) { rect = source.getBounds(); }
		if (!rect) { return null; }
		scale = scale||1;
		return this._frames.push({source:source, sourceRect:rect, scale:scale, funct:setupFunction, data:setupData, index:this._frames.length, height:rect.height*scale})-1;
	};

	/**
	 * Adds an animation that will be included in the created sprite sheet.
	 * @method addAnimation
	 * @param {String} name The name for the animation.
	 * @param {Array} frames An array of frame indexes that comprise the animation. Ex. [3,6,5] would describe an animation
	 * that played frame indexes 3, 6, and 5 in that order.
	 * @param {String} [next] Specifies the name of the animation to continue to after this animation ends. You can
	 * also pass false to have the animation stop when it ends. By default it will loop to the start of the same animation.
	 * @param {Number} [frequency] Specifies a frame advance frequency for this animation. For example, a value
	 * of 2 would cause the animation to advance every second tick.
	 **/
	p.addAnimation = function(name, frames, next, frequency) {
		if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
		this._animations[name] = {frames:frames, next:next, frequency:frequency};
	};

	/**
	 * This will take a MovieClip instance, and add its frames and labels to this builder. Labels will be added as an animation
	 * running from the label index to the next label. For example, if there is a label named "foo" at frame 0 and a label
	 * named "bar" at frame 10, in a MovieClip with 15 frames, it will add an animation named "foo" that runs from frame
	 * index 0 to 9, and an animation named "bar" that runs from frame index 10 to 14.
	 *
	 * Note that this will iterate through the full MovieClip with actionsEnabled set to false, ending on the last frame.
	 * @method addMovieClip
	 * @param {MovieClip} source The source MovieClip instance to add to the sprite sheet.
	 * @param {Rectangle} [sourceRect] A {{#crossLink "Rectangle"}}{{/crossLink}} defining the portion of the source to
	 * draw to the frame. If not specified, it will look for a <code>getBounds</code> method, <code>frameBounds</code>
	 * Array, <code>bounds</code> property, or <code>nominalBounds</code> property on the source to use. If one is not
	 * found, the MovieClip will be skipped.
	 * @param {Number} [scale=1] The scale to draw the movie clip at.
	 * @param {Function} [setupFunction] A function to call immediately before drawing each frame. It will be called with three parameters: the source, setupData, and the frame index.
	 * @param {Object} [setupData] Arbitrary setup data to pass to setupFunction as the second parameter.
	 * @param {Function} [labelFunction] This method will be called for each movieclip label that is added with four parameters: the label name, the source movieclip instance, the starting frame index (in the movieclip timeline) and the end index. It must return a new name for the label/animation, or false to exclude the label.
	 **/
	p.addMovieClip = function(source, sourceRect, scale, setupFunction, setupData, labelFunction) {
		if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
		var rects = source.frameBounds;
		var rect = sourceRect||source.bounds||source.nominalBounds;
		if (!rect&&source.getBounds) { rect = source.getBounds(); }
		if (!rect && !rects) { return; }

		var i, l, baseFrameIndex = this._frames.length;
		var duration = source.timeline.duration;
		for (i=0; i<duration; i++) {
			var r = (rects&&rects[i]) ? rects[i] : rect;
			this.addFrame(source, r, scale, this._setupMovieClipFrame, {i:i, f:setupFunction, d:setupData});
		}
		var labels = source.timeline._labels;
		var lbls = [];
		for (var n in labels) {
			lbls.push({index:labels[n], label:n});
		}
		if (lbls.length) {
			lbls.sort(function(a,b){ return a.index-b.index; });
			for (i=0,l=lbls.length; i<l; i++) {
				var label = lbls[i].label;
				var start = baseFrameIndex+lbls[i].index;
				var end = baseFrameIndex+((i == l-1) ? duration : lbls[i+1].index);
				var frames = [];
				for (var j=start; j<end; j++) { frames.push(j); }
				if (labelFunction) {
					label = labelFunction(label, source, start, end);
					if (!label) { continue; }
				}
				this.addAnimation(label, frames, true); // for now, this loops all animations.
			}
		}
	};

	/**
	 * Builds a SpriteSheet instance based on the current frames.
	 * @method build
	 * @return {SpriteSheet} The created SpriteSheet instance, or null if a build is already running or an error occurred.
	 **/
	p.build = function() {
		if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
		this._startBuild();
		while (this._drawNext()) {}
		this._endBuild();
		return this.spriteSheet;
	};

	/**
	 * Asynchronously builds a {{#crossLink "SpriteSheet"}}{{/crossLink}} instance based on the current frames. It will
	 * run 20 times per second, using an amount of time defined by <code>timeSlice</code>. When it is complete it will
	 * call the specified callback.
	 * @method buildAsync
	 * @param {Number} [timeSlice] Sets the timeSlice property on this instance.
	 **/
	p.buildAsync = function(timeSlice) {
		if (this._data) { throw SpriteSheetBuilder.ERR_RUNNING; }
		this.timeSlice = timeSlice;
		this._startBuild();
		var _this = this;
		this._timerID = setTimeout(function() { _this._run(); }, 50-Math.max(0.01, Math.min(0.99, this.timeSlice||0.3))*50);
	};

	/**
	 * Stops the current asynchronous build.
	 * @method stopAsync
	 **/
	p.stopAsync = function() {
		clearTimeout(this._timerID);
		this._data = null;
	};

	/**
	 * SpriteSheetBuilder instances cannot be cloned.
	 * @method clone
	 **/
	p.clone = function() {
		throw("SpriteSheetBuilder cannot be cloned.");
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[SpriteSheetBuilder]";
	};


// private methods:
	/**
	 * @method _startBuild
	 * @protected
	 **/
	p._startBuild = function() {
		var pad = this.padding||0;
		this.progress = 0;
		this.spriteSheet = null;
		this._index = 0;
		this._scale = this.scale;
		var dataFrames = [];
		this._data = {
			images: [],
			frames: dataFrames,
			animations: this._animations // TODO: should we "clone" _animations in case someone adds more animations after a build?
		};

		var frames = this._frames.slice();
		frames.sort(function(a,b) { return (a.height<=b.height) ? -1 : 1; });

		if (frames[frames.length-1].height+pad*2 > this.maxHeight) { throw SpriteSheetBuilder.ERR_DIMENSIONS; }
		var y=0, x=0;
		var img = 0;
		while (frames.length) {
			var o = this._fillRow(frames, y, img, dataFrames, pad);
			if (o.w > x) { x = o.w; }
			y += o.h;
			if (!o.h || !frames.length) {
				var canvas = createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");
				canvas.width = this._getSize(x,this.maxWidth);
				canvas.height = this._getSize(y,this.maxHeight);
				this._data.images[img] = canvas;
				if (!o.h) {
					x=y=0;
					img++;
				}
			}
		}
	};
	
	/**
	 * @method _setupMovieClipFrame
	 * @protected
	 * @return {Number} The width & height of the row.
	 **/
	p._setupMovieClipFrame = function(source, data) {
		var ae = source.actionsEnabled;
		source.actionsEnabled = false;
		source.gotoAndStop(data.i);
		source.actionsEnabled = ae;
		data.f&&data.f(source, data.d, data.i);
	};

	/**
	 * @method _getSize
	 * @protected
	 * @return {Number} The width & height of the row.
	 **/
	p._getSize = function(size,max) {
		var pow = 4;
		while (Math.pow(2,++pow) < size){}
		return Math.min(max,Math.pow(2,pow));
	};

	/**
	 * @method _fillRow
	 * @param {Array} frames
	 * @param {Number} y
	 * @param {HTMLImageElement} img
	 * @param {Object} dataFrames
	 * @param {Number} pad
	 * @protected
	 * @return {Number} The width & height of the row.
	 **/
	p._fillRow = function(frames, y, img, dataFrames, pad) {
		var w = this.maxWidth;
		var maxH = this.maxHeight;
		y += pad;
		var h = maxH-y;
		var x = pad;
		var height = 0;
		for (var i=frames.length-1; i>=0; i--) {
			var frame = frames[i];
			var sc = this._scale*frame.scale;
			var rect = frame.sourceRect;
			var source = frame.source;
			var rx = Math.floor(sc*rect.x-pad);
			var ry = Math.floor(sc*rect.y-pad);
			var rh = Math.ceil(sc*rect.height+pad*2);
			var rw = Math.ceil(sc*rect.width+pad*2);
			if (rw > w) { throw SpriteSheetBuilder.ERR_DIMENSIONS; }
			if (rh > h || x+rw > w) { continue; }
			frame.img = img;
			frame.rect = new createjs.Rectangle(x,y,rw,rh);
			height = height || rh;
			frames.splice(i,1);
			dataFrames[frame.index] = [x,y,rw,rh,img,Math.round(-rx+sc*source.regX-pad),Math.round(-ry+sc*source.regY-pad)];
			x += rw;
		}
		return {w:x, h:height};
	};

	/**
	 * @method _endBuild
	 * @protected
	 **/
	p._endBuild = function() {
		this.spriteSheet = new createjs.SpriteSheet(this._data);
		this._data = null;
		this.progress = 1;
		this.dispatchEvent("complete");
	};

	/**
	 * @method _run
	 * @protected
	 **/
	p._run = function() {
		var ts = Math.max(0.01, Math.min(0.99, this.timeSlice||0.3))*50;
		var t = (new Date()).getTime()+ts;
		var complete = false;
		while (t > (new Date()).getTime()) {
			if (!this._drawNext()) { complete = true; break; }
		}
		if (complete) {
			this._endBuild();
		} else {
			var _this = this;
			this._timerID = setTimeout(function() { _this._run(); }, 50-ts);
		}
		var p = this.progress = this._index/this._frames.length;
		if (this.hasEventListener("progress")) {
			var evt = new createjs.Event("progress");
			evt.progress = p;
			this.dispatchEvent(evt);
		}
	};

	/**
	 * @method _drawNext
	 * @protected
	 * @return Boolean Returns false if this is the last draw.
	 **/
	p._drawNext = function() {
		var frame = this._frames[this._index];
		var sc = frame.scale*this._scale;
		var rect = frame.rect;
		var sourceRect = frame.sourceRect;
		var canvas = this._data.images[frame.img];
		var ctx = canvas.getContext("2d");
		frame.funct&&frame.funct(frame.source, frame.data);
		ctx.save();
		ctx.beginPath();
		ctx.rect(rect.x, rect.y, rect.width, rect.height);
		ctx.clip();
		ctx.translate(Math.ceil(rect.x-sourceRect.x*sc), Math.ceil(rect.y-sourceRect.y*sc));
		ctx.scale(sc,sc);
		frame.source.draw(ctx); // display object will draw itself.
		ctx.restore();
		return (++this._index) < this._frames.length;
	};


	createjs.SpriteSheetBuilder = createjs.promote(SpriteSheetBuilder, "EventDispatcher");
}());

//##############################################################################
// DOMElement.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * <b>This class is still experimental, and more advanced use is likely to be buggy. Please report bugs.</b>
	 *
	 * A DOMElement allows you to associate a HTMLElement with the display list. It will be transformed
	 * within the DOM as though it is child of the {{#crossLink "Container"}}{{/crossLink}} it is added to. However, it is
	 * not rendered to canvas, and as such will retain whatever z-index it has relative to the canvas (ie. it will be
	 * drawn in front of or behind the canvas).
	 *
	 * The position of a DOMElement is relative to their parent node in the DOM. It is recommended that
	 * the DOM Object be added to a div that also contains the canvas so that they share the same position
	 * on the page.
	 *
	 * DOMElement is useful for positioning HTML elements over top of canvas content, and for elements
	 * that you want to display outside the bounds of the canvas. For example, a tooltip with rich HTML
	 * content.
	 *
	 * <h4>Mouse Interaction</h4>
	 *
	 * DOMElement instances are not full EaselJS display objects, and do not participate in EaselJS mouse
	 * events or support methods like hitTest. To get mouse events from a DOMElement, you must instead add handlers to
	 * the htmlElement (note, this does not support EventDispatcher)
	 *
	 *      var domElement = new createjs.DOMElement(htmlElement);
	 *      domElement.htmlElement.onclick = function() {
	 *          console.log("clicked");
	 *      }
	 *
	 * @class DOMElement
	 * @extends DisplayObject
	 * @constructor
	 * @param {HTMLElement} htmlElement A reference or id for the DOM element to manage.
	 */
	function DOMElement(htmlElement) {
		this.DisplayObject_constructor();
		
		if (typeof(htmlElement)=="string") { htmlElement = document.getElementById(htmlElement); }
		this.mouseEnabled = false;
		
		var style = htmlElement.style;
		style.position = "absolute";
		style.transformOrigin = style.WebkitTransformOrigin = style.msTransformOrigin = style.MozTransformOrigin = style.OTransformOrigin = "0% 0%";
		
		
	// public properties:
		/**
		 * The DOM object to manage.
		 * @property htmlElement
		 * @type HTMLElement
		 */
		this.htmlElement = htmlElement;
	
	
	// private properties:
		/**
		 * @property _oldMtx
		 * @type Matrix2D
		 * @protected
		 */
		this._oldProps = null;
	}
	var p = createjs.extend(DOMElement, createjs.DisplayObject);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// public methods:
	/**
	 * Returns true or false indicating whether the display object would be visible if drawn to a canvas.
	 * This does not account for whether it would be visible within the boundaries of the stage.
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method isVisible
	 * @return {Boolean} Boolean indicating whether the display object would be visible if drawn to a canvas
	 */
	p.isVisible = function() {
		return this.htmlElement != null;
	};

	/**
	 * Draws the display object into the specified context ignoring its visible, alpha, shadow, and transform.
	 * Returns true if the draw was handled (useful for overriding functionality).
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 * @param {Boolean} ignoreCache Indicates whether the draw operation should ignore any current cache.
	 * For example, used for drawing the cache (to prevent it from simply drawing an existing cache back
	 * into itself).
	 * @return {Boolean}
	 */
	p.draw = function(ctx, ignoreCache) {
		// this relies on the _tick method because draw isn't called if the parent is not visible.
		// the actual update happens in _handleDrawEnd
		return true;
	};

	/**
	 * Not applicable to DOMElement.
	 * @method cache
	 */
	p.cache = function() {};

	/**
	 * Not applicable to DOMElement.
	 * @method uncache
	 */
	p.uncache = function() {};

	/**
	 * Not applicable to DOMElement.
	 * @method updateCache
	 */
	p.updateCache = function() {};

	/**
	 * Not applicable to DOMElement.
	 * @method hitTest
	 */
	p.hitTest = function() {};

	/**
	 * Not applicable to DOMElement.
	 * @method localToGlobal
	 */
	p.localToGlobal = function() {};

	/**
	 * Not applicable to DOMElement.
	 * @method globalToLocal
	 */
	p.globalToLocal = function() {};

	/**
	 * Not applicable to DOMElement.
	 * @method localToLocal
	 */
	p.localToLocal = function() {};

	/**
	 * DOMElement cannot be cloned. Throws an error.
	 * @method clone
	 */
	p.clone = function() {
		throw("DOMElement cannot be cloned.")
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 */
	p.toString = function() {
		return "[DOMElement (name="+  this.name +")]";
	};

	/**
     * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances
	 * are not full EaselJS display objects and do not participate in EaselJS mouse events.
	 * @event click
	 */

     /**
     * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances
 	 * are not full EaselJS display objects and do not participate in EaselJS mouse events.
	 * @event dblClick
	 */

     /**
      * Interaction events should be added to `htmlElement`, and not the DOMElement instance, since DOMElement instances
 	  * are not full EaselJS display objects and do not participate in EaselJS mouse events.
	  * @event mousedown
	  */

     /**
      * The HTMLElement can listen for the mouseover event, not the DOMElement instance.
      * Since DOMElement instances are not full EaselJS display objects and do not participate in EaselJS mouse events.
      * @event mouseover
	  */

     /**
      * Not applicable to DOMElement.
	  * @event tick
	  */


// private methods:
	/**
	 * @method _tick
	 * @param {Object} evtObj An event object that will be dispatched to all tick listeners. This object is reused between dispatchers to reduce construction & GC costs.
	 * function.
	 * @protected
	 */
	p._tick = function(evtObj) {
		var stage = this.getStage();
		stage&&stage.on("drawend", this._handleDrawEnd, this, true);
		this.DisplayObject__tick(evtObj);
	};
	
	/**
	 * @method _handleDrawEnd
	 * @param {Event} evt
	 * @protected
	 */
	p._handleDrawEnd = function(evt) {
		var o = this.htmlElement;
		if (!o) { return; }
		var style = o.style;
		
		var props = this.getConcatenatedDisplayProps(this._props), mtx = props.matrix;
		
		var visibility = props.visible ? "visible" : "hidden";
		if (visibility != style.visibility) { style.visibility = visibility; }
		if (!props.visible) { return; }
		
		var oldProps = this._oldProps, oldMtx = oldProps&&oldProps.matrix;
		var n = 10000; // precision
		
		if (!oldMtx || !oldMtx.equals(mtx)) {
			var str = "matrix(" + (mtx.a*n|0)/n +","+ (mtx.b*n|0)/n +","+ (mtx.c*n|0)/n +","+ (mtx.d*n|0)/n +","+ (mtx.tx+0.5|0);
			style.transform = style.WebkitTransform = style.OTransform = style.msTransform = str +","+ (mtx.ty+0.5|0) +")";
			style.MozTransform = str +"px,"+ (mtx.ty+0.5|0) +"px)";
			if (!oldProps) { oldProps = this._oldProps = new createjs.DisplayProps(true, NaN); }
			oldProps.matrix.copy(mtx);
		}
		
		if (oldProps.alpha != props.alpha) {
			style.opacity = ""+(props.alpha*n|0)/n;
			oldProps.alpha = props.alpha;
		}
	};


	createjs.DOMElement = createjs.promote(DOMElement, "DisplayObject");
}());

//##############################################################################
// Filter.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Base class that all filters should inherit from. Filters need to be applied to objects that have been cached using
	 * the {{#crossLink "DisplayObject/cache"}}{{/crossLink}} method. If an object changes, please cache it again, or use
	 * {{#crossLink "DisplayObject/updateCache"}}{{/crossLink}}. Note that the filters must be applied before caching.
	 *
	 * <h4>Example</h4>
	 *
	 *      myInstance.filters = [
	 *          new createjs.ColorFilter(0, 0, 0, 1, 255, 0, 0),
	 *          new createjs.BlurFilter(5, 5, 10)
	 *      ];
	 *      myInstance.cache(0,0, 100, 100);
	 *
	 * Note that each filter can implement a {{#crossLink "Filter/getBounds"}}{{/crossLink}} method, which returns the
	 * margins that need to be applied in order to fully display the filter. For example, the {{#crossLink "BlurFilter"}}{{/crossLink}}
	 * will cause an object to feather outwards, resulting in a margin around the shape.
	 *
	 * <h4>EaselJS Filters</h4>
	 * EaselJS comes with a number of pre-built filters. Note that individual filters are not compiled into the minified
	 * version of EaselJS. To use them, you must include them manually in the HTML.
	 * <ul><li>{{#crossLink "AlphaMapFilter"}}{{/crossLink}} : Map a greyscale image to the alpha channel of a display object</li>
	 *      <li>{{#crossLink "AlphaMaskFilter"}}{{/crossLink}}: Map an image's alpha channel to the alpha channel of a display object</li>
	 *      <li>{{#crossLink "BlurFilter"}}{{/crossLink}}: Apply vertical and horizontal blur to a display object</li>
	 *      <li>{{#crossLink "ColorFilter"}}{{/crossLink}}: Color transform a display object</li>
	 *      <li>{{#crossLink "ColorMatrixFilter"}}{{/crossLink}}: Transform an image using a {{#crossLink "ColorMatrix"}}{{/crossLink}}</li>
	 * </ul>
	 *
	 * @class Filter
	 * @constructor
	 **/
	function Filter() {}
	var p = Filter.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// public methods:
	/**
	 * Provides padding values for this filter. That is, how much the filter will extend the visual bounds of an object it is applied to.
	 * @method getBounds
	 * @param {Rectangle} [rect] If specified, the provided Rectangle instance will be expanded by the padding amounts and returned.
	 * @return {Rectangle} If a `rect` param was provided, it is returned. If not, either a new rectangle with the padding values, or null if no padding is required for this filter.
	 **/
	p.getBounds = function(rect) {
		return rect;
	};

	/**
	 * Applies the filter to the specified context.
	 * @method applyFilter
	 * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.
	 * @param {Number} x The x position to use for the source rect.
	 * @param {Number} y The y position to use for the source rect.
	 * @param {Number} width The width to use for the source rect.
	 * @param {Number} height The height to use for the source rect.
	 * @param {CanvasRenderingContext2D} [targetCtx] The 2D context to draw the result to. Defaults to the context passed to ctx.
	 * @param {Number} [targetX] The x position to draw the result to. Defaults to the value passed to x.
	 * @param {Number} [targetY] The y position to draw the result to. Defaults to the value passed to y.
	 * @return {Boolean} If the filter was applied successfully.
	 **/
	p.applyFilter = function(ctx, x, y, width, height, targetCtx, targetX, targetY) {
		// this is the default behaviour because most filters access pixel data. It is overridden when not needed.
		targetCtx = targetCtx || ctx;
		if (targetX == null) { targetX = x; }
		if (targetY == null) { targetY = y; }
		try {
			var imageData = ctx.getImageData(x, y, width, height);
		} catch (e) {
			return false;
		}
		if (this._applyFilter(imageData)) {
			targetCtx.putImageData(imageData, targetX, targetY);
			return true;
		}
		return false;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Filter]";
	};

	/**
	 * Returns a clone of this Filter instance.
	 * @method clone
	 * @return {Filter} A clone of the current Filter instance.
	 **/
	p.clone = function() {
		return new Filter();
	};
	
// private methods:
	/**
	 * @method _applyFilter
	 * @param {ImageData} imageData Target ImageData instance.
	 * @return {Boolean}
	 **/
	p._applyFilter = function(imageData) { return true; };


	createjs.Filter = Filter;
}());

//##############################################################################
// BlurFilter.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Applies a box blur to DisplayObjects. Note that this filter is fairly CPU intensive, particularly if the quality is
	 * set higher than 1.
	 *
	 * <h4>Example</h4>
	 * This example creates a red circle, and then applies a 5 pixel blur to it. It uses the {{#crossLink "Filter/getBounds"}}{{/crossLink}}
	 * method to account for the spread that the blur causes.
	 *
	 *      var shape = new createjs.Shape().set({x:100,y:100});
	 *      shape.graphics.beginFill("#ff0000").drawCircle(0,0,50);
	 *
	 *      var blurFilter = new createjs.BlurFilter(5, 5, 1);
	 *      shape.filters = [blurFilter];
	 *      var bounds = blurFilter.getBounds();
	 *
	 *      shape.cache(-50+bounds.x, -50+bounds.y, 100+bounds.width, 100+bounds.height);
	 *
	 * See {{#crossLink "Filter"}}{{/crossLink}} for an more information on applying filters.
	 * @class BlurFilter
	 * @extends Filter
	 * @constructor
	 * @param {Number} [blurX=0] The horizontal blur radius in pixels.
	 * @param {Number} [blurY=0] The vertical blur radius in pixels.
	 * @param {Number} [quality=1] The number of blur iterations.
	 **/
	function BlurFilter( blurX, blurY, quality) {
		if ( isNaN(blurX) || blurX < 0 ) blurX = 0;
		if ( isNaN(blurY) || blurY < 0 ) blurY = 0;
		if ( isNaN(quality) || quality < 1  ) quality = 1;


		// public properties:
		/**
		 * Horizontal blur radius in pixels
		 * @property blurX
		 * @default 0
		 * @type Number
		 **/
		this.blurX = blurX | 0;

		/**
		 * Vertical blur radius in pixels
		 * @property blurY
		 * @default 0
		 * @type Number
		 **/
		this.blurY = blurY | 0;

		/**
		 * Number of blur iterations. For example, a value of 1 will produce a rough blur. A value of 2 will produce a
		 * smoother blur, but take twice as long to run.
		 * @property quality
		 * @default 1
		 * @type Number
		 **/
		this.quality = quality | 0;
	}
	var p = createjs.extend(BlurFilter, createjs.Filter);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// constants:
	/**
	 * Array of multiply values for blur calculations.
	 * @property MUL_TABLE
	 * @type Array
	 * @protected
	 * @static
	 **/
	BlurFilter.MUL_TABLE = [1, 171, 205, 293, 57, 373, 79, 137, 241, 27, 391, 357, 41, 19, 283, 265, 497, 469, 443, 421, 25, 191, 365, 349, 335, 161, 155, 149, 9, 278, 269, 261, 505, 245, 475, 231, 449, 437, 213, 415, 405, 395, 193, 377, 369, 361, 353, 345, 169, 331, 325, 319, 313, 307, 301, 37, 145, 285, 281, 69, 271, 267, 263, 259, 509, 501, 493, 243, 479, 118, 465, 459, 113, 446, 55, 435, 429, 423, 209, 413, 51, 403, 199, 393, 97, 3, 379, 375, 371, 367, 363, 359, 355, 351, 347, 43, 85, 337, 333, 165, 327, 323, 5, 317, 157, 311, 77, 305, 303, 75, 297, 294, 73, 289, 287, 71, 141, 279, 277, 275, 68, 135, 67, 133, 33, 262, 260, 129, 511, 507, 503, 499, 495, 491, 61, 121, 481, 477, 237, 235, 467, 232, 115, 457, 227, 451, 7, 445, 221, 439, 218, 433, 215, 427, 425, 211, 419, 417, 207, 411, 409, 203, 202, 401, 399, 396, 197, 49, 389, 387, 385, 383, 95, 189, 47, 187, 93, 185, 23, 183, 91, 181, 45, 179, 89, 177, 11, 175, 87, 173, 345, 343, 341, 339, 337, 21, 167, 83, 331, 329, 327, 163, 81, 323, 321, 319, 159, 79, 315, 313, 39, 155, 309, 307, 153, 305, 303, 151, 75, 299, 149, 37, 295, 147, 73, 291, 145, 289, 287, 143, 285, 71, 141, 281, 35, 279, 139, 69, 275, 137, 273, 17, 271, 135, 269, 267, 133, 265, 33, 263, 131, 261, 130, 259, 129, 257, 1];

	/**
	 * Array of shift values for blur calculations.
	 * @property SHG_TABLE
	 * @type Array
	 * @protected
	 * @static
	 **/
	BlurFilter.SHG_TABLE = [0, 9, 10, 11, 9, 12, 10, 11, 12, 9, 13, 13, 10, 9, 13, 13, 14, 14, 14, 14, 10, 13, 14, 14, 14, 13, 13, 13, 9, 14, 14, 14, 15, 14, 15, 14, 15, 15, 14, 15, 15, 15, 14, 15, 15, 15, 15, 15, 14, 15, 15, 15, 15, 15, 15, 12, 14, 15, 15, 13, 15, 15, 15, 15, 16, 16, 16, 15, 16, 14, 16, 16, 14, 16, 13, 16, 16, 16, 15, 16, 13, 16, 15, 16, 14, 9, 16, 16, 16, 16, 16, 16, 16, 16, 16, 13, 14, 16, 16, 15, 16, 16, 10, 16, 15, 16, 14, 16, 16, 14, 16, 16, 14, 16, 16, 14, 15, 16, 16, 16, 14, 15, 14, 15, 13, 16, 16, 15, 17, 17, 17, 17, 17, 17, 14, 15, 17, 17, 16, 16, 17, 16, 15, 17, 16, 17, 11, 17, 16, 17, 16, 17, 16, 17, 17, 16, 17, 17, 16, 17, 17, 16, 16, 17, 17, 17, 16, 14, 17, 17, 17, 17, 15, 16, 14, 16, 15, 16, 13, 16, 15, 16, 14, 16, 15, 16, 12, 16, 15, 16, 17, 17, 17, 17, 17, 13, 16, 15, 17, 17, 17, 16, 15, 17, 17, 17, 16, 15, 17, 17, 14, 16, 17, 17, 16, 17, 17, 16, 15, 17, 16, 14, 17, 16, 15, 17, 16, 17, 17, 16, 17, 15, 16, 17, 14, 17, 16, 15, 17, 16, 17, 13, 17, 16, 17, 17, 16, 17, 14, 17, 16, 17, 16, 17, 16, 17, 9];

// public methods:
	/** docced in super class **/
	p.getBounds = function (rect) {
		var x = this.blurX|0, y = this.blurY| 0;
		if (x <= 0 && y <= 0) { return rect; }
		var q = Math.pow(this.quality, 0.2);
		return (rect || new createjs.Rectangle()).pad(x*q+1,y*q+1,x*q+1,y*q+1);
	};

	/** docced in super class **/
	p.clone = function() {
		return new BlurFilter(this.blurX, this.blurY, this.quality);
	};

	/** docced in super class **/
	p.toString = function() {
		return "[BlurFilter]";
	};


// private methods:

	/** docced in super class **/
	p._applyFilter = function (imageData) {

		var radiusX = this.blurX >> 1;
		if (isNaN(radiusX) || radiusX < 0) return false;
		var radiusY = this.blurY >> 1;
		if (isNaN(radiusY) || radiusY < 0) return false;
		if (radiusX == 0 && radiusY == 0) return false;

		var iterations = this.quality;
		if (isNaN(iterations) || iterations < 1) iterations = 1;
		iterations |= 0;
		if (iterations > 3) iterations = 3;
		if (iterations < 1) iterations = 1;

		var px = imageData.data;
		var x=0, y=0, i=0, p=0, yp=0, yi=0, yw=0, r=0, g=0, b=0, a=0, pr=0, pg=0, pb=0, pa=0;

		var divx = (radiusX + radiusX + 1) | 0;
		var divy = (radiusY + radiusY + 1) | 0;
		var w = imageData.width | 0;
		var h = imageData.height | 0;

		var w1 = (w - 1) | 0;
		var h1 = (h - 1) | 0;
		var rxp1 = (radiusX + 1) | 0;
		var ryp1 = (radiusY + 1) | 0;

		var ssx = {r:0,b:0,g:0,a:0};
		var sx = ssx;
		for ( i = 1; i < divx; i++ )
		{
			sx = sx.n = {r:0,b:0,g:0,a:0};
		}
		sx.n = ssx;

		var ssy = {r:0,b:0,g:0,a:0};
		var sy = ssy;
		for ( i = 1; i < divy; i++ )
		{
			sy = sy.n = {r:0,b:0,g:0,a:0};
		}
		sy.n = ssy;

		var si = null;


		var mtx = BlurFilter.MUL_TABLE[radiusX] | 0;
		var stx = BlurFilter.SHG_TABLE[radiusX] | 0;
		var mty = BlurFilter.MUL_TABLE[radiusY] | 0;
		var sty = BlurFilter.SHG_TABLE[radiusY] | 0;

		while (iterations-- > 0) {

			yw = yi = 0;
			var ms = mtx;
			var ss = stx;
			for (y = h; --y > -1;) {
				r = rxp1 * (pr = px[(yi) | 0]);
				g = rxp1 * (pg = px[(yi + 1) | 0]);
				b = rxp1 * (pb = px[(yi + 2) | 0]);
				a = rxp1 * (pa = px[(yi + 3) | 0]);

				sx = ssx;

				for( i = rxp1; --i > -1; )
				{
					sx.r = pr;
					sx.g = pg;
					sx.b = pb;
					sx.a = pa;
					sx = sx.n;
				}

				for( i = 1; i < rxp1; i++ )
				{
					p = (yi + ((w1 < i ? w1 : i) << 2)) | 0;
					r += ( sx.r = px[p]);
					g += ( sx.g = px[p+1]);
					b += ( sx.b = px[p+2]);
					a += ( sx.a = px[p+3]);

					sx = sx.n;
				}

				si = ssx;
				for ( x = 0; x < w; x++ )
				{
					px[yi++] = (r * ms) >>> ss;
					px[yi++] = (g * ms) >>> ss;
					px[yi++] = (b * ms) >>> ss;
					px[yi++] = (a * ms) >>> ss;

					p = ((yw + ((p = x + radiusX + 1) < w1 ? p : w1)) << 2);

					r -= si.r - ( si.r = px[p]);
					g -= si.g - ( si.g = px[p+1]);
					b -= si.b - ( si.b = px[p+2]);
					a -= si.a - ( si.a = px[p+3]);

					si = si.n;

				}
				yw += w;
			}

			ms = mty;
			ss = sty;
			for (x = 0; x < w; x++) {
				yi = (x << 2) | 0;

				r = (ryp1 * (pr = px[yi])) | 0;
				g = (ryp1 * (pg = px[(yi + 1) | 0])) | 0;
				b = (ryp1 * (pb = px[(yi + 2) | 0])) | 0;
				a = (ryp1 * (pa = px[(yi + 3) | 0])) | 0;

				sy = ssy;
				for( i = 0; i < ryp1; i++ )
				{
					sy.r = pr;
					sy.g = pg;
					sy.b = pb;
					sy.a = pa;
					sy = sy.n;
				}

				yp = w;

				for( i = 1; i <= radiusY; i++ )
				{
					yi = ( yp + x ) << 2;

					r += ( sy.r = px[yi]);
					g += ( sy.g = px[yi+1]);
					b += ( sy.b = px[yi+2]);
					a += ( sy.a = px[yi+3]);

					sy = sy.n;

					if( i < h1 )
					{
						yp += w;
					}
				}

				yi = x;
				si = ssy;
				if ( iterations > 0 )
				{
					for ( y = 0; y < h; y++ )
					{
						p = yi << 2;
						px[p+3] = pa =(a * ms) >>> ss;
						if ( pa > 0 )
						{
							px[p]   = ((r * ms) >>> ss );
							px[p+1] = ((g * ms) >>> ss );
							px[p+2] = ((b * ms) >>> ss );
						} else {
							px[p] = px[p+1] = px[p+2] = 0
						}

						p = ( x + (( ( p = y + ryp1) < h1 ? p : h1 ) * w )) << 2;

						r -= si.r - ( si.r = px[p]);
						g -= si.g - ( si.g = px[p+1]);
						b -= si.b - ( si.b = px[p+2]);
						a -= si.a - ( si.a = px[p+3]);

						si = si.n;

						yi += w;
					}
				} else {
					for ( y = 0; y < h; y++ )
					{
						p = yi << 2;
						px[p+3] = pa =(a * ms) >>> ss;
						if ( pa > 0 )
						{
							pa = 255 / pa;
							px[p]   = ((r * ms) >>> ss ) * pa;
							px[p+1] = ((g * ms) >>> ss ) * pa;
							px[p+2] = ((b * ms) >>> ss ) * pa;
						} else {
							px[p] = px[p+1] = px[p+2] = 0
						}

						p = ( x + (( ( p = y + ryp1) < h1 ? p : h1 ) * w )) << 2;

						r -= si.r - ( si.r = px[p]);
						g -= si.g - ( si.g = px[p+1]);
						b -= si.b - ( si.b = px[p+2]);
						a -= si.a - ( si.a = px[p+3]);

						si = si.n;

						yi += w;
					}
				}
			}

		}
		return true;
	};

	createjs.BlurFilter = createjs.promote(BlurFilter, "Filter");
}());

//##############################################################################
// AlphaMapFilter.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";
	
	
// constructor:
	/**
	 * Applies a greyscale alpha map image (or canvas) to the target, such that the alpha channel of the result will
	 * be copied from the red channel of the map, and the RGB channels will be copied from the target.
	 *
	 * Generally, it is recommended that you use {{#crossLink "AlphaMaskFilter"}}{{/crossLink}}, because it has much
	 * better performance.
	 *
	 * <h4>Example</h4>
	 * This example draws a red->blue box, caches it, and then uses the cache canvas as an alpha map on a 100x100 image.
	 *
	 *       var box = new createjs.Shape();
	 *       box.graphics.beginLinearGradientFill(["#ff0000", "#0000ff"], [0, 1], 0, 0, 0, 100)
	 *       box.graphics.drawRect(0, 0, 100, 100);
	 *       box.cache(0, 0, 100, 100);
	 *
	 *       var bmp = new createjs.Bitmap("path/to/image.jpg");
	 *       bmp.filters = [
	 *           new createjs.AlphaMapFilter(box.cacheCanvas)
	 *       ];
	 *       bmp.cache(0, 0, 100, 100);
	 *       stage.addChild(bmp);
	 *
	 * See {{#crossLink "Filter"}}{{/crossLink}} for more information on applying filters.
	 * @class AlphaMapFilter
	 * @extends Filter
	 * @constructor
	 * @param {HTMLImageElement|HTMLCanvasElement} alphaMap The greyscale image (or canvas) to use as the alpha value for the
	 * result. This should be exactly the same dimensions as the target.
	 **/
	function AlphaMapFilter(alphaMap) {
	
	
	// public properties:
		/**
		 * The greyscale image (or canvas) to use as the alpha value for the result. This should be exactly the same
		 * dimensions as the target.
		 * @property alphaMap
		 * @type HTMLImageElement|HTMLCanvasElement
		 **/
		this.alphaMap = alphaMap;
		
		
	// private properties:
		/**
		 * @property _alphaMap
		 * @protected
		 * @type HTMLImageElement|HTMLCanvasElement
		 **/
		this._alphaMap = null;
		
		/**
		 * @property _mapData
		 * @protected
		 * @type Uint8ClampedArray
		 **/
		this._mapData = null;
	}
	var p = createjs.extend(AlphaMapFilter, createjs.Filter);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// public methods:
	/** docced in super class **/
	p.clone = function () {
		var o = new AlphaMapFilter(this.alphaMap);
		o._alphaMap = this._alphaMap;
		o._mapData = this._mapData;
		return o;
	};

	/** docced in super class **/
	p.toString = function () {
		return "[AlphaMapFilter]";
	};


// private methods:
	/** docced in super class **/
	p._applyFilter = function (imageData) {
		if (!this.alphaMap) { return true; }
		if (!this._prepAlphaMap()) { return false; }
		
		// TODO: update to support scenarios where the target has different dimensions.
		var data = imageData.data;
		var map = this._mapData;
		for(var i=0, l=data.length; i<l; i += 4) { data[i + 3] = map[i] || 0; }
		
		return true;
	};

	/**
	 * @method _prepAlphaMap
	 * @protected
	 **/
	p._prepAlphaMap = function () {
		if (!this.alphaMap) { return false; }
		if (this.alphaMap == this._alphaMap && this._mapData) { return true; }

		this._mapData = null;
		var map = this._alphaMap = this.alphaMap;
		var canvas = map;
		var ctx;
		if (map instanceof HTMLCanvasElement) {
			ctx = canvas.getContext("2d");
		} else {
			canvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement("canvas");
			canvas.width = map.width;
			canvas.height = map.height;
			ctx = canvas.getContext("2d");
			ctx.drawImage(map, 0, 0);
		}

		try {
			var imgData = ctx.getImageData(0, 0, map.width, map.height);
		} catch (e) {
			//if (!this.suppressCrossDomainErrors) throw new Error("unable to access local image data: " + e);
			return false;
		}
		
		this._mapData = imgData.data;
		return true;
	};


	createjs.AlphaMapFilter = createjs.promote(AlphaMapFilter, "Filter");
}());

//##############################################################################
// AlphaMaskFilter.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";


// constructor:
	/**
	 * Applies the alpha from the mask image (or canvas) to the target, such that the alpha channel of the result will
	 * be derived from the mask, and the RGB channels will be copied from the target. This can be used, for example, to
	 * apply an alpha mask to a display object. This can also be used to combine a JPG compressed RGB image with a PNG32
	 * alpha mask, which can result in a much smaller file size than a single PNG32 containing ARGB.
	 *
	 * <b>IMPORTANT NOTE: This filter currently does not support the targetCtx, or targetX/Y parameters correctly.</b>
	 *
	 * <h4>Example</h4>
	 * This example draws a gradient box, then caches it and uses the "cacheCanvas" as the alpha mask on a 100x100 image.
	 *
	 *      var box = new createjs.Shape();
	 *      box.graphics.beginLinearGradientFill(["#000000", "rgba(0, 0, 0, 0)"], [0, 1], 0, 0, 100, 100)
	 *      box.graphics.drawRect(0, 0, 100, 100);
	 *      box.cache(0, 0, 100, 100);
	 *
	 *      var bmp = new createjs.Bitmap("path/to/image.jpg");
	 *      bmp.filters = [
	 *          new createjs.AlphaMaskFilter(box.cacheCanvas)
	 *      ];
	 *      bmp.cache(0, 0, 100, 100);
	 *
	 * See {{#crossLink "Filter"}}{{/crossLink}} for more information on applying filters.
	 * @class AlphaMaskFilter
	 * @extends Filter
	 * @constructor
	 * @param {HTMLImageElement|HTMLCanvasElement} mask
	 **/
	function AlphaMaskFilter(mask) {
	
	
	// public properties:
		/**
		 * The image (or canvas) to use as the mask.
		 * @property mask
		 * @type HTMLImageElement|HTMLCanvasElement
		 **/
		this.mask = mask;
	}
	var p = createjs.extend(AlphaMaskFilter, createjs.Filter);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	

// public methods:
	/**
	 * Applies the filter to the specified context.
	 *
	 * <strong>IMPORTANT NOTE: This filter currently does not support the targetCtx, or targetX/Y parameters
	 * correctly.</strong>
	 * @method applyFilter
	 * @param {CanvasRenderingContext2D} ctx The 2D context to use as the source.
	 * @param {Number} x The x position to use for the source rect.
	 * @param {Number} y The y position to use for the source rect.
	 * @param {Number} width The width to use for the source rect.
	 * @param {Number} height The height to use for the source rect.
	 * @param {CanvasRenderingContext2D} [targetCtx] NOT SUPPORTED IN THIS FILTER. The 2D context to draw the result to. Defaults to the context passed to ctx.
	 * @param {Number} [targetX] NOT SUPPORTED IN THIS FILTER. The x position to draw the result to. Defaults to the value passed to x.
	 * @param {Number} [targetY] NOT SUPPORTED IN THIS FILTER. The y position to draw the result to. Defaults to the value passed to y.
	 * @return {Boolean} If the filter was applied successfully.
	 **/
	p.applyFilter = function (ctx, x, y, width, height, targetCtx, targetX, targetY) {
		if (!this.mask) { return true; }
		targetCtx = targetCtx || ctx;
		if (targetX == null) { targetX = x; }
		if (targetY == null) { targetY = y; }

		targetCtx.save();
		if (ctx != targetCtx) {
			// TODO: support targetCtx and targetX/Y
			// clearRect, then draw the ctx in?
			return false;
		}

		targetCtx.globalCompositeOperation = "destination-in";
		targetCtx.drawImage(this.mask, targetX, targetY);
		targetCtx.restore();
		return true;
	};

	/** docced in super class **/
	p.clone = function () {
		return new AlphaMaskFilter(this.mask);
	};

	/** docced in super class **/
	p.toString = function () {
		return "[AlphaMaskFilter]";
	};


	createjs.AlphaMaskFilter = createjs.promote(AlphaMaskFilter, "Filter");
}());

//##############################################################################
// ColorFilter.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Applies a color transform to DisplayObjects.
	 *
	 * <h4>Example</h4>
	 * This example draws a red circle, and then transforms it to Blue. This is accomplished by multiplying all the channels
	 * to 0 (except alpha, which is set to 1), and then adding 255 to the blue channel.
	 *
	 *      var shape = new createjs.Shape().set({x:100,y:100});
	 *      shape.graphics.beginFill("#ff0000").drawCircle(0,0,50);
	 *
	 *      shape.filters = [
	 *          new createjs.ColorFilter(0,0,0,1, 0,0,255,0)
	 *      ];
	 *      shape.cache(-50, -50, 100, 100);
	 *
	 * See {{#crossLink "Filter"}}{{/crossLink}} for an more information on applying filters.
	 * @class ColorFilter
	 * @param {Number} [redMultiplier=1] The amount to multiply against the red channel. This is a range between 0 and 1.
	 * @param {Number} [greenMultiplier=1] The amount to multiply against the green channel. This is a range between 0 and 1.
	 * @param {Number} [blueMultiplier=1] The amount to multiply against the blue channel. This is a range between 0 and 1.
	 * @param {Number} [alphaMultiplier=1] The amount to multiply against the alpha channel. This is a range between 0 and 1.
	 * @param {Number} [redOffset=0] The amount to add to the red channel after it has been multiplied. This is a range
	 * between -255 and 255.
	 * @param {Number} [greenOffset=0] The amount to add to the green channel after it has been multiplied. This is a range
	  * between -255 and 255.
	 * @param {Number} [blueOffset=0] The amount to add to the blue channel after it has been multiplied. This is a range
	  * between -255 and 255.
	 * @param {Number} [alphaOffset=0] The amount to add to the alpha channel after it has been multiplied. This is a range
	  * between -255 and 255.
	 * @constructor
	 * @extends Filter
	 **/
	function ColorFilter(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
		
	
	// public properties:
		/**
		 * Red channel multiplier.
		 * @property redMultiplier
		 * @type Number
		 **/
		this.redMultiplier = redMultiplier != null ? redMultiplier : 1;
	
		/**
		 * Green channel multiplier.
		 * @property greenMultiplier
		 * @type Number
		 **/
		this.greenMultiplier = greenMultiplier != null ? greenMultiplier : 1;
	
		/**
		 * Blue channel multiplier.
		 * @property blueMultiplier
		 * @type Number
		 **/
		this.blueMultiplier = blueMultiplier != null ? blueMultiplier : 1;
	
		/**
		 * Alpha channel multiplier.
		 * @property alphaMultiplier
		 * @type Number
		 **/
		this.alphaMultiplier = alphaMultiplier != null ? alphaMultiplier : 1;
	
		/**
		 * Red channel offset (added to value).
		 * @property redOffset
		 * @type Number
		 **/
		this.redOffset = redOffset || 0;
	
		/**
		 * Green channel offset (added to value).
		 * @property greenOffset
		 * @type Number
		 **/
		this.greenOffset = greenOffset || 0;
	
		/**
		 * Blue channel offset (added to value).
		 * @property blueOffset
		 * @type Number
		 **/
		this.blueOffset = blueOffset || 0;
	
		/**
		 * Alpha channel offset (added to value).
		 * @property alphaOffset
		 * @type Number
		 **/
		this.alphaOffset = alphaOffset || 0;
	}
	var p = createjs.extend(ColorFilter, createjs.Filter);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


// public methods:
	/** docced in super class **/
	p.toString = function() {
		return "[ColorFilter]";
	};

	/** docced in super class **/
	p.clone = function() {
		return new ColorFilter(this.redMultiplier, this.greenMultiplier, this.blueMultiplier, this.alphaMultiplier, this.redOffset, this.greenOffset, this.blueOffset, this.alphaOffset);
	};
	

// private methods:
	/** docced in super class **/
	p._applyFilter = function(imageData) {
		var data = imageData.data;
		var l = data.length;
		for (var i=0; i<l; i+=4) {
			data[i] = data[i]*this.redMultiplier+this.redOffset;
			data[i+1] = data[i+1]*this.greenMultiplier+this.greenOffset;
			data[i+2] = data[i+2]*this.blueMultiplier+this.blueOffset;
			data[i+3] = data[i+3]*this.alphaMultiplier+this.alphaOffset;
		}
		return true;
	};


	createjs.ColorFilter = createjs.promote(ColorFilter, "Filter");
}());

//##############################################################################
// ColorMatrix.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Provides helper functions for assembling a matrix for use with the {{#crossLink "ColorMatrixFilter"}}{{/crossLink}}.
	 * Most methods return the instance to facilitate chained calls.
	 *
	 * <h4>Example</h4>
	 *
	 *      myColorMatrix.adjustHue(20).adjustBrightness(50);
	 *
	 * See {{#crossLink "Filter"}}{{/crossLink}} for an example of how to apply filters, or {{#crossLink "ColorMatrixFilter"}}{{/crossLink}}
	 * for an example of how to use ColorMatrix to change a DisplayObject's color.
	 * @class ColorMatrix
	 * @param {Number} brightness
	 * @param {Number} contrast
	 * @param {Number} saturation
	 * @param {Number} hue
	 * @constructor
	 **/
	function ColorMatrix(brightness, contrast, saturation, hue) {
		this.setColor(brightness, contrast, saturation, hue);
	}
	var p = ColorMatrix.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// constants:
	/**
	 * Array of delta values for contrast calculations.
	 * @property DELTA_INDEX
	 * @type Array
	 * @protected
	 * @static
	 **/
	ColorMatrix.DELTA_INDEX = [
		0,    0.01, 0.02, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1,  0.11,
		0.12, 0.14, 0.15, 0.16, 0.17, 0.18, 0.20, 0.21, 0.22, 0.24,
		0.25, 0.27, 0.28, 0.30, 0.32, 0.34, 0.36, 0.38, 0.40, 0.42,
		0.44, 0.46, 0.48, 0.5,  0.53, 0.56, 0.59, 0.62, 0.65, 0.68,
		0.71, 0.74, 0.77, 0.80, 0.83, 0.86, 0.89, 0.92, 0.95, 0.98,
		1.0,  1.06, 1.12, 1.18, 1.24, 1.30, 1.36, 1.42, 1.48, 1.54,
		1.60, 1.66, 1.72, 1.78, 1.84, 1.90, 1.96, 2.0,  2.12, 2.25,
		2.37, 2.50, 2.62, 2.75, 2.87, 3.0,  3.2,  3.4,  3.6,  3.8,
		4.0,  4.3,  4.7,  4.9,  5.0,  5.5,  6.0,  6.5,  6.8,  7.0,
		7.3,  7.5,  7.8,  8.0,  8.4,  8.7,  9.0,  9.4,  9.6,  9.8,
		10.0
	];

	/**
	 * Identity matrix values.
	 * @property IDENTITY_MATRIX
	 * @type Array
	 * @protected
	 * @static
	 **/
	ColorMatrix.IDENTITY_MATRIX = [
		1,0,0,0,0,
		0,1,0,0,0,
		0,0,1,0,0,
		0,0,0,1,0,
		0,0,0,0,1
	];

	/**
	 * The constant length of a color matrix.
	 * @property LENGTH
	 * @type Number
	 * @protected
	 * @static
	 **/
	ColorMatrix.LENGTH = ColorMatrix.IDENTITY_MATRIX.length;


// public methods:
	/**
	 * Resets the instance with the specified values.
	 * @method setColor
	 * @param {Number} brightness
	 * @param {Number} contrast
	 * @param {Number} saturation
	 * @param {Number} hue
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 */
	p.setColor = function(brightness,contrast,saturation,hue) {
		return this.reset().adjustColor(brightness,contrast,saturation,hue);
	};

	/**
	 * Resets the matrix to identity values.
	 * @method reset
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 */
	p.reset = function() {
		return this.copy(ColorMatrix.IDENTITY_MATRIX);
	};

	/**
	 * Shortcut method to adjust brightness, contrast, saturation and hue.
	 * Equivalent to calling adjustHue(hue), adjustContrast(contrast),
	 * adjustBrightness(brightness), adjustSaturation(saturation), in that order.
	 * @method adjustColor
	 * @param {Number} brightness
	 * @param {Number} contrast
	 * @param {Number} saturation
	 * @param {Number} hue
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.adjustColor = function(brightness,contrast,saturation,hue) {
		this.adjustHue(hue);
		this.adjustContrast(contrast);
		this.adjustBrightness(brightness);
		return this.adjustSaturation(saturation);
	};

	/**
	 * Adjusts the brightness of pixel color by adding the specified value to the red, green and blue channels.
	 * Positive values will make the image brighter, negative values will make it darker.
	 * @method adjustBrightness
	 * @param {Number} value A value between -255 & 255 that will be added to the RGB channels.
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.adjustBrightness = function(value) {
		if (value == 0 || isNaN(value)) { return this; }
		value = this._cleanValue(value,255);
		this._multiplyMatrix([
			1,0,0,0,value,
			0,1,0,0,value,
			0,0,1,0,value,
			0,0,0,1,0,
			0,0,0,0,1
		]);
		return this;
	};

	/**
	 * Adjusts the contrast of pixel color.
	 * Positive values will increase contrast, negative values will decrease contrast.
	 * @method adjustContrast
	 * @param {Number} value A value between -100 & 100.
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.adjustContrast = function(value) {
		if (value == 0 || isNaN(value)) { return this; }
		value = this._cleanValue(value,100);
		var x;
		if (value<0) {
			x = 127+value/100*127;
		} else {
			x = value%1;
			if (x == 0) {
				x = ColorMatrix.DELTA_INDEX[value];
			} else {
				x = ColorMatrix.DELTA_INDEX[(value<<0)]*(1-x)+ColorMatrix.DELTA_INDEX[(value<<0)+1]*x; // use linear interpolation for more granularity.
			}
			x = x*127+127;
		}
		this._multiplyMatrix([
			x/127,0,0,0,0.5*(127-x),
			0,x/127,0,0,0.5*(127-x),
			0,0,x/127,0,0.5*(127-x),
			0,0,0,1,0,
			0,0,0,0,1
		]);
		return this;
	};

	/**
	 * Adjusts the color saturation of the pixel.
	 * Positive values will increase saturation, negative values will decrease saturation (trend towards greyscale).
	 * @method adjustSaturation
	 * @param {Number} value A value between -100 & 100.
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.adjustSaturation = function(value) {
		if (value == 0 || isNaN(value)) { return this; }
		value = this._cleanValue(value,100);
		var x = 1+((value > 0) ? 3*value/100 : value/100);
		var lumR = 0.3086;
		var lumG = 0.6094;
		var lumB = 0.0820;
		this._multiplyMatrix([
			lumR*(1-x)+x,lumG*(1-x),lumB*(1-x),0,0,
			lumR*(1-x),lumG*(1-x)+x,lumB*(1-x),0,0,
			lumR*(1-x),lumG*(1-x),lumB*(1-x)+x,0,0,
			0,0,0,1,0,
			0,0,0,0,1
		]);
		return this;
	};


	/**
	 * Adjusts the hue of the pixel color.
	 * @method adjustHue
	 * @param {Number} value A value between -180 & 180.
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.adjustHue = function(value) {
		if (value == 0 || isNaN(value)) { return this; }
		value = this._cleanValue(value,180)/180*Math.PI;
		var cosVal = Math.cos(value);
		var sinVal = Math.sin(value);
		var lumR = 0.213;
		var lumG = 0.715;
		var lumB = 0.072;
		this._multiplyMatrix([
			lumR+cosVal*(1-lumR)+sinVal*(-lumR),lumG+cosVal*(-lumG)+sinVal*(-lumG),lumB+cosVal*(-lumB)+sinVal*(1-lumB),0,0,
			lumR+cosVal*(-lumR)+sinVal*(0.143),lumG+cosVal*(1-lumG)+sinVal*(0.140),lumB+cosVal*(-lumB)+sinVal*(-0.283),0,0,
			lumR+cosVal*(-lumR)+sinVal*(-(1-lumR)),lumG+cosVal*(-lumG)+sinVal*(lumG),lumB+cosVal*(1-lumB)+sinVal*(lumB),0,0,
			0,0,0,1,0,
			0,0,0,0,1
		]);
		return this;
	};

	/**
	 * Concatenates (multiplies) the specified matrix with this one.
	 * @method concat
	 * @param {Array} matrix An array or ColorMatrix instance.
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.concat = function(matrix) {
		matrix = this._fixMatrix(matrix);
		if (matrix.length != ColorMatrix.LENGTH) { return this; }
		this._multiplyMatrix(matrix);
		return this;
	};

	/**
	 * Returns a clone of this ColorMatrix.
	 * @method clone
	 * @return {ColorMatrix} A clone of this ColorMatrix.
	 **/
	p.clone = function() {
		return (new ColorMatrix()).copy(this);
	};

	/**
	 * Return a length 25 (5x5) array instance containing this matrix's values.
	 * @method toArray
	 * @return {Array} An array holding this matrix's values.
	 **/
	p.toArray = function() {
		var arr = [];
		for (var i= 0, l=ColorMatrix.LENGTH; i<l; i++) {
			arr[i] = this[i];
		}
		return arr;
	};

	/**
	 * Copy the specified matrix's values to this matrix.
	 * @method copy
	 * @param {Array} matrix An array or ColorMatrix instance.
	 * @return {ColorMatrix} The ColorMatrix instance the method is called on (useful for chaining calls.)
	 * @chainable
	 **/
	p.copy = function(matrix) {
		var l = ColorMatrix.LENGTH;
		for (var i=0;i<l;i++) {
			this[i] = matrix[i];
		}
		return this;
	};
	
	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[ColorMatrix]";
	};


// private methods:
	/**
	 * @method _multiplyMatrix
	 * @param {Array} matrix
	 * @protected
	 **/
	p._multiplyMatrix = function(matrix) {
		var i, j, k, col = [];

		for (i=0;i<5;i++) {
			for (j=0;j<5;j++) {
				col[j] = this[j+i*5];
			}
			for (j=0;j<5;j++) {
				var val=0;
				for (k=0;k<5;k++) {
					val += matrix[j+k*5]*col[k];
				}
				this[j+i*5] = val;
			}
		}
	};

	/**
	 * Make sure values are within the specified range, hue has a limit of 180, brightness is 255, others are 100.
	 * @method _cleanValue
	 * @param {Number} value The raw number
	 * @param {Number} limit The maximum that the number can be. The minimum is the limit * -1.
	 * @protected
	 **/
	p._cleanValue = function(value, limit) {
		return Math.min(limit,Math.max(-limit,value));
	};

	/**
	 * Makes sure matrixes are 5x5 (25 long).
	 * @method _fixMatrix
	 * @param {Array} matrix
	 * @protected
	 **/
	p._fixMatrix = function(matrix) {
		if (matrix instanceof ColorMatrix) { matrix = matrix.toArray(); }
		if (matrix.length < ColorMatrix.LENGTH) {
			matrix = matrix.slice(0,matrix.length).concat(ColorMatrix.IDENTITY_MATRIX.slice(matrix.length,ColorMatrix.LENGTH));
		} else if (matrix.length > ColorMatrix.LENGTH) {
			matrix = matrix.slice(0,ColorMatrix.LENGTH);
		}
		return matrix;
	};


	createjs.ColorMatrix = ColorMatrix;
}());

//##############################################################################
// ColorMatrixFilter.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * Allows you to carry out complex color operations such as modifying saturation, brightness, or inverting. See the
	 * {{#crossLink "ColorMatrix"}}{{/crossLink}} for more information on changing colors. For an easier color transform,
	 * consider the {{#crossLink "ColorFilter"}}{{/crossLink}}.
	 *
	 * <h4>Example</h4>
	 * This example creates a red circle, inverts its hue, and then saturates it to brighten it up.
	 *
	 *      var shape = new createjs.Shape().set({x:100,y:100});
	 *      shape.graphics.beginFill("#ff0000").drawCircle(0,0,50);
	 *
	 *      var matrix = new createjs.ColorMatrix().adjustHue(180).adjustSaturation(100);
	 *      shape.filters = [
	 *          new createjs.ColorMatrixFilter(matrix)
	 *      ];
	 *
	 *      shape.cache(-50, -50, 100, 100);
	 *
	 * See {{#crossLink "Filter"}}{{/crossLink}} for an more information on applying filters.
	 * @class ColorMatrixFilter
	 * @constructor
	 * @extends Filter
	 * @param {Array | ColorMatrix} matrix A 4x5 matrix describing the color operation to perform. See also the {{#crossLink "ColorMatrix"}}{{/crossLink}}
	 * class.
	 **/
	function ColorMatrixFilter(matrix) {
	
		
	// public properties:
		/**
		 * A 4x5 matrix describing the color operation to perform. See also the {{#crossLink "ColorMatrix"}}{{/crossLink}}
		 * @property matrix
		 * @type Array | ColorMatrix
		 **/
		this.matrix = matrix;
	}
	var p = createjs.extend(ColorMatrixFilter, createjs.Filter);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	

// public methods:
	/** docced in super class **/
	p.toString = function() {
		return "[ColorMatrixFilter]";
	};

	/** docced in super class **/
	p.clone = function() {
		return new ColorMatrixFilter(this.matrix);
	};

// private methods:
	/** docced in super class **/
	p._applyFilter = function(imageData) { 
		var data = imageData.data;
		var l = data.length;
		var r,g,b,a;
		var mtx = this.matrix;
		var m0 =  mtx[0],  m1 =  mtx[1],  m2 =  mtx[2],  m3 =  mtx[3],  m4 =  mtx[4];
		var m5 =  mtx[5],  m6 =  mtx[6],  m7 =  mtx[7],  m8 =  mtx[8],  m9 =  mtx[9];
		var m10 = mtx[10], m11 = mtx[11], m12 = mtx[12], m13 = mtx[13], m14 = mtx[14];
		var m15 = mtx[15], m16 = mtx[16], m17 = mtx[17], m18 = mtx[18], m19 = mtx[19];

		for (var i=0; i<l; i+=4) {
			r = data[i];
			g = data[i+1];
			b = data[i+2];
			a = data[i+3];
			data[i] = r*m0+g*m1+b*m2+a*m3+m4; // red
			data[i+1] = r*m5+g*m6+b*m7+a*m8+m9; // green
			data[i+2] = r*m10+g*m11+b*m12+a*m13+m14; // blue
			data[i+3] = r*m15+g*m16+b*m17+a*m18+m19; // alpha
		}
		return true;
	};


	createjs.ColorMatrixFilter = createjs.promote(ColorMatrixFilter, "Filter");
}());

//##############################################################################
// Touch.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
 * Global utility for working with multi-touch enabled devices in EaselJS. Currently supports W3C Touch API (iOS and
 * modern Android browser) and the Pointer API (IE), including ms-prefixed events in IE10, and unprefixed in IE11.
 *
 * Ensure that you {{#crossLink "Touch/disable"}}{{/crossLink}} touch when cleaning up your application. You do not have
 * to check if touch is supported to enable it, as it will fail gracefully if it is not supported.
 *
 * <h4>Example</h4>
 *
 *      var stage = new createjs.Stage("canvasId");
 *      createjs.Touch.enable(stage);
 *
 * <strong>Note:</strong> It is important to disable Touch on a stage that you are no longer using:
 *
 *      createjs.Touch.disable(stage);
 *
 * @class Touch
 * @static
 **/
	function Touch() {
		throw "Touch cannot be instantiated";
	}


// public static methods:
	/**
	 * Returns `true` if touch is supported in the current browser.
	 * @method isSupported
	 * @return {Boolean} Indicates whether touch is supported in the current browser.
	 * @static
	 **/
	Touch.isSupported = function() {
		return	!!(('ontouchstart' in window) // iOS & Android
			|| (window.navigator['msPointerEnabled'] && window.navigator['msMaxTouchPoints'] > 0) // IE10
			|| (window.navigator['pointerEnabled'] && window.navigator['maxTouchPoints'] > 0)); // IE11+
	};

	/**
	 * Enables touch interaction for the specified EaselJS {{#crossLink "Stage"}}{{/crossLink}}. Currently supports iOS
	 * (and compatible browsers, such as modern Android browsers), and IE10/11. Supports both single touch and
	 * multi-touch modes. Extends the EaselJS {{#crossLink "MouseEvent"}}{{/crossLink}} model, but without support for
	 * double click or over/out events. See the MouseEvent {{#crossLink "MouseEvent/pointerId:property"}}{{/crossLink}}
	 * for more information.
	 * @method enable
	 * @param {Stage} stage The {{#crossLink "Stage"}}{{/crossLink}} to enable touch on.
	 * @param {Boolean} [singleTouch=false] If `true`, only a single touch will be active at a time.
	 * @param {Boolean} [allowDefault=false] If `true`, then default gesture actions (ex. scrolling, zooming) will be
	 * allowed when the user is interacting with the target canvas.
	 * @return {Boolean} Returns `true` if touch was successfully enabled on the target stage.
	 * @static
	 **/
	Touch.enable = function(stage, singleTouch, allowDefault) {
		if (!stage || !stage.canvas || !Touch.isSupported()) { return false; }
		if (stage.__touch) { return true; }

		// inject required properties on stage:
		stage.__touch = {pointers:{}, multitouch:!singleTouch, preventDefault:!allowDefault, count:0};

		// note that in the future we may need to disable the standard mouse event model before adding
		// these to prevent duplicate calls. It doesn't seem to be an issue with iOS devices though.
		if ('ontouchstart' in window) { Touch._IOS_enable(stage); }
		else if (window.navigator['msPointerEnabled'] || window.navigator["pointerEnabled"]) { Touch._IE_enable(stage); }
		return true;
	};

	/**
	 * Removes all listeners that were set up when calling `Touch.enable()` on a stage.
	 * @method disable
	 * @param {Stage} stage The {{#crossLink "Stage"}}{{/crossLink}} to disable touch on.
	 * @static
	 **/
	Touch.disable = function(stage) {
		if (!stage) { return; }
		if ('ontouchstart' in window) { Touch._IOS_disable(stage); }
		else if (window.navigator['msPointerEnabled'] || window.navigator["pointerEnabled"]) { Touch._IE_disable(stage); }
		
		delete stage.__touch;
	};


// Private static methods:
	/**
	 * @method _IOS_enable
	 * @protected
	 * @param {Stage} stage
	 * @static
	 **/
	Touch._IOS_enable = function(stage) {
		var canvas = stage.canvas;
		var f = stage.__touch.f = function(e) { Touch._IOS_handleEvent(stage,e); };
		canvas.addEventListener("touchstart", f, false);
		canvas.addEventListener("touchmove", f, false);
		canvas.addEventListener("touchend", f, false);
		canvas.addEventListener("touchcancel", f, false);
	};

	/**
	 * @method _IOS_disable
	 * @protected
	 * @param {Stage} stage
	 * @static
	 **/
	Touch._IOS_disable = function(stage) {
		var canvas = stage.canvas;
		if (!canvas) { return; }
		var f = stage.__touch.f;
		canvas.removeEventListener("touchstart", f, false);
		canvas.removeEventListener("touchmove", f, false);
		canvas.removeEventListener("touchend", f, false);
		canvas.removeEventListener("touchcancel", f, false);
	};

	/**
	 * @method _IOS_handleEvent
	 * @param {Stage} stage
	 * @param {Object} e The event to handle
	 * @protected
	 * @static
	 **/
	Touch._IOS_handleEvent = function(stage, e) {
		if (!stage) { return; }
		if (stage.__touch.preventDefault) { e.preventDefault&&e.preventDefault(); }
		var touches = e.changedTouches;
		var type = e.type;
		for (var i= 0,l=touches.length; i<l; i++) {
			var touch = touches[i];
			var id = touch.identifier;
			if (touch.target != stage.canvas) { continue; }

			if (type == "touchstart") {
				this._handleStart(stage, id, e, touch.pageX, touch.pageY);
			} else if (type == "touchmove") {
				this._handleMove(stage, id, e, touch.pageX, touch.pageY);
			} else if (type == "touchend" || type == "touchcancel") {
				this._handleEnd(stage, id, e);
			}
		}
	};

	/**
	 * @method _IE_enable
	 * @protected
	 * @param {Stage} stage
	 * @static
	 **/
	Touch._IE_enable = function(stage) {
		var canvas = stage.canvas;
		var f = stage.__touch.f = function(e) { Touch._IE_handleEvent(stage,e); };

		if (window.navigator["pointerEnabled"] === undefined) {
			canvas.addEventListener("MSPointerDown", f, false);
			window.addEventListener("MSPointerMove", f, false);
			window.addEventListener("MSPointerUp", f, false);
			window.addEventListener("MSPointerCancel", f, false);
			if (stage.__touch.preventDefault) { canvas.style.msTouchAction = "none"; }
		} else {
			canvas.addEventListener("pointerdown", f, false);
			window.addEventListener("pointermove", f, false);
			window.addEventListener("pointerup", f, false);
			window.addEventListener("pointercancel", f, false);
			if (stage.__touch.preventDefault) { canvas.style.touchAction = "none"; }

		}
		stage.__touch.activeIDs = {};
	};

	/**
	 * @method _IE_disable
	 * @protected
	 * @param {Stage} stage
	 * @static
	 **/
	Touch._IE_disable = function(stage) {
		var f = stage.__touch.f;

		if (window.navigator["pointerEnabled"] === undefined) {
			window.removeEventListener("MSPointerMove", f, false);
			window.removeEventListener("MSPointerUp", f, false);
			window.removeEventListener("MSPointerCancel", f, false);
			if (stage.canvas) {
				stage.canvas.removeEventListener("MSPointerDown", f, false);
			}
		} else {
			window.removeEventListener("pointermove", f, false);
			window.removeEventListener("pointerup", f, false);
			window.removeEventListener("pointercancel", f, false);
			if (stage.canvas) {
				stage.canvas.removeEventListener("pointerdown", f, false);
			}
		}
	};

	/**
	 * @method _IE_handleEvent
	 * @param {Stage} stage
	 * @param {Object} e The event to handle.
	 * @protected
	 * @static
	 **/
	Touch._IE_handleEvent = function(stage, e) {
		if (!stage) { return; }
		if (stage.__touch.preventDefault) { e.preventDefault && e.preventDefault(); }
		var type = e.type;
		var id = e.pointerId;
		var ids = stage.__touch.activeIDs;

		if (type == "MSPointerDown" || type == "pointerdown") {
			if (e.srcElement != stage.canvas) { return; }
			ids[id] = true;
			this._handleStart(stage, id, e, e.pageX, e.pageY);
		} else if (ids[id]) { // it's an id we're watching
			if (type == "MSPointerMove" || type == "pointermove") {
				this._handleMove(stage, id, e, e.pageX, e.pageY);
			} else if (type == "MSPointerUp" || type == "MSPointerCancel"
					|| type == "pointerup" || type == "pointercancel") {
				delete(ids[id]);
				this._handleEnd(stage, id, e);
			}
		}
	};

	/**
	 * @method _handleStart
	 * @param {Stage} stage
	 * @param {String|Number} id
	 * @param {Object} e
	 * @param {Number} x
	 * @param {Number} y
	 * @protected
	 **/
	Touch._handleStart = function(stage, id, e, x, y) {
		var props = stage.__touch;
		if (!props.multitouch && props.count) { return; }
		var ids = props.pointers;
		if (ids[id]) { return; }
		ids[id] = true;
		props.count++;
		stage._handlePointerDown(id, e, x, y);
	};

	/**
	 * @method _handleMove
	 * @param {Stage} stage
	 * @param {String|Number} id
	 * @param {Object} e
	 * @param {Number} x
	 * @param {Number} y
	 * @protected
	 **/
	Touch._handleMove = function(stage, id, e, x, y) {
		if (!stage.__touch.pointers[id]) { return; }
		stage._handlePointerMove(id, e, x, y);
	};

	/**
	 * @method _handleEnd
	 * @param {Stage} stage
	 * @param {String|Number} id
	 * @param {Object} e
	 * @protected
	 **/
	Touch._handleEnd = function(stage, id, e) {
		// TODO: cancel should be handled differently for proper UI (ex. an up would trigger a click, a cancel would more closely resemble an out).
		var props = stage.__touch;
		var ids = props.pointers;
		if (!ids[id]) { return; }
		props.count--;
		stage._handlePointerUp(id, e, true);
		delete(ids[id]);
	};


	createjs.Touch = Touch;
}());

//##############################################################################
// version.js
//##############################################################################

this.createjs = this.createjs || {};

(function() {
	"use strict";

	/**
	 * Static class holding library specific information such as the version and buildDate of
	 * the library.
	 * @class EaselJS
	 **/
	var s = createjs.EaselJS = createjs.EaselJS || {};

	/**
	 * The version string for this release.
	 * @property version
	 * @type String
	 * @static
	 **/
	s.version = /*=version*/"0.8.1"; // injected by build process

	/**
	 * The build date for this release in UTC format.
	 * @property buildDate
	 * @type String
	 * @static
	 **/
	s.buildDate = /*=date*/"Thu, 21 May 2015 16:17:39 GMT"; // injected by build process

})();
/*!
* PreloadJS
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2010 gskinner.com, inc.
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/


//##############################################################################
// version.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	/**
	 * Static class holding library specific information such as the version and buildDate of the library.
	 * @class PreloadJS
	 **/
	var s = createjs.PreloadJS = createjs.PreloadJS || {};

	/**
	 * The version string for this release.
	 * @property version
	 * @type {String}
	 * @static
	 **/
	s.version = /*=version*/"0.6.1"; // injected by build process

	/**
	 * The build date for this release in UTC format.
	 * @property buildDate
	 * @type {String}
	 * @static
	 **/
	s.buildDate = /*=date*/"Thu, 21 May 2015 16:17:37 GMT"; // injected by build process

})();

//##############################################################################
// extend.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Sets up the prototype chain and constructor property for a new class.
 *
 * This should be called right after creating the class constructor.
 *
 * 	function MySubClass() {}
 * 	createjs.extend(MySubClass, MySuperClass);
 * 	ClassB.prototype.doSomething = function() { }
 *
 * 	var foo = new MySubClass();
 * 	console.log(foo instanceof MySuperClass); // true
 * 	console.log(foo.prototype.constructor === MySubClass); // true
 *
 * @method extend
 * @param {Function} subclass The subclass.
 * @param {Function} superclass The superclass to extend.
 * @return {Function} Returns the subclass's new prototype.
 */
createjs.extend = function(subclass, superclass) {
	"use strict";

	function o() { this.constructor = subclass; }
	o.prototype = superclass.prototype;
	return (subclass.prototype = new o());
};

//##############################################################################
// promote.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.
 * It is recommended to use the super class's name as the prefix.
 * An alias to the super class's constructor is always added in the format `prefix_constructor`.
 * This allows the subclass to call super class methods without using `function.call`, providing better performance.
 *
 * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, "MySuperClass")`
 * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the
 * prototype of `MySubClass` as `MySuperClass_draw`.
 *
 * This should be called after the class's prototype is fully defined.
 *
 * 	function ClassA(name) {
 * 		this.name = name;
 * 	}
 * 	ClassA.prototype.greet = function() {
 * 		return "Hello "+this.name;
 * 	}
 *
 * 	function ClassB(name, punctuation) {
 * 		this.ClassA_constructor(name);
 * 		this.punctuation = punctuation;
 * 	}
 * 	createjs.extend(ClassB, ClassA);
 * 	ClassB.prototype.greet = function() {
 * 		return this.ClassA_greet()+this.punctuation;
 * 	}
 * 	createjs.promote(ClassB, "ClassA");
 *
 * 	var foo = new ClassB("World", "!?!");
 * 	console.log(foo.greet()); // Hello World!?!
 *
 * @method promote
 * @param {Function} subclass The class to promote super class methods on.
 * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.
 * @return {Function} Returns the subclass.
 */
createjs.promote = function(subclass, prefix) {
	"use strict";

	var subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;
	if (supP) {
		subP[(prefix+="_") + "constructor"] = supP.constructor; // constructor is not always innumerable
		for (var n in supP) {
			if (subP.hasOwnProperty(n) && (typeof supP[n] == "function")) { subP[prefix + n] = supP[n]; }
		}
	}
	return subclass;
};

//##############################################################################
// indexOf.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Finds the first occurrence of a specified value searchElement in the passed in array, and returns the index of
 * that value.  Returns -1 if value is not found.
 *
 *      var i = createjs.indexOf(myArray, myElementToFind);
 *
 * @method indexOf
 * @param {Array} array Array to search for searchElement
 * @param searchElement Element to find in array.
 * @return {Number} The first index of searchElement in array.
 */
createjs.indexOf = function (array, searchElement){
	"use strict";

	for (var i = 0,l=array.length; i < l; i++) {
		if (searchElement === array[i]) {
			return i;
		}
	}
	return -1;
};

//##############################################################################
// proxy.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * Various utilities that the CreateJS Suite uses. Utilities are created as separate files, and will be available on the
 * createjs namespace directly.
 *
 * <h4>Example</h4>
 *
 *      myObject.addEventListener("change", createjs.proxy(myMethod, scope));
 *
 * @class Utility Methods
 * @main Utility Methods
 */

(function() {
	"use strict";

	/**
	 * A function proxy for methods. By default, JavaScript methods do not maintain scope, so passing a method as a
	 * callback will result in the method getting called in the scope of the caller. Using a proxy ensures that the
	 * method gets called in the correct scope.
	 *
	 * Additional arguments can be passed that will be applied to the function when it is called.
	 *
	 * <h4>Example</h4>
	 *
	 *      myObject.addEventListener("event", createjs.proxy(myHandler, this, arg1, arg2));
	 *
	 *      function myHandler(arg1, arg2) {
	 *           // This gets called when myObject.myCallback is executed.
	 *      }
	 *
	 * @method proxy
	 * @param {Function} method The function to call
	 * @param {Object} scope The scope to call the method name on
	 * @param {mixed} [arg] * Arguments that are appended to the callback for additional params.
	 * @public
	 * @static
	 */
	createjs.proxy = function (method, scope) {
		var aArgs = Array.prototype.slice.call(arguments, 2);
		return function () {
			return method.apply(scope, Array.prototype.slice.call(arguments, 0).concat(aArgs));
		};
	}

}());

//##############################################################################
// BrowserDetect.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */
(function() {
	"use strict";

	/**
	 * An object that determines the current browser, version, operating system, and other environment
	 * variables via user agent string.
	 *
	 * Used for audio because feature detection is unable to detect the many limitations of mobile devices.
	 *
	 * <h4>Example</h4>
	 *
	 *      if (createjs.BrowserDetect.isIOS) { // do stuff }
	 *
	 * @property BrowserDetect
	 * @type {Object}
	 * @param {Boolean} isFirefox True if our browser is Firefox.
	 * @param {Boolean} isOpera True if our browser is opera.
	 * @param {Boolean} isChrome True if our browser is Chrome.  Note that Chrome for Android returns true, but is a
	 * completely different browser with different abilities.
	 * @param {Boolean} isIOS True if our browser is safari for iOS devices (iPad, iPhone, and iPod).
	 * @param {Boolean} isAndroid True if our browser is Android.
	 * @param {Boolean} isBlackberry True if our browser is Blackberry.
	 * @constructor
	 * @static
	 */
	function BrowserDetect() {
		throw "BrowserDetect cannot be instantiated";
	}

	var agent = BrowserDetect.agent = window.navigator.userAgent;
	BrowserDetect.isWindowPhone = (agent.indexOf("IEMobile") > -1) || (agent.indexOf("Windows Phone") > -1);
	BrowserDetect.isFirefox = (agent.indexOf("Firefox") > -1);
	BrowserDetect.isOpera = (window.opera != null);
	BrowserDetect.isChrome = (agent.indexOf("Chrome") > -1);  // NOTE that Chrome on Android returns true but is a completely different browser with different abilities
	BrowserDetect.isIOS = (agent.indexOf("iPod") > -1 || agent.indexOf("iPhone") > -1 || agent.indexOf("iPad") > -1) && !BrowserDetect.isWindowPhone;
	BrowserDetect.isAndroid = (agent.indexOf("Android") > -1) && !BrowserDetect.isWindowPhone;
	BrowserDetect.isBlackberry = (agent.indexOf("Blackberry") > -1);

	createjs.BrowserDetect = BrowserDetect;

}());

//##############################################################################
// Event.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

// constructor:
	/**
	 * Contains properties and methods shared by all events for use with
	 * {{#crossLink "EventDispatcher"}}{{/crossLink}}.
	 * 
	 * Note that Event objects are often reused, so you should never
	 * rely on an event object's state outside of the call stack it was received in.
	 * @class Event
	 * @param {String} type The event type.
	 * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
	 * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
	 * @constructor
	 **/
	function Event(type, bubbles, cancelable) {
		
	
	// public properties:
		/**
		 * The type of event.
		 * @property type
		 * @type String
		 **/
		this.type = type;
	
		/**
		 * The object that generated an event.
		 * @property target
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.target = null;
	
		/**
		 * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will
		 * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event
		 * is generated from childObj, then a listener on parentObj would receive the event with
		 * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).
		 * @property currentTarget
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.currentTarget = null;
	
		/**
		 * For bubbling events, this indicates the current event phase:<OL>
		 * 	<LI> capture phase: starting from the top parent to the target</LI>
		 * 	<LI> at target phase: currently being dispatched from the target</LI>
		 * 	<LI> bubbling phase: from the target to the top parent</LI>
		 * </OL>
		 * @property eventPhase
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.eventPhase = 0;
	
		/**
		 * Indicates whether the event will bubble through the display list.
		 * @property bubbles
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.bubbles = !!bubbles;
	
		/**
		 * Indicates whether the default behaviour of this event can be cancelled via
		 * {{#crossLink "Event/preventDefault"}}{{/crossLink}}. This is set via the Event constructor.
		 * @property cancelable
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.cancelable = !!cancelable;
	
		/**
		 * The epoch time at which this event was created.
		 * @property timeStamp
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.timeStamp = (new Date()).getTime();
	
		/**
		 * Indicates if {{#crossLink "Event/preventDefault"}}{{/crossLink}} has been called
		 * on this event.
		 * @property defaultPrevented
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.defaultPrevented = false;
	
		/**
		 * Indicates if {{#crossLink "Event/stopPropagation"}}{{/crossLink}} or
		 * {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called on this event.
		 * @property propagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.propagationStopped = false;
	
		/**
		 * Indicates if {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called
		 * on this event.
		 * @property immediatePropagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.immediatePropagationStopped = false;
		
		/**
		 * Indicates if {{#crossLink "Event/remove"}}{{/crossLink}} has been called on this event.
		 * @property removed
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.removed = false;
	}
	var p = Event.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.
	

// public methods:
	/**
	 * Sets {{#crossLink "Event/defaultPrevented"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method preventDefault
	 **/
	p.preventDefault = function() {
		this.defaultPrevented = this.cancelable&&true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopPropagation
	 **/
	p.stopPropagation = function() {
		this.propagationStopped = true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} and
	 * {{#crossLink "Event/immediatePropagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopImmediatePropagation
	 **/
	p.stopImmediatePropagation = function() {
		this.immediatePropagationStopped = this.propagationStopped = true;
	};
	
	/**
	 * Causes the active listener to be removed via removeEventListener();
	 * 
	 * 		myBtn.addEventListener("click", function(evt) {
	 * 			// do stuff...
	 * 			evt.remove(); // removes this listener.
	 * 		});
	 * 
	 * @method remove
	 **/
	p.remove = function() {
		this.removed = true;
	};
	
	/**
	 * Returns a clone of the Event instance.
	 * @method clone
	 * @return {Event} a clone of the Event instance.
	 **/
	p.clone = function() {
		return new Event(this.type, this.bubbles, this.cancelable);
	};
	
	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the instance.
	 * @return {Event} Returns the instance the method is called on (useful for chaining calls.)
	 * @chainable
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Event (type="+this.type+")]";
	};

	createjs.Event = Event;
}());

//##############################################################################
// ErrorEvent.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

	/**
	 * A general error {{#crossLink "Event"}}{{/crossLink}}, that describes an error that occurred, as well as any details.
	 * @class ErrorEvent
	 * @param {String} [title] The error title
	 * @param {String} [message] The error description
	 * @param {Object} [data] Additional error data
	 * @constructor
	 */
	function ErrorEvent(title, message, data) {
		this.Event_constructor("error");

		/**
		 * The short error title, which indicates the type of error that occurred.
		 * @property title
		 * @type String
		 */
		this.title = title;

		/**
		 * The verbose error message, containing details about the error.
		 * @property message
		 * @type String
		 */
		this.message = message;

		/**
		 * Additional data attached to an error.
		 * @property data
		 * @type {Object}
		 */
		this.data = data;
	}

	var p = createjs.extend(ErrorEvent, createjs.Event);

	p.clone = function() {
		return new createjs.ErrorEvent(this.title, this.message, this.data);
	};

	createjs.ErrorEvent = createjs.promote(ErrorEvent, "Event");

}());

//##############################################################################
// EventDispatcher.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * EventDispatcher provides methods for managing queues of event listeners and dispatching events.
	 *
	 * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the
	 * EventDispatcher {{#crossLink "EventDispatcher/initialize"}}{{/crossLink}} method.
	 * 
	 * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the
	 * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports
	 * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.
	 * 
	 * EventDispatcher also exposes a {{#crossLink "EventDispatcher/on"}}{{/crossLink}} method, which makes it easier
	 * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The 
	 * {{#crossLink "EventDispatcher/off"}}{{/crossLink}} method is merely an alias to
	 * {{#crossLink "EventDispatcher/removeEventListener"}}{{/crossLink}}.
	 * 
	 * Another addition to the DOM Level 2 model is the {{#crossLink "EventDispatcher/removeAllEventListeners"}}{{/crossLink}}
	 * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also 
	 * includes a {{#crossLink "Event/remove"}}{{/crossLink}} method which removes the active listener.
	 *
	 * <h4>Example</h4>
	 * Add EventDispatcher capabilities to the "MyClass" class.
	 *
	 *      EventDispatcher.initialize(MyClass.prototype);
	 *
	 * Add an event (see {{#crossLink "EventDispatcher/addEventListener"}}{{/crossLink}}).
	 *
	 *      instance.addEventListener("eventName", handlerMethod);
	 *      function handlerMethod(event) {
	 *          console.log(event.target + " Was Clicked");
	 *      }
	 *
	 * <b>Maintaining proper scope</b><br />
	 * Scope (ie. "this") can be be a challenge with events. Using the {{#crossLink "EventDispatcher/on"}}{{/crossLink}}
	 * method to subscribe to events simplifies this.
	 *
	 *      instance.addEventListener("click", function(event) {
	 *          console.log(instance == this); // false, scope is ambiguous.
	 *      });
	 *      
	 *      instance.on("click", function(event) {
	 *          console.log(instance == this); // true, "on" uses dispatcher scope by default.
	 *      });
	 * 
	 * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage scope.
	 *      
	 *
	 * @class EventDispatcher
	 * @constructor
	 **/
	function EventDispatcher() {
	
	
	// private properties:
		/**
		 * @protected
		 * @property _listeners
		 * @type Object
		 **/
		this._listeners = null;
		
		/**
		 * @protected
		 * @property _captureListeners
		 * @type Object
		 **/
		this._captureListeners = null;
	}
	var p = EventDispatcher.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// static public methods:
	/**
	 * Static initializer to mix EventDispatcher methods into a target object or prototype.
	 * 
	 * 		EventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class
	 * 		EventDispatcher.initialize(myObject); // add to a specific instance
	 * 
	 * @method initialize
	 * @static
	 * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a
	 * prototype.
	 **/
	EventDispatcher.initialize = function(target) {
		target.addEventListener = p.addEventListener;
		target.on = p.on;
		target.removeEventListener = target.off =  p.removeEventListener;
		target.removeAllEventListeners = p.removeAllEventListeners;
		target.hasEventListener = p.hasEventListener;
		target.dispatchEvent = p.dispatchEvent;
		target._dispatchEvent = p._dispatchEvent;
		target.willTrigger = p.willTrigger;
	};
	

// public methods:
	/**
	 * Adds the specified event listener. Note that adding multiple listeners to the same function will result in
	 * multiple callbacks getting fired.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.addEventListener("click", handleClick);
	 *      function handleClick(event) {
	 *         // Click happened.
	 *      }
	 *
	 * @method addEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function | Object} Returns the listener for chaining or assignment.
	 **/
	p.addEventListener = function(type, listener, useCapture) {
		var listeners;
		if (useCapture) {
			listeners = this._captureListeners = this._captureListeners||{};
		} else {
			listeners = this._listeners = this._listeners||{};
		}
		var arr = listeners[type];
		if (arr) { this.removeEventListener(type, listener, useCapture); }
		arr = listeners[type]; // remove may have deleted the array
		if (!arr) { listeners[type] = [listener];  }
		else { arr.push(listener); }
		return listener;
	};
	
	/**
	 * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener
	 * only run once, associate arbitrary data with the listener, and remove the listener.
	 * 
	 * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.
	 * The created anonymous function is returned for use with .removeEventListener (or .off).
	 * 
	 * <h4>Example</h4>
	 * 
	 * 		var listener = myBtn.on("click", handleClick, null, false, {count:3});
	 * 		function handleClick(evt, data) {
	 * 			data.count -= 1;
	 * 			console.log(this == myBtn); // true - scope defaults to the dispatcher
	 * 			if (data.count == 0) {
	 * 				alert("clicked 3 times!");
	 * 				myBtn.off("click", listener);
	 * 				// alternately: evt.remove();
	 * 			}
	 * 		}
	 * 
	 * @method on
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).
	 * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.
	 * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.
	 * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.
	 **/
	p.on = function(type, listener, scope, once, data, useCapture) {
		if (listener.handleEvent) {
			scope = scope||listener;
			listener = listener.handleEvent;
		}
		scope = scope||this;
		return this.addEventListener(type, function(evt) {
				listener.call(scope, evt, data);
				once&&evt.remove();
			}, useCapture);
	};

	/**
	 * Removes the specified event listener.
	 *
	 * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy
	 * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or
	 * closure will not work.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.removeEventListener("click", handleClick);
	 *
	 * @method removeEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.removeEventListener = function(type, listener, useCapture) {
		var listeners = useCapture ? this._captureListeners : this._listeners;
		if (!listeners) { return; }
		var arr = listeners[type];
		if (!arr) { return; }
		for (var i=0,l=arr.length; i<l; i++) {
			if (arr[i] == listener) {
				if (l==1) { delete(listeners[type]); } // allows for faster checks.
				else { arr.splice(i,1); }
				break;
			}
		}
	};
	
	/**
	 * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the
	 * .on method.
	 *
	 * @method off
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.off = p.removeEventListener;

	/**
	 * Removes all listeners for the specified type, or all listeners of all types.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Remove all listeners
	 *      displayObject.removeAllEventListeners();
	 *
	 *      // Remove all click listeners
	 *      displayObject.removeAllEventListeners("click");
	 *
	 * @method removeAllEventListeners
	 * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.
	 **/
	p.removeAllEventListeners = function(type) {
		if (!type) { this._listeners = this._captureListeners = null; }
		else {
			if (this._listeners) { delete(this._listeners[type]); }
			if (this._captureListeners) { delete(this._captureListeners[type]); }
		}
	};

	/**
	 * Dispatches the specified event to all listeners.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Use a string event
	 *      this.dispatchEvent("complete");
	 *
	 *      // Use an Event instance
	 *      var event = new createjs.Event("progress");
	 *      this.dispatchEvent(event);
	 *
	 * @method dispatchEvent
	 * @param {Object | String | Event} eventObj An object with a "type" property, or a string type.
	 * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,
	 * dispatchEvent will construct an Event instance with the specified type.
	 * @return {Boolean} Returns the value of eventObj.defaultPrevented.
	 **/
	p.dispatchEvent = function(eventObj) {
		if (typeof eventObj == "string") {
			// won't bubble, so skip everything if there's no listeners:
			var listeners = this._listeners;
			if (!listeners || !listeners[eventObj]) { return false; }
			eventObj = new createjs.Event(eventObj);
		} else if (eventObj.target && eventObj.clone) {
			// redispatching an active event object, so clone it:
			eventObj = eventObj.clone();
		}
		try { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events

		if (!eventObj.bubbles || !this.parent) {
			this._dispatchEvent(eventObj, 2);
		} else {
			var top=this, list=[top];
			while (top.parent) { list.push(top = top.parent); }
			var i, l=list.length;

			// capture & atTarget
			for (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {
				list[i]._dispatchEvent(eventObj, 1+(i==0));
			}
			// bubbling
			for (i=1; i<l && !eventObj.propagationStopped; i++) {
				list[i]._dispatchEvent(eventObj, 3);
			}
		}
		return eventObj.defaultPrevented;
	};

	/**
	 * Indicates whether there is at least one listener for the specified event type.
	 * @method hasEventListener
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns true if there is at least one listener for the specified event.
	 **/
	p.hasEventListener = function(type) {
		var listeners = this._listeners, captureListeners = this._captureListeners;
		return !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));
	};
	
	/**
	 * Indicates whether there is at least one listener for the specified event type on this object or any of its
	 * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the
	 * specified type is dispatched from this object, it will trigger at least one listener.
	 * 
	 * This is similar to {{#crossLink "EventDispatcher/hasEventListener"}}{{/crossLink}}, but it searches the entire
	 * event flow for a listener, not just this object.
	 * @method willTrigger
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns `true` if there is at least one listener for the specified event.
	 **/
	p.willTrigger = function(type) {
		var o = this;
		while (o) {
			if (o.hasEventListener(type)) { return true; }
			o = o.parent;
		}
		return false;
	};

	/**
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[EventDispatcher]";
	};


// private methods:
	/**
	 * @method _dispatchEvent
	 * @param {Object | String | Event} eventObj
	 * @param {Object} eventPhase
	 * @protected
	 **/
	p._dispatchEvent = function(eventObj, eventPhase) {
		var l, listeners = (eventPhase==1) ? this._captureListeners : this._listeners;
		if (eventObj && listeners) {
			var arr = listeners[eventObj.type];
			if (!arr||!(l=arr.length)) { return; }
			try { eventObj.currentTarget = this; } catch (e) {}
			try { eventObj.eventPhase = eventPhase; } catch (e) {}
			eventObj.removed = false;
			
			arr = arr.slice(); // to avoid issues with items being removed or added during the dispatch
			for (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {
				var o = arr[i];
				if (o.handleEvent) { o.handleEvent(eventObj); }
				else { o(eventObj); }
				if (eventObj.removed) {
					this.off(eventObj.type, o, eventPhase==1);
					eventObj.removed = false;
				}
			}
		}
	};


	createjs.EventDispatcher = EventDispatcher;
}());

//##############################################################################
// ProgressEvent.js
//##############################################################################

this.createjs = this.createjs || {};

(function (scope) {
	"use strict";

	// constructor
	/**
	 * A CreateJS {{#crossLink "Event"}}{{/crossLink}} that is dispatched when progress changes.
	 * @class ProgressEvent
	 * @param {Number} loaded The amount that has been loaded. This can be any number relative to the total.
	 * @param {Number} [total=1] The total amount that will load. This will default to 1, so if the `loaded` value is
	 * a percentage (between 0 and 1), it can be omitted.
	 * @todo Consider having this event be a "fileprogress" event as well
	 * @constructor
	 */
	function ProgressEvent(loaded, total) {
		this.Event_constructor("progress");

		/**
		 * The amount that has been loaded (out of a total amount)
		 * @property loaded
		 * @type {Number}
		 */
		this.loaded = loaded;

		/**
		 * The total "size" of the load.
		 * @property total
		 * @type {Number}
		 * @default 1
		 */
		this.total = (total == null) ? 1 : total;

		/**
		 * The percentage (out of 1) that the load has been completed. This is calculated using `loaded/total`.
		 * @property progress
		 * @type {Number}
		 * @default 0
		 */
		this.progress = (total == 0) ? 0 : this.loaded / this.total;
	};

	var p = createjs.extend(ProgressEvent, createjs.Event);

	/**
	 * Returns a clone of the ProgressEvent instance.
	 * @method clone
	 * @return {ProgressEvent} a clone of the Event instance.
	 **/
	p.clone = function() {
		return new createjs.ProgressEvent(this.loaded, this.total);
	};

	createjs.ProgressEvent = createjs.promote(ProgressEvent, "Event");

}(window));

//##############################################################################
// json3.js
//##############################################################################

/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

//##############################################################################
// DomUtils.js
//##############################################################################

(function () {

	/**
	 * A few utilities for interacting with the dom.
	 * @class DomUtils
	 */
	var s = {};

	s.appendToHead = function (el) {
		s.getHead().appendChild(el)
	}

	s.getHead = function () {
		return document.head || document.getElementsByTagName("head")[0];
	}

	s.getBody = function () {
		return document.body || document.getElementsByTagName("body")[0];
	}

	createjs.DomUtils = s;

}());

//##############################################################################
// DataUtils.js
//##############################################################################

(function () {

	/**
	 * A few data utilities for formatting different data types.
	 * @class DataUtils
	 */
	var s = {};

	// static methods
	/**
	 * Parse XML using the DOM. This is required when preloading XML or SVG.
	 * @method parseXML
	 * @param {String} text The raw text or XML that is loaded by XHR.
	 * @param {String} type The mime type of the XML. Use "text/xml" for XML, and  "image/svg+xml" for SVG parsing.
	 * @return {XML} An XML document
	 * @static
	 */
	s.parseXML = function (text, type) {
		var xml = null;
		// CocoonJS does not support XML parsing with either method.

		// Most browsers will use DOMParser
		// IE fails on certain SVG files, so we have a fallback below.
		try {
			if (window.DOMParser) {
				var parser = new DOMParser();
				xml = parser.parseFromString(text, type);
			}
		} catch (e) {
		}

		// Fallback for IE support.
		if (!xml) {
			try {
				xml = new ActiveXObject("Microsoft.XMLDOM");
				xml.async = false;
				xml.loadXML(text);
			} catch (e) {
				xml = null;
			}
		}

		return xml;
	};

	/**
	 * Parse a string into an Object.
	 * @method parseJSON
	 * @param {String} value The loaded JSON string
	 * @returns {Object} A JavaScript object.
	 */
	s.parseJSON = function (value) {
		if (value == null) {
			return null;
		}

		try {
			return JSON.parse(value);
		} catch (e) {
			// TODO; Handle this with a custom error?
			throw e;
		}
	};

	createjs.DataUtils = s;

}());

//##############################################################################
// LoadItem.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	/**
	 * All loaders accept an item containing the properties defined in this class. If a raw object is passed instead,
	 * it will not be affected, but it must contain at least a {{#crossLink "src:property"}}{{/crossLink}} property. A
	 * string path or HTML tag is also acceptable, but it will be automatically converted to a LoadItem using the
	 * {{#crossLink "create"}}{{/crossLink}} method by {{#crossLink "AbstractLoader"}}{{/crossLink}}
	 * @class LoadItem
	 * @constructor
	 * @since 0.6.0
	 */
	function LoadItem() {
		/**
		 * The source of the file that is being loaded. This property is <b>required</b>. The source can either be a
		 * string (recommended), or an HTML tag.
		 * This can also be an object, but in that case it has to include a type and be handled by a plugin.
		 * @property src
		 * @type {String}
		 * @default null
		 */
		this.src = null;

		/**
		 * The type file that is being loaded. The type of the file is usually inferred by the extension, but can also
		 * be set manually. This is helpful in cases where a file does not have an extension.
		 * @property type
		 * @type {String}
		 * @default null
		 */
		this.type = null;

		/**
		 * A string identifier which can be used to reference the loaded object. If none is provided, this will be
		 * automatically set to the {{#crossLink "src:property"}}{{/crossLink}}.
		 * @property id
		 * @type {String}
		 * @default null
		 */
		this.id = null;

		/**
		 * Determines if a manifest will maintain the order of this item, in relation to other items in the manifest
		 * that have also set the `maintainOrder` property to `true`. This only applies when the max connections has
		 * been set above 1 (using {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}). Everything with this
		 * property set to `false` will finish as it is loaded. Ordered items are combined with script tags loading in
		 * order when {{#crossLink "LoadQueue/maintainScriptOrder:property"}}{{/crossLink}} is set to `true`.
		 * @property maintainOrder
		 * @type {Boolean}
		 * @default false
		 */
		this.maintainOrder = false;

		/**
		 * A callback used by JSONP requests that defines what global method to call when the JSONP content is loaded.
		 * @property callback
		 * @type {String}
		 * @default null
		 */
		this.callback = null;

		/**
		 * An arbitrary data object, which is included with the loaded object.
		 * @property data
		 * @type {Object}
		 * @default null
		 */
		this.data = null;

		/**
		 * The request method used for HTTP calls. Both {{#crossLink "AbstractLoader/GET:property"}}{{/crossLink}} or
		 * {{#crossLink "AbstractLoader/POST:property"}}{{/crossLink}} request types are supported, and are defined as
		 * constants on {{#crossLink "AbstractLoader"}}{{/crossLink}}.
		 * @property method
		 * @type {String}
		 * @default get
		 */
		this.method = createjs.LoadItem.GET;

		/**
		 * An object hash of name/value pairs to send to the server.
		 * @property values
		 * @type {Object}
		 * @default null
		 */
		this.values = null;

		/**
		 * An object hash of headers to attach to an XHR request. PreloadJS will automatically attach some default
		 * headers when required, including "Origin", "Content-Type", and "X-Requested-With". You may override the
		 * default headers by including them in your headers object.
		 * @property headers
		 * @type {Object}
		 * @default null
		 */
		this.headers = null;

		/**
		 * Enable credentials for XHR requests.
		 * @property withCredentials
		 * @type {Boolean}
		 * @default false
		 */
		this.withCredentials = false;

		/**
		 * Set the mime type of XHR-based requests. This is automatically set to "text/plain; charset=utf-8" for text
		 * based files (json, xml, text, css, js).
		 * @property mimeType
		 * @type {String}
		 * @default null
		 */
		this.mimeType = null;

		/**
		 * Sets the crossOrigin attribute for CORS-enabled images loading cross-domain.
		 * @property crossOrigin
		 * @type {boolean}
		 * @default Anonymous
		 */
		this.crossOrigin = null;

		/**
		 * The duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR
		 * (level one) loading, as XHR (level 2) provides its own timeout event.
		 * @property loadTimeout
		 * @type {Number}
		 * @default 8000 (8 seconds)
		 */
		this.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;
	};

	var p = LoadItem.prototype = {};
	var s = LoadItem;

	/**
	 * Default duration in milliseconds to wait before a request times out. This only applies to tag-based and and XHR
	 * (level one) loading, as XHR (level 2) provides its own timeout event.
	 * @property LOAD_TIMEOUT_DEFAULT
	 * @type {number}
	 * @static
	 */
	s.LOAD_TIMEOUT_DEFAULT = 8000;

	/**
	 * Create a LoadItem.
	 * <ul>
	 *     <li>String-based items are converted to a LoadItem with a populated {{#crossLink "src:property"}}{{/crossLink}}.</li>
	 *     <li>LoadItem instances are returned as-is</li>
	 *     <li>Objects are returned with any needed properties added</li>
	 * </ul>
	 * @method create
	 * @param {LoadItem|String|Object} value The load item value
	 * @returns {LoadItem|Object}
	 * @static
	 */
	s.create = function (value) {
		if (typeof value == "string") {
			var item = new LoadItem();
			item.src = value;
			return item;
		} else if (value instanceof s) {
			return value;
		} else if (value instanceof Object && value.src) {
			if (value.loadTimeout == null) {
				value.loadTimeout = s.LOAD_TIMEOUT_DEFAULT;
			}
			return value;
		} else {
			throw new Error("Type not recognized.");
		}
	};

	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * <h4>Example</h4>
	 *
	 *      var loadItem = new createjs.LoadItem().set({src:"image.png", maintainOrder:true});
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the LoadItem instance.
	 * @return {LoadItem} Returns the instance the method is called on (useful for chaining calls.)
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};

	createjs.LoadItem = s;

}());

//##############################################################################
// RequestUtils.js
//##############################################################################

(function () {

	/**
	 * Utilities that assist with parsing load items, and determining file types, etc.
	 * @class RequestUtils
	 */
	var s = {};

	/**
	 * The Regular Expression used to test file URLS for an absolute path.
	 * @property ABSOLUTE_PATH
	 * @type {RegExp}
	 * @static
	 */
	s.ABSOLUTE_PATT = /^(?:\w+:)?\/{2}/i;

	/**
	 * The Regular Expression used to test file URLS for a relative path.
	 * @property RELATIVE_PATH
	 * @type {RegExp}
	 * @static
	 */
	s.RELATIVE_PATT = (/^[./]*?\//i);

	/**
	 * The Regular Expression used to test file URLS for an extension. Note that URIs must already have the query string
	 * removed.
	 * @property EXTENSION_PATT
	 * @type {RegExp}
	 * @static
	 */
	s.EXTENSION_PATT = /\/?[^/]+\.(\w{1,5})$/i;

	/**
	 * Parse a file path to determine the information we need to work with it. Currently, PreloadJS needs to know:
	 * <ul>
	 *     <li>If the path is absolute. Absolute paths start with a protocol (such as `http://`, `file://`, or
	 *     `//networkPath`)</li>
	 *     <li>If the path is relative. Relative paths start with `../` or `/path` (or similar)</li>
	 *     <li>The file extension. This is determined by the filename with an extension. Query strings are dropped, and
	 *     the file path is expected to follow the format `name.ext`.</li>
	 * </ul>
	 * @method parseURI
	 * @param {String} path
	 * @returns {Object} An Object with an `absolute` and `relative` Boolean values, as well as an optional 'extension`
	 * property, which is the lowercase extension.
	 * @static
	 */
	s.parseURI = function (path) {
		var info = {absolute: false, relative: false};
		if (path == null) { return info; }

		// Drop the query string
		var queryIndex = path.indexOf("?");
		if (queryIndex > -1) {
			path = path.substr(0, queryIndex);
		}

		// Absolute
		var match;
		if (s.ABSOLUTE_PATT.test(path)) {
			info.absolute = true;

			// Relative
		} else if (s.RELATIVE_PATT.test(path)) {
			info.relative = true;
		}

		// Extension
		if (match = path.match(s.EXTENSION_PATT)) {
			info.extension = match[1].toLowerCase();
		}
		return info;
	};

	/**
	 * Formats an object into a query string for either a POST or GET request.
	 * @method formatQueryString
	 * @param {Object} data The data to convert to a query string.
	 * @param {Array} [query] Existing name/value pairs to append on to this query.
	 * @static
	 */
	s.formatQueryString = function (data, query) {
		if (data == null) {
			throw new Error('You must specify data.');
		}
		var params = [];
		for (var n in data) {
			params.push(n + '=' + escape(data[n]));
		}
		if (query) {
			params = params.concat(query);
		}
		return params.join('&');
	};

	/**
	 * A utility method that builds a file path using a source and a data object, and formats it into a new path.
	 * @method buildPath
	 * @param {String} src The source path to add values to.
	 * @param {Object} [data] Object used to append values to this request as a query string. Existing parameters on the
	 * path will be preserved.
	 * @returns {string} A formatted string that contains the path and the supplied parameters.
	 * @static
	 */
	s.buildPath = function (src, data) {
		if (data == null) {
			return src;
		}

		var query = [];
		var idx = src.indexOf('?');

		if (idx != -1) {
			var q = src.slice(idx + 1);
			query = query.concat(q.split('&'));
		}

		if (idx != -1) {
			return src.slice(0, idx) + '?' + this._formatQueryString(data, query);
		} else {
			return src + '?' + this._formatQueryString(data, query);
		}
	};

	/**
	 * @method isCrossDomain
	 * @param {LoadItem|Object} item A load item with a `src` property.
	 * @return {Boolean} If the load item is loading from a different domain than the current location.
	 * @static
	 */
	s.isCrossDomain = function (item) {
		var target = document.createElement("a");
		target.href = item.src;

		var host = document.createElement("a");
		host.href = location.href;

		var crossdomain = (target.hostname != "") &&
						  (target.port != host.port ||
						   target.protocol != host.protocol ||
						   target.hostname != host.hostname);
		return crossdomain;
	};

	/**
	 * @method isLocal
	 * @param {LoadItem|Object} item A load item with a `src` property
	 * @return {Boolean} If the load item is loading from the "file:" protocol. Assume that the host must be local as
	 * well.
	 * @static
	 */
	s.isLocal = function (item) {
		var target = document.createElement("a");
		target.href = item.src;
		return target.hostname == "" && target.protocol == "file:";
	};

	/**
	 * Determine if a specific type should be loaded as a binary file. Currently, only images and items marked
	 * specifically as "binary" are loaded as binary. Note that audio is <b>not</b> a binary type, as we can not play
	 * back using an audio tag if it is loaded as binary. Plugins can change the item type to binary to ensure they get
	 * a binary result to work with. Binary files are loaded using XHR2. Types are defined as static constants on
	 * {{#crossLink "AbstractLoader"}}{{/crossLink}}.
	 * @method isBinary
	 * @param {String} type The item type.
	 * @return {Boolean} If the specified type is binary.
	 * @static
	 */
	s.isBinary = function (type) {
		switch (type) {
			case createjs.AbstractLoader.IMAGE:
			case createjs.AbstractLoader.BINARY:
				return true;
			default:
				return false;
		}
	};

	/**
	 * Check if item is a valid HTMLImageElement
	 * @method isImageTag
	 * @param {Object} item
	 * @returns {Boolean}
	 * @static
	 */
	s.isImageTag = function(item) {
		return item instanceof HTMLImageElement;
	};

	/**
	 * Check if item is a valid HTMLAudioElement
	 * @method isAudioTag
	 * @param {Object} item
	 * @returns {Boolean}
	 * @static
	 */
	s.isAudioTag = function(item) {
		if (window.HTMLAudioElement) {
			return item instanceof HTMLAudioElement;
		} else {
			return false;
		}
	};

	/**
	 * Check if item is a valid HTMLVideoElement
	 * @method isVideoTag
	 * @param {Object} item
	 * @returns {Boolean}
	 * @static
	 */
	s.isVideoTag = function(item) {
		if (window.HTMLVideoElement) {
			return item instanceof HTMLVideoElement;
		} else {
			return false;
		}
	};

	/**
	 * Determine if a specific type is a text-based asset, and should be loaded as UTF-8.
	 * @method isText
	 * @param {String} type The item type.
	 * @return {Boolean} If the specified type is text.
	 * @static
	 */
	s.isText = function (type) {
		switch (type) {
			case createjs.AbstractLoader.TEXT:
			case createjs.AbstractLoader.JSON:
			case createjs.AbstractLoader.MANIFEST:
			case createjs.AbstractLoader.XML:
			case createjs.AbstractLoader.CSS:
			case createjs.AbstractLoader.SVG:
			case createjs.AbstractLoader.JAVASCRIPT:
			case createjs.AbstractLoader.SPRITESHEET:
				return true;
			default:
				return false;
		}
	};

	/**
	 * Determine the type of the object using common extensions. Note that the type can be passed in with the load item
	 * if it is an unusual extension.
	 * @method getTypeByExtension
	 * @param {String} extension The file extension to use to determine the load type.
	 * @return {String} The determined load type (for example, <code>AbstractLoader.IMAGE</code>). Will return `null` if
	 * the type can not be determined by the extension.
	 * @static
	 */
	s.getTypeByExtension = function (extension) {
		if (extension == null) {
			return createjs.AbstractLoader.TEXT;
		}

		switch (extension.toLowerCase()) {
			case "jpeg":
			case "jpg":
			case "gif":
			case "png":
			case "webp":
			case "bmp":
				return createjs.AbstractLoader.IMAGE;
			case "ogg":
			case "mp3":
			case "webm":
				return createjs.AbstractLoader.SOUND;
			case "mp4":
			case "webm":
			case "ts":
				return createjs.AbstractLoader.VIDEO;
			case "json":
				return createjs.AbstractLoader.JSON;
			case "xml":
				return createjs.AbstractLoader.XML;
			case "css":
				return createjs.AbstractLoader.CSS;
			case "js":
				return createjs.AbstractLoader.JAVASCRIPT;
			case 'svg':
				return createjs.AbstractLoader.SVG;
			default:
				return createjs.AbstractLoader.TEXT;
		}
	};

	createjs.RequestUtils = s;

}());

//##############################################################################
// AbstractLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

// constructor
	/**
	 * The base loader, which defines all the generic methods, properties, and events. All loaders extend this class,
	 * including the {{#crossLink "LoadQueue"}}{{/crossLink}}.
	 * @class AbstractLoader
	 * @param {LoadItem|object|string} loadItem The item to be loaded.
	 * @param {Boolean} [preferXHR] Determines if the LoadItem should <em>try</em> and load using XHR, or take a
	 * tag-based approach, which can be better in cross-domain situations. Not all loaders can load using one or the
	 * other, so this is a suggested directive.
	 * @param {String} [type] The type of loader. Loader types are defined as constants on the AbstractLoader class,
	 * such as {{#crossLink "IMAGE:property"}}{{/crossLink}}, {{#crossLink "CSS:property"}}{{/crossLink}}, etc.
	 * @extends EventDispatcher
	 */
	function AbstractLoader(loadItem, preferXHR, type) {
		this.EventDispatcher_constructor();

		// public properties
		/**
		 * If the loader has completed loading. This provides a quick check, but also ensures that the different approaches
		 * used for loading do not pile up resulting in more than one `complete` {{#crossLink "Event"}}{{/crossLink}}.
		 * @property loaded
		 * @type {Boolean}
		 * @default false
		 */
		this.loaded = false;

		/**
		 * Determine if the loader was canceled. Canceled loads will not fire complete events. Note that this property
		 * is readonly, so {{#crossLink "LoadQueue"}}{{/crossLink}} queues should be closed using {{#crossLink "LoadQueue/close"}}{{/crossLink}}
		 * instead.
		 * @property canceled
		 * @type {Boolean}
		 * @default false
		 * @readonly
		 */
		this.canceled = false;

		/**
		 * The current load progress (percentage) for this item. This will be a number between 0 and 1.
		 *
		 * <h4>Example</h4>
		 *
		 *     var queue = new createjs.LoadQueue();
		 *     queue.loadFile("largeImage.png");
		 *     queue.on("progress", function() {
		 *         console.log("Progress:", queue.progress, event.progress);
		 *     });
		 *
		 * @property progress
		 * @type {Number}
		 * @default 0
		 */
		this.progress = 0;

		/**
		 * The type of item this loader will load. See {{#crossLink "AbstractLoader"}}{{/crossLink}} for a full list of
		 * supported types.
		 * @property type
		 * @type {String}
		 */
		this.type = type;

		/**
		 * A formatter function that converts the loaded raw result into the final result. For example, the JSONLoader
		 * converts a string of text into a JavaScript object. Not all loaders have a resultFormatter, and this property
		 * can be overridden to provide custom formatting.
		 *
		 * Optionally, a resultFormatter can return a callback function in cases where the formatting needs to be
		 * asynchronous, such as creating a new image.
		 * @property resultFormatter
		 * @type {Function}
		 * @default null
		 */
		this.resultFormatter = null;

		// protected properties
		/**
		 * The {{#crossLink "LoadItem"}}{{/crossLink}} this loader represents. Note that this is null in a {{#crossLink "LoadQueue"}}{{/crossLink}},
		 * but will be available on loaders such as {{#crossLink "XMLLoader"}}{{/crossLink}} and {{#crossLink "ImageLoader"}}{{/crossLink}}.
		 * @property _item
		 * @type {LoadItem|Object}
		 * @private
		 */
		if (loadItem) {
			this._item = createjs.LoadItem.create(loadItem);
		} else {
			this._item = null;
		}

		/**
		 * Whether the loader will try and load content using XHR (true) or HTML tags (false).
		 * @property _preferXHR
		 * @type {Boolean}
		 * @private
		 */
		this._preferXHR = preferXHR;

		/**
		 * The loaded result after it is formatted by an optional {{#crossLink "resultFormatter"}}{{/crossLink}}. For
		 * items that are not formatted, this will be the same as the {{#crossLink "_rawResult:property"}}{{/crossLink}}.
		 * The result is accessed using the {{#crossLink "getResult"}}{{/crossLink}} method.
		 * @property _result
		 * @type {Object|String}
		 * @private
		 */
		this._result = null;

		/**
		 * The loaded result before it is formatted. The rawResult is accessed using the {{#crossLink "getResult"}}{{/crossLink}}
		 * method, and passing `true`.
		 * @property _rawResult
		 * @type {Object|String}
		 * @private
		 */
		this._rawResult = null;

		/**
		 * A list of items that loaders load behind the scenes. This does not include the main item the loader is
		 * responsible for loading. Examples of loaders that have sub-items include the {{#crossLink "SpriteSheetLoader"}}{{/crossLink}} and
		 * {{#crossLink "ManifestLoader"}}{{/crossLink}}.
		 * @property _loadItems
		 * @type {null}
		 * @protected
		 */
		this._loadedItems = null;

		/**
		 * The attribute the items loaded using tags use for the source.
		 * @type {string}
		 * @default null
		 * @private
		 */
		this._tagSrcAttribute = null;

		/**
		 * An HTML tag (or similar) that a loader may use to load HTML content, such as images, scripts, etc.
		 * @property _tag
		 * @type {Object}
		 * @private
		 */
		this._tag = null;
	};

	var p = createjs.extend(AbstractLoader, createjs.EventDispatcher);
	var s = AbstractLoader;

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.


	/**
	 * Defines a POST request, use for a method value when loading data.
	 * @property POST
	 * @type {string}
	 * @default post
	 * @static
	 */
	s.POST = "POST";

	/**
	 * Defines a GET request, use for a method value when loading data.
	 * @property GET
	 * @type {string}
	 * @default get
	 * @static
	 */
	s.GET = "GET";

	/**
	 * The preload type for generic binary types. Note that images are loaded as binary files when using XHR.
	 * @property BINARY
	 * @type {String}
	 * @default binary
	 * @static
	 * @since 0.6.0
	 */
	s.BINARY = "binary";

	/**
	 * The preload type for css files. CSS files are loaded using a &lt;link&gt; when loaded with XHR, or a
	 * &lt;style&gt; tag when loaded with tags.
	 * @property CSS
	 * @type {String}
	 * @default css
	 * @static
	 * @since 0.6.0
	 */
	s.CSS = "css";

	/**
	 * The preload type for image files, usually png, gif, or jpg/jpeg. Images are loaded into an &lt;image&gt; tag.
	 * @property IMAGE
	 * @type {String}
	 * @default image
	 * @static
	 * @since 0.6.0
	 */
	s.IMAGE = "image";

	/**
	 * The preload type for javascript files, usually with the "js" file extension. JavaScript files are loaded into a
	 * &lt;script&gt; tag.
	 *
	 * Since version 0.4.1+, due to how tag-loaded scripts work, all JavaScript files are automatically injected into
	 * the body of the document to maintain parity between XHR and tag-loaded scripts. In version 0.4.0 and earlier,
	 * only tag-loaded scripts are injected.
	 * @property JAVASCRIPT
	 * @type {String}
	 * @default javascript
	 * @static
	 * @since 0.6.0
	 */
	s.JAVASCRIPT = "javascript";

	/**
	 * The preload type for json files, usually with the "json" file extension. JSON data is loaded and parsed into a
	 * JavaScript object. Note that if a `callback` is present on the load item, the file will be loaded with JSONP,
	 * no matter what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}} property is set to, and the JSON
	 * must contain a matching wrapper function.
	 * @property JSON
	 * @type {String}
	 * @default json
	 * @static
	 * @since 0.6.0
	 */
	s.JSON = "json";

	/**
	 * The preload type for jsonp files, usually with the "json" file extension. JSON data is loaded and parsed into a
	 * JavaScript object. You are required to pass a callback parameter that matches the function wrapper in the JSON.
	 * Note that JSONP will always be used if there is a callback present, no matter what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}}
	 * property is set to.
	 * @property JSONP
	 * @type {String}
	 * @default jsonp
	 * @static
	 * @since 0.6.0
	 */
	s.JSONP = "jsonp";

	/**
	 * The preload type for json-based manifest files, usually with the "json" file extension. The JSON data is loaded
	 * and parsed into a JavaScript object. PreloadJS will then look for a "manifest" property in the JSON, which is an
	 * Array of files to load, following the same format as the {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}
	 * method. If a "callback" is specified on the manifest object, then it will be loaded using JSONP instead,
	 * regardless of what the {{#crossLink "LoadQueue/preferXHR:property"}}{{/crossLink}} property is set to.
	 * @property MANIFEST
	 * @type {String}
	 * @default manifest
	 * @static
	 * @since 0.6.0
	 */
	s.MANIFEST = "manifest";

	/**
	 * The preload type for sound files, usually mp3, ogg, or wav. When loading via tags, audio is loaded into an
	 * &lt;audio&gt; tag.
	 * @property SOUND
	 * @type {String}
	 * @default sound
	 * @static
	 * @since 0.6.0
	 */
	s.SOUND = "sound";

	/**
	 * The preload type for video files, usually mp4, ts, or ogg. When loading via tags, video is loaded into an
	 * &lt;video&gt; tag.
	 * @property VIDEO
	 * @type {String}
	 * @default video
	 * @static
	 * @since 0.6.0
	 */
	s.VIDEO = "video";

	/**
	 * The preload type for SpriteSheet files. SpriteSheet files are JSON files that contain string image paths.
	 * @property SPRITESHEET
	 * @type {String}
	 * @default spritesheet
	 * @static
	 * @since 0.6.0
	 */
	s.SPRITESHEET = "spritesheet";

	/**
	 * The preload type for SVG files.
	 * @property SVG
	 * @type {String}
	 * @default svg
	 * @static
	 * @since 0.6.0
	 */
	s.SVG = "svg";

	/**
	 * The preload type for text files, which is also the default file type if the type can not be determined. Text is
	 * loaded as raw text.
	 * @property TEXT
	 * @type {String}
	 * @default text
	 * @static
	 * @since 0.6.0
	 */
	s.TEXT = "text";

	/**
	 * The preload type for xml files. XML is loaded into an XML document.
	 * @property XML
	 * @type {String}
	 * @default xml
	 * @static
	 * @since 0.6.0
	 */
	s.XML = "xml";

// Events
	/**
	 * The {{#crossLink "ProgressEvent"}}{{/crossLink}} that is fired when the overall progress changes. Prior to
	 * version 0.6.0, this was just a regular {{#crossLink "Event"}}{{/crossLink}}.
	 * @event progress
	 * @since 0.3.0
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when a load starts.
	 * @event loadstart
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @since 0.3.1
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when the entire queue has been loaded.
	 * @event complete
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @since 0.3.0
	 */

	/**
	 * The {{#crossLink "ErrorEvent"}}{{/crossLink}} that is fired when the loader encounters an error. If the error was
	 * encountered by a file, the event will contain the item that caused the error. Prior to version 0.6.0, this was
	 * just a regular {{#crossLink "Event"}}{{/crossLink}}.
	 * @event error
	 * @since 0.3.0
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when the loader encounters an internal file load error.
	 * This enables loaders to maintain internal queues, and surface file load errors.
	 * @event fileerror
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The even type ("fileerror")
	 * @param {LoadItem|object} The item that encountered the error
	 * @since 0.6.0
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired when a loader internally loads a file. This enables
	 * loaders such as {{#crossLink "ManifestLoader"}}{{/crossLink}} to maintain internal {{#crossLink "LoadQueue"}}{{/crossLink}}s
	 * and notify when they have loaded a file. The {{#crossLink "LoadQueue"}}{{/crossLink}} class dispatches a
	 * slightly different {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event.
	 * @event fileload
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type ("fileload")
	 * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a `src` property.
	 * @param {Object} result The HTML tag or parsed result of the loaded item.
	 * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted
	 * to a usable object.
	 * @since 0.6.0
	 */

	/**
	 * The {{#crossLink "Event"}}{{/crossLink}} that is fired after the internal request is created, but before a load.
	 * This allows updates to the loader for specific loading needs, such as binary or XHR image loading.
	 * @event initialize
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type ("initialize")
	 * @param {AbstractLoader} loader The loader that has been initialized.
	 */


	/**
	 * Get a reference to the manifest item that is loaded by this loader. In some cases this will be the value that was
	 * passed into {{#crossLink "LoadQueue"}}{{/crossLink}} using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or
	 * {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. However if only a String path was passed in, then it will
	 * be a {{#crossLink "LoadItem"}}{{/crossLink}}.
	 * @method getItem
	 * @return {Object} The manifest item that this loader is responsible for loading.
	 * @since 0.6.0
	 */
	p.getItem = function () {
		return this._item;
	};

	/**
	 * Get a reference to the content that was loaded by the loader (only available after the {{#crossLink "complete:event"}}{{/crossLink}}
	 * event is dispatched.
	 * @method getResult
	 * @param {Boolean} [raw=false] Determines if the returned result will be the formatted content, or the raw loaded
	 * data (if it exists).
	 * @return {Object}
	 * @since 0.6.0
	 */
	p.getResult = function (raw) {
		return raw ? this._rawResult : this._result;
	};

	/**
	 * Return the `tag` this object creates or uses for loading.
	 * @method getTag
	 * @return {Object} The tag instance
	 * @since 0.6.0
	 */
	p.getTag = function () {
		return this._tag;
	};

	/**
	 * Set the `tag` this item uses for loading.
	 * @method setTag
	 * @param {Object} tag The tag instance
	 * @since 0.6.0
	 */
	p.setTag = function(tag) {
	  this._tag = tag;
	};

	/**
	 * Begin loading the item. This method is required when using a loader by itself.
	 *
	 * <h4>Example</h4>
	 *
	 *      var queue = new createjs.LoadQueue();
	 *      queue.on("complete", handleComplete);
	 *      queue.loadManifest(fileArray, false); // Note the 2nd argument that tells the queue not to start loading yet
	 *      queue.load();
	 *
	 * @method load
	 */
	p.load = function () {
		this._createRequest();

		this._request.on("complete", this, this);
		this._request.on("progress", this, this);
		this._request.on("loadStart", this, this);
		this._request.on("abort", this, this);
		this._request.on("timeout", this, this);
		this._request.on("error", this, this);

		var evt = new createjs.Event("initialize");
		evt.loader = this._request;
		this.dispatchEvent(evt);

		this._request.load();
	};

	/**
	 * Close the the item. This will stop any open requests (although downloads using HTML tags may still continue in
	 * the background), but events will not longer be dispatched.
	 * @method cancel
	 */
	p.cancel = function () {
		this.canceled = true;
		this.destroy();
	};

	/**
	 * Clean up the loader.
	 * @method destroy
	 */
	p.destroy = function() {
		if (this._request) {
			this._request.removeAllEventListeners();
			this._request.destroy();
		}

		this._request = null;

		this._item = null;
		this._rawResult = null;
		this._result = null;

		this._loadItems = null;

		this.removeAllEventListeners();
	};

	/**
	 * Get any items loaded internally by the loader. The enables loaders such as {{#crossLink "ManifestLoader"}}{{/crossLink}}
	 * to expose items it loads internally.
	 * @method getLoadedItems
	 * @return {Array} A list of the items loaded by the loader.
	 * @since 0.6.0
	 */
	p.getLoadedItems = function () {
		return this._loadedItems;
	};


	// Private methods
	/**
	 * Create an internal request used for loading. By default, an {{#crossLink "XHRRequest"}}{{/crossLink}} or
	 * {{#crossLink "TagRequest"}}{{/crossLink}} is created, depending on the value of {{#crossLink "preferXHR:property"}}{{/crossLink}}.
	 * Other loaders may override this to use different request types, such as {{#crossLink "ManifestLoader"}}{{/crossLink}},
	 * which uses {{#crossLink "JSONLoader"}}{{/crossLink}} or {{#crossLink "JSONPLoader"}}{{/crossLink}} under the hood.
	 * @method _createRequest
	 * @protected
	 */
	p._createRequest = function() {
		if (!this._preferXHR) {
			this._request = new createjs.TagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);
		} else {
			this._request = new createjs.XHRRequest(this._item);
		}
	};

	/**
	 * Create the HTML tag used for loading. This method does nothing by default, and needs to be implemented
	 * by loaders that require tag loading.
	 * @method _createTag
	 * @param {String} src The tag source
	 * @return {HTMLElement} The tag that was created
	 * @protected
	 */
	p._createTag = function(src) { return null; };

	/**
	 * Dispatch a loadstart {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/loadstart:event"}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendLoadStart
	 * @protected
	 */
	p._sendLoadStart = function () {
		if (this._isCanceled()) { return; }
		this.dispatchEvent("loadstart");
	};

	/**
	 * Dispatch a {{#crossLink "ProgressEvent"}}{{/crossLink}}.
	 * @method _sendProgress
	 * @param {Number | Object} value The progress of the loaded item, or an object containing <code>loaded</code>
	 * and <code>total</code> properties.
	 * @protected
	 */
	p._sendProgress = function (value) {
		if (this._isCanceled()) { return; }
		var event = null;
		if (typeof(value) == "number") {
			this.progress = value;
			event = new createjs.ProgressEvent(this.progress);
		} else {
			event = value;
			this.progress = value.loaded / value.total;
			event.progress = this.progress;
			if (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }
		}
		this.hasEventListener("progress") && this.dispatchEvent(event);
	};

	/**
	 * Dispatch a complete {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}} event
	 * @method _sendComplete
	 * @protected
	 */
	p._sendComplete = function () {
		if (this._isCanceled()) { return; }

		this.loaded = true;

		var event = new createjs.Event("complete");
		event.rawResult = this._rawResult;

		if (this._result != null) {
			event.result = this._result;
		}

		this.dispatchEvent(event);
	};

	/**
	 * Dispatch an error {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendError
	 * @param {ErrorEvent} event The event object containing specific error properties.
	 * @protected
	 */
	p._sendError = function (event) {
		if (this._isCanceled() || !this.hasEventListener("error")) { return; }
		if (event == null) {
			event = new createjs.ErrorEvent("PRELOAD_ERROR_EMPTY"); // TODO: Populate error
		}
		this.dispatchEvent(event);
	};

	/**
	 * Determine if the load has been canceled. This is important to ensure that method calls or asynchronous events
	 * do not cause issues after the queue has been cleaned up.
	 * @method _isCanceled
	 * @return {Boolean} If the loader has been canceled.
	 * @protected
	 */
	p._isCanceled = function () {
		if (window.createjs == null || this.canceled) {
			return true;
		}
		return false;
	};

	/**
	 * A custom result formatter function, which is called just before a request dispatches its complete event. Most
	 * loader types already have an internal formatter, but this can be user-overridden for custom formatting. The
	 * formatted result will be available on Loaders using {{#crossLink "getResult"}}{{/crossLink}}, and passing `true`.
	 * @property resultFormatter
	 * @type Function
	 * @return {Object} The formatted result
	 * @since 0.6.0
	 */
	p.resultFormatter = null;

	/**
	 * Handle events from internal requests. By default, loaders will handle, and redispatch the necessary events, but
	 * this method can be overridden for custom behaviours.
	 * @method handleEvent
	 * @param {Event} event The event that the internal request dispatches.
	 * @protected
	 * @since 0.6.0
	 */
	p.handleEvent = function (event) {
		switch (event.type) {
			case "complete":
				this._rawResult = event.target._response;
				var result = this.resultFormatter && this.resultFormatter(this);
				var _this = this;
				if (result instanceof Function) {
					result(function(result) {
						_this._result = result;
						_this._sendComplete();
					});
				} else {
					this._result =  result || this._rawResult;
					this._sendComplete();
				}
				break;
			case "progress":
				this._sendProgress(event);
				break;
			case "error":
				this._sendError(event);
				break;
			case "loadstart":
				this._sendLoadStart();
				break;
			case "abort":
			case "timeout":
				if (!this._isCanceled()) {
					this.dispatchEvent(event.type);
				}
				break;
		}
	};

	/**
	 * @method buildPath
	 * @protected
	 * @deprecated Use the {{#crossLink "RequestUtils"}}{{/crossLink}} method {{#crossLink "RequestUtils/buildPath"}}{{/crossLink}}
	 * instead.
	 */
	p.buildPath = function (src, data) {
		return createjs.RequestUtils.buildPath(src, data);
	};

	/**
	 * @method toString
	 * @return {String} a string representation of the instance.
	 */
	p.toString = function () {
		return "[PreloadJS AbstractLoader]";
	};

	createjs.AbstractLoader = createjs.promote(AbstractLoader, "EventDispatcher");

}());

//##############################################################################
// AbstractMediaLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * The AbstractMediaLoader is a base class that handles some of the shared methods and properties of loaders that
	 * handle HTML media elements, such as Video and Audio.
	 * @class AbstractMediaLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @param {String} type The type of media to load. Usually "video" or "audio".
	 * @extends AbstractLoader
	 * @constructor
	 */
	function AbstractMediaLoader(loadItem, preferXHR, type) {
		this.AbstractLoader_constructor(loadItem, preferXHR, type);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = "src";
	};

	var p = createjs.extend(AbstractMediaLoader, createjs.AbstractLoader);

	// static properties
	// public methods
	p.load = function () {
		// TagRequest will handle most of this, but Sound / Video need a few custom properties, so just handle them here.
		if (!this._tag) {
			this._tag = this._createTag(this._item.src);
		}

		this._tag.preload = "auto";
		this._tag.load();

		this.AbstractLoader_load();
	};

	// protected methods
	/**
	 * Creates a new tag for loading if it doesn't exist yet.
	 * @method _createTag
	 * @private
	 */
	p._createTag = function () {};


	p._createRequest = function() {
		if (!this._preferXHR) {
			this._request = new createjs.MediaTagRequest(this._item, this._tag || this._createTag(), this._tagSrcAttribute);
		} else {
			this._request = new createjs.XHRRequest(this._item);
		}
	};

	/**
	 * The result formatter for media files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLVideoElement|HTMLAudioElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler);
		this._tag.onstalled = null;
		if (this._preferXHR) {
			loader.getTag().src = loader.getResult(true);
		}
		return loader.getTag();
	};

	createjs.AbstractMediaLoader = createjs.promote(AbstractMediaLoader, "AbstractLoader");

}());

//##############################################################################
// AbstractRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	/**
	 * A base class for actual data requests, such as {{#crossLink "XHRRequest"}}{{/crossLink}}, {{#crossLink "TagRequest"}}{{/crossLink}},
	 * and {{#crossLink "MediaRequest"}}{{/crossLink}}. PreloadJS loaders will typically use a data loader under the
	 * hood to get data.
	 * @class AbstractRequest
	 * @param {LoadItem} item
	 * @constructor
	 */
	var AbstractRequest = function (item) {
		this._item = item;
	};

	var p = createjs.extend(AbstractRequest, createjs.EventDispatcher);

	// public methods
	/**
	 * Begin a load.
	 * @method load
	 */
	p.load =  function() {};

	/**
	 * Clean up a request.
	 * @method destroy
	 */
	p.destroy = function() {};

	/**
	 * Cancel an in-progress request.
	 * @method cancel
	 */
	p.cancel = function() {};

	createjs.AbstractRequest = createjs.promote(AbstractRequest, "EventDispatcher");

}());

//##############################################################################
// TagRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * An {{#crossLink "AbstractRequest"}}{{/crossLink}} that loads HTML tags, such as images and scripts.
	 * @class TagRequest
	 * @param {LoadItem} loadItem
	 * @param {HTMLElement} tag
	 * @param {String} srcAttribute The tag attribute that specifies the source, such as "src", "href", etc.
	 */
	function TagRequest(loadItem, tag, srcAttribute) {
		this.AbstractRequest_constructor(loadItem);

		// protected properties
		/**
		 * The HTML tag instance that is used to load.
		 * @property _tag
		 * @type {HTMLElement}
		 * @protected
		 */
		this._tag = tag;

		/**
		 * The tag attribute that specifies the source, such as "src", "href", etc.
		 * @property _tagSrcAttribute
		 * @type {String}
		 * @protected
		 */
		this._tagSrcAttribute = srcAttribute;

		/**
		 * A method closure used for handling the tag load event.
		 * @property _loadedHandler
		 * @type {Function}
		 * @private
		 */
		this._loadedHandler = createjs.proxy(this._handleTagComplete, this);

		/**
		 * Determines if the element was added to the DOM automatically by PreloadJS, so it can be cleaned up after.
		 * @property _addedToDOM
		 * @type {Boolean}
		 * @private
		 */
		this._addedToDOM = false;

		/**
		 * Determines what the tags initial style.visibility was, so we can set it correctly after a load.
		 *
		 * @type {null}
		 * @private
		 */
		this._startTagVisibility = null;
	};

	var p = createjs.extend(TagRequest, createjs.AbstractRequest);

	// public methods
	p.load = function () {
		this._tag.onload = createjs.proxy(this._handleTagComplete, this);
		this._tag.onreadystatechange = createjs.proxy(this._handleReadyStateChange, this);
		this._tag.onerror = createjs.proxy(this._handleError, this);

		var evt = new createjs.Event("initialize");
		evt.loader = this._tag;

		this.dispatchEvent(evt);

		this._hideTag();

		this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);

		this._tag[this._tagSrcAttribute] = this._item.src;

		// wdg:: Append the tag AFTER setting the src, or SVG loading on iOS will fail.
		if (this._tag.parentNode == null) {
			window.document.body.appendChild(this._tag);
			this._addedToDOM = true;
		}
	};

	p.destroy = function() {
		this._clean();
		this._tag = null;

		this.AbstractRequest_destroy();
	};

	// private methods
	/**
	 * Handle the readyStateChange event from a tag. We need this in place of the `onload` callback (mainly SCRIPT
	 * and LINK tags), but other cases may exist.
	 * @method _handleReadyStateChange
	 * @private
	 */
	p._handleReadyStateChange = function () {
		clearTimeout(this._loadTimeout);
		// This is strictly for tags in browsers that do not support onload.
		var tag = this._tag;

		// Complete is for old IE support.
		if (tag.readyState == "loaded" || tag.readyState == "complete") {
			this._handleTagComplete();
		}
	};

	/**
	 * Handle any error events from the tag.
	 * @method _handleError
	 * @protected
	 */
	p._handleError = function() {
		this._clean();
		this.dispatchEvent("error");
	};

	/**
	 * Handle the tag's onload callback.
	 * @method _handleTagComplete
	 * @private
	 */
	p._handleTagComplete = function () {
		this._rawResult = this._tag;
		this._result = this.resultFormatter && this.resultFormatter(this) || this._rawResult;

		this._clean();
		this._showTag();

		this.dispatchEvent("complete");
	};

	/**
	 * The tag request has not loaded within the time specified in loadTimeout.
	 * @method _handleError
	 * @param {Object} event The XHR error event.
	 * @private
	 */
	p._handleTimeout = function () {
		this._clean();
		this.dispatchEvent(new createjs.Event("timeout"));
	};

	/**
	 * Remove event listeners, but don't destroy the request object
	 * @method _clean
	 * @private
	 */
	p._clean = function() {
		this._tag.onload = null;
		this._tag.onreadystatechange = null;
		this._tag.onerror = null;
		if (this._addedToDOM && this._tag.parentNode != null) {
			this._tag.parentNode.removeChild(this._tag);
		}
		clearTimeout(this._loadTimeout);
	};

	p._hideTag = function() {
		this._startTagVisibility = this._tag.style.visibility;
		this._tag.style.visibility = "hidden";
	};

	p._showTag = function() {
		this._tag.style.visibility = this._startTagVisibility;
	};

	/**
	 * Handle a stalled audio event. The main place this happens is with HTMLAudio in Chrome when playing back audio
	 * that is already in a load, but not complete.
	 * @method _handleStalled
	 * @private
	 */
	p._handleStalled = function () {
		//Ignore, let the timeout take care of it. Sometimes its not really stopped.
	};

	createjs.TagRequest = createjs.promote(TagRequest, "AbstractRequest");

}());

//##############################################################################
// MediaTagRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * An {{#crossLink "TagRequest"}}{{/crossLink}} that loads HTML tags for video and audio.
	 * @class MediaTagRequest
	 * @param {LoadItem} loadItem
	 * @param {HTMLAudioElement|HTMLVideoElement} tag
	 * @param {String} srcAttribute The tag attribute that specifies the source, such as "src", "href", etc.
	 * @constructor
	 */
	function MediaTagRequest(loadItem, tag, srcAttribute) {
		this.AbstractRequest_constructor(loadItem);

		// protected properties
		this._tag = tag;
		this._tagSrcAttribute = srcAttribute;
		this._loadedHandler = createjs.proxy(this._handleTagComplete, this);
	};

	var p = createjs.extend(MediaTagRequest, createjs.TagRequest);
	var s = MediaTagRequest;

	// public methods
	p.load = function () {
		var sc = createjs.proxy(this._handleStalled, this);
		this._stalledCallback = sc;

		var pc = createjs.proxy(this._handleProgress, this);
		this._handleProgress = pc;

		this._tag.addEventListener("stalled", sc);
		this._tag.addEventListener("progress", pc);

		// This will tell us when audio is buffered enough to play through, but not when its loaded.
		// The tag doesn't keep loading in Chrome once enough has buffered, and we have decided that behaviour is sufficient.
		this._tag.addEventListener && this._tag.addEventListener("canplaythrough", this._loadedHandler, false); // canplaythrough callback doesn't work in Chrome, so we use an event.

		this.TagRequest_load();
	};

	// private methods
	p._handleReadyStateChange = function () {
		clearTimeout(this._loadTimeout);
		// This is strictly for tags in browsers that do not support onload.
		var tag = this._tag;

		// Complete is for old IE support.
		if (tag.readyState == "loaded" || tag.readyState == "complete") {
			this._handleTagComplete();
		}
	};

	p._handleStalled = function () {
		//Ignore, let the timeout take care of it. Sometimes its not really stopped.
	};

	/**
	 * An XHR request has reported progress.
	 * @method _handleProgress
	 * @param {Object} event The XHR progress event.
	 * @private
	 */
	p._handleProgress = function (event) {
		if (!event || event.loaded > 0 && event.total == 0) {
			return; // Sometimes we get no "total", so just ignore the progress event.
		}

		var newEvent = new createjs.ProgressEvent(event.loaded, event.total);
		this.dispatchEvent(newEvent);
	};

	// protected methods
	p._clean = function () {
		this._tag.removeEventListener && this._tag.removeEventListener("canplaythrough", this._loadedHandler);
		this._tag.removeEventListener("stalled", this._stalledCallback);
		this._tag.removeEventListener("progress", this._progressCallback);

		this.TagRequest__clean();
	};

	createjs.MediaTagRequest = createjs.promote(MediaTagRequest, "TagRequest");

}());

//##############################################################################
// XHRRequest.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

// constructor
	/**
	 * A preloader that loads items using XHR requests, usually XMLHttpRequest. However XDomainRequests will be used
	 * for cross-domain requests if possible, and older versions of IE fall back on to ActiveX objects when necessary.
	 * XHR requests load the content as text or binary data, provide progress and consistent completion events, and
	 * can be canceled during load. Note that XHR is not supported in IE 6 or earlier, and is not recommended for
	 * cross-domain loading.
	 * @class XHRRequest
	 * @constructor
	 * @param {Object} item The object that defines the file to load. Please see the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * for an overview of supported file properties.
	 * @extends AbstractLoader
	 */
	function XHRRequest (item) {
		this.AbstractRequest_constructor(item);

		// protected properties
		/**
		 * A reference to the XHR request used to load the content.
		 * @property _request
		 * @type {XMLHttpRequest | XDomainRequest | ActiveX.XMLHTTP}
		 * @private
		 */
		this._request = null;

		/**
		 * A manual load timeout that is used for browsers that do not support the onTimeout event on XHR (XHR level 1,
		 * typically IE9).
		 * @property _loadTimeout
		 * @type {Number}
		 * @private
		 */
		this._loadTimeout = null;

		/**
		 * The browser's XHR (XMLHTTPRequest) version. Supported versions are 1 and 2. There is no official way to detect
		 * the version, so we use capabilities to make a best guess.
		 * @property _xhrLevel
		 * @type {Number}
		 * @default 1
		 * @private
		 */
		this._xhrLevel = 1;

		/**
		 * The response of a loaded file. This is set because it is expensive to look up constantly. This property will be
		 * null until the file is loaded.
		 * @property _response
		 * @type {mixed}
		 * @private
		 */
		this._response = null;

		/**
		 * The response of the loaded file before it is modified. In most cases, content is converted from raw text to
		 * an HTML tag or a formatted object which is set to the <code>result</code> property, but the developer may still
		 * want to access the raw content as it was loaded.
		 * @property _rawResponse
		 * @type {String|Object}
		 * @private
		 */
		this._rawResponse = null;

		this._canceled = false;

		// Setup our event handlers now.
		this._handleLoadStartProxy = createjs.proxy(this._handleLoadStart, this);
		this._handleProgressProxy = createjs.proxy(this._handleProgress, this);
		this._handleAbortProxy = createjs.proxy(this._handleAbort, this);
		this._handleErrorProxy = createjs.proxy(this._handleError, this);
		this._handleTimeoutProxy = createjs.proxy(this._handleTimeout, this);
		this._handleLoadProxy = createjs.proxy(this._handleLoad, this);
		this._handleReadyStateChangeProxy = createjs.proxy(this._handleReadyStateChange, this);

		if (!this._createXHR(item)) {
			//TODO: Throw error?
		}
	};

	var p = createjs.extend(XHRRequest, createjs.AbstractRequest);

// static properties
	/**
	 * A list of XMLHTTP object IDs to try when building an ActiveX object for XHR requests in earlier versions of IE.
	 * @property ACTIVEX_VERSIONS
	 * @type {Array}
	 * @since 0.4.2
	 * @private
	 */
	XHRRequest.ACTIVEX_VERSIONS = [
		"Msxml2.XMLHTTP.6.0",
		"Msxml2.XMLHTTP.5.0",
		"Msxml2.XMLHTTP.4.0",
		"MSXML2.XMLHTTP.3.0",
		"MSXML2.XMLHTTP",
		"Microsoft.XMLHTTP"
	];

// Public methods
	/**
	 * Look up the loaded result.
	 * @method getResult
	 * @param {Boolean} [raw=false] Return a raw result instead of a formatted result. This applies to content
	 * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be
	 * returned instead.
	 * @return {Object} A result object containing the content that was loaded, such as:
	 * <ul>
	 *      <li>An image tag (&lt;image /&gt;) for images</li>
	 *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts loaded with tags may be added to the
	 *      HTML head.</li>
	 *      <li>A style tag for CSS (&lt;style /&gt;)</li>
	 *      <li>Raw text for TEXT</li>
	 *      <li>A formatted JavaScript object defined by JSON</li>
	 *      <li>An XML document</li>
	 *      <li>An binary arraybuffer loaded by XHR</li>
	 * </ul>
	 * Note that if a raw result is requested, but not found, the result will be returned instead.
	 */
	p.getResult = function (raw) {
		if (raw && this._rawResponse) {
			return this._rawResponse;
		}
		return this._response;
	};

	// Overrides abstract method in AbstractRequest
	p.cancel = function () {
		this.canceled = true;
		this._clean();
		this._request.abort();
	};

	// Overrides abstract method in AbstractLoader
	p.load = function () {
		if (this._request == null) {
			this._handleError();
			return;
		}

		//Events
		if (this._request.addEventListener != null) {
			this._request.addEventListener("loadstart", this._handleLoadStartProxy, false);
			this._request.addEventListener("progress", this._handleProgressProxy, false);
			this._request.addEventListener("abort", this._handleAbortProxy, false);
			this._request.addEventListener("error", this._handleErrorProxy, false);
			this._request.addEventListener("timeout", this._handleTimeoutProxy, false);

			// Note: We don't get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.
			this._request.addEventListener("load", this._handleLoadProxy, false);
			this._request.addEventListener("readystatechange", this._handleReadyStateChangeProxy, false);
		} else {
			// IE9 support
			this._request.onloadstart = this._handleLoadStartProxy;
			this._request.onprogress = this._handleProgressProxy;
			this._request.onabort = this._handleAbortProxy;
			this._request.onerror = this._handleErrorProxy;
			this._request.ontimeout = this._handleTimeoutProxy;

			// Note: We don't get onload in all browsers (earlier FF and IE). onReadyStateChange handles these.
			this._request.onload = this._handleLoadProxy;
			this._request.onreadystatechange = this._handleReadyStateChangeProxy;
		}

		// Set up a timeout if we don't have XHR2
		if (this._xhrLevel == 1) {
			this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);
		}

		// Sometimes we get back 404s immediately, particularly when there is a cross origin request.  // note this does not catch in Chrome
		try {
			if (!this._item.values || this._item.method == createjs.AbstractLoader.GET) {
				this._request.send();
			} else if (this._item.method == createjs.AbstractLoader.POST) {
				this._request.send(createjs.RequestUtils.formatQueryString(this._item.values));
			}
		} catch (error) {
			this.dispatchEvent(new createjs.ErrorEvent("XHR_SEND", null, error));
		}
	};

	p.setResponseType = function (type) {
		// Some old browsers doesn't support blob, so we convert arraybuffer to blob after response is downloaded
		if (type === 'blob') {
			type = window.URL ? 'blob' : 'arraybuffer';
			this._responseType = type;
		}
		this._request.responseType = type;
	};

	/**
	 * Get all the response headers from the XmlHttpRequest.
	 *
	 * <strong>From the docs:</strong> Return all the HTTP headers, excluding headers that are a case-insensitive match
	 * for Set-Cookie or Set-Cookie2, as a single string, with each header line separated by a U+000D CR U+000A LF pair,
	 * excluding the status line, and with each header name and header value separated by a U+003A COLON U+0020 SPACE
	 * pair.
	 * @method getAllResponseHeaders
	 * @return {String}
	 * @since 0.4.1
	 */
	p.getAllResponseHeaders = function () {
		if (this._request.getAllResponseHeaders instanceof Function) {
			return this._request.getAllResponseHeaders();
		} else {
			return null;
		}
	};

	/**
	 * Get a specific response header from the XmlHttpRequest.
	 *
	 * <strong>From the docs:</strong> Returns the header field value from the response of which the field name matches
	 * header, unless the field name is Set-Cookie or Set-Cookie2.
	 * @method getResponseHeader
	 * @param {String} header The header name to retrieve.
	 * @return {String}
	 * @since 0.4.1
	 */
	p.getResponseHeader = function (header) {
		if (this._request.getResponseHeader instanceof Function) {
			return this._request.getResponseHeader(header);
		} else {
			return null;
		}
	};

// protected methods
	/**
	 * The XHR request has reported progress.
	 * @method _handleProgress
	 * @param {Object} event The XHR progress event.
	 * @private
	 */
	p._handleProgress = function (event) {
		if (!event || event.loaded > 0 && event.total == 0) {
			return; // Sometimes we get no "total", so just ignore the progress event.
		}

		var newEvent = new createjs.ProgressEvent(event.loaded, event.total);
		this.dispatchEvent(newEvent);
	};

	/**
	 * The XHR request has reported a load start.
	 * @method _handleLoadStart
	 * @param {Object} event The XHR loadStart event.
	 * @private
	 */
	p._handleLoadStart = function (event) {
		clearTimeout(this._loadTimeout);
		this.dispatchEvent("loadstart");
	};

	/**
	 * The XHR request has reported an abort event.
	 * @method handleAbort
	 * @param {Object} event The XHR abort event.
	 * @private
	 */
	p._handleAbort = function (event) {
		this._clean();
		this.dispatchEvent(new createjs.ErrorEvent("XHR_ABORTED", null, event));
	};

	/**
	 * The XHR request has reported an error event.
	 * @method _handleError
	 * @param {Object} event The XHR error event.
	 * @private
	 */
	p._handleError = function (event) {
		this._clean();
		this.dispatchEvent(new createjs.ErrorEvent(event.message));
	};

	/**
	 * The XHR request has reported a readyState change. Note that older browsers (IE 7 & 8) do not provide an onload
	 * event, so we must monitor the readyStateChange to determine if the file is loaded.
	 * @method _handleReadyStateChange
	 * @param {Object} event The XHR readyStateChange event.
	 * @private
	 */
	p._handleReadyStateChange = function (event) {
		if (this._request.readyState == 4) {
			this._handleLoad();
		}
	};

	/**
	 * The XHR request has completed. This is called by the XHR request directly, or by a readyStateChange that has
	 * <code>request.readyState == 4</code>. Only the first call to this method will be processed.
	 * @method _handleLoad
	 * @param {Object} event The XHR load event.
	 * @private
	 */
	p._handleLoad = function (event) {
		if (this.loaded) {
			return;
		}
		this.loaded = true;

		var error = this._checkError();
		if (error) {
			this._handleError(error);
			return;
		}

		this._response = this._getResponse();
		// Convert arraybuffer back to blob
		if (this._responseType === 'arraybuffer') {
			try {
				this._response = new Blob([this._response]);
			} catch (e) {
				// Fallback to use BlobBuilder if Blob constructor is not supported
				// Tested on Android 2.3 ~ 4.2 and iOS5 safari
				window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
				if (e.name === 'TypeError' && window.BlobBuilder) {
					var builder = new BlobBuilder();
					builder.append(this._response);
					this._response = builder.getBlob();
				}
			}
		}
		this._clean();

		this.dispatchEvent(new createjs.Event("complete"));
	};

	/**
	 * The XHR request has timed out. This is called by the XHR request directly, or via a <code>setTimeout</code>
	 * callback.
	 * @method _handleTimeout
	 * @param {Object} [event] The XHR timeout event. This is occasionally null when called by the backup setTimeout.
	 * @private
	 */
	p._handleTimeout = function (event) {
		this._clean();

		this.dispatchEvent(new createjs.ErrorEvent("PRELOAD_TIMEOUT", null, event));
	};

// Protected
	/**
	 * Determine if there is an error in the current load. This checks the status of the request for problem codes. Note
	 * that this does not check for an actual response. Currently, it only checks for 404 or 0 error code.
	 * @method _checkError
	 * @return {int} If the request status returns an error code.
	 * @private
	 */
	p._checkError = function () {
		//LM: Probably need additional handlers here, maybe 501
		var status = parseInt(this._request.status);

		switch (status) {
			case 404:   // Not Found
			case 0:     // Not Loaded
				return new Error(status);
		}
		return null;
	};

	/**
	 * Validate the response. Different browsers have different approaches, some of which throw errors when accessed
	 * in other browsers. If there is no response, the <code>_response</code> property will remain null.
	 * @method _getResponse
	 * @private
	 */
	p._getResponse = function () {
		if (this._response != null) {
			return this._response;
		}

		if (this._request.response != null) {
			return this._request.response;
		}

		// Android 2.2 uses .responseText
		try {
			if (this._request.responseText != null) {
				return this._request.responseText;
			}
		} catch (e) {
		}

		// When loading XML, IE9 does not return .response, instead it returns responseXML.xml
		try {
			if (this._request.responseXML != null) {
				return this._request.responseXML;
			}
		} catch (e) {
		}

		return null;
	};

	/**
	 * Create an XHR request. Depending on a number of factors, we get totally different results.
	 * <ol><li>Some browsers get an <code>XDomainRequest</code> when loading cross-domain.</li>
	 *      <li>XMLHttpRequest are created when available.</li>
	 *      <li>ActiveX.XMLHTTP objects are used in older IE browsers.</li>
	 *      <li>Text requests override the mime type if possible</li>
	 *      <li>Origin headers are sent for crossdomain requests in some browsers.</li>
	 *      <li>Binary loads set the response type to "arraybuffer"</li></ol>
	 * @method _createXHR
	 * @param {Object} item The requested item that is being loaded.
	 * @return {Boolean} If an XHR request or equivalent was successfully created.
	 * @private
	 */
	p._createXHR = function (item) {
		// Check for cross-domain loads. We can't fully support them, but we can try.
		var crossdomain = createjs.RequestUtils.isCrossDomain(item);
		var headers = {};

		// Create the request. Fallback to whatever support we have.
		var req = null;
		if (window.XMLHttpRequest) {
			req = new XMLHttpRequest();
			// This is 8 or 9, so use XDomainRequest instead.
			if (crossdomain && req.withCredentials === undefined && window.XDomainRequest) {
				req = new XDomainRequest();
			}
		} else { // Old IE versions use a different approach
			for (var i = 0, l = s.ACTIVEX_VERSIONS.length; i < l; i++) {
				var axVersion = s.ACTIVEX_VERSIONS[i];
				try {
					req = new ActiveXObject(axVersion);
					break;
				} catch (e) {
				}
			}
			if (req == null) {
				return false;
			}
		}

		// Default to utf-8 for Text requests.
		if (item.mimeType == null && createjs.RequestUtils.isText(item.type)) {
			item.mimeType = "text/plain; charset=utf-8";
		}

		// IE9 doesn't support overrideMimeType(), so we need to check for it.
		if (item.mimeType && req.overrideMimeType) {
			req.overrideMimeType(item.mimeType);
		}

		// Determine the XHR level
		this._xhrLevel = (typeof req.responseType === "string") ? 2 : 1;

		var src = null;
		if (item.method == createjs.AbstractLoader.GET) {
			src = createjs.RequestUtils.buildPath(item.src, item.values);
		} else {
			src = item.src;
		}

		// Open the request.  Set cross-domain flags if it is supported (XHR level 1 only)
		req.open(item.method || createjs.AbstractLoader.GET, src, true);

		if (crossdomain && req instanceof XMLHttpRequest && this._xhrLevel == 1) {
			headers["Origin"] = location.origin;
		}

		// To send data we need to set the Content-type header)
		if (item.values && item.method == createjs.AbstractLoader.POST) {
			headers["Content-Type"] = "application/x-www-form-urlencoded";
		}

		if (!crossdomain && !headers["X-Requested-With"]) {
			headers["X-Requested-With"] = "XMLHttpRequest";
		}

		if (item.headers) {
			for (var n in item.headers) {
				headers[n] = item.headers[n];
			}
		}

		for (n in headers) {
			req.setRequestHeader(n, headers[n])
		}

		if (req instanceof XMLHttpRequest && item.withCredentials !== undefined) {
			req.withCredentials = item.withCredentials;
		}

		this._request = req;

		return true;
	};

	/**
	 * A request has completed (or failed or canceled), and needs to be disposed.
	 * @method _clean
	 * @private
	 */
	p._clean = function () {
		clearTimeout(this._loadTimeout);

		if (this._request.removeEventListener != null) {
			this._request.removeEventListener("loadstart", this._handleLoadStartProxy);
			this._request.removeEventListener("progress", this._handleProgressProxy);
			this._request.removeEventListener("abort", this._handleAbortProxy);
			this._request.removeEventListener("error", this._handleErrorProxy);
			this._request.removeEventListener("timeout", this._handleTimeoutProxy);
			this._request.removeEventListener("load", this._handleLoadProxy);
			this._request.removeEventListener("readystatechange", this._handleReadyStateChangeProxy);
		} else {
			this._request.onloadstart = null;
			this._request.onprogress = null;
			this._request.onabort = null;
			this._request.onerror = null;
			this._request.ontimeout = null;
			this._request.onload = null;
			this._request.onreadystatechange = null;
		}
	};

	p.toString = function () {
		return "[PreloadJS XHRRequest]";
	};

	createjs.XHRRequest = createjs.promote(XHRRequest, "AbstractRequest");

}());

//##############################################################################
// LoadQueue.js
//##############################################################################

this.createjs = this.createjs || {};

/*
 TODO: WINDOWS ISSUES
 * No error for HTML audio in IE 678
 * SVG no failure error in IE 67 (maybe 8) TAGS AND XHR
 * No script complete handler in IE 67 TAGS (XHR is fine)
 * No XML/JSON in IE6 TAGS
 * Need to hide loading SVG in Opera TAGS
 * No CSS onload/readystatechange in Safari or Android TAGS (requires rule checking)
 * SVG no load or failure in Opera XHR
 * Reported issues with IE7/8
 */

(function () {
	"use strict";

// constructor
	/**
	 * The LoadQueue class is the main API for preloading content. LoadQueue is a load manager, which can preload either
	 * a single file, or queue of files.
	 *
	 * <b>Creating a Queue</b><br />
	 * To use LoadQueue, create a LoadQueue instance. If you want to force tag loading where possible, set the preferXHR
	 * argument to false.
	 *
	 *      var queue = new createjs.LoadQueue(true);
	 *
	 * <b>Listening for Events</b><br />
	 * Add any listeners you want to the queue. Since PreloadJS 0.3.0, the {{#crossLink "EventDispatcher"}}{{/crossLink}}
	 * lets you add as many listeners as you want for events. You can subscribe to the following events:<ul>
	 *     <li>{{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}}: fired when a queue completes loading all
	 *     files</li>
	 *     <li>{{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}: fired when the queue encounters an error with
	 *     any file.</li>
	 *     <li>{{#crossLink "AbstractLoader/progress:event"}}{{/crossLink}}: Progress for the entire queue has
	 *     changed.</li>
	 *     <li>{{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}: A single file has completed loading.</li>
	 *     <li>{{#crossLink "LoadQueue/fileprogress:event"}}{{/crossLink}}: Progress for a single file has changes. Note
	 *     that only files loaded with XHR (or possibly by plugins) will fire progress events other than 0 or 100%.</li>
	 * </ul>
	 *
	 *      queue.on("fileload", handleFileLoad, this);
	 *      queue.on("complete", handleComplete, this);
	 *
	 * <b>Adding files and manifests</b><br />
	 * Add files you want to load using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or add multiple files at a
	 * time using a list or a manifest definition using {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. Files are
	 * appended to the end of the active queue, so you can use these methods as many times as you like, whenever you
	 * like.
	 *
	 *      queue.loadFile("filePath/file.jpg");
	 *      queue.loadFile({id:"image", src:"filePath/file.jpg"});
	 *      queue.loadManifest(["filePath/file.jpg", {id:"image", src:"filePath/file.jpg"}]);
	 *
	 *      // Use an external manifest
	 *      queue.loadManifest("path/to/manifest.json");
	 *      queue.loadManifest({src:"manifest.json", type:"manifest"});
	 *
	 * If you pass `false` as the `loadNow` parameter, the queue will not kick of the load of the files, but it will not
	 * stop if it has already been started. Call the {{#crossLink "AbstractLoader/load"}}{{/crossLink}} method to begin
	 * a paused queue. Note that a paused queue will automatically resume when new files are added to it with a
	 * `loadNow` argument of `true`.
	 *
	 *      queue.load();
	 *
	 * <b>File Types</b><br />
	 * The file type of a manifest item is auto-determined by the file extension. The pattern matching in PreloadJS
	 * should handle the majority of standard file and url formats, and works with common file extensions. If you have
	 * either a non-standard file extension, or are serving the file using a proxy script, then you can pass in a
	 * <code>type</code> property with any manifest item.
	 *
	 *      queue.loadFile({src:"path/to/myFile.mp3x", type:createjs.AbstractLoader.SOUND});
	 *
	 *      // Note that PreloadJS will not read a file extension from the query string
	 *      queue.loadFile({src:"http://server.com/proxy?file=image.jpg", type:createjs.AbstractLoader.IMAGE});
	 *
	 * Supported types are defined on the {{#crossLink "AbstractLoader"}}{{/crossLink}} class, and include:
	 * <ul>
	 *     <li>{{#crossLink "AbstractLoader/BINARY:property"}}{{/crossLink}}: Raw binary data via XHR</li>
	 *     <li>{{#crossLink "AbstractLoader/CSS:property"}}{{/crossLink}}: CSS files</li>
	 *     <li>{{#crossLink "AbstractLoader/IMAGE:property"}}{{/crossLink}}: Common image formats</li>
	 *     <li>{{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}}: JavaScript files</li>
	 *     <li>{{#crossLink "AbstractLoader/JSON:property"}}{{/crossLink}}: JSON data</li>
	 *     <li>{{#crossLink "AbstractLoader/JSONP:property"}}{{/crossLink}}: JSON files cross-domain</li>
	 *     <li>{{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}}: A list of files to load in JSON format, see
	 *     {{#crossLink "AbstractLoader/loadManifest"}}{{/crossLink}}</li>
	 *     <li>{{#crossLink "AbstractLoader/SOUND:property"}}{{/crossLink}}: Audio file formats</li>
	 *     <li>{{#crossLink "AbstractLoader/SPRITESHEET:property"}}{{/crossLink}}: JSON SpriteSheet definiteions. This
	 *     will also load sub-images, and provide a {{#crossLink "SpriteSheet"}}{{/crossLink}} instance.</li>
	 *     <li>{{#crossLink "AbstractLoader/SVG:property"}}{{/crossLink}}: SVG files</li>
	 *     <li>{{#crossLink "AbstractLoader/TEXT:property"}}{{/crossLink}}: Text files - XHR only</li>
	 *     <li>{{#crossLink "AbstractLoader/XML:property"}}{{/crossLink}}: XML data</li>
	 * </ul>
	 *
	 * <em>Note: Loader types used to be defined on LoadQueue, but have been moved to AbstractLoader for better
	 * portability of loader classes, which can be used individually now. The properties on LoadQueue still exist, but
	 * are deprecated.</em>
	 *
	 * <b>Handling Results</b><br />
	 * When a file is finished downloading, a {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event is
	 * dispatched. In an example above, there is an event listener snippet for fileload. Loaded files are usually a
	 * formatted object that can be used immediately, including:
	 * <ul>
	 *     <li>Binary: The binary loaded result</li>
	 *     <li>CSS: A &lt;link /&gt; tag</li>
	 *     <li>Image: An &lt;img /&gt; tag</li>
	 *     <li>JavaScript: A &lt;script /&gt; tag</li>
	 *     <li>JSON/JSONP: A formatted JavaScript Object</li>
	 *     <li>Manifest: A JavaScript object.
	 *     <li>Sound: An &lt;audio /&gt; tag</a>
	 *     <li>SpriteSheet: A {{#crossLink "SpriteSheet"}}{{/crossLink}} instance, containing loaded images.
	 *     <li>SVG: An &lt;object /&gt; tag</li>
	 *     <li>Text: Raw text</li>
	 *     <li>XML: An XML DOM node</li>
	 * </ul>
	 *
	 *      function handleFileLoad(event) {
	 *          var item = event.item; // A reference to the item that was passed in to the LoadQueue
	 *          var type = item.type;
	 *
	 *          // Add any images to the page body.
	 *          if (type == createjs.LoadQueue.IMAGE) {
	 *              document.body.appendChild(event.result);
	 *          }
	 *      }
	 *
	 * At any time after the file has been loaded (usually after the queue has completed), any result can be looked up
	 * via its "id" using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}. If no id was provided, then the
	 * "src" or file path can be used instead, including the `path` defined by a manifest, but <strong>not including</strong>
	 * a base path defined on the LoadQueue. It is recommended to always pass an id if you want to look up content.
	 *
	 *      var image = queue.getResult("image");
	 *      document.body.appendChild(image);
	 *
	 * Raw loaded content can be accessed using the <code>rawResult</code> property of the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}
	 * event, or can be looked up using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}, passing `true` as the 2nd
	 * argument. This is only applicable for content that has been parsed for the browser, specifically: JavaScript,
	 * CSS, XML, SVG, and JSON objects, or anything loaded with XHR.
	 *
	 *      var image = queue.getResult("image", true); // load the binary image data loaded with XHR.
	 *
	 * <b>Plugins</b><br />
	 * LoadQueue has a simple plugin architecture to help process and preload content. For example, to preload audio,
	 * make sure to install the <a href="http://soundjs.com">SoundJS</a> Sound class, which will help load HTML audio,
	 * Flash audio, and WebAudio files. This should be installed <strong>before</strong> loading any audio files.
	 *
	 *      queue.installPlugin(createjs.Sound);
	 *
	 * <h4>Known Browser Issues</h4>
	 * <ul>
	 *     <li>Browsers without audio support can not load audio files.</li>
	 *     <li>Safari on Mac OS X can only play HTML audio if QuickTime is installed</li>
	 *     <li>HTML Audio tags will only download until their <code>canPlayThrough</code> event is fired. Browsers other
	 *     than Chrome will continue to download in the background.</li>
	 *     <li>When loading scripts using tags, they are automatically added to the document.</li>
	 *     <li>Scripts loaded via XHR may not be properly inspectable with browser tools.</li>
	 *     <li>IE6 and IE7 (and some other browsers) may not be able to load XML, Text, or JSON, since they require
	 *     XHR to work.</li>
	 *     <li>Content loaded via tags will not show progress, and will continue to download in the background when
	 *     canceled, although no events will be dispatched.</li>
	 * </ul>
	 *
	 * @class LoadQueue
	 * @param {Boolean} [preferXHR=true] Determines whether the preload instance will favor loading with XHR (XML HTTP
	 * Requests), or HTML tags. When this is `false`, the queue will use tag loading when possible, and fall back on XHR
	 * when necessary.
	 * @param {String} [basePath=""] A path that will be prepended on to the source parameter of all items in the queue
	 * before they are loaded.  Sources beginning with a protocol such as `http://` or a relative path such as `../`
	 * will not receive a base path.
	 * @param {String|Boolean} [crossOrigin=""] An optional flag to support images loaded from a CORS-enabled server. To
	 * use it, set this value to `true`, which will default the crossOrigin property on images to "Anonymous". Any
	 * string value will be passed through, but only "" and "Anonymous" are recommended. <strong>Note: The crossOrigin
	 * parameter is deprecated. Use LoadItem.crossOrigin instead</strong>
	 *
	 * @constructor
	 * @extends AbstractLoader
	 */
	function LoadQueue (preferXHR, basePath, crossOrigin) {
		this.AbstractLoader_constructor();

		/**
		 * An array of the plugins registered using {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}}.
		 * @property _plugins
		 * @type {Array}
		 * @private
		 * @since 0.6.1
		 */
		this._plugins = [];

		/**
		 * An object hash of callbacks that are fired for each file type before the file is loaded, giving plugins the
		 * ability to override properties of the load. Please see the {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}}
		 * method for more information.
		 * @property _typeCallbacks
		 * @type {Object}
		 * @private
		 */
		this._typeCallbacks = {};

		/**
		 * An object hash of callbacks that are fired for each file extension before the file is loaded, giving plugins the
		 * ability to override properties of the load. Please see the {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}}
		 * method for more information.
		 * @property _extensionCallbacks
		 * @type {null}
		 * @private
		 */
		this._extensionCallbacks = {};

		/**
		 * The next preload queue to process when this one is complete. If an error is thrown in the current queue, and
		 * {{#crossLink "LoadQueue/stopOnError:property"}}{{/crossLink}} is `true`, the next queue will not be processed.
		 * @property next
		 * @type {LoadQueue}
		 * @default null
		 */
		this.next = null;

		/**
		 * Ensure loaded scripts "complete" in the order they are specified. Loaded scripts are added to the document head
		 * once they are loaded. Scripts loaded via tags will load one-at-a-time when this property is `true`, whereas
		 * scripts loaded using XHR can load in any order, but will "finish" and be added to the document in the order
		 * specified.
		 *
		 * Any items can be set to load in order by setting the {{#crossLink "maintainOrder:property"}}{{/crossLink}}
		 * property on the load item, or by ensuring that only one connection can be open at a time using
		 * {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}. Note that when the `maintainScriptOrder` property
		 * is set to `true`, scripts items are automatically set to `maintainOrder=true`, and changing the
		 * `maintainScriptOrder` to `false` during a load will not change items already in a queue.
		 *
		 * <h4>Example</h4>
		 *
		 *      var queue = new createjs.LoadQueue();
		 *      queue.setMaxConnections(3); // Set a higher number to load multiple items at once
		 *      queue.maintainScriptOrder = true; // Ensure scripts are loaded in order
		 *      queue.loadManifest([
		 *          "script1.js",
		 *          "script2.js",
		 *          "image.png", // Load any time
		 *          {src: "image2.png", maintainOrder: true} // Will wait for script2.js
		 *          "image3.png",
		 *          "script3.js" // Will wait for image2.png before loading (or completing when loading with XHR)
		 *      ]);
		 *
		 * @property maintainScriptOrder
		 * @type {Boolean}
		 * @default true
		 */
		this.maintainScriptOrder = true;

		/**
		 * Determines if the LoadQueue will stop processing the current queue when an error is encountered.
		 * @property stopOnError
		 * @type {Boolean}
		 * @default false
		 */
		this.stopOnError = false;

		/**
		 * The number of maximum open connections that a loadQueue tries to maintain. Please see
		 * {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}} for more information.
		 * @property _maxConnections
		 * @type {Number}
		 * @default 1
		 * @private
		 */
		this._maxConnections = 1;

		/**
		 * An internal list of all the default Loaders that are included with PreloadJS. Before an item is loaded, the
		 * available loader list is iterated, in the order they are included, and as soon as a loader indicates it can
		 * handle the content, it will be selected. The default loader, ({{#crossLink "TextLoader"}}{{/crossLink}} is
		 * last in the list, so it will be used if no other match is found. Typically, loaders will match based on the
		 * {{#crossLink "LoadItem/type"}}{{/crossLink}}, which is automatically determined using the file extension of
		 * the {{#crossLink "LoadItem/src:property"}}{{/crossLink}}.
		 *
		 * Loaders can be removed from PreloadJS by simply not including them.
		 *
		 * Custom loaders installed using {{#crossLink "registerLoader"}}{{/crossLink}} will be prepended to this list
		 * so that they are checked first.
		 * @property _availableLoaders
		 * @type {Array}
		 * @private
		 * @since 0.6.0
		 */
		this._availableLoaders = [
			createjs.ImageLoader,
			createjs.JavaScriptLoader,
			createjs.CSSLoader,
			createjs.JSONLoader,
			createjs.JSONPLoader,
			createjs.SoundLoader,
			createjs.ManifestLoader,
			createjs.SpriteSheetLoader,
			createjs.XMLLoader,
			createjs.SVGLoader,
			createjs.BinaryLoader,
			createjs.VideoLoader,
			createjs.TextLoader,
		];

		/**
		 * The number of built in loaders, so they can't be removed by {{#crossLink "unregisterLoader"}}{{/crossLink}.
				 * @property _defaultLoaderLength
		 * @type {Number}
		 * @private
		 * @since 0.6.0
		 */
		this._defaultLoaderLength = this._availableLoaders.length;

		this.init(preferXHR, basePath, crossOrigin);
	}

	var p = createjs.extend(LoadQueue, createjs.AbstractLoader);
	var s = LoadQueue;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.

	/**
	 * An internal initialization method, which is used for initial set up, but also to reset the LoadQueue.
	 * @method init
	 * @param preferXHR
	 * @param basePath
	 * @param crossOrigin
	 * @private
	 */
	p.init = function (preferXHR, basePath, crossOrigin) {

		// public properties
		/**
		 * @property useXHR
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 * @deprecated Use preferXHR instead.
		 */
		this.useXHR = true;

		/**
		 * Try and use XMLHttpRequest (XHR) when possible. Note that LoadQueue will default to tag loading or XHR
		 * loading depending on the requirements for a media type. For example, HTML audio can not be loaded with XHR,
		 * and plain text can not be loaded with tags, so it will default the the correct type instead of using the
		 * user-defined type.
		 * @type {Boolean}
		 * @default true
		 * @since 0.6.0
		 */
		this.preferXHR = true; //TODO: Get/Set
		this._preferXHR = true;
		this.setPreferXHR(preferXHR);

		// protected properties
		/**
		 * Whether the queue is currently paused or not.
		 * @property _paused
		 * @type {boolean}
		 * @private
		 */
		this._paused = false;

		/**
		 * A path that will be prepended on to the item's {{#crossLink "LoadItem/src:property"}}{{/crossLink}}. The
		 * `_basePath` property will only be used if an item's source is relative, and does not include a protocol such
		 * as `http://`, or a relative path such as `../`.
		 * @property _basePath
		 * @type {String}
		 * @private
		 * @since 0.3.1
		 */
		this._basePath = basePath;

		/**
		 * An optional flag to set on images that are loaded using PreloadJS, which enables CORS support. Images loaded
		 * cross-domain by servers that support CORS require the crossOrigin flag to be loaded and interacted with by
		 * a canvas. When loading locally, or with a server with no CORS support, this flag can cause other security issues,
		 * so it is recommended to only set it if you are sure the server supports it. Currently, supported values are ""
		 * and "Anonymous".
		 * @property _crossOrigin
		 * @type {String}
		 * @default ""
		 * @private
		 * @since 0.4.1
		 */
		this._crossOrigin = crossOrigin;

		/**
		 * Determines if the loadStart event was dispatched already. This event is only fired one time, when the first
		 * file is requested.
		 * @property _loadStartWasDispatched
		 * @type {Boolean}
		 * @default false
		 * @private
		 */
		this._loadStartWasDispatched = false;

		/**
		 * Determines if there is currently a script loading. This helps ensure that only a single script loads at once when
		 * using a script tag to do preloading.
		 * @property _currentlyLoadingScript
		 * @type {Boolean}
		 * @private
		 */
		this._currentlyLoadingScript = null;

		/**
		 * An array containing the currently downloading files.
		 * @property _currentLoads
		 * @type {Array}
		 * @private
		 */
		this._currentLoads = [];

		/**
		 * An array containing the queued items that have not yet started downloading.
		 * @property _loadQueue
		 * @type {Array}
		 * @private
		 */
		this._loadQueue = [];

		/**
		 * An array containing downloads that have not completed, so that the LoadQueue can be properly reset.
		 * @property _loadQueueBackup
		 * @type {Array}
		 * @private
		 */
		this._loadQueueBackup = [];

		/**
		 * An object hash of items that have finished downloading, indexed by the {{#crossLink "LoadItem"}}{{/crossLink}}
		 * id.
		 * @property _loadItemsById
		 * @type {Object}
		 * @private
		 */
		this._loadItemsById = {};

		/**
		 * An object hash of items that have finished downloading, indexed by {{#crossLink "LoadItem"}}{{/crossLink}}
		 * source.
		 * @property _loadItemsBySrc
		 * @type {Object}
		 * @private
		 */
		this._loadItemsBySrc = {};

		/**
		 * An object hash of loaded items, indexed by the ID of the {{#crossLink "LoadItem"}}{{/crossLink}}.
		 * @property _loadedResults
		 * @type {Object}
		 * @private
		 */
		this._loadedResults = {};

		/**
		 * An object hash of un-parsed loaded items, indexed by the ID of the {{#crossLink "LoadItem"}}{{/crossLink}}.
		 * @property _loadedRawResults
		 * @type {Object}
		 * @private
		 */
		this._loadedRawResults = {};

		/**
		 * The number of items that have been requested. This helps manage an overall progress without knowing how large
		 * the files are before they are downloaded. This does not include items inside of loaders such as the
		 * {{#crossLink "ManifestLoader"}}{{/crossLink}}.
		 * @property _numItems
		 * @type {Number}
		 * @default 0
		 * @private
		 */
		this._numItems = 0;

		/**
		 * The number of items that have completed loaded. This helps manage an overall progress without knowing how large
		 * the files are before they are downloaded.
		 * @property _numItemsLoaded
		 * @type {Number}
		 * @default 0
		 * @private
		 */
		this._numItemsLoaded = 0;

		/**
		 * A list of scripts in the order they were requested. This helps ensure that scripts are "completed" in the right
		 * order.
		 * @property _scriptOrder
		 * @type {Array}
		 * @private
		 */
		this._scriptOrder = [];

		/**
		 * A list of scripts that have been loaded. Items are added to this list as <code>null</code> when they are
		 * requested, contain the loaded item if it has completed, but not been dispatched to the user, and <code>true</true>
		 * once they are complete and have been dispatched.
		 * @property _loadedScripts
		 * @type {Array}
		 * @private
		 */
		this._loadedScripts = [];

		/**
		 * The last progress amount. This is used to suppress duplicate progress events.
		 * @property _lastProgress
		 * @type {Number}
		 * @private
		 * @since 0.6.0
		 */
		this._lastProgress = NaN;

	};

// static properties
	/**
	 * The time in milliseconds to assume a load has failed. An {{#crossLink "AbstractLoader/error:event"}}{{/crossLink}}
	 * event is dispatched if the timeout is reached before any data is received.
	 * @property loadTimeout
	 * @type {Number}
	 * @default 8000
	 * @static
	 * @since 0.4.1
	 * @deprecated In favour of {{#crossLink "LoadItem/LOAD_TIMEOUT_DEFAULT:property}}{{/crossLink}} property.
	 */
	s.loadTimeout = 8000;

	/**
	 * The time in milliseconds to assume a load has failed.
	 * @property LOAD_TIMEOUT
	 * @type {Number}
	 * @default 0
	 * @deprecated in favor of the {{#crossLink "LoadQueue/loadTimeout:property"}}{{/crossLink}} property.
	 */
	s.LOAD_TIMEOUT = 0;

// Preload Types
	/**
	 * @property BINARY
	 * @type {String}
	 * @default binary
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/BINARY:property"}}{{/crossLink}} instead.
	 */
	s.BINARY = createjs.AbstractLoader.BINARY;

	/**
	 * @property CSS
	 * @type {String}
	 * @default css
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/CSS:property"}}{{/crossLink}} instead.
	 */
	s.CSS = createjs.AbstractLoader.CSS;

	/**
	 * @property IMAGE
	 * @type {String}
	 * @default image
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/CSS:property"}}{{/crossLink}} instead.
	 */
	s.IMAGE = createjs.AbstractLoader.IMAGE;

	/**
	 * @property JAVASCRIPT
	 * @type {String}
	 * @default javascript
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}} instead.
	 */
	s.JAVASCRIPT = createjs.AbstractLoader.JAVASCRIPT;

	/**
	 * @property JSON
	 * @type {String}
	 * @default json
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JSON:property"}}{{/crossLink}} instead.
	 */
	s.JSON = createjs.AbstractLoader.JSON;

	/**
	 * @property JSONP
	 * @type {String}
	 * @default jsonp
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JSONP:property"}}{{/crossLink}} instead.
	 */
	s.JSONP = createjs.AbstractLoader.JSONP;

	/**
	 * @property MANIFEST
	 * @type {String}
	 * @default manifest
	 * @static
	 * @since 0.4.1
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}} instead.
	 */
	s.MANIFEST = createjs.AbstractLoader.MANIFEST;

	/**
	 * @property SOUND
	 * @type {String}
	 * @default sound
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}} instead.
	 */
	s.SOUND = createjs.AbstractLoader.SOUND;

	/**
	 * @property VIDEO
	 * @type {String}
	 * @default video
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}} instead.
	 */
	s.VIDEO = createjs.AbstractLoader.VIDEO;

	/**
	 * @property SVG
	 * @type {String}
	 * @default svg
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/SVG:property"}}{{/crossLink}} instead.
	 */
	s.SVG = createjs.AbstractLoader.SVG;

	/**
	 * @property TEXT
	 * @type {String}
	 * @default text
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/TEXT:property"}}{{/crossLink}} instead.
	 */
	s.TEXT = createjs.AbstractLoader.TEXT;

	/**
	 * @property XML
	 * @type {String}
	 * @default xml
	 * @static
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/XML:property"}}{{/crossLink}} instead.
	 */
	s.XML = createjs.AbstractLoader.XML;

	/**
	 * @property POST
	 * @type {string}
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/POST:property"}}{{/crossLink}} instead.
	 */
	s.POST = createjs.AbstractLoader.POST;

	/**
	 * @property GET
	 * @type {string}
	 * @deprecated Use the AbstractLoader {{#crossLink "AbstractLoader/GET:property"}}{{/crossLink}} instead.
	 */
	s.GET = createjs.AbstractLoader.GET;

// events
	/**
	 * This event is fired when an individual file has loaded, and been processed.
	 * @event fileload
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a `src` property.
	 * @param {Object} result The HTML tag or parsed result of the loaded item.
	 * @param {Object} rawResult The unprocessed result, usually the raw text or binary data before it is converted
	 * to a usable object.
	 * @since 0.3.0
	 */

	/**
	 * This {{#crossLink "ProgressEvent"}}{{/crossLink}} that is fired when an an individual file's progress changes.
	 * @event fileprogress
	 * @since 0.3.0
	 */

	/**
	 * This event is fired when an individual file starts to load.
	 * @event filestart
	 * @param {Object} The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Object} item The file item which was specified in the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}} call. If only a string path or tag was specified, the
	 * object will contain that value as a property.
	 */

// public methods
	/**
	 * Register a custom loaders class. New loaders are given precedence over loaders added earlier and default loaders.
	 * It is recommended that loaders extend {{#crossLink "AbstractLoader"}}{{/crossLink}}. Loaders can only be added
	 * once, and will be prepended to the list of available loaders.
	 * @method registerLoader
	 * @param {Function|AbstractLoader} loader The AbstractLoader class to add.
	 * @since 0.6.0
	 */
	p.registerLoader = function (loader) {
		if (!loader || !loader.canLoadItem) {
			throw new Error("loader is of an incorrect type.");
		} else if (this._availableLoaders.indexOf(loader) != -1) {
			throw new Error("loader already exists."); //LM: Maybe just silently fail here
		}

		this._availableLoaders.unshift(loader);
	};

	/**
	 * Remove a custom loader added usig {{#crossLink "registerLoader"}}{{/crossLink}}. Only custom loaders can be
	 * unregistered, the default loaders will always be available.
	 * @method unregisterLoader
	 * @param {Function|AbstractLoader} loader The AbstractLoader class to remove
	 */
	p.unregisterLoader = function (loader) {
		var idx = this._availableLoaders.indexOf(loader);
		if (idx != -1 && idx < this._defaultLoaderLength - 1) {
			this._availableLoaders.splice(idx, 1);
		}
	};

	/**
	 * @method setUseXHR
	 * @param {Boolean} value The new useXHR value to set.
	 * @return {Boolean} The new useXHR value. If XHR is not supported by the browser, this will return false, even if
	 * the provided value argument was true.
	 * @since 0.3.0
	 * @deprecated use the {{#crossLink "preferXHR:property"}}{{/crossLink}} property, or the {{#crossLink "setUseXHR"}}{{/crossLink}}
	 * method instead.
	 */
	p.setUseXHR = function (value) {
		return this.setPreferXHR(value);
	};

	/**
	 * Change the {{#crossLink "preferXHR:property"}}{{/crossLink}} value. Note that if this is set to `true`, it may
	 * fail, or be ignored depending on the browser's capabilities and the load type.
	 * @method setPreferXHR
	 * @param {Boolean} value
	 * @returns {Boolean} The value of {{#crossLink "preferXHR"}}{{/crossLink}} that was successfully set.
	 * @since 0.6.0
	 */
	p.setPreferXHR = function (value) {
		// Determine if we can use XHR. XHR defaults to TRUE, but the browser may not support it.
		//TODO: Should we be checking for the other XHR types? Might have to do a try/catch on the different types similar to createXHR.
		this.preferXHR = (value != false && window.XMLHttpRequest != null);
		return this.preferXHR;
	};

	/**
	 * Stops all queued and loading items, and clears the queue. This also removes all internal references to loaded
	 * content, and allows the queue to be used again.
	 * @method removeAll
	 * @since 0.3.0
	 */
	p.removeAll = function () {
		this.remove();
	};

	/**
	 * Stops an item from being loaded, and removes it from the queue. If nothing is passed, all items are removed.
	 * This also removes internal references to loaded item(s).
	 *
	 * <h4>Example</h4>
	 *
	 *      queue.loadManifest([
	 *          {src:"test.png", id:"png"},
	 *          {src:"test.jpg", id:"jpg"},
	 *          {src:"test.mp3", id:"mp3"}
	 *      ]);
	 *      queue.remove("png"); // Single item by ID
	 *      queue.remove("png", "test.jpg"); // Items as arguments. Mixed id and src.
	 *      queue.remove(["test.png", "jpg"]); // Items in an Array. Mixed id and src.
	 *
	 * @method remove
	 * @param {String | Array} idsOrUrls* The id or ids to remove from this queue. You can pass an item, an array of
	 * items, or multiple items as arguments.
	 * @since 0.3.0
	 */
	p.remove = function (idsOrUrls) {
		var args = null;

		if (idsOrUrls && !(idsOrUrls instanceof Array)) {
			args = [idsOrUrls];
		} else if (idsOrUrls) {
			args = idsOrUrls;
		} else if (arguments.length > 0) {
			return;
		}

		var itemsWereRemoved = false;

		// Destroy everything
		if (!args) {
			this.close();
			for (var n in this._loadItemsById) {
				this._disposeItem(this._loadItemsById[n]);
			}
			this.init(this.preferXHR, this._basePath);

			// Remove specific items
		} else {
			while (args.length) {
				var item = args.pop();
				var r = this.getResult(item);

				//Remove from the main load Queue
				for (i = this._loadQueue.length - 1; i >= 0; i--) {
					loadItem = this._loadQueue[i].getItem();
					if (loadItem.id == item || loadItem.src == item) {
						this._loadQueue.splice(i, 1)[0].cancel();
						break;
					}
				}

				//Remove from the backup queue
				for (i = this._loadQueueBackup.length - 1; i >= 0; i--) {
					loadItem = this._loadQueueBackup[i].getItem();
					if (loadItem.id == item || loadItem.src == item) {
						this._loadQueueBackup.splice(i, 1)[0].cancel();
						break;
					}
				}

				if (r) {
					this._disposeItem(this.getItem(item));
				} else {
					for (var i = this._currentLoads.length - 1; i >= 0; i--) {
						var loadItem = this._currentLoads[i].getItem();
						if (loadItem.id == item || loadItem.src == item) {
							this._currentLoads.splice(i, 1)[0].cancel();
							itemsWereRemoved = true;
							break;
						}
					}
				}
			}

			// If this was called during a load, try to load the next item.
			if (itemsWereRemoved) {
				this._loadNext();
			}
		}
	};

	/**
	 * Stops all open loads, destroys any loaded items, and resets the queue, so all items can
	 * be reloaded again by calling {{#crossLink "AbstractLoader/load"}}{{/crossLink}}. Items are not removed from the
	 * queue. To remove items use the {{#crossLink "LoadQueue/remove"}}{{/crossLink}} or
	 * {{#crossLink "LoadQueue/removeAll"}}{{/crossLink}} method.
	 * @method reset
	 * @since 0.3.0
	 */
	p.reset = function () {
		this.close();
		for (var n in this._loadItemsById) {
			this._disposeItem(this._loadItemsById[n]);
		}

		//Reset the queue to its start state
		var a = [];
		for (var i = 0, l = this._loadQueueBackup.length; i < l; i++) {
			a.push(this._loadQueueBackup[i].getItem());
		}

		this.loadManifest(a, false);
	};

	/**
	 * Register a plugin. Plugins can map to load types (sound, image, etc), or specific extensions (png, mp3, etc).
	 * Currently, only one plugin can exist per type/extension.
	 *
	 * When a plugin is installed, a <code>getPreloadHandlers()</code> method will be called on it. For more information
	 * on this method, check out the {{#crossLink "SamplePlugin/getPreloadHandlers"}}{{/crossLink}} method in the
	 * {{#crossLink "SamplePlugin"}}{{/crossLink}} class.
	 *
	 * Before a file is loaded, a matching plugin has an opportunity to modify the load. If a `callback` is returned
	 * from the {{#crossLink "SamplePlugin/getPreloadHandlers"}}{{/crossLink}} method, it will be invoked first, and its
	 * result may cancel or modify the item. The callback method can also return a `completeHandler` to be fired when
	 * the file is loaded, or a `tag` object, which will manage the actual download. For more information on these
	 * methods, check out the {{#crossLink "SamplePlugin/preloadHandler"}}{{/crossLink}} and {{#crossLink "SamplePlugin/fileLoadHandler"}}{{/crossLink}}
	 * methods on the {{#crossLink "SamplePlugin"}}{{/crossLink}}.
	 *
	 * @method installPlugin
	 * @param {Function} plugin The plugin class to install.
	 */
	p.installPlugin = function (plugin) {
		if (plugin == null) {
			return;
		}

		if (plugin.getPreloadHandlers != null) {
			this._plugins.push(plugin);
			var map = plugin.getPreloadHandlers();
			map.scope = plugin;

			if (map.types != null) {
				for (var i = 0, l = map.types.length; i < l; i++) {
					this._typeCallbacks[map.types[i]] = map;
				}
			}

			if (map.extensions != null) {
				for (i = 0, l = map.extensions.length; i < l; i++) {
					this._extensionCallbacks[map.extensions[i]] = map;
				}
			}
		}
	};

	/**
	 * Set the maximum number of concurrent connections. Note that browsers and servers may have a built-in maximum
	 * number of open connections, so any additional connections may remain in a pending state until the browser
	 * opens the connection. When loading scripts using tags, and when {{#crossLink "LoadQueue/maintainScriptOrder:property"}}{{/crossLink}}
	 * is `true`, only one script is loaded at a time due to browser limitations.
	 *
	 * <h4>Example</h4>
	 *
	 *      var queue = new createjs.LoadQueue();
	 *      queue.setMaxConnections(10); // Allow 10 concurrent loads
	 *
	 * @method setMaxConnections
	 * @param {Number} value The number of concurrent loads to allow. By default, only a single connection per LoadQueue
	 * is open at any time.
	 */
	p.setMaxConnections = function (value) {
		this._maxConnections = value;
		if (!this._paused && this._loadQueue.length > 0) {
			this._loadNext();
		}
	};

	/**
	 * Load a single file. To add multiple files at once, use the {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}
	 * method.
	 *
	 * Files are always appended to the current queue, so this method can be used multiple times to add files.
	 * To clear the queue first, use the {{#crossLink "AbstractLoader/close"}}{{/crossLink}} method.
	 * @method loadFile
	 * @param {LoadItem|Object|String} file The file object or path to load. A file can be either
	 * <ul>
	 *     <li>A {{#crossLink "LoadItem"}}{{/crossLink}} instance</li>
	 *     <li>An object containing properties defined by {{#crossLink "LoadItem"}}{{/crossLink}}</li>
	 *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink "LoadItem"}}{{/crossLink}}
	 *     in the background.</li>
	 * </ul>
	 * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default
	 * value is true. If the queue is paused using {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}}, and the value is
	 * `true`, the queue will resume automatically.
	 * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the
	 * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}},
	 * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>
	 * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue
	 * constructor, or a `path` property in a manifest definition.
	 */
	p.loadFile = function (file, loadNow, basePath) {
		if (file == null) {
			var event = new createjs.ErrorEvent("PRELOAD_NO_FILE");
			this._sendError(event);
			return;
		}
		this._addItem(file, null, basePath);

		if (loadNow !== false) {
			this.setPaused(false);
		} else {
			this.setPaused(true);
		}
	};

	/**
	 * Load an array of files. To load a single file, use the {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} method.
	 * The files in the manifest are requested in the same order, but may complete in a different order if the max
	 * connections are set above 1 using {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}}. Scripts will load
	 * in the right order as long as {{#crossLink "LoadQueue/maintainScriptOrder"}}{{/crossLink}} is true (which is
	 * default).
	 *
	 * Files are always appended to the current queue, so this method can be used multiple times to add files.
	 * To clear the queue first, use the {{#crossLink "AbstractLoader/close"}}{{/crossLink}} method.
	 * @method loadManifest
	 * @param {Array|String|Object} manifest An list of files to load. The loadManifest call supports four types of
	 * manifests:
	 * <ol>
	 *     <li>A string path, which points to a manifest file, which is a JSON file that contains a "manifest" property,
	 *     which defines the list of files to load, and can optionally contain a "path" property, which will be
	 *     prepended to each file in the list.</li>
	 *     <li>An object which defines a "src", which is a JSON or JSONP file. A "callback" can be defined for JSONP
	 *     file. The JSON/JSONP file should contain a "manifest" property, which defines the list of files to load,
	 *     and can optionally contain a "path" property, which will be prepended to each file in the list.</li>
	 *     <li>An object which contains a "manifest" property, which defines the list of files to load, and can
	 *     optionally contain a "path" property, which will be prepended to each file in the list.</li>
	 *     <li>An Array of files to load.</li>
	 * </ol>
	 *
	 * Each "file" in a manifest can be either:
	 * <ul>
	 *     <li>A {{#crossLink "LoadItem"}}{{/crossLink}} instance</li>
	 *     <li>An object containing properties defined by {{#crossLink "LoadItem"}}{{/crossLink}}</li>
	 *     <li>OR A string path to a resource. Note that this kind of load item will be converted to a {{#crossLink "LoadItem"}}{{/crossLink}}
	 *     in the background.</li>
	 * </ul>
	 *
	 * @param {Boolean} [loadNow=true] Kick off an immediate load (true) or wait for a load call (false). The default
	 * value is true. If the queue is paused using {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}} and this value is
	 * `true`, the queue will resume automatically.
	 * @param {String} [basePath] A base path that will be prepended to each file. The basePath argument overrides the
	 * path specified in the constructor. Note that if you load a manifest using a file of type {{#crossLink "LoadQueue/MANIFEST:property"}}{{/crossLink}},
	 * its files will <strong>NOT</strong> use the basePath parameter. <strong>The basePath parameter is deprecated.</strong>
	 * This parameter will be removed in a future version. Please either use the `basePath` parameter in the LoadQueue
	 * constructor, or a `path` property in a manifest definition.
	 */
	p.loadManifest = function (manifest, loadNow, basePath) {
		var fileList = null;
		var path = null;

		// Array-based list of items
		if (manifest instanceof Array) {
			if (manifest.length == 0) {
				var event = new createjs.ErrorEvent("PRELOAD_MANIFEST_EMPTY");
				this._sendError(event);
				return;
			}
			fileList = manifest;

			// String-based. Only file manifests can be specified this way. Any other types will cause an error when loaded.
		} else if (typeof(manifest) === "string") {
			fileList = [
				{
					src: manifest,
					type: s.MANIFEST
				}
			];

		} else if (typeof(manifest) == "object") {

			// An object that defines a manifest path
			if (manifest.src !== undefined) {
				if (manifest.type == null) {
					manifest.type = s.MANIFEST;
				} else if (manifest.type != s.MANIFEST) {
					var event = new createjs.ErrorEvent("PRELOAD_MANIFEST_TYPE");
					this._sendError(event);
				}
				fileList = [manifest];

				// An object that defines a manifest
			} else if (manifest.manifest !== undefined) {
				fileList = manifest.manifest;
				path = manifest.path;
			}

			// Unsupported. This will throw an error.
		} else {
			var event = new createjs.ErrorEvent("PRELOAD_MANIFEST_NULL");
			this._sendError(event);
			return;
		}

		for (var i = 0, l = fileList.length; i < l; i++) {
			this._addItem(fileList[i], path, basePath);
		}

		if (loadNow !== false) {
			this.setPaused(false);
		} else {
			this.setPaused(true);
		}

	};

	/**
	 * Start a LoadQueue that was created, but not automatically started.
	 * @method load
	 */
	p.load = function () {
		this.setPaused(false);
	};

	/**
	 * Look up a {{#crossLink "LoadItem"}}{{/crossLink}} using either the "id" or "src" that was specified when loading it. Note that if no "id" was
	 * supplied with the load item, the ID will be the "src", including a `path` property defined by a manifest. The
	 * `basePath` will not be part of the ID.
	 * @method getItem
	 * @param {String} value The <code>id</code> or <code>src</code> of the load item.
	 * @return {Object} The load item that was initially requested using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}. This object is also returned via the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}}
	 * event as the `item` parameter.
	 */
	p.getItem = function (value) {
		return this._loadItemsById[value] || this._loadItemsBySrc[value];
	};

	/**
	 * Look up a loaded result using either the "id" or "src" that was specified when loading it. Note that if no "id"
	 * was supplied with the load item, the ID will be the "src", including a `path` property defined by a manifest. The
	 * `basePath` will not be part of the ID.
	 * @method getResult
	 * @param {String} value The <code>id</code> or <code>src</code> of the load item.
	 * @param {Boolean} [rawResult=false] Return a raw result instead of a formatted result. This applies to content
	 * loaded via XHR such as scripts, XML, CSS, and Images. If there is no raw result, the formatted result will be
	 * returned instead.
	 * @return {Object} A result object containing the content that was loaded, such as:
	 * <ul>
	 *      <li>An image tag (&lt;image /&gt;) for images</li>
	 *      <li>A script tag for JavaScript (&lt;script /&gt;). Note that scripts are automatically added to the HTML
	 *      DOM.</li>
	 *      <li>A style tag for CSS (&lt;style /&gt; or &lt;link &gt;)</li>
	 *      <li>Raw text for TEXT</li>
	 *      <li>A formatted JavaScript object defined by JSON</li>
	 *      <li>An XML document</li>
	 *      <li>A binary arraybuffer loaded by XHR</li>
	 *      <li>An audio tag (&lt;audio &gt;) for HTML audio. Note that it is recommended to use SoundJS APIs to play
	 *      loaded audio. Specifically, audio loaded by Flash and WebAudio will return a loader object using this method
	 *      which can not be used to play audio back.</li>
	 * </ul>
	 * This object is also returned via the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event as the 'item`
	 * parameter. Note that if a raw result is requested, but not found, the result will be returned instead.
	 */
	p.getResult = function (value, rawResult) {
		var item = this._loadItemsById[value] || this._loadItemsBySrc[value];
		if (item == null) {
			return null;
		}
		var id = item.id;
		if (rawResult && this._loadedRawResults[id]) {
			return this._loadedRawResults[id];
		}
		return this._loadedResults[id];
	};

	/**
	 * Generate an list of items loaded by this queue.
	 * @method getItems
	 * @param {Boolean} loaded Determines if only items that have been loaded should be returned. If false, in-progress
	 * and failed load items will also be included.
	 * @returns {Array} A list of objects that have been loaded. Each item includes the {{#crossLink "LoadItem"}}{{/crossLink}},
	 * result, and rawResult.
	 * @since 0.6.0
	 */
	p.getItems = function (loaded) {
		var arr = [];
		for (var n in this._loadItemsById) {
			var item = this._loadItemsById[n];
			var result = this.getResult(n);
			if (loaded === true && result == null) {
				continue;
			}
			arr.push({
				item: item,
				result: result,
				rawResult: this.getResult(n, true)
			});
		}
		return arr;
	};

	/**
	 * Pause or resume the current load. Active loads will not be cancelled, but the next items in the queue will not
	 * be processed when active loads complete. LoadQueues are not paused by default.
	 *
	 * Note that if new items are added to the queue using {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} or
	 * {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}, a paused queue will be resumed, unless the `loadNow`
	 * argument is `false`.
	 * @method setPaused
	 * @param {Boolean} value Whether the queue should be paused or not.
	 */
	p.setPaused = function (value) {
		this._paused = value;
		if (!this._paused) {
			this._loadNext();
		}
	};

	/**
	 * Close the active queue. Closing a queue completely empties the queue, and prevents any remaining items from
	 * starting to download. Note that currently any active loads will remain open, and events may be processed.
	 *
	 * To stop and restart a queue, use the {{#crossLink "LoadQueue/setPaused"}}{{/crossLink}} method instead.
	 * @method close
	 */
	p.close = function () {
		while (this._currentLoads.length) {
			this._currentLoads.pop().cancel();
		}
		this._scriptOrder.length = 0;
		this._loadedScripts.length = 0;
		this.loadStartWasDispatched = false;
		this._itemCount = 0;
		this._lastProgress = NaN;
	};

// protected methods
	/**
	 * Add an item to the queue. Items are formatted into a usable object containing all the properties necessary to
	 * load the content. The load queue is populated with the loader instance that handles preloading, and not the load
	 * item that was passed in by the user. To look up the load item by id or src, use the {{#crossLink "LoadQueue.getItem"}}{{/crossLink}}
	 * method.
	 * @method _addItem
	 * @param {String|Object} value The item to add to the queue.
	 * @param {String} [path] An optional path prepended to the `src`. The path will only be prepended if the src is
	 * relative, and does not start with a protocol such as `http://`, or a path like `../`. If the LoadQueue was
	 * provided a {{#crossLink "_basePath"}}{{/crossLink}}, then it will optionally be prepended after.
	 * @param {String} [basePath] <strong>Deprecated</strong>An optional basePath passed into a {{#crossLink "LoadQueue/loadManifest"}}{{/crossLink}}
	 * or {{#crossLink "LoadQueue/loadFile"}}{{/crossLink}} call. This parameter will be removed in a future tagged
	 * version.
	 * @private
	 */
	p._addItem = function (value, path, basePath) {
		var item = this._createLoadItem(value, path, basePath); // basePath and manifest path are added to the src.
		if (item == null) {
			return;
		} // Sometimes plugins or types should be skipped.
		var loader = this._createLoader(item);
		if (loader != null) {
			if ("plugins" in loader) {
				loader.plugins = this._plugins;
			}
			item._loader = loader;
			this._loadQueue.push(loader);
			this._loadQueueBackup.push(loader);

			this._numItems++;
			this._updateProgress();

			// Only worry about script order when using XHR to load scripts. Tags are only loading one at a time.
			if ((this.maintainScriptOrder
					&& item.type == createjs.LoadQueue.JAVASCRIPT
						//&& loader instanceof createjs.XHRLoader //NOTE: Have to track all JS files this way
					)
					|| item.maintainOrder === true) {
				this._scriptOrder.push(item);
				this._loadedScripts.push(null);
			}
		}
	};

	/**
	 * Create a refined {{#crossLink "LoadItem"}}{{/crossLink}}, which contains all the required properties. The type of
	 * item is determined by browser support, requirements based on the file type, and developer settings. For example,
	 * XHR is only used for file types that support it in new browsers.
	 *
	 * Before the item is returned, any plugins registered to handle the type or extension will be fired, which may
	 * alter the load item.
	 * @method _createLoadItem
	 * @param {String | Object | HTMLAudioElement | HTMLImageElement} value The item that needs to be preloaded.
	 * @param {String} [path] A path to prepend to the item's source. Sources beginning with http:// or similar will
	 * not receive a path. Since PreloadJS 0.4.1, the src will be modified to include the `path` and {{#crossLink "LoadQueue/_basePath:property"}}{{/crossLink}}
	 * when it is added.
	 * @param {String} [basePath] <strong>Deprectated</strong> A base path to prepend to the items source in addition to
	 * the path argument.
	 * @return {Object} The loader instance that will be used.
	 * @private
	 */
	p._createLoadItem = function (value, path, basePath) {
		var item = createjs.LoadItem.create(value);
		if (item == null) {
			return null;
		}

		var bp = ""; // Store the generated basePath
		var useBasePath = basePath || this._basePath;

		if (item.src instanceof Object) {
			if (!item.type) {
				return null;
			} // the the src is an object, type is required to pass off to plugin
			if (path) {
				bp = path;
				var pathMatch = createjs.RequestUtils.parseURI(path);
				// Also append basePath
				if (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {
					bp = useBasePath + bp;
				}
			} else if (useBasePath != null) {
				bp = useBasePath;
			}
		} else {
			// Determine Extension, etc.
			var match = createjs.RequestUtils.parseURI(item.src);
			if (match.extension) {
				item.ext = match.extension;
			}
			if (item.type == null) {
				item.type = createjs.RequestUtils.getTypeByExtension(item.ext);
			}

			// Inject path & basePath
			var autoId = item.src;
			if (!match.absolute && !match.relative) {
				if (path) {
					bp = path;
					var pathMatch = createjs.RequestUtils.parseURI(path);
					autoId = path + autoId;
					// Also append basePath
					if (useBasePath != null && !pathMatch.absolute && !pathMatch.relative) {
						bp = useBasePath + bp;
					}
				} else if (useBasePath != null) {
					bp = useBasePath;
				}
			}
			item.src = bp + item.src;
		}
		item.path = bp;

		// If there's no id, set one now.
		if (item.id === undefined || item.id === null || item.id === "") {
			item.id = autoId;
		}

		// Give plugins a chance to modify the loadItem:
		var customHandler = this._typeCallbacks[item.type] || this._extensionCallbacks[item.ext];
		if (customHandler) {
			// Plugins are now passed both the full source, as well as a combined path+basePath (appropriately)
			var result = customHandler.callback.call(customHandler.scope, item, this);

			// The plugin will handle the load, or has canceled it. Ignore it.
			if (result === false) {
				return null;

				// Load as normal:
			} else if (result === true) {
				// Do Nothing

				// Result is a loader class:
			} else if (result != null) {
				item._loader = result;
			}

			// Update the extension in case the type changed:
			match = createjs.RequestUtils.parseURI(item.src);
			if (match.extension != null) {
				item.ext = match.extension;
			}
		}

		// Store the item for lookup. This also helps clean-up later.
		this._loadItemsById[item.id] = item;
		this._loadItemsBySrc[item.src] = item;

		if (item.crossOrigin == null) {
			item.crossOrigin = this._crossOrigin;
		}

		return item;
	};

	/**
	 * Create a loader for a load item.
	 * @method _createLoader
	 * @param {Object} item A formatted load item that can be used to generate a loader.
	 * @return {AbstractLoader} A loader that can be used to load content.
	 * @private
	 */
	p._createLoader = function (item) {
		if (item._loader != null) { // A plugin already specified a loader
			return item._loader;
		}

		// Initially, try and use the provided/supported XHR mode:
		var preferXHR = this.preferXHR;

		for (var i = 0; i < this._availableLoaders.length; i++) {
			var loader = this._availableLoaders[i];
			if (loader && loader.canLoadItem(item)) {
				return new loader(item, preferXHR);
			}
		}

		// TODO: Log error (requires createjs.log)
		return null;
	};

	/**
	 * Load the next item in the queue. If the queue is empty (all items have been loaded), then the complete event
	 * is processed. The queue will "fill up" any empty slots, up to the max connection specified using
	 * {{#crossLink "LoadQueue.setMaxConnections"}}{{/crossLink}} method. The only exception is scripts that are loaded
	 * using tags, which have to be loaded one at a time to maintain load order.
	 * @method _loadNext
	 * @private
	 */
	p._loadNext = function () {
		if (this._paused) {
			return;
		}

		// Only dispatch loadstart event when the first file is loaded.
		if (!this._loadStartWasDispatched) {
			this._sendLoadStart();
			this._loadStartWasDispatched = true;
		}

		// The queue has completed.
		if (this._numItems == this._numItemsLoaded) {
			this.loaded = true;
			this._sendComplete();

			// Load the next queue, if it has been defined.
			if (this.next && this.next.load) {
				this.next.load();
			}
		} else {
			this.loaded = false;
		}

		// Must iterate forwards to load in the right order.
		for (var i = 0; i < this._loadQueue.length; i++) {
			if (this._currentLoads.length >= this._maxConnections) {
				break;
			}
			var loader = this._loadQueue[i];

			// Determine if we should be only loading one tag-script at a time:
			// Note: maintainOrder items don't do anything here because we can hold onto their loaded value
			if (!this._canStartLoad(loader)) {
				continue;
			}
			this._loadQueue.splice(i, 1);
			i--;
			this._loadItem(loader);
		}
	};

	/**
	 * Begin loading an item. Event listeners are not added to the loaders until the load starts.
	 * @method _loadItem
	 * @param {AbstractLoader} loader The loader instance to start. Currently, this will be an XHRLoader or TagLoader.
	 * @private
	 */
	p._loadItem = function (loader) {
		loader.on("fileload", this._handleFileLoad, this);
		loader.on("progress", this._handleProgress, this);
		loader.on("complete", this._handleFileComplete, this);
		loader.on("error", this._handleError, this);
		loader.on("fileerror", this._handleFileError, this);
		this._currentLoads.push(loader);
		this._sendFileStart(loader.getItem());
		loader.load();
	};

	/**
	 * The callback that is fired when a loader loads a file. This enables loaders like {{#crossLink "ManifestLoader"}}{{/crossLink}}
	 * to maintain internal queues, but for this queue to dispatch the {{#crossLink "fileload:event"}}{{/crossLink}}
	 * events.
	 * @param {Event} event The {{#crossLink "AbstractLoader/fileload:event"}}{{/crossLink}} event from the loader.
	 * @private
	 * @since 0.6.0
	 */
	p._handleFileLoad = function (event) {
		event.target = null;
		this.dispatchEvent(event);
	};

	/**
	 * The callback that is fired when a loader encounters an error from an internal file load operation. This enables
	 * loaders like M
	 * @param event
	 * @private
	 */
	p._handleFileError = function (event) {
		var newEvent = new createjs.ErrorEvent("FILE_LOAD_ERROR", null, event.item);
		this._sendError(newEvent);
	};

	/**
	 * The callback that is fired when a loader encounters an error. The queue will continue loading unless {{#crossLink "LoadQueue/stopOnError:property"}}{{/crossLink}}
	 * is set to `true`.
	 * @method _handleError
	 * @param {ErrorEvent} event The error event, containing relevant error information.
	 * @private
	 */
	p._handleError = function (event) {
		var loader = event.target;
		this._numItemsLoaded++;

		this._finishOrderedItem(loader, true);
		this._updateProgress();

		var newEvent = new createjs.ErrorEvent("FILE_LOAD_ERROR", null, loader.getItem());
		// TODO: Propagate actual error message.

		this._sendError(newEvent);

		if (!this.stopOnError) {
			this._removeLoadItem(loader);
			this._cleanLoadItem(loader);
			this._loadNext();
		} else {
			this.setPaused(true);
		}
	};

	/**
	 * An item has finished loading. We can assume that it is totally loaded, has been parsed for immediate use, and
	 * is available as the "result" property on the load item. The raw text result for a parsed item (such as JSON, XML,
	 * CSS, JavaScript, etc) is available as the "rawResult" property, and can also be looked up using {{#crossLink "LoadQueue/getResult"}}{{/crossLink}}.
	 * @method _handleFileComplete
	 * @param {Event} event The event object from the loader.
	 * @private
	 */
	p._handleFileComplete = function (event) {
		var loader = event.target;
		var item = loader.getItem();

		var result = loader.getResult();
		this._loadedResults[item.id] = result;
		var rawResult = loader.getResult(true);
		if (rawResult != null && rawResult !== result) {
			this._loadedRawResults[item.id] = rawResult;
		}

		this._saveLoadedItems(loader);

		// Remove the load item
		this._removeLoadItem(loader);

		if (!this._finishOrderedItem(loader)) {
			// The item was NOT managed, so process it now
			this._processFinishedLoad(item, loader);
		}

		// Clean up the load item
		this._cleanLoadItem(loader);
	};

	/**
	 * Some loaders might load additional content, other than the item they were passed (such as {{#crossLink "ManifestLoader"}}{{/crossLink}}).
	 * Any items exposed by the loader using {{#crossLink "AbstractLoader/getLoadItems"}}{{/crossLink}} are added to the
	 * LoadQueue's look-ups, including {{#crossLink "getItem"}}{{/crossLink}} and {{#crossLink "getResult"}}{{/crossLink}}
	 * methods.
	 * @method _saveLoadedItems
	 * @param {AbstractLoader} loader
	 * @protected
	 * @since 0.6.0
	 */
	p._saveLoadedItems = function (loader) {
		// TODO: Not sure how to handle this. Would be nice to expose the items.
		// Loaders may load sub-items. This adds them to this queue
		var list = loader.getLoadedItems();
		if (list === null) {
			return;
		}

		for (var i = 0; i < list.length; i++) {
			var item = list[i].item;

			// Store item lookups
			this._loadItemsBySrc[item.src] = item;
			this._loadItemsById[item.id] = item;

			// Store loaded content
			this._loadedResults[item.id] = list[i].result;
			this._loadedRawResults[item.id] = list[i].rawResult;
		}
	};

	/**
	 * Flag an item as finished. If the item's order is being managed, then ensure that it is allowed to finish, and if
	 * so, trigger prior items to trigger as well.
	 * @method _finishOrderedItem
	 * @param {AbstractLoader} loader
	 * @param {Boolean} loadFailed
	 * @return {Boolean} If the item's order is being managed. This allows the caller to take an alternate
	 * behaviour if it is.
	 * @private
	 */
	p._finishOrderedItem = function (loader, loadFailed) {
		var item = loader.getItem();

		if ((this.maintainScriptOrder && item.type == createjs.LoadQueue.JAVASCRIPT)
				|| item.maintainOrder) {

			//TODO: Evaluate removal of the _currentlyLoadingScript
			if (loader instanceof createjs.JavaScriptLoader) {
				this._currentlyLoadingScript = false;
			}

			var index = createjs.indexOf(this._scriptOrder, item);
			if (index == -1) {
				return false;
			} // This loader no longer exists
			this._loadedScripts[index] = (loadFailed === true) ? true : item;

			this._checkScriptLoadOrder();
			return true;
		}

		return false;
	};

	/**
	 * Ensure the scripts load and dispatch in the correct order. When using XHR, scripts are stored in an array in the
	 * order they were added, but with a "null" value. When they are completed, the value is set to the load item,
	 * and then when they are processed and dispatched, the value is set to `true`. This method simply
	 * iterates the array, and ensures that any loaded items that are not preceded by a `null` value are
	 * dispatched.
	 * @method _checkScriptLoadOrder
	 * @private
	 */
	p._checkScriptLoadOrder = function () {
		var l = this._loadedScripts.length;

		for (var i = 0; i < l; i++) {
			var item = this._loadedScripts[i];
			if (item === null) {
				break;
			} // This is still loading. Do not process further.
			if (item === true) {
				continue;
			} // This has completed, and been processed. Move on.

			var loadItem = this._loadedResults[item.id];
			if (item.type == createjs.LoadQueue.JAVASCRIPT) {
				// Append script tags to the head automatically.
				createjs.DomUtils.appendToHead(loadItem);
			}

			var loader = item._loader;
			this._processFinishedLoad(item, loader);
			this._loadedScripts[i] = true;
		}
	};

	/**
	 * A file has completed loading, and the LoadQueue can move on. This triggers the complete event, and kick-starts
	 * the next item.
	 * @method _processFinishedLoad
	 * @param {LoadItem|Object} item
	 * @param {AbstractLoader} loader
	 * @protected
	 */
	p._processFinishedLoad = function (item, loader) {
		this._numItemsLoaded++;

		// Since LoadQueue needs maintain order, we can't append scripts in the loader.
		// So we do it here instead. Or in _checkScriptLoadOrder();
		if (!this.maintainScriptOrder && item.type == createjs.LoadQueue.JAVASCRIPT) {
			createjs.DomUtils.appendToHead(item.result);
		}

		this._updateProgress();
		this._sendFileComplete(item, loader);
		this._loadNext();
	};

	/**
	 * Ensure items with `maintainOrder=true` that are before the specified item have loaded. This only applies to
	 * JavaScript items that are being loaded with a TagLoader, since they have to be loaded and completed <strong>before</strong>
	 * the script can even be started, since it exist in the DOM while loading.
	 * @method _canStartLoad
	 * @param {AbstractLoader} loader The loader for the item
	 * @return {Boolean} Whether the item can start a load or not.
	 * @private
	 */
	p._canStartLoad = function (loader) {
		if (!this.maintainScriptOrder || loader.preferXHR) {
			return true;
		}
		var item = loader.getItem();
		if (item.type != createjs.LoadQueue.JAVASCRIPT) {
			return true;
		}
		if (this._currentlyLoadingScript) {
			return false;
		}

		var index = this._scriptOrder.indexOf(item);
		var i = 0;
		while (i < index) {
			var checkItem = this._loadedScripts[i];
			if (checkItem == null) {
				return false;
			}
			i++;
		}
		this._currentlyLoadingScript = true;
		return true;
	};

	/**
	 * A load item is completed or was canceled, and needs to be removed from the LoadQueue.
	 * @method _removeLoadItem
	 * @param {AbstractLoader} loader A loader instance to remove.
	 * @private
	 */
	p._removeLoadItem = function (loader) {
		var l = this._currentLoads.length;
		for (var i = 0; i < l; i++) {
			if (this._currentLoads[i] == loader) {
				this._currentLoads.splice(i, 1);
				break;
			}
		}
	};

	/**
	 * Remove unneeded references from a loader.
	 *
	 * @param loader
	 * @private
	 */
	p._cleanLoadItem = function(loader) {
		var item = loader.getItem();
		if (item) {
			delete item._loader;
		}
	}

	/**
	 * An item has dispatched progress. Propagate that progress, and update the LoadQueue's overall progress.
	 * @method _handleProgress
	 * @param {ProgressEvent} event The progress event from the item.
	 * @private
	 */
	p._handleProgress = function (event) {
		var loader = event.target;
		this._sendFileProgress(loader.getItem(), loader.progress);
		this._updateProgress();
	};

	/**
	 * Overall progress has changed, so determine the new progress amount and dispatch it. This changes any time an
	 * item dispatches progress or completes. Note that since we don't always know the actual filesize of items before
	 * they are loaded. In this case, we define a "slot" for each item (1 item in 10 would get 10%), and then append
	 * loaded progress on top of the already-loaded items.
	 *
	 * For example, if 5/10 items have loaded, and item 6 is 20% loaded, the total progress would be:
	 * <ul>
	 *      <li>5/10 of the items in the queue (50%)</li>
	 *      <li>plus 20% of item 6's slot (2%)</li>
	 *      <li>equals 52%</li>
	 * </ul>
	 * @method _updateProgress
	 * @private
	 */
	p._updateProgress = function () {
		var loaded = this._numItemsLoaded / this._numItems; // Fully Loaded Progress
		var remaining = this._numItems - this._numItemsLoaded;
		if (remaining > 0) {
			var chunk = 0;
			for (var i = 0, l = this._currentLoads.length; i < l; i++) {
				chunk += this._currentLoads[i].progress;
			}
			loaded += (chunk / remaining) * (remaining / this._numItems);
		}

		if (this._lastProgress != loaded) {
			this._sendProgress(loaded);
			this._lastProgress = loaded;
		}
	};

	/**
	 * Clean out item results, to free them from memory. Mainly, the loaded item and results are cleared from internal
	 * hashes.
	 * @method _disposeItem
	 * @param {LoadItem|Object} item The item that was passed in for preloading.
	 * @private
	 */
	p._disposeItem = function (item) {
		delete this._loadedResults[item.id];
		delete this._loadedRawResults[item.id];
		delete this._loadItemsById[item.id];
		delete this._loadItemsBySrc[item.src];
	};

	/**
	 * Dispatch a "fileprogress" {{#crossLink "Event"}}{{/crossLink}}. Please see the LoadQueue {{#crossLink "LoadQueue/fileprogress:event"}}{{/crossLink}}
	 * event for details on the event payload.
	 * @method _sendFileProgress
	 * @param {LoadItem|Object} item The item that is being loaded.
	 * @param {Number} progress The amount the item has been loaded (between 0 and 1).
	 * @protected
	 */
	p._sendFileProgress = function (item, progress) {
		if (this._isCanceled() || this._paused) {
			return;
		}
		if (!this.hasEventListener("fileprogress")) {
			return;
		}

		//LM: Rework ProgressEvent to support this?
		var event = new createjs.Event("fileprogress");
		event.progress = progress;
		event.loaded = progress;
		event.total = 1;
		event.item = item;

		this.dispatchEvent(event);
	};

	/**
	 * Dispatch a fileload {{#crossLink "Event"}}{{/crossLink}}. Please see the {{#crossLink "LoadQueue/fileload:event"}}{{/crossLink}} event for
	 * details on the event payload.
	 * @method _sendFileComplete
	 * @param {LoadItemObject} item The item that is being loaded.
	 * @param {AbstractLoader} loader
	 * @protected
	 */
	p._sendFileComplete = function (item, loader) {
		if (this._isCanceled() || this._paused) {
			return;
		}

		var event = new createjs.Event("fileload");
		event.loader = loader;
		event.item = item;
		event.result = this._loadedResults[item.id];
		event.rawResult = this._loadedRawResults[item.id];

		// This calls a handler specified on the actual load item. Currently, the SoundJS plugin uses this.
		if (item.completeHandler) {
			item.completeHandler(event);
		}

		this.hasEventListener("fileload") && this.dispatchEvent(event);
	};

	/**
	 * Dispatch a filestart {{#crossLink "Event"}}{{/crossLink}} immediately before a file starts to load. Please see
	 * the {{#crossLink "LoadQueue/filestart:event"}}{{/crossLink}} event for details on the event payload.
	 * @method _sendFileStart
	 * @param {LoadItem|Object} item The item that is being loaded.
	 * @protected
	 */
	p._sendFileStart = function (item) {
		var event = new createjs.Event("filestart");
		event.item = item;
		this.hasEventListener("filestart") && this.dispatchEvent(event);
	};

	p.toString = function () {
		return "[PreloadJS LoadQueue]";
	};

	createjs.LoadQueue = createjs.promote(LoadQueue, "AbstractLoader");
}());

//##############################################################################
// TextLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for Text files.
	 * @class TextLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function TextLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.TEXT);
	};

	var p = createjs.extend(TextLoader, createjs.AbstractLoader);
	var s = TextLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader loads items that are of type {{#crossLink "AbstractLoader/TEXT:property"}}{{/crossLink}},
	 * but is also the default loader if a file type can not be determined.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.TEXT;
	};

	createjs.TextLoader = createjs.promote(TextLoader, "AbstractLoader");

}());

//##############################################################################
// BinaryLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for binary files. This is useful for loading web audio, or content that requires an ArrayBuffer.
	 * @class BinaryLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function BinaryLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.BINARY);
		this.on("initialize", this._updateXHR, this);
	};

	var p = createjs.extend(BinaryLoader, createjs.AbstractLoader);
	var s = BinaryLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/BINARY:property"}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.BINARY;
	};

	// private methods
	/**
	 * Before the item loads, set the response type to "arraybuffer"
	 * @property _updateXHR
	 * @param {Event} event
	 * @private
	 */
	p._updateXHR = function (event) {
		event.loader.setResponseType("arraybuffer");
	};

	createjs.BinaryLoader = createjs.promote(BinaryLoader, "AbstractLoader");

}());

//##############################################################################
// CSSLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for CSS files.
	 * @class CSSLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractLoader
	 * @constructor
	 */
	function CSSLoader(loadItem, preferXHR) {
		this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.CSS);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = "href";

		if (preferXHR) {
			this._tag = document.createElement("style");
		} else {
			this._tag = document.createElement("link");
		}

		this._tag.rel = "stylesheet";
		this._tag.type = "text/css";
	};

	var p = createjs.extend(CSSLoader, createjs.AbstractLoader);
	var s = CSSLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/CSS:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.CSS;
	};

	// protected methods
	/**
	 * The result formatter for CSS files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLLinkElement|HTMLStyleElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		if (this._preferXHR) {
			var tag = loader.getTag();

			if (tag.styleSheet) { // IE
				tag.styleSheet.cssText = loader.getResult(true);
			} else {
				var textNode = document.createTextNode(loader.getResult(true));
				tag.appendChild(textNode);
			}
		} else {
			tag = this._tag;
		}

		createjs.DomUtils.appendToHead(tag);

		return tag;
	};

	createjs.CSSLoader = createjs.promote(CSSLoader, "AbstractLoader");

}());

//##############################################################################
// ImageLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for image files.
	 * @class ImageLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractLoader
	 * @constructor
	 */
	function ImageLoader (loadItem, preferXHR) {
		this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.IMAGE);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = "src";

		// Check if the preload item is already a tag.
		if (createjs.RequestUtils.isImageTag(loadItem)) {
			this._tag = loadItem;
		} else if (createjs.RequestUtils.isImageTag(loadItem.src)) {
			this._tag = loadItem.src;
		} else if (createjs.RequestUtils.isImageTag(loadItem.tag)) {
			this._tag = loadItem.tag;
		}

		if (this._tag != null) {
			this._preferXHR = false;
		} else {
			this._tag = document.createElement("img");
		}

		this.on("initialize", this._updateXHR, this);
	};

	var p = createjs.extend(ImageLoader, createjs.AbstractLoader);
	var s = ImageLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/IMAGE:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.IMAGE;
	};

	// public methods
	p.load = function () {
		if (this._tag.src != "" && this._tag.complete) {
			this._sendComplete();
			return;
		}

		var crossOrigin = this._item.crossOrigin;
		if (crossOrigin == true) { crossOrigin = "Anonymous"; }
		if (crossOrigin != null && !createjs.RequestUtils.isLocal(this._item.src)) {
			this._tag.crossOrigin = crossOrigin;
		}

		this.AbstractLoader_load();
	};

	// protected methods
	/**
	 * Before the item loads, set its mimeType and responseType.
	 * @property _updateXHR
	 * @param {Event} event
	 * @private
	 */
	p._updateXHR = function (event) {
		event.loader.mimeType = 'text/plain; charset=x-user-defined-binary';

		// Only exists for XHR
		if (event.loader.setResponseType) {
			event.loader.setResponseType("blob");
		}
	};

	/**
	 * The result formatter for Image files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLImageElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		var _this = this;
		return function (done) {
			var tag = _this._tag;
			var URL = window.URL || window.webkitURL;

			if (!_this._preferXHR) {
				//document.body.removeChild(tag);
			} else if (URL) {
				var objURL = URL.createObjectURL(loader.getResult(true));
				tag.src = objURL;
				tag.onload = function () {
					URL.revokeObjectURL(_this.src);
				}
			} else {
				tag.src = loader.getItem().src;
			}

			if (tag.complete) {
				done(tag);
			} else {
				tag.onload = function () {
					done(this);
				}
			}
		};
	};

	createjs.ImageLoader = createjs.promote(ImageLoader, "AbstractLoader");

}());

//##############################################################################
// JavaScriptLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for JavaScript files.
	 * @class JavaScriptLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractLoader
	 * @constructor
	 */
	function JavaScriptLoader(loadItem, preferXHR) {
		this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.JAVASCRIPT);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = "src";
		this.setTag(document.createElement("script"));
	};

	var p = createjs.extend(JavaScriptLoader, createjs.AbstractLoader);
	var s = JavaScriptLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/JAVASCRIPT:property"}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.JAVASCRIPT;
	};

	// protected methods
	/**
	 * The result formatter for JavaScript files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLLinkElement|HTMLStyleElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		var tag = loader.getTag();
		if (this._preferXHR) {
			tag.text = loader.getResult(true);
		}
		return tag;
	};

	createjs.JavaScriptLoader = createjs.promote(JavaScriptLoader, "AbstractLoader");

}());

//##############################################################################
// JSONLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for JSON files. To load JSON cross-domain, use JSONP and the {{#crossLink "JSONPLoader"}}{{/crossLink}}
	 * instead. To load JSON-formatted manifests, use {{#crossLink "ManifestLoader"}}{{/crossLink}}, and to
	 * load EaselJS SpriteSheets, use {{#crossLink "SpriteSheetLoader"}}{{/crossLink}}.
	 * @class JSONLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function JSONLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.JSON);

		// public properties
		this.resultFormatter = this._formatResult;
	};

	var p = createjs.extend(JSONLoader, createjs.AbstractLoader);
	var s = JSONLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/JSON:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.JSON && !item._loadAsJSONP;
	};

	// protected methods
	/**
	 * The result formatter for JSON files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {HTMLLinkElement|HTMLStyleElement}
	 * @private
	 */
	p._formatResult = function (loader) {
		var json = null;
		try {
			json = createjs.DataUtils.parseJSON(loader.getResult(true));
		} catch (e) {
			var event = new createjs.ErrorEvent("JSON_FORMAT", null, e);
			this._sendError(event);
			return e;
		}

		return json;
	};

	createjs.JSONLoader = createjs.promote(JSONLoader, "AbstractLoader");

}());

//##############################################################################
// JSONPLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for JSONP files, which are JSON-formatted text files, wrapped in a callback. To load regular JSON
	 * without a callback use the {{#crossLink "JSONLoader"}}{{/crossLink}} instead. To load JSON-formatted manifests,
	 * use {{#crossLink "ManifestLoader"}}{{/crossLink}}, and to load EaselJS SpriteSheets, use
	 * {{#crossLink "SpriteSheetLoader"}}{{/crossLink}}.
	 *
	 * Note that JSONP files loaded concurrently require a <em>unique</em> callback. To ensure JSONP files are loaded
	 * in order, either use the {{#crossLink "LoadQueue/setMaxConnections"}}{{/crossLink}} method (set to 1),
	 * or set {{#crossLink "LoadItem/maintainOrder:property"}}{{/crossLink}} on items with the same callback.
	 * @class JSONPLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function JSONPLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, false, createjs.AbstractLoader.JSONP);
		this.setTag(document.createElement("script"));
		this.getTag().type = "text/javascript";
	};

	var p = createjs.extend(JSONPLoader, createjs.AbstractLoader);
	var s = JSONPLoader;


	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/JSONP:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.JSONP || item._loadAsJSONP;
	};

	// public methods
	p.cancel = function () {
		this.AbstractLoader_cancel();
		this._dispose();
	};

	/**
	 * Loads the JSONp file.  Because of the unique loading needs of jsonP
	 * we don't use the AbstractLoader.load() method.
	 *
	 * @method load
	 *
	 */
	p.load = function () {
		if (this._item.callback == null) {
			throw new Error('callback is required for loading JSONP requests.');
		}

		// TODO: Look into creating our own iFrame to handle the load
		// In the first attempt, FF did not get the result
		//   result instanceof Object did not work either
		//   so we would need to clone the result.
		if (window[this._item.callback] != null) {
			throw new Error(
				"JSONP callback '" +
				this._item.callback +
				"' already exists on window. You need to specify a different callback or re-name the current one.");
		}

		window[this._item.callback] = createjs.proxy(this._handleLoad, this);
		window.document.body.appendChild(this._tag);

		this._loadTimeout = setTimeout(createjs.proxy(this._handleTimeout, this), this._item.loadTimeout);

		// Load the tag
		this._tag.src = this._item.src;
	};

	// private methods
	/**
	 * Handle the JSONP callback, which is a public method defined on `window`.
	 * @method _handleLoad
	 * @param {Object} data The formatted JSON data.
	 * @private
	 */
	p._handleLoad = function (data) {
		this._result = this._rawResult = data;
		this._sendComplete();

		this._dispose();
	};

	/**
	 * The tag request has not loaded within the time specfied in loadTimeout.
	 * @method _handleError
	 * @param {Object} event The XHR error event.
	 * @private
	 */
	p._handleTimeout = function () {
		this._dispose();
		this.dispatchEvent(new createjs.ErrorEvent("timeout"));
	};

	/**
	 * Clean up the JSONP load. This clears out the callback and script tag that this loader creates.
	 * @method _dispose
	 * @private
	 */
	p._dispose = function () {
		window.document.body.removeChild(this._tag);
		delete window[this._item.callback];

		clearTimeout(this._loadTimeout);
	};

	createjs.JSONPLoader = createjs.promote(JSONPLoader, "AbstractLoader");

}());

//##############################################################################
// ManifestLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for JSON manifests. Items inside the manifest are loaded before the loader completes. To load manifests
	 * using JSONP, specify a {{#crossLink "LoadItem/callback:property"}}{{/crossLink}} as part of the
	 * {{#crossLink "LoadItem"}}{{/crossLink}}.
	 *
	 * The list of files in the manifest must be defined on the top-level JSON object in a `manifest` property. This
	 * example shows a sample manifest definition, as well as how to to include a sub-manifest.
	 *
	 * 		{
	 * 			"path": "assets/",
	 *	 	    "manifest": [
	 *				"image.png",
	 *				{"src": "image2.png", "id":"image2"},
	 *				{"src": "sub-manifest.json", "type":"manifest", "callback":"jsonCallback"}
	 *	 	    ]
	 *	 	}
	 *
	 * When a ManifestLoader has completed loading, the parent loader (usually a {{#crossLink "LoadQueue"}}{{/crossLink}},
	 * but could also be another ManifestLoader) will inherit all the loaded items, so you can access them directly.
	 *
	 * Note that the {{#crossLink "JSONLoader"}}{{/crossLink}} and {{#crossLink "JSONPLoader"}}{{/crossLink}} are
	 * higher priority loaders, so manifests <strong>must</strong> set the {{#crossLink "LoadItem"}}{{/crossLink}}
	 * {{#crossLink "LoadItem/type:property"}}{{/crossLink}} property to {{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}}.
	 * @class ManifestLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function ManifestLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, null, createjs.AbstractLoader.MANIFEST);

	// Public Properties
		/**
		 * An array of the plugins registered using {{#crossLink "LoadQueue/installPlugin"}}{{/crossLink}},
		 * used to pass plugins to new LoadQueues that may be created.
		 * @property _plugins
		 * @type {Array}
		 * @private
		 * @since 0.6.1
		 */
		this.plugins = null;


	// Protected Properties
		/**
		 * An internal {{#crossLink "LoadQueue"}}{{/crossLink}} that loads the contents of the manifest.
		 * @property _manifestQueue
		 * @type {LoadQueue}
		 * @private
		 */
		this._manifestQueue = null;
	};

	var p = createjs.extend(ManifestLoader, createjs.AbstractLoader);
	var s = ManifestLoader;

	// static properties
	/**
	 * The amount of progress that the manifest itself takes up.
	 * @property MANIFEST_PROGRESS
	 * @type {number}
	 * @default 0.25 (25%)
	 * @private
	 * @static
	 */
	s.MANIFEST_PROGRESS = 0.25;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/MANIFEST:property"}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.MANIFEST;
	};

	// public methods
	p.load = function () {
		this.AbstractLoader_load();
	};

	// protected methods
	p._createRequest = function() {
		var callback = this._item.callback;
		if (callback != null) {
			this._request = new createjs.JSONPLoader(this._item);
		} else {
			this._request = new createjs.JSONLoader(this._item);
		}
	};

	p.handleEvent = function (event) {
		switch (event.type) {
			case "complete":
				this._rawResult = event.target.getResult(true);
				this._result = event.target.getResult();
				this._sendProgress(s.MANIFEST_PROGRESS);
				this._loadManifest(this._result);
				return;
			case "progress":
				event.loaded *= s.MANIFEST_PROGRESS;
				this.progress = event.loaded / event.total;
				if (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }
				this._sendProgress(event);
				return;
		}
		this.AbstractLoader_handleEvent(event);
	};

	p.destroy = function() {
		this.AbstractLoader_destroy();
		this._manifestQueue.close();
	};

	/**
	 * Create and load the manifest items once the actual manifest has been loaded.
	 * @method _loadManifest
	 * @param {Object} json
	 * @private
	 */
	p._loadManifest = function (json) {
		if (json && json.manifest) {
			var queue = this._manifestQueue = new createjs.LoadQueue();
			queue.on("fileload", this._handleManifestFileLoad, this);
			queue.on("progress", this._handleManifestProgress, this);
			queue.on("complete", this._handleManifestComplete, this, true);
			queue.on("error", this._handleManifestError, this, true);
			for(var i = 0, l = this.plugins.length; i < l; i++) {	// conserve order of plugins
				queue.installPlugin(this.plugins[i]);
			}
			queue.loadManifest(json);
		} else {
			this._sendComplete();
		}
	};

	/**
	 * An item from the {{#crossLink "_manifestQueue:property"}}{{/crossLink}} has completed.
	 * @method _handleManifestFileLoad
	 * @param {Event} event
	 * @private
	 */
	p._handleManifestFileLoad = function (event) {
		event.target = null;
		this.dispatchEvent(event);
	};

	/**
	 * The manifest has completed loading. This triggers the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}}
	 * {{#crossLink "Event"}}{{/crossLink}} from the ManifestLoader.
	 * @method _handleManifestComplete
	 * @param {Event} event
	 * @private
	 */
	p._handleManifestComplete = function (event) {
		this._loadedItems = this._manifestQueue.getItems(true);
		this._sendComplete();
	};

	/**
	 * The manifest has reported progress.
	 * @method _handleManifestProgress
	 * @param {ProgressEvent} event
	 * @private
	 */
	p._handleManifestProgress = function (event) {
		this.progress = event.progress * (1 - s.MANIFEST_PROGRESS) + s.MANIFEST_PROGRESS;
		this._sendProgress(this.progress);
	};

	/**
	 * The manifest has reported an error with one of the files.
	 * @method _handleManifestError
	 * @param {ErrorEvent} event
	 * @private
	 */
	p._handleManifestError = function (event) {
		var newEvent = new createjs.Event("fileerror");
		newEvent.item = event.data;
		this.dispatchEvent(newEvent);
	};

	createjs.ManifestLoader = createjs.promote(ManifestLoader, "AbstractLoader");

}());

//##############################################################################
// SoundLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for HTML audio files. PreloadJS can not load WebAudio files, as a WebAudio context is required, which
	 * should be created by either a library playing the sound (such as <a href="http://soundjs.com">SoundJS</a>, or an
	 * external framework that handles audio playback. To load content that can be played by WebAudio, use the
	 * {{#crossLink "BinaryLoader"}}{{/crossLink}}, and handle the audio context decoding manually.
	 * @class SoundLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractMediaLoader
	 * @constructor
	 */
	function SoundLoader(loadItem, preferXHR) {
		this.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SOUND);

		// protected properties
		if (createjs.RequestUtils.isAudioTag(loadItem)) {
			this._tag = loadItem;
		} else if (createjs.RequestUtils.isAudioTag(loadItem.src)) {
			this._tag = loadItem;
		} else if (createjs.RequestUtils.isAudioTag(loadItem.tag)) {
			this._tag = createjs.RequestUtils.isAudioTag(loadItem) ? loadItem : loadItem.src;
		}

		if (this._tag != null) {
			this._preferXHR = false;
		}
	};

	var p = createjs.extend(SoundLoader, createjs.AbstractMediaLoader);
	var s = SoundLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/SOUND:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.SOUND;
	};

	// protected methods
	p._createTag = function (src) {
		var tag = document.createElement("audio");
		tag.autoplay = false;
		tag.preload = "none";

		//LM: Firefox fails when this the preload="none" for other tags, but it needs to be "none" to ensure PreloadJS works.
		tag.src = src;
		return tag;
	};

	createjs.SoundLoader = createjs.promote(SoundLoader, "AbstractMediaLoader");

}());

//##############################################################################
// VideoLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for video files.
	 * @class VideoLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractMediaLoader
	 * @constructor
	 */
	function VideoLoader(loadItem, preferXHR) {
		this.AbstractMediaLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.VIDEO);

		if (createjs.RequestUtils.isVideoTag(loadItem) || createjs.RequestUtils.isVideoTag(loadItem.src)) {
			this.setTag(createjs.RequestUtils.isVideoTag(loadItem)?loadItem:loadItem.src);

			// We can't use XHR for a tag that's passed in.
			this._preferXHR = false;
		} else {
			this.setTag(this._createTag());
		}
	};

	var p = createjs.extend(VideoLoader, createjs.AbstractMediaLoader);
	var s = VideoLoader;

	/**
	 * Create a new video tag
	 *
	 * @returns {HTMLElement}
	 * @private
	 */
	p._createTag = function () {
		return document.createElement("video");
	};

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/VIDEO:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.VIDEO;
	};

	createjs.VideoLoader = createjs.promote(VideoLoader, "AbstractMediaLoader");

}());

//##############################################################################
// SpriteSheetLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for EaselJS SpriteSheets. Images inside the spritesheet definition are loaded before the loader
	 * completes. To load SpriteSheets using JSONP, specify a {{#crossLink "LoadItem/callback:property"}}{{/crossLink}}
	 * as part of the {{#crossLink "LoadItem"}}{{/crossLink}}. Note that the {{#crossLink "JSONLoader"}}{{/crossLink}}
	 * and {{#crossLink "JSONPLoader"}}{{/crossLink}} are higher priority loaders, so SpriteSheets <strong>must</strong>
	 * set the {{#crossLink "LoadItem"}}{{/crossLink}} {{#crossLink "LoadItem/type:property"}}{{/crossLink}} property
	 * to {{#crossLink "AbstractLoader/SPRITESHEET:property"}}{{/crossLink}}.
	 * @class SpriteSheetLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function SpriteSheetLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, null, createjs.AbstractLoader.SPRITESHEET);

		// protected properties
		/**
		 * An internal queue which loads the SpriteSheet's images.
		 * @method _manifestQueue
		 * @type {LoadQueue}
		 * @private
		 */
		this._manifestQueue = null;
	}

	var p = createjs.extend(SpriteSheetLoader, createjs.AbstractLoader);
	var s = SpriteSheetLoader;

	// static properties
	/**
	 * The amount of progress that the manifest itself takes up.
	 * @property SPRITESHEET_PROGRESS
	 * @type {number}
	 * @default 0.25 (25%)
	 * @private
	 * @static
	 */
	s.SPRITESHEET_PROGRESS = 0.25;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/SPRITESHEET:property"}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.SPRITESHEET;
	};

	// public methods
	p.destroy = function() {
		this.AbstractLoader_destroy;
		this._manifestQueue.close();
	};

	// protected methods
	p._createRequest = function() {
		var callback = this._item.callback;
		if (callback != null && callback instanceof Function) {
			this._request = new createjs.JSONPLoader(this._item);
		} else {
			this._request = new createjs.JSONLoader(this._item);
		}
	};

	p.handleEvent = function (event) {
		switch (event.type) {
			case "complete":
				this._rawResult = event.target.getResult(true);
				this._result = event.target.getResult();
				this._sendProgress(s.SPRITESHEET_PROGRESS);
				this._loadManifest(this._result);
				return;
			case "progress":
				event.loaded *= s.SPRITESHEET_PROGRESS;
				this.progress = event.loaded / event.total;
				if (isNaN(this.progress) || this.progress == Infinity) { this.progress = 0; }
				this._sendProgress(event);
				return;
		}
		this.AbstractLoader_handleEvent(event);
	};

	/**
	 * Create and load the images once the SpriteSheet JSON has been loaded.
	 * @method _loadManifest
	 * @param {Object} json
	 * @private
	 */
	p._loadManifest = function (json) {
		if (json && json.images) {
			var queue = this._manifestQueue = new createjs.LoadQueue();
			queue.on("complete", this._handleManifestComplete, this, true);
			queue.on("fileload", this._handleManifestFileLoad, this);
			queue.on("progress", this._handleManifestProgress, this);
			queue.on("error", this._handleManifestError, this, true);
			queue.loadManifest(json.images);
		}
	};

	/**
	 * An item from the {{#crossLink "_manifestQueue:property"}}{{/crossLink}} has completed.
	 * @method _handleManifestFileLoad
	 * @param {Event} event
	 * @private
	 */
	p._handleManifestFileLoad = function (event) {
		var image = event.result;
		if (image != null) {
			var images = this.getResult().images;
			var pos = images.indexOf(event.item.src);
			images[pos] = image;
		}
	};

	/**
	 * The images have completed loading. This triggers the {{#crossLink "AbstractLoader/complete:event"}}{{/crossLink}}
	 * {{#crossLink "Event"}}{{/crossLink}} from the SpriteSheetLoader.
	 * @method _handleManifestComplete
	 * @param {Event} event
	 * @private
	 */
	p._handleManifestComplete = function (event) {
		this._result = new createjs.SpriteSheet(this._result);
		this._loadedItems = this._manifestQueue.getItems(true);
		this._sendComplete();
	};

	/**
	 * The images {{#crossLink "LoadQueue"}}{{/crossLink}} has reported progress.
	 * @method _handleManifestProgress
	 * @param {ProgressEvent} event
	 * @private
	 */
	p._handleManifestProgress = function (event) {
		this.progress = event.progress * (1 - s.SPRITESHEET_PROGRESS) + s.SPRITESHEET_PROGRESS;
		this._sendProgress(this.progress);
	};

	/**
	 * An image has reported an error.
	 * @method _handleManifestError
	 * @param {ErrorEvent} event
	 * @private
	 */
	p._handleManifestError = function (event) {
		var newEvent = new createjs.Event("fileerror");
		newEvent.item = event.data;
		this.dispatchEvent(newEvent);
	};

	createjs.SpriteSheetLoader = createjs.promote(SpriteSheetLoader, "AbstractLoader");

}());

//##############################################################################
// SVGLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for SVG files.
	 * @class SVGLoader
	 * @param {LoadItem|Object} loadItem
	 * @param {Boolean} preferXHR
	 * @extends AbstractLoader
	 * @constructor
	 */
	function SVGLoader(loadItem, preferXHR) {
		this.AbstractLoader_constructor(loadItem, preferXHR, createjs.AbstractLoader.SVG);

		// public properties
		this.resultFormatter = this._formatResult;

		// protected properties
		this._tagSrcAttribute = "data";

		if (preferXHR) {
			this.setTag(document.createElement("svg"));
		} else {
			this.setTag(document.createElement("object"));
			this.getTag().type = "image/svg+xml";
		}
	};

	var p = createjs.extend(SVGLoader, createjs.AbstractLoader);
	var s = SVGLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/SVG:property"}}{{/crossLink}}
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.SVG;
	};

	// protected methods
	/**
	 * The result formatter for SVG files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {Object}
	 * @private
	 */
	p._formatResult = function (loader) {
		// mime should be image/svg+xml, but Opera requires text/xml
		var xml = createjs.DataUtils.parseXML(loader.getResult(true), "text/xml");
		var tag = loader.getTag();

		if (!this._preferXHR && document.body.contains(tag)) {
			document.body.removeChild(tag);
		}

		if (xml.documentElement != null) {
			tag.appendChild(xml.documentElement);
			tag.style.visibility = "visible";
			return tag;
		} else { // For browsers that don't support SVG, just give them the XML. (IE 9-8)
			return xml;
		}
	};

	createjs.SVGLoader = createjs.promote(SVGLoader, "AbstractLoader");

}());

//##############################################################################
// XMLLoader.js
//##############################################################################

this.createjs = this.createjs || {};

(function () {
	"use strict";

	// constructor
	/**
	 * A loader for CSS files.
	 * @class XMLLoader
	 * @param {LoadItem|Object} loadItem
	 * @extends AbstractLoader
	 * @constructor
	 */
	function XMLLoader(loadItem) {
		this.AbstractLoader_constructor(loadItem, true, createjs.AbstractLoader.XML);

		// public properties
		this.resultFormatter = this._formatResult;
	};

	var p = createjs.extend(XMLLoader, createjs.AbstractLoader);
	var s = XMLLoader;

	// static methods
	/**
	 * Determines if the loader can load a specific item. This loader can only load items that are of type
	 * {{#crossLink "AbstractLoader/XML:property"}}{{/crossLink}}.
	 * @method canLoadItem
	 * @param {LoadItem|Object} item The LoadItem that a LoadQueue is trying to load.
	 * @returns {Boolean} Whether the loader can load the item.
	 * @static
	 */
	s.canLoadItem = function (item) {
		return item.type == createjs.AbstractLoader.XML;
	};

	// protected methods
	/**
	 * The result formatter for XML files.
	 * @method _formatResult
	 * @param {AbstractLoader} loader
	 * @returns {XMLDocument}
	 * @private
	 */
	p._formatResult = function (loader) {
		return createjs.DataUtils.parseXML(loader.getResult(true), "text/xml");
	};

	createjs.XMLLoader = createjs.promote(XMLLoader, "AbstractLoader");

}());
/*!
* TweenJS
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2010 gskinner.com, inc.
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the "Software"), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/


//##############################################################################
// extend.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Sets up the prototype chain and constructor property for a new class.
 *
 * This should be called right after creating the class constructor.
 *
 * 	function MySubClass() {}
 * 	createjs.extend(MySubClass, MySuperClass);
 * 	ClassB.prototype.doSomething = function() { }
 *
 * 	var foo = new MySubClass();
 * 	console.log(foo instanceof MySuperClass); // true
 * 	console.log(foo.prototype.constructor === MySubClass); // true
 *
 * @method extend
 * @param {Function} subclass The subclass.
 * @param {Function} superclass The superclass to extend.
 * @return {Function} Returns the subclass's new prototype.
 */
createjs.extend = function(subclass, superclass) {
	"use strict";

	function o() { this.constructor = subclass; }
	o.prototype = superclass.prototype;
	return (subclass.prototype = new o());
};

//##############################################################################
// promote.js
//##############################################################################

this.createjs = this.createjs||{};

/**
 * @class Utility Methods
 */

/**
 * Promotes any methods on the super class that were overridden, by creating an alias in the format `prefix_methodName`.
 * It is recommended to use the super class's name as the prefix.
 * An alias to the super class's constructor is always added in the format `prefix_constructor`.
 * This allows the subclass to call super class methods without using `function.call`, providing better performance.
 *
 * For example, if `MySubClass` extends `MySuperClass`, and both define a `draw` method, then calling `promote(MySubClass, "MySuperClass")`
 * would add a `MySuperClass_constructor` method to MySubClass and promote the `draw` method on `MySuperClass` to the
 * prototype of `MySubClass` as `MySuperClass_draw`.
 *
 * This should be called after the class's prototype is fully defined.
 *
 * 	function ClassA(name) {
 * 		this.name = name;
 * 	}
 * 	ClassA.prototype.greet = function() {
 * 		return "Hello "+this.name;
 * 	}
 *
 * 	function ClassB(name, punctuation) {
 * 		this.ClassA_constructor(name);
 * 		this.punctuation = punctuation;
 * 	}
 * 	createjs.extend(ClassB, ClassA);
 * 	ClassB.prototype.greet = function() {
 * 		return this.ClassA_greet()+this.punctuation;
 * 	}
 * 	createjs.promote(ClassB, "ClassA");
 *
 * 	var foo = new ClassB("World", "!?!");
 * 	console.log(foo.greet()); // Hello World!?!
 *
 * @method promote
 * @param {Function} subclass The class to promote super class methods on.
 * @param {String} prefix The prefix to add to the promoted method names. Usually the name of the superclass.
 * @return {Function} Returns the subclass.
 */
createjs.promote = function(subclass, prefix) {
	"use strict";

	var subP = subclass.prototype, supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;
	if (supP) {
		subP[(prefix+="_") + "constructor"] = supP.constructor; // constructor is not always innumerable
		for (var n in supP) {
			if (subP.hasOwnProperty(n) && (typeof supP[n] == "function")) { subP[prefix + n] = supP[n]; }
		}
	}
	return subclass;
};

//##############################################################################
// Event.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

// constructor:
	/**
	 * Contains properties and methods shared by all events for use with
	 * {{#crossLink "EventDispatcher"}}{{/crossLink}}.
	 * 
	 * Note that Event objects are often reused, so you should never
	 * rely on an event object's state outside of the call stack it was received in.
	 * @class Event
	 * @param {String} type The event type.
	 * @param {Boolean} bubbles Indicates whether the event will bubble through the display list.
	 * @param {Boolean} cancelable Indicates whether the default behaviour of this event can be cancelled.
	 * @constructor
	 **/
	function Event(type, bubbles, cancelable) {
		
	
	// public properties:
		/**
		 * The type of event.
		 * @property type
		 * @type String
		 **/
		this.type = type;
	
		/**
		 * The object that generated an event.
		 * @property target
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.target = null;
	
		/**
		 * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will
		 * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event
		 * is generated from childObj, then a listener on parentObj would receive the event with
		 * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).
		 * @property currentTarget
		 * @type Object
		 * @default null
		 * @readonly
		*/
		this.currentTarget = null;
	
		/**
		 * For bubbling events, this indicates the current event phase:<OL>
		 * 	<LI> capture phase: starting from the top parent to the target</LI>
		 * 	<LI> at target phase: currently being dispatched from the target</LI>
		 * 	<LI> bubbling phase: from the target to the top parent</LI>
		 * </OL>
		 * @property eventPhase
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.eventPhase = 0;
	
		/**
		 * Indicates whether the event will bubble through the display list.
		 * @property bubbles
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.bubbles = !!bubbles;
	
		/**
		 * Indicates whether the default behaviour of this event can be cancelled via
		 * {{#crossLink "Event/preventDefault"}}{{/crossLink}}. This is set via the Event constructor.
		 * @property cancelable
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.cancelable = !!cancelable;
	
		/**
		 * The epoch time at which this event was created.
		 * @property timeStamp
		 * @type Number
		 * @default 0
		 * @readonly
		*/
		this.timeStamp = (new Date()).getTime();
	
		/**
		 * Indicates if {{#crossLink "Event/preventDefault"}}{{/crossLink}} has been called
		 * on this event.
		 * @property defaultPrevented
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.defaultPrevented = false;
	
		/**
		 * Indicates if {{#crossLink "Event/stopPropagation"}}{{/crossLink}} or
		 * {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called on this event.
		 * @property propagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.propagationStopped = false;
	
		/**
		 * Indicates if {{#crossLink "Event/stopImmediatePropagation"}}{{/crossLink}} has been called
		 * on this event.
		 * @property immediatePropagationStopped
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.immediatePropagationStopped = false;
		
		/**
		 * Indicates if {{#crossLink "Event/remove"}}{{/crossLink}} has been called on this event.
		 * @property removed
		 * @type Boolean
		 * @default false
		 * @readonly
		*/
		this.removed = false;
	}
	var p = Event.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.
	

// public methods:
	/**
	 * Sets {{#crossLink "Event/defaultPrevented"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method preventDefault
	 **/
	p.preventDefault = function() {
		this.defaultPrevented = this.cancelable&&true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopPropagation
	 **/
	p.stopPropagation = function() {
		this.propagationStopped = true;
	};

	/**
	 * Sets {{#crossLink "Event/propagationStopped"}}{{/crossLink}} and
	 * {{#crossLink "Event/immediatePropagationStopped"}}{{/crossLink}} to true.
	 * Mirrors the DOM event standard.
	 * @method stopImmediatePropagation
	 **/
	p.stopImmediatePropagation = function() {
		this.immediatePropagationStopped = this.propagationStopped = true;
	};
	
	/**
	 * Causes the active listener to be removed via removeEventListener();
	 * 
	 * 		myBtn.addEventListener("click", function(evt) {
	 * 			// do stuff...
	 * 			evt.remove(); // removes this listener.
	 * 		});
	 * 
	 * @method remove
	 **/
	p.remove = function() {
		this.removed = true;
	};
	
	/**
	 * Returns a clone of the Event instance.
	 * @method clone
	 * @return {Event} a clone of the Event instance.
	 **/
	p.clone = function() {
		return new Event(this.type, this.bubbles, this.cancelable);
	};
	
	/**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
	 * @method set
	 * @param {Object} props A generic object containing properties to copy to the instance.
	 * @return {Event} Returns the instance the method is called on (useful for chaining calls.)
	 * @chainable
	*/
	p.set = function(props) {
		for (var n in props) { this[n] = props[n]; }
		return this;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[Event (type="+this.type+")]";
	};

	createjs.Event = Event;
}());

//##############################################################################
// EventDispatcher.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * EventDispatcher provides methods for managing queues of event listeners and dispatching events.
	 *
	 * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the
	 * EventDispatcher {{#crossLink "EventDispatcher/initialize"}}{{/crossLink}} method.
	 * 
	 * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the
	 * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports
	 * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.
	 * 
	 * EventDispatcher also exposes a {{#crossLink "EventDispatcher/on"}}{{/crossLink}} method, which makes it easier
	 * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The 
	 * {{#crossLink "EventDispatcher/off"}}{{/crossLink}} method is merely an alias to
	 * {{#crossLink "EventDispatcher/removeEventListener"}}{{/crossLink}}.
	 * 
	 * Another addition to the DOM Level 2 model is the {{#crossLink "EventDispatcher/removeAllEventListeners"}}{{/crossLink}}
	 * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also 
	 * includes a {{#crossLink "Event/remove"}}{{/crossLink}} method which removes the active listener.
	 *
	 * <h4>Example</h4>
	 * Add EventDispatcher capabilities to the "MyClass" class.
	 *
	 *      EventDispatcher.initialize(MyClass.prototype);
	 *
	 * Add an event (see {{#crossLink "EventDispatcher/addEventListener"}}{{/crossLink}}).
	 *
	 *      instance.addEventListener("eventName", handlerMethod);
	 *      function handlerMethod(event) {
	 *          console.log(event.target + " Was Clicked");
	 *      }
	 *
	 * <b>Maintaining proper scope</b><br />
	 * Scope (ie. "this") can be be a challenge with events. Using the {{#crossLink "EventDispatcher/on"}}{{/crossLink}}
	 * method to subscribe to events simplifies this.
	 *
	 *      instance.addEventListener("click", function(event) {
	 *          console.log(instance == this); // false, scope is ambiguous.
	 *      });
	 *      
	 *      instance.on("click", function(event) {
	 *          console.log(instance == this); // true, "on" uses dispatcher scope by default.
	 *      });
	 * 
	 * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage scope.
	 *      
	 *
	 * @class EventDispatcher
	 * @constructor
	 **/
	function EventDispatcher() {
	
	
	// private properties:
		/**
		 * @protected
		 * @property _listeners
		 * @type Object
		 **/
		this._listeners = null;
		
		/**
		 * @protected
		 * @property _captureListeners
		 * @type Object
		 **/
		this._captureListeners = null;
	}
	var p = EventDispatcher.prototype;

	/**
	 * <strong>REMOVED</strong>. Removed in favor of using `MySuperClass_constructor`.
	 * See {{#crossLink "Utility Methods/extend"}}{{/crossLink}} and {{#crossLink "Utility Methods/promote"}}{{/crossLink}}
	 * for details.
	 *
	 * There is an inheritance tutorial distributed with EaselJS in /tutorials/Inheritance.
	 *
	 * @method initialize
	 * @protected
	 * @deprecated
	 */
	// p.initialize = function() {}; // searchable for devs wondering where it is.


// static public methods:
	/**
	 * Static initializer to mix EventDispatcher methods into a target object or prototype.
	 * 
	 * 		EventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class
	 * 		EventDispatcher.initialize(myObject); // add to a specific instance
	 * 
	 * @method initialize
	 * @static
	 * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a
	 * prototype.
	 **/
	EventDispatcher.initialize = function(target) {
		target.addEventListener = p.addEventListener;
		target.on = p.on;
		target.removeEventListener = target.off =  p.removeEventListener;
		target.removeAllEventListeners = p.removeAllEventListeners;
		target.hasEventListener = p.hasEventListener;
		target.dispatchEvent = p.dispatchEvent;
		target._dispatchEvent = p._dispatchEvent;
		target.willTrigger = p.willTrigger;
	};
	

// public methods:
	/**
	 * Adds the specified event listener. Note that adding multiple listeners to the same function will result in
	 * multiple callbacks getting fired.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.addEventListener("click", handleClick);
	 *      function handleClick(event) {
	 *         // Click happened.
	 *      }
	 *
	 * @method addEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function | Object} Returns the listener for chaining or assignment.
	 **/
	p.addEventListener = function(type, listener, useCapture) {
		var listeners;
		if (useCapture) {
			listeners = this._captureListeners = this._captureListeners||{};
		} else {
			listeners = this._listeners = this._listeners||{};
		}
		var arr = listeners[type];
		if (arr) { this.removeEventListener(type, listener, useCapture); }
		arr = listeners[type]; // remove may have deleted the array
		if (!arr) { listeners[type] = [listener];  }
		else { arr.push(listener); }
		return listener;
	};
	
	/**
	 * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener
	 * only run once, associate arbitrary data with the listener, and remove the listener.
	 * 
	 * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.
	 * The created anonymous function is returned for use with .removeEventListener (or .off).
	 * 
	 * <h4>Example</h4>
	 * 
	 * 		var listener = myBtn.on("click", handleClick, null, false, {count:3});
	 * 		function handleClick(evt, data) {
	 * 			data.count -= 1;
	 * 			console.log(this == myBtn); // true - scope defaults to the dispatcher
	 * 			if (data.count == 0) {
	 * 				alert("clicked 3 times!");
	 * 				myBtn.off("click", listener);
	 * 				// alternately: evt.remove();
	 * 			}
	 * 		}
	 * 
	 * @method on
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when
	 * the event is dispatched.
	 * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).
	 * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.
	 * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.
	 * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.
	 **/
	p.on = function(type, listener, scope, once, data, useCapture) {
		if (listener.handleEvent) {
			scope = scope||listener;
			listener = listener.handleEvent;
		}
		scope = scope||this;
		return this.addEventListener(type, function(evt) {
				listener.call(scope, evt, data);
				once&&evt.remove();
			}, useCapture);
	};

	/**
	 * Removes the specified event listener.
	 *
	 * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy
	 * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or
	 * closure will not work.
	 *
	 * <h4>Example</h4>
	 *
	 *      displayObject.removeEventListener("click", handleClick);
	 *
	 * @method removeEventListener
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.removeEventListener = function(type, listener, useCapture) {
		var listeners = useCapture ? this._captureListeners : this._listeners;
		if (!listeners) { return; }
		var arr = listeners[type];
		if (!arr) { return; }
		for (var i=0,l=arr.length; i<l; i++) {
			if (arr[i] == listener) {
				if (l==1) { delete(listeners[type]); } // allows for faster checks.
				else { arr.splice(i,1); }
				break;
			}
		}
	};
	
	/**
	 * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the
	 * .on method.
	 *
	 * @method off
	 * @param {String} type The string type of the event.
	 * @param {Function | Object} listener The listener function or object.
	 * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.
	 **/
	p.off = p.removeEventListener;

	/**
	 * Removes all listeners for the specified type, or all listeners of all types.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Remove all listeners
	 *      displayObject.removeAllEventListeners();
	 *
	 *      // Remove all click listeners
	 *      displayObject.removeAllEventListeners("click");
	 *
	 * @method removeAllEventListeners
	 * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.
	 **/
	p.removeAllEventListeners = function(type) {
		if (!type) { this._listeners = this._captureListeners = null; }
		else {
			if (this._listeners) { delete(this._listeners[type]); }
			if (this._captureListeners) { delete(this._captureListeners[type]); }
		}
	};

	/**
	 * Dispatches the specified event to all listeners.
	 *
	 * <h4>Example</h4>
	 *
	 *      // Use a string event
	 *      this.dispatchEvent("complete");
	 *
	 *      // Use an Event instance
	 *      var event = new createjs.Event("progress");
	 *      this.dispatchEvent(event);
	 *
	 * @method dispatchEvent
	 * @param {Object | String | Event} eventObj An object with a "type" property, or a string type.
	 * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,
	 * dispatchEvent will construct an Event instance with the specified type.
	 * @return {Boolean} Returns the value of eventObj.defaultPrevented.
	 **/
	p.dispatchEvent = function(eventObj) {
		if (typeof eventObj == "string") {
			// won't bubble, so skip everything if there's no listeners:
			var listeners = this._listeners;
			if (!listeners || !listeners[eventObj]) { return false; }
			eventObj = new createjs.Event(eventObj);
		} else if (eventObj.target && eventObj.clone) {
			// redispatching an active event object, so clone it:
			eventObj = eventObj.clone();
		}
		try { eventObj.target = this; } catch (e) {} // try/catch allows redispatching of native events

		if (!eventObj.bubbles || !this.parent) {
			this._dispatchEvent(eventObj, 2);
		} else {
			var top=this, list=[top];
			while (top.parent) { list.push(top = top.parent); }
			var i, l=list.length;

			// capture & atTarget
			for (i=l-1; i>=0 && !eventObj.propagationStopped; i--) {
				list[i]._dispatchEvent(eventObj, 1+(i==0));
			}
			// bubbling
			for (i=1; i<l && !eventObj.propagationStopped; i++) {
				list[i]._dispatchEvent(eventObj, 3);
			}
		}
		return eventObj.defaultPrevented;
	};

	/**
	 * Indicates whether there is at least one listener for the specified event type.
	 * @method hasEventListener
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns true if there is at least one listener for the specified event.
	 **/
	p.hasEventListener = function(type) {
		var listeners = this._listeners, captureListeners = this._captureListeners;
		return !!((listeners && listeners[type]) || (captureListeners && captureListeners[type]));
	};
	
	/**
	 * Indicates whether there is at least one listener for the specified event type on this object or any of its
	 * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the
	 * specified type is dispatched from this object, it will trigger at least one listener.
	 * 
	 * This is similar to {{#crossLink "EventDispatcher/hasEventListener"}}{{/crossLink}}, but it searches the entire
	 * event flow for a listener, not just this object.
	 * @method willTrigger
	 * @param {String} type The string type of the event.
	 * @return {Boolean} Returns `true` if there is at least one listener for the specified event.
	 **/
	p.willTrigger = function(type) {
		var o = this;
		while (o) {
			if (o.hasEventListener(type)) { return true; }
			o = o.parent;
		}
		return false;
	};

	/**
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return "[EventDispatcher]";
	};


// private methods:
	/**
	 * @method _dispatchEvent
	 * @param {Object | String | Event} eventObj
	 * @param {Object} eventPhase
	 * @protected
	 **/
	p._dispatchEvent = function(eventObj, eventPhase) {
		var l, listeners = (eventPhase==1) ? this._captureListeners : this._listeners;
		if (eventObj && listeners) {
			var arr = listeners[eventObj.type];
			if (!arr||!(l=arr.length)) { return; }
			try { eventObj.currentTarget = this; } catch (e) {}
			try { eventObj.eventPhase = eventPhase; } catch (e) {}
			eventObj.removed = false;
			
			arr = arr.slice(); // to avoid issues with items being removed or added during the dispatch
			for (var i=0; i<l && !eventObj.immediatePropagationStopped; i++) {
				var o = arr[i];
				if (o.handleEvent) { o.handleEvent(eventObj); }
				else { o(eventObj); }
				if (eventObj.removed) {
					this.off(eventObj.type, o, eventPhase==1);
					eventObj.removed = false;
				}
			}
		}
	};


	createjs.EventDispatcher = EventDispatcher;
}());

//##############################################################################
// Ticker.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor:
	/**
	 * The Ticker provides a centralized tick or heartbeat broadcast at a set interval. Listeners can subscribe to the tick
	 * event to be notified when a set time interval has elapsed.
	 *
	 * Note that the interval that the tick event is called is a target interval, and may be broadcast at a slower interval
	 * when under high CPU load. The Ticker class uses a static interface (ex. `Ticker.framerate = 30;`) and
	 * can not be instantiated.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.Ticker.addEventListener("tick", handleTick);
	 *      function handleTick(event) {
	 *          // Actions carried out each tick (aka frame)
	 *          if (!event.paused) {
	 *              // Actions carried out when the Ticker is not paused.
	 *          }
	 *      }
	 *
	 * @class Ticker
	 * @uses EventDispatcher
	 * @static
	 **/
	function Ticker() {
		throw "Ticker cannot be instantiated.";
	}


// constants:
	/**
	 * In this mode, Ticker uses the requestAnimationFrame API, but attempts to synch the ticks to target framerate. It
	 * uses a simple heuristic that compares the time of the RAF return to the target time for the current frame and
	 * dispatches the tick when the time is within a certain threshold.
	 *
	 * This mode has a higher variance for time between frames than {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}},
	 * but does not require that content be time based as with {{#crossLink "Ticker/RAF:property"}}{{/crossLink}} while
	 * gaining the benefits of that API (screen synch, background throttling).
	 *
	 * Variance is usually lowest for framerates that are a divisor of the RAF frequency. This is usually 60, so
	 * framerates of 10, 12, 15, 20, and 30 work well.
	 *
	 * Falls back to {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}} if the requestAnimationFrame API is not
	 * supported.
	 * @property RAF_SYNCHED
	 * @static
	 * @type {String}
	 * @default "synched"
	 * @readonly
	 **/
	Ticker.RAF_SYNCHED = "synched";

	/**
	 * In this mode, Ticker passes through the requestAnimationFrame heartbeat, ignoring the target framerate completely.
	 * Because requestAnimationFrame frequency is not deterministic, any content using this mode should be time based.
	 * You can leverage {{#crossLink "Ticker/getTime"}}{{/crossLink}} and the {{#crossLink "Ticker/tick:event"}}{{/crossLink}}
	 * event object's "delta" properties to make this easier.
	 *
	 * Falls back on {{#crossLink "Ticker/TIMEOUT:property"}}{{/crossLink}} if the requestAnimationFrame API is not
	 * supported.
	 * @property RAF
	 * @static
	 * @type {String}
	 * @default "raf"
	 * @readonly
	 **/
	Ticker.RAF = "raf";

	/**
	 * In this mode, Ticker uses the setTimeout API. This provides predictable, adaptive frame timing, but does not
	 * provide the benefits of requestAnimationFrame (screen synch, background throttling).
	 * @property TIMEOUT
	 * @static
	 * @type {String}
	 * @default "timeout"
	 * @readonly
	 **/
	Ticker.TIMEOUT = "timeout";


// static events:
	/**
	 * Dispatched each tick. The event will be dispatched to each listener even when the Ticker has been paused using
	 * {{#crossLink "Ticker/setPaused"}}{{/crossLink}}.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.Ticker.addEventListener("tick", handleTick);
	 *      function handleTick(event) {
	 *          console.log("Paused:", event.paused, event.delta);
	 *      }
	 *
	 * @event tick
	 * @param {Object} target The object that dispatched the event.
	 * @param {String} type The event type.
	 * @param {Boolean} paused Indicates whether the ticker is currently paused.
	 * @param {Number} delta The time elapsed in ms since the last tick.
	 * @param {Number} time The total time in ms since Ticker was initialized.
	 * @param {Number} runTime The total time in ms that Ticker was not paused since it was initialized. For example,
	 * 	you could determine the amount of time that the Ticker has been paused since initialization with `time-runTime`.
	 * @since 0.6.0
	 */


// public static properties:
	/**
	 * Deprecated in favour of {{#crossLink "Ticker/timingMode"}}{{/crossLink}}, and will be removed in a future version. If true, timingMode will
	 * use {{#crossLink "Ticker/RAF_SYNCHED"}}{{/crossLink}} by default.
	 * @deprecated Deprecated in favour of {{#crossLink "Ticker/timingMode"}}{{/crossLink}}.
	 * @property useRAF
	 * @static
	 * @type {Boolean}
	 * @default false
	 **/
	Ticker.useRAF = false;

	/**
	 * Specifies the timing api (setTimeout or requestAnimationFrame) and mode to use. See
	 * {{#crossLink "Ticker/TIMEOUT"}}{{/crossLink}}, {{#crossLink "Ticker/RAF"}}{{/crossLink}}, and
	 * {{#crossLink "Ticker/RAF_SYNCHED"}}{{/crossLink}} for mode details.
	 * @property timingMode
	 * @static
	 * @type {String}
	 * @default Ticker.TIMEOUT
	 **/
	Ticker.timingMode = null;

	/**
	 * Specifies a maximum value for the delta property in the tick event object. This is useful when building time
	 * based animations and systems to prevent issues caused by large time gaps caused by background tabs, system sleep,
	 * alert dialogs, or other blocking routines. Double the expected frame duration is often an effective value
	 * (ex. maxDelta=50 when running at 40fps).
	 * 
	 * This does not impact any other values (ex. time, runTime, etc), so you may experience issues if you enable maxDelta
	 * when using both delta and other values.
	 * 
	 * If 0, there is no maximum.
	 * @property maxDelta
	 * @static
	 * @type {number}
	 * @default 0
	 */
	Ticker.maxDelta = 0;
	
	/**
	 * When the ticker is paused, all listeners will still receive a tick event, but the <code>paused</code> property
	 * of the event will be `true`. Also, while paused the `runTime` will not increase. See {{#crossLink "Ticker/tick:event"}}{{/crossLink}},
	 * {{#crossLink "Ticker/getTime"}}{{/crossLink}}, and {{#crossLink "Ticker/getEventTime"}}{{/crossLink}} for more
	 * info.
	 *
	 * <h4>Example</h4>
	 *
	 *      createjs.Ticker.addEventListener("tick", handleTick);
	 *      createjs.Ticker.paused = true;
	 *      function handleTick(event) {
	 *          console.log(event.paused,
	 *          	createjs.Ticker.getTime(false),
	 *          	createjs.Ticker.getTime(true));
	 *      }
	 *
	 * @property paused
	 * @static
	 * @type {Boolean}
	 * @default false
	 **/
	Ticker.paused = false;


// mix-ins:
	// EventDispatcher methods:
	Ticker.removeEventListener = null;
	Ticker.removeAllEventListeners = null;
	Ticker.dispatchEvent = null;
	Ticker.hasEventListener = null;
	Ticker._listeners = null;
	createjs.EventDispatcher.initialize(Ticker); // inject EventDispatcher methods.
	Ticker._addEventListener = Ticker.addEventListener;
	Ticker.addEventListener = function() {
		!Ticker._inited&&Ticker.init();
		return Ticker._addEventListener.apply(Ticker, arguments);
	};


// private static properties:
	/**
	 * @property _inited
	 * @static
	 * @type {Boolean}
	 * @protected
	 **/
	Ticker._inited = false;

	/**
	 * @property _startTime
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._startTime = 0;

	/**
	 * @property _pausedTime
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._pausedTime=0;

	/**
	 * The number of ticks that have passed
	 * @property _ticks
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._ticks = 0;

	/**
	 * The number of ticks that have passed while Ticker has been paused
	 * @property _pausedTicks
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._pausedTicks = 0;

	/**
	 * @property _interval
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._interval = 50;

	/**
	 * @property _lastTime
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._lastTime = 0;

	/**
	 * @property _times
	 * @static
	 * @type {Array}
	 * @protected
	 **/
	Ticker._times = null;

	/**
	 * @property _tickTimes
	 * @static
	 * @type {Array}
	 * @protected
	 **/
	Ticker._tickTimes = null;

	/**
	 * Stores the timeout or requestAnimationFrame id.
	 * @property _timerId
	 * @static
	 * @type {Number}
	 * @protected
	 **/
	Ticker._timerId = null;
	
	/**
	 * True if currently using requestAnimationFrame, false if using setTimeout. This may be different than timingMode
	 * if that property changed and a tick hasn't fired.
	 * @property _raf
	 * @static
	 * @type {Boolean}
	 * @protected
	 **/
	Ticker._raf = true;
	

// static getter / setters:
	/**
	 * Use the {{#crossLink "Ticker/interval:property"}}{{/crossLink}} property instead.
	 * @method setInterval
	 * @static
	 * @param {Number} interval
	 * @deprecated
	 **/
	Ticker.setInterval = function(interval) {
		Ticker._interval = interval;
		if (!Ticker._inited) { return; }
		Ticker._setupTick();
	};

	/**
	 * Use the {{#crossLink "Ticker/framerate:property"}}{{/crossLink}} property instead.
	 * @method getInterval
	 * @static
	 * @return {Number}
	 * @deprecated
	 **/
	Ticker.getInterval = function() {
		return Ticker._interval;
	};

	/**
	 * Use the {{#crossLink "Ticker/framerate:property"}}{{/crossLink}} property instead.
	 * @method setFPS
	 * @static
	 * @param {Number} value
	 * @deprecated
	 **/
	Ticker.setFPS = function(value) {
		Ticker.setInterval(1000/value);
	};

	/**
	 * Use the {{#crossLink "Ticker/interval:property"}}{{/crossLink}} property instead.
	 * @method getFPS
	 * @static
	 * @return {Number}
	 * @deprecated
	 **/
	Ticker.getFPS = function() {
		return 1000/Ticker._interval;
	};

	/**
	 * Indicates the target time (in milliseconds) between ticks. Default is 50 (20 FPS).
	 * Note that actual time between ticks may be more than specified depending on CPU load.
	 * This property is ignored if the ticker is using the `RAF` timing mode.
	 * @property interval
	 * @static
	 * @type {Number}
	 **/
	 
	/**
	 * Indicates the target frame rate in frames per second (FPS). Effectively just a shortcut to `interval`, where
	 * `framerate == 1000/interval`.
	 * @property framerate
	 * @static
	 * @type {Number}
	 **/
	try {
		Object.defineProperties(Ticker, {
			interval: { get: Ticker.getInterval, set: Ticker.setInterval },
			framerate: { get: Ticker.getFPS, set: Ticker.setFPS }
		});
	} catch (e) { console.log(e); }


// public static methods:
	/**
	 * Starts the tick. This is called automatically when the first listener is added.
	 * @method init
	 * @static
	 **/
	Ticker.init = function() {
		if (Ticker._inited) { return; }
		Ticker._inited = true;
		Ticker._times = [];
		Ticker._tickTimes = [];
		Ticker._startTime = Ticker._getTime();
		Ticker._times.push(Ticker._lastTime = 0);
		Ticker.interval = Ticker._interval;
	};
	
	/**
	 * Stops the Ticker and removes all listeners. Use init() to restart the Ticker.
	 * @method reset
	 * @static
	 **/
	Ticker.reset = function() {
		if (Ticker._raf) {
			var f = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;
			f&&f(Ticker._timerId);
		} else {
			clearTimeout(Ticker._timerId);
		}
		Ticker.removeAllEventListeners("tick");
		Ticker._timerId = Ticker._times = Ticker._tickTimes = null;
		Ticker._startTime = Ticker._lastTime = Ticker._ticks = 0;
		Ticker._inited = false;
	};

	/**
	 * Returns the average time spent within a tick. This can vary significantly from the value provided by getMeasuredFPS
	 * because it only measures the time spent within the tick execution stack. 
	 * 
	 * Example 1: With a target FPS of 20, getMeasuredFPS() returns 20fps, which indicates an average of 50ms between 
	 * the end of one tick and the end of the next. However, getMeasuredTickTime() returns 15ms. This indicates that 
	 * there may be up to 35ms of "idle" time between the end of one tick and the start of the next.
	 *
	 * Example 2: With a target FPS of 30, getFPS() returns 10fps, which indicates an average of 100ms between the end of
	 * one tick and the end of the next. However, getMeasuredTickTime() returns 20ms. This would indicate that something
	 * other than the tick is using ~80ms (another script, DOM rendering, etc).
	 * @method getMeasuredTickTime
	 * @static
	 * @param {Number} [ticks] The number of previous ticks over which to measure the average time spent in a tick.
	 * Defaults to the number of ticks per second. To get only the last tick's time, pass in 1.
	 * @return {Number} The average time spent in a tick in milliseconds.
	 **/
	Ticker.getMeasuredTickTime = function(ticks) {
		var ttl=0, times=Ticker._tickTimes;
		if (!times || times.length < 1) { return -1; }

		// by default, calculate average for the past ~1 second:
		ticks = Math.min(times.length, ticks||(Ticker.getFPS()|0));
		for (var i=0; i<ticks; i++) { ttl += times[i]; }
		return ttl/ticks;
	};

	/**
	 * Returns the actual frames / ticks per second.
	 * @method getMeasuredFPS
	 * @static
	 * @param {Number} [ticks] The number of previous ticks over which to measure the actual frames / ticks per second.
	 * Defaults to the number of ticks per second.
	 * @return {Number} The actual frames / ticks per second. Depending on performance, this may differ
	 * from the target frames per second.
	 **/
	Ticker.getMeasuredFPS = function(ticks) {
		var times = Ticker._times;
		if (!times || times.length < 2) { return -1; }

		// by default, calculate fps for the past ~1 second:
		ticks = Math.min(times.length-1, ticks||(Ticker.getFPS()|0));
		return 1000/((times[0]-times[ticks])/ticks);
	};

	/**
	 * Use the {{#crossLink "Ticker/paused:property"}}{{/crossLink}} property instead.
	 * @method setPaused
	 * @static
	 * @param {Boolean} value
	 * @deprecated
	 **/
	Ticker.setPaused = function(value) {
		// TODO: deprecated.
		Ticker.paused = value;
	};

	/**
	 * Use the {{#crossLink "Ticker/paused:property"}}{{/crossLink}} property instead.
	 * @method getPaused
	 * @static
	 * @return {Boolean}
	 * @deprecated
	 **/
	Ticker.getPaused = function() {
		// TODO: deprecated.
		return Ticker.paused;
	};

	/**
	 * Returns the number of milliseconds that have elapsed since Ticker was initialized via {{#crossLink "Ticker/init"}}.
	 * Returns -1 if Ticker has not been initialized. For example, you could use
	 * this in a time synchronized animation to determine the exact amount of time that has elapsed.
	 * @method getTime
	 * @static
	 * @param {Boolean} [runTime=false] If true only time elapsed while Ticker was not paused will be returned.
	 * If false, the value returned will be total time elapsed since the first tick event listener was added.
	 * @return {Number} Number of milliseconds that have elapsed since Ticker was initialized or -1.
	 **/
	Ticker.getTime = function(runTime) {
		return Ticker._startTime ? Ticker._getTime() - (runTime ? Ticker._pausedTime : 0) : -1;
	};

	/**
	 * Similar to getTime(), but returns the time on the most recent tick event object.
	 * @method getEventTime
	 * @static
	 * @param runTime {Boolean} [runTime=false] If true, the runTime property will be returned instead of time.
	 * @returns {number} The time or runTime property from the most recent tick event or -1.
	 */
	Ticker.getEventTime = function(runTime) {
		return Ticker._startTime ? (Ticker._lastTime || Ticker._startTime) - (runTime ? Ticker._pausedTime : 0) : -1;
	};
	
	/**
	 * Returns the number of ticks that have been broadcast by Ticker.
	 * @method getTicks
	 * @static
	 * @param {Boolean} pauseable Indicates whether to include ticks that would have been broadcast
	 * while Ticker was paused. If true only tick events broadcast while Ticker is not paused will be returned.
	 * If false, tick events that would have been broadcast while Ticker was paused will be included in the return
	 * value. The default value is false.
	 * @return {Number} of ticks that have been broadcast.
	 **/
	Ticker.getTicks = function(pauseable) {
		return  Ticker._ticks - (pauseable ? Ticker._pausedTicks : 0);
	};


// private static methods:
	/**
	 * @method _handleSynch
	 * @static
	 * @protected
	 **/
	Ticker._handleSynch = function() {
		Ticker._timerId = null;
		Ticker._setupTick();

		// run if enough time has elapsed, with a little bit of flexibility to be early:
		if (Ticker._getTime() - Ticker._lastTime >= (Ticker._interval-1)*0.97) {
			Ticker._tick();
		}
	};

	/**
	 * @method _handleRAF
	 * @static
	 * @protected
	 **/
	Ticker._handleRAF = function() {
		Ticker._timerId = null;
		Ticker._setupTick();
		Ticker._tick();
	};

	/**
	 * @method _handleTimeout
	 * @static
	 * @protected
	 **/
	Ticker._handleTimeout = function() {
		Ticker._timerId = null;
		Ticker._setupTick();
		Ticker._tick();
	};

	/**
	 * @method _setupTick
	 * @static
	 * @protected
	 **/
	Ticker._setupTick = function() {
		if (Ticker._timerId != null) { return; } // avoid duplicates

		var mode = Ticker.timingMode||(Ticker.useRAF&&Ticker.RAF_SYNCHED);
		if (mode == Ticker.RAF_SYNCHED || mode == Ticker.RAF) {
			var f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
			if (f) {
				Ticker._timerId = f(mode == Ticker.RAF ? Ticker._handleRAF : Ticker._handleSynch);
				Ticker._raf = true;
				return;
			}
		}
		Ticker._raf = false;
		Ticker._timerId = setTimeout(Ticker._handleTimeout, Ticker._interval);
	};

	/**
	 * @method _tick
	 * @static
	 * @protected
	 **/
	Ticker._tick = function() {
		var paused = Ticker.paused;
		var time = Ticker._getTime();
		var elapsedTime = time-Ticker._lastTime;
		Ticker._lastTime = time;
		Ticker._ticks++;
		
		if (paused) {
			Ticker._pausedTicks++;
			Ticker._pausedTime += elapsedTime;
		}
		
		if (Ticker.hasEventListener("tick")) {
			var event = new createjs.Event("tick");
			var maxDelta = Ticker.maxDelta;
			event.delta = (maxDelta && elapsedTime > maxDelta) ? maxDelta : elapsedTime;
			event.paused = paused;
			event.time = time;
			event.runTime = time-Ticker._pausedTime;
			Ticker.dispatchEvent(event);
		}
		
		Ticker._tickTimes.unshift(Ticker._getTime()-time);
		while (Ticker._tickTimes.length > 100) { Ticker._tickTimes.pop(); }

		Ticker._times.unshift(time);
		while (Ticker._times.length > 100) { Ticker._times.pop(); }
	};

	/**
	 * @method _getTime
	 * @static
	 * @protected
	 **/
	var now = window.performance && (performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow);
	Ticker._getTime = function() {
		return ((now&&now.call(performance))||(new Date().getTime())) - Ticker._startTime;
	};


	createjs.Ticker = Ticker;
}());

//##############################################################################
// Tween.js
//##############################################################################

// TODO: possibly add a END actionsMode (only runs actions that == position)?
// TODO: evaluate a way to decouple paused from tick registration.


this.createjs = this.createjs||{};

(function() {
	"use strict";


// constructor
	/**
	 * A Tween instance tweens properties for a single target. Instance methods can be chained for easy construction and sequencing:
	 *
	 * <h4>Example</h4>
	 *
	 *      target.alpha = 1;
	 *	    createjs.Tween.get(target)
	 *	         .wait(500)
	 *	         .to({alpha:0, visible:false}, 1000)
	 *	         .call(handleComplete);
	 *	    function handleComplete() {
	 *	    	//Tween complete
	 *	    }
	 *
	 * Multiple tweens can point to the same instance, however if they affect the same properties there could be unexpected
	 * behaviour. To stop all tweens on an object, use {{#crossLink "Tween/removeTweens"}}{{/crossLink}} or pass `override:true`
	 * in the props argument.
	 *
	 *      createjs.Tween.get(target, {override:true}).to({x:100});
	 *
	 * Subscribe to the {{#crossLink "Tween/change:event"}}{{/crossLink}} event to get notified when a property of the
	 * target is changed.
	 *
	 *      createjs.Tween.get(target, {override:true}).to({x:100}).addEventListener("change", handleChange);
	 *      function handleChange(event) {
	 *          // The tween changed.
	 *      }
	 *
	 * See the Tween {{#crossLink "Tween/get"}}{{/crossLink}} method for additional param documentation.
	 * @class Tween
	 * @param {Object} target The target object that will have its properties tweened.
	 * @param {Object} [props] The configuration properties to apply to this tween instance (ex. `{loop:true, paused:true}`.
	 * All properties default to false. Supported props are:<UL>
	 *    <LI> loop: sets the loop property on this tween.</LI>
	 *    <LI> useTicks: uses ticks for all durations instead of milliseconds.</LI>
	 *    <LI> ignoreGlobalPause: sets the {{#crossLink "Tween/ignoreGlobalPause:property"}}{{/crossLink}} property on this tween.</LI>
	 *    <LI> override: if true, `Tween.removeTweens(target)` will be called to remove any other tweens with the same target.
	 *    <LI> paused: indicates whether to start the tween paused.</LI>
	 *    <LI> position: indicates the initial position for this tween.</LI>
	 *    <LI> onChange: specifies a listener for the "change" event.</LI>
	 * </UL>
	 * @param {Object} [pluginData] An object containing data for use by installed plugins. See individual
	 * plugins' documentation for details.
	 * @extends EventDispatcher
	 * @constructor
	 */
	function Tween(target, props, pluginData) {

	// public properties:
		/**
		 * Causes this tween to continue playing when a global pause is active. For example, if TweenJS is using {{#crossLink "Ticker"}}{{/crossLink}},
		 * then setting this to true (the default) will cause this tween to be paused when <code>Ticker.setPaused(true)</code>
		 * is called. See the Tween {{#crossLink "Tween/tick"}}{{/crossLink}} method for more info. Can be set via the props
		 * parameter.
		 * @property ignoreGlobalPause
		 * @type Boolean
		 * @default false
		 */
		this.ignoreGlobalPause = false;
	
		/**
		 * If true, the tween will loop when it reaches the end. Can be set via the props param.
		 * @property loop
		 * @type {Boolean}
		 * @default false
		 */
		this.loop = false;
	
		/**
		 * Specifies the total duration of this tween in milliseconds (or ticks if useTicks is true).
		 * This value is automatically updated as you modify the tween. Changing it directly could result in unexpected
		 * behaviour.
		 * @property duration
		 * @type {Number}
		 * @default 0
		 * @readonly
		 */
		this.duration = 0;
	
		/**
		 * Allows you to specify data that will be used by installed plugins. Each plugin uses this differently, but in general
		 * you specify data by setting it to a property of pluginData with the same name as the plugin class.
		 * @example
		 *	myTween.pluginData.PluginClassName = data;
		 * <br/>
		 * Also, most plugins support a property to enable or disable them. This is typically the plugin class name followed by "_enabled".<br/>
		 * @example
		 *	myTween.pluginData.PluginClassName_enabled = false;<br/>
		 * <br/>
		 * Some plugins also store instance data in this object, usually in a property named _PluginClassName.
		 * See the documentation for individual plugins for more details.
		 * @property pluginData
		 * @type {Object}
		 */
		this.pluginData = pluginData || {};
	
		/**
		 * The target of this tween. This is the object on which the tweened properties will be changed. Changing
		 * this property after the tween is created will not have any effect.
		 * @property target
		 * @type {Object}
		 * @readonly
		 */
		this.target = target;
	
		/**
		 * The current normalized position of the tween. This will always be a value between 0 and duration.
		 * Changing this property directly will have no effect.
		 * @property position
		 * @type {Object}
		 * @readonly
		 */
		this.position = null;
	
		/**
		 * Indicates the tween's current position is within a passive wait.
		 * @property passive
		 * @type {Boolean}
		 * @default false
		 * @readonly
		 **/
		this.passive = false;
	
	// private properties:	
		/**
		 * @property _paused
		 * @type {Boolean}
		 * @default false
		 * @protected
		 */
		this._paused = false;
	
		/**
		 * @property _curQueueProps
		 * @type {Object}
		 * @protected
		 */
		this._curQueueProps = {};
	
		/**
		 * @property _initQueueProps
		 * @type {Object}
		 * @protected
		 */
		this._initQueueProps = {};
	
		/**
		 * @property _steps
		 * @type {Array}
		 * @protected
		 */
		this._steps = [];
	
		/**
		 * @property _actions
		 * @type {Array}
		 * @protected
		 */
		this._actions = [];
	
		/**
		 * Raw position.
		 * @property _prevPosition
		 * @type {Number}
		 * @default 0
		 * @protected
		 */
		this._prevPosition = 0;
	
		/**
		 * The position within the current step.
		 * @property _stepPosition
		 * @type {Number}
		 * @default 0
		 * @protected
		 */
		this._stepPosition = 0; // this is needed by MovieClip.
	
		/**
		 * Normalized position.
		 * @property _prevPos
		 * @type {Number}
		 * @default -1
		 * @protected
		 */
		this._prevPos = -1;
	
		/**
		 * @property _target
		 * @type {Object}
		 * @protected
		 */
		this._target = target;
	
		/**
		 * @property _useTicks
		 * @type {Boolean}
		 * @default false
		 * @protected
		 */
		this._useTicks = false;
	
		/**
		 * @property _inited
		 * @type {boolean}
		 * @default false
		 * @protected
		 */
		this._inited = false;
		
		/**
		 * Indicates whether the tween is currently registered with Tween.
		 * @property _registered
		 * @type {boolean}
		 * @default false
		 * @protected
		 */
		this._registered = false;


		if (props) {
			this._useTicks = props.useTicks;
			this.ignoreGlobalPause = props.ignoreGlobalPause;
			this.loop = props.loop;
			props.onChange && this.addEventListener("change", props.onChange);
			if (props.override) { Tween.removeTweens(target); }
		}
		if (props&&props.paused) { this._paused=true; }
		else { createjs.Tween._register(this,true); }
		if (props&&props.position!=null) { this.setPosition(props.position, Tween.NONE); }

	};

	var p = createjs.extend(Tween, createjs.EventDispatcher);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.
	

// static properties
	/**
	 * Constant defining the none actionsMode for use with setPosition.
	 * @property NONE
	 * @type Number
	 * @default 0
	 * @static
	 */
	Tween.NONE = 0;

	/**
	 * Constant defining the loop actionsMode for use with setPosition.
	 * @property LOOP
	 * @type Number
	 * @default 1
	 * @static
	 */
	Tween.LOOP = 1;

	/**
	 * Constant defining the reverse actionsMode for use with setPosition.
	 * @property REVERSE
	 * @type Number
	 * @default 2
	 * @static
	 */
	Tween.REVERSE = 2;

	/**
	 * Constant returned by plugins to tell the tween not to use default assignment.
	 * @property IGNORE
	 * @type Object
	 * @static
	 */
	Tween.IGNORE = {};

	/**
	 * @property _listeners
	 * @type Array[Tween]
	 * @static
	 * @protected
	 */
	Tween._tweens = [];

	/**
	 * @property _plugins
	 * @type Object
	 * @static
	 * @protected
	 */
	Tween._plugins = {};


// static methods	
	/**
	 * Returns a new tween instance. This is functionally identical to using "new Tween(...)", but looks cleaner
	 * with the chained syntax of TweenJS.
	 * <h4>Example</h4>
	 *
	 *		var tween = createjs.Tween.get(target);
	 *
	 * @method get
	 * @param {Object} target The target object that will have its properties tweened.
	 * @param {Object} [props] The configuration properties to apply to this tween instance (ex. `{loop:true, paused:true}`).
	 * All properties default to `false`. Supported props are:
	 * <UL>
	 *    <LI> loop: sets the loop property on this tween.</LI>
	 *    <LI> useTicks: uses ticks for all durations instead of milliseconds.</LI>
	 *    <LI> ignoreGlobalPause: sets the {{#crossLink "Tween/ignoreGlobalPause:property"}}{{/crossLink}} property on
	 *    this tween.</LI>
	 *    <LI> override: if true, `createjs.Tween.removeTweens(target)` will be called to remove any other tweens with
	 *    the same target.
	 *    <LI> paused: indicates whether to start the tween paused.</LI>
	 *    <LI> position: indicates the initial position for this tween.</LI>
	 *    <LI> onChange: specifies a listener for the {{#crossLink "Tween/change:event"}}{{/crossLink}} event.</LI>
	 * </UL>
	 * @param {Object} [pluginData] An object containing data for use by installed plugins. See individual plugins'
	 * documentation for details.
	 * @param {Boolean} [override=false] If true, any previous tweens on the same target will be removed. This is the
	 * same as calling `Tween.removeTweens(target)`.
	 * @return {Tween} A reference to the created tween. Additional chained tweens, method calls, or callbacks can be
	 * applied to the returned tween instance.
	 * @static
	 */
	Tween.get = function(target, props, pluginData, override) {
		if (override) { Tween.removeTweens(target); }
		return new Tween(target, props, pluginData);
	};

	/**
	 * Advances all tweens. This typically uses the {{#crossLink "Ticker"}}{{/crossLink}} class, but you can call it
	 * manually if you prefer to use your own "heartbeat" implementation.
	 * @method tick
	 * @param {Number} delta The change in time in milliseconds since the last tick. Required unless all tweens have
	 * `useTicks` set to true.
	 * @param {Boolean} paused Indicates whether a global pause is in effect. Tweens with {{#crossLink "Tween/ignoreGlobalPause:property"}}{{/crossLink}}
	 * will ignore this, but all others will pause if this is `true`.
	 * @static
	 */
	Tween.tick = function(delta, paused) {
		var tweens = Tween._tweens.slice(); // to avoid race conditions.
		for (var i=tweens.length-1; i>=0; i--) {
			var tween = tweens[i];
			if ((paused && !tween.ignoreGlobalPause) || tween._paused) { continue; }
			tween.tick(tween._useTicks?1:delta);
		}
	};

	/**
	 * Handle events that result from Tween being used as an event handler. This is included to allow Tween to handle
	 * {{#crossLink "Ticker/tick:event"}}{{/crossLink}} events from the createjs {{#crossLink "Ticker"}}{{/crossLink}}.
	 * No other events are handled in Tween.
	 * @method handleEvent
	 * @param {Object} event An event object passed in by the {{#crossLink "EventDispatcher"}}{{/crossLink}}. Will
	 * usually be of type "tick".
	 * @private
	 * @static
	 * @since 0.4.2
	 */
	Tween.handleEvent = function(event) {
		if (event.type == "tick") {
			this.tick(event.delta, event.paused);
		}
	};

	/**
	 * Removes all existing tweens for a target. This is called automatically by new tweens if the `override`
	 * property is `true`.
	 * @method removeTweens
	 * @param {Object} target The target object to remove existing tweens from.
	 * @static
	 */
	Tween.removeTweens = function(target) {
		if (!target.tweenjs_count) { return; }
		var tweens = Tween._tweens;
		for (var i=tweens.length-1; i>=0; i--) {
			var tween = tweens[i];
			if (tween._target == target) {
				tween._paused = true;
				tweens.splice(i, 1);
			}
		}
		target.tweenjs_count = 0;
	};

	/**
	 * Stop and remove all existing tweens.
	 * @method removeAllTweens
	 * @static
	 * @since 0.4.1
	 */
	Tween.removeAllTweens = function() {
		var tweens = Tween._tweens;
		for (var i= 0, l=tweens.length; i<l; i++) {
			var tween = tweens[i];
			tween._paused = true;
			tween.target&&(tween.target.tweenjs_count = 0);
		}
		tweens.length = 0;
	};

	/**
	 * Indicates whether there are any active tweens (and how many) on the target object (if specified) or in general.
	 * @method hasActiveTweens
	 * @param {Object} [target] The target to check for active tweens. If not specified, the return value will indicate
	 * if there are any active tweens on any target.
	 * @return {Boolean} If there are active tweens.
	 * @static
	 */
	Tween.hasActiveTweens = function(target) {
		if (target) { return target.tweenjs_count != null && !!target.tweenjs_count; }
		return Tween._tweens && !!Tween._tweens.length;
	};

	/**
	 * Installs a plugin, which can modify how certain properties are handled when tweened. See the {{#crossLink "CSSPlugin"}}{{/crossLink}}
	 * for an example of how to write TweenJS plugins.
	 * @method installPlugin
	 * @static
	 * @param {Object} plugin The plugin class to install
	 * @param {Array} properties An array of properties that the plugin will handle.
	 */
	Tween.installPlugin = function(plugin, properties) {
		var priority = plugin.priority;
		if (priority == null) { plugin.priority = priority = 0; }
		for (var i=0,l=properties.length,p=Tween._plugins;i<l;i++) {
			var n = properties[i];
			if (!p[n]) { p[n] = [plugin]; }
			else {
				var arr = p[n];
				for (var j=0,jl=arr.length;j<jl;j++) {
					if (priority < arr[j].priority) { break; }
				}
				p[n].splice(j,0,plugin);
			}
		}
	};

	/**
	 * Registers or unregisters a tween with the ticking system.
	 * @method _register
	 * @param {Tween} tween The tween instance to register or unregister.
	 * @param {Boolean} value If `true`, the tween is registered. If `false` the tween is unregistered.
	 * @static
	 * @protected
	 */
	Tween._register = function(tween, value) {
		var target = tween._target;
		var tweens = Tween._tweens;
		if (value && !tween._registered) {
			// TODO: this approach might fail if a dev is using sealed objects in ES5
			if (target) { target.tweenjs_count = target.tweenjs_count ? target.tweenjs_count+1 : 1; }
			tweens.push(tween);
			if (!Tween._inited && createjs.Ticker) { createjs.Ticker.addEventListener("tick", Tween); Tween._inited = true; }
		} else if (!value && tween._registered) {
			if (target) { target.tweenjs_count--; }
			var i = tweens.length;
			while (i--) {
				if (tweens[i] == tween) {
					tweens.splice(i, 1);
					break;
				}
			}
		}
		tween._registered = value;
	};


// events:
	/**
	 * Called whenever the tween's position changes.
	 * @event change
	 * @since 0.4.0
	 **/
	

// public methods:
	/**
	 * Queues a wait (essentially an empty tween).
	 * <h4>Example</h4>
	 *
	 *		//This tween will wait 1s before alpha is faded to 0.
	 *		createjs.Tween.get(target).wait(1000).to({alpha:0}, 1000);
	 *
	 * @method wait
	 * @param {Number} duration The duration of the wait in milliseconds (or in ticks if `useTicks` is true).
	 * @param {Boolean} [passive] Tween properties will not be updated during a passive wait. This
	 * is mostly useful for use with {{#crossLink "Timeline"}}{{/crossLink}} instances that contain multiple tweens
	 * affecting the same target at different times.
	 * @return {Tween} This tween instance (for chaining calls).
	 **/
	p.wait = function(duration, passive) {
		if (duration == null || duration <= 0) { return this; }
		var o = this._cloneProps(this._curQueueProps);
		return this._addStep({d:duration, p0:o, e:this._linearEase, p1:o, v:passive});
	};

	/**
	 * Queues a tween from the current values to the target properties. Set duration to 0 to jump to these value.
	 * Numeric properties will be tweened from their current value in the tween to the target value. Non-numeric
	 * properties will be set at the end of the specified duration.
	 * <h4>Example</h4>
	 *
	 *		createjs.Tween.get(target).to({alpha:0}, 1000);
	 *
	 * @method to
	 * @param {Object} props An object specifying property target values for this tween (Ex. `{x:300}` would tween the x
	 * property of the target to 300).
	 * @param {Number} [duration=0] The duration of the wait in milliseconds (or in ticks if `useTicks` is true).
	 * @param {Function} [ease="linear"] The easing function to use for this tween. See the {{#crossLink "Ease"}}{{/crossLink}}
	 * class for a list of built-in ease functions.
	 * @return {Tween} This tween instance (for chaining calls).
	 */
	p.to = function(props, duration, ease) {
		if (isNaN(duration) || duration < 0) { duration = 0; }
		return this._addStep({d:duration||0, p0:this._cloneProps(this._curQueueProps), e:ease, p1:this._cloneProps(this._appendQueueProps(props))});
	};

	/**
	 * Queues an action to call the specified function.
	 * <h4>Example</h4>
	 *
	 *   	//would call myFunction() after 1 second.
	 *   	myTween.wait(1000).call(myFunction);
	 *
	 * @method call
	 * @param {Function} callback The function to call.
	 * @param {Array} [params]. The parameters to call the function with. If this is omitted, then the function
	 *      will be called with a single param pointing to this tween.
	 * @param {Object} [scope]. The scope to call the function in. If omitted, it will be called in the target's
	 *      scope.
	 * @return {Tween} This tween instance (for chaining calls).
	 */
	p.call = function(callback, params, scope) {
		return this._addAction({f:callback, p:params ? params : [this], o:scope ? scope : this._target});
	};

	// TODO: add clarification between this and a 0 duration .to:
	/**
	 * Queues an action to set the specified props on the specified target. If target is null, it will use this tween's
	 * target.
	 * <h4>Example</h4>
	 *
	 *		myTween.wait(1000).set({visible:false},foo);
	 *
	 * @method set
	 * @param {Object} props The properties to set (ex. `{visible:false}`).
	 * @param {Object} [target] The target to set the properties on. If omitted, they will be set on the tween's target.
	 * @return {Tween} This tween instance (for chaining calls).
	 */
	p.set = function(props, target) {
		return this._addAction({f:this._set, o:this, p:[props, target ? target : this._target]});
	};

	/**
	 * Queues an action to play (unpause) the specified tween. This enables you to sequence multiple tweens.
	 * <h4>Example</h4>
	 *
	 *		myTween.to({x:100},500).play(otherTween);
	 *
	 * @method play
	 * @param {Tween} tween The tween to play.
	 * @return {Tween} This tween instance (for chaining calls).
	 */
	p.play = function(tween) {
		if (!tween) { tween = this; }
		return this.call(tween.setPaused, [false], tween);
	};

	/**
	 * Queues an action to pause the specified tween.
	 * @method pause
	 * @param {Tween} tween The tween to pause. If null, it pauses this tween.
	 * @return {Tween} This tween instance (for chaining calls)
	 */
	p.pause = function(tween) {
		if (!tween) { tween = this; }
		return this.call(tween.setPaused, [true], tween);
	};

	/**
	 * Advances the tween to a specified position.
	 * @method setPosition
	 * @param {Number} value The position to seek to in milliseconds (or ticks if useTicks is true).
	 * @param {Number} [actionsMode=1] Specifies how actions are handled (ie. call, set, play, pause):
	 * <ul>
	 *      <li>{{#crossLink "Tween/NONE:property"}}{{/crossLink}} (0) - run no actions.</li>
	 *      <li>{{#crossLink "Tween/LOOP:property"}}{{/crossLink}} (1) - if new position is less than old, then run all
	 *      actions between old and duration, then all actions between 0 and new.</li>
	 *      <li>{{#crossLink "Tween/REVERSE:property"}}{{/crossLink}} (2) - if new position is less than old, run all
	 *      actions between them in reverse.</li>
	 * </ul>
	 * @return {Boolean} Returns `true` if the tween is complete (ie. the full tween has run & {{#crossLink "Tween/loop:property"}}{{/crossLink}}
	 * is `false`).
	 */
	p.setPosition = function(value, actionsMode) {
		if (value < 0) { value = 0; }
		if (actionsMode == null) { actionsMode = 1; }

		// normalize position:
		var t = value;
		var end = false;
		if (t >= this.duration) {
			if (this.loop) { t = t%this.duration; }
			else {
				t = this.duration;
				end = true;
			}
		}
		if (t == this._prevPos) { return end; }


		var prevPos = this._prevPos;
		this.position = this._prevPos = t; // set this in advance in case an action modifies position.
		this._prevPosition = value;

		// handle tweens:
		if (this._target) {
			if (end) {
				// addresses problems with an ending zero length step.
				this._updateTargetProps(null,1);
			} else if (this._steps.length > 0) {
				// find our new tween index:
				for (var i=0, l=this._steps.length; i<l; i++) {
					if (this._steps[i].t > t) { break; }
				}
				var step = this._steps[i-1];
				this._updateTargetProps(step,(this._stepPosition = t-step.t)/step.d);
			}
		}

		// run actions:
		if (actionsMode != 0 && this._actions.length > 0) {
			if (this._useTicks) {
				// only run the actions we landed on.
				this._runActions(t,t);
			} else if (actionsMode == 1 && t<prevPos) {
				if (prevPos != this.duration) { this._runActions(prevPos, this.duration); }
				this._runActions(0, t, true);
			} else {
				this._runActions(prevPos, t);
			}
		}

		if (end) { this.setPaused(true); }

        this.dispatchEvent("change");
		return end;
	};

	/**
	 * Advances this tween by the specified amount of time in milliseconds (or ticks if`useTicks` is `true`).
	 * This is normally called automatically by the Tween engine (via {{#crossLink "Tween/tick"}}{{/crossLink}}), but is
	 * exposed for advanced uses.
	 * @method tick
	 * @param {Number} delta The time to advance in milliseconds (or ticks if `useTicks` is `true`).
	 */
	p.tick = function(delta) {
		if (this._paused) { return; }
		this.setPosition(this._prevPosition+delta);
	};

	/**
	 * Pauses or plays this tween.
	 * @method setPaused
	 * @param {Boolean} [value=true] Indicates whether the tween should be paused (`true`) or played (`false`).
	 * @return {Tween} This tween instance (for chaining calls)
	 */
	p.setPaused = function(value) {
		if (this._paused === !!value) { return this; }
		this._paused = !!value;
		Tween._register(this, !value);
		return this;
	};

	// tiny api (primarily for tool output):
	p.w = p.wait;
	p.t = p.to;
	p.c = p.call;
	p.s = p.set;

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 */
	p.toString = function() {
		return "[Tween]";
	};

	/**
	 * @method clone
	 * @protected
	 */
	p.clone = function() {
		throw("Tween can not be cloned.")
	};

// private methods:
	/**
	 * @method _updateTargetProps
	 * @param {Object} step
	 * @param {Number} ratio
	 * @protected
	 */
	p._updateTargetProps = function(step, ratio) {
		var p0,p1,v,v0,v1,arr;
		if (!step && ratio == 1) {
			// GDS: when does this run? Just at the very end? Shouldn't.
			this.passive = false;
			p0 = p1 = this._curQueueProps;
		} else {
			this.passive = !!step.v;
			if (this.passive) { return; } // don't update props.
			// apply ease to ratio.
			if (step.e) { ratio = step.e(ratio,0,1,1); }
			p0 = step.p0;
			p1 = step.p1;
		}

		for (var n in this._initQueueProps) {
			if ((v0 = p0[n]) == null) { p0[n] = v0 = this._initQueueProps[n]; }
			if ((v1 = p1[n]) == null) { p1[n] = v1 = v0; }
			if (v0 == v1 || ratio == 0 || ratio == 1 || (typeof(v0) != "number")) {
				// no interpolation - either at start, end, values don't change, or the value is non-numeric.
				v = ratio == 1 ? v1 : v0;
			} else {
				v = v0+(v1-v0)*ratio;
			}

			var ignore = false;
			if (arr = Tween._plugins[n]) {
				for (var i=0,l=arr.length;i<l;i++) {
					var v2 = arr[i].tween(this, n, v, p0, p1, ratio, !!step&&p0==p1, !step);
					if (v2 == Tween.IGNORE) { ignore = true; }
					else { v = v2; }
				}
			}
			if (!ignore) { this._target[n] = v; }
		}

	};

	/**
	 * @method _runActions
	 * @param {Number} startPos
	 * @param {Number} endPos
	 * @param {Boolean} includeStart
	 * @protected
	 */
	p._runActions = function(startPos, endPos, includeStart) {
		var sPos = startPos;
		var ePos = endPos;
		var i = -1;
		var j = this._actions.length;
		var k = 1;
		if (startPos > endPos) {
			// running backwards, flip everything:
			sPos = endPos;
			ePos = startPos;
			i = j;
			j = k = -1;
		}
		while ((i+=k) != j) {
			var action = this._actions[i];
			var pos = action.t;
			if (pos == ePos || (pos > sPos && pos < ePos) || (includeStart && pos == startPos) ) {
				action.f.apply(action.o, action.p);
			}
		}
	};

	/**
	 * @method _appendQueueProps
	 * @param {Object} o
	 * @protected
	 */
	p._appendQueueProps = function(o) {
		var arr,oldValue,i, l, injectProps;
		for (var n in o) {
			if (this._initQueueProps[n] === undefined) {
				oldValue = this._target[n];

				// init plugins:
				if (arr = Tween._plugins[n]) {
					for (i=0,l=arr.length;i<l;i++) {
						oldValue = arr[i].init(this, n, oldValue);
					}
				}
				this._initQueueProps[n] = this._curQueueProps[n] = (oldValue===undefined) ? null : oldValue;
			} else {
				oldValue = this._curQueueProps[n];
			}
		}

		for (var n in o) {
			oldValue = this._curQueueProps[n];
			if (arr = Tween._plugins[n]) {
				injectProps = injectProps||{};
				for (i=0, l=arr.length;i<l;i++) {
					// TODO: remove the check for .step in the next version. It's here for backwards compatibility.
					if (arr[i].step) { arr[i].step(this, n, oldValue, o[n], injectProps); }
				}
			}
			this._curQueueProps[n] = o[n];
		}
		if (injectProps) { this._appendQueueProps(injectProps); }
		return this._curQueueProps;
	};

	/**
	 * @method _cloneProps
	 * @param {Object} props
	 * @protected
	 */
	p._cloneProps = function(props) {
		var o = {};
		for (var n in props) {
			o[n] = props[n];
		}
		return o;
	};

	/**
	 * @method _addStep
	 * @param {Object} o
	 * @protected
	 */
	p._addStep = function(o) {
		if (o.d > 0) {
			this._steps.push(o);
			o.t = this.duration;
			this.duration += o.d;
		}
		return this;
	};

	/**
	 * @method _addAction
	 * @param {Object} o
	 * @protected
	 */
	p._addAction = function(o) {
		o.t = this.duration;
		this._actions.push(o);
		return this;
	};

	/**
	 * @method _set
	 * @param {Object} props
	 * @param {Object} o
	 * @protected
	 */
	p._set = function(props, o) {
		for (var n in props) {
			o[n] = props[n];
		}
	};

	createjs.Tween = createjs.promote(Tween, "EventDispatcher");

}());

//##############################################################################
// Timeline.js
//##############################################################################

this.createjs = this.createjs||{};


(function() {
	"use strict";
	

// constructor	
	/**
	 * The Timeline class synchronizes multiple tweens and allows them to be controlled as a group. Please note that if a
	 * timeline is looping, the tweens on it may appear to loop even if the "loop" property of the tween is false.
	 * @class Timeline
	 * @param {Array} tweens An array of Tweens to add to this timeline. See {{#crossLink "Timeline/addTween"}}{{/crossLink}}
	 * for more info.
	 * @param {Object} labels An object defining labels for using {{#crossLink "Timeline/gotoAndPlay"}}{{/crossLink}}/{{#crossLink "Timeline/gotoAndStop"}}{{/crossLink}}.
	 * See {{#crossLink "Timeline/setLabels"}}{{/crossLink}}
	 * for details.
	 * @param {Object} props The configuration properties to apply to this tween instance (ex. `{loop:true}`). All properties
	 * default to false. Supported props are:<UL>
	 *    <LI> loop: sets the loop property on this tween.</LI>
	 *    <LI> useTicks: uses ticks for all durations instead of milliseconds.</LI>
	 *    <LI> ignoreGlobalPause: sets the ignoreGlobalPause property on this tween.</LI>
	 *    <LI> paused: indicates whether to start the tween paused.</LI>
	 *    <LI> position: indicates the initial position for this timeline.</LI>
	 *    <LI> onChange: specifies a listener to add for the {{#crossLink "Timeline/change:event"}}{{/crossLink}} event.</LI>
	 * </UL>
	 * @extends EventDispatcher
	 * @constructor
	 **/
	function Timeline(tweens, labels, props) {
		this.EventDispatcher_constructor();

	// public properties:
		/**
		 * Causes this timeline to continue playing when a global pause is active.
		 * @property ignoreGlobalPause
		 * @type Boolean
		 **/
		this.ignoreGlobalPause = false;

		/**
		 * The total duration of this timeline in milliseconds (or ticks if `useTicks `is `true`). This value is usually
		 * automatically updated as you modify the timeline. See {{#crossLink "Timeline/updateDuration"}}{{/crossLink}}
		 * for more information.
		 * @property duration
		 * @type Number
		 * @default 0
		 * @readonly
		 **/
		this.duration = 0;

		/**
		 * If true, the timeline will loop when it reaches the end. Can be set via the props param.
		 * @property loop
		 * @type Boolean
		 **/
		this.loop = false;

		/**
		 * The current normalized position of the timeline. This will always be a value between 0 and
		 * {{#crossLink "Timeline/duration:property"}}{{/crossLink}}.
		 * Changing this property directly will have no effect.
		 * @property position
		 * @type Object
		 * @readonly
		 **/
		this.position = null;

		// private properties:
		/**
		 * @property _paused
		 * @type Boolean
		 * @protected
		 **/
		this._paused = false;

		/**
		 * @property _tweens
		 * @type Array[Tween]
		 * @protected
		 **/
		this._tweens = [];

		/**
		 * @property _labels
		 * @type Object
		 * @protected
		 **/
		this._labels = null;

		/**
		 * @property _labelList
		 * @type Array[Object]
		 * @protected
		 **/
		this._labelList = null;

		/**
		 * @property _prevPosition
		 * @type Number
		 * @default 0
		 * @protected
		 **/
		this._prevPosition = 0;

		/**
		 * @property _prevPos
		 * @type Number
		 * @default -1
		 * @protected
		 **/
		this._prevPos = -1;

		/**
		 * @property _useTicks
		 * @type Boolean
		 * @default false
		 * @protected
		 **/
		this._useTicks = false;
		
		/**
		 * Indicates whether the timeline is currently registered with Tween.
		 * @property _registered
		 * @type {boolean}
		 * @default false
		 * @protected
		 */
		this._registered = false;


		if (props) {
			this._useTicks = props.useTicks;
			this.loop = props.loop;
			this.ignoreGlobalPause = props.ignoreGlobalPause;
			props.onChange&&this.addEventListener("change", props.onChange);
		}
		if (tweens) { this.addTween.apply(this, tweens); }
		this.setLabels(labels);
		if (props&&props.paused) { this._paused=true; }
		else { createjs.Tween._register(this,true); }
		if (props&&props.position!=null) { this.setPosition(props.position, createjs.Tween.NONE); }
		
	};
	
	var p = createjs.extend(Timeline, createjs.EventDispatcher);

	// TODO: deprecated
	// p.initialize = function() {}; // searchable for devs wondering where it is. REMOVED. See docs for details.

	
// events:
	/**
	 * Called whenever the timeline's position changes.
	 * @event change
	 * @since 0.5.0
	 **/


// public methods:
	/**
	 * Adds one or more tweens (or timelines) to this timeline. The tweens will be paused (to remove them from the
	 * normal ticking system) and managed by this timeline. Adding a tween to multiple timelines will result in
	 * unexpected behaviour.
	 * @method addTween
	 * @param {Tween} ...tween The tween(s) to add. Accepts multiple arguments.
	 * @return {Tween} The first tween that was passed in.
	 **/
	p.addTween = function(tween) {
		var l = arguments.length;
		if (l > 1) {
			for (var i=0; i<l; i++) { this.addTween(arguments[i]); }
			return arguments[0];
		} else if (l == 0) { return null; }
		this.removeTween(tween);
		this._tweens.push(tween);
		tween.setPaused(true);
		tween._paused = false;
		tween._useTicks = this._useTicks;
		if (tween.duration > this.duration) { this.duration = tween.duration; }
		if (this._prevPos >= 0) { tween.setPosition(this._prevPos, createjs.Tween.NONE); }
		return tween;
	};

	/**
	 * Removes one or more tweens from this timeline.
	 * @method removeTween
	 * @param {Tween} ...tween The tween(s) to remove. Accepts multiple arguments.
	 * @return Boolean Returns `true` if all of the tweens were successfully removed.
	 **/
	p.removeTween = function(tween) {
		var l = arguments.length;
		if (l > 1) {
			var good = true;
			for (var i=0; i<l; i++) { good = good && this.removeTween(arguments[i]); }
			return good;
		} else if (l == 0) { return false; }

		var tweens = this._tweens;
		var i = tweens.length;
		while (i--) {
			if (tweens[i] == tween) {
				tweens.splice(i, 1);
				if (tween.duration >= this.duration) { this.updateDuration(); }
				return true;
			}
		}
		return false;
	};

	/**
	 * Adds a label that can be used with {{#crossLink "Timeline/gotoAndPlay"}}{{/crossLink}}/{{#crossLink "Timeline/gotoAndStop"}}{{/crossLink}}.
	 * @method addLabel
	 * @param {String} label The label name.
	 * @param {Number} position The position this label represents.
	 **/
	p.addLabel = function(label, position) {
		this._labels[label] = position;
		var list = this._labelList;
		if (list) {
			for (var i= 0,l=list.length; i<l; i++) { if (position < list[i].position) { break; } }
			list.splice(i, 0, {label:label, position:position});
		}
	};

	/**
	 * Defines labels for use with gotoAndPlay/Stop. Overwrites any previously set labels.
	 * @method setLabels
	 * @param {Object} o An object defining labels for using {{#crossLink "Timeline/gotoAndPlay"}}{{/crossLink}}/{{#crossLink "Timeline/gotoAndStop"}}{{/crossLink}}
	 * in the form `{labelName:time}` where time is in milliseconds (or ticks if `useTicks` is `true`).
	 **/
	p.setLabels = function(o) {
		this._labels = o ?  o : {};
	};

	/**
	 * Returns a sorted list of the labels defined on this timeline.
	 * @method getLabels
	 * @return {Array[Object]} A sorted array of objects with label and position properties.
	 **/
	p.getLabels = function() {
		var list = this._labelList;
		if (!list) {
			list = this._labelList = [];
			var labels = this._labels;
			for (var n in labels) {
				list.push({label:n, position:labels[n]});
			}
			list.sort(function (a,b) { return a.position- b.position; });
		}
		return list;
	};

	/**
	 * Returns the name of the label on or immediately before the current position. For example, given a timeline with
	 * two labels, "first" on frame index 4, and "second" on frame 8, getCurrentLabel would return:
	 * <UL>
	 * 		<LI>null if the current position is 2.</LI>
	 * 		<LI>"first" if the current position is 4.</LI>
	 * 		<LI>"first" if the current position is 7.</LI>
	 * 		<LI>"second" if the current position is 15.</LI>
	 * </UL>
	 * @method getCurrentLabel
	 * @return {String} The name of the current label or null if there is no label
	 **/
	p.getCurrentLabel = function() {
		var labels = this.getLabels();
		var pos = this.position;
		var l = labels.length;
		if (l) {
			for (var i = 0; i<l; i++) { if (pos < labels[i].position) { break; } }
			return (i==0) ? null : labels[i-1].label;
		}
		return null;
	};

	/**
	 * Unpauses this timeline and jumps to the specified position or label.
	 * @method gotoAndPlay
	 * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`)
	 * or label to jump to.
	 **/
	p.gotoAndPlay = function(positionOrLabel) {
		this.setPaused(false);
		this._goto(positionOrLabel);
	};

	/**
	 * Pauses this timeline and jumps to the specified position or label.
	 * @method gotoAndStop
	 * @param {String|Number} positionOrLabel The position in milliseconds (or ticks if `useTicks` is `true`) or label
	 * to jump to.
	 **/
	p.gotoAndStop = function(positionOrLabel) {
		this.setPaused(true);
		this._goto(positionOrLabel);
	};

	/**
	 * Advances the timeline to the specified position.
	 * @method setPosition
	 * @param {Number} value The position to seek to in milliseconds (or ticks if `useTicks` is `true`).
	 * @param {Number} [actionsMode] parameter specifying how actions are handled. See the Tween {{#crossLink "Tween/setPosition"}}{{/crossLink}}
	 * method for more details.
	 * @return {Boolean} Returns `true` if the timeline is complete (ie. the full timeline has run & {{#crossLink "Timeline/loop:property"}}{{/crossLink}}
	 * is `false`).
	 **/
	p.setPosition = function(value, actionsMode) {
		var t = this._calcPosition(value);
		var end = !this.loop && value >= this.duration;
		if (t == this._prevPos) { return end; }
		this._prevPosition = value;
		this.position = this._prevPos = t; // in case an action changes the current frame.
		for (var i=0, l=this._tweens.length; i<l; i++) {
			this._tweens[i].setPosition(t, actionsMode);
			if (t != this._prevPos) { return false; } // an action changed this timeline's position.
		}
		if (end) { this.setPaused(true); }
		this.dispatchEvent("change");
		return end;
	};

	/**
	 * Pauses or plays this timeline.
	 * @method setPaused
	 * @param {Boolean} value Indicates whether the tween should be paused (`true`) or played (`false`).
	 **/
	p.setPaused = function(value) {
		this._paused = !!value; 
		createjs.Tween._register(this, !value);
	};

	/**
	 * Recalculates the duration of the timeline. The duration is automatically updated when tweens are added or removed,
	 * but this method is useful if you modify a tween after it was added to the timeline.
	 * @method updateDuration
	 **/
	p.updateDuration = function() {
		this.duration = 0;
		for (var i=0,l=this._tweens.length; i<l; i++) {
			var tween = this._tweens[i];
			if (tween.duration > this.duration) { this.duration = tween.duration; }
		}
	};

	/**
	 * Advances this timeline by the specified amount of time in milliseconds (or ticks if `useTicks` is `true`).
	 * This is normally called automatically by the Tween engine (via the {{#crossLink "Tween/tick:event"}}{{/crossLink}}
	 * event), but is exposed for advanced uses.
	 * @method tick
	 * @param {Number} delta The time to advance in milliseconds (or ticks if useTicks is true).
	 **/
	p.tick = function(delta) {
		this.setPosition(this._prevPosition+delta);
	};

	/**
	 * If a numeric position is passed, it is returned unchanged. If a string is passed, the position of the
	 * corresponding frame label will be returned, or `null` if a matching label is not defined.
	 * @method resolve
	 * @param {String|Number} positionOrLabel A numeric position value or label string.
	 **/
	p.resolve = function(positionOrLabel) {
		var pos = Number(positionOrLabel);
		if (isNaN(pos)) { pos = this._labels[positionOrLabel]; }
		return pos;
	};

	/**
	* Returns a string representation of this object.
	* @method toString
	* @return {String} a string representation of the instance.
	**/
	p.toString = function() {
		return "[Timeline]";
	};

	/**
	 * @method clone
	 * @protected
	 **/
	p.clone = function() {
		throw("Timeline can not be cloned.")
	};

// private methods:
	/**
	 * @method _goto
	 * @param {String | Number} positionOrLabel
	 * @protected
	 **/
	p._goto = function(positionOrLabel) {
		var pos = this.resolve(positionOrLabel);
		if (pos != null) { this.setPosition(pos); }
	};
	
	/**
	 * @method _calcPosition
	 * @param {Number} value
	 * @return {Number}
	 * @protected
	 **/
	p._calcPosition = function(value) {
		if (value < 0) { return 0; }
		if (value < this.duration) { return value; }
		return this.loop ? value%this.duration : this.duration;
	};

	createjs.Timeline = createjs.promote(Timeline, "EventDispatcher");

}());

//##############################################################################
// Ease.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

	/**
	 * The Ease class provides a collection of easing functions for use with TweenJS. It does not use the standard 4 param
	 * easing signature. Instead it uses a single param which indicates the current linear ratio (0 to 1) of the tween.
	 *
	 * Most methods on Ease can be passed directly as easing functions:
	 *
	 *      Tween.get(target).to({x:100}, 500, Ease.linear);
	 *
	 * However, methods beginning with "get" will return an easing function based on parameter values:
	 *
	 *      Tween.get(target).to({y:200}, 500, Ease.getPowIn(2.2));
	 *
	 * Please see the <a href="http://www.createjs.com/Demos/TweenJS/Tween_SparkTable">spark table demo</a> for an
	 * overview of the different ease types on <a href="http://tweenjs.com">TweenJS.com</a>.
	 *
	 * <em>Equations derived from work by Robert Penner.</em>
	 * @class Ease
	 * @static
	 **/
	function Ease() {
		throw "Ease cannot be instantiated.";
	}


// static methods and properties
	/**
	 * @method linear
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.linear = function(t) { return t; };

	/**
	 * Identical to linear.
	 * @method none
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.none = Ease.linear;

	/**
	 * Mimics the simple -100 to 100 easing in Flash Pro.
	 * @method get
	 * @param {Number} amount A value from -1 (ease in) to 1 (ease out) indicating the strength and direction of the ease.
	 * @static
	 * @return {Function}
	 **/
	Ease.get = function(amount) {
		if (amount < -1) { amount = -1; }
		if (amount > 1) { amount = 1; }
		return function(t) {
			if (amount==0) { return t; }
			if (amount<0) { return t*(t*-amount+1+amount); }
			return t*((2-t)*amount+(1-amount));
		};
	};

	/**
	 * Configurable exponential ease.
	 * @method getPowIn
	 * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
	 * @static
	 * @return {Function}
	 **/
	Ease.getPowIn = function(pow) {
		return function(t) {
			return Math.pow(t,pow);
		};
	};

	/**
	 * Configurable exponential ease.
	 * @method getPowOut
	 * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
	 * @static
	 * @return {Function}
	 **/
	Ease.getPowOut = function(pow) {
		return function(t) {
			return 1-Math.pow(1-t,pow);
		};
	};

	/**
	 * Configurable exponential ease.
	 * @method getPowInOut
	 * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
	 * @static
	 * @return {Function}
	 **/
	Ease.getPowInOut = function(pow) {
		return function(t) {
			if ((t*=2)<1) return 0.5*Math.pow(t,pow);
			return 1-0.5*Math.abs(Math.pow(2-t,pow));
		};
	};

	/**
	 * @method quadIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quadIn = Ease.getPowIn(2);
	/**
	 * @method quadOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quadOut = Ease.getPowOut(2);
	/**
	 * @method quadInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quadInOut = Ease.getPowInOut(2);

	/**
	 * @method cubicIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.cubicIn = Ease.getPowIn(3);
	/**
	 * @method cubicOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.cubicOut = Ease.getPowOut(3);
	/**
	 * @method cubicInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.cubicInOut = Ease.getPowInOut(3);

	/**
	 * @method quartIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quartIn = Ease.getPowIn(4);
	/**
	 * @method quartOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quartOut = Ease.getPowOut(4);
	/**
	 * @method quartInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quartInOut = Ease.getPowInOut(4);

	/**
	 * @method quintIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quintIn = Ease.getPowIn(5);
	/**
	 * @method quintOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quintOut = Ease.getPowOut(5);
	/**
	 * @method quintInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.quintInOut = Ease.getPowInOut(5);

	/**
	 * @method sineIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.sineIn = function(t) {
		return 1-Math.cos(t*Math.PI/2);
	};

	/**
	 * @method sineOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.sineOut = function(t) {
		return Math.sin(t*Math.PI/2);
	};

	/**
	 * @method sineInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.sineInOut = function(t) {
		return -0.5*(Math.cos(Math.PI*t) - 1);
	};

	/**
	 * Configurable "back in" ease.
	 * @method getBackIn
	 * @param {Number} amount The strength of the ease.
	 * @static
	 * @return {Function}
	 **/
	Ease.getBackIn = function(amount) {
		return function(t) {
			return t*t*((amount+1)*t-amount);
		};
	};
	/**
	 * @method backIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.backIn = Ease.getBackIn(1.7);

	/**
	 * Configurable "back out" ease.
	 * @method getBackOut
	 * @param {Number} amount The strength of the ease.
	 * @static
	 * @return {Function}
	 **/
	Ease.getBackOut = function(amount) {
		return function(t) {
			return (--t*t*((amount+1)*t + amount) + 1);
		};
	};
	/**
	 * @method backOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.backOut = Ease.getBackOut(1.7);

	/**
	 * Configurable "back in out" ease.
	 * @method getBackInOut
	 * @param {Number} amount The strength of the ease.
	 * @static
	 * @return {Function}
	 **/
	Ease.getBackInOut = function(amount) {
		amount*=1.525;
		return function(t) {
			if ((t*=2)<1) return 0.5*(t*t*((amount+1)*t-amount));
			return 0.5*((t-=2)*t*((amount+1)*t+amount)+2);
		};
	};
	/**
	 * @method backInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.backInOut = Ease.getBackInOut(1.7);

	/**
	 * @method circIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.circIn = function(t) {
		return -(Math.sqrt(1-t*t)- 1);
	};

	/**
	 * @method circOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.circOut = function(t) {
		return Math.sqrt(1-(--t)*t);
	};

	/**
	 * @method circInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.circInOut = function(t) {
		if ((t*=2) < 1) return -0.5*(Math.sqrt(1-t*t)-1);
		return 0.5*(Math.sqrt(1-(t-=2)*t)+1);
	};

	/**
	 * @method bounceIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.bounceIn = function(t) {
		return 1-Ease.bounceOut(1-t);
	};

	/**
	 * @method bounceOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.bounceOut = function(t) {
		if (t < 1/2.75) {
			return (7.5625*t*t);
		} else if (t < 2/2.75) {
			return (7.5625*(t-=1.5/2.75)*t+0.75);
		} else if (t < 2.5/2.75) {
			return (7.5625*(t-=2.25/2.75)*t+0.9375);
		} else {
			return (7.5625*(t-=2.625/2.75)*t +0.984375);
		}
	};

	/**
	 * @method bounceInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.bounceInOut = function(t) {
		if (t<0.5) return Ease.bounceIn (t*2) * .5;
		return Ease.bounceOut(t*2-1)*0.5+0.5;
	};

	/**
	 * Configurable elastic ease.
	 * @method getElasticIn
	 * @param {Number} amplitude
	 * @param {Number} period
	 * @static
	 * @return {Function}
	 **/
	Ease.getElasticIn = function(amplitude,period) {
		var pi2 = Math.PI*2;
		return function(t) {
			if (t==0 || t==1) return t;
			var s = period/pi2*Math.asin(1/amplitude);
			return -(amplitude*Math.pow(2,10*(t-=1))*Math.sin((t-s)*pi2/period));
		};
	};
	/**
	 * @method elasticIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.elasticIn = Ease.getElasticIn(1,0.3);

	/**
	 * Configurable elastic ease.
	 * @method getElasticOut
	 * @param {Number} amplitude
	 * @param {Number} period
	 * @static
	 * @return {Function}
	 **/
	Ease.getElasticOut = function(amplitude,period) {
		var pi2 = Math.PI*2;
		return function(t) {
			if (t==0 || t==1) return t;
			var s = period/pi2 * Math.asin(1/amplitude);
			return (amplitude*Math.pow(2,-10*t)*Math.sin((t-s)*pi2/period )+1);
		};
	};
	/**
	 * @method elasticOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.elasticOut = Ease.getElasticOut(1,0.3);

	/**
	 * Configurable elastic ease.
	 * @method getElasticInOut
	 * @param {Number} amplitude
	 * @param {Number} period
	 * @static
	 * @return {Function}
	 **/
	Ease.getElasticInOut = function(amplitude,period) {
		var pi2 = Math.PI*2;
		return function(t) {
			var s = period/pi2 * Math.asin(1/amplitude);
			if ((t*=2)<1) return -0.5*(amplitude*Math.pow(2,10*(t-=1))*Math.sin( (t-s)*pi2/period ));
			return amplitude*Math.pow(2,-10*(t-=1))*Math.sin((t-s)*pi2/period)*0.5+1;
		};
	};
	/**
	 * @method elasticInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/
	Ease.elasticInOut = Ease.getElasticInOut(1,0.3*1.5);

	createjs.Ease = Ease;

}());

//##############################################################################
// MotionGuidePlugin.js
//##############################################################################

this.createjs = this.createjs||{};

(function() {
	"use strict";

	/**
	 * A TweenJS plugin for working with motion guides.
	 *
	 * To use, install the plugin after TweenJS has loaded. Next tween the 'guide' property with an object as detailed below.
	 *
	 *       createjs.MotionGuidePlugin.install();
	 *
	 * <h4>Example</h4>
	 *
	 *      // Using a Motion Guide
	 *	    createjs.Tween.get(target).to({guide:{ path:[0,0, 0,200,200,200, 200,0,0,0] }},7000);
	 *	    // Visualizing the line
	 *	    graphics.moveTo(0,0).curveTo(0,200,200,200).curveTo(200,0,0,0);
	 *
	 * Each path needs pre-computation to ensure there's fast performance. Because of the pre-computation there's no
	 * built in support for path changes mid tween. These are the Guide Object's properties:<UL>
	 *      <LI> path: Required, Array : The x/y points used to draw the path with a moveTo and 1 to n curveTo calls.</LI>
	 *      <LI> start: Optional, 0-1 : Initial position, default 0 except for when continuing along the same path.</LI>
	 *      <LI> end: Optional, 0-1 : Final position, default 1 if not specified.</LI>
	 *      <LI> orient: Optional, string : "fixed"/"auto"/"cw"/"ccw"<UL>
	 *				<LI>"fixed" forces the object to face down the path all movement (relative to start rotation),</LI>
	 *      		<LI>"auto" rotates the object along the path relative to the line.</LI>
	 *      		<LI>"cw"/"ccw" force clockwise or counter clockwise rotations including flash like behaviour</LI>
	 * 		</UL></LI>
	 * </UL>
	 * Guide objects should not be shared between tweens even if all properties are identical, the library stores
	 * information on these objects in the background and sharing them can cause unexpected behaviour. Values
	 * outside 0-1 range of tweens will be a "best guess" from the appropriate part of the defined curve.
	 *
	 * @class MotionGuidePlugin
	 * @constructor
	 **/
	function MotionGuidePlugin() {
		throw("MotionGuidePlugin cannot be instantiated.")
	};


// static properties:
	/**
	 * @property priority
	 * @protected
	 * @static
	 **/
	MotionGuidePlugin.priority = 0; // high priority, should run sooner

	/**
	 * @property temporary variable storage
	 * @private
	 * @static
	 */
	MotionGuidePlugin._rotOffS;
	/**
	 * @property temporary variable storage
	 * @private
	 * @static
	 */
	MotionGuidePlugin._rotOffE;
	/**
	 * @property temporary variable storage
	 * @private
	 * @static
	 */
	MotionGuidePlugin._rotNormS;
	/**
	 * @property temporary variable storage
	 * @private
	 * @static
	 */
	MotionGuidePlugin._rotNormE;


// static methods
	/**
	 * Installs this plugin for use with TweenJS. Call this once after TweenJS is loaded to enable this plugin.
	 * @method install
	 * @static
	 **/
	MotionGuidePlugin.install = function() {
		createjs.Tween.installPlugin(MotionGuidePlugin, ["guide", "x", "y", "rotation"]);
		return createjs.Tween.IGNORE;
	};

	/**
	 * @method init
	 * @protected
	 * @static
	 **/
	MotionGuidePlugin.init = function(tween, prop, value) {
		var target = tween.target;
		if(!target.hasOwnProperty("x")){ target.x = 0; }
		if(!target.hasOwnProperty("y")){ target.y = 0; }
		if(!target.hasOwnProperty("rotation")){ target.rotation = 0; }

		if(prop=="rotation"){ tween.__needsRot = true; }
		return prop=="guide"?null:value;
	};

	/**
	 * @method step
	 * @protected
	 * @static
	 **/
	MotionGuidePlugin.step = function(tween, prop, startValue, endValue, injectProps) {
		// other props
		if(prop == "rotation"){
			tween.__rotGlobalS = startValue;
			tween.__rotGlobalE = endValue;
			MotionGuidePlugin.testRotData(tween, injectProps);
		}
		if(prop != "guide"){ return endValue; }

		// guide only information - Start -
		var temp, data = endValue;
		if(!data.hasOwnProperty("path")){ data.path = []; }
		var path = data.path;
		if(!data.hasOwnProperty("end")){ data.end = 1; }
		if(!data.hasOwnProperty("start")){
			data.start = (startValue&&startValue.hasOwnProperty("end")&&startValue.path===path)?startValue.end:0;
		}

		// Figure out subline information
		if(data.hasOwnProperty("_segments") && data._length){ return endValue; }
		var l = path.length;
		var accuracy = 10;		// Adjust to improve line following precision but sacrifice performance (# of seg)
		if(l >= 6 && (l-2) % 4 == 0){	// Enough points && contains correct number per entry ignoring start
			data._segments = [];
			data._length = 0;
			for(var i=2; i<l; i+=4){
				var sx = path[i-2], sy = path[i-1];
				var cx = path[i+0], cy = path[i+1];
				var ex = path[i+2], ey = path[i+3];
				var oldX = sx, oldY = sy;
				var tempX, tempY, total = 0;
				var sublines = [];
				for(var j=1; j<=accuracy; j++){
					var t = j/accuracy;
					var inv = 1 - t;
					tempX = inv*inv * sx + 2 * inv * t * cx + t*t * ex;
					tempY = inv*inv * sy + 2 * inv * t * cy + t*t * ey;
					total += sublines[sublines.push(Math.sqrt((temp=tempX-oldX)*temp + (temp=tempY-oldY)*temp))-1];
					oldX = tempX;
					oldY = tempY;
				}
				data._segments.push(total);
				data._segments.push(sublines);
				data._length += total;
			}
		} else {
			throw("invalid 'path' data, please see documentation for valid paths");
		}

		// Setup x/y tweens
		temp = data.orient;
		data.orient = true;
		var o = {};
		MotionGuidePlugin.calc(data, data.start, o);
		tween.__rotPathS = Number(o.rotation.toFixed(5));
		MotionGuidePlugin.calc(data, data.end, o);
		tween.__rotPathE = Number(o.rotation.toFixed(5));
		data.orient = false;	//here and now we don't know if we need to
		MotionGuidePlugin.calc(data, data.end, injectProps);
		data.orient = temp;

		// Setup rotation properties
		if(!data.orient){ return endValue; }
		tween.__guideData = data;
		MotionGuidePlugin.testRotData(tween, injectProps);
		return endValue;
	};

	/**
	 * @method testRotData
	 * @protected
	 * @static
	 **/
	MotionGuidePlugin.testRotData = function(tween, injectProps){

		// no rotation informat? if we need it come back, if we don't use 0 & ensure we have guide data
		if(tween.__rotGlobalS === undefined || tween.__rotGlobalE === undefined){
			if(tween.__needsRot){ return; }
			if(tween._curQueueProps.rotation !== undefined){
				tween.__rotGlobalS = tween.__rotGlobalE = tween._curQueueProps.rotation;
			} else {
				tween.__rotGlobalS = tween.__rotGlobalE = injectProps.rotation = tween.target.rotation || 0;
			}
		}
		if(tween.__guideData === undefined){ return; }

		// Process rotation properties
		var data = tween.__guideData;
		var rotGlobalD = tween.__rotGlobalE - tween.__rotGlobalS;
		var rotPathD = tween.__rotPathE - tween.__rotPathS;
		var rot = rotGlobalD - rotPathD;

		if(data.orient == "auto"){
			if(rot > 180){			rot -= 360; }
			else if(rot < -180){	rot += 360; }

		} else if(data.orient == "cw"){
			while(rot < 0){ rot += 360; }
			if(rot == 0 && rotGlobalD > 0 && rotGlobalD != 180){ rot += 360; }

		} else if(data.orient == "ccw"){
			rot = rotGlobalD - ((rotPathD > 180)?(360-rotPathD):(rotPathD));	// sign flipping on path
			while(rot > 0){ rot -= 360; }
			if(rot == 0 && rotGlobalD < 0 && rotGlobalD != -180){ rot -= 360; }
		}

		data.rotDelta = rot;
		data.rotOffS = tween.__rotGlobalS - tween.__rotPathS;

		// reset
		tween.__rotGlobalS = tween.__rotGlobalE = tween.__guideData = tween.__needsRot = undefined;
	};

	/**
	 * @method tween
	 * @protected
	 * @static
	 **/
	MotionGuidePlugin.tween = function(tween, prop, value, startValues, endValues, ratio, wait, end) {
		var data = endValues.guide;
		if(data == undefined || data === startValues.guide){ return value; }
		if(data.lastRatio != ratio){
			// first time through so calculate what I need to
			var t = ((data.end-data.start)*(wait?data.end:ratio)+data.start);
			MotionGuidePlugin.calc(data, t, tween.target);
			switch(data.orient){
				case "cw":		// mix in the original rotation
				case "ccw":
				case "auto": tween.target.rotation += data.rotOffS + data.rotDelta*ratio; break;
				case "fixed":	// follow fixed behaviour to solve potential issues
				default: tween.target.rotation += data.rotOffS; break;
			}
			data.lastRatio = ratio;
		}
		if(prop == "rotation" && ((!data.orient) || data.orient == "false")){ return value; }
		return tween.target[prop];
	};

	/**
	 * Determine the appropriate x/y/rotation information about a path for a given ratio along the path.
	 * Assumes a path object with all optional parameters specified.
	 * @param data Data object you would pass to the "guide:" property in a Tween
	 * @param ratio 0-1 Distance along path, values outside 0-1 are "best guess"
	 * @param target Object to copy the results onto, will use a new object if not supplied.
	 * @return {Object} The target object or a new object w/ the tweened properties
	 * @static
	 */
	MotionGuidePlugin.calc = function(data, ratio, target) {
		if(data._segments == undefined){ MotionGuidePlugin.validate(data); }
		if(target == undefined){ target = {x:0, y:0, rotation:0}; }
		var seg = data._segments;
		var path = data.path;

		// find segment
		var pos = data._length * ratio;
		var cap = seg.length - 2;
		var n = 0;
		while(pos > seg[n] && n < cap){
			pos -= seg[n];
			n+=2;
		}

		// find subline
		var sublines = seg[n+1];
		var i = 0;
		cap = sublines.length-1;
		while(pos > sublines[i] && i < cap){
			pos -= sublines[i];
			i++;
		}
		var t = (i/++cap)+(pos/(cap*sublines[i]));

		// find x/y
		n = (n*2)+2;
		var inv = 1 - t;
		target.x = inv*inv * path[n-2] + 2 * inv * t * path[n+0] + t*t * path[n+2];
		target.y = inv*inv * path[n-1] + 2 * inv * t * path[n+1] + t*t * path[n+3];

		// orientation
		if(data.orient){
			target.rotation = 57.2957795 * Math.atan2(
				(path[n+1]-path[n-1])*inv + (path[n+3]-path[n+1])*t,
				(path[n+0]-path[n-2])*inv + (path[n+2]-path[n+0])*t);
		}

		return target;
	};

	createjs.MotionGuidePlugin = MotionGuidePlugin;

}());

//##############################################################################
// version.js
//##############################################################################

this.createjs = this.createjs || {};

(function() {
	"use strict";

	/**
	 * Static class holding library specific information such as the version and buildDate of
	 * the library.
	 * @class TweenJS
	 **/
	var s = createjs.TweenJS = createjs.TweenJS || {};

	/**
	 * The version string for this release.
	 * @property version
	 * @type String
	 * @static
	 **/
	s.version = /*=version*/"0.6.1"; // injected by build process

	/**
	 * The build date for this release in UTC format.
	 * @property buildDate
	 * @type String
	 * @static
	 **/
	s.buildDate = /*=date*/"Thu, 21 May 2015 16:17:37 GMT"; // injected by build process

})();
if(typeof module !== "undefined" && typeof module.exports !== "undefined") module.exports = this.createjs;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
'use strict'

// TODO: resize or reposition shapes based on media size

module.exports = function(canvasWidth, canvasHeight) {

	var createjs = require('createjs-collection');

	var stage = new createjs.Stage("gameCanvas");

	var squareOne = new createjs.Shape(),
		squareTwo = new createjs.Shape(),
		squareThree = new createjs.Shape(),
		squareFour = new createjs.Shape();

	// the dimensions of the squares
	var squareWidth = canvasWidth * 0.4,
		squareHeight = canvasHeight * 0.4,
		centerWidth = canvasWidth / 2,
		centerHeight = canvasHeight / 2;

	// starting position (square one) and offsets (all other squares)
	var xOffset = centerWidth - squareWidth - 5,
		yOffset = centerHeight - squareHeight - 5;

	// spacing between squares
	var spacing = 10;

	// rectangle params - x, y, width, height
	squareOne.graphics.beginFill("red").drawRect(xOffset, yOffset, squareWidth, squareHeight);
	stage.addChild(squareOne);

	squareTwo.graphics.beginFill("green").drawRect(0, yOffset, squareWidth, squareHeight);
	squareTwo.x = xOffset + squareWidth + spacing; // square 2 positioning
	stage.addChild(squareTwo);

	squareThree.graphics.beginFill("blue").drawRect(xOffset, 0, squareWidth, squareHeight);
	squareThree.y = yOffset + squareHeight + spacing; // square 3 positioning
	stage.addChild(squareThree);

	squareFour.graphics.beginFill("yellow").drawRect(0, 0, squareWidth, squareHeight);
	squareFour.x = xOffset + squareWidth + spacing; // square 4 positioning
	squareFour.y = yOffset + squareHeight + spacing; // square 4 positioning
	stage.addChild(squareFour);
	

	/* 
		-Changing x moves the shape horizonatally
		-Changing y moves the shape vertically
		-Changing alpha will fade the shape in and out
	*/

	/*
		createjs.Tween.get(circle, { loop: true })
			.to({ x: 400 }, 1000, createjs.Ease.getPowInOut(4))
			.to({ alpha: 0, y: 175 }, 500, createjs.Ease.getPowInOut(2))
			.to({ alpha: 0, y: 225 }, 100)
			.to({ alpha: 1, y: 200 }, 500, createjs.Ease.getPowInOut(2))
			.to({ x: 100 }, 800, createjs.Ease.getPowInOut(2));

		createjs.Ticker.setFPS(60);
		createjs.Ticker.addEventListener("tick", stage);
	*/

	stage.update(); // can't be used when using tween
			
};
},{"createjs-collection":1}],3:[function(require,module,exports){
(function() {

	'use strict'

	var resize = require('./resizeCanvas');

	resize();

	var randomInt = require('./randomIntFromInterval');

	var randomSquare = randomInt(1, 4);

})();
},{"./randomIntFromInterval":4,"./resizeCanvas":5}],4:[function(require,module,exports){
'use strict'

module.exports = function (min, max) {

	return Math.floor(Math.random() * (max-min+1) + min);

}
},{}],5:[function(require,module,exports){
'use strict'

module.exports = function () {

	var draw = require('./draw')

	var canvas = document.getElementById('gameCanvas'),
		gameSection = document.getElementById('gameSection');

	window.addEventListener('resize', resizeCanvas, false);

	function resizeCanvas() {

		var width = gameSection.offsetWidth,
			height = gameSection.offsetHeight;

		if (width > height) {
			canvas.width = height;
			canvas.height = height;
		} else {
			canvas.width = width;
			canvas.height = width;
		}

		draw(canvas.width, canvas.height);

	}

	resizeCanvas();

};
},{"./draw":2}]},{},[3])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvY3JlYXRlanMtY29sbGVjdGlvbi9jcmVhdGVqcy5qcyIsInB1YmxpYy9qcy9kcmF3LmpzIiwicHVibGljL2pzL21haW4uanMiLCJwdWJsaWMvanMvcmFuZG9tSW50RnJvbUludGVydmFsLmpzIiwicHVibGljL2pzL3Jlc2l6ZUNhbnZhcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BydEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIgY3JlYXRlanMgPSAodGhpcy5jcmVhdGVqcyA9ICh0aGlzLmNyZWF0ZWpzIHx8IHt9KSk7XG4vKiFcbiogRWFzZWxKU1xuKiBWaXNpdCBodHRwOi8vY3JlYXRlanMuY29tLyBmb3IgZG9jdW1lbnRhdGlvbiwgdXBkYXRlcyBhbmQgZXhhbXBsZXMuXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMCBnc2tpbm5lci5jb20sIGluYy5cbipcbiogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4qIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiogY29uZGl0aW9uczpcbipcbiogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4qXG4qIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4qIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4qIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cblxuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gZXh0ZW5kLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbi8qKlxuICogU2V0cyB1cCB0aGUgcHJvdG90eXBlIGNoYWluIGFuZCBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBmb3IgYSBuZXcgY2xhc3MuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIHJpZ2h0IGFmdGVyIGNyZWF0aW5nIHRoZSBjbGFzcyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBcdGZ1bmN0aW9uIE15U3ViQ2xhc3MoKSB7fVxuICogXHRjcmVhdGVqcy5leHRlbmQoTXlTdWJDbGFzcywgTXlTdXBlckNsYXNzKTtcbiAqIFx0Q2xhc3NCLnByb3RvdHlwZS5kb1NvbWV0aGluZyA9IGZ1bmN0aW9uKCkgeyB9XG4gKlxuICogXHR2YXIgZm9vID0gbmV3IE15U3ViQ2xhc3MoKTtcbiAqIFx0Y29uc29sZS5sb2coZm9vIGluc3RhbmNlb2YgTXlTdXBlckNsYXNzKTsgLy8gdHJ1ZVxuICogXHRjb25zb2xlLmxvZyhmb28ucHJvdG90eXBlLmNvbnN0cnVjdG9yID09PSBNeVN1YkNsYXNzKTsgLy8gdHJ1ZVxuICpcbiAqIEBtZXRob2QgZXh0ZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJjbGFzcyBUaGUgc3ViY2xhc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdXBlcmNsYXNzIFRoZSBzdXBlcmNsYXNzIHRvIGV4dGVuZC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBzdWJjbGFzcydzIG5ldyBwcm90b3R5cGUuXG4gKi9cbmNyZWF0ZWpzLmV4dGVuZCA9IGZ1bmN0aW9uKHN1YmNsYXNzLCBzdXBlcmNsYXNzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGZ1bmN0aW9uIG8oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBzdWJjbGFzczsgfVxuXHRvLnByb3RvdHlwZSA9IHN1cGVyY2xhc3MucHJvdG90eXBlO1xuXHRyZXR1cm4gKHN1YmNsYXNzLnByb3RvdHlwZSA9IG5ldyBvKCkpO1xufTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIHByb21vdGUuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuLyoqXG4gKiBAY2xhc3MgVXRpbGl0eSBNZXRob2RzXG4gKi9cblxuLyoqXG4gKiBQcm9tb3RlcyBhbnkgbWV0aG9kcyBvbiB0aGUgc3VwZXIgY2xhc3MgdGhhdCB3ZXJlIG92ZXJyaWRkZW4sIGJ5IGNyZWF0aW5nIGFuIGFsaWFzIGluIHRoZSBmb3JtYXQgYHByZWZpeF9tZXRob2ROYW1lYC5cbiAqIEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGUgc3VwZXIgY2xhc3MncyBuYW1lIGFzIHRoZSBwcmVmaXguXG4gKiBBbiBhbGlhcyB0byB0aGUgc3VwZXIgY2xhc3MncyBjb25zdHJ1Y3RvciBpcyBhbHdheXMgYWRkZWQgaW4gdGhlIGZvcm1hdCBgcHJlZml4X2NvbnN0cnVjdG9yYC5cbiAqIFRoaXMgYWxsb3dzIHRoZSBzdWJjbGFzcyB0byBjYWxsIHN1cGVyIGNsYXNzIG1ldGhvZHMgd2l0aG91dCB1c2luZyBgZnVuY3Rpb24uY2FsbGAsIHByb3ZpZGluZyBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIGBNeVN1YkNsYXNzYCBleHRlbmRzIGBNeVN1cGVyQ2xhc3NgLCBhbmQgYm90aCBkZWZpbmUgYSBgZHJhd2AgbWV0aG9kLCB0aGVuIGNhbGxpbmcgYHByb21vdGUoTXlTdWJDbGFzcywgXCJNeVN1cGVyQ2xhc3NcIilgXG4gKiB3b3VsZCBhZGQgYSBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYCBtZXRob2QgdG8gTXlTdWJDbGFzcyBhbmQgcHJvbW90ZSB0aGUgYGRyYXdgIG1ldGhvZCBvbiBgTXlTdXBlckNsYXNzYCB0byB0aGVcbiAqIHByb3RvdHlwZSBvZiBgTXlTdWJDbGFzc2AgYXMgYE15U3VwZXJDbGFzc19kcmF3YC5cbiAqXG4gKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGNsYXNzJ3MgcHJvdG90eXBlIGlzIGZ1bGx5IGRlZmluZWQuXG4gKlxuICogXHRmdW5jdGlvbiBDbGFzc0EobmFtZSkge1xuICogXHRcdHRoaXMubmFtZSA9IG5hbWU7XG4gKiBcdH1cbiAqIFx0Q2xhc3NBLnByb3RvdHlwZS5ncmVldCA9IGZ1bmN0aW9uKCkge1xuICogXHRcdHJldHVybiBcIkhlbGxvIFwiK3RoaXMubmFtZTtcbiAqIFx0fVxuICpcbiAqIFx0ZnVuY3Rpb24gQ2xhc3NCKG5hbWUsIHB1bmN0dWF0aW9uKSB7XG4gKiBcdFx0dGhpcy5DbGFzc0FfY29uc3RydWN0b3IobmFtZSk7XG4gKiBcdFx0dGhpcy5wdW5jdHVhdGlvbiA9IHB1bmN0dWF0aW9uO1xuICogXHR9XG4gKiBcdGNyZWF0ZWpzLmV4dGVuZChDbGFzc0IsIENsYXNzQSk7XG4gKiBcdENsYXNzQi5wcm90b3R5cGUuZ3JlZXQgPSBmdW5jdGlvbigpIHtcbiAqIFx0XHRyZXR1cm4gdGhpcy5DbGFzc0FfZ3JlZXQoKSt0aGlzLnB1bmN0dWF0aW9uO1xuICogXHR9XG4gKiBcdGNyZWF0ZWpzLnByb21vdGUoQ2xhc3NCLCBcIkNsYXNzQVwiKTtcbiAqXG4gKiBcdHZhciBmb28gPSBuZXcgQ2xhc3NCKFwiV29ybGRcIiwgXCIhPyFcIik7XG4gKiBcdGNvbnNvbGUubG9nKGZvby5ncmVldCgpKTsgLy8gSGVsbG8gV29ybGQhPyFcbiAqXG4gKiBAbWV0aG9kIHByb21vdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YmNsYXNzIFRoZSBjbGFzcyB0byBwcm9tb3RlIHN1cGVyIGNsYXNzIG1ldGhvZHMgb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IFRoZSBwcmVmaXggdG8gYWRkIHRvIHRoZSBwcm9tb3RlZCBtZXRob2QgbmFtZXMuIFVzdWFsbHkgdGhlIG5hbWUgb2YgdGhlIHN1cGVyY2xhc3MuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgc3ViY2xhc3MuXG4gKi9cbmNyZWF0ZWpzLnByb21vdGUgPSBmdW5jdGlvbihzdWJjbGFzcywgcHJlZml4KSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciBzdWJQID0gc3ViY2xhc3MucHJvdG90eXBlLCBzdXBQID0gKE9iamVjdC5nZXRQcm90b3R5cGVPZiYmT2JqZWN0LmdldFByb3RvdHlwZU9mKHN1YlApKXx8c3ViUC5fX3Byb3RvX187XG5cdGlmIChzdXBQKSB7XG5cdFx0c3ViUFsocHJlZml4Kz1cIl9cIikgKyBcImNvbnN0cnVjdG9yXCJdID0gc3VwUC5jb25zdHJ1Y3RvcjsgLy8gY29uc3RydWN0b3IgaXMgbm90IGFsd2F5cyBpbm51bWVyYWJsZVxuXHRcdGZvciAodmFyIG4gaW4gc3VwUCkge1xuXHRcdFx0aWYgKHN1YlAuaGFzT3duUHJvcGVydHkobikgJiYgKHR5cGVvZiBzdXBQW25dID09IFwiZnVuY3Rpb25cIikpIHsgc3ViUFtwcmVmaXggKyBuXSA9IHN1cFBbbl07IH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHN1YmNsYXNzO1xufTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIGluZGV4T2YuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuLyoqXG4gKiBAY2xhc3MgVXRpbGl0eSBNZXRob2RzXG4gKi9cblxuLyoqXG4gKiBGaW5kcyB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhIHNwZWNpZmllZCB2YWx1ZSBzZWFyY2hFbGVtZW50IGluIHRoZSBwYXNzZWQgaW4gYXJyYXksIGFuZCByZXR1cm5zIHRoZSBpbmRleCBvZlxuICogdGhhdCB2YWx1ZS4gIFJldHVybnMgLTEgaWYgdmFsdWUgaXMgbm90IGZvdW5kLlxuICpcbiAqICAgICAgdmFyIGkgPSBjcmVhdGVqcy5pbmRleE9mKG15QXJyYXksIG15RWxlbWVudFRvRmluZCk7XG4gKlxuICogQG1ldGhvZCBpbmRleE9mXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBBcnJheSB0byBzZWFyY2ggZm9yIHNlYXJjaEVsZW1lbnRcbiAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gZmluZCBpbiBhcnJheS5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIGZpcnN0IGluZGV4IG9mIHNlYXJjaEVsZW1lbnQgaW4gYXJyYXkuXG4gKi9cbmNyZWF0ZWpzLmluZGV4T2YgPSBmdW5jdGlvbiAoYXJyYXksIHNlYXJjaEVsZW1lbnQpe1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRmb3IgKHZhciBpID0gMCxsPWFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGlmIChzZWFyY2hFbGVtZW50ID09PSBhcnJheVtpXSkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBFdmVudC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIENvbnRhaW5zIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgc2hhcmVkIGJ5IGFsbCBldmVudHMgZm9yIHVzZSB3aXRoXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogXG5cdCAqIE5vdGUgdGhhdCBFdmVudCBvYmplY3RzIGFyZSBvZnRlbiByZXVzZWQsIHNvIHlvdSBzaG91bGQgbmV2ZXJcblx0ICogcmVseSBvbiBhbiBldmVudCBvYmplY3QncyBzdGF0ZSBvdXRzaWRlIG9mIHRoZSBjYWxsIHN0YWNrIGl0IHdhcyByZWNlaXZlZCBpbi5cblx0ICogQGNsYXNzIEV2ZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGJ1YmJsZXMgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IHdpbGwgYnViYmxlIHRocm91Z2ggdGhlIGRpc3BsYXkgbGlzdC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBjYW5jZWxhYmxlIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiB0aGlzIGV2ZW50IGNhbiBiZSBjYW5jZWxsZWQuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIEV2ZW50KHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUpIHtcblx0XHRcblx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSB0eXBlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICoqL1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBvYmplY3QgdGhhdCBnZW5lcmF0ZWQgYW4gZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IHRhcmdldFxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMudGFyZ2V0ID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgdGFyZ2V0IHRoYXQgYSBidWJibGluZyBldmVudCBpcyBiZWluZyBkaXNwYXRjaGVkIGZyb20uIEZvciBub24tYnViYmxpbmcgZXZlbnRzLCB0aGlzIHdpbGxcblx0XHQgKiBhbHdheXMgYmUgdGhlIHNhbWUgYXMgdGFyZ2V0LiBGb3IgZXhhbXBsZSwgaWYgY2hpbGRPYmoucGFyZW50ID0gcGFyZW50T2JqLCBhbmQgYSBidWJibGluZyBldmVudFxuXHRcdCAqIGlzIGdlbmVyYXRlZCBmcm9tIGNoaWxkT2JqLCB0aGVuIGEgbGlzdGVuZXIgb24gcGFyZW50T2JqIHdvdWxkIHJlY2VpdmUgdGhlIGV2ZW50IHdpdGhcblx0XHQgKiB0YXJnZXQ9Y2hpbGRPYmogKHRoZSBvcmlnaW5hbCB0YXJnZXQpIGFuZCBjdXJyZW50VGFyZ2V0PXBhcmVudE9iaiAod2hlcmUgdGhlIGxpc3RlbmVyIHdhcyBhZGRlZCkuXG5cdFx0ICogQHByb3BlcnR5IGN1cnJlbnRUYXJnZXRcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBGb3IgYnViYmxpbmcgZXZlbnRzLCB0aGlzIGluZGljYXRlcyB0aGUgY3VycmVudCBldmVudCBwaGFzZTo8T0w+XG5cdFx0ICogXHQ8TEk+IGNhcHR1cmUgcGhhc2U6IHN0YXJ0aW5nIGZyb20gdGhlIHRvcCBwYXJlbnQgdG8gdGhlIHRhcmdldDwvTEk+XG5cdFx0ICogXHQ8TEk+IGF0IHRhcmdldCBwaGFzZTogY3VycmVudGx5IGJlaW5nIGRpc3BhdGNoZWQgZnJvbSB0aGUgdGFyZ2V0PC9MST5cblx0XHQgKiBcdDxMST4gYnViYmxpbmcgcGhhc2U6IGZyb20gdGhlIHRhcmdldCB0byB0aGUgdG9wIHBhcmVudDwvTEk+XG5cdFx0ICogPC9PTD5cblx0XHQgKiBAcHJvcGVydHkgZXZlbnRQaGFzZVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuZXZlbnRQaGFzZSA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBldmVudCB3aWxsIGJ1YmJsZSB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuXG5cdFx0ICogQHByb3BlcnR5IGJ1YmJsZXNcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuYnViYmxlcyA9ICEhYnViYmxlcztcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mIHRoaXMgZXZlbnQgY2FuIGJlIGNhbmNlbGxlZCB2aWFcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudC9wcmV2ZW50RGVmYXVsdFwifX17ey9jcm9zc0xpbmt9fS4gVGhpcyBpcyBzZXQgdmlhIHRoZSBFdmVudCBjb25zdHJ1Y3Rvci5cblx0XHQgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5jYW5jZWxhYmxlID0gISFjYW5jZWxhYmxlO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgZXBvY2ggdGltZSBhdCB3aGljaCB0aGlzIGV2ZW50IHdhcyBjcmVhdGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSB0aW1lU3RhbXBcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLnRpbWVTdGFtcCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9wcmV2ZW50RGVmYXVsdFwifX17ey9jcm9zc0xpbmt9fSBoYXMgYmVlbiBjYWxsZWRcblx0XHQgKiBvbiB0aGlzIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBkZWZhdWx0UHJldmVudGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHt7I2Nyb3NzTGluayBcIkV2ZW50L3N0b3BQcm9wYWdhdGlvblwifX17ey9jcm9zc0xpbmt9fSBvclxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50L3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwifX17ey9jcm9zc0xpbmt9fSBoYXMgYmVlbiBjYWxsZWQgb24gdGhpcyBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgcHJvcGFnYXRpb25TdG9wcGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYge3sjY3Jvc3NMaW5rIFwiRXZlbnQvc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXCJ9fXt7L2Nyb3NzTGlua319IGhhcyBiZWVuIGNhbGxlZFxuXHRcdCAqIG9uIHRoaXMgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IGltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcmVtb3ZlXCJ9fXt7L2Nyb3NzTGlua319IGhhcyBiZWVuIGNhbGxlZCBvbiB0aGlzIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSByZW1vdmVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLnJlbW92ZWQgPSBmYWxzZTtcblx0fVxuXHR2YXIgcCA9IEV2ZW50LnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogU2V0cyB7eyNjcm9zc0xpbmsgXCJFdmVudC9kZWZhdWx0UHJldmVudGVkXCJ9fXt7L2Nyb3NzTGlua319IHRvIHRydWUgaWYgdGhlIGV2ZW50IGlzIGNhbmNlbGFibGUuXG5cdCAqIE1pcnJvcnMgdGhlIERPTSBsZXZlbCAyIGV2ZW50IHN0YW5kYXJkLiBJbiBnZW5lcmFsLCBjYW5jZWxhYmxlIGV2ZW50cyB0aGF0IGhhdmUgYHByZXZlbnREZWZhdWx0KClgIGNhbGxlZCB3aWxsXG5cdCAqIGNhbmNlbCB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudC5cblx0ICogQG1ldGhvZCBwcmV2ZW50RGVmYXVsdFxuXHQgKiovXG5cdHAucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0aGlzLmNhbmNlbGFibGUmJnRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcHJvcGFnYXRpb25TdG9wcGVkXCJ9fXt7L2Nyb3NzTGlua319IHRvIHRydWUuXG5cdCAqIE1pcnJvcnMgdGhlIERPTSBldmVudCBzdGFuZGFyZC5cblx0ICogQG1ldGhvZCBzdG9wUHJvcGFnYXRpb25cblx0ICoqL1xuXHRwLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB7eyNjcm9zc0xpbmsgXCJFdmVudC9wcm9wYWdhdGlvblN0b3BwZWRcIn19e3svY3Jvc3NMaW5rfX0gYW5kXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50L2ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZFwifX17ey9jcm9zc0xpbmt9fSB0byB0cnVlLlxuXHQgKiBNaXJyb3JzIHRoZSBET00gZXZlbnQgc3RhbmRhcmQuXG5cdCAqIEBtZXRob2Qgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXG5cdCAqKi9cblx0cC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBDYXVzZXMgdGhlIGFjdGl2ZSBsaXN0ZW5lciB0byBiZSByZW1vdmVkIHZpYSByZW1vdmVFdmVudExpc3RlbmVyKCk7XG5cdCAqIFxuXHQgKiBcdFx0bXlCdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2dCkge1xuXHQgKiBcdFx0XHQvLyBkbyBzdHVmZi4uLlxuXHQgKiBcdFx0XHRldnQucmVtb3ZlKCk7IC8vIHJlbW92ZXMgdGhpcyBsaXN0ZW5lci5cblx0ICogXHRcdH0pO1xuXHQgKiBcblx0ICogQG1ldGhvZCByZW1vdmVcblx0ICoqL1xuXHRwLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVtb3ZlZCA9IHRydWU7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBFdmVudCBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtFdmVudH0gYSBjbG9uZSBvZiB0aGUgRXZlbnQgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgRXZlbnQodGhpcy50eXBlLCB0aGlzLmJ1YmJsZXMsIHRoaXMuY2FuY2VsYWJsZSk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUHJvdmlkZXMgYSBjaGFpbmFibGUgc2hvcnRjdXQgbWV0aG9kIGZvciBzZXR0aW5nIGEgbnVtYmVyIG9mIHByb3BlcnRpZXMgb24gdGhlIGluc3RhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHNldFxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQSBnZW5lcmljIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gY29weSB0byB0aGUgaW5zdGFuY2UuXG5cdCAqIEByZXR1cm4ge0V2ZW50fSBSZXR1cm5zIHRoZSBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5zZXQgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdGZvciAodmFyIG4gaW4gcHJvcHMpIHsgdGhpc1tuXSA9IHByb3BzW25dOyB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltFdmVudCAodHlwZT1cIit0aGlzLnR5cGUrXCIpXVwiO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkV2ZW50ID0gRXZlbnQ7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRXZlbnREaXNwYXRjaGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuLy8gY29uc3RydWN0b3I6XHJcblx0LyoqXHJcblx0ICogRXZlbnREaXNwYXRjaGVyIHByb3ZpZGVzIG1ldGhvZHMgZm9yIG1hbmFnaW5nIHF1ZXVlcyBvZiBldmVudCBsaXN0ZW5lcnMgYW5kIGRpc3BhdGNoaW5nIGV2ZW50cy5cclxuXHQgKlxyXG5cdCAqIFlvdSBjYW4gZWl0aGVyIGV4dGVuZCBFdmVudERpc3BhdGNoZXIgb3IgbWl4IGl0cyBtZXRob2RzIGludG8gYW4gZXhpc3RpbmcgcHJvdG90eXBlIG9yIGluc3RhbmNlIGJ5IHVzaW5nIHRoZVxyXG5cdCAqIEV2ZW50RGlzcGF0Y2hlciB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvaW5pdGlhbGl6ZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXHJcblx0ICogXHJcblx0ICogVG9nZXRoZXIgd2l0aCB0aGUgQ3JlYXRlSlMgRXZlbnQgY2xhc3MsIEV2ZW50RGlzcGF0Y2hlciBwcm92aWRlcyBhbiBleHRlbmRlZCBldmVudCBtb2RlbCB0aGF0IGlzIGJhc2VkIG9uIHRoZVxyXG5cdCAqIERPTSBMZXZlbCAyIGV2ZW50IG1vZGVsLCBpbmNsdWRpbmcgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciwgYW5kIGRpc3BhdGNoRXZlbnQuIEl0IHN1cHBvcnRzXHJcblx0ICogYnViYmxpbmcgLyBjYXB0dXJlLCBwcmV2ZW50RGVmYXVsdCwgc3RvcFByb3BhZ2F0aW9uLCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24sIGFuZCBoYW5kbGVFdmVudC5cclxuXHQgKiBcclxuXHQgKiBFdmVudERpc3BhdGNoZXIgYWxzbyBleHBvc2VzIGEge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL29uXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCwgd2hpY2ggbWFrZXMgaXQgZWFzaWVyXHJcblx0ICogdG8gY3JlYXRlIHNjb3BlZCBsaXN0ZW5lcnMsIGxpc3RlbmVycyB0aGF0IG9ubHkgcnVuIG9uY2UsIGFuZCBsaXN0ZW5lcnMgd2l0aCBhc3NvY2lhdGVkIGFyYml0cmFyeSBkYXRhLiBUaGUgXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL29mZlwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgaXMgbWVyZWx5IGFuIGFsaWFzIHRvXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL3JlbW92ZUV2ZW50TGlzdGVuZXJcIn19e3svY3Jvc3NMaW5rfX0uXHJcblx0ICogXHJcblx0ICogQW5vdGhlciBhZGRpdGlvbiB0byB0aGUgRE9NIExldmVsIDIgbW9kZWwgaXMgdGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9yZW1vdmVBbGxFdmVudExpc3RlbmVyc1wifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIG1ldGhvZCwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbGlzdGVuZXJzIGZvciBhbGwgZXZlbnRzLCBvciBsaXN0ZW5lcnMgZm9yIGEgc3BlY2lmaWMgZXZlbnQuIFRoZSBFdmVudCBvYmplY3QgYWxzbyBcclxuXHQgKiBpbmNsdWRlcyBhIHt7I2Nyb3NzTGluayBcIkV2ZW50L3JlbW92ZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2Qgd2hpY2ggcmVtb3ZlcyB0aGUgYWN0aXZlIGxpc3RlbmVyLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqIEFkZCBFdmVudERpc3BhdGNoZXIgY2FwYWJpbGl0aWVzIHRvIHRoZSBcIk15Q2xhc3NcIiBjbGFzcy5cclxuXHQgKlxyXG5cdCAqICAgICAgRXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUoTXlDbGFzcy5wcm90b3R5cGUpO1xyXG5cdCAqXHJcblx0ICogQWRkIGFuIGV2ZW50IChzZWUge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL2FkZEV2ZW50TGlzdGVuZXJcIn19e3svY3Jvc3NMaW5rfX0pLlxyXG5cdCAqXHJcblx0ICogICAgICBpbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKFwiZXZlbnROYW1lXCIsIGhhbmRsZXJNZXRob2QpO1xyXG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlck1ldGhvZChldmVudCkge1xyXG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LnRhcmdldCArIFwiIFdhcyBDbGlja2VkXCIpO1xyXG5cdCAqICAgICAgfVxyXG5cdCAqXHJcblx0ICogPGI+TWFpbnRhaW5pbmcgcHJvcGVyIHNjb3BlPC9iPjxiciAvPlxyXG5cdCAqIFNjb3BlIChpZS4gXCJ0aGlzXCIpIGNhbiBiZSBiZSBhIGNoYWxsZW5nZSB3aXRoIGV2ZW50cy4gVXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9vblwifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIG1ldGhvZCB0byBzdWJzY3JpYmUgdG8gZXZlbnRzIHNpbXBsaWZpZXMgdGhpcy5cclxuXHQgKlxyXG5cdCAqICAgICAgaW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0ICogICAgICAgICAgY29uc29sZS5sb2coaW5zdGFuY2UgPT0gdGhpcyk7IC8vIGZhbHNlLCBzY29wZSBpcyBhbWJpZ3VvdXMuXHJcblx0ICogICAgICB9KTtcclxuXHQgKiAgICAgIFxyXG5cdCAqICAgICAgaW5zdGFuY2Uub24oXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCkge1xyXG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKGluc3RhbmNlID09IHRoaXMpOyAvLyB0cnVlLCBcIm9uXCIgdXNlcyBkaXNwYXRjaGVyIHNjb3BlIGJ5IGRlZmF1bHQuXHJcblx0ICogICAgICB9KTtcclxuXHQgKiBcclxuXHQgKiBJZiB5b3Ugd2FudCB0byB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpbnN0ZWFkLCB5b3UgbWF5IHdhbnQgdG8gdXNlIGZ1bmN0aW9uLmJpbmQoKSBvciBhIHNpbWlsYXIgcHJveHkgdG8gbWFuYWdlIHNjb3BlLlxyXG5cdCAqICAgICAgXHJcblx0ICpcclxuXHQgKiBAY2xhc3MgRXZlbnREaXNwYXRjaGVyXHJcblx0ICogQGNvbnN0cnVjdG9yXHJcblx0ICoqL1xyXG5cdGZ1bmN0aW9uIEV2ZW50RGlzcGF0Y2hlcigpIHtcclxuXHRcclxuXHRcclxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XHJcblx0XHQvKipcclxuXHRcdCAqIEBwcm90ZWN0ZWRcclxuXHRcdCAqIEBwcm9wZXJ0eSBfbGlzdGVuZXJzXHJcblx0XHQgKiBAdHlwZSBPYmplY3RcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuX2xpc3RlbmVycyA9IG51bGw7XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogQHByb3RlY3RlZFxyXG5cdFx0ICogQHByb3BlcnR5IF9jYXB0dXJlTGlzdGVuZXJzXHJcblx0XHQgKiBAdHlwZSBPYmplY3RcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgPSBudWxsO1xyXG5cdH1cclxuXHR2YXIgcCA9IEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGU7XHJcblxyXG5cdC8qKlxyXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cclxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cclxuXHQgKiBmb3IgZGV0YWlscy5cclxuXHQgKlxyXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqIEBkZXByZWNhdGVkXHJcblx0ICovXHJcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXHJcblxyXG5cclxuLy8gc3RhdGljIHB1YmxpYyBtZXRob2RzOlxyXG5cdC8qKlxyXG5cdCAqIFN0YXRpYyBpbml0aWFsaXplciB0byBtaXggRXZlbnREaXNwYXRjaGVyIG1ldGhvZHMgaW50byBhIHRhcmdldCBvYmplY3Qgb3IgcHJvdG90eXBlLlxyXG5cdCAqIFxyXG5cdCAqIFx0XHRFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShNeUNsYXNzLnByb3RvdHlwZSk7IC8vIGFkZCB0byB0aGUgcHJvdG90eXBlIG9mIHRoZSBjbGFzc1xyXG5cdCAqIFx0XHRFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShteU9iamVjdCk7IC8vIGFkZCB0byBhIHNwZWNpZmljIGluc3RhbmNlXHJcblx0ICogXHJcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXHJcblx0ICogQHN0YXRpY1xyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3QgdG8gaW5qZWN0IEV2ZW50RGlzcGF0Y2hlciBtZXRob2RzIGludG8uIFRoaXMgY2FuIGJlIGFuIGluc3RhbmNlIG9yIGFcclxuXHQgKiBwcm90b3R5cGUuXHJcblx0ICoqL1xyXG5cdEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplID0gZnVuY3Rpb24odGFyZ2V0KSB7XHJcblx0XHR0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lciA9IHAuYWRkRXZlbnRMaXN0ZW5lcjtcclxuXHRcdHRhcmdldC5vbiA9IHAub247XHJcblx0XHR0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHRhcmdldC5vZmYgPSAgcC5yZW1vdmVFdmVudExpc3RlbmVyO1xyXG5cdFx0dGFyZ2V0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gcC5yZW1vdmVBbGxFdmVudExpc3RlbmVycztcclxuXHRcdHRhcmdldC5oYXNFdmVudExpc3RlbmVyID0gcC5oYXNFdmVudExpc3RlbmVyO1xyXG5cdFx0dGFyZ2V0LmRpc3BhdGNoRXZlbnQgPSBwLmRpc3BhdGNoRXZlbnQ7XHJcblx0XHR0YXJnZXQuX2Rpc3BhdGNoRXZlbnQgPSBwLl9kaXNwYXRjaEV2ZW50O1xyXG5cdFx0dGFyZ2V0LndpbGxUcmlnZ2VyID0gcC53aWxsVHJpZ2dlcjtcclxuXHR9O1xyXG5cdFxyXG5cclxuLy8gcHVibGljIG1ldGhvZHM6XHJcblx0LyoqXHJcblx0ICogQWRkcyB0aGUgc3BlY2lmaWVkIGV2ZW50IGxpc3RlbmVyLiBOb3RlIHRoYXQgYWRkaW5nIG11bHRpcGxlIGxpc3RlbmVycyB0byB0aGUgc2FtZSBmdW5jdGlvbiB3aWxsIHJlc3VsdCBpblxyXG5cdCAqIG11bHRpcGxlIGNhbGxiYWNrcyBnZXR0aW5nIGZpcmVkLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljayk7XHJcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xyXG5cdCAqICAgICAgICAgLy8gQ2xpY2sgaGFwcGVuZWQuXHJcblx0ICogICAgICB9XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXJcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb24gfCBPYmplY3R9IGxpc3RlbmVyIEFuIG9iamVjdCB3aXRoIGEgaGFuZGxlRXZlbnQgbWV0aG9kLCBvciBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlblxyXG5cdCAqIHRoZSBldmVudCBpcyBkaXNwYXRjaGVkLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdIEZvciBldmVudHMgdGhhdCBidWJibGUsIGluZGljYXRlcyB3aGV0aGVyIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50IGluIHRoZSBjYXB0dXJlIG9yIGJ1YmJsaW5nL3RhcmdldCBwaGFzZS5cclxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbiB8IE9iamVjdH0gUmV0dXJucyB0aGUgbGlzdGVuZXIgZm9yIGNoYWluaW5nIG9yIGFzc2lnbm1lbnQuXHJcblx0ICoqL1xyXG5cdHAuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzO1xyXG5cdFx0aWYgKHVzZUNhcHR1cmUpIHtcclxuXHRcdFx0bGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnN8fHt9O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzfHx7fTtcclxuXHRcdH1cclxuXHRcdHZhciBhcnIgPSBsaXN0ZW5lcnNbdHlwZV07XHJcblx0XHRpZiAoYXJyKSB7IHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7IH1cclxuXHRcdGFyciA9IGxpc3RlbmVyc1t0eXBlXTsgLy8gcmVtb3ZlIG1heSBoYXZlIGRlbGV0ZWQgdGhlIGFycmF5XHJcblx0XHRpZiAoIWFycikgeyBsaXN0ZW5lcnNbdHlwZV0gPSBbbGlzdGVuZXJdOyAgfVxyXG5cdFx0ZWxzZSB7IGFyci5wdXNoKGxpc3RlbmVyKTsgfVxyXG5cdFx0cmV0dXJuIGxpc3RlbmVyO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogQSBzaG9ydGN1dCBtZXRob2QgZm9yIHVzaW5nIGFkZEV2ZW50TGlzdGVuZXIgdGhhdCBtYWtlcyBpdCBlYXNpZXIgdG8gc3BlY2lmeSBhbiBleGVjdXRpb24gc2NvcGUsIGhhdmUgYSBsaXN0ZW5lclxyXG5cdCAqIG9ubHkgcnVuIG9uY2UsIGFzc29jaWF0ZSBhcmJpdHJhcnkgZGF0YSB3aXRoIHRoZSBsaXN0ZW5lciwgYW5kIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcblx0ICogXHJcblx0ICogVGhpcyBtZXRob2Qgd29ya3MgYnkgY3JlYXRpbmcgYW4gYW5vbnltb3VzIHdyYXBwZXIgZnVuY3Rpb24gYW5kIHN1YnNjcmliaW5nIGl0IHdpdGggYWRkRXZlbnRMaXN0ZW5lci5cclxuXHQgKiBUaGUgd3JhcHBlciBmdW5jdGlvbiBpcyByZXR1cm5lZCBmb3IgdXNlIHdpdGggYHJlbW92ZUV2ZW50TGlzdGVuZXJgIChvciBgb2ZmYCkuXHJcblx0ICogXHJcblx0ICogPGI+SU1QT1JUQU5UOjwvYj4gVG8gcmVtb3ZlIGEgbGlzdGVuZXIgYWRkZWQgd2l0aCBgb25gLCB5b3UgbXVzdCBwYXNzIGluIHRoZSByZXR1cm5lZCB3cmFwcGVyIGZ1bmN0aW9uIGFzIHRoZSBsaXN0ZW5lciwgb3IgdXNlXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcmVtb3ZlXCJ9fXt7L2Nyb3NzTGlua319LiBMaWtld2lzZSwgZWFjaCB0aW1lIHlvdSBjYWxsIGBvbmAgYSBORVcgd3JhcHBlciBmdW5jdGlvbiBpcyBzdWJzY3JpYmVkLCBzbyBtdWx0aXBsZSBjYWxsc1xyXG5cdCAqIHRvIGBvbmAgd2l0aCB0aGUgc2FtZSBwYXJhbXMgd2lsbCBjcmVhdGUgbXVsdGlwbGUgbGlzdGVuZXJzLlxyXG5cdCAqIFxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKiBcclxuXHQgKiBcdFx0dmFyIGxpc3RlbmVyID0gbXlCdG4ub24oXCJjbGlja1wiLCBoYW5kbGVDbGljaywgbnVsbCwgZmFsc2UsIHtjb3VudDozfSk7XHJcblx0ICogXHRcdGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2dCwgZGF0YSkge1xyXG5cdCAqIFx0XHRcdGRhdGEuY291bnQgLT0gMTtcclxuXHQgKiBcdFx0XHRjb25zb2xlLmxvZyh0aGlzID09IG15QnRuKTsgLy8gdHJ1ZSAtIHNjb3BlIGRlZmF1bHRzIHRvIHRoZSBkaXNwYXRjaGVyXHJcblx0ICogXHRcdFx0aWYgKGRhdGEuY291bnQgPT0gMCkge1xyXG5cdCAqIFx0XHRcdFx0YWxlcnQoXCJjbGlja2VkIDMgdGltZXMhXCIpO1xyXG5cdCAqIFx0XHRcdFx0bXlCdG4ub2ZmKFwiY2xpY2tcIiwgbGlzdGVuZXIpO1xyXG5cdCAqIFx0XHRcdFx0Ly8gYWx0ZXJuYXRlbHk6IGV2dC5yZW1vdmUoKTtcclxuXHQgKiBcdFx0XHR9XHJcblx0ICogXHRcdH1cclxuXHQgKiBcclxuXHQgKiBAbWV0aG9kIG9uXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBBbiBvYmplY3Qgd2l0aCBhIGhhbmRsZUV2ZW50IG1ldGhvZCwgb3IgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5cclxuXHQgKiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSBUaGUgc2NvcGUgdG8gZXhlY3V0ZSB0aGUgbGlzdGVuZXIgaW4uIERlZmF1bHRzIHRvIHRoZSBkaXNwYXRjaGVyL2N1cnJlbnRUYXJnZXQgZm9yIGZ1bmN0aW9uIGxpc3RlbmVycywgYW5kIHRvIHRoZSBsaXN0ZW5lciBpdHNlbGYgZm9yIG9iamVjdCBsaXN0ZW5lcnMgKGllLiB1c2luZyBoYW5kbGVFdmVudCkuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gSWYgdHJ1ZSwgdGhlIGxpc3RlbmVyIHdpbGwgcmVtb3ZlIGl0c2VsZiBhZnRlciB0aGUgZmlyc3QgdGltZSBpdCBpcyB0cmlnZ2VyZWQuXHJcblx0ICogQHBhcmFtIHsqfSBbZGF0YV0gQXJiaXRyYXJ5IGRhdGEgdGhhdCB3aWxsIGJlIGluY2x1ZGVkIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHdoZW4gdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlPWZhbHNlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXHJcblx0ICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgdGhlIGFub255bW91cyBmdW5jdGlvbiB0aGF0IHdhcyBjcmVhdGVkIGFuZCBhc3NpZ25lZCBhcyB0aGUgbGlzdGVuZXIuIFRoaXMgaXMgbmVlZGVkIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIgbGF0ZXIgdXNpbmcgLnJlbW92ZUV2ZW50TGlzdGVuZXIuXHJcblx0ICoqL1xyXG5cdHAub24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgc2NvcGUsIG9uY2UsIGRhdGEsIHVzZUNhcHR1cmUpIHtcclxuXHRcdGlmIChsaXN0ZW5lci5oYW5kbGVFdmVudCkge1xyXG5cdFx0XHRzY29wZSA9IHNjb3BlfHxsaXN0ZW5lcjtcclxuXHRcdFx0bGlzdGVuZXIgPSBsaXN0ZW5lci5oYW5kbGVFdmVudDtcclxuXHRcdH1cclxuXHRcdHNjb3BlID0gc2NvcGV8fHRoaXM7XHJcblx0XHRyZXR1cm4gdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmN0aW9uKGV2dCkge1xyXG5cdFx0XHRcdGxpc3RlbmVyLmNhbGwoc2NvcGUsIGV2dCwgZGF0YSk7XHJcblx0XHRcdFx0b25jZSYmZXZ0LnJlbW92ZSgpO1xyXG5cdFx0XHR9LCB1c2VDYXB0dXJlKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgZXZlbnQgbGlzdGVuZXIuXHJcblx0ICpcclxuXHQgKiA8Yj5JbXBvcnRhbnQgTm90ZTo8L2I+IHRoYXQgeW91IG11c3QgcGFzcyB0aGUgZXhhY3QgZnVuY3Rpb24gcmVmZXJlbmNlIHVzZWQgd2hlbiB0aGUgZXZlbnQgd2FzIGFkZGVkLiBJZiBhIHByb3h5XHJcblx0ICogZnVuY3Rpb24sIG9yIGZ1bmN0aW9uIGNsb3N1cmUgaXMgdXNlZCBhcyB0aGUgY2FsbGJhY2ssIHRoZSBwcm94eS9jbG9zdXJlIHJlZmVyZW5jZSBtdXN0IGJlIHVzZWQgLSBhIG5ldyBwcm94eSBvclxyXG5cdCAqIGNsb3N1cmUgd2lsbCBub3Qgd29yay5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gb3Igb2JqZWN0LlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdIEZvciBldmVudHMgdGhhdCBidWJibGUsIGluZGljYXRlcyB3aGV0aGVyIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50IGluIHRoZSBjYXB0dXJlIG9yIGJ1YmJsaW5nL3RhcmdldCBwaGFzZS5cclxuXHQgKiovXHJcblx0cC5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB1c2VDYXB0dXJlID8gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA6IHRoaXMuX2xpc3RlbmVycztcclxuXHRcdGlmICghbGlzdGVuZXJzKSB7IHJldHVybjsgfVxyXG5cdFx0dmFyIGFyciA9IGxpc3RlbmVyc1t0eXBlXTtcclxuXHRcdGlmICghYXJyKSB7IHJldHVybjsgfVxyXG5cdFx0Zm9yICh2YXIgaT0wLGw9YXJyLmxlbmd0aDsgaTxsOyBpKyspIHtcclxuXHRcdFx0aWYgKGFycltpXSA9PSBsaXN0ZW5lcikge1xyXG5cdFx0XHRcdGlmIChsPT0xKSB7IGRlbGV0ZShsaXN0ZW5lcnNbdHlwZV0pOyB9IC8vIGFsbG93cyBmb3IgZmFzdGVyIGNoZWNrcy5cclxuXHRcdFx0XHRlbHNlIHsgYXJyLnNwbGljZShpLDEpOyB9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEEgc2hvcnRjdXQgdG8gdGhlIHJlbW92ZUV2ZW50TGlzdGVuZXIgbWV0aG9kLCB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMgYW5kIHJldHVybiB2YWx1ZS4gVGhpcyBpcyBhIGNvbXBhbmlvbiB0byB0aGVcclxuXHQgKiAub24gbWV0aG9kLlxyXG5cdCAqIFxyXG5cdCAqIDxiPklNUE9SVEFOVDo8L2I+IFRvIHJlbW92ZSBhIGxpc3RlbmVyIGFkZGVkIHdpdGggYG9uYCwgeW91IG11c3QgcGFzcyBpbiB0aGUgcmV0dXJuZWQgd3JhcHBlciBmdW5jdGlvbiBhcyB0aGUgbGlzdGVuZXIuIFNlZSBcclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvb25cIn19e3svY3Jvc3NMaW5rfX0gZm9yIGFuIGV4YW1wbGUuXHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIG9mZlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbiB8IE9iamVjdH0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIG9yIG9iamVjdC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXHJcblx0ICoqL1xyXG5cdHAub2ZmID0gcC5yZW1vdmVFdmVudExpc3RlbmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgdHlwZSwgb3IgYWxsIGxpc3RlbmVycyBvZiBhbGwgdHlwZXMuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzXHJcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XHJcblx0ICpcclxuXHQgKiAgICAgIC8vIFJlbW92ZSBhbGwgY2xpY2sgbGlzdGVuZXJzXHJcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKFwiY2xpY2tcIik7XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LiBJZiBvbWl0dGVkLCBhbGwgbGlzdGVuZXJzIGZvciBhbGwgdHlwZXMgd2lsbCBiZSByZW1vdmVkLlxyXG5cdCAqKi9cclxuXHRwLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0aWYgKCF0eXBlKSB7IHRoaXMuX2xpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgPSBudWxsOyB9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0aWYgKHRoaXMuX2xpc3RlbmVycykgeyBkZWxldGUodGhpcy5fbGlzdGVuZXJzW3R5cGVdKTsgfVxyXG5cdFx0XHRpZiAodGhpcy5fY2FwdHVyZUxpc3RlbmVycykgeyBkZWxldGUodGhpcy5fY2FwdHVyZUxpc3RlbmVyc1t0eXBlXSk7IH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBEaXNwYXRjaGVzIHRoZSBzcGVjaWZpZWQgZXZlbnQgdG8gYWxsIGxpc3RlbmVycy5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgLy8gVXNlIGEgc3RyaW5nIGV2ZW50XHJcblx0ICogICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKTtcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gVXNlIGFuIEV2ZW50IGluc3RhbmNlXHJcblx0ICogICAgICB2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJwcm9ncmVzc1wiKTtcclxuXHQgKiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGRpc3BhdGNoRXZlbnRcclxuXHQgKiBAcGFyYW0ge09iamVjdCB8IFN0cmluZyB8IEV2ZW50fSBldmVudE9iaiBBbiBvYmplY3Qgd2l0aCBhIFwidHlwZVwiIHByb3BlcnR5LCBvciBhIHN0cmluZyB0eXBlLlxyXG5cdCAqIFdoaWxlIGEgZ2VuZXJpYyBvYmplY3Qgd2lsbCB3b3JrLCBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYSBDcmVhdGVKUyBFdmVudCBpbnN0YW5jZS4gSWYgYSBzdHJpbmcgaXMgdXNlZCxcclxuXHQgKiBkaXNwYXRjaEV2ZW50IHdpbGwgY29uc3RydWN0IGFuIEV2ZW50IGluc3RhbmNlIGlmIG5lY2Vzc2FyeSB3aXRoIHRoZSBzcGVjaWZpZWQgdHlwZS4gVGhpcyBsYXR0ZXIgYXBwcm9hY2ggY2FuXHJcblx0ICogYmUgdXNlZCB0byBhdm9pZCBldmVudCBvYmplY3QgaW5zdGFudGlhdGlvbiBmb3Igbm9uLWJ1YmJsaW5nIGV2ZW50cyB0aGF0IG1heSBub3QgaGF2ZSBhbnkgbGlzdGVuZXJzLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXNdIFNwZWNpZmllcyB0aGUgYGJ1YmJsZXNgIHZhbHVlIHdoZW4gYSBzdHJpbmcgd2FzIHBhc3NlZCB0byBldmVudE9iai5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtjYW5jZWxhYmxlXSBTcGVjaWZpZXMgdGhlIGBjYW5jZWxhYmxlYCB2YWx1ZSB3aGVuIGEgc3RyaW5nIHdhcyBwYXNzZWQgdG8gZXZlbnRPYmouXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBmYWxzZSBpZiBgcHJldmVudERlZmF1bHQoKWAgd2FzIGNhbGxlZCBvbiBhIGNhbmNlbGFibGUgZXZlbnQsIHRydWUgb3RoZXJ3aXNlLlxyXG5cdCAqKi9cclxuXHRwLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudE9iaiwgYnViYmxlcywgY2FuY2VsYWJsZSkge1xyXG5cdFx0aWYgKHR5cGVvZiBldmVudE9iaiA9PSBcInN0cmluZ1wiKSB7XHJcblx0XHRcdC8vIHNraXAgZXZlcnl0aGluZyBpZiB0aGVyZSdzIG5vIGxpc3RlbmVycyBhbmQgaXQgZG9lc24ndCBidWJibGU6XHJcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcblx0XHRcdGlmICghYnViYmxlcyAmJiAoIWxpc3RlbmVycyB8fCAhbGlzdGVuZXJzW2V2ZW50T2JqXSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0ZXZlbnRPYmogPSBuZXcgY3JlYXRlanMuRXZlbnQoZXZlbnRPYmosIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xyXG5cdFx0fSBlbHNlIGlmIChldmVudE9iai50YXJnZXQgJiYgZXZlbnRPYmouY2xvbmUpIHtcclxuXHRcdFx0Ly8gcmVkaXNwYXRjaGluZyBhbiBhY3RpdmUgZXZlbnQgb2JqZWN0LCBzbyBjbG9uZSBpdDpcclxuXHRcdFx0ZXZlbnRPYmogPSBldmVudE9iai5jbG9uZSgpO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHQvLyBUT0RPOiBpdCB3b3VsZCBiZSBuaWNlIHRvIGVsaW1pbmF0ZSB0aGlzLiBNYXliZSBpbiBmYXZvdXIgb2YgZXZ0T2JqIGluc3RhbmNlb2YgRXZlbnQ/IE9yICEhZXZ0T2JqLmNyZWF0ZUV2ZW50XHJcblx0XHR0cnkgeyBldmVudE9iai50YXJnZXQgPSB0aGlzOyB9IGNhdGNoIChlKSB7fSAvLyB0cnkvY2F0Y2ggYWxsb3dzIHJlZGlzcGF0Y2hpbmcgb2YgbmF0aXZlIGV2ZW50c1xyXG5cclxuXHRcdGlmICghZXZlbnRPYmouYnViYmxlcyB8fCAhdGhpcy5wYXJlbnQpIHtcclxuXHRcdFx0dGhpcy5fZGlzcGF0Y2hFdmVudChldmVudE9iaiwgMik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgdG9wPXRoaXMsIGxpc3Q9W3RvcF07XHJcblx0XHRcdHdoaWxlICh0b3AucGFyZW50KSB7IGxpc3QucHVzaCh0b3AgPSB0b3AucGFyZW50KTsgfVxyXG5cdFx0XHR2YXIgaSwgbD1saXN0Lmxlbmd0aDtcclxuXHJcblx0XHRcdC8vIGNhcHR1cmUgJiBhdFRhcmdldFxyXG5cdFx0XHRmb3IgKGk9bC0xOyBpPj0wICYmICFldmVudE9iai5wcm9wYWdhdGlvblN0b3BwZWQ7IGktLSkge1xyXG5cdFx0XHRcdGxpc3RbaV0uX2Rpc3BhdGNoRXZlbnQoZXZlbnRPYmosIDErKGk9PTApKTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBidWJibGluZ1xyXG5cdFx0XHRmb3IgKGk9MTsgaTxsICYmICFldmVudE9iai5wcm9wYWdhdGlvblN0b3BwZWQ7IGkrKykge1xyXG5cdFx0XHRcdGxpc3RbaV0uX2Rpc3BhdGNoRXZlbnQoZXZlbnRPYmosIDMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gIWV2ZW50T2JqLmRlZmF1bHRQcmV2ZW50ZWQ7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXHJcblx0ICogQG1ldGhvZCBoYXNFdmVudExpc3RlbmVyXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxyXG5cdCAqKi9cclxuXHRwLmhhc0V2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLCBjYXB0dXJlTGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVycztcclxuXHRcdHJldHVybiAhISgobGlzdGVuZXJzICYmIGxpc3RlbmVyc1t0eXBlXSkgfHwgKGNhcHR1cmVMaXN0ZW5lcnMgJiYgY2FwdHVyZUxpc3RlbmVyc1t0eXBlXSkpO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUgb24gdGhpcyBvYmplY3Qgb3IgYW55IG9mIGl0c1xyXG5cdCAqIGFuY2VzdG9ycyAocGFyZW50LCBwYXJlbnQncyBwYXJlbnQsIGV0YykuIEEgcmV0dXJuIHZhbHVlIG9mIHRydWUgaW5kaWNhdGVzIHRoYXQgaWYgYSBidWJibGluZyBldmVudCBvZiB0aGVcclxuXHQgKiBzcGVjaWZpZWQgdHlwZSBpcyBkaXNwYXRjaGVkIGZyb20gdGhpcyBvYmplY3QsIGl0IHdpbGwgdHJpZ2dlciBhdCBsZWFzdCBvbmUgbGlzdGVuZXIuXHJcblx0ICogXHJcblx0ICogVGhpcyBpcyBzaW1pbGFyIHRvIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9oYXNFdmVudExpc3RlbmVyXCJ9fXt7L2Nyb3NzTGlua319LCBidXQgaXQgc2VhcmNoZXMgdGhlIGVudGlyZVxyXG5cdCAqIGV2ZW50IGZsb3cgZm9yIGEgbGlzdGVuZXIsIG5vdCBqdXN0IHRoaXMgb2JqZWN0LlxyXG5cdCAqIEBtZXRob2Qgd2lsbFRyaWdnZXJcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cclxuXHQgKiovXHJcblx0cC53aWxsVHJpZ2dlciA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdHZhciBvID0gdGhpcztcclxuXHRcdHdoaWxlIChvKSB7XHJcblx0XHRcdGlmIChvLmhhc0V2ZW50TGlzdGVuZXIodHlwZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0byA9IG8ucGFyZW50O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cclxuXHQgKiovXHJcblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIFwiW0V2ZW50RGlzcGF0Y2hlcl1cIjtcclxuXHR9O1xyXG5cclxuXHJcbi8vIHByaXZhdGUgbWV0aG9kczpcclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIF9kaXNwYXRjaEV2ZW50XHJcblx0ICogQHBhcmFtIHtPYmplY3QgfCBTdHJpbmcgfCBFdmVudH0gZXZlbnRPYmpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRQaGFzZVxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiovXHJcblx0cC5fZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50T2JqLCBldmVudFBoYXNlKSB7XHJcblx0XHR2YXIgbCwgbGlzdGVuZXJzID0gKGV2ZW50UGhhc2U9PTEpID8gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA6IHRoaXMuX2xpc3RlbmVycztcclxuXHRcdGlmIChldmVudE9iaiAmJiBsaXN0ZW5lcnMpIHtcclxuXHRcdFx0dmFyIGFyciA9IGxpc3RlbmVyc1tldmVudE9iai50eXBlXTtcclxuXHRcdFx0aWYgKCFhcnJ8fCEobD1hcnIubGVuZ3RoKSkgeyByZXR1cm47IH1cclxuXHRcdFx0dHJ5IHsgZXZlbnRPYmouY3VycmVudFRhcmdldCA9IHRoaXM7IH0gY2F0Y2ggKGUpIHt9XHJcblx0XHRcdHRyeSB7IGV2ZW50T2JqLmV2ZW50UGhhc2UgPSBldmVudFBoYXNlOyB9IGNhdGNoIChlKSB7fVxyXG5cdFx0XHRldmVudE9iai5yZW1vdmVkID0gZmFsc2U7XHJcblx0XHRcdFxyXG5cdFx0XHRhcnIgPSBhcnIuc2xpY2UoKTsgLy8gdG8gYXZvaWQgaXNzdWVzIHdpdGggaXRlbXMgYmVpbmcgcmVtb3ZlZCBvciBhZGRlZCBkdXJpbmcgdGhlIGRpc3BhdGNoXHJcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsICYmICFldmVudE9iai5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ7IGkrKykge1xyXG5cdFx0XHRcdHZhciBvID0gYXJyW2ldO1xyXG5cdFx0XHRcdGlmIChvLmhhbmRsZUV2ZW50KSB7IG8uaGFuZGxlRXZlbnQoZXZlbnRPYmopOyB9XHJcblx0XHRcdFx0ZWxzZSB7IG8oZXZlbnRPYmopOyB9XHJcblx0XHRcdFx0aWYgKGV2ZW50T2JqLnJlbW92ZWQpIHtcclxuXHRcdFx0XHRcdHRoaXMub2ZmKGV2ZW50T2JqLnR5cGUsIG8sIGV2ZW50UGhhc2U9PTEpO1xyXG5cdFx0XHRcdFx0ZXZlbnRPYmoucmVtb3ZlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cclxuXHRjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIgPSBFdmVudERpc3BhdGNoZXI7XHJcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUaWNrZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFRoZSBUaWNrZXIgcHJvdmlkZXMgYSBjZW50cmFsaXplZCB0aWNrIG9yIGhlYXJ0YmVhdCBicm9hZGNhc3QgYXQgYSBzZXQgaW50ZXJ2YWwuIExpc3RlbmVycyBjYW4gc3Vic2NyaWJlIHRvIHRoZSB0aWNrXG5cdCAqIGV2ZW50IHRvIGJlIG5vdGlmaWVkIHdoZW4gYSBzZXQgdGltZSBpbnRlcnZhbCBoYXMgZWxhcHNlZC5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoZSBpbnRlcnZhbCB0aGF0IHRoZSB0aWNrIGV2ZW50IGlzIGNhbGxlZCBpcyBhIHRhcmdldCBpbnRlcnZhbCwgYW5kIG1heSBiZSBicm9hZGNhc3QgYXQgYSBzbG93ZXIgaW50ZXJ2YWxcblx0ICogd2hlbiB1bmRlciBoaWdoIENQVSBsb2FkLiBUaGUgVGlja2VyIGNsYXNzIHVzZXMgYSBzdGF0aWMgaW50ZXJmYWNlIChleC4gYFRpY2tlci5mcmFtZXJhdGUgPSAzMDtgKSBhbmRcblx0ICogY2FuIG5vdCBiZSBpbnN0YW50aWF0ZWQuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgaGFuZGxlVGljayk7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlVGljayhldmVudCkge1xuXHQgKiAgICAgICAgICAvLyBBY3Rpb25zIGNhcnJpZWQgb3V0IGVhY2ggdGljayAoYWthIGZyYW1lKVxuXHQgKiAgICAgICAgICBpZiAoIWV2ZW50LnBhdXNlZCkge1xuXHQgKiAgICAgICAgICAgICAgLy8gQWN0aW9ucyBjYXJyaWVkIG91dCB3aGVuIHRoZSBUaWNrZXIgaXMgbm90IHBhdXNlZC5cblx0ICogICAgICAgICAgfVxuXHQgKiAgICAgIH1cblx0ICpcblx0ICogQGNsYXNzIFRpY2tlclxuXHQgKiBAdXNlcyBFdmVudERpc3BhdGNoZXJcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdGZ1bmN0aW9uIFRpY2tlcigpIHtcblx0XHR0aHJvdyBcIlRpY2tlciBjYW5ub3QgYmUgaW5zdGFudGlhdGVkLlwiO1xuXHR9XG5cblxuLy8gY29uc3RhbnRzOlxuXHQvKipcblx0ICogSW4gdGhpcyBtb2RlLCBUaWNrZXIgdXNlcyB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIEFQSSwgYnV0IGF0dGVtcHRzIHRvIHN5bmNoIHRoZSB0aWNrcyB0byB0YXJnZXQgZnJhbWVyYXRlLiBJdFxuXHQgKiB1c2VzIGEgc2ltcGxlIGhldXJpc3RpYyB0aGF0IGNvbXBhcmVzIHRoZSB0aW1lIG9mIHRoZSBSQUYgcmV0dXJuIHRvIHRoZSB0YXJnZXQgdGltZSBmb3IgdGhlIGN1cnJlbnQgZnJhbWUgYW5kXG5cdCAqIGRpc3BhdGNoZXMgdGhlIHRpY2sgd2hlbiB0aGUgdGltZSBpcyB3aXRoaW4gYSBjZXJ0YWluIHRocmVzaG9sZC5cblx0ICpcblx0ICogVGhpcyBtb2RlIGhhcyBhIGhpZ2hlciB2YXJpYW5jZSBmb3IgdGltZSBiZXR3ZWVuIGZyYW1lcyB0aGFuIHt7I2Nyb3NzTGluayBcIlRpY2tlci9USU1FT1VUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBidXQgZG9lcyBub3QgcmVxdWlyZSB0aGF0IGNvbnRlbnQgYmUgdGltZSBiYXNlZCBhcyB3aXRoIHt7I2Nyb3NzTGluayBcIlRpY2tlci9SQUY6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gd2hpbGVcblx0ICogZ2FpbmluZyB0aGUgYmVuZWZpdHMgb2YgdGhhdCBBUEkgKHNjcmVlbiBzeW5jaCwgYmFja2dyb3VuZCB0aHJvdHRsaW5nKS5cblx0ICpcblx0ICogVmFyaWFuY2UgaXMgdXN1YWxseSBsb3dlc3QgZm9yIGZyYW1lcmF0ZXMgdGhhdCBhcmUgYSBkaXZpc29yIG9mIHRoZSBSQUYgZnJlcXVlbmN5LiBUaGlzIGlzIHVzdWFsbHkgNjAsIHNvXG5cdCAqIGZyYW1lcmF0ZXMgb2YgMTAsIDEyLCAxNSwgMjAsIGFuZCAzMCB3b3JrIHdlbGwuXG5cdCAqXG5cdCAqIEZhbGxzIGJhY2sgdG8ge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1RJTUVPVVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaWYgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBBUEkgaXMgbm90XG5cdCAqIHN1cHBvcnRlZC5cblx0ICogQHByb3BlcnR5IFJBRl9TWU5DSEVEXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgXCJzeW5jaGVkXCJcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0VGlja2VyLlJBRl9TWU5DSEVEID0gXCJzeW5jaGVkXCI7XG5cblx0LyoqXG5cdCAqIEluIHRoaXMgbW9kZSwgVGlja2VyIHBhc3NlcyB0aHJvdWdoIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgaGVhcnRiZWF0LCBpZ25vcmluZyB0aGUgdGFyZ2V0IGZyYW1lcmF0ZSBjb21wbGV0ZWx5LlxuXHQgKiBCZWNhdXNlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmcmVxdWVuY3kgaXMgbm90IGRldGVybWluaXN0aWMsIGFueSBjb250ZW50IHVzaW5nIHRoaXMgbW9kZSBzaG91bGQgYmUgdGltZSBiYXNlZC5cblx0ICogWW91IGNhbiBsZXZlcmFnZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvZ2V0VGltZVwifX17ey9jcm9zc0xpbmt9fSBhbmQgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aWNrOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IG9iamVjdCdzIFwiZGVsdGFcIiBwcm9wZXJ0aWVzIHRvIG1ha2UgdGhpcyBlYXNpZXIuXG5cdCAqXG5cdCAqIEZhbGxzIGJhY2sgb24ge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1RJTUVPVVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaWYgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBBUEkgaXMgbm90XG5cdCAqIHN1cHBvcnRlZC5cblx0ICogQHByb3BlcnR5IFJBRlxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IFwicmFmXCJcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0VGlja2VyLlJBRiA9IFwicmFmXCI7XG5cblx0LyoqXG5cdCAqIEluIHRoaXMgbW9kZSwgVGlja2VyIHVzZXMgdGhlIHNldFRpbWVvdXQgQVBJLiBUaGlzIHByb3ZpZGVzIHByZWRpY3RhYmxlLCBhZGFwdGl2ZSBmcmFtZSB0aW1pbmcsIGJ1dCBkb2VzIG5vdFxuXHQgKiBwcm92aWRlIHRoZSBiZW5lZml0cyBvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKHNjcmVlbiBzeW5jaCwgYmFja2dyb3VuZCB0aHJvdHRsaW5nKS5cblx0ICogQHByb3BlcnR5IFRJTUVPVVRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBcInRpbWVvdXRcIlxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRUaWNrZXIuVElNRU9VVCA9IFwidGltZW91dFwiO1xuXG5cbi8vIHN0YXRpYyBldmVudHM6XG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIGVhY2ggdGljay4gVGhlIGV2ZW50IHdpbGwgYmUgZGlzcGF0Y2hlZCB0byBlYWNoIGxpc3RlbmVyIGV2ZW4gd2hlbiB0aGUgVGlja2VyIGhhcyBiZWVuIHBhdXNlZCB1c2luZ1xuXHQgKiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvc2V0UGF1c2VkXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIGhhbmRsZVRpY2spO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZVRpY2soZXZlbnQpIHtcblx0ICogICAgICAgICAgY29uc29sZS5sb2coXCJQYXVzZWQ6XCIsIGV2ZW50LnBhdXNlZCwgZXZlbnQuZGVsdGEpO1xuXHQgKiAgICAgIH1cblx0ICpcblx0ICogQGV2ZW50IHRpY2tcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHBhdXNlZCBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGlja2VyIGlzIGN1cnJlbnRseSBwYXVzZWQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YSBUaGUgdGltZSBlbGFwc2VkIGluIG1zIHNpbmNlIHRoZSBsYXN0IHRpY2suXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRoZSB0b3RhbCB0aW1lIGluIG1zIHNpbmNlIFRpY2tlciB3YXMgaW5pdGlhbGl6ZWQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBydW5UaW1lIFRoZSB0b3RhbCB0aW1lIGluIG1zIHRoYXQgVGlja2VyIHdhcyBub3QgcGF1c2VkIHNpbmNlIGl0IHdhcyBpbml0aWFsaXplZC4gRm9yIGV4YW1wbGUsXG5cdCAqIFx0eW91IGNvdWxkIGRldGVybWluZSB0aGUgYW1vdW50IG9mIHRpbWUgdGhhdCB0aGUgVGlja2VyIGhhcyBiZWVuIHBhdXNlZCBzaW5jZSBpbml0aWFsaXphdGlvbiB3aXRoIGB0aW1lLXJ1blRpbWVgLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblxuLy8gcHVibGljIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogRGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Yge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3RpbWluZ01vZGVcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gSWYgdHJ1ZSwgdGltaW5nTW9kZSB3aWxsXG5cdCAqIHVzZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvUkFGX1NZTkNIRURcIn19e3svY3Jvc3NMaW5rfX0gYnkgZGVmYXVsdC5cblx0ICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Yge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3RpbWluZ01vZGVcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBwcm9wZXJ0eSB1c2VSQUZcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICoqL1xuXHRUaWNrZXIudXNlUkFGID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIFNwZWNpZmllcyB0aGUgdGltaW5nIGFwaSAoc2V0VGltZW91dCBvciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIGFuZCBtb2RlIHRvIHVzZS4gU2VlXG5cdCAqIHt7I2Nyb3NzTGluayBcIlRpY2tlci9USU1FT1VUXCJ9fXt7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvUkFGXCJ9fXt7L2Nyb3NzTGlua319LCBhbmRcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1JBRl9TWU5DSEVEXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb2RlIGRldGFpbHMuXG5cdCAqIEBwcm9wZXJ0eSB0aW1pbmdNb2RlXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgVGlja2VyLlRJTUVPVVRcblx0ICoqL1xuXHRUaWNrZXIudGltaW5nTW9kZSA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFNwZWNpZmllcyBhIG1heGltdW0gdmFsdWUgZm9yIHRoZSBkZWx0YSBwcm9wZXJ0eSBpbiB0aGUgdGljayBldmVudCBvYmplY3QuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYnVpbGRpbmcgdGltZVxuXHQgKiBiYXNlZCBhbmltYXRpb25zIGFuZCBzeXN0ZW1zIHRvIHByZXZlbnQgaXNzdWVzIGNhdXNlZCBieSBsYXJnZSB0aW1lIGdhcHMgY2F1c2VkIGJ5IGJhY2tncm91bmQgdGFicywgc3lzdGVtIHNsZWVwLFxuXHQgKiBhbGVydCBkaWFsb2dzLCBvciBvdGhlciBibG9ja2luZyByb3V0aW5lcy4gRG91YmxlIHRoZSBleHBlY3RlZCBmcmFtZSBkdXJhdGlvbiBpcyBvZnRlbiBhbiBlZmZlY3RpdmUgdmFsdWVcblx0ICogKGV4LiBtYXhEZWx0YT01MCB3aGVuIHJ1bm5pbmcgYXQgNDBmcHMpLlxuXHQgKiBcblx0ICogVGhpcyBkb2VzIG5vdCBpbXBhY3QgYW55IG90aGVyIHZhbHVlcyAoZXguIHRpbWUsIHJ1blRpbWUsIGV0YyksIHNvIHlvdSBtYXkgZXhwZXJpZW5jZSBpc3N1ZXMgaWYgeW91IGVuYWJsZSBtYXhEZWx0YVxuXHQgKiB3aGVuIHVzaW5nIGJvdGggZGVsdGEgYW5kIG90aGVyIHZhbHVlcy5cblx0ICogXG5cdCAqIElmIDAsIHRoZXJlIGlzIG5vIG1heGltdW0uXG5cdCAqIEBwcm9wZXJ0eSBtYXhEZWx0YVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDBcblx0ICovXG5cdFRpY2tlci5tYXhEZWx0YSA9IDA7XG5cdFxuXHQvKipcblx0ICogV2hlbiB0aGUgdGlja2VyIGlzIHBhdXNlZCwgYWxsIGxpc3RlbmVycyB3aWxsIHN0aWxsIHJlY2VpdmUgYSB0aWNrIGV2ZW50LCBidXQgdGhlIDxjb2RlPnBhdXNlZDwvY29kZT4gcHJvcGVydHlcblx0ICogb2YgdGhlIGV2ZW50IHdpbGwgYmUgYHRydWVgLiBBbHNvLCB3aGlsZSBwYXVzZWQgdGhlIGBydW5UaW1lYCB3aWxsIG5vdCBpbmNyZWFzZS4gU2VlIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aWNrOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvZ2V0VGltZVwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHt7I2Nyb3NzTGluayBcIlRpY2tlci9nZXRFdmVudFRpbWVcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmVcblx0ICogaW5mby5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLlRpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBoYW5kbGVUaWNrKTtcblx0ICogICAgICBjcmVhdGVqcy5UaWNrZXIucGF1c2VkID0gdHJ1ZTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVUaWNrKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LnBhdXNlZCxcblx0ICogICAgICAgICAgXHRjcmVhdGVqcy5UaWNrZXIuZ2V0VGltZShmYWxzZSksXG5cdCAqICAgICAgICAgIFx0Y3JlYXRlanMuVGlja2VyLmdldFRpbWUodHJ1ZSkpO1xuXHQgKiAgICAgIH1cblx0ICpcblx0ICogQHByb3BlcnR5IHBhdXNlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAZGVmYXVsdCBmYWxzZVxuXHQgKiovXG5cdFRpY2tlci5wYXVzZWQgPSBmYWxzZTtcblxuXG4vLyBtaXgtaW5zOlxuXHQvLyBFdmVudERpc3BhdGNoZXIgbWV0aG9kczpcblx0VGlja2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBudWxsO1xuXHRUaWNrZXIucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMgPSBudWxsO1xuXHRUaWNrZXIuZGlzcGF0Y2hFdmVudCA9IG51bGw7XG5cdFRpY2tlci5oYXNFdmVudExpc3RlbmVyID0gbnVsbDtcblx0VGlja2VyLl9saXN0ZW5lcnMgPSBudWxsO1xuXHRjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShUaWNrZXIpOyAvLyBpbmplY3QgRXZlbnREaXNwYXRjaGVyIG1ldGhvZHMuXG5cdFRpY2tlci5fYWRkRXZlbnRMaXN0ZW5lciA9IFRpY2tlci5hZGRFdmVudExpc3RlbmVyO1xuXHRUaWNrZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuXHRcdCFUaWNrZXIuX2luaXRlZCYmVGlja2VyLmluaXQoKTtcblx0XHRyZXR1cm4gVGlja2VyLl9hZGRFdmVudExpc3RlbmVyLmFwcGx5KFRpY2tlciwgYXJndW1lbnRzKTtcblx0fTtcblxuXG4vLyBwcml2YXRlIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQHByb3BlcnR5IF9pbml0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5faW5pdGVkID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfc3RhcnRUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fc3RhcnRUaW1lID0gMDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IF9wYXVzZWRUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fcGF1c2VkVGltZT0wO1xuXG5cdC8qKlxuXHQgKiBUaGUgbnVtYmVyIG9mIHRpY2tzIHRoYXQgaGF2ZSBwYXNzZWRcblx0ICogQHByb3BlcnR5IF90aWNrc1xuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3RpY2tzID0gMDtcblxuXHQvKipcblx0ICogVGhlIG51bWJlciBvZiB0aWNrcyB0aGF0IGhhdmUgcGFzc2VkIHdoaWxlIFRpY2tlciBoYXMgYmVlbiBwYXVzZWRcblx0ICogQHByb3BlcnR5IF9wYXVzZWRUaWNrc1xuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3BhdXNlZFRpY2tzID0gMDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IF9pbnRlcnZhbFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX2ludGVydmFsID0gNTA7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfbGFzdFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9sYXN0VGltZSA9IDA7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfdGltZXNcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3RpbWVzID0gbnVsbDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IF90aWNrVGltZXNcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3RpY2tUaW1lcyA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFN0b3JlcyB0aGUgdGltZW91dCBvciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgaWQuXG5cdCAqIEBwcm9wZXJ0eSBfdGltZXJJZFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3RpbWVySWQgPSBudWxsO1xuXHRcblx0LyoqXG5cdCAqIFRydWUgaWYgY3VycmVudGx5IHVzaW5nIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgZmFsc2UgaWYgdXNpbmcgc2V0VGltZW91dC4gVGhpcyBtYXkgYmUgZGlmZmVyZW50IHRoYW4gdGltaW5nTW9kZVxuXHQgKiBpZiB0aGF0IHByb3BlcnR5IGNoYW5nZWQgYW5kIGEgdGljayBoYXNuJ3QgZmlyZWQuXG5cdCAqIEBwcm9wZXJ0eSBfcmFmXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3JhZiA9IHRydWU7XG5cdFxuXG4vLyBzdGF0aWMgZ2V0dGVyIC8gc2V0dGVyczpcblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2ludGVydmFsOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2Qgc2V0SW50ZXJ2YWxcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaW50ZXJ2YWxcblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbihpbnRlcnZhbCkge1xuXHRcdFRpY2tlci5faW50ZXJ2YWwgPSBpbnRlcnZhbDtcblx0XHRpZiAoIVRpY2tlci5faW5pdGVkKSB7IHJldHVybjsgfVxuXHRcdFRpY2tlci5fc2V0dXBUaWNrKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2ludGVydmFsOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgZ2V0SW50ZXJ2YWxcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqKi9cblx0VGlja2VyLmdldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFRpY2tlci5faW50ZXJ2YWw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2ZyYW1lcmF0ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIHNldEZQU1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdFRpY2tlci5zZXRGUFMgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFRpY2tlci5zZXRJbnRlcnZhbCgxMDAwL3ZhbHVlKTtcblx0fTtcblxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvZnJhbWVyYXRlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgZ2V0RlBTXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdFRpY2tlci5nZXRGUFMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gMTAwMC9UaWNrZXIuX2ludGVydmFsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgdGhlIHRhcmdldCB0aW1lIChpbiBtaWxsaXNlY29uZHMpIGJldHdlZW4gdGlja3MuIERlZmF1bHQgaXMgNTAgKDIwIEZQUykuXG5cdCAqIE5vdGUgdGhhdCBhY3R1YWwgdGltZSBiZXR3ZWVuIHRpY2tzIG1heSBiZSBtb3JlIHRoYW4gc3BlY2lmaWVkIGRlcGVuZGluZyBvbiBDUFUgbG9hZC5cblx0ICogVGhpcyBwcm9wZXJ0eSBpcyBpZ25vcmVkIGlmIHRoZSB0aWNrZXIgaXMgdXNpbmcgdGhlIGBSQUZgIHRpbWluZyBtb2RlLlxuXHQgKiBAcHJvcGVydHkgaW50ZXJ2YWxcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiovXG5cdCBcblx0LyoqXG5cdCAqIEluZGljYXRlcyB0aGUgdGFyZ2V0IGZyYW1lIHJhdGUgaW4gZnJhbWVzIHBlciBzZWNvbmQgKEZQUykuIEVmZmVjdGl2ZWx5IGp1c3QgYSBzaG9ydGN1dCB0byBgaW50ZXJ2YWxgLCB3aGVyZVxuXHQgKiBgZnJhbWVyYXRlID09IDEwMDAvaW50ZXJ2YWxgLlxuXHQgKiBAcHJvcGVydHkgZnJhbWVyYXRlXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICoqL1xuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRpY2tlciwge1xuXHRcdFx0aW50ZXJ2YWw6IHsgZ2V0OiBUaWNrZXIuZ2V0SW50ZXJ2YWwsIHNldDogVGlja2VyLnNldEludGVydmFsIH0sXG5cdFx0XHRmcmFtZXJhdGU6IHsgZ2V0OiBUaWNrZXIuZ2V0RlBTLCBzZXQ6IFRpY2tlci5zZXRGUFMgfVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlKSB7IGNvbnNvbGUubG9nKGUpOyB9XG5cblxuLy8gcHVibGljIHN0YXRpYyBtZXRob2RzOlxuXHQvKipcblx0ICogU3RhcnRzIHRoZSB0aWNrLiBUaGlzIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIGZpcnN0IGxpc3RlbmVyIGlzIGFkZGVkLlxuXHQgKiBAbWV0aG9kIGluaXRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRpY2tlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKFRpY2tlci5faW5pdGVkKSB7IHJldHVybjsgfVxuXHRcdFRpY2tlci5faW5pdGVkID0gdHJ1ZTtcblx0XHRUaWNrZXIuX3RpbWVzID0gW107XG5cdFx0VGlja2VyLl90aWNrVGltZXMgPSBbXTtcblx0XHRUaWNrZXIuX3N0YXJ0VGltZSA9IFRpY2tlci5fZ2V0VGltZSgpO1xuXHRcdFRpY2tlci5fdGltZXMucHVzaChUaWNrZXIuX2xhc3RUaW1lID0gMCk7XG5cdFx0VGlja2VyLmludGVydmFsID0gVGlja2VyLl9pbnRlcnZhbDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBTdG9wcyB0aGUgVGlja2VyIGFuZCByZW1vdmVzIGFsbCBsaXN0ZW5lcnMuIFVzZSBpbml0KCkgdG8gcmVzdGFydCB0aGUgVGlja2VyLlxuXHQgKiBAbWV0aG9kIHJlc2V0XG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUaWNrZXIucmVzZXQgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoVGlja2VyLl9yYWYpIHtcblx0XHRcdHZhciBmID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9DYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNDYW5jZWxBbmltYXRpb25GcmFtZTtcblx0XHRcdGYmJmYoVGlja2VyLl90aW1lcklkKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KFRpY2tlci5fdGltZXJJZCk7XG5cdFx0fVxuXHRcdFRpY2tlci5yZW1vdmVBbGxFdmVudExpc3RlbmVycyhcInRpY2tcIik7XG5cdFx0VGlja2VyLl90aW1lcklkID0gVGlja2VyLl90aW1lcyA9IFRpY2tlci5fdGlja1RpbWVzID0gbnVsbDtcblx0XHRUaWNrZXIuX3N0YXJ0VGltZSA9IFRpY2tlci5fbGFzdFRpbWUgPSBUaWNrZXIuX3RpY2tzID0gMDtcblx0XHRUaWNrZXIuX2luaXRlZCA9IGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhdmVyYWdlIHRpbWUgc3BlbnQgd2l0aGluIGEgdGljay4gVGhpcyBjYW4gdmFyeSBzaWduaWZpY2FudGx5IGZyb20gdGhlIHZhbHVlIHByb3ZpZGVkIGJ5IGdldE1lYXN1cmVkRlBTXG5cdCAqIGJlY2F1c2UgaXQgb25seSBtZWFzdXJlcyB0aGUgdGltZSBzcGVudCB3aXRoaW4gdGhlIHRpY2sgZXhlY3V0aW9uIHN0YWNrLiBcblx0ICogXG5cdCAqIEV4YW1wbGUgMTogV2l0aCBhIHRhcmdldCBGUFMgb2YgMjAsIGdldE1lYXN1cmVkRlBTKCkgcmV0dXJucyAyMGZwcywgd2hpY2ggaW5kaWNhdGVzIGFuIGF2ZXJhZ2Ugb2YgNTBtcyBiZXR3ZWVuIFxuXHQgKiB0aGUgZW5kIG9mIG9uZSB0aWNrIGFuZCB0aGUgZW5kIG9mIHRoZSBuZXh0LiBIb3dldmVyLCBnZXRNZWFzdXJlZFRpY2tUaW1lKCkgcmV0dXJucyAxNW1zLiBUaGlzIGluZGljYXRlcyB0aGF0IFxuXHQgKiB0aGVyZSBtYXkgYmUgdXAgdG8gMzVtcyBvZiBcImlkbGVcIiB0aW1lIGJldHdlZW4gdGhlIGVuZCBvZiBvbmUgdGljayBhbmQgdGhlIHN0YXJ0IG9mIHRoZSBuZXh0LlxuXHQgKlxuXHQgKiBFeGFtcGxlIDI6IFdpdGggYSB0YXJnZXQgRlBTIG9mIDMwLCBnZXRGUFMoKSByZXR1cm5zIDEwZnBzLCB3aGljaCBpbmRpY2F0ZXMgYW4gYXZlcmFnZSBvZiAxMDBtcyBiZXR3ZWVuIHRoZSBlbmQgb2Zcblx0ICogb25lIHRpY2sgYW5kIHRoZSBlbmQgb2YgdGhlIG5leHQuIEhvd2V2ZXIsIGdldE1lYXN1cmVkVGlja1RpbWUoKSByZXR1cm5zIDIwbXMuIFRoaXMgd291bGQgaW5kaWNhdGUgdGhhdCBzb21ldGhpbmdcblx0ICogb3RoZXIgdGhhbiB0aGUgdGljayBpcyB1c2luZyB+ODBtcyAoYW5vdGhlciBzY3JpcHQsIERPTSByZW5kZXJpbmcsIGV0YykuXG5cdCAqIEBtZXRob2QgZ2V0TWVhc3VyZWRUaWNrVGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGlja3NdIFRoZSBudW1iZXIgb2YgcHJldmlvdXMgdGlja3Mgb3ZlciB3aGljaCB0byBtZWFzdXJlIHRoZSBhdmVyYWdlIHRpbWUgc3BlbnQgaW4gYSB0aWNrLlxuXHQgKiBEZWZhdWx0cyB0byB0aGUgbnVtYmVyIG9mIHRpY2tzIHBlciBzZWNvbmQuIFRvIGdldCBvbmx5IHRoZSBsYXN0IHRpY2sncyB0aW1lLCBwYXNzIGluIDEuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGF2ZXJhZ2UgdGltZSBzcGVudCBpbiBhIHRpY2sgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiovXG5cdFRpY2tlci5nZXRNZWFzdXJlZFRpY2tUaW1lID0gZnVuY3Rpb24odGlja3MpIHtcblx0XHR2YXIgdHRsPTAsIHRpbWVzPVRpY2tlci5fdGlja1RpbWVzO1xuXHRcdGlmICghdGltZXMgfHwgdGltZXMubGVuZ3RoIDwgMSkgeyByZXR1cm4gLTE7IH1cblxuXHRcdC8vIGJ5IGRlZmF1bHQsIGNhbGN1bGF0ZSBhdmVyYWdlIGZvciB0aGUgcGFzdCB+MSBzZWNvbmQ6XG5cdFx0dGlja3MgPSBNYXRoLm1pbih0aW1lcy5sZW5ndGgsIHRpY2tzfHwoVGlja2VyLmdldEZQUygpfDApKTtcblx0XHRmb3IgKHZhciBpPTA7IGk8dGlja3M7IGkrKykgeyB0dGwgKz0gdGltZXNbaV07IH1cblx0XHRyZXR1cm4gdHRsL3RpY2tzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhY3R1YWwgZnJhbWVzIC8gdGlja3MgcGVyIHNlY29uZC5cblx0ICogQG1ldGhvZCBnZXRNZWFzdXJlZEZQU1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGlja3NdIFRoZSBudW1iZXIgb2YgcHJldmlvdXMgdGlja3Mgb3ZlciB3aGljaCB0byBtZWFzdXJlIHRoZSBhY3R1YWwgZnJhbWVzIC8gdGlja3MgcGVyIHNlY29uZC5cblx0ICogRGVmYXVsdHMgdG8gdGhlIG51bWJlciBvZiB0aWNrcyBwZXIgc2Vjb25kLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBhY3R1YWwgZnJhbWVzIC8gdGlja3MgcGVyIHNlY29uZC4gRGVwZW5kaW5nIG9uIHBlcmZvcm1hbmNlLCB0aGlzIG1heSBkaWZmZXJcblx0ICogZnJvbSB0aGUgdGFyZ2V0IGZyYW1lcyBwZXIgc2Vjb25kLlxuXHQgKiovXG5cdFRpY2tlci5nZXRNZWFzdXJlZEZQUyA9IGZ1bmN0aW9uKHRpY2tzKSB7XG5cdFx0dmFyIHRpbWVzID0gVGlja2VyLl90aW1lcztcblx0XHRpZiAoIXRpbWVzIHx8IHRpbWVzLmxlbmd0aCA8IDIpIHsgcmV0dXJuIC0xOyB9XG5cblx0XHQvLyBieSBkZWZhdWx0LCBjYWxjdWxhdGUgZnBzIGZvciB0aGUgcGFzdCB+MSBzZWNvbmQ6XG5cdFx0dGlja3MgPSBNYXRoLm1pbih0aW1lcy5sZW5ndGgtMSwgdGlja3N8fChUaWNrZXIuZ2V0RlBTKCl8MCkpO1xuXHRcdHJldHVybiAxMDAwLygodGltZXNbMF0tdGltZXNbdGlja3NdKS90aWNrcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3BhdXNlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIHNldFBhdXNlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuc2V0UGF1c2VkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHQvLyBUT0RPOiBkZXByZWNhdGVkLlxuXHRcdFRpY2tlci5wYXVzZWQgPSB2YWx1ZTtcblx0fTtcblxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvcGF1c2VkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgZ2V0UGF1c2VkXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuZ2V0UGF1c2VkID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gVE9ETzogZGVwcmVjYXRlZC5cblx0XHRyZXR1cm4gVGlja2VyLnBhdXNlZDtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZSBUaWNrZXIgd2FzIGluaXRpYWxpemVkIHZpYSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvaW5pdFwifX0uXG5cdCAqIFJldHVybnMgLTEgaWYgVGlja2VyIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZC4gRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCB1c2Vcblx0ICogdGhpcyBpbiBhIHRpbWUgc3luY2hyb25pemVkIGFuaW1hdGlvbiB0byBkZXRlcm1pbmUgdGhlIGV4YWN0IGFtb3VudCBvZiB0aW1lIHRoYXQgaGFzIGVsYXBzZWQuXG5cdCAqIEBtZXRob2QgZ2V0VGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3J1blRpbWU9ZmFsc2VdIElmIHRydWUgb25seSB0aW1lIGVsYXBzZWQgd2hpbGUgVGlja2VyIHdhcyBub3QgcGF1c2VkIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIElmIGZhbHNlLCB0aGUgdmFsdWUgcmV0dXJuZWQgd2lsbCBiZSB0b3RhbCB0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGZpcnN0IHRpY2sgZXZlbnQgbGlzdGVuZXIgd2FzIGFkZGVkLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IE51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2UgVGlja2VyIHdhcyBpbml0aWFsaXplZCBvciAtMS5cblx0ICoqL1xuXHRUaWNrZXIuZ2V0VGltZSA9IGZ1bmN0aW9uKHJ1blRpbWUpIHtcblx0XHRyZXR1cm4gVGlja2VyLl9zdGFydFRpbWUgPyBUaWNrZXIuX2dldFRpbWUoKSAtIChydW5UaW1lID8gVGlja2VyLl9wYXVzZWRUaW1lIDogMCkgOiAtMTtcblx0fTtcblxuXHQvKipcblx0ICogU2ltaWxhciB0byB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2dldFRpbWVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLCBidXQgcmV0dXJucyB0aGUgdGltZSBvbiB0aGUgbW9zdCByZWNlbnQge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3RpY2s6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIGdldEV2ZW50VGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSBydW5UaW1lIHtCb29sZWFufSBbcnVuVGltZT1mYWxzZV0gSWYgdHJ1ZSwgdGhlIHJ1blRpbWUgcHJvcGVydHkgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIHRpbWUuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB0aW1lIG9yIHJ1blRpbWUgcHJvcGVydHkgZnJvbSB0aGUgbW9zdCByZWNlbnQgdGljayBldmVudCBvciAtMS5cblx0ICovXG5cdFRpY2tlci5nZXRFdmVudFRpbWUgPSBmdW5jdGlvbihydW5UaW1lKSB7XG5cdFx0cmV0dXJuIFRpY2tlci5fc3RhcnRUaW1lID8gKFRpY2tlci5fbGFzdFRpbWUgfHwgVGlja2VyLl9zdGFydFRpbWUpIC0gKHJ1blRpbWUgPyBUaWNrZXIuX3BhdXNlZFRpbWUgOiAwKSA6IC0xO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiB0aWNrcyB0aGF0IGhhdmUgYmVlbiBicm9hZGNhc3QgYnkgVGlja2VyLlxuXHQgKiBAbWV0aG9kIGdldFRpY2tzXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtCb29sZWFufSBwYXVzZWFibGUgSW5kaWNhdGVzIHdoZXRoZXIgdG8gaW5jbHVkZSB0aWNrcyB0aGF0IHdvdWxkIGhhdmUgYmVlbiBicm9hZGNhc3Rcblx0ICogd2hpbGUgVGlja2VyIHdhcyBwYXVzZWQuIElmIHRydWUgb25seSB0aWNrIGV2ZW50cyBicm9hZGNhc3Qgd2hpbGUgVGlja2VyIGlzIG5vdCBwYXVzZWQgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogSWYgZmFsc2UsIHRpY2sgZXZlbnRzIHRoYXQgd291bGQgaGF2ZSBiZWVuIGJyb2FkY2FzdCB3aGlsZSBUaWNrZXIgd2FzIHBhdXNlZCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSByZXR1cm5cblx0ICogdmFsdWUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGZhbHNlLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IG9mIHRpY2tzIHRoYXQgaGF2ZSBiZWVuIGJyb2FkY2FzdC5cblx0ICoqL1xuXHRUaWNrZXIuZ2V0VGlja3MgPSBmdW5jdGlvbihwYXVzZWFibGUpIHtcblx0XHRyZXR1cm4gIFRpY2tlci5fdGlja3MgLSAocGF1c2VhYmxlID8gVGlja2VyLl9wYXVzZWRUaWNrcyA6IDApO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgc3RhdGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVTeW5jaFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX2hhbmRsZVN5bmNoID0gZnVuY3Rpb24oKSB7XG5cdFx0VGlja2VyLl90aW1lcklkID0gbnVsbDtcblx0XHRUaWNrZXIuX3NldHVwVGljaygpO1xuXG5cdFx0Ly8gcnVuIGlmIGVub3VnaCB0aW1lIGhhcyBlbGFwc2VkLCB3aXRoIGEgbGl0dGxlIGJpdCBvZiBmbGV4aWJpbGl0eSB0byBiZSBlYXJseTpcblx0XHRpZiAoVGlja2VyLl9nZXRUaW1lKCkgLSBUaWNrZXIuX2xhc3RUaW1lID49IChUaWNrZXIuX2ludGVydmFsLTEpKjAuOTcpIHtcblx0XHRcdFRpY2tlci5fdGljaygpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlUkFGXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5faGFuZGxlUkFGID0gZnVuY3Rpb24oKSB7XG5cdFx0VGlja2VyLl90aW1lcklkID0gbnVsbDtcblx0XHRUaWNrZXIuX3NldHVwVGljaygpO1xuXHRcdFRpY2tlci5fdGljaygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVUaW1lb3V0XG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5faGFuZGxlVGltZW91dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFRpY2tlci5fdGltZXJJZCA9IG51bGw7XG5cdFx0VGlja2VyLl9zZXR1cFRpY2soKTtcblx0XHRUaWNrZXIuX3RpY2soKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfc2V0dXBUaWNrXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fc2V0dXBUaWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKFRpY2tlci5fdGltZXJJZCAhPSBudWxsKSB7IHJldHVybjsgfSAvLyBhdm9pZCBkdXBsaWNhdGVzXG5cblx0XHR2YXIgbW9kZSA9IFRpY2tlci50aW1pbmdNb2RlfHwoVGlja2VyLnVzZVJBRiYmVGlja2VyLlJBRl9TWU5DSEVEKTtcblx0XHRpZiAobW9kZSA9PSBUaWNrZXIuUkFGX1NZTkNIRUQgfHwgbW9kZSA9PSBUaWNrZXIuUkFGKSB7XG5cdFx0XHR2YXIgZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZTtcblx0XHRcdGlmIChmKSB7XG5cdFx0XHRcdFRpY2tlci5fdGltZXJJZCA9IGYobW9kZSA9PSBUaWNrZXIuUkFGID8gVGlja2VyLl9oYW5kbGVSQUYgOiBUaWNrZXIuX2hhbmRsZVN5bmNoKTtcblx0XHRcdFx0VGlja2VyLl9yYWYgPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFRpY2tlci5fcmFmID0gZmFsc2U7XG5cdFx0VGlja2VyLl90aW1lcklkID0gc2V0VGltZW91dChUaWNrZXIuX2hhbmRsZVRpbWVvdXQsIFRpY2tlci5faW50ZXJ2YWwpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF90aWNrXG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fdGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXVzZWQgPSBUaWNrZXIucGF1c2VkO1xuXHRcdHZhciB0aW1lID0gVGlja2VyLl9nZXRUaW1lKCk7XG5cdFx0dmFyIGVsYXBzZWRUaW1lID0gdGltZS1UaWNrZXIuX2xhc3RUaW1lO1xuXHRcdFRpY2tlci5fbGFzdFRpbWUgPSB0aW1lO1xuXHRcdFRpY2tlci5fdGlja3MrKztcblx0XHRcblx0XHRpZiAocGF1c2VkKSB7XG5cdFx0XHRUaWNrZXIuX3BhdXNlZFRpY2tzKys7XG5cdFx0XHRUaWNrZXIuX3BhdXNlZFRpbWUgKz0gZWxhcHNlZFRpbWU7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChUaWNrZXIuaGFzRXZlbnRMaXN0ZW5lcihcInRpY2tcIikpIHtcblx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcInRpY2tcIik7XG5cdFx0XHR2YXIgbWF4RGVsdGEgPSBUaWNrZXIubWF4RGVsdGE7XG5cdFx0XHRldmVudC5kZWx0YSA9IChtYXhEZWx0YSAmJiBlbGFwc2VkVGltZSA+IG1heERlbHRhKSA/IG1heERlbHRhIDogZWxhcHNlZFRpbWU7XG5cdFx0XHRldmVudC5wYXVzZWQgPSBwYXVzZWQ7XG5cdFx0XHRldmVudC50aW1lID0gdGltZTtcblx0XHRcdGV2ZW50LnJ1blRpbWUgPSB0aW1lLVRpY2tlci5fcGF1c2VkVGltZTtcblx0XHRcdFRpY2tlci5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0XHR9XG5cdFx0XG5cdFx0VGlja2VyLl90aWNrVGltZXMudW5zaGlmdChUaWNrZXIuX2dldFRpbWUoKS10aW1lKTtcblx0XHR3aGlsZSAoVGlja2VyLl90aWNrVGltZXMubGVuZ3RoID4gMTAwKSB7IFRpY2tlci5fdGlja1RpbWVzLnBvcCgpOyB9XG5cblx0XHRUaWNrZXIuX3RpbWVzLnVuc2hpZnQodGltZSk7XG5cdFx0d2hpbGUgKFRpY2tlci5fdGltZXMubGVuZ3RoID4gMTAwKSB7IFRpY2tlci5fdGltZXMucG9wKCk7IH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0VGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHR2YXIgbm93ID0gd2luZG93LnBlcmZvcm1hbmNlICYmIChwZXJmb3JtYW5jZS5ub3cgfHwgcGVyZm9ybWFuY2UubW96Tm93IHx8IHBlcmZvcm1hbmNlLm1zTm93IHx8IHBlcmZvcm1hbmNlLm9Ob3cgfHwgcGVyZm9ybWFuY2Uud2Via2l0Tm93KTtcblx0VGlja2VyLl9nZXRUaW1lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICgobm93JiZub3cuY2FsbChwZXJmb3JtYW5jZSkpfHwobmV3IERhdGUoKS5nZXRUaW1lKCkpKSAtIFRpY2tlci5fc3RhcnRUaW1lO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuVGlja2VyID0gVGlja2VyO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFVJRC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogR2xvYmFsIHV0aWxpdHkgZm9yIGdlbmVyYXRpbmcgc2VxdWVudGlhbCB1bmlxdWUgSUQgbnVtYmVycy4gVGhlIFVJRCBjbGFzcyB1c2VzIGEgc3RhdGljIGludGVyZmFjZSAoZXguIDxjb2RlPlVJRC5nZXQoKTwvY29kZT4pXG5cdCAqIGFuZCBzaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZC5cblx0ICogQGNsYXNzIFVJRFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0ZnVuY3Rpb24gVUlEKCkge1xuXHRcdHRocm93IFwiVUlEIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWRcIjtcblx0fVxuXG5cbi8vIHByaXZhdGUgc3RhdGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgX25leHRJRFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFVJRC5fbmV4dElEID0gMDtcblxuXG4vLyBwdWJsaWMgc3RhdGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBuZXh0IHVuaXF1ZSBpZC5cblx0ICogQG1ldGhvZCBnZXRcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgbmV4dCB1bmlxdWUgaWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFVJRC5nZXQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gVUlELl9uZXh0SUQrKztcblx0fTtcblxuXG5cdGNyZWF0ZWpzLlVJRCA9IFVJRDtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBNb3VzZUV2ZW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBQYXNzZWQgYXMgdGhlIHBhcmFtZXRlciB0byBhbGwgbW91c2UvcG9pbnRlci90b3VjaCByZWxhdGVkIGV2ZW50cy4gRm9yIGEgbGlzdGluZyBvZiBtb3VzZSBldmVudHMgYW5kIHRoZWlyIHByb3BlcnRpZXMsXG5cdCAqIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiU3RhZ2VcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgbGlzdGluZ3MuXG5cdCAqIEBjbGFzcyBNb3VzZUV2ZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGJ1YmJsZXMgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGV2ZW50IHdpbGwgYnViYmxlIHRocm91Z2ggdGhlIGRpc3BsYXkgbGlzdC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBjYW5jZWxhYmxlIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiB0aGlzIGV2ZW50IGNhbiBiZSBjYW5jZWxsZWQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFnZVggVGhlIG5vcm1hbGl6ZWQgeCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhZ2UuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFnZVkgVGhlIG5vcm1hbGl6ZWQgeSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhZ2UuXG5cdCAqIEBwYXJhbSB7TW91c2VFdmVudH0gbmF0aXZlRXZlbnQgVGhlIG5hdGl2ZSBET00gZXZlbnQgcmVsYXRlZCB0byB0aGlzIG1vdXNlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9pbnRlcklEIFRoZSB1bmlxdWUgaWQgZm9yIHRoZSBwb2ludGVyLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHByaW1hcnkgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyB0aGUgcHJpbWFyeSBwb2ludGVyIGluIGEgbXVsdGl0b3VjaCBlbnZpcm9ubWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhd1ggVGhlIHJhdyB4IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBzdGFnZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhd1kgVGhlIHJhdyB5IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBzdGFnZS5cblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSByZWxhdGVkVGFyZ2V0IFRoZSBzZWNvbmRhcnkgdGFyZ2V0IGZvciB0aGUgZXZlbnQuXG5cdCAqIEBleHRlbmRzIEV2ZW50XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIE1vdXNlRXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSwgc3RhZ2VYLCBzdGFnZVksIG5hdGl2ZUV2ZW50LCBwb2ludGVySUQsIHByaW1hcnksIHJhd1gsIHJhd1ksIHJlbGF0ZWRUYXJnZXQpIHtcblx0XHR0aGlzLkV2ZW50X2NvbnN0cnVjdG9yKHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgbm9ybWFsaXplZCB4IHBvc2l0aW9uIG9uIHRoZSBzdGFnZS4gVGhpcyB3aWxsIGFsd2F5cyBiZSB3aXRoaW4gdGhlIHJhbmdlIDAgdG8gc3RhZ2Ugd2lkdGguXG5cdFx0ICogQHByb3BlcnR5IHN0YWdlWFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCovXG5cdFx0dGhpcy5zdGFnZVggPSBzdGFnZVg7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBub3JtYWxpemVkIHkgcG9zaXRpb24gb24gdGhlIHN0YWdlLiBUaGlzIHdpbGwgYWx3YXlzIGJlIHdpdGhpbiB0aGUgcmFuZ2UgMCB0byBzdGFnZSBoZWlnaHQuXG5cdFx0ICogQHByb3BlcnR5IHN0YWdlWVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLnN0YWdlWSA9IHN0YWdlWTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHJhdyB4IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBzdGFnZS4gTm9ybWFsbHkgdGhpcyB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSBzdGFnZVggdmFsdWUsIHVubGVzc1xuXHRcdCAqIHN0YWdlLm1vdXNlTW92ZU91dHNpZGUgaXMgdHJ1ZSBhbmQgdGhlIHBvaW50ZXIgaXMgb3V0c2lkZSBvZiB0aGUgc3RhZ2UgYm91bmRzLlxuXHRcdCAqIEBwcm9wZXJ0eSByYXdYXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0Ki9cblx0XHR0aGlzLnJhd1ggPSAocmF3WD09bnVsbCk/c3RhZ2VYOnJhd1g7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSByYXcgeSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc3RhZ2UuIE5vcm1hbGx5IHRoaXMgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgc3RhZ2VZIHZhbHVlLCB1bmxlc3Ncblx0XHQgKiBzdGFnZS5tb3VzZU1vdmVPdXRzaWRlIGlzIHRydWUgYW5kIHRoZSBwb2ludGVyIGlzIG91dHNpZGUgb2YgdGhlIHN0YWdlIGJvdW5kcy5cblx0XHQgKiBAcHJvcGVydHkgcmF3WVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCovXG5cdFx0dGhpcy5yYXdZID0gKHJhd1k9PW51bGwpP3N0YWdlWTpyYXdZO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgbmF0aXZlIE1vdXNlRXZlbnQgZ2VuZXJhdGVkIGJ5IHRoZSBicm93c2VyLiBUaGUgcHJvcGVydGllcyBhbmQgQVBJIGZvciB0aGlzXG5cdFx0ICogZXZlbnQgbWF5IGRpZmZlciBiZXR3ZWVuIGJyb3dzZXJzLiBUaGlzIHByb3BlcnR5IHdpbGwgYmUgbnVsbCBpZiB0aGVcblx0XHQgKiBFYXNlbEpTIHByb3BlcnR5IHdhcyBub3QgZGlyZWN0bHkgZ2VuZXJhdGVkIGZyb20gYSBuYXRpdmUgTW91c2VFdmVudC5cblx0XHQgKiBAcHJvcGVydHkgbmF0aXZlRXZlbnRcblx0XHQgKiBAdHlwZSBIdG1sTW91c2VFdmVudFxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiovXG5cdFx0dGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgdW5pcXVlIGlkIGZvciB0aGUgcG9pbnRlciAodG91Y2ggcG9pbnQgb3IgY3Vyc29yKS4gVGhpcyB3aWxsIGJlIGVpdGhlciAtMSBmb3IgdGhlIG1vdXNlLCBvciB0aGUgc3lzdGVtXG5cdFx0ICogc3VwcGxpZWQgaWQgdmFsdWUuXG5cdFx0ICogQHByb3BlcnR5IHBvaW50ZXJJRFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5wb2ludGVySUQgPSBwb2ludGVySUQ7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgdGhlIHByaW1hcnkgcG9pbnRlciBpbiBhIG11bHRpdG91Y2ggZW52aXJvbm1lbnQuIFRoaXMgd2lsbCBhbHdheXMgYmUgdHJ1ZSBmb3IgdGhlIG1vdXNlLlxuXHRcdCAqIEZvciB0b3VjaCBwb2ludGVycywgdGhlIGZpcnN0IHBvaW50ZXIgaW4gdGhlIGN1cnJlbnQgc3RhY2sgd2lsbCBiZSBjb25zaWRlcmVkIHRoZSBwcmltYXJ5IHBvaW50ZXIuXG5cdFx0ICogQHByb3BlcnR5IHByaW1hcnlcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHR0aGlzLnByaW1hcnkgPSAhIXByaW1hcnk7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHNlY29uZGFyeSB0YXJnZXQgZm9yIHRoZSBldmVudCwgaWYgYXBwbGljYWJsZS4gVGhpcyBpcyB1c2VkIGZvciBtb3VzZW91dC9yb2xsb3V0XG5cdFx0ICogZXZlbnRzIHRvIGluZGljYXRlIHRoZSBvYmplY3QgdGhhdCB0aGUgbW91c2UgZW50ZXJlZCBmcm9tLCBtb3VzZW92ZXIvcm9sbG92ZXIgZm9yIHRoZSBvYmplY3QgdGhlIG1vdXNlIGV4aXRlZCxcblx0XHQgKiBhbmQgc3RhZ2Vtb3VzZWRvd24vc3RhZ2Vtb3VzZXVwIGV2ZW50cyBmb3IgdGhlIG9iamVjdCB0aGF0IHdhcyB0aGUgdW5kZXIgdGhlIGN1cnNvciwgaWYgYW55LlxuXHRcdCAqIFxuXHRcdCAqIE9ubHkgdmFsaWQgaW50ZXJhY3Rpb24gdGFyZ2V0cyB3aWxsIGJlIHJldHVybmVkIChpZS4gb2JqZWN0cyB3aXRoIG1vdXNlIGxpc3RlbmVycyBvciBhIGN1cnNvciBzZXQpLlxuXHRcdCAqIEBwcm9wZXJ0eSByZWxhdGVkVGFyZ2V0XG5cdFx0ICogQHR5cGUge0Rpc3BsYXlPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gcmVsYXRlZFRhcmdldDtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChNb3VzZUV2ZW50LCBjcmVhdGVqcy5FdmVudCk7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cdFxuXHRcbi8vIGdldHRlciAvIHNldHRlcnM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB4IHBvc2l0aW9uIG9mIHRoZSBtb3VzZSBpbiB0aGUgbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW0gb2YgdGhlIGN1cnJlbnQgdGFyZ2V0IChpZS4gdGhlIGRpc3BhdGNoZXIpLlxuXHQgKiBAcHJvcGVydHkgbG9jYWxYXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEByZWFkb25seVxuXHQgKi9cblx0cC5fZ2V0X2xvY2FsWCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmN1cnJlbnRUYXJnZXQuZ2xvYmFsVG9Mb2NhbCh0aGlzLnJhd1gsIHRoaXMucmF3WSkueDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSBtb3VzZSBpbiB0aGUgbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW0gb2YgdGhlIGN1cnJlbnQgdGFyZ2V0IChpZS4gdGhlIGRpc3BhdGNoZXIpLlxuXHQgKiBAcHJvcGVydHkgbG9jYWxZXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEByZWFkb25seVxuXHQgKi9cblx0cC5fZ2V0X2xvY2FsWSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmN1cnJlbnRUYXJnZXQuZ2xvYmFsVG9Mb2NhbCh0aGlzLnJhd1gsIHRoaXMucmF3WSkueTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZXZlbnQgd2FzIGdlbmVyYXRlZCBieSBhIHRvdWNoIGlucHV0ICh2ZXJzdXMgYSBtb3VzZSBpbnB1dCkuXG5cdCAqIEBwcm9wZXJ0eSBpc1RvdWNoXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAcmVhZG9ubHlcblx0ICovXG5cdHAuX2dldF9pc1RvdWNoID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucG9pbnRlcklEICE9PSAtMTtcblx0fTtcblx0XG5cdFxuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcblx0XHRcdGxvY2FsWDogeyBnZXQ6IHAuX2dldF9sb2NhbFggfSxcblx0XHRcdGxvY2FsWTogeyBnZXQ6IHAuX2dldF9sb2NhbFkgfSxcblx0XHRcdGlzVG91Y2g6IHsgZ2V0OiBwLl9nZXRfaXNUb3VjaCB9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHt9IC8vIFRPRE86IHVzZSBMb2dcblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgTW91c2VFdmVudCBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtNb3VzZUV2ZW50fSBhIGNsb25lIG9mIHRoZSBNb3VzZUV2ZW50IGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IE1vdXNlRXZlbnQodGhpcy50eXBlLCB0aGlzLmJ1YmJsZXMsIHRoaXMuY2FuY2VsYWJsZSwgdGhpcy5zdGFnZVgsIHRoaXMuc3RhZ2VZLCB0aGlzLm5hdGl2ZUV2ZW50LCB0aGlzLnBvaW50ZXJJRCwgdGhpcy5wcmltYXJ5LCB0aGlzLnJhd1gsIHRoaXMucmF3WSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltNb3VzZUV2ZW50ICh0eXBlPVwiK3RoaXMudHlwZStcIiBzdGFnZVg9XCIrdGhpcy5zdGFnZVgrXCIgc3RhZ2VZPVwiK3RoaXMuc3RhZ2VZK1wiKV1cIjtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLk1vdXNlRXZlbnQgPSBjcmVhdGVqcy5wcm9tb3RlKE1vdXNlRXZlbnQsIFwiRXZlbnRcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gTWF0cml4MkQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFJlcHJlc2VudHMgYW4gYWZmaW5lIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCwgYW5kIHByb3ZpZGVzIHRvb2xzIGZvciBjb25zdHJ1Y3RpbmcgYW5kIGNvbmNhdGVuYXRpbmcgbWF0cmljZXMuXG5cdCAqXG5cdCAqIFRoaXMgbWF0cml4IGNhbiBiZSB2aXN1YWxpemVkIGFzOlxuXHQgKlxuXHQgKiBcdFsgYSAgYyAgdHhcblx0ICogXHQgIGIgIGQgIHR5XG5cdCAqIFx0ICAwICAwICAxICBdXG5cdCAqXG5cdCAqIE5vdGUgdGhlIGxvY2F0aW9ucyBvZiBiIGFuZCBjLlxuXHQgKlxuXHQgKiBAY2xhc3MgTWF0cml4MkRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthPTFdIFNwZWNpZmllcyB0aGUgYSBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYj0wXSBTcGVjaWZpZXMgdGhlIGIgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2M9MF0gU3BlY2lmaWVzIHRoZSBjIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtkPTFdIFNwZWNpZmllcyB0aGUgZCBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdHg9MF0gU3BlY2lmaWVzIHRoZSB0eCBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdHk9MF0gU3BlY2lmaWVzIHRoZSB0eSBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIE1hdHJpeDJEKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuXHRcdHRoaXMuc2V0VmFsdWVzKGEsYixjLGQsdHgsdHkpO1xuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvLyBhc3NpZ25lZCBpbiB0aGUgc2V0VmFsdWVzIG1ldGhvZC5cblx0XHQvKipcblx0XHQgKiBQb3NpdGlvbiAoMCwgMCkgaW4gYSAzeDMgYWZmaW5lIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0XHQgKiBAcHJvcGVydHkgYVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogUG9zaXRpb24gKDAsIDEpIGluIGEgM3gzIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG5cdFx0ICogQHByb3BlcnR5IGJcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFBvc2l0aW9uICgxLCAwKSBpbiBhIDN4MyBhZmZpbmUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuXHRcdCAqIEBwcm9wZXJ0eSBjXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBQb3NpdGlvbiAoMSwgMSkgaW4gYSAzeDMgYWZmaW5lIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0XHQgKiBAcHJvcGVydHkgZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogUG9zaXRpb24gKDIsIDApIGluIGEgM3gzIGFmZmluZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG5cdFx0ICogQHByb3BlcnR5IHR4XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBQb3NpdGlvbiAoMiwgMSkgaW4gYSAzeDMgYWZmaW5lIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cblx0XHQgKiBAcHJvcGVydHkgdHlcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdH1cblx0dmFyIHAgPSBNYXRyaXgyRC5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cbi8vIGNvbnN0YW50czpcblx0LyoqXG5cdCAqIE11bHRpcGxpZXIgZm9yIGNvbnZlcnRpbmcgZGVncmVlcyB0byByYWRpYW5zLiBVc2VkIGludGVybmFsbHkgYnkgTWF0cml4MkQuXG5cdCAqIEBwcm9wZXJ0eSBERUdfVE9fUkFEXG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRNYXRyaXgyRC5ERUdfVE9fUkFEID0gTWF0aC5QSS8xODA7XG5cblxuLy8gc3RhdGljIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQW4gaWRlbnRpdHkgbWF0cml4LCByZXByZXNlbnRpbmcgYSBudWxsIHRyYW5zZm9ybWF0aW9uLlxuXHQgKiBAcHJvcGVydHkgaWRlbnRpdHlcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSBNYXRyaXgyRFxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRNYXRyaXgyRC5pZGVudGl0eSA9IG51bGw7IC8vIHNldCBhdCBib3R0b20gb2YgY2xhc3MgZGVmaW5pdGlvbi5cblx0XG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogU2V0cyB0aGUgc3BlY2lmaWVkIHZhbHVlcyBvbiB0aGlzIGluc3RhbmNlLiBcblx0ICogQG1ldGhvZCBzZXRWYWx1ZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthPTFdIFNwZWNpZmllcyB0aGUgYSBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYj0wXSBTcGVjaWZpZXMgdGhlIGIgcHJvcGVydHkgZm9yIHRoZSBuZXcgbWF0cml4LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2M9MF0gU3BlY2lmaWVzIHRoZSBjIHByb3BlcnR5IGZvciB0aGUgbmV3IG1hdHJpeC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtkPTFdIFNwZWNpZmllcyB0aGUgZCBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdHg9MF0gU3BlY2lmaWVzIHRoZSB0eCBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdHk9MF0gU3BlY2lmaWVzIHRoZSB0eSBwcm9wZXJ0eSBmb3IgdGhlIG5ldyBtYXRyaXguXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0Ki9cblx0cC5zZXRWYWx1ZXMgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCB0eCwgdHkpIHtcblx0XHQvLyBkb24ndCBmb3JnZXQgdG8gdXBkYXRlIGRvY3MgaW4gdGhlIGNvbnN0cnVjdG9yIGlmIHRoZXNlIGNoYW5nZTpcblx0XHR0aGlzLmEgPSAoYSA9PSBudWxsKSA/IDEgOiBhO1xuXHRcdHRoaXMuYiA9IGIgfHwgMDtcblx0XHR0aGlzLmMgPSBjIHx8IDA7XG5cdFx0dGhpcy5kID0gKGQgPT0gbnVsbCkgPyAxIDogZDtcblx0XHR0aGlzLnR4ID0gdHggfHwgMDtcblx0XHR0aGlzLnR5ID0gdHkgfHwgMDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQXBwZW5kcyB0aGUgc3BlY2lmaWVkIG1hdHJpeCBwcm9wZXJ0aWVzIHRvIHRoaXMgbWF0cml4LiBBbGwgcGFyYW1ldGVycyBhcmUgcmVxdWlyZWQuXG5cdCAqIFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgbXVsdGlwbHlpbmcgYCh0aGlzIG1hdHJpeCkgKiAoc3BlY2lmaWVkIG1hdHJpeClgLlxuXHQgKiBAbWV0aG9kIGFwcGVuZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gYVxuXHQgKiBAcGFyYW0ge051bWJlcn0gYlxuXHQgKiBAcGFyYW0ge051bWJlcn0gY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHR5XG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5hcHBlbmQgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCB0eCwgdHkpIHtcblx0XHR2YXIgYTEgPSB0aGlzLmE7XG5cdFx0dmFyIGIxID0gdGhpcy5iO1xuXHRcdHZhciBjMSA9IHRoaXMuYztcblx0XHR2YXIgZDEgPSB0aGlzLmQ7XG5cdFx0aWYgKGEgIT0gMSB8fCBiICE9IDAgfHwgYyAhPSAwIHx8IGQgIT0gMSkge1xuXHRcdFx0dGhpcy5hICA9IGExKmErYzEqYjtcblx0XHRcdHRoaXMuYiAgPSBiMSphK2QxKmI7XG5cdFx0XHR0aGlzLmMgID0gYTEqYytjMSpkO1xuXHRcdFx0dGhpcy5kICA9IGIxKmMrZDEqZDtcblx0XHR9XG5cdFx0dGhpcy50eCA9IGExKnR4K2MxKnR5K3RoaXMudHg7XG5cdFx0dGhpcy50eSA9IGIxKnR4K2QxKnR5K3RoaXMudHk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFByZXBlbmRzIHRoZSBzcGVjaWZpZWQgbWF0cml4IHByb3BlcnRpZXMgdG8gdGhpcyBtYXRyaXguXG5cdCAqIFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgbXVsdGlwbHlpbmcgYChzcGVjaWZpZWQgbWF0cml4KSAqICh0aGlzIG1hdHJpeClgLlxuXHQgKiBBbGwgcGFyYW1ldGVycyBhcmUgcmVxdWlyZWQuXG5cdCAqIEBtZXRob2QgcHJlcGVuZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gYVxuXHQgKiBAcGFyYW0ge051bWJlcn0gYlxuXHQgKiBAcGFyYW0ge051bWJlcn0gY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHR5XG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5wcmVwZW5kID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgdHgsIHR5KSB7XG5cdFx0dmFyIGExID0gdGhpcy5hO1xuXHRcdHZhciBjMSA9IHRoaXMuYztcblx0XHR2YXIgdHgxID0gdGhpcy50eDtcblxuXHRcdHRoaXMuYSAgPSBhKmExK2MqdGhpcy5iO1xuXHRcdHRoaXMuYiAgPSBiKmExK2QqdGhpcy5iO1xuXHRcdHRoaXMuYyAgPSBhKmMxK2MqdGhpcy5kO1xuXHRcdHRoaXMuZCAgPSBiKmMxK2QqdGhpcy5kO1xuXHRcdHRoaXMudHggPSBhKnR4MStjKnRoaXMudHkrdHg7XG5cdFx0dGhpcy50eSA9IGIqdHgxK2QqdGhpcy50eSt0eTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQXBwZW5kcyB0aGUgc3BlY2lmaWVkIG1hdHJpeCB0byB0aGlzIG1hdHJpeC5cblx0ICogVGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiBtdWx0aXBseWluZyBgKHRoaXMgbWF0cml4KSAqIChzcGVjaWZpZWQgbWF0cml4KWAuXG5cdCAqIEBtZXRob2QgYXBwZW5kTWF0cml4XG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeFxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAuYXBwZW5kTWF0cml4ID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG1hdHJpeC5hLCBtYXRyaXguYiwgbWF0cml4LmMsIG1hdHJpeC5kLCBtYXRyaXgudHgsIG1hdHJpeC50eSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFByZXBlbmRzIHRoZSBzcGVjaWZpZWQgbWF0cml4IHRvIHRoaXMgbWF0cml4LlxuXHQgKiBUaGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIG11bHRpcGx5aW5nIGAoc3BlY2lmaWVkIG1hdHJpeCkgKiAodGhpcyBtYXRyaXgpYC5cblx0ICogRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCBjYWxjdWxhdGUgdGhlIGNvbWJpbmVkIHRyYW5zZm9ybWF0aW9uIGZvciBhIGNoaWxkIG9iamVjdCB1c2luZzpcblx0ICogXG5cdCAqIFx0dmFyIG8gPSBteURpc3BsYXlPYmplY3Q7XG5cdCAqIFx0dmFyIG10eCA9IG8uZ2V0TWF0cml4KCk7XG5cdCAqIFx0d2hpbGUgKG8gPSBvLnBhcmVudCkge1xuXHQgKiBcdFx0Ly8gcHJlcGVuZCBlYWNoIHBhcmVudCdzIHRyYW5zZm9ybWF0aW9uIGluIHR1cm46XG5cdCAqIFx0XHRvLnByZXBlbmRNYXRyaXgoby5nZXRNYXRyaXgoKSk7XG5cdCAqIFx0fVxuXHQgKiBAbWV0aG9kIHByZXBlbmRNYXRyaXhcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4XG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5wcmVwZW5kTWF0cml4ID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0cmV0dXJuIHRoaXMucHJlcGVuZChtYXRyaXguYSwgbWF0cml4LmIsIG1hdHJpeC5jLCBtYXRyaXguZCwgbWF0cml4LnR4LCBtYXRyaXgudHkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgbWF0cml4IHByb3BlcnRpZXMgZnJvbSB0aGUgc3BlY2lmaWVkIGRpc3BsYXkgb2JqZWN0IHRyYW5zZm9ybSBwcm9wZXJ0aWVzLCBhbmQgYXBwZW5kcyB0aGVtIHRvIHRoaXMgbWF0cml4LlxuXHQgKiBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgdGhpcyB0byBnZW5lcmF0ZSBhIG1hdHJpeCByZXByZXNlbnRpbmcgdGhlIHRyYW5zZm9ybWF0aW9ucyBvZiBhIGRpc3BsYXkgb2JqZWN0OlxuXHQgKiBcblx0ICogXHR2YXIgbXR4ID0gbmV3IE1hdHJpeDJEKCk7XG5cdCAqIFx0bXR4LmFwcGVuZFRyYW5zZm9ybShvLngsIG8ueSwgby5zY2FsZVgsIG8uc2NhbGVZLCBvLnJvdGF0aW9uKTtcblx0ICogQG1ldGhvZCBhcHBlbmRUcmFuc2Zvcm1cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlWFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVZXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByb3RhdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2tld1hcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNrZXdZXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByZWdYIE9wdGlvbmFsLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmVnWSBPcHRpb25hbC5cblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLmFwcGVuZFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHgsIHksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1gsIHNrZXdZLCByZWdYLCByZWdZKSB7XG5cdFx0aWYgKHJvdGF0aW9uJTM2MCkge1xuXHRcdFx0dmFyIHIgPSByb3RhdGlvbipNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0dmFyIGNvcyA9IE1hdGguY29zKHIpO1xuXHRcdFx0dmFyIHNpbiA9IE1hdGguc2luKHIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb3MgPSAxO1xuXHRcdFx0c2luID0gMDtcblx0XHR9XG5cblx0XHRpZiAoc2tld1ggfHwgc2tld1kpIHtcblx0XHRcdC8vIFRPRE86IGNhbiB0aGlzIGJlIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgYXBwZW5kIG9wZXJhdGlvbj9cblx0XHRcdHNrZXdYICo9IE1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0XHRza2V3WSAqPSBNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0dGhpcy5hcHBlbmQoTWF0aC5jb3Moc2tld1kpLCBNYXRoLnNpbihza2V3WSksIC1NYXRoLnNpbihza2V3WCksIE1hdGguY29zKHNrZXdYKSwgeCwgeSk7XG5cdFx0XHR0aGlzLmFwcGVuZChjb3Mqc2NhbGVYLCBzaW4qc2NhbGVYLCAtc2luKnNjYWxlWSwgY29zKnNjYWxlWSwgMCwgMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYXBwZW5kKGNvcypzY2FsZVgsIHNpbipzY2FsZVgsIC1zaW4qc2NhbGVZLCBjb3Mqc2NhbGVZLCB4LCB5KTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKHJlZ1ggfHwgcmVnWSkge1xuXHRcdFx0Ly8gYXBwZW5kIHRoZSByZWdpc3RyYXRpb24gb2Zmc2V0OlxuXHRcdFx0dGhpcy50eCAtPSByZWdYKnRoaXMuYStyZWdZKnRoaXMuYzsgXG5cdFx0XHR0aGlzLnR5IC09IHJlZ1gqdGhpcy5iK3JlZ1kqdGhpcy5kO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogR2VuZXJhdGVzIG1hdHJpeCBwcm9wZXJ0aWVzIGZyb20gdGhlIHNwZWNpZmllZCBkaXNwbGF5IG9iamVjdCB0cmFuc2Zvcm0gcHJvcGVydGllcywgYW5kIHByZXBlbmRzIHRoZW0gdG8gdGhpcyBtYXRyaXguXG5cdCAqIEZvciBleGFtcGxlLCB5b3UgY291bGQgY2FsY3VsYXRlIHRoZSBjb21iaW5lZCB0cmFuc2Zvcm1hdGlvbiBmb3IgYSBjaGlsZCBvYmplY3QgdXNpbmc6XG5cdCAqIFxuXHQgKiBcdHZhciBvID0gbXlEaXNwbGF5T2JqZWN0O1xuXHQgKiBcdHZhciBtdHggPSBuZXcgY3JlYXRlanMuTWF0cml4MkQoKTtcblx0ICogXHRkbyAge1xuXHQgKiBcdFx0Ly8gcHJlcGVuZCBlYWNoIHBhcmVudCdzIHRyYW5zZm9ybWF0aW9uIGluIHR1cm46XG5cdCAqIFx0XHRtdHgucHJlcGVuZFRyYW5zZm9ybShvLngsIG8ueSwgby5zY2FsZVgsIG8uc2NhbGVZLCBvLnJvdGF0aW9uLCBvLnNrZXdYLCBvLnNrZXdZLCBvLnJlZ1gsIG8ucmVnWSk7XG5cdCAqIFx0fSB3aGlsZSAobyA9IG8ucGFyZW50KTtcblx0ICogXHRcblx0ICogXHROb3RlIHRoYXQgdGhlIGFib3ZlIGV4YW1wbGUgd291bGQgbm90IGFjY291bnQgZm9yIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvdHJhbnNmb3JtTWF0cml4OnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIFx0dmFsdWVzLiBTZWUge3sjY3Jvc3NMaW5rIFwiTWF0cml4MkQvcHJlcGVuZE1hdHJpeFwifX17ey9jcm9zc0xpbmt9fSBmb3IgYW4gZXhhbXBsZSB0aGF0IGRvZXMuXG5cdCAqIEBtZXRob2QgcHJlcGVuZFRyYW5zZm9ybVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2NhbGVYXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZVlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJvdGF0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBza2V3WFxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2tld1lcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJlZ1ggT3B0aW9uYWwuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByZWdZIE9wdGlvbmFsLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiovXG5cdHAucHJlcGVuZFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHgsIHksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1gsIHNrZXdZLCByZWdYLCByZWdZKSB7XG5cdFx0aWYgKHJvdGF0aW9uJTM2MCkge1xuXHRcdFx0dmFyIHIgPSByb3RhdGlvbipNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0dmFyIGNvcyA9IE1hdGguY29zKHIpO1xuXHRcdFx0dmFyIHNpbiA9IE1hdGguc2luKHIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb3MgPSAxO1xuXHRcdFx0c2luID0gMDtcblx0XHR9XG5cblx0XHRpZiAocmVnWCB8fCByZWdZKSB7XG5cdFx0XHQvLyBwcmVwZW5kIHRoZSByZWdpc3RyYXRpb24gb2Zmc2V0OlxuXHRcdFx0dGhpcy50eCAtPSByZWdYOyB0aGlzLnR5IC09IHJlZ1k7XG5cdFx0fVxuXHRcdGlmIChza2V3WCB8fCBza2V3WSkge1xuXHRcdFx0Ly8gVE9ETzogY2FuIHRoaXMgYmUgY29tYmluZWQgaW50byBhIHNpbmdsZSBwcmVwZW5kIG9wZXJhdGlvbj9cblx0XHRcdHNrZXdYICo9IE1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0XHRza2V3WSAqPSBNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdFx0dGhpcy5wcmVwZW5kKGNvcypzY2FsZVgsIHNpbipzY2FsZVgsIC1zaW4qc2NhbGVZLCBjb3Mqc2NhbGVZLCAwLCAwKTtcblx0XHRcdHRoaXMucHJlcGVuZChNYXRoLmNvcyhza2V3WSksIE1hdGguc2luKHNrZXdZKSwgLU1hdGguc2luKHNrZXdYKSwgTWF0aC5jb3Moc2tld1gpLCB4LCB5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wcmVwZW5kKGNvcypzY2FsZVgsIHNpbipzY2FsZVgsIC1zaW4qc2NhbGVZLCBjb3Mqc2NhbGVZLCB4LCB5KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgYSBjbG9ja3dpc2Ugcm90YXRpb24gdHJhbnNmb3JtYXRpb24gdG8gdGhlIG1hdHJpeC5cblx0ICogQG1ldGhvZCByb3RhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIFRoZSBhbmdsZSB0byByb3RhdGUgYnksIGluIGRlZ3JlZXMuIFRvIHVzZSBhIHZhbHVlIGluIHJhZGlhbnMsIG11bHRpcGx5IGl0IGJ5IGAxODAvTWF0aC5QSWAuXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC5yb3RhdGUgPSBmdW5jdGlvbihhbmdsZSkge1xuXHRcdGFuZ2xlID0gYW5nbGUqTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHR2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG5cblx0XHR2YXIgYTEgPSB0aGlzLmE7XG5cdFx0dmFyIGIxID0gdGhpcy5iO1xuXG5cdFx0dGhpcy5hID0gYTEqY29zK3RoaXMuYypzaW47XG5cdFx0dGhpcy5iID0gYjEqY29zK3RoaXMuZCpzaW47XG5cdFx0dGhpcy5jID0gLWExKnNpbit0aGlzLmMqY29zO1xuXHRcdHRoaXMuZCA9IC1iMSpzaW4rdGhpcy5kKmNvcztcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQXBwbGllcyBhIHNrZXcgdHJhbnNmb3JtYXRpb24gdG8gdGhlIG1hdHJpeC5cblx0ICogQG1ldGhvZCBza2V3XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBza2V3WCBUaGUgYW1vdW50IHRvIHNrZXcgaG9yaXpvbnRhbGx5IGluIGRlZ3JlZXMuIFRvIHVzZSBhIHZhbHVlIGluIHJhZGlhbnMsIG11bHRpcGx5IGl0IGJ5IGAxODAvTWF0aC5QSWAuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBza2V3WSBUaGUgYW1vdW50IHRvIHNrZXcgdmVydGljYWxseSBpbiBkZWdyZWVzLlxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhpcyBtYXRyaXguIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQqL1xuXHRwLnNrZXcgPSBmdW5jdGlvbihza2V3WCwgc2tld1kpIHtcblx0XHRza2V3WCA9IHNrZXdYKk1hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0c2tld1kgPSBza2V3WSpNYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdHRoaXMuYXBwZW5kKE1hdGguY29zKHNrZXdZKSwgTWF0aC5zaW4oc2tld1kpLCAtTWF0aC5zaW4oc2tld1gpLCBNYXRoLmNvcyhza2V3WCksIDAsIDApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBcHBsaWVzIGEgc2NhbGUgdHJhbnNmb3JtYXRpb24gdG8gdGhlIG1hdHJpeC5cblx0ICogQG1ldGhvZCBzY2FsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgYW1vdW50IHRvIHNjYWxlIGhvcml6b250YWxseS4gRS5HLiBhIHZhbHVlIG9mIDIgd2lsbCBkb3VibGUgdGhlIHNpemUgaW4gdGhlIFggZGlyZWN0aW9uLCBhbmQgMC41IHdpbGwgaGFsdmUgaXQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSBhbW91bnQgdG8gc2NhbGUgdmVydGljYWxseS5cblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLnNjYWxlID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMuYSAqPSB4O1xuXHRcdHRoaXMuYiAqPSB4O1xuXHRcdHRoaXMuYyAqPSB5O1xuXHRcdHRoaXMuZCAqPSB5O1xuXHRcdC8vdGhpcy50eCAqPSB4O1xuXHRcdC8vdGhpcy50eSAqPSB5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUcmFuc2xhdGVzIHRoZSBtYXRyaXggb24gdGhlIHggYW5kIHkgYXhlcy5cblx0ICogQG1ldGhvZCB0cmFuc2xhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLnR4ICs9IHRoaXMuYSp4ICsgdGhpcy5jKnk7XG5cdFx0dGhpcy50eSArPSB0aGlzLmIqeCArIHRoaXMuZCp5O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBtYXRyaXggdG8gdGhvc2Ugb2YgYW4gaWRlbnRpdHkgbWF0cml4IChvbmUgdGhhdCBhcHBsaWVzIGEgbnVsbCB0cmFuc2Zvcm1hdGlvbikuXG5cdCAqIEBtZXRob2QgaWRlbnRpdHlcblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLmlkZW50aXR5ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5hID0gdGhpcy5kID0gMTtcblx0XHR0aGlzLmIgPSB0aGlzLmMgPSB0aGlzLnR4ID0gdGhpcy50eSA9IDA7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEludmVydHMgdGhlIG1hdHJpeCwgY2F1c2luZyBpdCB0byBwZXJmb3JtIHRoZSBvcHBvc2l0ZSB0cmFuc2Zvcm1hdGlvbi5cblx0ICogQG1ldGhvZCBpbnZlcnRcblx0ICogQHJldHVybiB7TWF0cml4MkR9IFRoaXMgbWF0cml4LiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICoqL1xuXHRwLmludmVydCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhMSA9IHRoaXMuYTtcblx0XHR2YXIgYjEgPSB0aGlzLmI7XG5cdFx0dmFyIGMxID0gdGhpcy5jO1xuXHRcdHZhciBkMSA9IHRoaXMuZDtcblx0XHR2YXIgdHgxID0gdGhpcy50eDtcblx0XHR2YXIgbiA9IGExKmQxLWIxKmMxO1xuXG5cdFx0dGhpcy5hID0gZDEvbjtcblx0XHR0aGlzLmIgPSAtYjEvbjtcblx0XHR0aGlzLmMgPSAtYzEvbjtcblx0XHR0aGlzLmQgPSBhMS9uO1xuXHRcdHRoaXMudHggPSAoYzEqdGhpcy50eS1kMSp0eDEpL247XG5cdFx0dGhpcy50eSA9IC0oYTEqdGhpcy50eS1iMSp0eDEpL247XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbWF0cml4IGlzIGFuIGlkZW50aXR5IG1hdHJpeC5cblx0ICogQG1ldGhvZCBpc0lkZW50aXR5XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqKi9cblx0cC5pc0lkZW50aXR5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudHggPT09IDAgJiYgdGhpcy50eSA9PT0gMCAmJiB0aGlzLmEgPT09IDEgJiYgdGhpcy5iID09PSAwICYmIHRoaXMuYyA9PT0gMCAmJiB0aGlzLmQgPT09IDE7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbWF0cml4IGlzIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWQgbWF0cml4IChhbGwgcHJvcGVydHkgdmFsdWVzIGFyZSBlcXVhbCkuXG5cdCAqIEBtZXRob2QgZXF1YWxzXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeCBUaGUgbWF0cml4IHRvIGNvbXBhcmUuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqKi9cblx0cC5lcXVhbHMgPSBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRyZXR1cm4gdGhpcy50eCA9PT0gbWF0cml4LnR4ICYmIHRoaXMudHkgPT09IG1hdHJpeC50eSAmJiB0aGlzLmEgPT09IG1hdHJpeC5hICYmIHRoaXMuYiA9PT0gbWF0cml4LmIgJiYgdGhpcy5jID09PSBtYXRyaXguYyAmJiB0aGlzLmQgPT09IG1hdHJpeC5kO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUcmFuc2Zvcm1zIGEgcG9pbnQgYWNjb3JkaW5nIHRvIHRoaXMgbWF0cml4LlxuXHQgKiBAbWV0aG9kIHRyYW5zZm9ybVBvaW50XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvbXBvbmVudCBvZiB0aGUgcG9pbnQgdG8gdHJhbnNmb3JtLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb21wb25lbnQgb2YgdGhlIHBvaW50IHRvIHRyYW5zZm9ybS5cblx0ICogQHBhcmFtIHtQb2ludCB8IE9iamVjdH0gW3B0XSBBbiBvYmplY3QgdG8gY29weSB0aGUgcmVzdWx0IGludG8uIElmIG9taXR0ZWQgYSBnZW5lcmljIG9iamVjdCB3aXRoIHgveSBwcm9wZXJ0aWVzIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEByZXR1cm4ge1BvaW50fSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqKi9cblx0cC50cmFuc2Zvcm1Qb2ludCA9IGZ1bmN0aW9uKHgsIHksIHB0KSB7XG5cdFx0cHQgPSBwdHx8e307XG5cdFx0cHQueCA9IHgqdGhpcy5hK3kqdGhpcy5jK3RoaXMudHg7XG5cdFx0cHQueSA9IHgqdGhpcy5iK3kqdGhpcy5kK3RoaXMudHk7XG5cdFx0cmV0dXJuIHB0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZWNvbXBvc2VzIHRoZSBtYXRyaXggaW50byB0cmFuc2Zvcm0gcHJvcGVydGllcyAoeCwgeSwgc2NhbGVYLCBzY2FsZVksIGFuZCByb3RhdGlvbikuIE5vdGUgdGhhdCB0aGVzZSB2YWx1ZXNcblx0ICogbWF5IG5vdCBtYXRjaCB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMgeW91IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIG1hdHJpeCwgdGhvdWdoIHRoZXkgd2lsbCBwcm9kdWNlIHRoZSBzYW1lIHZpc3VhbFxuXHQgKiByZXN1bHRzLlxuXHQgKiBAbWV0aG9kIGRlY29tcG9zZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdG8gYXBwbHkgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0aWVzIHRvLiBJZiBudWxsLCB0aGVuIGEgbmV3IG9iamVjdCB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSB0YXJnZXQsIG9yIGEgbmV3IGdlbmVyaWMgb2JqZWN0IHdpdGggdGhlIHRyYW5zZm9ybSBwcm9wZXJ0aWVzIGFwcGxpZWQuXG5cdCovXG5cdHAuZGVjb21wb3NlID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0Ly8gVE9ETzogaXQgd291bGQgYmUgbmljZSB0byBiZSBhYmxlIHRvIHNvbHZlIGZvciB3aGV0aGVyIHRoZSBtYXRyaXggY2FuIGJlIGRlY29tcG9zZWQgaW50byBvbmx5IHNjYWxlL3JvdGF0aW9uIGV2ZW4gd2hlbiBzY2FsZSBpcyBuZWdhdGl2ZVxuXHRcdGlmICh0YXJnZXQgPT0gbnVsbCkgeyB0YXJnZXQgPSB7fTsgfVxuXHRcdHRhcmdldC54ID0gdGhpcy50eDtcblx0XHR0YXJnZXQueSA9IHRoaXMudHk7XG5cdFx0dGFyZ2V0LnNjYWxlWCA9IE1hdGguc3FydCh0aGlzLmEgKiB0aGlzLmEgKyB0aGlzLmIgKiB0aGlzLmIpO1xuXHRcdHRhcmdldC5zY2FsZVkgPSBNYXRoLnNxcnQodGhpcy5jICogdGhpcy5jICsgdGhpcy5kICogdGhpcy5kKTtcblxuXHRcdHZhciBza2V3WCA9IE1hdGguYXRhbjIoLXRoaXMuYywgdGhpcy5kKTtcblx0XHR2YXIgc2tld1kgPSBNYXRoLmF0YW4yKHRoaXMuYiwgdGhpcy5hKTtcblxuXHRcdHZhciBkZWx0YSA9IE1hdGguYWJzKDEtc2tld1gvc2tld1kpO1xuXHRcdGlmIChkZWx0YSA8IDAuMDAwMDEpIHsgLy8gZWZmZWN0aXZlbHkgaWRlbnRpY2FsLCBjYW4gdXNlIHJvdGF0aW9uOlxuXHRcdFx0dGFyZ2V0LnJvdGF0aW9uID0gc2tld1kvTWF0cml4MkQuREVHX1RPX1JBRDtcblx0XHRcdGlmICh0aGlzLmEgPCAwICYmIHRoaXMuZCA+PSAwKSB7XG5cdFx0XHRcdHRhcmdldC5yb3RhdGlvbiArPSAodGFyZ2V0LnJvdGF0aW9uIDw9IDApID8gMTgwIDogLTE4MDtcblx0XHRcdH1cblx0XHRcdHRhcmdldC5za2V3WCA9IHRhcmdldC5za2V3WSA9IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5za2V3WCA9IHNrZXdYL01hdHJpeDJELkRFR19UT19SQUQ7XG5cdFx0XHR0YXJnZXQuc2tld1kgPSBza2V3WS9NYXRyaXgyRC5ERUdfVE9fUkFEO1xuXHRcdH1cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENvcGllcyBhbGwgcHJvcGVydGllcyBmcm9tIHRoZSBzcGVjaWZpZWQgbWF0cml4IHRvIHRoaXMgbWF0cml4LlxuXHQgKiBAbWV0aG9kIGNvcHlcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4IFRoZSBtYXRyaXggdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBUaGlzIG1hdHJpeC4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCovXG5cdHAuY29weSA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHJldHVybiB0aGlzLnNldFZhbHVlcyhtYXRyaXguYSwgbWF0cml4LmIsIG1hdHJpeC5jLCBtYXRyaXguZCwgbWF0cml4LnR4LCBtYXRyaXgudHkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIE1hdHJpeDJEIGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBhIGNsb25lIG9mIHRoZSBNYXRyaXgyRCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBNYXRyaXgyRCh0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCB0aGlzLmQsIHRoaXMudHgsIHRoaXMudHkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbTWF0cml4MkQgKGE9XCIrdGhpcy5hK1wiIGI9XCIrdGhpcy5iK1wiIGM9XCIrdGhpcy5jK1wiIGQ9XCIrdGhpcy5kK1wiIHR4PVwiK3RoaXMudHgrXCIgdHk9XCIrdGhpcy50eStcIildXCI7XG5cdH07XG5cblx0Ly8gdGhpcyBoYXMgdG8gYmUgcG9wdWxhdGVkIGFmdGVyIHRoZSBjbGFzcyBpcyBkZWZpbmVkOlxuXHRNYXRyaXgyRC5pZGVudGl0eSA9IG5ldyBNYXRyaXgyRCgpO1xuXG5cblx0Y3JlYXRlanMuTWF0cml4MkQgPSBNYXRyaXgyRDtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBEaXNwbGF5UHJvcHMuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogVXNlZCBmb3IgY2FsY3VsYXRpbmcgYW5kIGVuY2Fwc3VsYXRpbmcgZGlzcGxheSByZWxhdGVkIHByb3BlcnRpZXMuXG5cdCAqIEBjbGFzcyBEaXNwbGF5UHJvcHNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt2aXNpYmxlPXRydWVdIFZpc2libGUgdmFsdWUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYWxwaGE9MF0gQWxwaGEgdmFsdWUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2hhZG93PW51bGxdIEEgU2hhZG93IGluc3RhbmNlIG9yIG51bGwuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbY29tcG9zaXRlT3BlcmF0aW9uPW51bGxdIEEgY29tcG9zaXRlT3BlcmF0aW9uIHZhbHVlIG9yIG51bGwuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbWF0cml4XSBBIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC4gRGVmYXVsdHMgdG8gYSBuZXcgaWRlbnRpdHkgbWF0cml4LlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBEaXNwbGF5UHJvcHModmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgY29tcG9zaXRlT3BlcmF0aW9uLCBtYXRyaXgpIHtcblx0XHR0aGlzLnNldFZhbHVlcyh2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBjb21wb3NpdGVPcGVyYXRpb24sIG1hdHJpeCk7XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8vIGFzc2lnbmVkIGluIHRoZSBzZXRWYWx1ZXMgbWV0aG9kLlxuXHRcdC8qKlxuXHRcdCAqIFByb3BlcnR5IHJlcHJlc2VudGluZyB0aGUgYWxwaGEgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYSBkaXNwbGF5IG9iamVjdC5cblx0XHQgKiBAcHJvcGVydHkgYWxwaGFcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFByb3BlcnR5IHJlcHJlc2VudGluZyB0aGUgc2hhZG93IHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGEgZGlzcGxheSBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IHNoYWRvd1xuXHRcdCAqIEB0eXBlIFNoYWRvd1xuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogUHJvcGVydHkgcmVwcmVzZW50aW5nIHRoZSBjb21wb3NpdGVPcGVyYXRpb24gdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYSBkaXNwbGF5IG9iamVjdC5cblx0XHQgKiBZb3UgY2FuIGZpbmQgYSBsaXN0IG9mIHZhbGlkIGNvbXBvc2l0ZSBvcGVyYXRpb25zIGF0OlxuXHRcdCAqIDxhIGhyZWY9XCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9DYW52YXNfdHV0b3JpYWwvQ29tcG9zaXRpbmdcIj5odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9DYW52YXNfdHV0b3JpYWwvQ29tcG9zaXRpbmc8L2E+XG5cdFx0ICogQHByb3BlcnR5IGNvbXBvc2l0ZU9wZXJhdGlvblxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqKi9cblx0XHRcblx0XHQvKipcblx0XHQgKiBQcm9wZXJ0eSByZXByZXNlbnRpbmcgdGhlIHZhbHVlIGZvciB2aXNpYmxlIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGEgZGlzcGxheSBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IHZpc2libGVcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICoqL1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYSBkaXNwbGF5IG9iamVjdC5cblx0XHQgKiBAcHJvcGVydHkgbWF0cml4XG5cdFx0ICogQHR5cGUgTWF0cml4MkRcblx0XHQgKiovXG5cdH1cblx0dmFyIHAgPSBEaXNwbGF5UHJvcHMucHJvdG90eXBlO1xuXG4vLyBpbml0aWFsaXphdGlvbjpcblx0LyoqXG5cdCAqIFJlaW5pdGlhbGl6ZXMgdGhlIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZXMuXG5cdCAqIEBtZXRob2Qgc2V0VmFsdWVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdmlzaWJsZT10cnVlXSBWaXNpYmxlIHZhbHVlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2FscGhhPTFdIEFscGhhIHZhbHVlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NoYWRvdz1udWxsXSBBIFNoYWRvdyBpbnN0YW5jZSBvciBudWxsLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2NvbXBvc2l0ZU9wZXJhdGlvbj1udWxsXSBBIGNvbXBvc2l0ZU9wZXJhdGlvbiB2YWx1ZSBvciBudWxsLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW21hdHJpeF0gQSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguIERlZmF1bHRzIHRvIGFuIGlkZW50aXR5IG1hdHJpeC5cblx0ICogQHJldHVybiB7RGlzcGxheVByb3BzfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLnNldFZhbHVlcyA9IGZ1bmN0aW9uICh2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBjb21wb3NpdGVPcGVyYXRpb24sIG1hdHJpeCkge1xuXHRcdHRoaXMudmlzaWJsZSA9IHZpc2libGUgPT0gbnVsbCA/IHRydWUgOiAhIXZpc2libGU7XG5cdFx0dGhpcy5hbHBoYSA9IGFscGhhID09IG51bGwgPyAxIDogYWxwaGE7XG5cdFx0dGhpcy5zaGFkb3cgPSBzaGFkb3c7XG5cdFx0dGhpcy5jb21wb3NpdGVPcGVyYXRpb24gPSBzaGFkb3c7XG5cdFx0dGhpcy5tYXRyaXggPSBtYXRyaXggfHwgKHRoaXMubWF0cml4JiZ0aGlzLm1hdHJpeC5pZGVudGl0eSgpKSB8fCBuZXcgY3JlYXRlanMuTWF0cml4MkQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBBcHBlbmRzIHRoZSBzcGVjaWZpZWQgZGlzcGxheSBwcm9wZXJ0aWVzLiBUaGlzIGlzIGdlbmVyYWxseSB1c2VkIHRvIGFwcGx5IGEgY2hpbGQncyBwcm9wZXJ0aWVzIGl0cyBwYXJlbnQncy5cblx0ICogQG1ldGhvZCBhcHBlbmRcblx0ICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlIGRlc2lyZWQgdmlzaWJsZSB2YWx1ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gYWxwaGEgZGVzaXJlZCBhbHBoYSB2YWx1ZVxuXHQgKiBAcGFyYW0ge1NoYWRvd30gc2hhZG93IGRlc2lyZWQgc2hhZG93IHZhbHVlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb3NpdGVPcGVyYXRpb24gZGVzaXJlZCBjb21wb3NpdGUgb3BlcmF0aW9uIHZhbHVlXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IFttYXRyaXhdIGEgTWF0cml4MkQgaW5zdGFuY2Vcblx0ICogQHJldHVybiB7RGlzcGxheVByb3BzfSBUaGlzIGluc3RhbmNlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLmFwcGVuZCA9IGZ1bmN0aW9uKHZpc2libGUsIGFscGhhLCBzaGFkb3csIGNvbXBvc2l0ZU9wZXJhdGlvbiwgbWF0cml4KSB7XG5cdFx0dGhpcy5hbHBoYSAqPSBhbHBoYTtcblx0XHR0aGlzLnNoYWRvdyA9IHNoYWRvdyB8fCB0aGlzLnNoYWRvdztcblx0XHR0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbiA9IGNvbXBvc2l0ZU9wZXJhdGlvbiB8fCB0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbjtcblx0XHR0aGlzLnZpc2libGUgPSB0aGlzLnZpc2libGUgJiYgdmlzaWJsZTtcblx0XHRtYXRyaXgmJnRoaXMubWF0cml4LmFwcGVuZE1hdHJpeChtYXRyaXgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFByZXBlbmRzIHRoZSBzcGVjaWZpZWQgZGlzcGxheSBwcm9wZXJ0aWVzLiBUaGlzIGlzIGdlbmVyYWxseSB1c2VkIHRvIGFwcGx5IGEgcGFyZW50J3MgcHJvcGVydGllcyB0byBhIGNoaWxkJ3MuXG5cdCAqIEZvciBleGFtcGxlLCB0byBnZXQgdGhlIGNvbWJpbmVkIGRpc3BsYXkgcHJvcGVydGllcyB0aGF0IHdvdWxkIGJlIGFwcGxpZWQgdG8gYSBjaGlsZCwgeW91IGNvdWxkIHVzZTpcblx0ICogXG5cdCAqIFx0dmFyIG8gPSBteURpc3BsYXlPYmplY3Q7XG5cdCAqIFx0dmFyIHByb3BzID0gbmV3IGNyZWF0ZWpzLkRpc3BsYXlQcm9wcygpO1xuXHQgKiBcdGRvIHtcblx0ICogXHRcdC8vIHByZXBlbmQgZWFjaCBwYXJlbnQncyBwcm9wcyBpbiB0dXJuOlxuXHQgKiBcdFx0cHJvcHMucHJlcGVuZChvLnZpc2libGUsIG8uYWxwaGEsIG8uc2hhZG93LCBvLmNvbXBvc2l0ZU9wZXJhdGlvbiwgby5nZXRNYXRyaXgoKSk7XG5cdCAqIFx0fSB3aGlsZSAobyA9IG8ucGFyZW50KTtcblx0ICogXHRcblx0ICogQG1ldGhvZCBwcmVwZW5kXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmlzaWJsZSBkZXNpcmVkIHZpc2libGUgdmFsdWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFscGhhIGRlc2lyZWQgYWxwaGEgdmFsdWVcblx0ICogQHBhcmFtIHtTaGFkb3d9IHNoYWRvdyBkZXNpcmVkIHNoYWRvdyB2YWx1ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9zaXRlT3BlcmF0aW9uIGRlc2lyZWQgY29tcG9zaXRlIG9wZXJhdGlvbiB2YWx1ZVxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBbbWF0cml4XSBhIE1hdHJpeDJEIGluc3RhbmNlXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlQcm9wc30gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5wcmVwZW5kID0gZnVuY3Rpb24odmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgY29tcG9zaXRlT3BlcmF0aW9uLCBtYXRyaXgpIHtcblx0XHR0aGlzLmFscGhhICo9IGFscGhhO1xuXHRcdHRoaXMuc2hhZG93ID0gdGhpcy5zaGFkb3cgfHwgc2hhZG93O1xuXHRcdHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uID0gdGhpcy5jb21wb3NpdGVPcGVyYXRpb24gfHwgY29tcG9zaXRlT3BlcmF0aW9uO1xuXHRcdHRoaXMudmlzaWJsZSA9IHRoaXMudmlzaWJsZSAmJiB2aXNpYmxlO1xuXHRcdG1hdHJpeCYmdGhpcy5tYXRyaXgucHJlcGVuZE1hdHJpeChtYXRyaXgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJlc2V0cyB0aGlzIGluc3RhbmNlIGFuZCBpdHMgbWF0cml4IHRvIGRlZmF1bHQgdmFsdWVzLlxuXHQgKiBAbWV0aG9kIGlkZW50aXR5XG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlQcm9wc30gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5pZGVudGl0eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cdFx0dGhpcy5hbHBoYSA9IDE7XG5cdFx0dGhpcy5zaGFkb3cgPSB0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbiA9IG51bGw7XG5cdFx0dGhpcy5tYXRyaXguaWRlbnRpdHkoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIERpc3BsYXlQcm9wcyBpbnN0YW5jZS4gQ2xvbmVzIHRoZSBhc3NvY2lhdGVkIG1hdHJpeC5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5UHJvcHN9IGEgY2xvbmUgb2YgdGhlIERpc3BsYXlQcm9wcyBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBEaXNwbGF5UHJvcHModGhpcy5hbHBoYSwgdGhpcy5zaGFkb3csIHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uLCB0aGlzLnZpc2libGUsIHRoaXMubWF0cml4LmNsb25lKCkpO1xuXHR9O1xuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cblx0Y3JlYXRlanMuRGlzcGxheVByb3BzID0gRGlzcGxheVByb3BzO1xufSkoKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFBvaW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBSZXByZXNlbnRzIGEgcG9pbnQgb24gYSAyIGRpbWVuc2lvbmFsIHggLyB5IGNvb3JkaW5hdGUgc3lzdGVtLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIFxuXHQgKiAgICAgIHZhciBwb2ludCA9IG5ldyBjcmVhdGVqcy5Qb2ludCgwLCAxMDApO1xuXHQgKiBcblx0ICogQGNsYXNzIFBvaW50XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSBYIHBvc2l0aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gWSBwb3NpdGlvbi5cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gUG9pbnQoeCwgeSkge1xuXHQgXHR0aGlzLnNldFZhbHVlcyh4LCB5KTtcblx0IFx0XG5cdCBcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvLyBhc3NpZ25lZCBpbiB0aGUgc2V0VmFsdWVzIG1ldGhvZC5cblx0XHQvKipcblx0XHQgKiBYIHBvc2l0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSB4XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcblx0XHQvKipcblx0XHQgKiBZIHBvc2l0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSB5XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHR9XG5cdHZhciBwID0gUG9pbnQucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXHRcbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKiogXG5cdCAqIFNldHMgdGhlIHNwZWNpZmllZCB2YWx1ZXMgb24gdGhpcyBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBzZXRWYWx1ZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIFggcG9zaXRpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSBZIHBvc2l0aW9uLlxuXHQgKiBAcmV0dXJuIHtQb2ludH0gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5zZXRWYWx1ZXMgPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0dGhpcy54ID0geHx8MDtcblx0XHR0aGlzLnkgPSB5fHwwO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENvcGllcyBhbGwgcHJvcGVydGllcyBmcm9tIHRoZSBzcGVjaWZpZWQgcG9pbnQgdG8gdGhpcyBwb2ludC5cblx0ICogQG1ldGhvZCBjb3B5XG5cdCAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IFRoZSBwb2ludCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cblx0ICogQHJldHVybiB7UG9pbnR9IFRoaXMgcG9pbnQuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAuY29weSA9IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dGhpcy54ID0gcG9pbnQueDtcblx0XHR0aGlzLnkgPSBwb2ludC55O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgUG9pbnQgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7UG9pbnR9IGEgY2xvbmUgb2YgdGhlIFBvaW50IGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1BvaW50ICh4PVwiK3RoaXMueCtcIiB5PVwiK3RoaXMueStcIildXCI7XG5cdH07XG5cdFxuXHRcblx0Y3JlYXRlanMuUG9pbnQgPSBQb2ludDtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBSZWN0YW5nbGUuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFJlcHJlc2VudHMgYSByZWN0YW5nbGUgYXMgZGVmaW5lZCBieSB0aGUgcG9pbnRzICh4LCB5KSBhbmQgKHgrd2lkdGgsIHkraGVpZ2h0KS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciByZWN0ID0gbmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqXG5cdCAqIEBjbGFzcyBSZWN0YW5nbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIFggcG9zaXRpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSBZIHBvc2l0aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTBdIFRoZSB3aWR0aCBvZiB0aGUgUmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodD0wXSBUaGUgaGVpZ2h0IG9mIHRoZSBSZWN0YW5nbGUuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dGhpcy5zZXRWYWx1ZXMoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cdFx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8vIGFzc2lnbmVkIGluIHRoZSBzZXRWYWx1ZXMgbWV0aG9kLlxuXHRcdC8qKlxuXHRcdCAqIFggcG9zaXRpb24uXG5cdFx0ICogQHByb3BlcnR5IHhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFkgcG9zaXRpb24uXG5cdFx0ICogQHByb3BlcnR5IHlcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFxuXHRcdC8qKlxuXHRcdCAqIFdpZHRoLlxuXHRcdCAqIEBwcm9wZXJ0eSB3aWR0aFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XG5cdFx0LyoqXG5cdFx0ICogSGVpZ2h0LlxuXHRcdCAqIEBwcm9wZXJ0eSBoZWlnaHRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdH1cblx0dmFyIHAgPSBSZWN0YW5nbGUucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqIFxuXHQgKiBTZXRzIHRoZSBzcGVjaWZpZWQgdmFsdWVzIG9uIHRoaXMgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2Qgc2V0VmFsdWVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSBYIHBvc2l0aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gWSBwb3NpdGlvbi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aD0wXSBUaGUgd2lkdGggb2YgdGhlIFJlY3RhbmdsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQ9MF0gVGhlIGhlaWdodCBvZiB0aGUgUmVjdGFuZ2xlLlxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAuc2V0VmFsdWVzID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdC8vIGRvbid0IGZvcmdldCB0byB1cGRhdGUgZG9jcyBpbiB0aGUgY29uc3RydWN0b3IgaWYgdGhlc2UgY2hhbmdlOlxuXHRcdHRoaXMueCA9IHh8fDA7XG5cdFx0dGhpcy55ID0geXx8MDtcblx0XHR0aGlzLndpZHRoID0gd2lkdGh8fDA7XG5cdFx0dGhpcy5oZWlnaHQgPSBoZWlnaHR8fDA7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKiogXG5cdCAqIEV4dGVuZHMgdGhlIHJlY3RhbmdsZSdzIGJvdW5kcyB0byBpbmNsdWRlIHRoZSBkZXNjcmliZWQgcG9pbnQgb3IgcmVjdGFuZ2xlLlxuXHQgKiBAbWV0aG9kIGV4dGVuZFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBYIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvciByZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgcG9zaXRpb24gb2YgdGhlIHBvaW50IG9yIHJlY3RhbmdsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aD0wXSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQ9MF0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLlxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IFRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCovXG5cdHAuZXh0ZW5kID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdHdpZHRoID0gd2lkdGh8fDA7XG5cdFx0aGVpZ2h0ID0gaGVpZ2h0fHwwO1xuXHRcdGlmICh4K3dpZHRoID4gdGhpcy54K3RoaXMud2lkdGgpIHsgdGhpcy53aWR0aCA9IHgrd2lkdGgtdGhpcy54OyB9XG5cdFx0aWYgKHkraGVpZ2h0ID4gdGhpcy55K3RoaXMuaGVpZ2h0KSB7IHRoaXMuaGVpZ2h0ID0geStoZWlnaHQtdGhpcy55OyB9XG5cdFx0aWYgKHggPCB0aGlzLngpIHsgdGhpcy53aWR0aCArPSB0aGlzLngteDsgdGhpcy54ID0geDsgfVxuXHRcdGlmICh5IDwgdGhpcy55KSB7IHRoaXMuaGVpZ2h0ICs9IHRoaXMueS15OyB0aGlzLnkgPSB5OyB9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKiogXG5cdCAqIEFkZHMgdGhlIHNwZWNpZmllZCBwYWRkaW5nIHRvIHRoZSByZWN0YW5nbGUncyBib3VuZHMuXG5cdCAqIEBtZXRob2QgZXh0ZW5kXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdG9wPTBdXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbGVmdD0wXVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3JpZ2h0PTBdXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYm90dG9tPTBdXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gVGhpcyBpbnN0YW5jZS4gVXNlZnVsIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG5cdCAqIEBjaGFpbmFibGVcblx0Ki9cblx0cC5wYWQgPSBmdW5jdGlvbih0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQpIHtcblx0XHR0aGlzLnggLT0gbGVmdDtcblx0XHR0aGlzLnkgLT0gdG9wO1xuXHRcdHRoaXMud2lkdGggKz0gbGVmdCtyaWdodDtcblx0XHR0aGlzLmhlaWdodCArPSB0b3ArYm90dG9tO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENvcGllcyBhbGwgcHJvcGVydGllcyBmcm9tIHRoZSBzcGVjaWZpZWQgcmVjdGFuZ2xlIHRvIHRoaXMgcmVjdGFuZ2xlLlxuXHQgKiBAbWV0aG9kIGNvcHlcblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3RhbmdsZSBUaGUgcmVjdGFuZ2xlIHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IFRoaXMgcmVjdGFuZ2xlLiBVc2VmdWwgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLmNvcHkgPSBmdW5jdGlvbihyZWN0YW5nbGUpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRWYWx1ZXMocmVjdGFuZ2xlLngsIHJlY3RhbmdsZS55LCByZWN0YW5nbGUud2lkdGgsIHJlY3RhbmdsZS5oZWlnaHQpO1xuXHR9O1xuXHRcblx0LyoqIFxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyByZWN0YW5nbGUgZnVsbHkgZW5jbG9zZXMgdGhlIGRlc2NyaWJlZCBwb2ludCBvciByZWN0YW5nbGUuXG5cdCAqIEBtZXRob2QgY29udGFpbnNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggWCBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb3IgcmVjdGFuZ2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBZIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvciByZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGg9MF0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0PTBdIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgZGVzY3JpYmVkIHBvaW50IG9yIHJlY3RhbmdsZSBpcyBjb250YWluZWQgd2l0aGluIHRoaXMgcmVjdGFuZ2xlLlxuXHQqL1xuXHRwLmNvbnRhaW5zID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdHdpZHRoID0gd2lkdGh8fDA7XG5cdFx0aGVpZ2h0ID0gaGVpZ2h0fHwwO1xuXHRcdHJldHVybiAoeCA+PSB0aGlzLnggJiYgeCt3aWR0aCA8PSB0aGlzLngrdGhpcy53aWR0aCAmJiB5ID49IHRoaXMueSAmJiB5K2hlaWdodCA8PSB0aGlzLnkrdGhpcy5oZWlnaHQpO1xuXHR9O1xuXHRcblx0LyoqIFxuXHQgKiBSZXR1cm5zIGEgbmV3IHJlY3RhbmdsZSB3aGljaCBjb250YWlucyB0aGlzIHJlY3RhbmdsZSBhbmQgdGhlIHNwZWNpZmllZCByZWN0YW5nbGUuXG5cdCAqIEBtZXRob2QgdW5pb25cblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QgVGhlIHJlY3RhbmdsZSB0byBjYWxjdWxhdGUgYSB1bmlvbiB3aXRoLlxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IEEgbmV3IHJlY3RhbmdsZSBkZXNjcmliaW5nIHRoZSB1bmlvbi5cblx0Ki9cblx0cC51bmlvbiA9IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLmV4dGVuZChyZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuXHR9O1xuXHRcblx0LyoqIFxuXHQgKiBSZXR1cm5zIGEgbmV3IHJlY3RhbmdsZSB3aGljaCBkZXNjcmliZXMgdGhlIGludGVyc2VjdGlvbiAob3ZlcmxhcCkgb2YgdGhpcyByZWN0YW5nbGUgYW5kIHRoZSBzcGVjaWZpZWQgcmVjdGFuZ2xlLFxuXHQgKiBvciBudWxsIGlmIHRoZXkgZG8gbm90IGludGVyc2VjdC5cblx0ICogQG1ldGhvZCBpbnRlcnNlY3Rpb25cblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QgVGhlIHJlY3RhbmdsZSB0byBjYWxjdWxhdGUgYW4gaW50ZXJzZWN0aW9uIHdpdGguXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gQSBuZXcgcmVjdGFuZ2xlIGRlc2NyaWJpbmcgdGhlIGludGVyc2VjdGlvbiBvciBudWxsLlxuXHQqL1xuXHRwLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHR2YXIgeDEgPSByZWN0LngsIHkxID0gcmVjdC55LCB4MiA9IHgxK3JlY3Qud2lkdGgsIHkyID0geTErcmVjdC5oZWlnaHQ7XG5cdFx0aWYgKHRoaXMueCA+IHgxKSB7IHgxID0gdGhpcy54OyB9XG5cdFx0aWYgKHRoaXMueSA+IHkxKSB7IHkxID0gdGhpcy55OyB9XG5cdFx0aWYgKHRoaXMueCArIHRoaXMud2lkdGggPCB4MikgeyB4MiA9IHRoaXMueCArIHRoaXMud2lkdGg7IH1cblx0XHRpZiAodGhpcy55ICsgdGhpcy5oZWlnaHQgPCB5MikgeyB5MiA9IHRoaXMueSArIHRoaXMuaGVpZ2h0OyB9XG5cdFx0cmV0dXJuICh4MiA8PSB4MSB8fCB5MiA8PSB5MSkgPyBudWxsIDogbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyLXgxLCB5Mi15MSk7XG5cdH07XG5cdFxuXHQvKiogXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHJlY3RhbmdsZSBpbnRlcnNlY3RzIChoYXMgYW55IG92ZXJsYXApIHdpdGggdGhpcyByZWN0YW5nbGUuXG5cdCAqIEBtZXRob2QgaW50ZXJzZWN0c1xuXHQgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdCBUaGUgcmVjdGFuZ2xlIHRvIGNvbXBhcmUuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHJlY3RhbmdsZXMgaW50ZXJzZWN0LlxuXHQqL1xuXHRwLmludGVyc2VjdHMgPSBmdW5jdGlvbihyZWN0KSB7XG5cdFx0cmV0dXJuIChyZWN0LnggPD0gdGhpcy54K3RoaXMud2lkdGggJiYgdGhpcy54IDw9IHJlY3QueCtyZWN0LndpZHRoICYmIHJlY3QueSA8PSB0aGlzLnkrdGhpcy5oZWlnaHQgJiYgdGhpcy55IDw9IHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcblx0fTtcblx0XG5cdC8qKiBcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSB3aWR0aCBvciBoZWlnaHQgYXJlIGVxdWFsIG9yIGxlc3MgdGhhbiAwLlxuXHQgKiBAbWV0aG9kIGlzRW1wdHlcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcmVjdGFuZ2xlIGlzIGVtcHR5LlxuXHQqL1xuXHRwLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDA7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBSZWN0YW5nbGUgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBhIGNsb25lIG9mIHRoZSBSZWN0YW5nbGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltSZWN0YW5nbGUgKHg9XCIrdGhpcy54K1wiIHk9XCIrdGhpcy55K1wiIHdpZHRoPVwiK3RoaXMud2lkdGgrXCIgaGVpZ2h0PVwiK3RoaXMuaGVpZ2h0K1wiKV1cIjtcblx0fTtcblx0XG5cdFxuXHRjcmVhdGVqcy5SZWN0YW5nbGUgPSBSZWN0YW5nbGU7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQnV0dG9uSGVscGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBUaGUgQnV0dG9uSGVscGVyIGlzIGEgaGVscGVyIGNsYXNzIHRvIGNyZWF0ZSBpbnRlcmFjdGl2ZSBidXR0b25zIGZyb20ge3sjY3Jvc3NMaW5rIFwiTW92aWVDbGlwXCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNwcml0ZVwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZXMuIFRoaXMgY2xhc3Mgd2lsbCBpbnRlcmNlcHQgbW91c2UgZXZlbnRzIGZyb20gYW4gb2JqZWN0LCBhbmRcblx0ICogYXV0b21hdGljYWxseSBjYWxsIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9nb3RvQW5kU3RvcFwifX17ey9jcm9zc0xpbmt9fSBvciB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIHRvIHRoZSByZXNwZWN0aXZlIGFuaW1hdGlvbiBsYWJlbHMsIGFkZCBhIHBvaW50ZXIgY3Vyc29yLCBhbmQgYWxsb3dzIHRoZSB1c2VyIHRvIGRlZmluZSBhIGhpdCBzdGF0ZSBmcmFtZS5cblx0ICpcblx0ICogVGhlIEJ1dHRvbkhlbHBlciBpbnN0YW5jZSBkb2VzIG5vdCBuZWVkIHRvIGJlIGFkZGVkIHRvIHRoZSBzdGFnZSwgYnV0IGEgcmVmZXJlbmNlIHNob3VsZCBiZSBtYWludGFpbmVkIHRvIHByZXZlbnRcblx0ICogZ2FyYmFnZSBjb2xsZWN0aW9uLlxuXHQgKiBcblx0ICogTm90ZSB0aGF0IG92ZXIgc3RhdGVzIHdpbGwgbm90IHdvcmsgdW5sZXNzIHlvdSBjYWxsIHt7I2Nyb3NzTGluayBcIlN0YWdlL2VuYWJsZU1vdXNlT3ZlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBoZWxwZXIgPSBuZXcgY3JlYXRlanMuQnV0dG9uSGVscGVyKG15SW5zdGFuY2UsIFwib3V0XCIsIFwib3ZlclwiLCBcImRvd25cIiwgZmFsc2UsIG15SW5zdGFuY2UsIFwiaGl0XCIpO1xuXHQgKiAgICAgIG15SW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrKTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuXHQgKiAgICAgICAgICAvLyBDbGljayBIYXBwZW5lZC5cblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBjbGFzcyBCdXR0b25IZWxwZXJcblx0ICogQHBhcmFtIHtTcHJpdGV8TW92aWVDbGlwfSB0YXJnZXQgVGhlIGluc3RhbmNlIHRvIG1hbmFnZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtvdXRMYWJlbD1cIm91dFwiXSBUaGUgbGFiZWwgb3IgYW5pbWF0aW9uIHRvIGdvIHRvIHdoZW4gdGhlIHVzZXIgcm9sbHMgb3V0IG9mIHRoZSBidXR0b24uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbb3ZlckxhYmVsPVwib3ZlclwiXSBUaGUgbGFiZWwgb3IgYW5pbWF0aW9uIHRvIGdvIHRvIHdoZW4gdGhlIHVzZXIgcm9sbHMgb3ZlciB0aGUgYnV0dG9uLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2Rvd25MYWJlbD1cImRvd25cIl0gVGhlIGxhYmVsIG9yIGFuaW1hdGlvbiB0byBnbyB0byB3aGVuIHRoZSB1c2VyIHByZXNzZXMgdGhlIGJ1dHRvbi5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcGxheT1mYWxzZV0gSWYgdGhlIGhlbHBlciBzaG91bGQgY2FsbCBcImdvdG9BbmRQbGF5XCIgb3IgXCJnb3RvQW5kU3RvcFwiIG9uIHRoZSBidXR0b24gd2hlbiBjaGFuZ2luZ1xuXHQgKiBzdGF0ZXMuXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gW2hpdEFyZWFdIEFuIG9wdGlvbmFsIGl0ZW0gdG8gdXNlIGFzIHRoZSBoaXQgc3RhdGUgZm9yIHRoZSBidXR0b24uIElmIHRoaXMgaXMgbm90IGRlZmluZWQsXG5cdCAqIHRoZW4gdGhlIGJ1dHRvbidzIHZpc2libGUgc3RhdGVzIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBOb3RlIHRoYXQgdGhlIHNhbWUgaW5zdGFuY2UgYXMgdGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgY2FuIGJlXG5cdCAqIHVzZWQgZm9yIHRoZSBoaXRTdGF0ZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtoaXRMYWJlbF0gVGhlIGxhYmVsIG9yIGFuaW1hdGlvbiBvbiB0aGUgaGl0QXJlYSBpbnN0YW5jZSB0aGF0IGRlZmluZXMgdGhlIGhpdEFyZWEgYm91bmRzLiBJZiB0aGlzIGlzXG5cdCAqIG51bGwsIHRoZW4gdGhlIGRlZmF1bHQgc3RhdGUgb2YgdGhlIGhpdEFyZWEgd2lsbCBiZSB1c2VkLiAqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gQnV0dG9uSGVscGVyKHRhcmdldCwgb3V0TGFiZWwsIG92ZXJMYWJlbCwgZG93bkxhYmVsLCBwbGF5LCBoaXRBcmVhLCBoaXRMYWJlbCkge1xuXHRcdGlmICghdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHsgcmV0dXJuOyB9XG5cdFxuXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIHRhcmdldCBmb3IgdGhpcyBidXR0b24gaGVscGVyLlxuXHRcdCAqIEBwcm9wZXJ0eSB0YXJnZXRcblx0XHQgKiBAdHlwZSBNb3ZpZUNsaXAgfCBTcHJpdGVcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsYWJlbCBuYW1lIG9yIGZyYW1lIG51bWJlciB0byBkaXNwbGF5IHdoZW4gdGhlIHVzZXIgbW91c2VzIG91dCBvZiB0aGUgdGFyZ2V0LiBEZWZhdWx0cyB0byBcIm92ZXJcIi5cblx0XHQgKiBAcHJvcGVydHkgb3ZlckxhYmVsXG5cdFx0ICogQHR5cGUgU3RyaW5nIHwgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMub3ZlckxhYmVsID0gb3ZlckxhYmVsID09IG51bGwgPyBcIm92ZXJcIiA6IG92ZXJMYWJlbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGxhYmVsIG5hbWUgb3IgZnJhbWUgbnVtYmVyIHRvIGRpc3BsYXkgd2hlbiB0aGUgdXNlciBtb3VzZXMgb3ZlciB0aGUgdGFyZ2V0LiBEZWZhdWx0cyB0byBcIm91dFwiLlxuXHRcdCAqIEBwcm9wZXJ0eSBvdXRMYWJlbFxuXHRcdCAqIEB0eXBlIFN0cmluZyB8IE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLm91dExhYmVsID0gb3V0TGFiZWwgPT0gbnVsbCA/IFwib3V0XCIgOiBvdXRMYWJlbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGxhYmVsIG5hbWUgb3IgZnJhbWUgbnVtYmVyIHRvIGRpc3BsYXkgd2hlbiB0aGUgdXNlciBwcmVzc2VzIG9uIHRoZSB0YXJnZXQuIERlZmF1bHRzIHRvIFwiZG93blwiLlxuXHRcdCAqIEBwcm9wZXJ0eSBkb3duTGFiZWxcblx0XHQgKiBAdHlwZSBTdHJpbmcgfCBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5kb3duTGFiZWwgPSBkb3duTGFiZWwgPT0gbnVsbCA/IFwiZG93blwiIDogZG93bkxhYmVsO1xuXHRcblx0XHQvKipcblx0XHQgKiBJZiB0cnVlLCB0aGVuIEJ1dHRvbkhlbHBlciB3aWxsIGNhbGwgZ290b0FuZFBsYXksIGlmIGZhbHNlLCBpdCB3aWxsIHVzZSBnb3RvQW5kU3RvcC4gRGVmYXVsdCBpcyBmYWxzZS5cblx0XHQgKiBAcHJvcGVydHkgcGxheVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqKi9cblx0XHR0aGlzLnBsYXkgPSBwbGF5O1xuXHRcdFxuXHRcdFxuXHQvLyAgcHJpdmF0ZSBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9pc1ByZXNzZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9pc1ByZXNzZWQgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9pc092ZXJcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9pc092ZXIgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9lbmFibGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuXHRcdFxuXHQvLyBzZXR1cDpcblx0XHR0YXJnZXQubW91c2VDaGlsZHJlbiA9IGZhbHNlOyAvLyBwcmV2ZW50cyBpc3N1ZXMgd2hlbiBjaGlsZHJlbiBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBkaXNwbGF5IGxpc3Qgd2hlbiBzdGF0ZSBjaGFuZ2VzLlxuXHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cdFx0dGhpcy5oYW5kbGVFdmVudCh7fSk7XG5cdFx0aWYgKGhpdEFyZWEpIHtcblx0XHRcdGlmIChoaXRMYWJlbCkge1xuXHRcdFx0XHRoaXRBcmVhLmFjdGlvbnNFbmFibGVkID0gZmFsc2U7XG5cdFx0XHRcdGhpdEFyZWEuZ290b0FuZFN0b3AmJmhpdEFyZWEuZ290b0FuZFN0b3AoaGl0TGFiZWwpO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0LmhpdEFyZWEgPSBoaXRBcmVhO1xuXHRcdH1cblx0fVxuXHR2YXIgcCA9IEJ1dHRvbkhlbHBlci5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cdFxuLy8gZ2V0dGVyIC8gc2V0dGVyczpcblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiQnV0dG9uSGVscGVyL2VuYWJsZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBzZXRFbmFibGVkXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRwLnNldEVuYWJsZWQgPSBmdW5jdGlvbih2YWx1ZSkgeyAvLyBUT0RPOiBkZXByZWNhdGVkLlxuXHRcdGlmICh2YWx1ZSA9PSB0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxuXHRcdHZhciBvID0gdGhpcy50YXJnZXQ7XG5cdFx0dGhpcy5fZW5hYmxlZCA9IHZhbHVlO1xuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0by5jdXJzb3IgPSBcInBvaW50ZXJcIjtcblx0XHRcdG8uYWRkRXZlbnRMaXN0ZW5lcihcInJvbGxvdmVyXCIsIHRoaXMpO1xuXHRcdFx0by5hZGRFdmVudExpc3RlbmVyKFwicm9sbG91dFwiLCB0aGlzKTtcblx0XHRcdG8uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzKTtcblx0XHRcdG8uYWRkRXZlbnRMaXN0ZW5lcihcInByZXNzdXBcIiwgdGhpcyk7XG5cdFx0XHRpZiAoby5fcmVzZXQpIHsgby5fX3Jlc2V0ID0gby5fcmVzZXQ7IG8uX3Jlc2V0ID0gdGhpcy5fcmVzZXQ7fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvLmN1cnNvciA9IG51bGw7XG5cdFx0XHRvLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyb2xsb3ZlclwiLCB0aGlzKTtcblx0XHRcdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJvbGxvdXRcIiwgdGhpcyk7XG5cdFx0XHRvLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcyk7XG5cdFx0XHRvLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwcmVzc3VwXCIsIHRoaXMpO1xuXHRcdFx0aWYgKG8uX19yZXNldCkgeyBvLl9yZXNldCA9IG8uX19yZXNldDsgZGVsZXRlKG8uX19yZXNldCk7IH1cblx0XHR9XG5cdH07XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIkJ1dHRvbkhlbHBlci9lbmFibGVkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgZ2V0RW5hYmxlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdHAuZ2V0RW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9lbmFibGVkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbmFibGVzIG9yIGRpc2FibGVzIHRoZSBidXR0b24gZnVuY3Rpb25hbGl0eSBvbiB0aGUgdGFyZ2V0LlxuXHQgKiBAcHJvcGVydHkgZW5hYmxlZFxuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICoqL1xuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcblx0XHRcdGVuYWJsZWQ6IHsgZ2V0OiBwLmdldEVuYWJsZWQsIHNldDogcC5zZXRFbmFibGVkIH1cblx0XHR9KTtcblx0fSBjYXRjaCAoZSkge30gLy8gVE9ETzogdXNlIExvZ1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0J1dHRvbkhlbHBlcl1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGhhbmRsZUV2ZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldnQgVGhlIG1vdXNlIGV2ZW50IHRvIGhhbmRsZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbihldnQpIHtcblx0XHR2YXIgbGFiZWwsIHQgPSB0aGlzLnRhcmdldCwgdHlwZSA9IGV2dC50eXBlO1xuXHRcdGlmICh0eXBlID09IFwibW91c2Vkb3duXCIpIHtcblx0XHRcdHRoaXMuX2lzUHJlc3NlZCA9IHRydWU7XG5cdFx0XHRsYWJlbCA9IHRoaXMuZG93bkxhYmVsO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PSBcInByZXNzdXBcIikge1xuXHRcdFx0dGhpcy5faXNQcmVzc2VkID0gZmFsc2U7XG5cdFx0XHRsYWJlbCA9IHRoaXMuX2lzT3ZlciA/IHRoaXMub3ZlckxhYmVsIDogdGhpcy5vdXRMYWJlbDtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT0gXCJyb2xsb3ZlclwiKSB7XG5cdFx0XHR0aGlzLl9pc092ZXIgPSB0cnVlO1xuXHRcdFx0bGFiZWwgPSB0aGlzLl9pc1ByZXNzZWQgPyB0aGlzLmRvd25MYWJlbCA6IHRoaXMub3ZlckxhYmVsO1xuXHRcdH0gZWxzZSB7IC8vIHJvbGxvdXQgYW5kIGRlZmF1bHRcblx0XHRcdHRoaXMuX2lzT3ZlciA9IGZhbHNlO1xuXHRcdFx0bGFiZWwgPSB0aGlzLl9pc1ByZXNzZWQgPyB0aGlzLm92ZXJMYWJlbCA6IHRoaXMub3V0TGFiZWw7XG5cdFx0fVxuXHRcdGlmICh0aGlzLnBsYXkpIHtcblx0XHRcdHQuZ290b0FuZFBsYXkmJnQuZ290b0FuZFBsYXkobGFiZWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0LmdvdG9BbmRTdG9wJiZ0LmdvdG9BbmRTdG9wKGxhYmVsKTtcblx0XHR9XG5cdH07XG5cdFxuXHQvKipcblx0ICogSW5qZWN0ZWQgaW50byB0YXJnZXQuIFByZXNlcnZlcyB0aGUgcGF1c2VkIHN0YXRlIHRocm91Z2ggYSByZXNldC5cblx0ICogQG1ldGhvZCBfcmVzZXRcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3Jlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gVE9ETzogZXhwbG9yZSBiZXR0ZXIgd2F5cyB0byBoYW5kbGUgdGhpcyBpc3N1ZS4gVGhpcyBpcyBoYWNreSAmIGRpc3J1cHRzIG9iamVjdCBzaWduYXR1cmVzLlxuXHRcdHZhciBwID0gdGhpcy5wYXVzZWQ7XG5cdFx0dGhpcy5fX3Jlc2V0KCk7XG5cdFx0dGhpcy5wYXVzZWQgPSBwO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuQnV0dG9uSGVscGVyID0gQnV0dG9uSGVscGVyO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNoYWRvdy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogVGhpcyBjbGFzcyBlbmNhcHN1bGF0ZXMgdGhlIHByb3BlcnRpZXMgcmVxdWlyZWQgdG8gZGVmaW5lIGEgc2hhZG93IHRvIGFwcGx5IHRvIGEge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB2aWEgaXRzIDxjb2RlPnNoYWRvdzwvY29kZT4gcHJvcGVydHkuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBteUltYWdlLnNoYWRvdyA9IG5ldyBjcmVhdGVqcy5TaGFkb3coXCIjMDAwMDAwXCIsIDUsIDUsIDEwKTtcblx0ICpcblx0ICogQGNsYXNzIFNoYWRvd1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIFRoZSBjb2xvciBvZiB0aGUgc2hhZG93LiBUaGlzIGNhbiBiZSBhbnkgdmFsaWQgQ1NTIGNvbG9yIHZhbHVlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0WCBUaGUgeCBvZmZzZXQgb2YgdGhlIHNoYWRvdyBpbiBwaXhlbHMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRZIFRoZSB5IG9mZnNldCBvZiB0aGUgc2hhZG93IGluIHBpeGVscy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGJsdXIgVGhlIHNpemUgb2YgdGhlIGJsdXJyaW5nIGVmZmVjdC5cblx0ICoqL1xuXHRmdW5jdGlvbiBTaGFkb3coY29sb3IsIG9mZnNldFgsIG9mZnNldFksIGJsdXIpIHtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqIFxuXHRcdCAqIFRoZSBjb2xvciBvZiB0aGUgc2hhZG93LiBUaGlzIGNhbiBiZSBhbnkgdmFsaWQgQ1NTIGNvbG9yIHZhbHVlLlxuXHRcdCAqIEBwcm9wZXJ0eSBjb2xvclxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmNvbG9yID0gY29sb3J8fFwiYmxhY2tcIjtcblx0XG5cdFx0LyoqIFRoZSB4IG9mZnNldCBvZiB0aGUgc2hhZG93LlxuXHRcdCAqIEBwcm9wZXJ0eSBvZmZzZXRYXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMub2Zmc2V0WCA9IG9mZnNldFh8fDA7XG5cdFxuXHRcdC8qKiBUaGUgeSBvZmZzZXQgb2YgdGhlIHNoYWRvdy5cblx0XHQgKiBAcHJvcGVydHkgb2Zmc2V0WVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLm9mZnNldFkgPSBvZmZzZXRZfHwwO1xuXHRcblx0XHQvKiogVGhlIGJsdXIgb2YgdGhlIHNoYWRvdy5cblx0XHQgKiBAcHJvcGVydHkgYmx1clxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKi9cblx0XHR0aGlzLmJsdXIgPSBibHVyfHwwO1xuXHR9XG5cdHZhciBwID0gU2hhZG93LnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuLy8gc3RhdGljIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQW4gaWRlbnRpdHkgc2hhZG93IG9iamVjdCAoYWxsIHByb3BlcnRpZXMgYXJlIHNldCB0byAwKS5cblx0ICogQHByb3BlcnR5IGlkZW50aXR5XG5cdCAqIEB0eXBlIFNoYWRvd1xuXHQgKiBAc3RhdGljXG5cdCAqIEBmaW5hbFxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRTaGFkb3cuaWRlbnRpdHkgPSBuZXcgU2hhZG93KFwidHJhbnNwYXJlbnRcIiwgMCwgMCwgMCk7XG5cblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbU2hhZG93XVwiO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBTaGFkb3cgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7U2hhZG93fSBBIGNsb25lIG9mIHRoZSBjdXJyZW50IFNoYWRvdyBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaGFkb3codGhpcy5jb2xvciwgdGhpcy5vZmZzZXRYLCB0aGlzLm9mZnNldFksIHRoaXMuYmx1cik7XG5cdH07XG5cdFxuXG5cdGNyZWF0ZWpzLlNoYWRvdyA9IFNoYWRvdztcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTcHJpdGVTaGVldC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogRW5jYXBzdWxhdGVzIHRoZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGFzc29jaWF0ZWQgd2l0aCBhIHNwcml0ZSBzaGVldC4gQSBzcHJpdGUgc2hlZXQgaXMgYSBzZXJpZXMgb2YgaW1hZ2VzICh1c3VhbGx5XG5cdCAqIGFuaW1hdGlvbiBmcmFtZXMpIGNvbWJpbmVkIGludG8gYSBsYXJnZXIgaW1hZ2UgKG9yIGltYWdlcykuIEZvciBleGFtcGxlLCBhbiBhbmltYXRpb24gY29uc2lzdGluZyBvZiBlaWdodCAxMDB4MTAwXG5cdCAqIGltYWdlcyBjb3VsZCBiZSBjb21iaW5lZCBpbnRvIGEgc2luZ2xlIDQwMHgyMDAgc3ByaXRlIHNoZWV0ICg0IGZyYW1lcyBhY3Jvc3MgYnkgMiBoaWdoKS5cblx0ICpcblx0ICogVGhlIGRhdGEgcGFzc2VkIHRvIHRoZSBTcHJpdGVTaGVldCBjb25zdHJ1Y3RvciBkZWZpbmVzOjxvbD5cblx0ICogXHQ8bGk+IFRoZSBzb3VyY2UgaW1hZ2Ugb3IgaW1hZ2VzIHRvIHVzZS48L2xpPlxuXHQgKiBcdDxsaT4gVGhlIHBvc2l0aW9ucyBvZiBpbmRpdmlkdWFsIGltYWdlIGZyYW1lcy48L2xpPlxuXHQgKiBcdDxsaT4gU2VxdWVuY2VzIG9mIGZyYW1lcyB0aGF0IGZvcm0gbmFtZWQgYW5pbWF0aW9ucy4gT3B0aW9uYWwuPC9saT5cblx0ICogXHQ8bGk+IFRoZSB0YXJnZXQgcGxheWJhY2sgZnJhbWVyYXRlLiBPcHRpb25hbC48L2xpPlxuXHQgKiA8L09MPlxuXHQgKlxuXHQgKiA8aDM+U3ByaXRlU2hlZXQgRm9ybWF0PC9oMz5cblx0ICpcblx0ICogU3ByaXRlU2hlZXRzIGFyZSBhbiBvYmplY3Qgd2l0aCB0d28gcmVxdWlyZWQgcHJvcGVydGllcyAoYGltYWdlc2AgYW5kIGBmcmFtZXNgKSwgYW5kIHR3byBvcHRpb25hbCBwcm9wZXJ0aWVzXG5cdCAqIChgZnJhbWVyYXRlYCBhbmQgYGFuaW1hdGlvbnNgKS4gVGhpcyBtYWtlcyB0aGVtIGVhc3kgdG8gZGVmaW5lIGluIGphdmFzY3JpcHQgY29kZSwgb3IgaW4gSlNPTi5cblx0ICpcblx0ICogPGg0PmltYWdlczwvaDQ+XG5cdCAqIEFuIGFycmF5IG9mIHNvdXJjZSBpbWFnZXMuIEltYWdlcyBjYW4gYmUgZWl0aGVyIGFuIEhUTUxJbWFnZVxuXHQgKiBpbnN0YW5jZSwgb3IgYSB1cmkgdG8gYW4gaW1hZ2UuIFRoZSBmb3JtZXIgaXMgcmVjb21tZW5kZWQgdG8gY29udHJvbCBwcmVsb2FkaW5nLlxuXHQgKlxuXHQgKiBcdGltYWdlczogW2ltYWdlMSwgXCJwYXRoL3RvL2ltYWdlMi5wbmdcIl0sXG5cdCAqXG5cdCAqIDxoND5mcmFtZXM8L2g0PlxuXHQgKiBEZWZpbmVzIHRoZSBpbmRpdmlkdWFsIGZyYW1lcy4gVGhlcmUgYXJlIHR3byBzdXBwb3J0ZWQgZm9ybWF0cyBmb3IgZnJhbWUgZGF0YTo8T0w+XG5cdCAqIDxMST4gd2hlbiBhbGwgb2YgdGhlIGZyYW1lcyBhcmUgdGhlIHNhbWUgc2l6ZSAoaW4gYSBncmlkKSwgdXNlIGFuIG9iamVjdCB3aXRoIGB3aWR0aGAsIGBoZWlnaHRgLCBgcmVnWGAsIGByZWdZYCwgYW5kIGBjb3VudGAgcHJvcGVydGllcy5cblx0ICogYHdpZHRoYCAmIGBoZWlnaHRgIGFyZSByZXF1aXJlZCBhbmQgc3BlY2lmeSB0aGUgZGltZW5zaW9ucyBvZiB0aGUgZnJhbWVzLlxuXHQgKiBgcmVnWGAgJiBgcmVnWWAgaW5kaWNhdGUgdGhlIHJlZ2lzdHJhdGlvbiBwb2ludCBvciBcIm9yaWdpblwiIG9mIHRoZSBmcmFtZXMuXG5cdCAqIGBzcGFjaW5nYCBpbmRpY2F0ZSB0aGUgc3BhY2luZyBiZXR3ZWVuIGZyYW1lcy5cblx0ICogYG1hcmdpbmAgc3BlY2lmeSB0aGUgbWFyZ2luIGFyb3VuZCB0aGUgaW1hZ2UocykuXG5cdCAqIGBjb3VudGAgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IHRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBzcHJpdGVzaGVldDsgaWYgb21pdHRlZCwgdGhpcyB3aWxsIGJlIGNhbGN1bGF0ZWRcblx0ICogYmFzZWQgb24gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHNvdXJjZSBpbWFnZXMgYW5kIHRoZSBmcmFtZXMuIEZyYW1lcyB3aWxsIGJlIGFzc2lnbmVkIGluZGV4ZXMgYmFzZWQgb24gdGhlaXIgcG9zaXRpb25cblx0ICogaW4gdGhlIHNvdXJjZSBpbWFnZXMgKGxlZnQgdG8gcmlnaHQsIHRvcCB0byBib3R0b20pLlxuXHQgKlxuXHQgKiBcdGZyYW1lczoge3dpZHRoOjY0LCBoZWlnaHQ6NjQsIGNvdW50OjIwLCByZWdYOiAzMiwgcmVnWTo2NCwgc3BhY2luZzowLCBtYXJnaW46MH1cblx0ICpcblx0ICogPExJPiBpZiB0aGUgZnJhbWVzIGFyZSBvZiBkaWZmZXJlbnQgc2l6ZXMsIHVzZSBhbiBhcnJheSBvZiBmcmFtZSBkZWZpbml0aW9ucy4gRWFjaCBkZWZpbml0aW9uIGlzIGl0c2VsZiBhbiBhcnJheVxuXHQgKiB3aXRoIDQgcmVxdWlyZWQgYW5kIDMgb3B0aW9uYWwgZW50cmllcywgaW4gdGhlIG9yZGVyOiBgeGAsIGB5YCwgYHdpZHRoYCwgYGhlaWdodGAsIGBpbWFnZUluZGV4YCwgYHJlZ1hgLCBgcmVnWWAuIFRoZSBmaXJzdFxuXHQgKiBmb3VyIGVudHJpZXMgYXJlIHJlcXVpcmVkIGFuZCBkZWZpbmUgdGhlIGZyYW1lIHJlY3RhbmdsZS4gVGhlIGZpZnRoIHNwZWNpZmllcyB0aGUgaW5kZXggb2YgdGhlIHNvdXJjZSBpbWFnZSAoZGVmYXVsdHMgdG8gMCkuIFRoZVxuXHQgKiBsYXN0IHR3byBzcGVjaWZ5IHRoZSByZWdpc3RyYXRpb24gcG9pbnQgb2YgdGhlIGZyYW1lLlxuXHQgKlxuXHQgKiBcdGZyYW1lczogW1xuXHQgKiBcdFx0Ly8geCwgeSwgd2lkdGgsIGhlaWdodCwgaW1hZ2VJbmRleCosIHJlZ1gqLCByZWdZKlxuXHQgKiBcdFx0WzY0LCAwLCA5NiwgNjRdLFxuXHQgKiBcdFx0WzAsIDAsIDY0LCA2NCwgMSwgMzIsIDMyXVxuXHQgKiBcdFx0Ly8gZXRjLlxuXHQgKiBcdF1cblx0ICpcblx0ICogPC9PTD5cblx0ICpcblx0ICogPGg0PmFuaW1hdGlvbnM8L2g0PlxuXHQgKiBPcHRpb25hbC4gQW4gb2JqZWN0IGRlZmluaW5nIHNlcXVlbmNlcyBvZiBmcmFtZXMgdG8gcGxheSBhcyBuYW1lZCBhbmltYXRpb25zLiBFYWNoIHByb3BlcnR5IGNvcnJlc3BvbmRzIHRvIGFuXG5cdCAqIGFuaW1hdGlvbiBvZiB0aGUgc2FtZSBuYW1lLiBFYWNoIGFuaW1hdGlvbiBtdXN0IHNwZWNpZnkgdGhlIGZyYW1lcyB0byBwbGF5LCBhbmQgbWF5XG5cdCAqIGFsc28gaW5jbHVkZSBhIHJlbGF0aXZlIHBsYXliYWNrIGBzcGVlZGAgKGV4LiAyIHdvdWxkIHBsYXliYWNrIGF0IGRvdWJsZSBzcGVlZCwgMC41IGF0IGhhbGYpLCBhbmRcblx0ICogdGhlIG5hbWUgb2YgdGhlIGBuZXh0YCBhbmltYXRpb24gdG8gc2VxdWVuY2UgdG8gYWZ0ZXIgaXQgY29tcGxldGVzLlxuXHQgKlxuXHQgKiBUaGVyZSBhcmUgdGhyZWUgZm9ybWF0cyBzdXBwb3J0ZWQgZm9yIGRlZmluaW5nIHRoZSBmcmFtZXMgaW4gYW4gYW5pbWF0aW9uLCB3aGljaCBjYW4gYmUgbWl4ZWQgYW5kIG1hdGNoZWQgYXMgYXBwcm9wcmlhdGU6PE9MPlxuXHQgKiA8TEk+IGZvciBhIHNpbmdsZSBmcmFtZSBhbmltYXRpb24sIHlvdSBjYW4gc2ltcGx5IHNwZWNpZnkgdGhlIGZyYW1lIGluZGV4XG5cdCAqXG5cdCAqIFx0YW5pbWF0aW9uczoge1xuXHQgKiBcdFx0c2l0OiA3XG5cdCAqIFx0fVxuXHQgKlxuXHQgKiA8TEk+IGZvciBhbiBhbmltYXRpb24gb2YgY29uc2VjdXRpdmUgZnJhbWVzLCB5b3UgY2FuIHVzZSBhbiBhcnJheSB3aXRoIHR3byByZXF1aXJlZCwgYW5kIHR3byBvcHRpb25hbCBlbnRyaWVzXG5cdCAqIGluIHRoZSBvcmRlcjogYHN0YXJ0YCwgYGVuZGAsIGBuZXh0YCwgYW5kIGBzcGVlZGAuIFRoaXMgd2lsbCBwbGF5IHRoZSBmcmFtZXMgZnJvbSBzdGFydCB0byBlbmQgaW5jbHVzaXZlLlxuXHQgKlxuXHQgKiBcdGFuaW1hdGlvbnM6IHtcblx0ICogXHRcdC8vIHN0YXJ0LCBlbmQsIG5leHQqLCBzcGVlZCpcblx0ICogXHRcdHJ1bjogWzAsIDhdLFxuXHQgKiBcdFx0anVtcDogWzksIDEyLCBcInJ1blwiLCAyXVxuXHQgKiBcdH1cblx0ICpcblx0ICogPExJPiBmb3Igbm9uLWNvbnNlY3V0aXZlIGZyYW1lcywgeW91IGNhbiB1c2UgYW4gb2JqZWN0IHdpdGggYSBgZnJhbWVzYCBwcm9wZXJ0eSBkZWZpbmluZyBhbiBhcnJheSBvZiBmcmFtZSBpbmRleGVzIHRvXG5cdCAqIHBsYXkgaW4gb3JkZXIuIFRoZSBvYmplY3QgY2FuIGFsc28gc3BlY2lmeSBgbmV4dGAgYW5kIGBzcGVlZGAgcHJvcGVydGllcy5cblx0ICpcblx0ICogXHRhbmltYXRpb25zOiB7XG5cdCAqIFx0XHR3YWxrOiB7XG5cdCAqIFx0XHRcdGZyYW1lczogWzEsMiwzLDMsMiwxXVxuXHQgKiBcdFx0fSxcblx0ICogXHRcdHNob290OiB7XG5cdCAqIFx0XHRcdGZyYW1lczogWzEsNCw1LDZdLFxuXHQgKiBcdFx0XHRuZXh0OiBcIndhbGtcIixcblx0ICogXHRcdFx0c3BlZWQ6IDAuNVxuXHQgKiBcdFx0fVxuXHQgKiBcdH1cblx0ICpcblx0ICogPC9PTD5cblx0ICogPHN0cm9uZz5Ob3RlOjwvc3Ryb25nPiB0aGUgYHNwZWVkYCBwcm9wZXJ0eSB3YXMgYWRkZWQgaW4gRWFzZWxKUyAwLjcuMC4gRWFybGllciB2ZXJzaW9ucyBoYWQgYSBgZnJlcXVlbmN5YFxuXHQgKiBwcm9wZXJ0eSBpbnN0ZWFkLCB3aGljaCB3YXMgdGhlIGludmVyc2Ugb2YgYHNwZWVkYC4gRm9yIGV4YW1wbGUsIGEgdmFsdWUgb2YgXCI0XCIgd291bGQgYmUgMS80IG5vcm1hbCBzcGVlZCBpbiBlYXJsaWVyXG5cdCAqIHZlcnNpb25zLCBidXQgaXMgNHggbm9ybWFsIHNwZWVkIGluIDAuNy4wKy5cblx0ICpcblx0ICogPGg0PmZyYW1lcmF0ZTwvaDQ+XG5cdCAqIE9wdGlvbmFsLiBJbmRpY2F0ZXMgdGhlIGRlZmF1bHQgZnJhbWVyYXRlIHRvIHBsYXkgdGhpcyBzcHJpdGVzaGVldCBhdCBpbiBmcmFtZXMgcGVyIHNlY29uZC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0L2ZyYW1lcmF0ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICpcblx0ICogXHRmcmFtZXJhdGU6IDIwXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogVG8gZGVmaW5lIGEgc2ltcGxlIHNwcml0ZSBzaGVldCwgd2l0aCBhIHNpbmdsZSBpbWFnZSBcInNwcml0ZXMuanBnXCIgYXJyYW5nZWQgaW4gYSByZWd1bGFyIDUweDUwIGdyaWQgd2l0aCB0aHJlZVxuXHQgKiBhbmltYXRpb25zOiBcInN0YW5kXCIgc2hvd2luZyB0aGUgZmlyc3QgZnJhbWUsIFwicnVuXCIgbG9vcGluZyBmcmFtZSAxLTUgaW5jbHVzaXZlLCBhbmQgXCJqdW1wXCIgcGxheWluZyAgZnJhbWUgNi04IGFuZCBzZXF1ZW5jaW5nIGJhY2sgdG8gcnVuLlxuXHQgKlxuXHQgKiBcdHZhciBkYXRhID0ge1xuXHQgKiBcdFx0aW1hZ2VzOiBbXCJzcHJpdGVzLmpwZ1wiXSxcblx0ICogXHRcdGZyYW1lczoge3dpZHRoOjUwLCBoZWlnaHQ6NTB9LFxuXHQgKiBcdFx0YW5pbWF0aW9uczoge1xuXHQgKiBcdFx0XHRzdGFuZDowLFxuXHQgKiBcdFx0XHRydW46WzEsNV0sXG5cdCAqIFx0XHRcdGp1bXA6WzYsOCxcInJ1blwiXVxuXHQgKiBcdFx0fVxuXHQgKiBcdH07XG5cdCAqIFx0dmFyIHNwcml0ZVNoZWV0ID0gbmV3IGNyZWF0ZWpzLlNwcml0ZVNoZWV0KGRhdGEpO1xuXHQgKiBcdHZhciBhbmltYXRpb24gPSBuZXcgY3JlYXRlanMuU3ByaXRlKHNwcml0ZVNoZWV0LCBcInJ1blwiKTtcblx0ICpcblx0ICpcblx0ICogPHN0cm9uZz5XYXJuaW5nOjwvc3Ryb25nPiBJbWFnZXMgbG9hZGVkIGNyb3NzLW9yaWdpbiB3aWxsIHRocm93IGNyb3NzLW9yaWdpbiBzZWN1cml0eSBlcnJvcnMgd2hlbiBpbnRlcmFjdGVkIHdpdGhcblx0ICogdXNpbmcgYSBtb3VzZSwgdXNpbmcgbWV0aG9kcyBzdWNoIGFzIGBnZXRPYmplY3RVbmRlclBvaW50YCwgdXNpbmcgZmlsdGVycywgb3IgY2FjaGluZy4gWW91IGNhbiBnZXQgYXJvdW5kIHRoaXMgYnlcblx0ICogc2V0dGluZyBgY3Jvc3NPcmlnaW5gIGZsYWdzIG9uIHlvdXIgaW1hZ2VzIGJlZm9yZSBwYXNzaW5nIHRoZW0gdG8gRWFzZWxKUywgZWc6IGBpbWcuY3Jvc3NPcmlnaW49XCJBbm9ueW1vdXNcIjtgXG5cdCAqXG5cdCAqIEBjbGFzcyBTcHJpdGVTaGVldFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIFNwcml0ZVNoZWV0IGRhdGEuXG5cdCAqIEBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlclxuXHQgKiovXG5cdGZ1bmN0aW9uIFNwcml0ZVNoZWV0KGRhdGEpIHtcblx0XHR0aGlzLkV2ZW50RGlzcGF0Y2hlcl9jb25zdHJ1Y3RvcigpO1xuXG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciBhbGwgaW1hZ2VzIGFyZSBmaW5pc2hlZCBsb2FkaW5nLlxuXHRcdCAqIEBwcm9wZXJ0eSBjb21wbGV0ZVxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5jb21wbGV0ZSA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBTcGVjaWZpZXMgdGhlIGZyYW1lcmF0ZSB0byB1c2UgYnkgZGVmYXVsdCBmb3IgU3ByaXRlIGluc3RhbmNlcyB1c2luZyB0aGUgU3ByaXRlU2hlZXQuIFNlZVxuXHRcdCAqIFNwcml0ZS5mcmFtZXJhdGUgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdFx0ICogQHByb3BlcnR5IGZyYW1lcmF0ZVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmZyYW1lcmF0ZSA9IDA7XG5cblxuXHRcdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2FuaW1hdGlvbnNcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgQXJyYXlcblx0XHQgKiovXG5cdFx0dGhpcy5fYW5pbWF0aW9ucyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2ZyYW1lc1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBBcnJheVxuXHRcdCAqKi9cblx0XHR0aGlzLl9mcmFtZXMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9pbWFnZXNcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgQXJyYXlcblx0XHQgKiovXG5cdFx0dGhpcy5faW1hZ2VzID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfZGF0YVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiovXG5cdFx0dGhpcy5fZGF0YSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2xvYWRDb3VudFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fbG9hZENvdW50ID0gMDtcblxuXHRcdC8vIG9ubHkgdXNlZCBmb3Igc2ltcGxlIGZyYW1lIGRlZnM6XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9mcmFtZUhlaWdodFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fZnJhbWVIZWlnaHQgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9mcmFtZVdpZHRoXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9mcmFtZVdpZHRoID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbnVtRnJhbWVzXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9udW1GcmFtZXMgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9yZWdYXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9yZWdYID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmVnWVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fcmVnWSA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3NwYWNpbmdcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3NwYWNpbmcgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9tYXJnaW5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX21hcmdpbiA9IDA7XG5cblx0XHQvLyBzZXR1cDpcblx0XHR0aGlzLl9wYXJzZURhdGEoZGF0YSk7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoU3ByaXRlU2hlZXQsIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuLy8gZXZlbnRzOlxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIGFsbCBpbWFnZXMgYXJlIGxvYWRlZC4gIE5vdGUgdGhhdCB0aGlzIG9ubHkgZmlyZXMgaWYgdGhlIGltYWdlc1xuXHQgKiB3ZXJlIG5vdCBmdWxseSBsb2FkZWQgd2hlbiB0aGUgc3ByaXRlIHNoZWV0IHdhcyBpbml0aWFsaXplZC4gWW91IHNob3VsZCBjaGVjayB0aGUgY29tcGxldGUgcHJvcGVydHlcblx0ICogdG8gcHJpb3IgdG8gYWRkaW5nIGEgbGlzdGVuZXIuIEV4LlxuXHQgKlxuXHQgKiBcdHZhciBzaGVldCA9IG5ldyBTcHJpdGVTaGVldChkYXRhKTtcblx0ICogXHRpZiAoIXNoZWV0LmNvbXBsZXRlKSB7XG5cdCAqIFx0XHQvLyBub3QgcHJlbG9hZGVkLCBsaXN0ZW4gZm9yIHRoZSBjb21wbGV0ZSBldmVudDpcblx0ICogXHRcdHNoZWV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjb21wbGV0ZVwiLCBoYW5kbGVyKTtcblx0ICogXHR9XG5cdCAqXG5cdCAqIEBldmVudCBjb21wbGV0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIGdldEZyYW1lIGlzIGNhbGxlZCB3aXRoIGEgdmFsaWQgZnJhbWUgaW5kZXguIFRoaXMgaXMgcHJpbWFyaWx5IGludGVuZGVkIGZvciB1c2UgYnkge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRCdWlsZGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdoZW4gZG9pbmcgb24tZGVtYW5kIHJlbmRlcmluZy5cblx0ICogQGV2ZW50IGdldGZyYW1lXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgZnJhbWUgaW5kZXguXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBmcmFtZSBUaGUgZnJhbWUgb2JqZWN0IHRoYXQgZ2V0RnJhbWUgd2lsbCByZXR1cm4uXG5cdCAqL1xuXG5cbi8vIGdldHRlciAvIHNldHRlcnM6XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0L2FuaW1hdGlvbnM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBnZXRBbmltYXRpb25zXG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdHAuZ2V0QW5pbWF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hbmltYXRpb25zLnNsaWNlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGF2YWlsYWJsZSBhbmltYXRpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoaXMgc3ByaXRlIHNoZWV0IGFzIHN0cmluZ3MuXG5cdCAqIEBwcm9wZXJ0eSBhbmltYXRpb25zXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XG5cdFx0XHRhbmltYXRpb25zOiB7IGdldDogcC5nZXRBbmltYXRpb25zIH1cblx0XHR9KTtcblx0fSBjYXRjaCAoZSkge31cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBmcmFtZXMgaW4gdGhlIHNwZWNpZmllZCBhbmltYXRpb24sIG9yIGluIHRoZSB3aG9sZSBzcHJpdGVcblx0ICogc2hlZXQgaWYgdGhlIGFuaW1hdGlvbiBwYXJhbSBpcyBvbWl0dGVkLiBSZXR1cm5zIDAgaWYgdGhlIHNwcml0ZXNoZWV0IHJlbGllcyBvbiBjYWxjdWxhdGVkIGZyYW1lIGNvdW50cywgYW5kXG5cdCAqIHRoZSBpbWFnZXMgaGF2ZSBub3QgYmVlbiBmdWxseSBsb2FkZWQuXG5cdCAqIEBtZXRob2QgZ2V0TnVtRnJhbWVzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBhbmltYXRpb24gVGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBnZXQgYSBmcmFtZSBjb3VudCBmb3IuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIG51bWJlciBvZiBmcmFtZXMgaW4gdGhlIGFuaW1hdGlvbiwgb3IgaW4gdGhlIGVudGlyZSBzcHJpdGUgc2hlZXQgaWYgdGhlIGFuaW1hdGlvbiBwYXJhbSBpcyBvbWl0dGVkLlxuXHQgKi9cblx0cC5nZXROdW1GcmFtZXMgPSBmdW5jdGlvbihhbmltYXRpb24pIHtcblx0XHRpZiAoYW5pbWF0aW9uID09IG51bGwpIHtcblx0XHRcdHJldHVybiB0aGlzLl9mcmFtZXMgPyB0aGlzLl9mcmFtZXMubGVuZ3RoIDogdGhpcy5fbnVtRnJhbWVzIHx8IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBkYXRhID0gdGhpcy5fZGF0YVthbmltYXRpb25dO1xuXHRcdFx0aWYgKGRhdGEgPT0gbnVsbCkgeyByZXR1cm4gMDsgfVxuXHRcdFx0ZWxzZSB7IHJldHVybiBkYXRhLmZyYW1lcy5sZW5ndGg7IH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gb2JqZWN0IGRlZmluaW5nIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uLiBUaGUgcmV0dXJuZWQgb2JqZWN0IGNvbnRhaW5zOjxVTD5cblx0ICogXHQ8TEk+ZnJhbWVzOiBhbiBhcnJheSBvZiB0aGUgZnJhbWUgaWRzIGluIHRoZSBhbmltYXRpb248L0xJPlxuXHQgKiBcdDxMST5zcGVlZDogdGhlIHBsYXliYWNrIHNwZWVkIGZvciB0aGlzIGFuaW1hdGlvbjwvTEk+XG5cdCAqIFx0PExJPm5hbWU6IHRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb248L0xJPlxuXHQgKiBcdDxMST5uZXh0OiB0aGUgZGVmYXVsdCBhbmltYXRpb24gdG8gcGxheSBuZXh0LiBJZiB0aGUgYW5pbWF0aW9uIGxvb3BzLCB0aGUgbmFtZSBhbmQgbmV4dCBwcm9wZXJ0eSB3aWxsIGJlIHRoZVxuXHQgKiBcdHNhbWUuPC9MST5cblx0ICogPC9VTD5cblx0ICogQG1ldGhvZCBnZXRBbmltYXRpb25cblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBnZXQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gYSBnZW5lcmljIG9iamVjdCB3aXRoIGZyYW1lcywgc3BlZWQsIG5hbWUsIGFuZCBuZXh0IHByb3BlcnRpZXMuXG5cdCAqKi9cblx0cC5nZXRBbmltYXRpb24gPSBmdW5jdGlvbihuYW1lKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGFbbmFtZV07XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gb2JqZWN0IHNwZWNpZnlpbmcgdGhlIGltYWdlIGFuZCBzb3VyY2UgcmVjdCBvZiB0aGUgc3BlY2lmaWVkIGZyYW1lLiBUaGUgcmV0dXJuZWQgb2JqZWN0IGhhczo8VUw+XG5cdCAqIFx0PExJPmFuIGltYWdlIHByb3BlcnR5IGhvbGRpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGltYWdlIG9iamVjdCBpbiB3aGljaCB0aGUgZnJhbWUgaXMgZm91bmQ8L0xJPlxuXHQgKiBcdDxMST5hIHJlY3QgcHJvcGVydHkgY29udGFpbmluZyBhIFJlY3RhbmdsZSBpbnN0YW5jZSB3aGljaCBkZWZpbmVzIHRoZSBib3VuZGFyaWVzIGZvciB0aGUgZnJhbWUgd2l0aGluIHRoYXRcblx0ICogXHRpbWFnZS48L0xJPlxuXHQgKiBcdDxMST4gQSByZWdYIGFuZCByZWdZIHByb3BlcnR5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHJlZ1gvWSB2YWx1ZXMgZm9yIHRoZSBmcmFtZS5cblx0ICogPC9VTD5cblx0ICogQG1ldGhvZCBnZXRGcmFtZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVJbmRleCBUaGUgaW5kZXggb2YgdGhlIGZyYW1lLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IGEgZ2VuZXJpYyBvYmplY3Qgd2l0aCBpbWFnZSBhbmQgcmVjdCBwcm9wZXJ0aWVzLiBSZXR1cm5zIG51bGwgaWYgdGhlIGZyYW1lIGRvZXMgbm90IGV4aXN0LlxuXHQgKiovXG5cdHAuZ2V0RnJhbWUgPSBmdW5jdGlvbihmcmFtZUluZGV4KSB7XG5cdFx0dmFyIGZyYW1lO1xuXHRcdGlmICh0aGlzLl9mcmFtZXMgJiYgKGZyYW1lPXRoaXMuX2ZyYW1lc1tmcmFtZUluZGV4XSkpIHsgcmV0dXJuIGZyYW1lOyB9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB7eyNjcm9zc0xpbmsgXCJSZWN0YW5nbGVcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGFuY2UgZGVmaW5pbmcgdGhlIGJvdW5kcyBvZiB0aGUgc3BlY2lmaWVkIGZyYW1lIHJlbGF0aXZlXG5cdCAqIHRvIHRoZSBvcmlnaW4uIEZvciBleGFtcGxlLCBhIDkwIHggNzAgZnJhbWUgd2l0aCBhIHJlZ1ggb2YgNTAgYW5kIGEgcmVnWSBvZiA0MCB3b3VsZCByZXR1cm46XG5cdCAqXG5cdCAqIFx0W3g9LTUwLCB5PS00MCwgd2lkdGg9OTAsIGhlaWdodD03MF1cblx0ICpcblx0ICogQG1ldGhvZCBnZXRGcmFtZUJvdW5kc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZnJhbWVJbmRleCBUaGUgaW5kZXggb2YgdGhlIGZyYW1lLlxuXHQgKiBAcGFyYW0ge1JlY3RhbmdsZX0gW3JlY3RhbmdsZV0gQSBSZWN0YW5nbGUgaW5zdGFuY2UgdG8gY29weSB0aGUgdmFsdWVzIGludG8uIEJ5IGRlZmF1bHQgYSBuZXcgaW5zdGFuY2UgaXMgY3JlYXRlZC5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBBIFJlY3RhbmdsZSBpbnN0YW5jZS4gUmV0dXJucyBudWxsIGlmIHRoZSBmcmFtZSBkb2VzIG5vdCBleGlzdCwgb3IgdGhlIGltYWdlIGlzIG5vdCBmdWxseSBsb2FkZWQuXG5cdCAqKi9cblx0cC5nZXRGcmFtZUJvdW5kcyA9IGZ1bmN0aW9uKGZyYW1lSW5kZXgsIHJlY3RhbmdsZSkge1xuXHRcdHZhciBmcmFtZSA9IHRoaXMuZ2V0RnJhbWUoZnJhbWVJbmRleCk7XG5cdFx0cmV0dXJuIGZyYW1lID8gKHJlY3RhbmdsZXx8bmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSgpKS5zZXRWYWx1ZXMoLWZyYW1lLnJlZ1gsIC1mcmFtZS5yZWdZLCBmcmFtZS5yZWN0LndpZHRoLCBmcmFtZS5yZWN0LmhlaWdodCkgOiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbU3ByaXRlU2hlZXRdXCI7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNwcml0ZVNoZWV0IGNhbm5vdCBiZSBjbG9uZWQuIEEgU3ByaXRlU2hlZXQgY2FuIGJlIHNoYXJlZCBieSBtdWx0aXBsZSBTcHJpdGUgaW5zdGFuY2VzIHdpdGhvdXQgY2xvbmluZyBpdC5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyhcIlNwcml0ZVNoZWV0IGNhbm5vdCBiZSBjbG9uZWQuXCIpXG5cdH07XG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX3BhcnNlRGF0YVxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBBbiBvYmplY3QgZGVzY3JpYmluZyB0aGUgU3ByaXRlU2hlZXQgZGF0YS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3BhcnNlRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHR2YXIgaSxsLG8sYTtcblx0XHRpZiAoZGF0YSA9PSBudWxsKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5mcmFtZXJhdGUgPSBkYXRhLmZyYW1lcmF0ZXx8MDtcblxuXHRcdC8vIHBhcnNlIGltYWdlczpcblx0XHRpZiAoZGF0YS5pbWFnZXMgJiYgKGw9ZGF0YS5pbWFnZXMubGVuZ3RoKSA+IDApIHtcblx0XHRcdGEgPSB0aGlzLl9pbWFnZXMgPSBbXTtcblx0XHRcdGZvciAoaT0wOyBpPGw7IGkrKykge1xuXHRcdFx0XHR2YXIgaW1nID0gZGF0YS5pbWFnZXNbaV07XG5cdFx0XHRcdGlmICh0eXBlb2YgaW1nID09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHR2YXIgc3JjID0gaW1nO1xuXHRcdFx0XHRcdGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG5cdFx0XHRcdFx0aW1nLnNyYyA9IHNyYztcblx0XHRcdFx0fVxuXHRcdFx0XHRhLnB1c2goaW1nKTtcblx0XHRcdFx0aWYgKCFpbWcuZ2V0Q29udGV4dCAmJiAhaW1nLm5hdHVyYWxXaWR0aCkge1xuXHRcdFx0XHRcdHRoaXMuX2xvYWRDb3VudCsrO1xuXHRcdFx0XHRcdHRoaXMuY29tcGxldGUgPSBmYWxzZTtcblx0XHRcdFx0XHQoZnVuY3Rpb24obykgeyBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7IG8uX2hhbmRsZUltYWdlTG9hZCgpOyB9IH0pKHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcGFyc2UgZnJhbWVzOlxuXHRcdGlmIChkYXRhLmZyYW1lcyA9PSBudWxsKSB7IC8vIG5vdGhpbmdcblx0XHR9IGVsc2UgaWYgKGRhdGEuZnJhbWVzIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdHRoaXMuX2ZyYW1lcyA9IFtdO1xuXHRcdFx0YSA9IGRhdGEuZnJhbWVzO1xuXHRcdFx0Zm9yIChpPTAsbD1hLmxlbmd0aDtpPGw7aSsrKSB7XG5cdFx0XHRcdHZhciBhcnIgPSBhW2ldO1xuXHRcdFx0XHR0aGlzLl9mcmFtZXMucHVzaCh7aW1hZ2U6dGhpcy5faW1hZ2VzW2Fycls0XT9hcnJbNF06MF0sIHJlY3Q6bmV3IGNyZWF0ZWpzLlJlY3RhbmdsZShhcnJbMF0sYXJyWzFdLGFyclsyXSxhcnJbM10pLCByZWdYOmFycls1XXx8MCwgcmVnWTphcnJbNl18fDAgfSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG8gPSBkYXRhLmZyYW1lcztcblx0XHRcdHRoaXMuX2ZyYW1lV2lkdGggPSBvLndpZHRoO1xuXHRcdFx0dGhpcy5fZnJhbWVIZWlnaHQgPSBvLmhlaWdodDtcblx0XHRcdHRoaXMuX3JlZ1ggPSBvLnJlZ1h8fDA7XG5cdFx0XHR0aGlzLl9yZWdZID0gby5yZWdZfHwwO1xuXHRcdFx0dGhpcy5fc3BhY2luZyA9IG8uc3BhY2luZ3x8MDtcblx0XHRcdHRoaXMuX21hcmdpbiA9IG8ubWFyZ2lufHwwO1xuXHRcdFx0dGhpcy5fbnVtRnJhbWVzID0gby5jb3VudDtcblx0XHRcdGlmICh0aGlzLl9sb2FkQ291bnQgPT0gMCkgeyB0aGlzLl9jYWxjdWxhdGVGcmFtZXMoKTsgfVxuXHRcdH1cblxuXHRcdC8vIHBhcnNlIGFuaW1hdGlvbnM6XG5cdFx0dGhpcy5fYW5pbWF0aW9ucyA9IFtdO1xuXHRcdGlmICgobz1kYXRhLmFuaW1hdGlvbnMpICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX2RhdGEgPSB7fTtcblx0XHRcdHZhciBuYW1lO1xuXHRcdFx0Zm9yIChuYW1lIGluIG8pIHtcblx0XHRcdFx0dmFyIGFuaW0gPSB7bmFtZTpuYW1lfTtcblx0XHRcdFx0dmFyIG9iaiA9IG9bbmFtZV07XG5cdFx0XHRcdGlmICh0eXBlb2Ygb2JqID09IFwibnVtYmVyXCIpIHsgLy8gc2luZ2xlIGZyYW1lXG5cdFx0XHRcdFx0YSA9IGFuaW0uZnJhbWVzID0gW29ial07XG5cdFx0XHRcdH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgQXJyYXkpIHsgLy8gc2ltcGxlXG5cdFx0XHRcdFx0aWYgKG9iai5sZW5ndGggPT0gMSkgeyBhbmltLmZyYW1lcyA9IFtvYmpbMF1dOyB9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRhbmltLnNwZWVkID0gb2JqWzNdO1xuXHRcdFx0XHRcdFx0YW5pbS5uZXh0ID0gb2JqWzJdO1xuXHRcdFx0XHRcdFx0YSA9IGFuaW0uZnJhbWVzID0gW107XG5cdFx0XHRcdFx0XHRmb3IgKGk9b2JqWzBdO2k8PW9ialsxXTtpKyspIHtcblx0XHRcdFx0XHRcdFx0YS5wdXNoKGkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHsgLy8gY29tcGxleFxuXHRcdFx0XHRcdGFuaW0uc3BlZWQgPSBvYmouc3BlZWQ7XG5cdFx0XHRcdFx0YW5pbS5uZXh0ID0gb2JqLm5leHQ7XG5cdFx0XHRcdFx0dmFyIGZyYW1lcyA9IG9iai5mcmFtZXM7XG5cdFx0XHRcdFx0YSA9IGFuaW0uZnJhbWVzID0gKHR5cGVvZiBmcmFtZXMgPT0gXCJudW1iZXJcIikgPyBbZnJhbWVzXSA6IGZyYW1lcy5zbGljZSgwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYW5pbS5uZXh0ID09PSB0cnVlIHx8IGFuaW0ubmV4dCA9PT0gdW5kZWZpbmVkKSB7IGFuaW0ubmV4dCA9IG5hbWU7IH0gLy8gbG9vcFxuXHRcdFx0XHRpZiAoYW5pbS5uZXh0ID09PSBmYWxzZSB8fCAoYS5sZW5ndGggPCAyICYmIGFuaW0ubmV4dCA9PSBuYW1lKSkgeyBhbmltLm5leHQgPSBudWxsOyB9IC8vIHN0b3Bcblx0XHRcdFx0aWYgKCFhbmltLnNwZWVkKSB7IGFuaW0uc3BlZWQgPSAxOyB9XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvbnMucHVzaChuYW1lKTtcblx0XHRcdFx0dGhpcy5fZGF0YVtuYW1lXSA9IGFuaW07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVJbWFnZUxvYWRcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2hhbmRsZUltYWdlTG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICgtLXRoaXMuX2xvYWRDb3VudCA9PSAwKSB7XG5cdFx0XHR0aGlzLl9jYWxjdWxhdGVGcmFtZXMoKTtcblx0XHRcdHRoaXMuY29tcGxldGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwiY29tcGxldGVcIik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9jYWxjdWxhdGVGcmFtZXNcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2NhbGN1bGF0ZUZyYW1lcyA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9mcmFtZXMgfHwgdGhpcy5fZnJhbWVXaWR0aCA9PSAwKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZnJhbWVzID0gW107XG5cblx0XHR2YXIgbWF4RnJhbWVzID0gdGhpcy5fbnVtRnJhbWVzIHx8IDEwMDAwMDsgLy8gaWYgd2UgZ28gb3ZlciB0aGlzLCBzb21ldGhpbmcgaXMgd3JvbmcuXG5cdFx0dmFyIGZyYW1lQ291bnQgPSAwLCBmcmFtZVdpZHRoID0gdGhpcy5fZnJhbWVXaWR0aCwgZnJhbWVIZWlnaHQgPSB0aGlzLl9mcmFtZUhlaWdodDtcblx0XHR2YXIgc3BhY2luZyA9IHRoaXMuX3NwYWNpbmcsIG1hcmdpbiA9IHRoaXMuX21hcmdpbjtcblx0XHRcblx0XHRpbWdMb29wOlxuXHRcdGZvciAodmFyIGk9MCwgaW1ncz10aGlzLl9pbWFnZXM7IGk8aW1ncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGltZyA9IGltZ3NbaV0sIGltZ1cgPSBpbWcud2lkdGgsIGltZ0ggPSBpbWcuaGVpZ2h0O1xuXG5cdFx0XHR2YXIgeSA9IG1hcmdpbjtcblx0XHRcdHdoaWxlICh5IDw9IGltZ0gtbWFyZ2luLWZyYW1lSGVpZ2h0KSB7XG5cdFx0XHRcdHZhciB4ID0gbWFyZ2luO1xuXHRcdFx0XHR3aGlsZSAoeCA8PSBpbWdXLW1hcmdpbi1mcmFtZVdpZHRoKSB7XG5cdFx0XHRcdFx0aWYgKGZyYW1lQ291bnQgPj0gbWF4RnJhbWVzKSB7IGJyZWFrIGltZ0xvb3A7IH1cblx0XHRcdFx0XHRmcmFtZUNvdW50Kys7XG5cdFx0XHRcdFx0dGhpcy5fZnJhbWVzLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRpbWFnZTogaW1nLFxuXHRcdFx0XHRcdFx0XHRyZWN0OiBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKHgsIHksIGZyYW1lV2lkdGgsIGZyYW1lSGVpZ2h0KSxcblx0XHRcdFx0XHRcdFx0cmVnWDogdGhpcy5fcmVnWCxcblx0XHRcdFx0XHRcdFx0cmVnWTogdGhpcy5fcmVnWVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0eCArPSBmcmFtZVdpZHRoK3NwYWNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdFx0eSArPSBmcmFtZUhlaWdodCtzcGFjaW5nO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9udW1GcmFtZXMgPSBmcmFtZUNvdW50O1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuU3ByaXRlU2hlZXQgPSBjcmVhdGVqcy5wcm9tb3RlKFNwcml0ZVNoZWV0LCBcIkV2ZW50RGlzcGF0Y2hlclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBHcmFwaGljcy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogVGhlIEdyYXBoaWNzIGNsYXNzIGV4cG9zZXMgYW4gZWFzeSB0byB1c2UgQVBJIGZvciBnZW5lcmF0aW5nIHZlY3RvciBkcmF3aW5nIGluc3RydWN0aW9ucyBhbmQgZHJhd2luZyB0aGVtIHRvIGFcblx0ICogc3BlY2lmaWVkIGNvbnRleHQuIE5vdGUgdGhhdCB5b3UgY2FuIHVzZSBHcmFwaGljcyB3aXRob3V0IGFueSBkZXBlbmRlbmN5IG9uIHRoZSBFYXNlbEpTIGZyYW1ld29yayBieSBjYWxsaW5nIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZGlyZWN0bHksIG9yIGl0IGNhbiBiZSB1c2VkIHdpdGggdGhlIHt7I2Nyb3NzTGluayBcIlNoYXBlXCJ9fXt7L2Nyb3NzTGlua319IG9iamVjdCB0byBkcmF3IHZlY3RvciBncmFwaGljcyB3aXRoaW4gdGhlXG5cdCAqIGNvbnRleHQgb2YgYW4gRWFzZWxKUyBkaXNwbGF5IGxpc3QuXG5cdCAqXG5cdCAqIFRoZXJlIGFyZSB0d28gYXBwcm9hY2hlcyB0byB3b3JraW5nIHdpdGggR3JhcGhpY3Mgb2JqZWN0OiBjYWxsaW5nIG1ldGhvZHMgb24gYSBHcmFwaGljcyBpbnN0YW5jZSAodGhlIFwiR3JhcGhpY3MgQVBJXCIpLCBvclxuXHQgKiBpbnN0YW50aWF0aW5nIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0cyBhbmQgYWRkaW5nIHRoZW0gdG8gdGhlIGdyYXBoaWNzIHF1ZXVlIHZpYSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFRoZSBmb3JtZXIgYWJzdHJhY3RzIHRoZSBsYXR0ZXIsIHNpbXBsaWZ5aW5nIGJlZ2lubmluZyBhbmQgZW5kaW5nIHBhdGhzLCBmaWxscywgYW5kIHN0cm9rZXMuXG5cdCAqXG5cdCAqICAgICAgdmFyIGcgPSBuZXcgY3JlYXRlanMuR3JhcGhpY3MoKTtcblx0ICogICAgICBnLnNldFN0cm9rZVN0eWxlKDEpO1xuXHQgKiAgICAgIGcuYmVnaW5TdHJva2UoXCIjMDAwMDAwXCIpO1xuXHQgKiAgICAgIGcuYmVnaW5GaWxsKFwicmVkXCIpO1xuXHQgKiAgICAgIGcuZHJhd0NpcmNsZSgwLDAsMzApO1xuXHQgKlxuXHQgKiBBbGwgZHJhd2luZyBtZXRob2RzIGluIEdyYXBoaWNzIHJldHVybiB0aGUgR3JhcGhpY3MgaW5zdGFuY2UsIHNvIHRoZXkgY2FuIGJlIGNoYWluZWQgdG9nZXRoZXIuIEZvciBleGFtcGxlLFxuXHQgKiB0aGUgZm9sbG93aW5nIGxpbmUgb2YgY29kZSB3b3VsZCBnZW5lcmF0ZSB0aGUgaW5zdHJ1Y3Rpb25zIHRvIGRyYXcgYSByZWN0YW5nbGUgd2l0aCBhIHJlZCBzdHJva2UgYW5kIGJsdWUgZmlsbDpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLmJlZ2luU3Ryb2tlKFwicmVkXCIpLmJlZ2luRmlsbChcImJsdWVcIikuZHJhd1JlY3QoMjAsIDIwLCAxMDAsIDUwKTtcblx0ICpcblx0ICogRWFjaCBncmFwaGljcyBBUEkgY2FsbCBnZW5lcmF0ZXMgYSBjb21tYW5kIG9iamVjdCAoc2VlIGJlbG93KS4gVGhlIGxhc3QgY29tbWFuZCB0byBiZSBjcmVhdGVkIGNhbiBiZSBhY2Nlc3NlZCB2aWFcblx0ICoge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvY29tbWFuZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTpcblx0ICpcblx0ICogICAgICB2YXIgZmlsbENvbW1hbmQgPSBteUdyYXBoaWNzLmJlZ2luRmlsbChcInJlZFwiKS5jb21tYW5kO1xuXHQgKiAgICAgIC8vIC4uLiBsYXRlciwgdXBkYXRlIHRoZSBmaWxsIHN0eWxlL2NvbG9yOlxuXHQgKiAgICAgIGZpbGxDb21tYW5kLnN0eWxlID0gXCJibHVlXCI7XG5cdCAqICAgICAgLy8gb3IgY2hhbmdlIGl0IHRvIGEgYml0bWFwIGZpbGw6XG5cdCAqICAgICAgZmlsbENvbW1hbmQuYml0bWFwKG15SW1hZ2UpO1xuXHQgKlxuXHQgKiBGb3IgbW9yZSBkaXJlY3QgY29udHJvbCBvZiByZW5kZXJpbmcsIHlvdSBjYW4gaW5zdGFudGlhdGUgYW5kIGFwcGVuZCBjb21tYW5kIG9iamVjdHMgdG8gdGhlIGdyYXBoaWNzIHF1ZXVlIGRpcmVjdGx5LiBJbiB0aGlzIGNhc2UsIHlvdVxuXHQgKiBuZWVkIHRvIG1hbmFnZSBwYXRoIGNyZWF0aW9uIG1hbnVhbGx5LCBhbmQgZW5zdXJlIHRoYXQgZmlsbC9zdHJva2UgaXMgYXBwbGllZCB0byBhIGRlZmluZWQgcGF0aDpcblx0ICpcblx0ICogICAgICAvLyBzdGFydCBhIG5ldyBwYXRoLiBHcmFwaGljcy5iZWdpbkNtZCBpcyBhIHJldXNhYmxlIEJlZ2luUGF0aCBpbnN0YW5jZTpcblx0ICogICAgICBteUdyYXBoaWNzLmFwcGVuZChjcmVhdGVqcy5HcmFwaGljcy5iZWdpbkNtZCk7XG5cdCAqICAgICAgLy8gd2UgbmVlZCB0byBkZWZpbmUgdGhlIHBhdGggYmVmb3JlIGFwcGx5aW5nIHRoZSBmaWxsOlxuXHQgKiAgICAgIHZhciBjaXJjbGUgPSBuZXcgY3JlYXRlanMuR3JhcGhpY3MuQ2lyY2xlKDAsMCwzMCk7XG5cdCAqICAgICAgbXlHcmFwaGljcy5hcHBlbmQoY2lyY2xlKTtcblx0ICogICAgICAvLyBmaWxsIHRoZSBwYXRoIHdlIGp1c3QgZGVmaW5lZDpcblx0ICogICAgICB2YXIgZmlsbCA9IG5ldyBjcmVhdGVqcy5HcmFwaGljcy5GaWxsKFwicmVkXCIpO1xuXHQgKiAgICAgIG15R3JhcGhpY3MuYXBwZW5kKGZpbGwpO1xuXHQgKlxuXHQgKiBUaGVzZSBhcHByb2FjaGVzIGNhbiBiZSB1c2VkIHRvZ2V0aGVyLCBmb3IgZXhhbXBsZSB0byBpbnNlcnQgYSBjdXN0b20gY29tbWFuZDpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLmJlZ2luRmlsbChcInJlZFwiKTtcblx0ICogICAgICB2YXIgY3VzdG9tQ29tbWFuZCA9IG5ldyBDdXN0b21TcGlyYWxDb21tYW5kKGV0Yyk7XG5cdCAqICAgICAgbXlHcmFwaGljcy5hcHBlbmQoY3VzdG9tQ29tbWFuZCk7XG5cdCAqICAgICAgbXlHcmFwaGljcy5iZWdpbkZpbGwoXCJibHVlXCIpO1xuXHQgKiAgICAgIG15R3JhcGhpY3MuZHJhd0NpcmNsZSgwLCAwLCAzMCk7XG5cdCAqXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mbyBvbiBjcmVhdGluZyBjdXN0b20gY29tbWFuZHMuXG5cdCAqXG5cdCAqIDxoND5UaW55IEFQSTwvaDQ+XG5cdCAqIFRoZSBHcmFwaGljcyBjbGFzcyBhbHNvIGluY2x1ZGVzIGEgXCJ0aW55IEFQSVwiLCB3aGljaCBpcyBvbmUgb3IgdHdvLWxldHRlciBtZXRob2RzIHRoYXQgYXJlIHNob3J0Y3V0cyBmb3IgYWxsIG9mIHRoZVxuXHQgKiBHcmFwaGljcyBtZXRob2RzLiBUaGVzZSBtZXRob2RzIGFyZSBncmVhdCBmb3IgY3JlYXRpbmcgY29tcGFjdCBpbnN0cnVjdGlvbnMsIGFuZCBpcyB1c2VkIGJ5IHRoZSBUb29sa2l0IGZvciBDcmVhdGVKU1xuXHQgKiB0byBnZW5lcmF0ZSByZWFkYWJsZSBjb2RlLiBBbGwgdGlueSBtZXRob2RzIGFyZSBtYXJrZWQgYXMgcHJvdGVjdGVkLCBzbyB5b3UgY2FuIHZpZXcgdGhlbSBieSBlbmFibGluZyBwcm90ZWN0ZWRcblx0ICogZGVzY3JpcHRpb25zIGluIHRoZSBkb2NzLlxuXHQgKlxuXHQgKiA8dGFibGU+XG5cdCAqICAgICA8dHI+PHRkPjxiPlRpbnk8L2I+PC90ZD48dGQ+PGI+TWV0aG9kPC9iPjwvdGQ+PHRkPjxiPlRpbnk8L2I+PC90ZD48dGQ+PGI+TWV0aG9kPC9iPjwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+bXQ8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9tb3ZlVG9cIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5sdDwvdGQ+IDx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9saW5lVG9cIn19e3svY3Jvc3NMaW5rfX08L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPmEvYXQ8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcmNcIn19e3svY3Jvc3NMaW5rfX0gLyB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcmNUb1wifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPmJ0PC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmV6aWVyQ3VydmVUb1wifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPnF0PC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvcXVhZHJhdGljQ3VydmVUb1wifX17ey9jcm9zc0xpbmt9fSAoYWxzbyBjdXJ2ZVRvKTwvdGQ+XG5cdCAqICAgICA8dGQ+cjwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3JlY3RcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5jcDwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2Nsb3NlUGF0aFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPmM8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9jbGVhclwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPmY8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkZpbGxcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5sZjwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luTGluZWFyR3JhZGllbnRGaWxsXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+cmY8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpblJhZGlhbEdyYWRpZW50RmlsbFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPmJmPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5CaXRtYXBGaWxsXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+ZWY8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9lbmRGaWxsXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+c3MgLyBzZDwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3NldFN0cm9rZVN0eWxlXCJ9fXt7L2Nyb3NzTGlua319IC8ge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3Mvc2V0U3Ryb2tlRGFzaFwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPnM8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpblN0cm9rZVwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPmxzPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5MaW5lYXJHcmFkaWVudFN0cm9rZVwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPnJzPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5SYWRpYWxHcmFkaWVudFN0cm9rZVwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPmJzPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5CaXRtYXBTdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5lczwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2VuZFN0cm9rZVwifX17ey9jcm9zc0xpbmt9fSA8L3RkPlxuXHQgKiAgICAgPHRkPmRyPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd1JlY3RcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiAgICAgPHRyPjx0ZD5ycjwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdSb3VuZFJlY3RcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD5cblx0ICogICAgIDx0ZD5yYzwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdSb3VuZFJlY3RDb21wbGV4XCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+PC90cj5cblx0ICogICAgIDx0cj48dGQ+ZGM8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Q2lyY2xlXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+ZGU8L3RkPjx0ZD57eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3RWxsaXBzZVwifX17ey9jcm9zc0xpbmt9fSA8L3RkPjwvdHI+XG5cdCAqICAgICA8dHI+PHRkPmRwPC90ZD48dGQ+e3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd1BvbHlTdGFyXCJ9fXt7L2Nyb3NzTGlua319IDwvdGQ+XG5cdCAqICAgICA8dGQ+cDwvdGQ+PHRkPnt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RlY29kZVBhdGhcIn19e3svY3Jvc3NMaW5rfX0gPC90ZD48L3RyPlxuXHQgKiA8L3RhYmxlPlxuXHQgKlxuXHQgKiBIZXJlIGlzIHRoZSBhYm92ZSBleGFtcGxlLCB1c2luZyB0aGUgdGlueSBBUEkgaW5zdGVhZC5cblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLnMoXCJyZWRcIikuZihcImJsdWVcIikucigyMCwgMjAsIDEwMCwgNTApO1xuXHQgKlxuXHQgKiBAY2xhc3MgR3JhcGhpY3Ncblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gR3JhcGhpY3MoKSB7XG5cblxuXHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEhvbGRzIGEgcmVmZXJlbmNlIHRvIHRoZSBsYXN0IGNvbW1hbmQgdGhhdCB3YXMgY3JlYXRlZCBvciBhcHBlbmRlZC4gRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCByZXRhaW4gYSByZWZlcmVuY2Vcblx0XHQgKiB0byBhIEZpbGwgY29tbWFuZCBpbiBvcmRlciB0byBkeW5hbWljYWxseSB1cGRhdGUgdGhlIGNvbG9yIGxhdGVyIGJ5IHVzaW5nOlxuXHRcdCAqIFx0XHRteUZpbGwgPSBteUdyYXBoaWNzLmJlZ2luRmlsbChcInJlZFwiKS5jb21tYW5kO1xuXHRcdCAqIFx0XHQvLyB1cGRhdGUgY29sb3IgbGF0ZXI6XG5cdFx0ICogXHRcdG15RmlsbC5zdHlsZSA9IFwieWVsbG93XCI7XG5cdFx0ICogQHByb3BlcnR5IGNvbW1hbmRcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiovXG5cdFx0dGhpcy5jb21tYW5kID0gbnVsbDtcblxuXG5cdC8vIHByaXZhdGUgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfc3Ryb2tlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtTdHJva2V9XG5cdFx0ICoqL1xuXHRcdHRoaXMuX3N0cm9rZSA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3N0cm9rZVN0eWxlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtTdHJva2VTdHlsZX1cblx0XHQgKiovXG5cdFx0dGhpcy5fc3Ryb2tlU3R5bGUgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfb2xkU3Ryb2tlU3R5bGVcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge1N0cm9rZVN0eWxlfVxuXHRcdCAqKi9cblx0XHR0aGlzLl9vbGRTdHJva2VTdHlsZSA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9zdHJva2VEYXNoXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtTdHJva2VEYXNofVxuXHRcdCAqKi9cblx0XHR0aGlzLl9zdHJva2VEYXNoID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX29sZFN0cm9rZURhc2hcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge1N0cm9rZURhc2h9XG5cdFx0ICoqL1xuXHRcdHRoaXMuX29sZFN0cm9rZURhc2ggPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9zdHJva2VJZ25vcmVTY2FsZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3N0cm9rZUlnbm9yZVNjYWxlID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2ZpbGxcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge0ZpbGx9XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2ZpbGwgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9pbnN0cnVjdGlvbnNcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqKi9cblx0XHR0aGlzLl9pbnN0cnVjdGlvbnMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB0aGUgbGFzdCBpbnN0cnVjdGlvbiBpbmRleCB0aGF0IHdhcyBjb21taXR0ZWQuXG5cdFx0ICogQHByb3BlcnR5IF9jb21taXRJbmRleFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqKi9cblx0XHR0aGlzLl9jb21taXRJbmRleCA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBVbmNvbW1pdHRlZCBpbnN0cnVjdGlvbnMuXG5cdFx0ICogQHByb3BlcnR5IF9hY3RpdmVJbnN0cnVjdGlvbnNcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqKi9cblx0XHR0aGlzLl9hY3RpdmVJbnN0cnVjdGlvbnMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaGF2ZSBiZWVuIGNoYW5nZXMgdG8gdGhlIGFjdGl2ZUluc3RydWN0aW9uIGxpc3Qgc2luY2UgdGhlIGxhc3QgdXBkYXRlSW5zdHJ1Y3Rpb25zIGNhbGwuXG5cdFx0ICogQHByb3BlcnR5IF9kaXJ0eVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqKi9cblx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogSW5kZXggdG8gZHJhdyBmcm9tIGlmIGEgc3RvcmUgb3BlcmF0aW9uIGhhcyBoYXBwZW5lZC5cblx0XHQgKiBAcHJvcGVydHkgX3N0b3JlSW5kZXhcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3N0b3JlSW5kZXggPSAwO1xuXG5cdC8vIHNldHVwOlxuXHRcdHRoaXMuY2xlYXIoKTtcblx0fVxuXHR2YXIgcCA9IEdyYXBoaWNzLnByb3RvdHlwZTtcblx0dmFyIEcgPSBHcmFwaGljczsgLy8gc2hvcnRjdXRcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuLy8gc3RhdGljIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyBhIENTUyBjb21wYXRpYmxlIGNvbG9yIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIFJHQiBudW1lcmljIGNvbG9yIHZhbHVlcyBpbiB0aGUgZm9ybWF0XG5cdCAqIFwicmdiYSgyNTUsMjU1LDI1NSwxLjApXCIsIG9yIGlmIGFscGhhIGlzIG51bGwgdGhlbiBpbiB0aGUgZm9ybWF0IFwicmdiKDI1NSwyNTUsMjU1KVwiLiBGb3IgZXhhbXBsZSxcblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5HcmFwaGljcy5nZXRSR0IoNTAsIDEwMCwgMTUwLCAwLjUpO1xuXHQgKiAgICAgIC8vIFJldHVybnMgXCJyZ2JhKDUwLDEwMCwxNTAsMC41KVwiXG5cdCAqXG5cdCAqIEl0IGFsc28gc3VwcG9ydHMgcGFzc2luZyBhIHNpbmdsZSBoZXggY29sb3IgdmFsdWUgYXMgdGhlIGZpcnN0IHBhcmFtLCBhbmQgYW4gb3B0aW9uYWwgYWxwaGEgdmFsdWUgYXMgdGhlIHNlY29uZFxuXHQgKiBwYXJhbS4gRm9yIGV4YW1wbGUsXG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuR3JhcGhpY3MuZ2V0UkdCKDB4RkYwMEZGLCAwLjIpO1xuXHQgKiAgICAgIC8vIFJldHVybnMgXCJyZ2JhKDI1NSwwLDI1NSwwLjIpXCJcblx0ICpcblx0ICogQG1ldGhvZCBnZXRSR0Jcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gciBUaGUgcmVkIGNvbXBvbmVudCBmb3IgdGhlIGNvbG9yLCBiZXR3ZWVuIDAgYW5kIDB4RkYgKDI1NSkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBnIFRoZSBncmVlbiBjb21wb25lbnQgZm9yIHRoZSBjb2xvciwgYmV0d2VlbiAwIGFuZCAweEZGICgyNTUpLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgYmx1ZSBjb21wb25lbnQgZm9yIHRoZSBjb2xvciwgYmV0d2VlbiAwIGFuZCAweEZGICgyNTUpLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2FscGhhXSBUaGUgYWxwaGEgY29tcG9uZW50IGZvciB0aGUgY29sb3Igd2hlcmUgMCBpcyBmdWxseSB0cmFuc3BhcmVudCBhbmQgMSBpcyBmdWxseSBvcGFxdWUuXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gQSBDU1MgY29tcGF0aWJsZSBjb2xvciBzdHJpbmcgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBSR0IgbnVtZXJpYyBjb2xvciB2YWx1ZXMgaW4gdGhlIGZvcm1hdFxuXHQgKiBcInJnYmEoMjU1LDI1NSwyNTUsMS4wKVwiLCBvciBpZiBhbHBoYSBpcyBudWxsIHRoZW4gaW4gdGhlIGZvcm1hdCBcInJnYigyNTUsMjU1LDI1NSlcIi5cblx0ICoqL1xuXHRHcmFwaGljcy5nZXRSR0IgPSBmdW5jdGlvbihyLCBnLCBiLCBhbHBoYSkge1xuXHRcdGlmIChyICE9IG51bGwgJiYgYiA9PSBudWxsKSB7XG5cdFx0XHRhbHBoYSA9IGc7XG5cdFx0XHRiID0gciYweEZGO1xuXHRcdFx0ZyA9IHI+PjgmMHhGRjtcblx0XHRcdHIgPSByPj4xNiYweEZGO1xuXHRcdH1cblx0XHRpZiAoYWxwaGEgPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIFwicmdiKFwiK3IrXCIsXCIrZytcIixcIitiK1wiKVwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gXCJyZ2JhKFwiK3IrXCIsXCIrZytcIixcIitiK1wiLFwiK2FscGhhK1wiKVwiO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIENTUyBjb21wYXRpYmxlIGNvbG9yIHN0cmluZyBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIEhTTCBudW1lcmljIGNvbG9yIHZhbHVlcyBpbiB0aGUgZm9ybWF0IFwiaHNsYSgzNjAsMTAwLDEwMCwxLjApXCIsXG5cdCAqIG9yIGlmIGFscGhhIGlzIG51bGwgdGhlbiBpbiB0aGUgZm9ybWF0IFwiaHNsKDM2MCwxMDAsMTAwKVwiLlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLkdyYXBoaWNzLmdldEhTTCgxNTAsIDEwMCwgNzApO1xuXHQgKiAgICAgIC8vIFJldHVybnMgXCJoc2woMTUwLDEwMCw3MClcIlxuXHQgKlxuXHQgKiBAbWV0aG9kIGdldEhTTFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBodWUgVGhlIGh1ZSBjb21wb25lbnQgZm9yIHRoZSBjb2xvciwgYmV0d2VlbiAwIGFuZCAzNjAuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzYXR1cmF0aW9uIFRoZSBzYXR1cmF0aW9uIGNvbXBvbmVudCBmb3IgdGhlIGNvbG9yLCBiZXR3ZWVuIDAgYW5kIDEwMC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGxpZ2h0bmVzcyBUaGUgbGlnaHRuZXNzIGNvbXBvbmVudCBmb3IgdGhlIGNvbG9yLCBiZXR3ZWVuIDAgYW5kIDEwMC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthbHBoYV0gVGhlIGFscGhhIGNvbXBvbmVudCBmb3IgdGhlIGNvbG9yIHdoZXJlIDAgaXMgZnVsbHkgdHJhbnNwYXJlbnQgYW5kIDEgaXMgZnVsbHkgb3BhcXVlLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IEEgQ1NTIGNvbXBhdGlibGUgY29sb3Igc3RyaW5nIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgSFNMIG51bWVyaWMgY29sb3IgdmFsdWVzIGluIHRoZSBmb3JtYXRcblx0ICogXCJoc2xhKDM2MCwxMDAsMTAwLDEuMClcIiwgb3IgaWYgYWxwaGEgaXMgbnVsbCB0aGVuIGluIHRoZSBmb3JtYXQgXCJoc2woMzYwLDEwMCwxMDApXCIuXG5cdCAqKi9cblx0R3JhcGhpY3MuZ2V0SFNMID0gZnVuY3Rpb24oaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MsIGFscGhhKSB7XG5cdFx0aWYgKGFscGhhID09IG51bGwpIHtcblx0XHRcdHJldHVybiBcImhzbChcIisoaHVlJTM2MCkrXCIsXCIrc2F0dXJhdGlvbitcIiUsXCIrbGlnaHRuZXNzK1wiJSlcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFwiaHNsYShcIisoaHVlJTM2MCkrXCIsXCIrc2F0dXJhdGlvbitcIiUsXCIrbGlnaHRuZXNzK1wiJSxcIithbHBoYStcIilcIjtcblx0XHR9XG5cdH07XG5cblxuLy8gc3RhdGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBBIHJldXNhYmxlIGluc3RhbmNlIG9mIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL0JlZ2luUGF0aFwifX17ey9jcm9zc0xpbmt9fSB0byBhdm9pZFxuXHQgKiB1bm5lY2Vzc2FyeSBpbnN0YW50aWF0aW9uLlxuXHQgKiBAcHJvcGVydHkgYmVnaW5DbWRcblx0ICogQHR5cGUge0dyYXBoaWNzLkJlZ2luUGF0aH1cblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdCAvLyBkZWZpbmVkIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuXG5cdC8qKlxuXHQgKiBNYXAgb2YgQmFzZTY0IGNoYXJhY3RlcnMgdG8gdmFsdWVzLiBVc2VkIGJ5IHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RlY29kZVBhdGhcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBwcm9wZXJ0eSBCQVNFXzY0XG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqIEByZWFkb25seVxuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKiovXG5cdEdyYXBoaWNzLkJBU0VfNjQgPSB7XCJBXCI6MCxcIkJcIjoxLFwiQ1wiOjIsXCJEXCI6MyxcIkVcIjo0LFwiRlwiOjUsXCJHXCI6NixcIkhcIjo3LFwiSVwiOjgsXCJKXCI6OSxcIktcIjoxMCxcIkxcIjoxMSxcIk1cIjoxMixcIk5cIjoxMyxcIk9cIjoxNCxcIlBcIjoxNSxcIlFcIjoxNixcIlJcIjoxNyxcIlNcIjoxOCxcIlRcIjoxOSxcIlVcIjoyMCxcIlZcIjoyMSxcIldcIjoyMixcIlhcIjoyMyxcIllcIjoyNCxcIlpcIjoyNSxcImFcIjoyNixcImJcIjoyNyxcImNcIjoyOCxcImRcIjoyOSxcImVcIjozMCxcImZcIjozMSxcImdcIjozMixcImhcIjozMyxcImlcIjozNCxcImpcIjozNSxcImtcIjozNixcImxcIjozNyxcIm1cIjozOCxcIm5cIjozOSxcIm9cIjo0MCxcInBcIjo0MSxcInFcIjo0MixcInJcIjo0MyxcInNcIjo0NCxcInRcIjo0NSxcInVcIjo0NixcInZcIjo0NyxcIndcIjo0OCxcInhcIjo0OSxcInlcIjo1MCxcInpcIjo1MSxcIjBcIjo1MixcIjFcIjo1MyxcIjJcIjo1NCxcIjNcIjo1NSxcIjRcIjo1NixcIjVcIjo1NyxcIjZcIjo1OCxcIjdcIjo1OSxcIjhcIjo2MCxcIjlcIjo2MSxcIitcIjo2MixcIi9cIjo2M307XG5cblx0LyoqXG5cdCAqIE1hcHMgbnVtZXJpYyB2YWx1ZXMgZm9yIHRoZSBjYXBzIHBhcmFtZXRlciBvZiB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9zZXRTdHJva2VTdHlsZVwifX17ey9jcm9zc0xpbmt9fSB0b1xuXHQgKiBjb3JyZXNwb25kaW5nIHN0cmluZyB2YWx1ZXMuIFRoaXMgaXMgcHJpbWFyaWx5IGZvciB1c2Ugd2l0aCB0aGUgdGlueSBBUEkuIFRoZSBtYXBwaW5ncyBhcmUgYXMgZm9sbG93czogMCB0b1xuXHQgKiBcImJ1dHRcIiwgMSB0byBcInJvdW5kXCIsIGFuZCAyIHRvIFwic3F1YXJlXCIuXG5cdCAqIEZvciBleGFtcGxlLCB0byBzZXQgdGhlIGxpbmUgY2FwcyB0byBcInNxdWFyZVwiOlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3Muc3MoMTYsIDIpO1xuXHQgKlxuXHQgKiBAcHJvcGVydHkgU1RST0tFX0NBUFNfTUFQXG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqIEByZWFkb25seVxuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqKi9cblx0R3JhcGhpY3MuU1RST0tFX0NBUFNfTUFQID0gW1wiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCJdO1xuXG5cdC8qKlxuXHQgKiBNYXBzIG51bWVyaWMgdmFsdWVzIGZvciB0aGUgam9pbnRzIHBhcmFtZXRlciBvZiB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9zZXRTdHJva2VTdHlsZVwifX17ey9jcm9zc0xpbmt9fSB0b1xuXHQgKiBjb3JyZXNwb25kaW5nIHN0cmluZyB2YWx1ZXMuIFRoaXMgaXMgcHJpbWFyaWx5IGZvciB1c2Ugd2l0aCB0aGUgdGlueSBBUEkuIFRoZSBtYXBwaW5ncyBhcmUgYXMgZm9sbG93czogMCB0b1xuXHQgKiBcIm1pdGVyXCIsIDEgdG8gXCJyb3VuZFwiLCBhbmQgMiB0byBcImJldmVsXCIuXG5cdCAqIEZvciBleGFtcGxlLCB0byBzZXQgdGhlIGxpbmUgam9pbnRzIHRvIFwiYmV2ZWxcIjpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLnNzKDE2LCAwLCAyKTtcblx0ICpcblx0ICogQHByb3BlcnR5IFNUUk9LRV9KT0lOVFNfTUFQXG5cdCAqIEBzdGF0aWNcblx0ICogQGZpbmFsXG5cdCAqIEByZWFkb25seVxuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqKi9cblx0R3JhcGhpY3MuU1RST0tFX0pPSU5UU19NQVAgPSBbXCJtaXRlclwiLCBcInJvdW5kXCIsIFwiYmV2ZWxcIl07XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfY3R4XG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuXHQgKiovXG5cdHZhciBjYW52YXMgPSAoY3JlYXRlanMuY3JlYXRlQ2FudmFzP2NyZWF0ZWpzLmNyZWF0ZUNhbnZhcygpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikpO1xuXHRpZiAoY2FudmFzLmdldENvbnRleHQpIHtcblx0XHRHcmFwaGljcy5fY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHRjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMTtcblx0fVxuXG5cbi8vIGdldHRlciAvIHNldHRlcnM6XG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2luc3RydWN0aW9uczpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldEluc3RydWN0aW9uc1xuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRwLmdldEluc3RydWN0aW9ucyA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3VwZGF0ZUluc3RydWN0aW9ucygpO1xuXHRcdHJldHVybiB0aGlzLl9pbnN0cnVjdGlvbnM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGdyYXBoaWNzIGluc3RydWN0aW9ucyBhcnJheS4gRWFjaCBlbnRyeSBpcyBhIGdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0IChleC4gR3JhcGhpY3MuRmlsbCwgR3JhcGhpY3MuUmVjdClcblx0ICogTW9kaWZ5aW5nIHRoZSByZXR1cm5lZCBhcnJheSBkaXJlY3RseSBpcyBub3QgcmVjb21tZW5kZWQsIGFuZCBpcyBsaWtlbHkgdG8gcmVzdWx0IGluIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLlxuXHQgKlxuXHQgKiBUaGlzIHByb3BlcnR5IGlzIG1haW5seSBpbnRlbmRlZCBmb3IgaW50cm9zcGVjdGlvbiBvZiB0aGUgaW5zdHJ1Y3Rpb25zIChleC4gZm9yIGdyYXBoaWNzIGV4cG9ydCkuXG5cdCAqIEBwcm9wZXJ0eSBpbnN0cnVjdGlvbnNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcblx0XHRcdGluc3RydWN0aW9uczogeyBnZXQ6IHAuZ2V0SW5zdHJ1Y3Rpb25zIH1cblx0XHR9KTtcblx0fSBjYXRjaCAoZSkge31cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIEdyYXBoaWNzIGluc3RhbmNlIGhhcyBubyBkcmF3aW5nIGNvbW1hbmRzLlxuXHQgKiBAbWV0aG9kIGlzRW1wdHlcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoaXMgR3JhcGhpY3MgaW5zdGFuY2UgaGFzIG5vIGRyYXdpbmcgY29tbWFuZHMuXG5cdCAqKi9cblx0cC5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEodGhpcy5faW5zdHJ1Y3Rpb25zLmxlbmd0aCB8fCB0aGlzLl9hY3RpdmVJbnN0cnVjdGlvbnMubGVuZ3RoKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgdGhlIGRpc3BsYXkgb2JqZWN0IGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IGlnbm9yaW5nIGl0cyB2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBhbmQgdHJhbnNmb3JtLlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cblx0ICpcblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGRyYXdcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgT3B0aW9uYWwgZGF0YSB0aGF0IGlzIHBhc3NlZCB0byBncmFwaGljcyBjb21tYW5kIGV4ZWMgbWV0aG9kcy4gV2hlbiBjYWxsZWQgZnJvbSBhIFNoYXBlIGluc3RhbmNlLCB0aGUgc2hhcGUgcGFzc2VzIGl0c2VsZiBhcyB0aGUgZGF0YSBwYXJhbWV0ZXIuIFRoaXMgY2FuIGJlIHVzZWQgYnkgY3VzdG9tIGdyYXBoaWMgY29tbWFuZHMgdG8gaW5zZXJ0IGNvbnRleHR1YWwgZGF0YS5cblx0ICoqL1xuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGRhdGEpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnMoKTtcblx0XHR2YXIgaW5zdHIgPSB0aGlzLl9pbnN0cnVjdGlvbnM7XG5cdFx0Zm9yICh2YXIgaT10aGlzLl9zdG9yZUluZGV4LCBsPWluc3RyLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdGluc3RyW2ldLmV4ZWMoY3R4LCBkYXRhKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIG9ubHkgdGhlIHBhdGggZGVzY3JpYmVkIGZvciB0aGlzIEdyYXBoaWNzIGluc3RhbmNlLCBza2lwcGluZyBhbnkgbm9uLXBhdGggaW5zdHJ1Y3Rpb25zLCBpbmNsdWRpbmcgZmlsbCBhbmRcblx0ICogc3Ryb2tlIGRlc2NyaXB0aW9ucy4gVXNlZCBmb3IgPGNvZGU+RGlzcGxheU9iamVjdC5tYXNrPC9jb2RlPiB0byBkcmF3IHRoZSBjbGlwcGluZyBwYXRoLCBmb3IgZXhhbXBsZS5cblx0ICpcblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGRyYXdBc1BhdGhcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cblx0ICoqL1xuXHRwLmRyYXdBc1BhdGggPSBmdW5jdGlvbihjdHgpIHtcblx0XHR0aGlzLl91cGRhdGVJbnN0cnVjdGlvbnMoKTtcblx0XHR2YXIgaW5zdHIsIGluc3RycyA9IHRoaXMuX2luc3RydWN0aW9ucztcblx0XHRmb3IgKHZhciBpPXRoaXMuX3N0b3JlSW5kZXgsIGw9aW5zdHJzLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdC8vIHRoZSBmaXJzdCBjb21tYW5kIGlzIGFsd2F5cyBhIGJlZ2luUGF0aCBjb21tYW5kLlxuXHRcdFx0aWYgKChpbnN0ciA9IGluc3Ryc1tpXSkucGF0aCAhPT0gZmFsc2UpIHsgaW5zdHIuZXhlYyhjdHgpOyB9XG5cdFx0fVxuXHR9O1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzIHRoYXQgbWFwIGRpcmVjdGx5IHRvIGNvbnRleHQgMkQgY2FsbHM6XG5cdC8qKlxuXHQgKiBNb3ZlcyB0aGUgZHJhd2luZyBwb2ludCB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLiBBIHRpbnkgQVBJIG1ldGhvZCBcIm10XCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgbW92ZVRvXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgdGhlIGRyYXdpbmcgcG9pbnQgc2hvdWxkIG1vdmUgdG8uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgdGhlIGRyYXdpbmcgcG9pbnQgc2hvdWxkIG1vdmUgdG8uXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMpLlxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5tb3ZlVG8gPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLk1vdmVUbyh4LHkpLCB0cnVlKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgYSBsaW5lIGZyb20gdGhlIGN1cnJlbnQgZHJhd2luZyBwb2ludCB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLCB3aGljaCBiZWNvbWUgdGhlIG5ldyBjdXJyZW50IGRyYXdpbmdcblx0ICogcG9pbnQuIEEgdGlueSBBUEkgbWV0aG9kIFwibHRcIiBhbHNvIGV4aXN0cy5cblx0ICpcblx0ICogRm9yIGRldGFpbGVkIGluZm9ybWF0aW9uLCByZWFkIHRoZVxuXHQgKiA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjY29tcGxleC1zaGFwZXMtKHBhdGhzKVwiPlxuXHQgKiB3aGF0d2cgc3BlYzwvYT4uXG5cdCAqIEBtZXRob2QgbGluZVRvXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGNvb3JkaW5hdGUgdGhlIGRyYXdpbmcgcG9pbnQgc2hvdWxkIGRyYXcgdG8uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGNvb3JkaW5hdGUgdGhlIGRyYXdpbmcgcG9pbnQgc2hvdWxkIGRyYXcgdG8uXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5saW5lVG8gPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLkxpbmVUbyh4LHkpKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgYW4gYXJjIHdpdGggdGhlIHNwZWNpZmllZCBjb250cm9sIHBvaW50cyBhbmQgcmFkaXVzLiAgRm9yIGRldGFpbGVkIGluZm9ybWF0aW9uLCByZWFkIHRoZVxuXHQgKiA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjZG9tLWNvbnRleHQtMmQtYXJjdG9cIj5cblx0ICogd2hhdHdnIHNwZWM8L2E+LiBBIHRpbnkgQVBJIG1ldGhvZCBcImF0XCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYXJjVG9cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geDJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmFyY1RvID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5BcmNUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGFuIGFyYyBkZWZpbmVkIGJ5IHRoZSByYWRpdXMsIHN0YXJ0QW5nbGUgYW5kIGVuZEFuZ2xlIGFyZ3VtZW50cywgY2VudGVyZWQgYXQgdGhlIHBvc2l0aW9uICh4LCB5KS4gRm9yXG5cdCAqIGV4YW1wbGUsIHRvIGRyYXcgYSBmdWxsIGNpcmNsZSB3aXRoIGEgcmFkaXVzIG9mIDIwIGNlbnRlcmVkIGF0ICgxMDAsIDEwMCk6XG5cdCAqXG5cdCAqICAgICAgYXJjKDEwMCwgMTAwLCAyMCwgMCwgTWF0aC5QSSoyKTtcblx0ICpcblx0ICogRm9yIGRldGFpbGVkIGluZm9ybWF0aW9uLCByZWFkIHRoZVxuXHQgKiA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjZG9tLWNvbnRleHQtMmQtYXJjXCI+d2hhdHdnIHNwZWM8L2E+LlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImFcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBhcmNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRBbmdsZSBNZWFzdXJlZCBpbiByYWRpYW5zLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZW5kQW5nbGUgTWVhc3VyZWQgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtCb29sZWFufSBhbnRpY2xvY2t3aXNlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hcmMgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLkFyYyh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgcXVhZHJhdGljIGN1cnZlIGZyb20gdGhlIGN1cnJlbnQgZHJhd2luZyBwb2ludCB0byAoeCwgeSkgdXNpbmcgdGhlIGNvbnRyb2wgcG9pbnQgKGNweCwgY3B5KS4gRm9yIGRldGFpbGVkXG5cdCAqIGluZm9ybWF0aW9uLCByZWFkIHRoZSA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjZG9tLWNvbnRleHQtMmQtcXVhZHJhdGljY3VydmV0b1wiPlxuXHQgKiB3aGF0d2cgc3BlYzwvYT4uIEEgdGlueSBBUEkgbWV0aG9kIFwicXRcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBxdWFkcmF0aWNDdXJ2ZVRvXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNweVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAucXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uKGNweCwgY3B5LCB4LCB5KSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLlF1YWRyYXRpY0N1cnZlVG8oY3B4LCBjcHksIHgsIHkpKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgYSBiZXppZXIgY3VydmUgZnJvbSB0aGUgY3VycmVudCBkcmF3aW5nIHBvaW50IHRvICh4LCB5KSB1c2luZyB0aGUgY29udHJvbCBwb2ludHMgKGNwMXgsIGNwMXkpIGFuZCAoY3AyeCxcblx0ICogY3AyeSkuIEZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiwgcmVhZCB0aGVcblx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2RvbS1jb250ZXh0LTJkLWJlemllcmN1cnZldG9cIj5cblx0ICogd2hhdHdnIHNwZWM8L2E+LiBBIHRpbnkgQVBJIG1ldGhvZCBcImJ0XCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYmV6aWVyQ3VydmVUb1xuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AxeFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AxeVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AyeFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AyeVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuQmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgcmVjdGFuZ2xlIGF0ICh4LCB5KSB3aXRoIHRoZSBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodCB1c2luZyB0aGUgY3VycmVudCBmaWxsIGFuZC9vciBzdHJva2UuXG5cdCAqIEZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiwgcmVhZCB0aGVcblx0ICogPGEgaHJlZj1cImh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1jYW52YXMtZWxlbWVudC5odG1sI2RvbS1jb250ZXh0LTJkLXJlY3RcIj5cblx0ICogd2hhdHdnIHNwZWM8L2E+LiBBIHRpbnkgQVBJIG1ldGhvZCBcInJcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCByZWN0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFdpZHRoIG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGggSGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLnJlY3QgPSBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kKG5ldyBHLlJlY3QoeCwgeSwgdywgaCkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbG9zZXMgdGhlIGN1cnJlbnQgcGF0aCwgZWZmZWN0aXZlbHkgZHJhd2luZyBhIGxpbmUgZnJvbSB0aGUgY3VycmVudCBkcmF3aW5nIHBvaW50IHRvIHRoZSBmaXJzdCBkcmF3aW5nIHBvaW50IHNwZWNpZmllZFxuXHQgKiBzaW5jZSB0aGUgZmlsbCBvciBzdHJva2Ugd2FzIGxhc3Qgc2V0LiBBIHRpbnkgQVBJIG1ldGhvZCBcImNwXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgY2xvc2VQYXRoXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5jbG9zZVBhdGggPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWN0aXZlSW5zdHJ1Y3Rpb25zLmxlbmd0aCA/IHRoaXMuYXBwZW5kKG5ldyBHLkNsb3NlUGF0aCgpKSA6IHRoaXM7XG5cdH07XG5cblxuLy8gcHVibGljIG1ldGhvZHMgdGhhdCByb3VnaGx5IG1hcCB0byBGbGFzaCBncmFwaGljcyBBUElzOlxuXHQvKipcblx0ICogQ2xlYXJzIGFsbCBkcmF3aW5nIGluc3RydWN0aW9ucywgZWZmZWN0aXZlbHkgcmVzZXR0aW5nIHRoaXMgR3JhcGhpY3MgaW5zdGFuY2UuIEFueSBsaW5lIGFuZCBmaWxsIHN0eWxlcyB3aWxsIG5lZWRcblx0ICogdG8gYmUgcmVkZWZpbmVkIHRvIGRyYXcgc2hhcGVzIGZvbGxvd2luZyBhIGNsZWFyIGNhbGwuIEEgdGlueSBBUEkgbWV0aG9kIFwiY1wiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGNsZWFyXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5jbGVhciA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2luc3RydWN0aW9ucy5sZW5ndGggPSB0aGlzLl9hY3RpdmVJbnN0cnVjdGlvbnMubGVuZ3RoID0gdGhpcy5fY29tbWl0SW5kZXggPSAwO1xuXHRcdHRoaXMuX3N0cm9rZVN0eWxlID0gdGhpcy5fb2xkU3Ryb2tlU3R5bGUgPSB0aGlzLl9zdHJva2UgPSB0aGlzLl9maWxsID0gdGhpcy5fc3Ryb2tlRGFzaCA9IHRoaXMuX29sZFN0cm9rZURhc2ggPSBudWxsO1xuXHRcdHRoaXMuX2RpcnR5ID0gdGhpcy5fc3Ryb2tlSWdub3JlU2NhbGUgPSBmYWxzZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW5zIGEgZmlsbCB3aXRoIHRoZSBzcGVjaWZpZWQgY29sb3IuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC4gQSB0aW55IEFQSSBtZXRob2QgXCJmXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYmVnaW5GaWxsXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBBIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlIChleC4gXCJyZWRcIiwgXCIjRkYwMDAwXCIsIG9yIFwicmdiYSgyNTUsMCwwLDAuNSlcIikuIFNldHRpbmcgdG9cblx0ICogbnVsbCB3aWxsIHJlc3VsdCBpbiBubyBmaWxsLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmVnaW5GaWxsID0gZnVuY3Rpb24oY29sb3IpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0RmlsbChjb2xvciA/IG5ldyBHLkZpbGwoY29sb3IpIDogbnVsbCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2lucyBhIGxpbmVhciBncmFkaWVudCBmaWxsIGRlZmluZWQgYnkgdGhlIGxpbmUgKHgwLCB5MCkgdG8gKHgxLCB5MSkuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC4gRm9yXG5cdCAqIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgY29kZSBkZWZpbmVzIGEgYmxhY2sgdG8gd2hpdGUgdmVydGljYWwgZ3JhZGllbnQgcmFuZ2luZyBmcm9tIDIwcHggdG8gMTIwcHgsIGFuZCBkcmF3cyBhXG5cdCAqIHNxdWFyZSB0byBkaXNwbGF5IGl0OlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3MuYmVnaW5MaW5lYXJHcmFkaWVudEZpbGwoW1wiIzAwMFwiLFwiI0ZGRlwiXSwgWzAsIDFdLCAwLCAyMCwgMCwgMTIwKS5kcmF3UmVjdCgyMCwgMjAsIDEyMCwgMTIwKTtcblx0ICpcblx0ICogQSB0aW55IEFQSSBtZXRob2QgXCJsZlwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luTGluZWFyR3JhZGllbnRGaWxsXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBBbiBhcnJheSBvZiBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZXMuIEZvciBleGFtcGxlLCBbXCIjRjAwXCIsXCIjMDBGXCJdIHdvdWxkIGRlZmluZSBhIGdyYWRpZW50XG5cdCAqIGRyYXdpbmcgZnJvbSByZWQgdG8gYmx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zIEFuIGFycmF5IG9mIGdyYWRpZW50IHBvc2l0aW9ucyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjb2xvcnMuIEZvciBleGFtcGxlLCBbMC4xLCAwLjldIHdvdWxkIGRyYXdcblx0ICogdGhlIGZpcnN0IGNvbG9yIHRvIDEwJSB0aGVuIGludGVycG9sYXRpbmcgdG8gdGhlIHNlY29uZCBjb2xvciBhdCA5MCUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTAgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTEgVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5iZWdpbkxpbmVhckdyYWRpZW50RmlsbCA9IGZ1bmN0aW9uKGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHgxLCB5MSkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRGaWxsKG5ldyBHLkZpbGwoKS5saW5lYXJHcmFkaWVudChjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCB4MSwgeTEpKTtcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW5zIGEgcmFkaWFsIGdyYWRpZW50IGZpbGwuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgY29kZSBkZWZpbmVzIGEgcmVkIHRvXG5cdCAqIGJsdWUgcmFkaWFsIGdyYWRpZW50IGNlbnRlcmVkIGF0ICgxMDAsIDEwMCksIHdpdGggYSByYWRpdXMgb2YgNTAsIGFuZCBkcmF3cyBhIGNpcmNsZSB0byBkaXNwbGF5IGl0OlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3MuYmVnaW5SYWRpYWxHcmFkaWVudEZpbGwoW1wiI0YwMFwiLFwiIzAwRlwiXSwgWzAsIDFdLCAxMDAsIDEwMCwgMCwgMTAwLCAxMDAsIDUwKS5kcmF3Q2lyY2xlKDEwMCwgMTAwLCA1MCk7XG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwicmZcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBiZWdpblJhZGlhbEdyYWRpZW50RmlsbFxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnMgQW4gYXJyYXkgb2YgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWVzLiBGb3IgZXhhbXBsZSwgW1wiI0YwMFwiLFwiIzAwRlwiXSB3b3VsZCBkZWZpbmVcblx0ICogYSBncmFkaWVudCBkcmF3aW5nIGZyb20gcmVkIHRvIGJsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvcyBBbiBhcnJheSBvZiBncmFkaWVudCBwb3NpdGlvbnMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgY29sb3JzLiBGb3IgZXhhbXBsZSwgWzAuMSxcblx0ICogMC45XSB3b3VsZCBkcmF3IHRoZSBmaXJzdCBjb2xvciB0byAxMCUgdGhlbiBpbnRlcnBvbGF0aW5nIHRvIHRoZSBzZWNvbmQgY29sb3IgYXQgOTAlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDAgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMCBSYWRpdXMgb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDEgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMSBSYWRpdXMgb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmVnaW5SYWRpYWxHcmFkaWVudEZpbGwgPSBmdW5jdGlvbihjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCByMCwgeDEsIHkxLCByMSkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRGaWxsKG5ldyBHLkZpbGwoKS5yYWRpYWxHcmFkaWVudChjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCByMCwgeDEsIHkxLCByMSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSBwYXR0ZXJuIGZpbGwgdXNpbmcgdGhlIHNwZWNpZmllZCBpbWFnZS4gVGhpcyBlbmRzIHRoZSBjdXJyZW50IHN1Yi1wYXRoLiBBIHRpbnkgQVBJIG1ldGhvZCBcImJmXCIgYWxzb1xuXHQgKiBleGlzdHMuXG5cdCAqIEBtZXRob2QgYmVnaW5CaXRtYXBGaWxsXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgVGhlIEltYWdlLCBDYW52YXMsIG9yIFZpZGVvIG9iamVjdCB0byB1c2Vcblx0ICogYXMgdGhlIHBhdHRlcm4uIE11c3QgYmUgbG9hZGVkIHByaW9yIHRvIGNyZWF0aW5nIGEgYml0bWFwIGZpbGwsIG9yIHRoZSBmaWxsIHdpbGwgYmUgZW1wdHkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSByZXBldGl0aW9uIE9wdGlvbmFsLiBJbmRpY2F0ZXMgd2hldGhlciB0byByZXBlYXQgdGhlIGltYWdlIGluIHRoZSBmaWxsIGFyZWEuIE9uZSBvZiBcInJlcGVhdFwiLFxuXHQgKiBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gRGVmYXVsdHMgdG8gXCJyZXBlYXRcIi4gTm90ZSB0aGF0IEZpcmVmb3ggZG9lcyBub3Qgc3VwcG9ydCBcInJlcGVhdC14XCIgb3Jcblx0ICogXCJyZXBlYXQteVwiIChsYXRlc3QgdGVzdHMgd2VyZSBpbiBGRiAyMC4wKSwgYW5kIHdpbGwgZGVmYXVsdCB0byBcInJlcGVhdFwiLlxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXggT3B0aW9uYWwuIFNwZWNpZmllcyBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBmb3IgdGhlIGJpdG1hcCBmaWxsLiBUaGlzIHRyYW5zZm9ybWF0aW9uXG5cdCAqIHdpbGwgYmUgYXBwbGllZCByZWxhdGl2ZSB0byB0aGUgcGFyZW50IHRyYW5zZm9ybS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlZ2luQml0bWFwRmlsbCA9IGZ1bmN0aW9uKGltYWdlLCByZXBldGl0aW9uLCBtYXRyaXgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2V0RmlsbChuZXcgRy5GaWxsKG51bGwsbWF0cml4KS5iaXRtYXAoaW1hZ2UsIHJlcGV0aXRpb24pKTtcblx0fTtcblxuXHQvKipcblx0ICogRW5kcyB0aGUgY3VycmVudCBzdWItcGF0aCwgYW5kIGJlZ2lucyBhIG5ldyBvbmUgd2l0aCBubyBmaWxsLiBGdW5jdGlvbmFsbHkgaWRlbnRpY2FsIHRvIDxjb2RlPmJlZ2luRmlsbChudWxsKTwvY29kZT4uXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwiZWZcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBlbmRGaWxsXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5lbmRGaWxsID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuYmVnaW5GaWxsKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHN0cm9rZSBzdHlsZS4gTGlrZSBhbGwgZHJhd2luZyBtZXRob2RzLCB0aGlzIGNhbiBiZSBjaGFpbmVkLCBzbyB5b3UgY2FuIGRlZmluZVxuXHQgKiB0aGUgc3Ryb2tlIHN0eWxlIGFuZCBjb2xvciBpbiBhIHNpbmdsZSBsaW5lIG9mIGNvZGUgbGlrZSBzbzpcblx0ICpcblx0ICogXHRteUdyYXBoaWNzLnNldFN0cm9rZVN0eWxlKDgsXCJyb3VuZFwiKS5iZWdpblN0cm9rZShcIiNGMDBcIik7XG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwic3NcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBzZXRTdHJva2VTdHlsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdGhpY2tuZXNzIFRoZSB3aWR0aCBvZiB0aGUgc3Ryb2tlLlxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gW2NhcHM9MF0gSW5kaWNhdGVzIHRoZSB0eXBlIG9mIGNhcHMgdG8gdXNlIGF0IHRoZSBlbmQgb2YgbGluZXMuIE9uZSBvZiBidXR0LFxuXHQgKiByb3VuZCwgb3Igc3F1YXJlLiBEZWZhdWx0cyB0byBcImJ1dHRcIi4gQWxzbyBhY2NlcHRzIHRoZSB2YWx1ZXMgMCAoYnV0dCksIDEgKHJvdW5kKSwgYW5kIDIgKHNxdWFyZSkgZm9yIHVzZSB3aXRoXG5cdCAqIHRoZSB0aW55IEFQSS5cblx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IFtqb2ludHM9MF0gU3BlY2lmaWVzIHRoZSB0eXBlIG9mIGpvaW50cyB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZXJlIHR3byBsaW5lcyBtZWV0LlxuXHQgKiBPbmUgb2YgYmV2ZWwsIHJvdW5kLCBvciBtaXRlci4gRGVmYXVsdHMgdG8gXCJtaXRlclwiLiBBbHNvIGFjY2VwdHMgdGhlIHZhbHVlcyAwIChtaXRlciksIDEgKHJvdW5kKSwgYW5kIDIgKGJldmVsKVxuXHQgKiBmb3IgdXNlIHdpdGggdGhlIHRpbnkgQVBJLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW21pdGVyTGltaXQ9MTBdIElmIGpvaW50cyBpcyBzZXQgdG8gXCJtaXRlclwiLCB0aGVuIHlvdSBjYW4gc3BlY2lmeSBhIG1pdGVyIGxpbWl0IHJhdGlvIHdoaWNoXG5cdCAqIGNvbnRyb2xzIGF0IHdoYXQgcG9pbnQgYSBtaXRlcmVkIGpvaW50IHdpbGwgYmUgY2xpcHBlZC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbaWdub3JlU2NhbGU9ZmFsc2VdIElmIHRydWUsIHRoZSBzdHJva2Ugd2lsbCBiZSBkcmF3biBhdCB0aGUgc3BlY2lmaWVkIHRoaWNrbmVzcyByZWdhcmRsZXNzXG5cdCAqIG9mIGFjdGl2ZSB0cmFuc2Zvcm1hdGlvbnMuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5zZXRTdHJva2VTdHlsZSA9IGZ1bmN0aW9uKHRoaWNrbmVzcywgY2Fwcywgam9pbnRzLCBtaXRlckxpbWl0LCBpZ25vcmVTY2FsZSkge1xuXHRcdHRoaXMuX3VwZGF0ZUluc3RydWN0aW9ucyh0cnVlKTtcblx0XHR0aGlzLl9zdHJva2VTdHlsZSA9IHRoaXMuY29tbWFuZCA9IG5ldyBHLlN0cm9rZVN0eWxlKHRoaWNrbmVzcywgY2Fwcywgam9pbnRzLCBtaXRlckxpbWl0LCBpZ25vcmVTY2FsZSk7XG5cblx0XHQvLyBpZ25vcmVTY2FsZSBsaXZlcyBvbiBTdHJva2UsIG5vdCBTdHJva2VTdHlsZSwgc28gd2UgZG8gYSBsaXR0bGUgdHJpY2tlcnk6XG5cdFx0aWYgKHRoaXMuX3N0cm9rZSkgeyB0aGlzLl9zdHJva2UuaWdub3JlU2NhbGUgPSBpZ25vcmVTY2FsZTsgfVxuXHRcdHRoaXMuX3N0cm9rZUlnbm9yZVNjYWxlID0gaWdub3JlU2NhbGU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cdFxuXHQvKipcblx0ICogU2V0cyBvciBjbGVhcnMgdGhlIHN0cm9rZSBkYXNoIHBhdHRlcm4uXG5cdCAqXG5cdCAqIFx0bXlHcmFwaGljcy5zZXRTdHJva2VEYXNoKFsyMCwgMTBdLCAwKTtcblx0ICpcblx0ICogQSB0aW55IEFQSSBtZXRob2QgYHNkYCBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBzZXRTdHJva2VEYXNoXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtzZWdtZW50c10gQW4gYXJyYXkgc3BlY2lmeWluZyB0aGUgZGFzaCBwYXR0ZXJuLCBhbHRlcm5hdGluZyBiZXR3ZWVuIGxpbmUgYW5kIGdhcC5cblx0ICogRm9yIGV4YW1wbGUsIGBbMjAsMTBdYCB3b3VsZCBjcmVhdGUgYSBwYXR0ZXJuIG9mIDIwIHBpeGVsIGxpbmVzIHdpdGggMTAgcGl4ZWwgZ2FwcyBiZXR3ZWVuIHRoZW0uXG5cdCAqIFBhc3NpbmcgbnVsbCBvciBhbiBlbXB0eSBhcnJheSB3aWxsIGNsZWFyIHRoZSBleGlzdGluZyBzdHJva2UgZGFzaC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXQ9MF0gVGhlIG9mZnNldCBvZiB0aGUgZGFzaCBwYXR0ZXJuLiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIGluY3JlbWVudCB0aGlzIHZhbHVlIHRvIGNyZWF0ZSBhIFwibWFyY2hpbmcgYW50c1wiIGVmZmVjdC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLnNldFN0cm9rZURhc2ggPSBmdW5jdGlvbihzZWdtZW50cywgb2Zmc2V0KSB7XG5cdFx0dGhpcy5fdXBkYXRlSW5zdHJ1Y3Rpb25zKHRydWUpO1xuXHRcdHRoaXMuX3N0cm9rZURhc2ggPSB0aGlzLmNvbW1hbmQgPSBuZXcgRy5TdHJva2VEYXNoKHNlZ21lbnRzLCBvZmZzZXQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSBzdHJva2Ugd2l0aCB0aGUgc3BlY2lmaWVkIGNvbG9yLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguIEEgdGlueSBBUEkgbWV0aG9kIFwic1wiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luU3Ryb2tlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBBIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlIChleC4gXCIjRkYwMDAwXCIsIFwicmVkXCIsIG9yIFwicmdiYSgyNTUsMCwwLDAuNSlcIikuIFNldHRpbmcgdG9cblx0ICogbnVsbCB3aWxsIHJlc3VsdCBpbiBubyBzdHJva2UuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5iZWdpblN0cm9rZSA9IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldFN0cm9rZShjb2xvciA/IG5ldyBHLlN0cm9rZShjb2xvcikgOiBudWxsKTtcblx0fTtcblxuXHQvKipcblx0ICogQmVnaW5zIGEgbGluZWFyIGdyYWRpZW50IHN0cm9rZSBkZWZpbmVkIGJ5IHRoZSBsaW5lICh4MCwgeTApIHRvICh4MSwgeTEpLiBUaGlzIGVuZHMgdGhlIGN1cnJlbnQgc3ViLXBhdGguIEZvclxuXHQgKiBleGFtcGxlLCB0aGUgZm9sbG93aW5nIGNvZGUgZGVmaW5lcyBhIGJsYWNrIHRvIHdoaXRlIHZlcnRpY2FsIGdyYWRpZW50IHJhbmdpbmcgZnJvbSAyMHB4IHRvIDEyMHB4LCBhbmQgZHJhd3MgYVxuXHQgKiBzcXVhcmUgdG8gZGlzcGxheSBpdDpcblx0ICpcblx0ICogICAgICBteUdyYXBoaWNzLnNldFN0cm9rZVN0eWxlKDEwKS5cblx0ICogICAgICAgICAgYmVnaW5MaW5lYXJHcmFkaWVudFN0cm9rZShbXCIjMDAwXCIsXCIjRkZGXCJdLCBbMCwgMV0sIDAsIDIwLCAwLCAxMjApLmRyYXdSZWN0KDIwLCAyMCwgMTIwLCAxMjApO1xuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImxzXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYmVnaW5MaW5lYXJHcmFkaWVudFN0cm9rZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnMgQW4gYXJyYXkgb2YgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWVzLiBGb3IgZXhhbXBsZSwgW1wiI0YwMFwiLFwiIzAwRlwiXSB3b3VsZCBkZWZpbmVcblx0ICogYSBncmFkaWVudCBkcmF3aW5nIGZyb20gcmVkIHRvIGJsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvcyBBbiBhcnJheSBvZiBncmFkaWVudCBwb3NpdGlvbnMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgY29sb3JzLiBGb3IgZXhhbXBsZSwgWzAuMSxcblx0ICogMC45XSB3b3VsZCBkcmF3IHRoZSBmaXJzdCBjb2xvciB0byAxMCUgdGhlbiBpbnRlcnBvbGF0aW5nIHRvIHRoZSBzZWNvbmQgY29sb3IgYXQgOTAlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDAgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwIFRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MSBUaGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmVnaW5MaW5lYXJHcmFkaWVudFN0cm9rZSA9IGZ1bmN0aW9uKGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHgxLCB5MSkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRTdHJva2UobmV3IEcuU3Ryb2tlKCkubGluZWFyR3JhZGllbnQoY29sb3JzLCByYXRpb3MsIHgwLCB5MCwgeDEsIHkxKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEJlZ2lucyBhIHJhZGlhbCBncmFkaWVudCBzdHJva2UuIFRoaXMgZW5kcyB0aGUgY3VycmVudCBzdWItcGF0aC4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgY29kZSBkZWZpbmVzIGEgcmVkIHRvXG5cdCAqIGJsdWUgcmFkaWFsIGdyYWRpZW50IGNlbnRlcmVkIGF0ICgxMDAsIDEwMCksIHdpdGggYSByYWRpdXMgb2YgNTAsIGFuZCBkcmF3cyBhIHJlY3RhbmdsZSB0byBkaXNwbGF5IGl0OlxuXHQgKlxuXHQgKiAgICAgIG15R3JhcGhpY3Muc2V0U3Ryb2tlU3R5bGUoMTApXG5cdCAqICAgICAgICAgIC5iZWdpblJhZGlhbEdyYWRpZW50U3Ryb2tlKFtcIiNGMDBcIixcIiMwMEZcIl0sIFswLCAxXSwgMTAwLCAxMDAsIDAsIDEwMCwgMTAwLCA1MClcblx0ICogICAgICAgICAgLmRyYXdSZWN0KDUwLCA5MCwgMTUwLCAxMTApO1xuXHQgKlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcInJzXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgYmVnaW5SYWRpYWxHcmFkaWVudFN0cm9rZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2xvcnMgQW4gYXJyYXkgb2YgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWVzLiBGb3IgZXhhbXBsZSwgW1wiI0YwMFwiLFwiIzAwRlwiXSB3b3VsZCBkZWZpbmVcblx0ICogYSBncmFkaWVudCBkcmF3aW5nIGZyb20gcmVkIHRvIGJsdWUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvcyBBbiBhcnJheSBvZiBncmFkaWVudCBwb3NpdGlvbnMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgY29sb3JzLiBGb3IgZXhhbXBsZSwgWzAuMSxcblx0ICogMC45XSB3b3VsZCBkcmF3IHRoZSBmaXJzdCBjb2xvciB0byAxMCUgdGhlbiBpbnRlcnBvbGF0aW5nIHRvIHRoZSBzZWNvbmQgY29sb3IgYXQgOTAlLCB0aGVuIGRyYXcgdGhlIHNlY29uZCBjb2xvclxuXHQgKiB0byAxMDAlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDAgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMCBSYWRpdXMgb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDEgQ2VudGVyIHBvc2l0aW9uIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMSBSYWRpdXMgb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYmVnaW5SYWRpYWxHcmFkaWVudFN0cm9rZSA9IGZ1bmN0aW9uKGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHIwLCB4MSwgeTEsIHIxKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldFN0cm9rZShuZXcgRy5TdHJva2UoKS5yYWRpYWxHcmFkaWVudChjb2xvcnMsIHJhdGlvcywgeDAsIHkwLCByMCwgeDEsIHkxLCByMSkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbnMgYSBwYXR0ZXJuIGZpbGwgdXNpbmcgdGhlIHNwZWNpZmllZCBpbWFnZS4gVGhpcyBlbmRzIHRoZSBjdXJyZW50IHN1Yi1wYXRoLiBOb3RlIHRoYXQgdW5saWtlIGJpdG1hcCBmaWxscyxcblx0ICogc3Ryb2tlcyBkbyBub3QgY3VycmVudGx5IHN1cHBvcnQgYSBtYXRyaXggcGFyYW1ldGVyIGR1ZSB0byBsaW1pdGF0aW9ucyBpbiB0aGUgY2FudmFzIEFQSS4gQSB0aW55IEFQSSBtZXRob2QgXCJic1wiXG5cdCAqIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGJlZ2luQml0bWFwU3Ryb2tlXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgVGhlIEltYWdlLCBDYW52YXMsIG9yIFZpZGVvIG9iamVjdCB0byB1c2Vcblx0ICogYXMgdGhlIHBhdHRlcm4uIE11c3QgYmUgbG9hZGVkIHByaW9yIHRvIGNyZWF0aW5nIGEgYml0bWFwIGZpbGwsIG9yIHRoZSBmaWxsIHdpbGwgYmUgZW1wdHkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcmVwZXRpdGlvbj1yZXBlYXRdIE9wdGlvbmFsLiBJbmRpY2F0ZXMgd2hldGhlciB0byByZXBlYXQgdGhlIGltYWdlIGluIHRoZSBmaWxsIGFyZWEuIE9uZSBvZlxuXHQgKiBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gRGVmYXVsdHMgdG8gXCJyZXBlYXRcIi5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmJlZ2luQml0bWFwU3Ryb2tlID0gZnVuY3Rpb24oaW1hZ2UsIHJlcGV0aXRpb24pIHtcblx0XHQvLyBOT1RFOiBtYXRyaXggaXMgbm90IHN1cHBvcnRlZCBmb3Igc3Ryb2tlIGJlY2F1c2UgdHJhbnNmb3JtcyBvbiBzdHJva2VzIGFsc28gYWZmZWN0IHRoZSBkcmF3biBzdHJva2Ugd2lkdGguXG5cdFx0cmV0dXJuIHRoaXMuX3NldFN0cm9rZShuZXcgRy5TdHJva2UoKS5iaXRtYXAoaW1hZ2UsIHJlcGV0aXRpb24pKTtcblx0fTtcblxuXHQvKipcblx0ICogRW5kcyB0aGUgY3VycmVudCBzdWItcGF0aCwgYW5kIGJlZ2lucyBhIG5ldyBvbmUgd2l0aCBubyBzdHJva2UuIEZ1bmN0aW9uYWxseSBpZGVudGljYWwgdG8gPGNvZGU+YmVnaW5TdHJva2UobnVsbCk8L2NvZGU+LlxuXHQgKiBBIHRpbnkgQVBJIG1ldGhvZCBcImVzXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgZW5kU3Ryb2tlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5lbmRTdHJva2UgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5iZWdpblN0cm9rZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBNYXBzIHRoZSBmYW1pbGlhciBBY3Rpb25TY3JpcHQgPGNvZGU+Y3VydmVUbygpPC9jb2RlPiBtZXRob2QgdG8gdGhlIGZ1bmN0aW9uYWxseSBzaW1pbGFyIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3F1YWRyYXRpY0N1cnZlVG9cIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLlxuXHQgKiBAbWV0aG9kIHF1YWRyYXRpY0N1cnZlVG9cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNweFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3B5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5jdXJ2ZVRvID0gcC5xdWFkcmF0aWNDdXJ2ZVRvO1xuXG5cdC8qKlxuXHQgKlxuXHQgKiBNYXBzIHRoZSBmYW1pbGlhciBBY3Rpb25TY3JpcHQgPGNvZGU+ZHJhd1JlY3QoKTwvY29kZT4gbWV0aG9kIHRvIHRoZSBmdW5jdGlvbmFsbHkgc2ltaWxhciB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9yZWN0XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC5cblx0ICogQG1ldGhvZCBkcmF3UmVjdFxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdyBXaWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoIEhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5kcmF3UmVjdCA9IHAucmVjdDtcblxuXHQvKipcblx0ICogRHJhd3MgYSByb3VuZGVkIHJlY3RhbmdsZSB3aXRoIGFsbCBjb3JuZXJzIHdpdGggdGhlIHNwZWNpZmllZCByYWRpdXMuXG5cdCAqIEBtZXRob2QgZHJhd1JvdW5kUmVjdFxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gd1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIENvcm5lciByYWRpdXMuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5kcmF3Um91bmRSZWN0ID0gZnVuY3Rpb24oeCwgeSwgdywgaCwgcmFkaXVzKSB7XG5cdFx0cmV0dXJuIHRoaXMuZHJhd1JvdW5kUmVjdENvbXBsZXgoeCwgeSwgdywgaCwgcmFkaXVzLCByYWRpdXMsIHJhZGl1cywgcmFkaXVzKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgYSByb3VuZGVkIHJlY3RhbmdsZSB3aXRoIGRpZmZlcmVudCBjb3JuZXIgcmFkaWkuIFN1cHBvcnRzIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSBjb3JuZXIgcmFkaWkuIEEgdGlueSBBUElcblx0ICogbWV0aG9kIFwicmNcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBkcmF3Um91bmRSZWN0Q29tcGxleFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlIHRvIGRyYXcgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlIHRvIGRyYXcgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFRoZSB3aWR0aCBvZiB0aGUgcm91bmQgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGggVGhlIGhlaWdodCBvZiB0aGUgcm91bmQgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1RMIFRvcCBsZWZ0IGNvcm5lciByYWRpdXMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUUiBUb3AgcmlnaHQgY29ybmVyIHJhZGl1cy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c0JSIEJvdHRvbSByaWdodCBjb3JuZXIgcmFkaXVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzQkwgQm90dG9tIGxlZnQgY29ybmVyIHJhZGl1cy5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmRyYXdSb3VuZFJlY3RDb21wbGV4ID0gZnVuY3Rpb24oeCwgeSwgdywgaCwgcmFkaXVzVEwsIHJhZGl1c1RSLCByYWRpdXNCUiwgcmFkaXVzQkwpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuUm91bmRSZWN0KHgsIHksIHcsIGgsIHJhZGl1c1RMLCByYWRpdXNUUiwgcmFkaXVzQlIsIHJhZGl1c0JMKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGEgY2lyY2xlIHdpdGggdGhlIHNwZWNpZmllZCByYWRpdXMgYXQgKHgsIHkpLlxuXHQgKlxuXHQgKiAgICAgIHZhciBnID0gbmV3IGNyZWF0ZWpzLkdyYXBoaWNzKCk7XG5cdCAqXHQgICAgZy5zZXRTdHJva2VTdHlsZSgxKTtcblx0ICpcdCAgICBnLmJlZ2luU3Ryb2tlKGNyZWF0ZWpzLkdyYXBoaWNzLmdldFJHQigwLDAsMCkpO1xuXHQgKlx0ICAgIGcuYmVnaW5GaWxsKGNyZWF0ZWpzLkdyYXBoaWNzLmdldFJHQigyNTUsMCwwKSk7XG5cdCAqXHQgICAgZy5kcmF3Q2lyY2xlKDAsMCwzKTtcblx0ICpcblx0ICpcdCAgICB2YXIgcyA9IG5ldyBjcmVhdGVqcy5TaGFwZShnKTtcblx0ICpcdFx0cy54ID0gMTAwO1xuXHQgKlx0XHRzLnkgPSAxMDA7XG5cdCAqXG5cdCAqXHQgICAgc3RhZ2UuYWRkQ2hpbGQocyk7XG5cdCAqXHQgICAgc3RhZ2UudXBkYXRlKCk7XG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwiZGNcIiBhbHNvIGV4aXN0cy5cblx0ICogQG1ldGhvZCBkcmF3Q2lyY2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IHggY29vcmRpbmF0ZSBjZW50ZXIgcG9pbnQgb2YgY2lyY2xlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSB5IGNvb3JkaW5hdGUgY2VudGVyIHBvaW50IG9mIGNpcmNsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgY2lyY2xlLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuZHJhd0NpcmNsZSA9IGZ1bmN0aW9uKHgsIHksIHJhZGl1cykge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5DaXJjbGUoeCwgeSwgcmFkaXVzKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERyYXdzIGFuIGVsbGlwc2UgKG92YWwpIHdpdGggYSBzcGVjaWZpZWQgd2lkdGggKHcpIGFuZCBoZWlnaHQgKGgpLiBTaW1pbGFyIHRvIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdDaXJjbGVcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIGV4Y2VwdCB0aGUgd2lkdGggYW5kIGhlaWdodCBjYW4gYmUgZGlmZmVyZW50LiBBIHRpbnkgQVBJIG1ldGhvZCBcImRlXCIgYWxzbyBleGlzdHMuXG5cdCAqIEBtZXRob2QgZHJhd0VsbGlwc2Vcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGxlZnQgY29vcmRpbmF0ZSBwb2ludCBvZiB0aGUgZWxsaXBzZS4gTm90ZSB0aGF0IHRoaXMgaXMgZGlmZmVyZW50IGZyb20ge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd0NpcmNsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aGljaCBkcmF3cyBmcm9tIGNlbnRlci5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHRvcCBjb29yZGluYXRlIHBvaW50IG9mIHRoZSBlbGxpcHNlLiBOb3RlIHRoYXQgdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9kcmF3Q2lyY2xlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdoaWNoIGRyYXdzIGZyb20gdGhlIGNlbnRlci5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHcgVGhlIGhlaWdodCAoaG9yaXpvbnRhbCBkaWFtZXRlcikgb2YgdGhlIGVsbGlwc2UuIFRoZSBob3Jpem9udGFsIHJhZGl1cyB3aWxsIGJlIGhhbGYgb2YgdGhpc1xuXHQgKiBudW1iZXIuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoIFRoZSB3aWR0aCAodmVydGljYWwgZGlhbWV0ZXIpIG9mIHRoZSBlbGxpcHNlLiBUaGUgdmVydGljYWwgcmFkaXVzIHdpbGwgYmUgaGFsZiBvZiB0aGlzIG51bWJlci5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmRyYXdFbGxpcHNlID0gZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuXHRcdHJldHVybiB0aGlzLmFwcGVuZChuZXcgRy5FbGxpcHNlKHgsIHksIHcsIGgpKTtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgYSBzdGFyIGlmIHBvaW50U2l6ZSBpcyBncmVhdGVyIHRoYW4gMCwgb3IgYSByZWd1bGFyIHBvbHlnb24gaWYgcG9pbnRTaXplIGlzIDAgd2l0aCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZlxuXHQgKiBwb2ludHMuIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIGNvZGUgd2lsbCBkcmF3IGEgZmFtaWxpYXIgNSBwb2ludGVkIHN0YXIgc2hhcGUgY2VudGVyZWQgYXQgMTAwLCAxMDAgYW5kIHdpdGggYVxuXHQgKiByYWRpdXMgb2YgNTA6XG5cdCAqXG5cdCAqICAgICAgbXlHcmFwaGljcy5iZWdpbkZpbGwoXCIjRkYwXCIpLmRyYXdQb2x5U3RhcigxMDAsIDEwMCwgNTAsIDUsIDAuNiwgLTkwKTtcblx0ICogICAgICAvLyBOb3RlOiAtOTAgbWFrZXMgdGhlIGZpcnN0IHBvaW50IHZlcnRpY2FsXG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwiZHBcIiBhbHNvIGV4aXN0cy5cblx0ICpcblx0ICogQG1ldGhvZCBkcmF3UG9seVN0YXJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggUG9zaXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGUgc2hhcGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHNoYXBlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIHNoYXBlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2lkZXMgVGhlIG51bWJlciBvZiBwb2ludHMgb24gdGhlIHN0YXIgb3Igc2lkZXMgb24gdGhlIHBvbHlnb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludFNpemUgVGhlIGRlcHRoIG9yIFwicG9pbnR5LW5lc3NcIiBvZiB0aGUgc3RhciBwb2ludHMuIEEgcG9pbnRTaXplIG9mIDAgd2lsbCBkcmF3IGEgcmVndWxhclxuXHQgKiBwb2x5Z29uIChubyBwb2ludHMpLCBhIHBvaW50U2l6ZSBvZiAxIHdpbGwgZHJhdyBub3RoaW5nIGJlY2F1c2UgdGhlIHBvaW50cyBhcmUgaW5maW5pdGVseSBwb2ludHkuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSBUaGUgYW5nbGUgb2YgdGhlIGZpcnN0IHBvaW50IC8gY29ybmVyLiBGb3IgZXhhbXBsZSBhIHZhbHVlIG9mIDAgd2lsbCBkcmF3IHRoZSBmaXJzdCBwb2ludFxuXHQgKiBkaXJlY3RseSB0byB0aGUgcmlnaHQgb2YgdGhlIGNlbnRlci5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmRyYXdQb2x5U3RhciA9IGZ1bmN0aW9uKHgsIHksIHJhZGl1cywgc2lkZXMsIHBvaW50U2l6ZSwgYW5nbGUpIHtcblx0XHRyZXR1cm4gdGhpcy5hcHBlbmQobmV3IEcuUG9seVN0YXIoeCwgeSwgcmFkaXVzLCBzaWRlcywgcG9pbnRTaXplLCBhbmdsZSkpO1xuXHR9O1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWQuXG5cdC8qKlxuXHQgKiBSZW1vdmVkIGluIGZhdm91ciBvZiB1c2luZyBjdXN0b20gY29tbWFuZCBvYmplY3RzIHdpdGgge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGluamVjdFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cblx0LyoqXG5cdCAqIEFwcGVuZHMgYSBncmFwaGljcyBjb21tYW5kIG9iamVjdCB0byB0aGUgZ3JhcGhpY3MgcXVldWUuIENvbW1hbmQgb2JqZWN0cyBleHBvc2UgYW4gXCJleGVjXCIgbWV0aG9kXG5cdCAqIHRoYXQgYWNjZXB0cyB0d28gcGFyYW1ldGVyczogdGhlIENvbnRleHQyRCB0byBvcGVyYXRlIG9uLCBhbmQgYW4gYXJiaXRyYXJ5IGRhdGEgb2JqZWN0IHBhc3NlZCBpbnRvXG5cdCAqIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdcIn19e3svY3Jvc3NMaW5rfX0uIFRoZSBsYXR0ZXIgd2lsbCB1c3VhbGx5IGJlIHRoZSBTaGFwZSBpbnN0YW5jZSB0aGF0IGNhbGxlZCBkcmF3LlxuXHQgKlxuXHQgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGludGVybmFsbHkgYnkgR3JhcGhpY3MgbWV0aG9kcywgc3VjaCBhcyBkcmF3Q2lyY2xlLCBidXQgY2FuIGFsc28gYmUgdXNlZCBkaXJlY3RseSB0byBpbnNlcnRcblx0ICogYnVpbHQtaW4gb3IgY3VzdG9tIGdyYXBoaWNzIGNvbW1hbmRzLiBGb3IgZXhhbXBsZTpcblx0ICpcblx0ICogXHRcdC8vIGF0dGFjaCBkYXRhIHRvIG91ciBzaGFwZSwgc28gd2UgY2FuIGFjY2VzcyBpdCBkdXJpbmcgdGhlIGRyYXc6XG5cdCAqIFx0XHRteVNoYXBlLmNvbG9yID0gXCJyZWRcIjtcblx0ICpcblx0ICogXHRcdC8vIGFwcGVuZCBhIENpcmNsZSBjb21tYW5kIG9iamVjdDpcblx0ICogXHRcdG15U2hhcGUuZ3JhcGhpY3MuYXBwZW5kKG5ldyBHcmFwaGljcy5DaXJjbGUoNTAsIDUwLCAzMCkpO1xuXHQgKlxuXHQgKiBcdFx0Ly8gYXBwZW5kIGEgY3VzdG9tIGNvbW1hbmQgb2JqZWN0IHdpdGggYW4gZXhlYyBtZXRob2QgdGhhdCBzZXRzIHRoZSBmaWxsIHN0eWxlXG5cdCAqIFx0XHQvLyBiYXNlZCBvbiB0aGUgc2hhcGUncyBkYXRhLCBhbmQgdGhlbiBmaWxscyB0aGUgY2lyY2xlLlxuXHQgKiBcdFx0bXlTaGFwZS5ncmFwaGljcy5hcHBlbmQoe2V4ZWM6ZnVuY3Rpb24oY3R4LCBzaGFwZSkge1xuXHQgKiBcdFx0XHRjdHguZmlsbFN0eWxlID0gc2hhcGUuY29sb3I7XG5cdCAqIFx0XHRcdGN0eC5maWxsKCk7XG5cdCAqIFx0XHR9fSk7XG5cdCAqXG5cdCAqIEBtZXRob2QgYXBwZW5kXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjb21tYW5kIEEgZ3JhcGhpY3MgY29tbWFuZCBvYmplY3QgZXhwb3NpbmcgYW4gXCJleGVjXCIgbWV0aG9kLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFuIFRoZSBjbGVhbiBwYXJhbSBpcyBwcmltYXJpbHkgZm9yIGludGVybmFsIHVzZS4gQSB2YWx1ZSBvZiB0cnVlIGluZGljYXRlcyB0aGF0IGEgY29tbWFuZCBkb2VzIG5vdCBnZW5lcmF0ZSBhIHBhdGggdGhhdCBzaG91bGQgYmUgc3Ryb2tlZCBvciBmaWxsZWQuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hcHBlbmQgPSBmdW5jdGlvbihjb21tYW5kLCBjbGVhbikge1xuXHRcdHRoaXMuX2FjdGl2ZUluc3RydWN0aW9ucy5wdXNoKGNvbW1hbmQpO1xuXHRcdHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XG5cdFx0aWYgKCFjbGVhbikgeyB0aGlzLl9kaXJ0eSA9IHRydWU7IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogRGVjb2RlcyBhIGNvbXBhY3QgZW5jb2RlZCBwYXRoIHN0cmluZyBpbnRvIGEgc2VyaWVzIG9mIGRyYXcgaW5zdHJ1Y3Rpb25zLlxuXHQgKiBUaGlzIGZvcm1hdCBpcyBub3QgaW50ZW5kZWQgdG8gYmUgaHVtYW4gcmVhZGFibGUsIGFuZCBpcyBtZWFudCBmb3IgdXNlIGJ5IGF1dGhvcmluZyB0b29scy5cblx0ICogVGhlIGZvcm1hdCB1c2VzIGEgYmFzZTY0IGNoYXJhY3RlciBzZXQsIHdpdGggZWFjaCBjaGFyYWN0ZXIgcmVwcmVzZW50aW5nIDYgYml0cywgdG8gZGVmaW5lIGEgc2VyaWVzIG9mIGRyYXdcblx0ICogY29tbWFuZHMuXG5cdCAqXG5cdCAqIEVhY2ggY29tbWFuZCBpcyBjb21wcmlzZWQgb2YgYSBzaW5nbGUgXCJoZWFkZXJcIiBjaGFyYWN0ZXIgZm9sbG93ZWQgYnkgYSB2YXJpYWJsZSBudW1iZXIgb2YgYWx0ZXJuYXRpbmcgeCBhbmQgeVxuXHQgKiBwb3NpdGlvbiB2YWx1ZXMuIFJlYWRpbmcgdGhlIGhlYWRlciBiaXRzIGZyb20gbGVmdCB0byByaWdodCAobW9zdCB0byBsZWFzdCBzaWduaWZpY2FudCk6IGJpdHMgMSB0byAzIHNwZWNpZnkgdGhlXG5cdCAqIHR5cGUgb2Ygb3BlcmF0aW9uICgwLW1vdmVUbywgMS1saW5lVG8sIDItcXVhZHJhdGljQ3VydmVUbywgMy1iZXppZXJDdXJ2ZVRvLCA0LWNsb3NlUGF0aCwgNS03IHVudXNlZCkuIEJpdCA0XG5cdCAqIGluZGljYXRlcyB3aGV0aGVyIHBvc2l0aW9uIHZhbHVlcyB1c2UgMTIgYml0cyAoMiBjaGFyYWN0ZXJzKSBvciAxOCBiaXRzICgzIGNoYXJhY3RlcnMpLCB3aXRoIGEgb25lIGluZGljYXRpbmcgdGhlXG5cdCAqIGxhdHRlci4gQml0cyA1IGFuZCA2IGFyZSBjdXJyZW50bHkgdW51c2VkLlxuXHQgKlxuXHQgKiBGb2xsb3dpbmcgdGhlIGhlYWRlciBpcyBhIHNlcmllcyBvZiAwIChjbG9zZVBhdGgpLCAyIChtb3ZlVG8sIGxpbmVUbyksIDQgKHF1YWRyYXRpY0N1cnZlVG8pLCBvciA2IChiZXppZXJDdXJ2ZVRvKVxuXHQgKiBwYXJhbWV0ZXJzLiBUaGVzZSBwYXJhbWV0ZXJzIGFyZSBhbHRlcm5hdGluZyB4L3kgcG9zaXRpb25zIHJlcHJlc2VudGVkIGJ5IDIgb3IgMyBjaGFyYWN0ZXJzIChhcyBpbmRpY2F0ZWQgYnkgdGhlXG5cdCAqIDR0aCBiaXQgaW4gdGhlIGNvbW1hbmQgY2hhcikuIFRoZXNlIGNoYXJhY3RlcnMgY29uc2lzdCBvZiBhIDEgYml0IHNpZ24gKDEgaXMgbmVnYXRpdmUsIDAgaXMgcG9zaXRpdmUpLCBmb2xsb3dlZFxuXHQgKiBieSBhbiAxMSAoMiBjaGFyKSBvciAxNyAoMyBjaGFyKSBiaXQgaW50ZWdlciB2YWx1ZS4gQWxsIHBvc2l0aW9uIHZhbHVlcyBhcmUgaW4gdGVudGhzIG9mIGEgcGl4ZWwuIEV4Y2VwdCBpbiB0aGVcblx0ICogY2FzZSBvZiBtb3ZlIG9wZXJhdGlvbnMgd2hpY2ggYXJlIGFic29sdXRlLCB0aGlzIHZhbHVlIGlzIGEgZGVsdGEgZnJvbSB0aGUgcHJldmlvdXMgeCBvciB5IHBvc2l0aW9uIChhc1xuXHQgKiBhcHByb3ByaWF0ZSkuXG5cdCAqXG5cdCAqIEZvciBleGFtcGxlLCB0aGUgc3RyaW5nIFwiQTNjQUFNQXU0QUFBXCIgcmVwcmVzZW50cyBhIGxpbmUgc3RhcnRpbmcgYXQgLTE1MCwwIGFuZCBlbmRpbmcgYXQgMTUwLDAuXG5cdCAqIDxiciAvPkEgLSBiaXRzIDAwMDAwMC4gRmlyc3QgMyBiaXRzICgwMDApIGluZGljYXRlIGEgbW92ZVRvIG9wZXJhdGlvbi4gNHRoIGJpdCAoMCkgaW5kaWNhdGVzIDIgY2hhcnMgcGVyXG5cdCAqIHBhcmFtZXRlci5cblx0ICogPGJyIC8+bjAgLSAxMTAxMTEwMTExMDAuIEFic29sdXRlIHggcG9zaXRpb24gb2YgLTE1MC4wcHguIEZpcnN0IGJpdCBpbmRpY2F0ZXMgYSBuZWdhdGl2ZSB2YWx1ZSwgcmVtYWluaW5nIGJpdHNcblx0ICogaW5kaWNhdGUgMTUwMCB0ZW50aHMgb2YgYSBwaXhlbC5cblx0ICogPGJyIC8+QUEgLSAwMDAwMDAwMDAwMDAuIEFic29sdXRlIHkgcG9zaXRpb24gb2YgMC5cblx0ICogPGJyIC8+SSAtIDAwMTEwMC4gRmlyc3QgMyBiaXRzICgwMDEpIGluZGljYXRlIGEgbGluZVRvIG9wZXJhdGlvbi4gNHRoIGJpdCAoMSkgaW5kaWNhdGVzIDMgY2hhcnMgcGVyIHBhcmFtZXRlci5cblx0ICogPGJyIC8+QXU0IC0gMDAwMDAwMTAxMTEwMTExMDAwLiBBbiB4IGRlbHRhIG9mIDMwMC4wcHgsIHdoaWNoIGlzIGFkZGVkIHRvIHRoZSBwcmV2aW91cyB4IHZhbHVlIG9mIC0xNTAuMHB4IHRvXG5cdCAqIHByb3ZpZGUgYW4gYWJzb2x1dGUgcG9zaXRpb24gb2YgKzE1MC4wcHguXG5cdCAqIDxiciAvPkFBQSAtIDAwMDAwMDAwMDAwMDAwMDAwMC4gQSB5IGRlbHRhIHZhbHVlIG9mIDAuXG5cdCAqXG5cdCAqIEEgdGlueSBBUEkgbWV0aG9kIFwicFwiIGFsc28gZXhpc3RzLlxuXHQgKiBAbWV0aG9kIGRlY29kZVBhdGhcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgcGF0aCBzdHJpbmcgdG8gZGVjb2RlLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuZGVjb2RlUGF0aCA9IGZ1bmN0aW9uKHN0cikge1xuXHRcdHZhciBpbnN0cnVjdGlvbnMgPSBbdGhpcy5tb3ZlVG8sIHRoaXMubGluZVRvLCB0aGlzLnF1YWRyYXRpY0N1cnZlVG8sIHRoaXMuYmV6aWVyQ3VydmVUbywgdGhpcy5jbG9zZVBhdGhdO1xuXHRcdHZhciBwYXJhbUNvdW50ID0gWzIsIDIsIDQsIDYsIDBdO1xuXHRcdHZhciBpPTAsIGw9c3RyLmxlbmd0aDtcblx0XHR2YXIgcGFyYW1zID0gW107XG5cdFx0dmFyIHg9MCwgeT0wO1xuXHRcdHZhciBiYXNlNjQgPSBHcmFwaGljcy5CQVNFXzY0O1xuXG5cdFx0d2hpbGUgKGk8bCkge1xuXHRcdFx0dmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuXHRcdFx0dmFyIG4gPSBiYXNlNjRbY107XG5cdFx0XHR2YXIgZmkgPSBuPj4zOyAvLyBoaWdoZXN0IG9yZGVyIGJpdHMgMS0zIGNvZGUgZm9yIG9wZXJhdGlvbi5cblx0XHRcdHZhciBmID0gaW5zdHJ1Y3Rpb25zW2ZpXTtcblx0XHRcdC8vIGNoZWNrIHRoYXQgd2UgaGF2ZSBhIHZhbGlkIGluc3RydWN0aW9uICYgdGhhdCB0aGUgdW51c2VkIGJpdHMgYXJlIGVtcHR5OlxuXHRcdFx0aWYgKCFmIHx8IChuJjMpKSB7IHRocm93KFwiYmFkIHBhdGggZGF0YSAoQFwiK2krXCIpOiBcIitjKTsgfVxuXHRcdFx0dmFyIHBsID0gcGFyYW1Db3VudFtmaV07XG5cdFx0XHRpZiAoIWZpKSB7IHg9eT0wOyB9IC8vIG1vdmUgb3BlcmF0aW9ucyByZXNldCB0aGUgcG9zaXRpb24uXG5cdFx0XHRwYXJhbXMubGVuZ3RoID0gMDtcblx0XHRcdGkrKztcblx0XHRcdHZhciBjaGFyQ291bnQgPSAobj4+MiYxKSsyOyAgLy8gNHRoIGhlYWRlciBiaXQgaW5kaWNhdGVzIG51bWJlciBzaXplIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0XHRcdGZvciAodmFyIHA9MDsgcDxwbDsgcCsrKSB7XG5cdFx0XHRcdHZhciBudW0gPSBiYXNlNjRbc3RyLmNoYXJBdChpKV07XG5cdFx0XHRcdHZhciBzaWduID0gKG51bT4+NSkgPyAtMSA6IDE7XG5cdFx0XHRcdG51bSA9ICgobnVtJjMxKTw8Nil8KGJhc2U2NFtzdHIuY2hhckF0KGkrMSldKTtcblx0XHRcdFx0aWYgKGNoYXJDb3VudCA9PSAzKSB7IG51bSA9IChudW08PDYpfChiYXNlNjRbc3RyLmNoYXJBdChpKzIpXSk7IH1cblx0XHRcdFx0bnVtID0gc2lnbipudW0vMTA7XG5cdFx0XHRcdGlmIChwJTIpIHsgeCA9IChudW0gKz0geCk7IH1cblx0XHRcdFx0ZWxzZSB7IHkgPSAobnVtICs9IHkpOyB9XG5cdFx0XHRcdHBhcmFtc1twXSA9IG51bTtcblx0XHRcdFx0aSArPSBjaGFyQ291bnQ7XG5cdFx0XHR9XG5cdFx0XHRmLmFwcGx5KHRoaXMscGFyYW1zKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3JlcyBhbGwgZ3JhcGhpY3MgY29tbWFuZHMgc28gdGhleSB3b24ndCBiZSBleGVjdXRlZCBpbiBmdXR1cmUgZHJhd3MuIENhbGxpbmcgc3RvcmUoKSBhIHNlY29uZCB0aW1lIGFkZHMgdG9cblx0ICogdGhlIGV4aXN0aW5nIHN0b3JlLiBUaGlzIGFsc28gYWZmZWN0cyBgZHJhd0FzUGF0aCgpYC5cblx0ICpcblx0ICogVGhpcyBpcyB1c2VmdWwgaW4gY2FzZXMgd2hlcmUgeW91IGFyZSBjcmVhdGluZyB2ZWN0b3IgZ3JhcGhpY3MgaW4gYW4gaXRlcmF0aXZlIG1hbm5lciAoZXguIGdlbmVyYXRpdmUgYXJ0KSwgc29cblx0ICogdGhhdCBvbmx5IG5ldyBncmFwaGljcyBuZWVkIHRvIGJlIGRyYXduICh3aGljaCBjYW4gcHJvdmlkZSBodWdlIHBlcmZvcm1hbmNlIGJlbmVmaXRzKSwgYnV0IHlvdSB3aXNoIHRvIHJldGFpbiBhbGxcblx0ICogb2YgdGhlIHZlY3RvciBpbnN0cnVjdGlvbnMgZm9yIGxhdGVyIHVzZSAoZXguIHNjYWxpbmcsIG1vZGlmeWluZywgb3IgZXhwb3J0aW5nKS5cblx0ICpcblx0ICogTm90ZSB0aGF0IGNhbGxpbmcgc3RvcmUoKSB3aWxsIGZvcmNlIHRoZSBhY3RpdmUgcGF0aCAoaWYgYW55KSB0byBiZSBlbmRlZCBpbiBhIG1hbm5lciBzaW1pbGFyIHRvIGNoYW5naW5nXG5cdCAqIHRoZSBmaWxsIG9yIHN0cm9rZS5cblx0ICpcblx0ICogRm9yIGV4YW1wbGUsIGNvbnNpZGVyIGEgYXBwbGljYXRpb24gd2hlcmUgdGhlIHVzZXIgZHJhd3MgbGluZXMgd2l0aCB0aGUgbW91c2UuIEFzIGVhY2ggbGluZSBzZWdtZW50IChvciBjb2xsZWN0aW9uIG9mXG5cdCAqIHNlZ21lbnRzKSBhcmUgYWRkZWQgdG8gYSBTaGFwZSwgaXQgY2FuIGJlIHJhc3Rlcml6ZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC91cGRhdGVDYWNoZVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogYW5kIHRoZW4gc3RvcmVkLCBzbyB0aGF0IGl0IGNhbiBiZSByZWRyYXduIGF0IGEgZGlmZmVyZW50IHNjYWxlIHdoZW4gdGhlIGFwcGxpY2F0aW9uIGlzIHJlc2l6ZWQsIG9yIGV4cG9ydGVkIHRvIFNWRy5cblx0ICpcblx0ICogXHQvLyBzZXQgdXAgY2FjaGU6XG5cdCAqIFx0bXlTaGFwZS5jYWNoZSgwLDAsNTAwLDUwMCxzY2FsZSk7XG5cdCAqXG5cdCAqIFx0Ly8gd2hlbiB0aGUgdXNlciBkcmFncywgZHJhdyBhIG5ldyBsaW5lOlxuXHQgKiBcdG15U2hhcGUuZ3JhcGhpY3MubW92ZVRvKG9sZFgsb2xkWSkubGluZVRvKG5ld1gsbmV3WSk7XG5cdCAqIFx0Ly8gdGhlbiBkcmF3IGl0IGludG8gdGhlIGV4aXN0aW5nIGNhY2hlOlxuXHQgKiBcdG15U2hhcGUudXBkYXRlQ2FjaGUoXCJzb3VyY2Utb3ZlclwiKTtcblx0ICogXHQvLyBzdG9yZSB0aGUgbmV3IGxpbmUsIHNvIGl0IGlzbid0IHJlZHJhd24gbmV4dCB0aW1lOlxuXHQgKiBcdG15U2hhcGUuc3RvcmUoKTtcblx0ICpcblx0ICogXHQvLyB0aGVuLCB3aGVuIHRoZSB3aW5kb3cgcmVzaXplcywgd2UgY2FuIHJlLXJlbmRlciBhdCBhIGRpZmZlcmVudCBzY2FsZTpcblx0ICogXHQvLyBmaXJzdCwgdW5zdG9yZSBhbGwgb3VyIGxpbmVzOlxuXHQgKiBcdG15U2hhcGUudW5zdG9yZSgpO1xuXHQgKiBcdC8vIHRoZW4gY2FjaGUgdXNpbmcgdGhlIG5ldyBzY2FsZTpcblx0ICogXHRteVNoYXBlLmNhY2hlKDAsMCw1MDAsNTAwLG5ld1NjYWxlKTtcblx0ICogXHQvLyBmaW5hbGx5LCBzdG9yZSB0aGUgZXhpc3RpbmcgY29tbWFuZHMgYWdhaW46XG5cdCAqIFx0bXlTaGFwZS5zdG9yZSgpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHN0b3JlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5zdG9yZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3VwZGF0ZUluc3RydWN0aW9ucyh0cnVlKTtcblx0XHR0aGlzLl9zdG9yZUluZGV4ID0gdGhpcy5faW5zdHJ1Y3Rpb25zLmxlbmd0aDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogVW5zdG9yZXMgYW55IGdyYXBoaWNzIGNvbW1hbmRzIHRoYXQgd2VyZSBwcmV2aW91c2x5IHN0b3JlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9zdG9yZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBzbyB0aGF0IHRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiBzdWJzZXF1ZW50IGRyYXcgY2FsbHMuXG5cdCAqXG5cdCAqIEBtZXRob2QgdW5zdG9yZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAudW5zdG9yZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3N0b3JlSW5kZXggPSAwO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBHcmFwaGljcyBpbnN0YW5jZS4gTm90ZSB0aGF0IHRoZSBpbmRpdmlkdWFsIGNvbW1hbmQgb2JqZWN0cyBhcmUgbm90IGNsb25lZC5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gQSBjbG9uZSBvZiB0aGUgY3VycmVudCBHcmFwaGljcyBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG8gPSBuZXcgR3JhcGhpY3MoKTtcblx0XHRvLmNvbW1hbmQgPSB0aGlzLmNvbW1hbmQ7XG5cdFx0by5fc3Ryb2tlID0gdGhpcy5fc3Ryb2tlO1xuXHRcdG8uX3N0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlU3R5bGU7XG5cdFx0by5fc3Ryb2tlRGFzaCA9IHRoaXMuX3N0cm9rZURhc2g7XG5cdFx0by5fc3Ryb2tlSWdub3JlU2NhbGUgPSB0aGlzLl9zdHJva2VJZ25vcmVTY2FsZTtcblx0XHRvLl9maWxsID0gdGhpcy5fZmlsbDtcblx0XHRvLl9pbnN0cnVjdGlvbnMgPSB0aGlzLl9pbnN0cnVjdGlvbnMuc2xpY2UoKTtcblx0XHRvLl9jb21taXRJbmRleCA9IHRoaXMuX2NvbW1pdEluZGV4O1xuXHRcdG8uX2FjdGl2ZUluc3RydWN0aW9ucyA9IHRoaXMuX2FjdGl2ZUluc3RydWN0aW9ucy5zbGljZSgpO1xuXHRcdG8uX2RpcnR5ID0gdGhpcy5fZGlydHk7XG5cdFx0by5fc3RvcmVJbmRleCA9IHRoaXMuX3N0b3JlSW5kZXg7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltHcmFwaGljc11cIjtcblx0fTtcblxuXG4vLyB0aW55IEFQSTpcblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIG1vdmVUby5cblx0ICogQG1ldGhvZCBtdFxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBtb3ZlIHRvLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBjb29yZGluYXRlIHRoZSBkcmF3aW5nIHBvaW50IHNob3VsZCBtb3ZlIHRvLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5tdCA9IHAubW92ZVRvO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBsaW5lVG8uXG5cdCAqIEBtZXRob2QgbHRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggY29vcmRpbmF0ZSB0aGUgZHJhd2luZyBwb2ludCBzaG91bGQgZHJhdyB0by5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZSB0aGUgZHJhd2luZyBwb2ludCBzaG91bGQgZHJhdyB0by5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAubHQgPSBwLmxpbmVUbztcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYXJjVG8uXG5cdCAqIEBtZXRob2QgYXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geDJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuYXQgPSBwLmFyY1RvO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZXppZXJDdXJ2ZVRvLlxuXHQgKiBAbWV0aG9kIGJ0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcDF4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcDF5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcDJ4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcDJ5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmJ0ID0gcC5iZXppZXJDdXJ2ZVRvO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBxdWFkcmF0aWNDdXJ2ZVRvIC8gY3VydmVUby5cblx0ICogQG1ldGhvZCBxdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3B4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5xdCA9IHAucXVhZHJhdGljQ3VydmVUbztcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYXJjLlxuXHQgKiBAbWV0aG9kIGFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRBbmdsZSBNZWFzdXJlZCBpbiByYWRpYW5zLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZW5kQW5nbGUgTWVhc3VyZWQgaW4gcmFkaWFucy5cblx0ICogQHBhcmFtIHtCb29sZWFufSBhbnRpY2xvY2t3aXNlXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmEgPSBwLmFyYztcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gcmVjdC5cblx0ICogQG1ldGhvZCByXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFdpZHRoIG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGggSGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuciA9IHAucmVjdDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gY2xvc2VQYXRoLlxuXHQgKiBAbWV0aG9kIGNwXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmNwID0gcC5jbG9zZVBhdGg7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGNsZWFyLlxuXHQgKiBAbWV0aG9kIGNcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuYyA9IHAuY2xlYXI7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luRmlsbC5cblx0ICogQG1ldGhvZCBmXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBBIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlIChleC4gXCJyZWRcIiwgXCIjRkYwMDAwXCIsIG9yIFwicmdiYSgyNTUsMCwwLDAuNSlcIikuIFNldHRpbmcgdG9cblx0ICogbnVsbCB3aWxsIHJlc3VsdCBpbiBubyBmaWxsLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5mID0gcC5iZWdpbkZpbGw7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luTGluZWFyR3JhZGllbnRGaWxsLlxuXHQgKiBAbWV0aG9kIGxmXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9ycyBBbiBhcnJheSBvZiBDU1MgY29tcGF0aWJsZSBjb2xvciB2YWx1ZXMuIEZvciBleGFtcGxlLCBbXCIjRjAwXCIsXCIjMDBGXCJdIHdvdWxkIGRlZmluZSBhIGdyYWRpZW50XG5cdCAqIGRyYXdpbmcgZnJvbSByZWQgdG8gYmx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gcmF0aW9zIEFuIGFycmF5IG9mIGdyYWRpZW50IHBvc2l0aW9ucyB3aGljaCBjb3JyZXNwb25kIHRvIHRoZSBjb2xvcnMuIEZvciBleGFtcGxlLCBbMC4xLCAwLjldIHdvdWxkIGRyYXdcblx0ICogdGhlIGZpcnN0IGNvbG9yIHRvIDEwJSB0aGVuIGludGVycG9sYXRpbmcgdG8gdGhlIHNlY29uZCBjb2xvciBhdCA5MCUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTAgVGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTEgVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmxmID0gcC5iZWdpbkxpbmVhckdyYWRpZW50RmlsbDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gYmVnaW5SYWRpYWxHcmFkaWVudEZpbGwuXG5cdCAqIEBtZXRob2QgcmZcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzIEFuIGFycmF5IG9mIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlcy4gRm9yIGV4YW1wbGUsIFtcIiNGMDBcIixcIiMwMEZcIl0gd291bGQgZGVmaW5lXG5cdCAqIGEgZ3JhZGllbnQgZHJhd2luZyBmcm9tIHJlZCB0byBibHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3MgQW4gYXJyYXkgb2YgZ3JhZGllbnQgcG9zaXRpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNvbG9ycy4gRm9yIGV4YW1wbGUsIFswLjEsXG5cdCAqIDAuOV0gd291bGQgZHJhdyB0aGUgZmlyc3QgY29sb3IgdG8gMTAlIHRoZW4gaW50ZXJwb2xhdGluZyB0byB0aGUgc2Vjb25kIGNvbG9yIGF0IDkwJS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjAgUmFkaXVzIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjEgUmFkaXVzIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAucmYgPSBwLmJlZ2luUmFkaWFsR3JhZGllbnRGaWxsO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBiZWdpbkJpdG1hcEZpbGwuXG5cdCAqIEBtZXRob2QgYmZcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50fSBpbWFnZSBUaGUgSW1hZ2UsIENhbnZhcywgb3IgVmlkZW8gb2JqZWN0IHRvIHVzZVxuXHQgKiBhcyB0aGUgcGF0dGVybi5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHJlcGV0aXRpb24gT3B0aW9uYWwuIEluZGljYXRlcyB3aGV0aGVyIHRvIHJlcGVhdCB0aGUgaW1hZ2UgaW4gdGhlIGZpbGwgYXJlYS4gT25lIG9mIFwicmVwZWF0XCIsXG5cdCAqIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiBEZWZhdWx0cyB0byBcInJlcGVhdFwiLiBOb3RlIHRoYXQgRmlyZWZveCBkb2VzIG5vdCBzdXBwb3J0IFwicmVwZWF0LXhcIiBvclxuXHQgKiBcInJlcGVhdC15XCIgKGxhdGVzdCB0ZXN0cyB3ZXJlIGluIEZGIDIwLjApLCBhbmQgd2lsbCBkZWZhdWx0IHRvIFwicmVwZWF0XCIuXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IG1hdHJpeCBPcHRpb25hbC4gU3BlY2lmaWVzIGEgdHJhbnNmb3JtYXRpb24gbWF0cml4IGZvciB0aGUgYml0bWFwIGZpbGwuIFRoaXMgdHJhbnNmb3JtYXRpb25cblx0ICogd2lsbCBiZSBhcHBsaWVkIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQgdHJhbnNmb3JtLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5iZiA9IHAuYmVnaW5CaXRtYXBGaWxsO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBlbmRGaWxsLlxuXHQgKiBAbWV0aG9kIGVmXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmVmID0gcC5lbmRGaWxsO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBzZXRTdHJva2VTdHlsZS5cblx0ICogQG1ldGhvZCBzc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gdGhpY2tuZXNzIFRoZSB3aWR0aCBvZiB0aGUgc3Ryb2tlLlxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gW2NhcHM9MF0gSW5kaWNhdGVzIHRoZSB0eXBlIG9mIGNhcHMgdG8gdXNlIGF0IHRoZSBlbmQgb2YgbGluZXMuIE9uZSBvZiBidXR0LFxuXHQgKiByb3VuZCwgb3Igc3F1YXJlLiBEZWZhdWx0cyB0byBcImJ1dHRcIi4gQWxzbyBhY2NlcHRzIHRoZSB2YWx1ZXMgMCAoYnV0dCksIDEgKHJvdW5kKSwgYW5kIDIgKHNxdWFyZSkgZm9yIHVzZSB3aXRoXG5cdCAqIHRoZSB0aW55IEFQSS5cblx0ICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IFtqb2ludHM9MF0gU3BlY2lmaWVzIHRoZSB0eXBlIG9mIGpvaW50cyB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZXJlIHR3byBsaW5lcyBtZWV0LlxuXHQgKiBPbmUgb2YgYmV2ZWwsIHJvdW5kLCBvciBtaXRlci4gRGVmYXVsdHMgdG8gXCJtaXRlclwiLiBBbHNvIGFjY2VwdHMgdGhlIHZhbHVlcyAwIChtaXRlciksIDEgKHJvdW5kKSwgYW5kIDIgKGJldmVsKVxuXHQgKiBmb3IgdXNlIHdpdGggdGhlIHRpbnkgQVBJLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW21pdGVyTGltaXQ9MTBdIElmIGpvaW50cyBpcyBzZXQgdG8gXCJtaXRlclwiLCB0aGVuIHlvdSBjYW4gc3BlY2lmeSBhIG1pdGVyIGxpbWl0IHJhdGlvIHdoaWNoXG5cdCAqIGNvbnRyb2xzIGF0IHdoYXQgcG9pbnQgYSBtaXRlcmVkIGpvaW50IHdpbGwgYmUgY2xpcHBlZC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbaWdub3JlU2NhbGU9ZmFsc2VdIElmIHRydWUsIHRoZSBzdHJva2Ugd2lsbCBiZSBkcmF3biBhdCB0aGUgc3BlY2lmaWVkIHRoaWNrbmVzcyByZWdhcmRsZXNzXG5cdCAqIG9mIGFjdGl2ZSB0cmFuc2Zvcm1hdGlvbnMuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnNzID0gcC5zZXRTdHJva2VTdHlsZTtcblx0XG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBzZXRTdHJva2VEYXNoLlxuXHQgKiBAbWV0aG9kIHNkXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtzZWdtZW50c10gQW4gYXJyYXkgc3BlY2lmeWluZyB0aGUgZGFzaCBwYXR0ZXJuLCBhbHRlcm5hdGluZyBiZXR3ZWVuIGxpbmUgYW5kIGdhcC5cblx0ICogRm9yIGV4YW1wbGUsIFsyMCwxMF0gd291bGQgY3JlYXRlIGEgcGF0dGVybiBvZiAyMCBwaXhlbCBsaW5lcyB3aXRoIDEwIHBpeGVsIGdhcHMgYmV0d2VlbiB0aGVtLlxuXHQgKiBQYXNzaW5nIG51bGwgb3IgYW4gZW1wdHkgYXJyYXkgd2lsbCBjbGVhciBhbnkgZXhpc3RpbmcgZGFzaC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXQ9MF0gVGhlIG9mZnNldCBvZiB0aGUgZGFzaCBwYXR0ZXJuLiBGb3IgZXhhbXBsZSwgeW91IGNvdWxkIGluY3JlbWVudCB0aGlzIHZhbHVlIHRvIGNyZWF0ZSBhIFwibWFyY2hpbmcgYW50c1wiIGVmZmVjdC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuc2QgPSBwLnNldFN0cm9rZURhc2g7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luU3Ryb2tlLlxuXHQgKiBAbWV0aG9kIHNcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIEEgQ1NTIGNvbXBhdGlibGUgY29sb3IgdmFsdWUgKGV4LiBcIiNGRjAwMDBcIiwgXCJyZWRcIiwgb3IgXCJyZ2JhKDI1NSwwLDAsMC41KVwiKS4gU2V0dGluZyB0b1xuXHQgKiBudWxsIHdpbGwgcmVzdWx0IGluIG5vIHN0cm9rZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAucyA9IHAuYmVnaW5TdHJva2U7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luTGluZWFyR3JhZGllbnRTdHJva2UuXG5cdCAqIEBtZXRob2QgbHNcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzIEFuIGFycmF5IG9mIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlcy4gRm9yIGV4YW1wbGUsIFtcIiNGMDBcIixcIiMwMEZcIl0gd291bGQgZGVmaW5lXG5cdCAqIGEgZ3JhZGllbnQgZHJhd2luZyBmcm9tIHJlZCB0byBibHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3MgQW4gYXJyYXkgb2YgZ3JhZGllbnQgcG9zaXRpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNvbG9ycy4gRm9yIGV4YW1wbGUsIFswLjEsXG5cdCAqIDAuOV0gd291bGQgZHJhdyB0aGUgZmlyc3QgY29sb3IgdG8gMTAlIHRoZW4gaW50ZXJwb2xhdGluZyB0byB0aGUgc2Vjb25kIGNvbG9yIGF0IDkwJS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwIFRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MCBUaGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHBvaW50IGRlZmluaW5nIHRoZSBsaW5lIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQgZGlyZWN0aW9uIGFuZCBzaXplLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geDEgVGhlIHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgcG9pbnQgZGVmaW5pbmcgdGhlIGxpbmUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudCBkaXJlY3Rpb24gYW5kIHNpemUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MSBUaGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBwb2ludCBkZWZpbmluZyB0aGUgbGluZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50IGRpcmVjdGlvbiBhbmQgc2l6ZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAubHMgPSBwLmJlZ2luTGluZWFyR3JhZGllbnRTdHJva2U7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luUmFkaWFsR3JhZGllbnRTdHJva2UuXG5cdCAqIEBtZXRob2QgcnNcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzIEFuIGFycmF5IG9mIENTUyBjb21wYXRpYmxlIGNvbG9yIHZhbHVlcy4gRm9yIGV4YW1wbGUsIFtcIiNGMDBcIixcIiMwMEZcIl0gd291bGQgZGVmaW5lXG5cdCAqIGEgZ3JhZGllbnQgZHJhd2luZyBmcm9tIHJlZCB0byBibHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3MgQW4gYXJyYXkgb2YgZ3JhZGllbnQgcG9zaXRpb25zIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIGNvbG9ycy4gRm9yIGV4YW1wbGUsIFswLjEsXG5cdCAqIDAuOV0gd291bGQgZHJhdyB0aGUgZmlyc3QgY29sb3IgdG8gMTAlIHRoZW4gaW50ZXJwb2xhdGluZyB0byB0aGUgc2Vjb25kIGNvbG9yIGF0IDkwJSwgdGhlbiBkcmF3IHRoZSBzZWNvbmQgY29sb3Jcblx0ICogdG8gMTAwJS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgaW5uZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MCBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIGlubmVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjAgUmFkaXVzIG9mIHRoZSBpbm5lciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxIENlbnRlciBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgY2lyY2xlIHRoYXQgZGVmaW5lcyB0aGUgZ3JhZGllbnQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MSBDZW50ZXIgcG9zaXRpb24gb2YgdGhlIG91dGVyIGNpcmNsZSB0aGF0IGRlZmluZXMgdGhlIGdyYWRpZW50LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjEgUmFkaXVzIG9mIHRoZSBvdXRlciBjaXJjbGUgdGhhdCBkZWZpbmVzIHRoZSBncmFkaWVudC5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAucnMgPSBwLmJlZ2luUmFkaWFsR3JhZGllbnRTdHJva2U7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGJlZ2luQml0bWFwU3Ryb2tlLlxuXHQgKiBAbWV0aG9kIGJzXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudH0gaW1hZ2UgVGhlIEltYWdlLCBDYW52YXMsIG9yIFZpZGVvIG9iamVjdCB0byB1c2Vcblx0ICogYXMgdGhlIHBhdHRlcm4uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcmVwZXRpdGlvbj1yZXBlYXRdIE9wdGlvbmFsLiBJbmRpY2F0ZXMgd2hldGhlciB0byByZXBlYXQgdGhlIGltYWdlIGluIHRoZSBmaWxsIGFyZWEuIE9uZSBvZlxuXHQgKiBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gRGVmYXVsdHMgdG8gXCJyZXBlYXRcIi5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuYnMgPSBwLmJlZ2luQml0bWFwU3Ryb2tlO1xuXG5cdC8qKlxuXHQgKiBTaG9ydGN1dCB0byBlbmRTdHJva2UuXG5cdCAqIEBtZXRob2QgZXNcblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuZXMgPSBwLmVuZFN0cm9rZTtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gZHJhd1JlY3QuXG5cdCAqIEBtZXRob2QgZHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHcgV2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaCBIZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5kciA9IHAuZHJhd1JlY3Q7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGRyYXdSb3VuZFJlY3QuXG5cdCAqIEBtZXRob2QgcnJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBDb3JuZXIgcmFkaXVzLlxuXHQgKiBAcmV0dXJuIHtHcmFwaGljc30gVGhlIEdyYXBoaWNzIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5yciA9IHAuZHJhd1JvdW5kUmVjdDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gZHJhd1JvdW5kUmVjdENvbXBsZXguXG5cdCAqIEBtZXRob2QgcmNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZSB0byBkcmF3IHRoZSByb3VuZCByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgdmVydGljYWwgY29vcmRpbmF0ZSB0byBkcmF3IHRoZSByb3VuZCByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdyBUaGUgd2lkdGggb2YgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoIFRoZSBoZWlnaHQgb2YgdGhlIHJvdW5kIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUTCBUb3AgbGVmdCBjb3JuZXIgcmFkaXVzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzVFIgVG9wIHJpZ2h0IGNvcm5lciByYWRpdXMuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCUiBCb3R0b20gcmlnaHQgY29ybmVyIHJhZGl1cy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c0JMIEJvdHRvbSBsZWZ0IGNvcm5lciByYWRpdXMuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnJjID0gcC5kcmF3Um91bmRSZWN0Q29tcGxleDtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gZHJhd0NpcmNsZS5cblx0ICogQG1ldGhvZCBkY1xuXHQgKiBAcGFyYW0ge051bWJlcn0geCB4IGNvb3JkaW5hdGUgY2VudGVyIHBvaW50IG9mIGNpcmNsZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgeSBjb29yZGluYXRlIGNlbnRlciBwb2ludCBvZiBjaXJjbGUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIGNpcmNsZS5cblx0ICogQHJldHVybiB7R3JhcGhpY3N9IFRoZSBHcmFwaGljcyBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuZGMgPSBwLmRyYXdDaXJjbGU7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGRyYXdFbGxpcHNlLlxuXHQgKiBAbWV0aG9kIGRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSBsZWZ0IGNvb3JkaW5hdGUgcG9pbnQgb2YgdGhlIGVsbGlwc2UuIE5vdGUgdGhhdCB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdDaXJjbGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2hpY2ggZHJhd3MgZnJvbSBjZW50ZXIuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB0b3AgY29vcmRpbmF0ZSBwb2ludCBvZiB0aGUgZWxsaXBzZS4gTm90ZSB0aGF0IHRoaXMgaXMgZGlmZmVyZW50IGZyb20ge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd0NpcmNsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aGljaCBkcmF3cyBmcm9tIHRoZSBjZW50ZXIuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3IFRoZSBoZWlnaHQgKGhvcml6b250YWwgZGlhbWV0ZXIpIG9mIHRoZSBlbGxpcHNlLiBUaGUgaG9yaXpvbnRhbCByYWRpdXMgd2lsbCBiZSBoYWxmIG9mIHRoaXNcblx0ICogbnVtYmVyLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaCBUaGUgd2lkdGggKHZlcnRpY2FsIGRpYW1ldGVyKSBvZiB0aGUgZWxsaXBzZS4gVGhlIHZlcnRpY2FsIHJhZGl1cyB3aWxsIGJlIGhhbGYgb2YgdGhpcyBudW1iZXIuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmRlID0gcC5kcmF3RWxsaXBzZTtcblxuXHQvKipcblx0ICogU2hvcnRjdXQgdG8gZHJhd1BvbHlTdGFyLlxuXHQgKiBAbWV0aG9kIGRwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb2YgdGhlIHNoYXBlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBQb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIHRoZSBzaGFwZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBzaGFwZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNpZGVzIFRoZSBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBzdGFyIG9yIHNpZGVzIG9uIHRoZSBwb2x5Z29uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9pbnRTaXplIFRoZSBkZXB0aCBvciBcInBvaW50eS1uZXNzXCIgb2YgdGhlIHN0YXIgcG9pbnRzLiBBIHBvaW50U2l6ZSBvZiAwIHdpbGwgZHJhdyBhIHJlZ3VsYXJcblx0ICogcG9seWdvbiAobm8gcG9pbnRzKSwgYSBwb2ludFNpemUgb2YgMSB3aWxsIGRyYXcgbm90aGluZyBiZWNhdXNlIHRoZSBwb2ludHMgYXJlIGluZmluaXRlbHkgcG9pbnR5LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgVGhlIGFuZ2xlIG9mIHRoZSBmaXJzdCBwb2ludCAvIGNvcm5lci4gRm9yIGV4YW1wbGUgYSB2YWx1ZSBvZiAwIHdpbGwgZHJhdyB0aGUgZmlyc3QgcG9pbnRcblx0ICogZGlyZWN0bHkgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjZW50ZXIuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLmRwID0gcC5kcmF3UG9seVN0YXI7XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGRlY29kZVBhdGguXG5cdCAqIEBtZXRob2QgcFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBwYXRoIHN0cmluZyB0byBkZWNvZGUuXG5cdCAqIEByZXR1cm4ge0dyYXBoaWNzfSBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLnAgPSBwLmRlY29kZVBhdGg7XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfdXBkYXRlSW5zdHJ1Y3Rpb25zXG5cdCAqIEBwYXJhbSBjb21taXRcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3VwZGF0ZUluc3RydWN0aW9ucyA9IGZ1bmN0aW9uKGNvbW1pdCkge1xuXHRcdHZhciBpbnN0ciA9IHRoaXMuX2luc3RydWN0aW9ucywgYWN0aXZlID0gdGhpcy5fYWN0aXZlSW5zdHJ1Y3Rpb25zLCBjb21taXRJbmRleCA9IHRoaXMuX2NvbW1pdEluZGV4O1xuXG5cdFx0aWYgKHRoaXMuX2RpcnR5ICYmIGFjdGl2ZS5sZW5ndGgpIHtcblx0XHRcdGluc3RyLmxlbmd0aCA9IGNvbW1pdEluZGV4OyAvLyByZW1vdmUgb2xkLCB1bmNvbW1pdHRlZCBjb21tYW5kc1xuXHRcdFx0aW5zdHIucHVzaChHcmFwaGljcy5iZWdpbkNtZCk7XG5cblx0XHRcdHZhciBsID0gYWN0aXZlLmxlbmd0aCwgbGwgPSBpbnN0ci5sZW5ndGg7XG5cdFx0XHRpbnN0ci5sZW5ndGggPSBsbCtsO1xuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykgeyBpbnN0cltpK2xsXSA9IGFjdGl2ZVtpXTsgfVxuXG5cdFx0XHRpZiAodGhpcy5fZmlsbCkgeyBpbnN0ci5wdXNoKHRoaXMuX2ZpbGwpOyB9XG5cdFx0XHRpZiAodGhpcy5fc3Ryb2tlKSB7XG5cdFx0XHRcdC8vIGRvZXNuJ3QgbmVlZCB0byBiZSByZS1hcHBsaWVkIGlmIGl0IGhhc24ndCBjaGFuZ2VkLlxuXHRcdFx0XHRpZiAodGhpcy5fc3Ryb2tlRGFzaCAhPT0gdGhpcy5fb2xkU3Ryb2tlRGFzaCkge1xuXHRcdFx0XHRcdHRoaXMuX29sZFN0cm9rZURhc2ggPSB0aGlzLl9zdHJva2VEYXNoO1xuXHRcdFx0XHRcdGluc3RyLnB1c2godGhpcy5fc3Ryb2tlRGFzaCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX3N0cm9rZVN0eWxlICE9PSB0aGlzLl9vbGRTdHJva2VTdHlsZSkge1xuXHRcdFx0XHRcdHRoaXMuX29sZFN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlU3R5bGU7XG5cdFx0XHRcdFx0aW5zdHIucHVzaCh0aGlzLl9zdHJva2VTdHlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5zdHIucHVzaCh0aGlzLl9zdHJva2UpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChjb21taXQpIHtcblx0XHRcdGFjdGl2ZS5sZW5ndGggPSAwO1xuXHRcdFx0dGhpcy5fY29tbWl0SW5kZXggPSBpbnN0ci5sZW5ndGg7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9zZXRGaWxsXG5cdCAqIEBwYXJhbSBmaWxsXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9zZXRGaWxsID0gZnVuY3Rpb24oZmlsbCkge1xuXHRcdHRoaXMuX3VwZGF0ZUluc3RydWN0aW9ucyh0cnVlKTtcblx0XHR0aGlzLmNvbW1hbmQgPSB0aGlzLl9maWxsID0gZmlsbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfc2V0U3Ryb2tlXG5cdCAqIEBwYXJhbSBzdHJva2Vcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3NldFN0cm9rZSA9IGZ1bmN0aW9uKHN0cm9rZSkge1xuXHRcdHRoaXMuX3VwZGF0ZUluc3RydWN0aW9ucyh0cnVlKTtcblx0XHRpZiAodGhpcy5jb21tYW5kID0gdGhpcy5fc3Ryb2tlID0gc3Ryb2tlKSB7XG5cdFx0XHRzdHJva2UuaWdub3JlU2NhbGUgPSB0aGlzLl9zdHJva2VJZ25vcmVTY2FsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cbi8vIENvbW1hbmQgT2JqZWN0czpcblx0LyoqXG5cdCAqIEBuYW1lc3BhY2UgR3JhcGhpY3Ncblx0ICovXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2xpbmVUb1wifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3NcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIExpbmVUb1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdChHLkxpbmVUbyA9IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHgubGluZVRvKHRoaXMueCx0aGlzLnkpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL21vdmVUb1wifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgTW92ZVRvXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKi9cblx0KEcuTW92ZVRvID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7IGN0eC5tb3ZlVG8odGhpcy54LCB0aGlzLnkpOyB9O1xuXG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXJjVG9cIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIEFyY1RvXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0geDFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MlxuXHQgKiBAcGFyYW0ge051bWJlcn0geTJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeDFcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHkxXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4MlxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeTJcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHJhZGl1c1xuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKi9cblx0KEcuQXJjVG8gPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKSB7XG5cdFx0dGhpcy54MSA9IHgxOyB0aGlzLnkxID0geTE7XG5cdFx0dGhpcy54MiA9IHgyOyB0aGlzLnkyID0geTI7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7IGN0eC5hcmNUbyh0aGlzLngxLCB0aGlzLnkxLCB0aGlzLngyLCB0aGlzLnkyLCB0aGlzLnJhZGl1cyk7IH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXJjXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBBcmNcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0QW5nbGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGVuZEFuZ2xlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbnRpY2xvY2t3aXNlXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSByYWRpdXNcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHN0YXJ0QW5nbGVcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGVuZEFuZ2xlXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBhbnRpY2xvY2t3aXNlXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqL1xuXHQoRy5BcmMgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKSB7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0XHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcblx0XHR0aGlzLnN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlOyB0aGlzLmVuZEFuZ2xlID0gZW5kQW5nbGU7XG5cdFx0dGhpcy5hbnRpY2xvY2t3aXNlID0gISFhbnRpY2xvY2t3aXNlO1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHguYXJjKHRoaXMueCwgdGhpcy55LCB0aGlzLnJhZGl1cywgdGhpcy5zdGFydEFuZ2xlLCB0aGlzLmVuZEFuZ2xlLCB0aGlzLmFudGljbG9ja3dpc2UpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3F1YWRyYXRpY0N1cnZlVG9cIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2FwcGVuZFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQGNsYXNzIFF1YWRyYXRpY0N1cnZlVG9cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjcHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNweVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgY3B4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBjcHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdChHLlF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbihjcHgsIGNweSwgeCwgeSkge1xuXHRcdHRoaXMuY3B4ID0gY3B4OyB0aGlzLmNweSA9IGNweTtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHgucXVhZHJhdGljQ3VydmVUbyh0aGlzLmNweCwgdGhpcy5jcHksIHRoaXMueCwgdGhpcy55KTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZXppZXJDdXJ2ZVRvXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBCZXppZXJDdXJ2ZVRvXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AxeFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AxeVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AyeFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY3AyeVxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgY3AxeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgY3AxeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgY3AyeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgY3AyeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKi9cblx0KEcuQmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcblx0XHR0aGlzLmNwMXggPSBjcDF4OyB0aGlzLmNwMXkgPSBjcDF5O1xuXHRcdHRoaXMuY3AyeCA9IGNwMng7IHRoaXMuY3AyeSA9IGNwMnk7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LmJlemllckN1cnZlVG8odGhpcy5jcDF4LCB0aGlzLmNwMXksIHRoaXMuY3AyeCwgdGhpcy5jcDJ5LCB0aGlzLngsIHRoaXMueSk7IH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvcmVjdFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgUmVjdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHdcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdChHLlJlY3QgPSBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0XHR0aGlzLncgPSB3OyB0aGlzLmggPSBoO1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkgeyBjdHgucmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy53LCB0aGlzLmgpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2Nsb3NlUGF0aFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgQ2xvc2VQYXRoXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKi9cblx0KEcuQ2xvc2VQYXRoID0gZnVuY3Rpb24oKSB7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7IGN0eC5jbG9zZVBhdGgoKTsgfTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QgdG8gYmVnaW4gYSBuZXcgcGF0aC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBCZWdpblBhdGhcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqL1xuXHQoRy5CZWdpblBhdGggPSBmdW5jdGlvbigpIHtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHsgY3R4LmJlZ2luUGF0aCgpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luRmlsbFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgRmlsbFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IHN0eWxlIEEgdmFsaWQgQ29udGV4dDJEIGZpbGxTdHlsZS5cblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4XG5cdCAqKi9cblx0LyoqXG5cdCAqIEEgdmFsaWQgQ29udGV4dDJEIGZpbGxTdHlsZS5cblx0ICogQHByb3BlcnR5IHN0eWxlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBtYXRyaXhcblx0ICogQHR5cGUgTWF0cml4MkRcblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKi9cblx0cCA9IChHLkZpbGwgPSBmdW5jdGlvbihzdHlsZSwgbWF0cml4KSB7XG5cdFx0dGhpcy5zdHlsZSA9IHN0eWxlO1xuXHRcdHRoaXMubWF0cml4ID0gbWF0cml4O1xuXHR9KS5wcm90b3R5cGU7XG5cdHAuZXhlYyA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGlmICghdGhpcy5zdHlsZSkgeyByZXR1cm47IH1cblx0XHRjdHguZmlsbFN0eWxlID0gdGhpcy5zdHlsZTtcblx0XHR2YXIgbXR4ID0gdGhpcy5tYXRyaXg7XG5cdFx0aWYgKG10eCkgeyBjdHguc2F2ZSgpOyBjdHgudHJhbnNmb3JtKG10eC5hLCBtdHguYiwgbXR4LmMsIG10eC5kLCBtdHgudHgsIG10eC50eSk7IH1cblx0XHRjdHguZmlsbCgpO1xuXHRcdGlmIChtdHgpIHsgY3R4LnJlc3RvcmUoKTsgfVxuXHR9O1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIGxpbmVhciBncmFkaWVudCBzdHlsZSBhbmQgYXNzaWducyBpdCB0byB7eyNjcm9zc0xpbmsgXCJGaWxsL3N0eWxlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYmVnaW5MaW5lYXJHcmFkaWVudEZpbGxcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBtZXRob2QgbGluZWFyR3JhZGllbnRcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvc1xuXHQgKiBAcGFyYW0ge051bWJlcn0geDBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuXHQgKiBAcGFyYW0ge051bWJlcn0geTFcblx0ICogQHJldHVybiB7RmlsbH0gUmV0dXJucyB0aGlzIEZpbGwgb2JqZWN0IGZvciBjaGFpbmluZyBvciBhc3NpZ25tZW50LlxuXHQgKi9cblx0cC5saW5lYXJHcmFkaWVudCA9IGZ1bmN0aW9uKGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHgxLCB5MSkge1xuXHRcdHZhciBvID0gdGhpcy5zdHlsZSA9ICBHcmFwaGljcy5fY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgwLCB5MCwgeDEsIHkxKTtcblx0XHRmb3IgKHZhciBpPTAsIGw9Y29sb3JzLmxlbmd0aDsgaTxsOyBpKyspIHsgby5hZGRDb2xvclN0b3AocmF0aW9zW2ldLCBjb2xvcnNbaV0pOyB9XG5cdFx0by5wcm9wcyA9IHtjb2xvcnM6Y29sb3JzLCByYXRpb3M6cmF0aW9zLCB4MDp4MCwgeTA6eTAsIHgxOngxLCB5MTp5MSwgdHlwZTpcImxpbmVhclwifTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSByYWRpYWwgZ3JhZGllbnQgc3R5bGUgYW5kIGFzc2lnbnMgaXQgdG8ge3sjY3Jvc3NMaW5rIFwiRmlsbC9zdHlsZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luUmFkaWFsR3JhZGllbnRGaWxsXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIHJhZGlhbEdyYWRpZW50XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9yc1xuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcjFcblx0ICogQHJldHVybiB7RmlsbH0gUmV0dXJucyB0aGlzIEZpbGwgb2JqZWN0IGZvciBjaGFpbmluZyBvciBhc3NpZ25tZW50LlxuXHQgKi9cblx0cC5yYWRpYWxHcmFkaWVudCA9IGZ1bmN0aW9uKGNvbG9ycywgcmF0aW9zLCB4MCwgeTAsIHIwLCB4MSwgeTEsIHIxKSB7XG5cdFx0dmFyIG8gPSB0aGlzLnN0eWxlID0gIEdyYXBoaWNzLl9jdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoeDAsIHkwLCByMCwgeDEsIHkxLCByMSk7XG5cdFx0Zm9yICh2YXIgaT0wLCBsPWNvbG9ycy5sZW5ndGg7IGk8bDsgaSsrKSB7IG8uYWRkQ29sb3JTdG9wKHJhdGlvc1tpXSwgY29sb3JzW2ldKTsgfVxuXHRcdG8ucHJvcHMgPSB7Y29sb3JzOmNvbG9ycywgcmF0aW9zOnJhdGlvcywgeDA6eDAsIHkwOnkwLCByMDpyMCwgeDE6eDEsIHkxOnkxLCByMTpyMSwgdHlwZTpcInJhZGlhbFwifTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBiaXRtYXAgZmlsbCBzdHlsZSBhbmQgYXNzaWducyBpdCB0byB0aGUge3sjY3Jvc3NMaW5rIFwiRmlsbC9zdHlsZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luQml0bWFwRmlsbFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQG1ldGhvZCBiaXRtYXBcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50fSBpbWFnZSAgTXVzdCBiZSBsb2FkZWQgcHJpb3IgdG8gY3JlYXRpbmcgYSBiaXRtYXAgZmlsbCwgb3IgdGhlIGZpbGwgd2lsbCBiZSBlbXB0eS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtyZXBldGl0aW9uXSBPbmUgb2Y6IHJlcGVhdCwgcmVwZWF0LXgsIHJlcGVhdC15LCBvciBuby1yZXBlYXQuXG5cdCAqIEByZXR1cm4ge0ZpbGx9IFJldHVybnMgdGhpcyBGaWxsIG9iamVjdCBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cblx0ICovXG5cdHAuYml0bWFwID0gZnVuY3Rpb24oaW1hZ2UsIHJlcGV0aXRpb24pIHtcblx0XHRpZiAoaW1hZ2UubmF0dXJhbFdpZHRoIHx8IGltYWdlLmdldENvbnRleHQgfHwgaW1hZ2UucmVhZHlTdGF0ZSA+PSAyKSB7XG5cdFx0XHR2YXIgbyA9IHRoaXMuc3R5bGUgPSBHcmFwaGljcy5fY3R4LmNyZWF0ZVBhdHRlcm4oaW1hZ2UsIHJlcGV0aXRpb24gfHwgXCJcIik7XG5cdFx0XHRvLnByb3BzID0ge2ltYWdlOiBpbWFnZSwgcmVwZXRpdGlvbjogcmVwZXRpdGlvbiwgdHlwZTogXCJiaXRtYXBcIn07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRwLnBhdGggPSBmYWxzZTtcblxuXHQvKipcblx0ICogR3JhcGhpY3MgY29tbWFuZCBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpblN0cm9rZVwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgU3Ryb2tlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3R5bGUgQSB2YWxpZCBDb250ZXh0MkQgZmlsbFN0eWxlLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZVNjYWxlXG5cdCAqKi9cblx0LyoqXG5cdCAqIEEgdmFsaWQgQ29udGV4dDJEIHN0cm9rZVN0eWxlLlxuXHQgKiBAcHJvcGVydHkgc3R5bGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IGlnbm9yZVNjYWxlXG5cdCAqIEB0eXBlIEJvb2xlYW5cblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKi9cblx0cCA9IChHLlN0cm9rZSA9IGZ1bmN0aW9uKHN0eWxlLCBpZ25vcmVTY2FsZSkge1xuXHRcdHRoaXMuc3R5bGUgPSBzdHlsZTtcblx0XHR0aGlzLmlnbm9yZVNjYWxlID0gaWdub3JlU2NhbGU7XG5cdH0pLnByb3RvdHlwZTtcblx0cC5leGVjID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0aWYgKCF0aGlzLnN0eWxlKSB7IHJldHVybjsgfVxuXHRcdGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc3R5bGU7XG5cdFx0aWYgKHRoaXMuaWdub3JlU2NhbGUpIHsgY3R4LnNhdmUoKTsgY3R4LnNldFRyYW5zZm9ybSgxLDAsMCwxLDAsMCk7IH1cblx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0aWYgKHRoaXMuaWdub3JlU2NhbGUpIHsgY3R4LnJlc3RvcmUoKTsgfVxuXHR9O1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIGxpbmVhciBncmFkaWVudCBzdHlsZSBhbmQgYXNzaWducyBpdCB0byB7eyNjcm9zc0xpbmsgXCJTdHJva2Uvc3R5bGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9iZWdpbkxpbmVhckdyYWRpZW50U3Ryb2tlXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIGxpbmVhckdyYWRpZW50XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvbG9yc1xuXHQgKiBAcGFyYW0ge0FycmF5fSByYXRpb3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IHgwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5MFxuXHQgKiBAcGFyYW0ge051bWJlcn0geDFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxXG5cdCAqIEByZXR1cm4ge0ZpbGx9IFJldHVybnMgdGhpcyBTdHJva2Ugb2JqZWN0IGZvciBjaGFpbmluZyBvciBhc3NpZ25tZW50LlxuXHQgKi9cblx0cC5saW5lYXJHcmFkaWVudCA9IEcuRmlsbC5wcm90b3R5cGUubGluZWFyR3JhZGllbnQ7XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgcmFkaWFsIGdyYWRpZW50IHN0eWxlIGFuZCBhc3NpZ25zIGl0IHRvIHt7I2Nyb3NzTGluayBcIlN0cm9rZS9zdHlsZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luUmFkaWFsR3JhZGllbnRTdHJva2VcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBtZXRob2QgcmFkaWFsR3JhZGllbnRcblx0ICogQHBhcmFtIHtBcnJheX0gY29sb3JzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHJhdGlvc1xuXHQgKiBAcGFyYW0ge051bWJlcn0geDBcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMFxuXHQgKiBAcGFyYW0ge051bWJlcn0geDFcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkxXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByMVxuXHQgKiBAcmV0dXJuIHtGaWxsfSBSZXR1cm5zIHRoaXMgU3Ryb2tlIG9iamVjdCBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cblx0ICovXG5cdHAucmFkaWFsR3JhZGllbnQgPSBHLkZpbGwucHJvdG90eXBlLnJhZGlhbEdyYWRpZW50O1xuXHQvKipcblx0ICogQ3JlYXRlcyBhIGJpdG1hcCBmaWxsIHN0eWxlIGFuZCBhc3NpZ25zIGl0IHRvIHt7I2Nyb3NzTGluayBcIlN0cm9rZS9zdHlsZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2JlZ2luQml0bWFwU3Ryb2tlXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAbWV0aG9kIGJpdG1hcFxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IGltYWdlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbcmVwZXRpdGlvbl0gT25lIG9mOiByZXBlYXQsIHJlcGVhdC14LCByZXBlYXQteSwgb3Igbm8tcmVwZWF0LlxuXHQgKiBAcmV0dXJuIHtGaWxsfSBSZXR1cm5zIHRoaXMgU3Ryb2tlIG9iamVjdCBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cblx0ICovXG5cdHAuYml0bWFwID0gRy5GaWxsLnByb3RvdHlwZS5iaXRtYXA7XG5cdHAucGF0aCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL3NldFN0cm9rZVN0eWxlXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBTdHJva2VTdHlsZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbY2Fwc11cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtqb2ludHNdXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbWl0ZXJMaW1pdF1cblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHdpZHRoXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIE9uZSBvZjogYnV0dCwgcm91bmQsIHNxdWFyZVxuXHQgKiBAcHJvcGVydHkgY2Fwc1xuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICovXG5cdC8qKlxuXHQgKiBPbmUgb2Y6IHJvdW5kLCBiZXZlbCwgbWl0ZXJcblx0ICogQHByb3BlcnR5IGpvaW50c1xuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgbWl0ZXJMaW1pdFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKi9cblx0cCA9IChHLlN0cm9rZVN0eWxlID0gZnVuY3Rpb24od2lkdGgsIGNhcHMsIGpvaW50cywgbWl0ZXJMaW1pdCkge1xuXHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLmNhcHMgPSBjYXBzO1xuXHRcdHRoaXMuam9pbnRzID0gam9pbnRzO1xuXHRcdHRoaXMubWl0ZXJMaW1pdCA9IG1pdGVyTGltaXQ7XG5cdH0pLnByb3RvdHlwZTtcblx0cC5leGVjID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0Y3R4LmxpbmVXaWR0aCA9ICh0aGlzLndpZHRoID09IG51bGwgPyBcIjFcIiA6IHRoaXMud2lkdGgpO1xuXHRcdGN0eC5saW5lQ2FwID0gKHRoaXMuY2FwcyA9PSBudWxsID8gXCJidXR0XCIgOiAoaXNOYU4odGhpcy5jYXBzKSA/IHRoaXMuY2FwcyA6IEdyYXBoaWNzLlNUUk9LRV9DQVBTX01BUFt0aGlzLmNhcHNdKSk7XG5cdFx0Y3R4LmxpbmVKb2luID0gKHRoaXMuam9pbnRzID09IG51bGwgPyBcIm1pdGVyXCIgOiAoaXNOYU4odGhpcy5qb2ludHMpID8gdGhpcy5qb2ludHMgOiBHcmFwaGljcy5TVFJPS0VfSk9JTlRTX01BUFt0aGlzLmpvaW50c10pKTtcblx0XHRjdHgubWl0ZXJMaW1pdCA9ICh0aGlzLm1pdGVyTGltaXQgPT0gbnVsbCA/IFwiMTBcIiA6IHRoaXMubWl0ZXJMaW1pdCk7XG5cdH07XG5cdHAucGF0aCA9IGZhbHNlO1xuXHRcblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3Mvc2V0U3Ryb2tlRGFzaFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgU3Ryb2tlRGFzaFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtBcnJheX0gW3NlZ21lbnRzXVxuXHQgKiBAcGFyYW0ge051bWJlcn0gW29mZnNldD0wXVxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgc2VnbWVudHNcblx0ICogQHR5cGUgQXJyYXlcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgb2Zmc2V0XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBtZXRob2QgZXhlY1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqL1xuXHQoRy5TdHJva2VEYXNoID0gZnVuY3Rpb24oc2VnbWVudHMsIG9mZnNldCkge1xuXHRcdHRoaXMuc2VnbWVudHMgPSBzZWdtZW50cztcblx0XHR0aGlzLm9mZnNldCA9IG9mZnNldHx8MDtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHtcblx0XHRpZiAoY3R4LnNldExpbmVEYXNoKSB7IC8vIGZlYXR1cmUgZGV0ZWN0aW9uLlxuXHRcdFx0Y3R4LnNldExpbmVEYXNoKHRoaXMuc2VnbWVudHN8fCBHLlN0cm9rZURhc2guRU1QVFlfU0VHTUVOVFMpOyAvLyBpbnN0ZWFkIG9mIFtdIHRvIHJlZHVjZSBjaHVybi5cblx0XHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IHRoaXMub2Zmc2V0fHwwO1xuXHRcdH1cblx0fTtcblx0LyoqXG5cdCAqIFRoZSBkZWZhdWx0IHZhbHVlIGZvciBzZWdtZW50cyAoaWUuIG5vIGRhc2gpLlxuXHQgKiBAcHJvcGVydHkgRU1QVFlfU0VHTUVOVFNcblx0ICogQHN0YXRpY1xuXHQgKiBAZmluYWxcblx0ICogQHJlYWRvbmx5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiovXG5cdEcuU3Ryb2tlRGFzaC5FTVBUWV9TRUdNRU5UUyA9IFtdO1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdSb3VuZFJlY3RDb21wbGV4XCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBSb3VuZFJlY3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUTFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzVFJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c0JSXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCTFxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgd1xuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgaFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcmFkaXVzVExcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHJhZGl1c1RSXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSByYWRpdXNCUlxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcmFkaXVzQkxcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdChHLlJvdW5kUmVjdCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgsIHJhZGl1c1RMLCByYWRpdXNUUiwgcmFkaXVzQlIsIHJhZGl1c0JMKSB7XG5cdFx0dGhpcy54ID0geDsgdGhpcy55ID0geTtcblx0XHR0aGlzLncgPSB3OyB0aGlzLmggPSBoO1xuXHRcdHRoaXMucmFkaXVzVEwgPSByYWRpdXNUTDsgdGhpcy5yYWRpdXNUUiA9IHJhZGl1c1RSO1xuXHRcdHRoaXMucmFkaXVzQlIgPSByYWRpdXNCUjsgdGhpcy5yYWRpdXNCTCA9IHJhZGl1c0JMO1xuXHR9KS5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKGN0eCkge1xuXHRcdHZhciBtYXggPSAodzxoP3c6aCkvMjtcblx0XHR2YXIgbVRMPTAsIG1UUj0wLCBtQlI9MCwgbUJMPTA7XG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHcgPSB0aGlzLncsIGggPSB0aGlzLmg7XG5cdFx0dmFyIHJUTCA9IHRoaXMucmFkaXVzVEwsIHJUUiA9IHRoaXMucmFkaXVzVFIsIHJCUiA9IHRoaXMucmFkaXVzQlIsIHJCTCA9IHRoaXMucmFkaXVzQkw7XG5cblx0XHRpZiAoclRMIDwgMCkgeyByVEwgKj0gKG1UTD0tMSk7IH1cblx0XHRpZiAoclRMID4gbWF4KSB7IHJUTCA9IG1heDsgfVxuXHRcdGlmIChyVFIgPCAwKSB7IHJUUiAqPSAobVRSPS0xKTsgfVxuXHRcdGlmIChyVFIgPiBtYXgpIHsgclRSID0gbWF4OyB9XG5cdFx0aWYgKHJCUiA8IDApIHsgckJSICo9IChtQlI9LTEpOyB9XG5cdFx0aWYgKHJCUiA+IG1heCkgeyByQlIgPSBtYXg7IH1cblx0XHRpZiAockJMIDwgMCkgeyByQkwgKj0gKG1CTD0tMSk7IH1cblx0XHRpZiAockJMID4gbWF4KSB7IHJCTCA9IG1heDsgfVxuXG5cdFx0Y3R4Lm1vdmVUbyh4K3ctclRSLCB5KTtcblx0XHRjdHguYXJjVG8oeCt3K3JUUiptVFIsIHktclRSKm1UUiwgeCt3LCB5K3JUUiwgclRSKTtcblx0XHRjdHgubGluZVRvKHgrdywgeStoLXJCUik7XG5cdFx0Y3R4LmFyY1RvKHgrdytyQlIqbUJSLCB5K2grckJSKm1CUiwgeCt3LXJCUiwgeStoLCByQlIpO1xuXHRcdGN0eC5saW5lVG8oeCtyQkwsIHkraCk7XG5cdFx0Y3R4LmFyY1RvKHgtckJMKm1CTCwgeStoK3JCTCptQkwsIHgsIHkraC1yQkwsIHJCTCk7XG5cdFx0Y3R4LmxpbmVUbyh4LCB5K3JUTCk7XG5cdFx0Y3R4LmFyY1RvKHgtclRMKm1UTCwgeS1yVEwqbVRMLCB4K3JUTCwgeSwgclRMKTtcblx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd0NpcmNsZVwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvYXBwZW5kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHQgKiBAY2xhc3MgQ2lyY2xlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG5cdCAqKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB4XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB5XG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKi9cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSByYWRpdXNcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdChHLkNpcmNsZSA9IGZ1bmN0aW9uKHgsIHksIHJhZGl1cykge1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7IGN0eC5hcmModGhpcy54LCB0aGlzLnksIHRoaXMucmFkaXVzLCAwLCBNYXRoLlBJKjIpOyB9O1xuXG5cdC8qKlxuXHQgKiBHcmFwaGljcyBjb21tYW5kIG9iamVjdC4gU2VlIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzL2RyYXdFbGxpcHNlXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBFbGxpcHNlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxuXHQgKiBAcGFyYW0ge051bWJlcn0gd1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaFxuXHQgKiovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgeVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgd1xuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgaFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGV4ZWNcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKi9cblx0KEcuRWxsaXBzZSA9IGZ1bmN0aW9uKHgsIHksIHcsIGgpIHtcblx0XHR0aGlzLnggPSB4OyB0aGlzLnkgPSB5O1xuXHRcdHRoaXMudyA9IHc7IHRoaXMuaCA9IGg7XG5cdH0pLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oY3R4KSB7XG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnk7XG5cdFx0dmFyIHcgPSB0aGlzLncsIGggPSB0aGlzLmg7XG5cblx0XHR2YXIgayA9IDAuNTUyMjg0ODtcblx0XHR2YXIgb3ggPSAodyAvIDIpICogaztcblx0XHR2YXIgb3kgPSAoaCAvIDIpICogaztcblx0XHR2YXIgeGUgPSB4ICsgdztcblx0XHR2YXIgeWUgPSB5ICsgaDtcblx0XHR2YXIgeG0gPSB4ICsgdyAvIDI7XG5cdFx0dmFyIHltID0geSArIGggLyAyO1xuXG5cdFx0Y3R4Lm1vdmVUbyh4LCB5bSk7XG5cdFx0Y3R4LmJlemllckN1cnZlVG8oeCwgeW0tb3ksIHhtLW94LCB5LCB4bSwgeSk7XG5cdFx0Y3R4LmJlemllckN1cnZlVG8oeG0rb3gsIHksIHhlLCB5bS1veSwgeGUsIHltKTtcblx0XHRjdHguYmV6aWVyQ3VydmVUbyh4ZSwgeW0rb3ksIHhtK294LCB5ZSwgeG0sIHllKTtcblx0XHRjdHguYmV6aWVyQ3VydmVUbyh4bS1veCwgeWUsIHgsIHltK295LCB4LCB5bSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdyYXBoaWNzIGNvbW1hbmQgb2JqZWN0LiBTZWUge3sjY3Jvc3NMaW5rIFwiR3JhcGhpY3MvZHJhd1BvbHlTdGFyXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJHcmFwaGljcy9hcHBlbmRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBjbGFzcyBQb2x5U3RhclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuXHQgKiBAcGFyYW0ge051bWJlcn0gc2lkZXNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50U2l6ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW5nbGVcblx0ICoqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHhcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHlcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHJhZGl1c1xuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgc2lkZXNcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQHByb3BlcnR5IHBvaW50U2l6ZVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgYW5nbGVcblx0ICogQHR5cGUgTnVtYmVyXG5cdCAqL1xuXHQvKipcblx0ICogQG1ldGhvZCBleGVjXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICovXG5cdChHLlBvbHlTdGFyID0gZnVuY3Rpb24oeCwgeSwgcmFkaXVzLCBzaWRlcywgcG9pbnRTaXplLCBhbmdsZSkge1xuXHRcdHRoaXMueCA9IHg7IHRoaXMueSA9IHk7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cdFx0dGhpcy5zaWRlcyA9IHNpZGVzO1xuXHRcdHRoaXMucG9pbnRTaXplID0gcG9pbnRTaXplO1xuXHRcdHRoaXMuYW5nbGUgPSBhbmdsZTtcblx0fSkucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihjdHgpIHtcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcblx0XHR2YXIgcmFkaXVzID0gdGhpcy5yYWRpdXM7XG5cdFx0dmFyIGFuZ2xlID0gKHRoaXMuYW5nbGV8fDApLzE4MCpNYXRoLlBJO1xuXHRcdHZhciBzaWRlcyA9IHRoaXMuc2lkZXM7XG5cdFx0dmFyIHBzID0gMS0odGhpcy5wb2ludFNpemV8fDApO1xuXHRcdHZhciBhID0gTWF0aC5QSS9zaWRlcztcblxuXHRcdGN0eC5tb3ZlVG8oeCtNYXRoLmNvcyhhbmdsZSkqcmFkaXVzLCB5K01hdGguc2luKGFuZ2xlKSpyYWRpdXMpO1xuXHRcdGZvciAodmFyIGk9MDsgaTxzaWRlczsgaSsrKSB7XG5cdFx0XHRhbmdsZSArPSBhO1xuXHRcdFx0aWYgKHBzICE9IDEpIHtcblx0XHRcdFx0Y3R4LmxpbmVUbyh4K01hdGguY29zKGFuZ2xlKSpyYWRpdXMqcHMsIHkrTWF0aC5zaW4oYW5nbGUpKnJhZGl1cypwcyk7XG5cdFx0XHR9XG5cdFx0XHRhbmdsZSArPSBhO1xuXHRcdFx0Y3R4LmxpbmVUbyh4K01hdGguY29zKGFuZ2xlKSpyYWRpdXMsIHkrTWF0aC5zaW4oYW5nbGUpKnJhZGl1cyk7XG5cdFx0fVxuXHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0fTtcblxuXHQvLyBkb2NjZWQgYWJvdmUuXG5cdEdyYXBoaWNzLmJlZ2luQ21kID0gbmV3IEcuQmVnaW5QYXRoKCk7IC8vIHNvIHdlIGRvbid0IGhhdmUgdG8gaW5zdGFudGlhdGUgbXVsdGlwbGUgaW5zdGFuY2VzLlxuXG5cblx0Y3JlYXRlanMuR3JhcGhpY3MgPSBHcmFwaGljcztcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBEaXNwbGF5T2JqZWN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cclxuLy8gY29uc3RydWN0b3I6XHJcblx0LyoqXHJcblx0ICogRGlzcGxheU9iamVjdCBpcyBhbiBhYnN0cmFjdCBjbGFzcyB0aGF0IHNob3VsZCBub3QgYmUgY29uc3RydWN0ZWQgZGlyZWN0bHkuIEluc3RlYWQgY29uc3RydWN0IHN1YmNsYXNzZXMgc3VjaCBhc1xyXG5cdCAqIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiQml0bWFwXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQge3sjY3Jvc3NMaW5rIFwiU2hhcGVcIn19e3svY3Jvc3NMaW5rfX0uXHJcblx0ICogRGlzcGxheU9iamVjdCBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIGRpc3BsYXkgY2xhc3NlcyBpbiB0aGUgRWFzZWxKUyBsaWJyYXJ5LiBJdCBkZWZpbmVzIHRoZSBjb3JlIHByb3BlcnRpZXMgYW5kXHJcblx0ICogbWV0aG9kcyB0aGF0IGFyZSBzaGFyZWQgYmV0d2VlbiBhbGwgZGlzcGxheSBvYmplY3RzLCBzdWNoIGFzIHRyYW5zZm9ybWF0aW9uIHByb3BlcnRpZXMgKHgsIHksIHNjYWxlWCwgc2NhbGVZLCBldGMpLFxyXG5cdCAqIGNhY2hpbmcsIGFuZCBtb3VzZSBoYW5kbGVycy5cclxuXHQgKiBAY2xhc3MgRGlzcGxheU9iamVjdFxyXG5cdCAqIEBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlclxyXG5cdCAqIEBjb25zdHJ1Y3RvclxyXG5cdCAqKi9cclxuXHRmdW5jdGlvbiBEaXNwbGF5T2JqZWN0KCkge1xyXG5cdFx0dGhpcy5FdmVudERpc3BhdGNoZXJfY29uc3RydWN0b3IoKTtcclxuXHRcdFxyXG5cdFx0XHJcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBhbHBoYSAodHJhbnNwYXJlbmN5KSBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdC4gMCBpcyBmdWxseSB0cmFuc3BhcmVudCwgMSBpcyBmdWxseSBvcGFxdWUuXHJcblx0XHQgKiBAcHJvcGVydHkgYWxwaGFcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAxXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLmFscGhhID0gMTtcclxuXHRcclxuXHRcdC8qKlxyXG5cdFx0ICogSWYgYSBjYWNoZSBpcyBhY3RpdmUsIHRoaXMgcmV0dXJucyB0aGUgY2FudmFzIHRoYXQgaG9sZHMgdGhlIGNhY2hlZCB2ZXJzaW9uIG9mIHRoaXMgZGlzcGxheSBvYmplY3QuIFNlZSB7eyNjcm9zc0xpbmsgXCJjYWNoZVwifX17ey9jcm9zc0xpbmt9fVxyXG5cdFx0ICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcblx0XHQgKiBAcHJvcGVydHkgY2FjaGVDYW52YXNcclxuXHRcdCAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudCB8IE9iamVjdH1cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqIEByZWFkb25seVxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5jYWNoZUNhbnZhcyA9IG51bGw7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIFJldHVybnMgYW4gSUQgbnVtYmVyIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGUgY3VycmVudCBjYWNoZSBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZCB0b1xyXG5cdFx0ICogZGV0ZXJtaW5lIGlmIHRoZSBjYWNoZSBoYXMgY2hhbmdlZCBzaW5jZSBhIHByZXZpb3VzIGNoZWNrLlxyXG5cdFx0ICogQHByb3BlcnR5IGNhY2hlSURcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAwXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuY2FjaGVJRCA9IDA7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIFVuaXF1ZSBJRCBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdC4gTWFrZXMgZGlzcGxheSBvYmplY3RzIGVhc2llciBmb3Igc29tZSB1c2VzLlxyXG5cdFx0ICogQHByb3BlcnR5IGlkXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgLTFcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuaWQgPSBjcmVhdGVqcy5VSUQuZ2V0KCk7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRvIGluY2x1ZGUgdGhpcyBvYmplY3Qgd2hlbiBydW5uaW5nIG1vdXNlIGludGVyYWN0aW9ucy4gU2V0dGluZyB0aGlzIHRvIGBmYWxzZWAgZm9yIGNoaWxkcmVuXHJcblx0XHQgKiBvZiBhIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fSB3aWxsIGNhdXNlIGV2ZW50cyBvbiB0aGUgQ29udGFpbmVyIHRvIG5vdCBmaXJlIHdoZW4gdGhhdCBjaGlsZCBpc1xyXG5cdFx0ICogY2xpY2tlZC4gU2V0dGluZyB0aGlzIHByb3BlcnR5IHRvIGBmYWxzZWAgZG9lcyBub3QgcHJldmVudCB0aGUge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyL2dldE9iamVjdHNVbmRlclBvaW50XCJ9fXt7L2Nyb3NzTGlua319XHJcblx0XHQgKiBtZXRob2QgZnJvbSByZXR1cm5pbmcgdGhlIGNoaWxkLlxyXG5cdFx0ICpcclxuXHRcdCAqIDxzdHJvbmc+Tm90ZTo8L3N0cm9uZz4gSW4gRWFzZWxKUyAwLjcuMCwgdGhlIG1vdXNlRW5hYmxlZCBwcm9wZXJ0eSB3aWxsIG5vdCB3b3JrIHByb3Blcmx5IHdpdGggbmVzdGVkIENvbnRhaW5lcnMuIFBsZWFzZVxyXG5cdFx0ICogY2hlY2sgb3V0IHRoZSBsYXRlc3QgTkVYVCB2ZXJzaW9uIGluIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vQ3JlYXRlSlMvRWFzZWxKUy90cmVlL21hc3Rlci9saWJcIj5HaXRIdWI8L2E+IGZvciBhbiB1cGRhdGVkIHZlcnNpb24gd2l0aCB0aGlzIGlzc3VlIHJlc29sdmVkLiBUaGUgZml4IHdpbGwgYmVcclxuXHRcdCAqIHByb3ZpZGVkIGluIHRoZSBuZXh0IHJlbGVhc2Ugb2YgRWFzZWxKUy5cclxuXHRcdCAqIEBwcm9wZXJ0eSBtb3VzZUVuYWJsZWRcclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5tb3VzZUVuYWJsZWQgPSB0cnVlO1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIElmIGZhbHNlLCB0aGUgdGljayB3aWxsIG5vdCBydW4gb24gdGhpcyBkaXNwbGF5IG9iamVjdCAob3IgaXRzIGNoaWxkcmVuKS4gVGhpcyBjYW4gcHJvdmlkZSBzb21lIHBlcmZvcm1hbmNlIGJlbmVmaXRzLlxyXG5cdFx0ICogSW4gYWRkaXRpb24gdG8gcHJldmVudGluZyB0aGUgXCJ0aWNrXCIgZXZlbnQgZnJvbSBiZWluZyBkaXNwYXRjaGVkLCBpdCB3aWxsIGFsc28gcHJldmVudCB0aWNrIHJlbGF0ZWQgdXBkYXRlc1xyXG5cdFx0ICogb24gc29tZSBkaXNwbGF5IG9iamVjdHMgKGV4LiBTcHJpdGUgJiBNb3ZpZUNsaXAgZnJhbWUgYWR2YW5jaW5nLCBET01FbGVtZW50IHZpc2liaWxpdHkgaGFuZGxpbmcpLlxyXG5cdFx0ICogQHByb3BlcnR5IHRpY2tFbmFibGVkXHJcblx0XHQgKiBAdHlwZSBCb29sZWFuXHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLnRpY2tFbmFibGVkID0gdHJ1ZTtcclxuXHRcclxuXHRcdC8qKlxyXG5cdFx0ICogQW4gb3B0aW9uYWwgbmFtZSBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdC4gSW5jbHVkZWQgaW4ge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC90b1N0cmluZ1wifX17ey9jcm9zc0xpbmt9fSAuIFVzZWZ1bCBmb3JcclxuXHRcdCAqIGRlYnVnZ2luZy5cclxuXHRcdCAqIEBwcm9wZXJ0eSBuYW1lXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5uYW1lID0gbnVsbDtcclxuXHRcclxuXHRcdC8qKlxyXG5cdFx0ICogQSByZWZlcmVuY2UgdG8gdGhlIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fSBvciB7eyNjcm9zc0xpbmsgXCJTdGFnZVwifX17ey9jcm9zc0xpbmt9fSBvYmplY3QgdGhhdFxyXG5cdFx0ICogY29udGFpbnMgdGhpcyBkaXNwbGF5IG9iamVjdCwgb3IgbnVsbCBpZiBpdCBoYXMgbm90IGJlZW4gYWRkZWRcclxuXHRcdCAqIHRvIG9uZS5cclxuXHRcdCAqIEBwcm9wZXJ0eSBwYXJlbnRcclxuXHRcdCAqIEBmaW5hbFxyXG5cdFx0ICogQHR5cGUge0NvbnRhaW5lcn1cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqIEByZWFkb25seVxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5wYXJlbnQgPSBudWxsO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgbGVmdCBvZmZzZXQgZm9yIHRoaXMgZGlzcGxheSBvYmplY3QncyByZWdpc3RyYXRpb24gcG9pbnQuIEZvciBleGFtcGxlLCB0byBtYWtlIGEgMTAweDEwMHB4IEJpdG1hcCByb3RhdGVcclxuXHRcdCAqIGFyb3VuZCBpdHMgY2VudGVyLCB5b3Ugd291bGQgc2V0IHJlZ1ggYW5kIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvcmVnWTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSB0byA1MC5cclxuXHRcdCAqIEBwcm9wZXJ0eSByZWdYXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5yZWdYID0gMDtcclxuXHRcclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIHkgb2Zmc2V0IGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0J3MgcmVnaXN0cmF0aW9uIHBvaW50LiBGb3IgZXhhbXBsZSwgdG8gbWFrZSBhIDEwMHgxMDBweCBCaXRtYXAgcm90YXRlIGFyb3VuZFxyXG5cdFx0ICogaXRzIGNlbnRlciwgeW91IHdvdWxkIHNldCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3JlZ1g6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHJlZ1kgdG8gNTAuXHJcblx0XHQgKiBAcHJvcGVydHkgcmVnWVxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IDBcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMucmVnWSA9IDA7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSByb3RhdGlvbiBpbiBkZWdyZWVzIGZvciB0aGlzIGRpc3BsYXkgb2JqZWN0LlxyXG5cdFx0ICogQHByb3BlcnR5IHJvdGF0aW9uXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5yb3RhdGlvbiA9IDA7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBmYWN0b3IgdG8gc3RyZXRjaCB0aGlzIGRpc3BsYXkgb2JqZWN0IGhvcml6b250YWxseS4gRm9yIGV4YW1wbGUsIHNldHRpbmcgc2NhbGVYIHRvIDIgd2lsbCBzdHJldGNoIHRoZSBkaXNwbGF5XHJcblx0XHQgKiBvYmplY3QgdG8gdHdpY2UgaXRzIG5vbWluYWwgd2lkdGguIFRvIGhvcml6b250YWxseSBmbGlwIGFuIG9iamVjdCwgc2V0IHRoZSBzY2FsZSB0byBhIG5lZ2F0aXZlIG51bWJlci5cclxuXHRcdCAqIEBwcm9wZXJ0eSBzY2FsZVhcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAxXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLnNjYWxlWCA9IDE7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSBmYWN0b3IgdG8gc3RyZXRjaCB0aGlzIGRpc3BsYXkgb2JqZWN0IHZlcnRpY2FsbHkuIEZvciBleGFtcGxlLCBzZXR0aW5nIHNjYWxlWSB0byAwLjUgd2lsbCBzdHJldGNoIHRoZSBkaXNwbGF5XHJcblx0XHQgKiBvYmplY3QgdG8gaGFsZiBpdHMgbm9taW5hbCBoZWlnaHQuIFRvIHZlcnRpY2FsbHkgZmxpcCBhbiBvYmplY3QsIHNldCB0aGUgc2NhbGUgdG8gYSBuZWdhdGl2ZSBudW1iZXIuXHJcblx0XHQgKiBAcHJvcGVydHkgc2NhbGVZXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMVxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5zY2FsZVkgPSAxO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGUgZmFjdG9yIHRvIHNrZXcgdGhpcyBkaXNwbGF5IG9iamVjdCBob3Jpem9udGFsbHkuXHJcblx0XHQgKiBAcHJvcGVydHkgc2tld1hcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAwXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLnNrZXdYID0gMDtcclxuXHRcclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGZhY3RvciB0byBza2V3IHRoaXMgZGlzcGxheSBvYmplY3QgdmVydGljYWxseS5cclxuXHRcdCAqIEBwcm9wZXJ0eSBza2V3WVxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IDBcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuc2tld1kgPSAwO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHNoYWRvdyBvYmplY3QgdGhhdCBkZWZpbmVzIHRoZSBzaGFkb3cgdG8gcmVuZGVyIG9uIHRoaXMgZGlzcGxheSBvYmplY3QuIFNldCB0byBgbnVsbGAgdG8gcmVtb3ZlIGEgc2hhZG93LiBJZlxyXG5cdFx0ICogbnVsbCwgdGhpcyBwcm9wZXJ0eSBpcyBpbmhlcml0ZWQgZnJvbSB0aGUgcGFyZW50IGNvbnRhaW5lci5cclxuXHRcdCAqIEBwcm9wZXJ0eSBzaGFkb3dcclxuXHRcdCAqIEB0eXBlIHtTaGFkb3d9XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLnNoYWRvdyA9IG51bGw7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgZGlzcGxheSBvYmplY3Qgc2hvdWxkIGJlIHJlbmRlcmVkIHRvIHRoZSBjYW52YXMgYW5kIGluY2x1ZGVkIHdoZW4gcnVubmluZyB0aGUgU3RhZ2VcclxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIlN0YWdlL2dldE9iamVjdHNVbmRlclBvaW50XCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cclxuXHRcdCAqIEBwcm9wZXJ0eSB2aXNpYmxlXHJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdCAqIEBkZWZhdWx0IHRydWVcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMudmlzaWJsZSA9IHRydWU7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIFRoZSB4IChob3Jpem9udGFsKSBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheSBvYmplY3QsIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQuXHJcblx0XHQgKiBAcHJvcGVydHkgeFxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IDBcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMueCA9IDA7XHJcblx0XHJcblx0XHQvKiogVGhlIHkgKHZlcnRpY2FsKSBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheSBvYmplY3QsIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQuXHJcblx0XHQgKiBAcHJvcGVydHkgeVxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IDBcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMueSA9IDA7XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogSWYgc2V0LCBkZWZpbmVzIHRoZSB0cmFuc2Zvcm1hdGlvbiBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdCwgb3ZlcnJpZGluZyBhbGwgb3RoZXIgdHJhbnNmb3JtYXRpb24gcHJvcGVydGllc1xyXG5cdFx0ICogKHgsIHksIHJvdGF0aW9uLCBzY2FsZSwgc2tldykuXHJcblx0XHQgKiBAcHJvcGVydHkgdHJhbnNmb3JtTWF0cml4XHJcblx0XHQgKiBAdHlwZSB7TWF0cml4MkR9XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IG51bGw7XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGNvbXBvc2l0ZSBvcGVyYXRpb24gaW5kaWNhdGVzIGhvdyB0aGUgcGl4ZWxzIG9mIHRoaXMgZGlzcGxheSBvYmplY3Qgd2lsbCBiZSBjb21wb3NpdGVkIHdpdGggdGhlIGVsZW1lbnRzXHJcblx0XHQgKiBiZWhpbmQgaXQuIElmIGBudWxsYCwgdGhpcyBwcm9wZXJ0eSBpcyBpbmhlcml0ZWQgZnJvbSB0aGUgcGFyZW50IGNvbnRhaW5lci4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlYWQgdGhlXHJcblx0XHQgKiA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjY29tcG9zaXRpbmdcIj5cclxuXHRcdCAqIHdoYXR3ZyBzcGVjIG9uIGNvbXBvc2l0aW5nPC9hPi5cclxuXHRcdCAqIEBwcm9wZXJ0eSBjb21wb3NpdGVPcGVyYXRpb25cclxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLmNvbXBvc2l0ZU9wZXJhdGlvbiA9IG51bGw7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCBzaG91bGQgYmUgZHJhd24gdG8gYSB3aG9sZSBwaXhlbCB3aGVuXHJcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJTdGFnZS9zbmFwVG9QaXhlbEVuYWJsZWRcIn19e3svY3Jvc3NMaW5rfX0gaXMgdHJ1ZS4gVG8gZW5hYmxlL2Rpc2FibGUgc25hcHBpbmcgb24gd2hvbGVcclxuXHRcdCAqIGNhdGVnb3JpZXMgb2YgZGlzcGxheSBvYmplY3RzLCBzZXQgdGhpcyB2YWx1ZSBvbiB0aGUgcHJvdG90eXBlIChFeC4gVGV4dC5wcm90b3R5cGUuc25hcFRvUGl4ZWwgPSB0cnVlKS5cclxuXHRcdCAqIEBwcm9wZXJ0eSBzbmFwVG9QaXhlbFxyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLnNuYXBUb1BpeGVsID0gdHJ1ZTtcclxuXHRcclxuXHRcdC8qKlxyXG5cdFx0ICogQW4gYXJyYXkgb2YgRmlsdGVyIG9iamVjdHMgdG8gYXBwbHkgdG8gdGhpcyBkaXNwbGF5IG9iamVjdC4gRmlsdGVycyBhcmUgb25seSBhcHBsaWVkIC8gdXBkYXRlZCB3aGVuIHt7I2Nyb3NzTGluayBcImNhY2hlXCJ9fXt7L2Nyb3NzTGlua319XHJcblx0XHQgKiBvciB7eyNjcm9zc0xpbmsgXCJ1cGRhdGVDYWNoZVwifX17ey9jcm9zc0xpbmt9fSBpcyBjYWxsZWQgb24gdGhlIGRpc3BsYXkgb2JqZWN0LCBhbmQgb25seSBhcHBseSB0byB0aGUgYXJlYSB0aGF0IGlzXHJcblx0XHQgKiBjYWNoZWQuXHJcblx0XHQgKiBAcHJvcGVydHkgZmlsdGVyc1xyXG5cdFx0ICogQHR5cGUge0FycmF5fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5maWx0ZXJzID0gbnVsbDtcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIFNoYXBlIGluc3RhbmNlIHRoYXQgZGVmaW5lcyBhIHZlY3RvciBtYXNrIChjbGlwcGluZyBwYXRoKSBmb3IgdGhpcyBkaXNwbGF5IG9iamVjdC4gIFRoZSBzaGFwZSdzIHRyYW5zZm9ybWF0aW9uXHJcblx0XHQgKiB3aWxsIGJlIGFwcGxpZWQgcmVsYXRpdmUgdG8gdGhlIGRpc3BsYXkgb2JqZWN0J3MgcGFyZW50IGNvb3JkaW5hdGVzIChhcyBpZiBpdCB3ZXJlIGEgY2hpbGQgb2YgdGhlIHBhcmVudCkuXHJcblx0XHQgKiBAcHJvcGVydHkgbWFza1xyXG5cdFx0ICogQHR5cGUge1NoYXBlfVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLm1hc2sgPSBudWxsO1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIEEgZGlzcGxheSBvYmplY3QgdGhhdCB3aWxsIGJlIHRlc3RlZCB3aGVuIGNoZWNraW5nIG1vdXNlIGludGVyYWN0aW9ucyBvciB0ZXN0aW5nIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lci9nZXRPYmplY3RzVW5kZXJQb2ludFwifX17ey9jcm9zc0xpbmt9fS5cclxuXHRcdCAqIFRoZSBoaXQgYXJlYSB3aWxsIGhhdmUgaXRzIHRyYW5zZm9ybWF0aW9uIGFwcGxpZWQgcmVsYXRpdmUgdG8gdGhpcyBkaXNwbGF5IG9iamVjdCdzIGNvb3JkaW5hdGUgc3BhY2UgKGFzIHRob3VnaFxyXG5cdFx0ICogdGhlIGhpdCB0ZXN0IG9iamVjdCB3ZXJlIGEgY2hpbGQgb2YgdGhpcyBkaXNwbGF5IG9iamVjdCBhbmQgcmVsYXRpdmUgdG8gaXRzIHJlZ1gvWSkuIFRoZSBoaXRBcmVhIHdpbGwgYmUgdGVzdGVkXHJcblx0XHQgKiB1c2luZyBvbmx5IGl0cyBvd24gYGFscGhhYCB2YWx1ZSByZWdhcmRsZXNzIG9mIHRoZSBhbHBoYSB2YWx1ZSBvbiB0aGUgdGFyZ2V0IGRpc3BsYXkgb2JqZWN0LCBvciB0aGUgdGFyZ2V0J3NcclxuXHRcdCAqIGFuY2VzdG9ycyAocGFyZW50cykuXHJcblx0XHQgKiBcclxuXHRcdCAqIElmIHNldCBvbiBhIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fSwgY2hpbGRyZW4gb2YgdGhlIENvbnRhaW5lciB3aWxsIG5vdCByZWNlaXZlIG1vdXNlIGV2ZW50cy5cclxuXHRcdCAqIFRoaXMgaXMgc2ltaWxhciB0byBzZXR0aW5nIHt7I2Nyb3NzTGluayBcIm1vdXNlQ2hpbGRyZW5cIn19e3svY3Jvc3NMaW5rfX0gdG8gZmFsc2UuXHJcblx0XHQgKlxyXG5cdFx0ICogTm90ZSB0aGF0IGhpdEFyZWEgaXMgTk9UIGN1cnJlbnRseSB1c2VkIGJ5IHRoZSBgaGl0VGVzdCgpYCBtZXRob2QsIG5vciBpcyBpdCBzdXBwb3J0ZWQgZm9yIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319LlxyXG5cdFx0ICogQHByb3BlcnR5IGhpdEFyZWFcclxuXHRcdCAqIEB0eXBlIHtEaXNwbGF5T2JqZWN0fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmhpdEFyZWEgPSBudWxsO1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIEEgQ1NTIGN1cnNvciAoZXguIFwicG9pbnRlclwiLCBcImhlbHBcIiwgXCJ0ZXh0XCIsIGV0YykgdGhhdCB3aWxsIGJlIGRpc3BsYXllZCB3aGVuIHRoZSB1c2VyIGhvdmVycyBvdmVyIHRoaXMgZGlzcGxheVxyXG5cdFx0ICogb2JqZWN0LiBZb3UgbXVzdCBlbmFibGUgbW91c2VvdmVyIGV2ZW50cyB1c2luZyB0aGUge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvZW5hYmxlTW91c2VPdmVyXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCB0b1xyXG5cdFx0ICogdXNlIHRoaXMgcHJvcGVydHkuIFNldHRpbmcgYSBub24tbnVsbCBjdXJzb3Igb24gYSBDb250YWluZXIgd2lsbCBvdmVycmlkZSB0aGUgY3Vyc29yIHNldCBvbiBpdHMgZGVzY2VuZGFudHMuXHJcblx0XHQgKiBAcHJvcGVydHkgY3Vyc29yXHJcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmN1cnNvciA9IG51bGw7XHJcblx0XHJcblx0XHJcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJvcGVydHkgX2NhY2hlT2Zmc2V0WFxyXG5cdFx0ICogQHByb3RlY3RlZFxyXG5cdFx0ICogQHR5cGUge051bWJlcn1cclxuXHRcdCAqIEBkZWZhdWx0IDBcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuX2NhY2hlT2Zmc2V0WCA9IDA7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIEBwcm9wZXJ0eSBfY2FjaGVPZmZzZXRZXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxyXG5cdFx0ICogQGRlZmF1bHQgMFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5fY2FjaGVPZmZzZXRZID0gMDtcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJvcGVydHkgX2ZpbHRlck9mZnNldFhcclxuXHRcdCAqIEBwcm90ZWN0ZWRcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAwXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLl9maWx0ZXJPZmZzZXRYID0gMDtcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJvcGVydHkgX2ZpbHRlck9mZnNldFlcclxuXHRcdCAqIEBwcm90ZWN0ZWRcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAwXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLl9maWx0ZXJPZmZzZXRZID0gMDtcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJvcGVydHkgX2NhY2hlU2NhbGVcclxuXHRcdCAqIEBwcm90ZWN0ZWRcclxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XHJcblx0XHQgKiBAZGVmYXVsdCAxXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLl9jYWNoZVNjYWxlID0gMTtcclxuXHRcclxuXHRcdC8qKlxyXG5cdFx0KiBAcHJvcGVydHkgX2NhY2hlRGF0YVVSTElEXHJcblx0XHQqIEBwcm90ZWN0ZWRcclxuXHRcdCogQHR5cGUge051bWJlcn1cclxuXHRcdCogQGRlZmF1bHQgMFxyXG5cdFx0Ki9cclxuXHRcdHRoaXMuX2NhY2hlRGF0YVVSTElEID0gMDtcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQqIEBwcm9wZXJ0eSBfY2FjaGVEYXRhVVJMXHJcblx0XHQqIEBwcm90ZWN0ZWRcclxuXHRcdCogQHR5cGUge1N0cmluZ31cclxuXHRcdCogQGRlZmF1bHQgbnVsbFxyXG5cdFx0Ki9cclxuXHRcdHRoaXMuX2NhY2hlRGF0YVVSTCA9IG51bGw7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIEBwcm9wZXJ0eSBfcHJvcHNcclxuXHRcdCAqIEBwcm90ZWN0ZWRcclxuXHRcdCAqIEB0eXBlIHtEaXNwbGF5T2JqZWN0fVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5fcHJvcHMgPSBuZXcgY3JlYXRlanMuRGlzcGxheVByb3BzKCk7XHJcblx0XHJcblx0XHQvKipcclxuXHRcdCAqIEBwcm9wZXJ0eSBfcmVjdGFuZ2xlXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAdHlwZSB7UmVjdGFuZ2xlfVxyXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5fcmVjdGFuZ2xlID0gbmV3IGNyZWF0ZWpzLlJlY3RhbmdsZSgpO1xyXG5cdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJvcGVydHkgX2JvdW5kc1xyXG5cdFx0ICogQHByb3RlY3RlZFxyXG5cdFx0ICogQHR5cGUge1JlY3RhbmdsZX1cclxuXHRcdCAqIEBkZWZhdWx0IG51bGxcclxuXHRcdCAqKi9cclxuXHRcdHRoaXMuX2JvdW5kcyA9IG51bGw7XHJcblx0fVxyXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKERpc3BsYXlPYmplY3QsIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlcik7XHJcblxyXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcclxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXHJcblx0XHJcbi8vIHN0YXRpYyBwcm9wZXJ0aWVzOlxyXG5cdC8qKlxyXG5cdCAqIExpc3Rpbmcgb2YgbW91c2UgZXZlbnQgbmFtZXMuIFVzZWQgaW4gX2hhc01vdXNlRXZlbnRMaXN0ZW5lci5cclxuXHQgKiBAcHJvcGVydHkgX01PVVNFX0VWRU5UU1xyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiBAc3RhdGljXHJcblx0ICogQHR5cGUge0FycmF5fVxyXG5cdCAqKi9cclxuXHREaXNwbGF5T2JqZWN0Ll9NT1VTRV9FVkVOVFMgPSBbXCJjbGlja1wiLFwiZGJsY2xpY2tcIixcIm1vdXNlZG93blwiLFwibW91c2VvdXRcIixcIm1vdXNlb3ZlclwiLFwicHJlc3Ntb3ZlXCIsXCJwcmVzc3VwXCIsXCJyb2xsb3V0XCIsXCJyb2xsb3ZlclwiXTtcclxuXHJcblx0LyoqXHJcblx0ICogU3VwcHJlc3NlcyBlcnJvcnMgZ2VuZXJhdGVkIHdoZW4gdXNpbmcgZmVhdHVyZXMgbGlrZSBoaXRUZXN0LCBtb3VzZSBldmVudHMsIGFuZCB7eyNjcm9zc0xpbmsgXCJnZXRPYmplY3RzVW5kZXJQb2ludFwifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIHdpdGggY3Jvc3MgZG9tYWluIGNvbnRlbnQuXHJcblx0ICogQHByb3BlcnR5IHN1cHByZXNzQ3Jvc3NEb21haW5FcnJvcnNcclxuXHQgKiBAc3RhdGljXHJcblx0ICogQHR5cGUge0Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHQgKiovXHJcblx0RGlzcGxheU9iamVjdC5zdXBwcmVzc0Nyb3NzRG9tYWluRXJyb3JzID0gZmFsc2U7XHJcblx0XHJcblx0LyoqXHJcblx0ICogQHByb3BlcnR5IF9zbmFwVG9QaXhlbEVuYWJsZWRcclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICogQHN0YXRpY1xyXG5cdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0ICoqL1xyXG5cdERpc3BsYXlPYmplY3QuX3NuYXBUb1BpeGVsRW5hYmxlZCA9IGZhbHNlOyAvLyBzdGFnZS5zbmFwVG9QaXhlbEVuYWJsZWQgaXMgdGVtcG9yYXJpbHkgY29waWVkIGhlcmUgZHVyaW5nIGEgZHJhdyB0byBwcm92aWRlIGdsb2JhbCBhY2Nlc3MuXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBwcm9wZXJ0eSBfaGl0VGVzdENhbnZhc1xyXG5cdCAqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudCB8IE9iamVjdH1cclxuXHQgKiBAc3RhdGljXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqKi9cclxuXHQvKipcclxuXHQgKiBAcHJvcGVydHkgX2hpdFRlc3RDb250ZXh0XHJcblx0ICogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cclxuXHQgKiBAc3RhdGljXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqKi9cclxuXHR2YXIgY2FudmFzID0gY3JlYXRlanMuY3JlYXRlQ2FudmFzP2NyZWF0ZWpzLmNyZWF0ZUNhbnZhcygpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7IC8vIHByZXZlbnQgZXJyb3JzIG9uIGxvYWQgaW4gYnJvd3NlcnMgd2l0aG91dCBjYW52YXMuXHJcblx0aWYgKGNhbnZhcy5nZXRDb250ZXh0KSB7XHJcblx0XHREaXNwbGF5T2JqZWN0Ll9oaXRUZXN0Q2FudmFzID0gY2FudmFzO1xyXG5cdFx0RGlzcGxheU9iamVjdC5faGl0VGVzdENvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDE7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBAcHJvcGVydHkgX25leHRDYWNoZUlEXHJcblx0ICogQHR5cGUge051bWJlcn1cclxuXHQgKiBAc3RhdGljXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqKi9cclxuXHREaXNwbGF5T2JqZWN0Ll9uZXh0Q2FjaGVJRCA9IDE7XHJcblxyXG5cclxuLy8gZXZlbnRzOlxyXG5cdC8qKlxyXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIHRoZWlyIGxlZnQgbW91c2UgYnV0dG9uIG92ZXIgdGhlIGRpc3BsYXkgb2JqZWN0LiBTZWUgdGhlIFxyXG5cdCAqIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxyXG5cdCAqIEBldmVudCBtb3VzZWRvd25cclxuXHQgKiBAc2luY2UgMC42LjBcclxuXHQgKi9cclxuXHQgXHJcblx0LyoqXHJcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgdGhlaXIgbGVmdCBtb3VzZSBidXR0b24gYW5kIHRoZW4gcmVsZWFzZXMgaXQgd2hpbGUgb3ZlciB0aGUgZGlzcGxheSBvYmplY3QuXHJcblx0ICogU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cclxuXHQgKiBAZXZlbnQgY2xpY2tcclxuXHQgKiBAc2luY2UgMC42LjBcclxuXHQgKi9cclxuXHQgXHJcblx0LyoqXHJcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSB1c2VyIGRvdWJsZSBjbGlja3MgdGhlaXIgbGVmdCBtb3VzZSBidXR0b24gb3ZlciB0aGlzIGRpc3BsYXkgb2JqZWN0LlxyXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXHJcblx0ICogQGV2ZW50IGRibGNsaWNrXHJcblx0ICogQHNpbmNlIDAuNi4wXHJcblx0ICovXHJcblx0IFxyXG5cdC8qKlxyXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgdXNlcidzIG1vdXNlIGVudGVycyB0aGlzIGRpc3BsYXkgb2JqZWN0LiBUaGlzIGV2ZW50IG11c3QgYmUgZW5hYmxlZCB1c2luZyBcclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTdGFnZS9lbmFibGVNb3VzZU92ZXJcIn19e3svY3Jvc3NMaW5rfX0uIFNlZSBhbHNvIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3Qvcm9sbG92ZXI6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uXHJcblx0ICogU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cclxuXHQgKiBAZXZlbnQgbW91c2VvdmVyXHJcblx0ICogQHNpbmNlIDAuNi4wXHJcblx0ICovXHJcblxyXG5cdC8qKlxyXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgdXNlcidzIG1vdXNlIGxlYXZlcyB0aGlzIGRpc3BsYXkgb2JqZWN0LiBUaGlzIGV2ZW50IG11c3QgYmUgZW5hYmxlZCB1c2luZyBcclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJTdGFnZS9lbmFibGVNb3VzZU92ZXJcIn19e3svY3Jvc3NMaW5rfX0uIFNlZSBhbHNvIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3Qvcm9sbG91dDpldmVudFwifX17ey9jcm9zc0xpbmt9fS5cclxuXHQgKiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxyXG5cdCAqIEBldmVudCBtb3VzZW91dFxyXG5cdCAqIEBzaW5jZSAwLjYuMFxyXG5cdCAqL1xyXG5cdCBcclxuXHQvKipcclxuXHQgKiBUaGlzIGV2ZW50IGlzIHNpbWlsYXIgdG8ge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9tb3VzZW92ZXI6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0sIHdpdGggdGhlIGZvbGxvd2luZ1xyXG5cdCAqIGRpZmZlcmVuY2VzOiBpdCBkb2VzIG5vdCBidWJibGUsIGFuZCBpdCBjb25zaWRlcnMge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlcyBhcyBhblxyXG5cdCAqIGFnZ3JlZ2F0ZSBvZiB0aGVpciBjb250ZW50LlxyXG5cdCAqIFxyXG5cdCAqIEZvciBleGFtcGxlLCBteUNvbnRhaW5lciBjb250YWlucyB0d28gb3ZlcmxhcHBpbmcgY2hpbGRyZW46IHNoYXBlQSBhbmQgc2hhcGVCLiBUaGUgdXNlciBtb3ZlcyB0aGVpciBtb3VzZSBvdmVyXHJcblx0ICogc2hhcGVBIGFuZCB0aGVuIGRpcmVjdGx5IG9uIHRvIHNoYXBlQi4gV2l0aCBhIGxpc3RlbmVyIGZvciB7eyNjcm9zc0xpbmsgXCJtb3VzZW92ZXI6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gb25cclxuXHQgKiBteUNvbnRhaW5lciwgdHdvIGV2ZW50cyB3b3VsZCBiZSByZWNlaXZlZCwgZWFjaCB0YXJnZXRpbmcgYSBjaGlsZCBlbGVtZW50OjxPTD5cclxuXHQgKiA8TEk+d2hlbiB0aGUgbW91c2UgZW50ZXJzIHNoYXBlQSAodGFyZ2V0PXNoYXBlQSk8L0xJPlxyXG5cdCAqIDxMST53aGVuIHRoZSBtb3VzZSBlbnRlcnMgc2hhcGVCICh0YXJnZXQ9c2hhcGVCKTwvTEk+XHJcblx0ICogPC9PTD5cclxuXHQgKiBIb3dldmVyLCB3aXRoIGEgbGlzdGVuZXIgZm9yIFwicm9sbG92ZXJcIiBpbnN0ZWFkLCBvbmx5IGEgc2luZ2xlIGV2ZW50IGlzIHJlY2VpdmVkIHdoZW4gdGhlIG1vdXNlIGZpcnN0IGVudGVyc1xyXG5cdCAqIHRoZSBhZ2dyZWdhdGUgbXlDb250YWluZXIgY29udGVudCAodGFyZ2V0PW15Q29udGFpbmVyKS5cclxuXHQgKiBcclxuXHQgKiBUaGlzIGV2ZW50IG11c3QgYmUgZW5hYmxlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJTdGFnZS9lbmFibGVNb3VzZU92ZXJcIn19e3svY3Jvc3NMaW5rfX0uXHJcblx0ICogU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cclxuXHQgKiBAZXZlbnQgcm9sbG92ZXJcclxuXHQgKiBAc2luY2UgMC43LjBcclxuXHQgKi9cclxuXHQgXHJcblx0LyoqXHJcblx0ICogVGhpcyBldmVudCBpcyBzaW1pbGFyIHRvIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2VvdXQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0sIHdpdGggdGhlIGZvbGxvd2luZ1xyXG5cdCAqIGRpZmZlcmVuY2VzOiBpdCBkb2VzIG5vdCBidWJibGUsIGFuZCBpdCBjb25zaWRlcnMge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlcyBhcyBhblxyXG5cdCAqIGFnZ3JlZ2F0ZSBvZiB0aGVpciBjb250ZW50LlxyXG5cdCAqIFxyXG5cdCAqIEZvciBleGFtcGxlLCBteUNvbnRhaW5lciBjb250YWlucyB0d28gb3ZlcmxhcHBpbmcgY2hpbGRyZW46IHNoYXBlQSBhbmQgc2hhcGVCLiBUaGUgdXNlciBtb3ZlcyB0aGVpciBtb3VzZSBvdmVyXHJcblx0ICogc2hhcGVBLCB0aGVuIGRpcmVjdGx5IG9uIHRvIHNoYXBlQiwgdGhlbiBvZmYgYm90aC4gV2l0aCBhIGxpc3RlbmVyIGZvciB7eyNjcm9zc0xpbmsgXCJtb3VzZW91dDpldmVudFwifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIG9uIG15Q29udGFpbmVyLCB0d28gZXZlbnRzIHdvdWxkIGJlIHJlY2VpdmVkLCBlYWNoIHRhcmdldGluZyBhIGNoaWxkIGVsZW1lbnQ6PE9MPlxyXG5cdCAqIDxMST53aGVuIHRoZSBtb3VzZSBsZWF2ZXMgc2hhcGVBICh0YXJnZXQ9c2hhcGVBKTwvTEk+XHJcblx0ICogPExJPndoZW4gdGhlIG1vdXNlIGxlYXZlcyBzaGFwZUIgKHRhcmdldD1zaGFwZUIpPC9MST5cclxuXHQgKiA8L09MPlxyXG5cdCAqIEhvd2V2ZXIsIHdpdGggYSBsaXN0ZW5lciBmb3IgXCJyb2xsb3V0XCIgaW5zdGVhZCwgb25seSBhIHNpbmdsZSBldmVudCBpcyByZWNlaXZlZCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXNcclxuXHQgKiB0aGUgYWdncmVnYXRlIG15Q29udGFpbmVyIGNvbnRlbnQgKHRhcmdldD1teUNvbnRhaW5lcikuXHJcblx0ICogXHJcblx0ICogVGhpcyBldmVudCBtdXN0IGJlIGVuYWJsZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvZW5hYmxlTW91c2VPdmVyXCJ9fXt7L2Nyb3NzTGlua319LlxyXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXHJcblx0ICogQGV2ZW50IHJvbGxvdXRcclxuXHQgKiBAc2luY2UgMC43LjBcclxuXHQgKi9cclxuXHQgXHJcblx0LyoqXHJcblx0ICogQWZ0ZXIgYSB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L21vdXNlZG93bjpldmVudFwifX17ey9jcm9zc0xpbmt9fSBvY2N1cnMgb24gYSBkaXNwbGF5IG9iamVjdCwgYSBwcmVzc21vdmVcclxuXHQgKiBldmVudCB3aWxsIGJlIGdlbmVyYXRlZCBvbiB0aGF0IG9iamVjdCB3aGVuZXZlciB0aGUgbW91c2UgbW92ZXMgdW50aWwgdGhlIG1vdXNlIHByZXNzIGlzIHJlbGVhc2VkLiBUaGlzIGNhbiBiZVxyXG5cdCAqIHVzZWZ1bCBmb3IgZHJhZ2dpbmcgYW5kIHNpbWlsYXIgb3BlcmF0aW9ucy5cclxuXHQgKiBAZXZlbnQgcHJlc3Ntb3ZlXHJcblx0ICogQHNpbmNlIDAuNy4wXHJcblx0ICovXHJcblx0IFxyXG5cdC8qKlxyXG5cdCAqIEFmdGVyIGEge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9tb3VzZWRvd246ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gb2NjdXJzIG9uIGEgZGlzcGxheSBvYmplY3QsIGEgcHJlc3N1cCBldmVudFxyXG5cdCAqIHdpbGwgYmUgZ2VuZXJhdGVkIG9uIHRoYXQgb2JqZWN0IHdoZW4gdGhhdCBtb3VzZSBwcmVzcyBpcyByZWxlYXNlZC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvciBkcmFnZ2luZyBhbmQgc2ltaWxhclxyXG5cdCAqIG9wZXJhdGlvbnMuXHJcblx0ICogQGV2ZW50IHByZXNzdXBcclxuXHQgKiBAc2luY2UgMC43LjBcclxuXHQgKi9cclxuXHQgXHJcblx0LyoqXHJcblx0ICogRGlzcGF0Y2hlZCB3aGVuIHRoZSBkaXNwbGF5IG9iamVjdCBpcyBhZGRlZCB0byBhIHBhcmVudCBjb250YWluZXIuXHJcblx0ICogQGV2ZW50IGFkZGVkXHJcblx0ICovXHJcblx0IFxyXG5cdC8qKlxyXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgZGlzcGxheSBvYmplY3QgaXMgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgY29udGFpbmVyLlxyXG5cdCAqIEBldmVudCByZW1vdmVkXHJcblx0ICovXHJcblx0IFxyXG5cdC8qKlxyXG5cdCAqIERpc3BhdGNoZWQgb24gZWFjaCBkaXNwbGF5IG9iamVjdCBvbiBhIHN0YWdlIHdoZW5ldmVyIHRoZSBzdGFnZSB1cGRhdGVzLiBUaGlzIG9jY3VycyBpbW1lZGlhdGVseSBiZWZvcmUgdGhlXHJcblx0ICogcmVuZGVyaW5nIChkcmF3KSBwYXNzLiBXaGVuIHt7I2Nyb3NzTGluayBcIlN0YWdlL3VwZGF0ZVwifX17ey9jcm9zc0xpbmt9fSBpcyBjYWxsZWQsIGZpcnN0IGFsbCBkaXNwbGF5IG9iamVjdHMgb25cclxuXHQgKiB0aGUgc3RhZ2UgZGlzcGF0Y2ggdGhlIHRpY2sgZXZlbnQsIHRoZW4gYWxsIG9mIHRoZSBkaXNwbGF5IG9iamVjdHMgYXJlIGRyYXduIHRvIHN0YWdlLiBDaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXJcclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJ0aWNrOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGRpc3BhdGNoZWQgaW4gb3JkZXIgb2YgdGhlaXIgZGVwdGggcHJpb3IgdG8gdGhlIGV2ZW50IGJlaW5nXHJcblx0ICogZGlzcGF0Y2hlZCBvbiB0aGVpciBwYXJlbnQuXHJcblx0ICogQGV2ZW50IHRpY2tcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cclxuXHQgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgQW4gYXJyYXkgY29udGFpbmluZyBhbnkgYXJndW1lbnRzIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhlIFN0YWdlLnVwZGF0ZSgpIG1ldGhvZC4gRm9yXHJcblx0ICogICAgICBleGFtcGxlIGlmIHlvdSBjYWxsZWQgc3RhZ2UudXBkYXRlKFwiaGVsbG9cIiksIHRoZW4gdGhlIHBhcmFtcyB3b3VsZCBiZSBbXCJoZWxsb1wiXS5cclxuXHQgKiBAc2luY2UgMC42LjBcclxuXHQgKi9cclxuXHRcclxuXHRcclxuLy8gZ2V0dGVyIC8gc2V0dGVyczpcclxuXHQvKipcclxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3Qvc3RhZ2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cclxuXHQgKiBAbWV0aG9kIGdldFN0YWdlXHJcblx0ICogQHJldHVybiB7U3RhZ2V9XHJcblx0ICogQGRlcHJlY2F0ZWRcclxuXHQgKiovXHJcblx0cC5nZXRTdGFnZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0Ly8gdXNlcyBkeW5hbWljIGFjY2VzcyB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXM7XHJcblx0XHR2YXIgbyA9IHRoaXMsIF9TdGFnZSA9IGNyZWF0ZWpzW1wiU3RhZ2VcIl07XHJcblx0XHR3aGlsZSAoby5wYXJlbnQpIHsgbyA9IG8ucGFyZW50OyB9XHJcblx0XHRpZiAobyBpbnN0YW5jZW9mIF9TdGFnZSkgeyByZXR1cm4gbzsgfVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgU3RhZ2UgaW5zdGFuY2UgdGhhdCB0aGlzIGRpc3BsYXkgb2JqZWN0IHdpbGwgYmUgcmVuZGVyZWQgb24sIG9yIG51bGwgaWYgaXQgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIG9uZS5cclxuXHQgKiBAcHJvcGVydHkgc3RhZ2VcclxuXHQgKiBAdHlwZSB7U3RhZ2V9XHJcblx0ICogQHJlYWRvbmx5XHJcblx0ICoqL1xyXG5cdHRyeSB7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwLCB7XHJcblx0XHRcdHN0YWdlOiB7IGdldDogcC5nZXRTdGFnZSB9XHJcblx0XHR9KTtcclxuXHR9IGNhdGNoIChlKSB7fVxyXG5cclxuXHJcbi8vIHB1YmxpYyBtZXRob2RzOlxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXMuXHJcblx0ICogVGhpcyBkb2VzIG5vdCBhY2NvdW50IGZvciB3aGV0aGVyIGl0IHdvdWxkIGJlIHZpc2libGUgd2l0aGluIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBzdGFnZS5cclxuXHQgKlxyXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cclxuXHQgKiBAbWV0aG9kIGlzVmlzaWJsZVxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzXHJcblx0ICoqL1xyXG5cdHAuaXNWaXNpYmxlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9IDAgJiYgdGhpcy5zY2FsZVkgIT0gMCk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogRHJhd3MgdGhlIGRpc3BsYXkgb2JqZWN0IGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IGlnbm9yaW5nIGl0cyB2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBhbmQgdHJhbnNmb3JtLlxyXG5cdCAqIFJldHVybnMgPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cclxuXHQgKlxyXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cclxuXHQgKiBAbWV0aG9kIGRyYXdcclxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZUNhY2hlPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZHJhdyBvcGVyYXRpb24gc2hvdWxkIGlnbm9yZSBhbnkgY3VycmVudCBjYWNoZS4gRm9yIGV4YW1wbGUsXHJcblx0ICogdXNlZCBmb3IgZHJhd2luZyB0aGUgY2FjaGUgKHRvIHByZXZlbnQgaXQgZnJvbSBzaW1wbHkgZHJhd2luZyBhbiBleGlzdGluZyBjYWNoZSBiYWNrIGludG8gaXRzZWxmKS5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxyXG5cdCAqKi9cclxuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGlnbm9yZUNhY2hlKSB7XHJcblx0XHR2YXIgY2FjaGVDYW52YXMgPSB0aGlzLmNhY2hlQ2FudmFzO1xyXG5cdFx0aWYgKGlnbm9yZUNhY2hlIHx8ICFjYWNoZUNhbnZhcykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuX2NhY2hlU2NhbGU7XHJcblx0XHRjdHguZHJhd0ltYWdlKGNhY2hlQ2FudmFzLCB0aGlzLl9jYWNoZU9mZnNldFgrdGhpcy5fZmlsdGVyT2Zmc2V0WCwgdGhpcy5fY2FjaGVPZmZzZXRZK3RoaXMuX2ZpbHRlck9mZnNldFksIGNhY2hlQ2FudmFzLndpZHRoL3NjYWxlLCBjYWNoZUNhbnZhcy5oZWlnaHQvc2NhbGUpO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBBcHBsaWVzIHRoaXMgZGlzcGxheSBvYmplY3QncyB0cmFuc2Zvcm1hdGlvbiwgYWxwaGEsIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiwgY2xpcHBpbmcgcGF0aCAobWFzayksIGFuZCBzaGFkb3dcclxuXHQgKiB0byB0aGUgc3BlY2lmaWVkIGNvbnRleHQuIFRoaXMgaXMgdHlwaWNhbGx5IGNhbGxlZCBwcmlvciB0byB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2RyYXdcIn19e3svY3Jvc3NMaW5rfX0uXHJcblx0ICogQG1ldGhvZCB1cGRhdGVDb250ZXh0XHJcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIHRvIHVwZGF0ZS5cclxuXHQgKiovXHJcblx0cC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHR2YXIgbz10aGlzLCBtYXNrPW8ubWFzaywgbXR4PSBvLl9wcm9wcy5tYXRyaXg7XHJcblx0XHRcclxuXHRcdGlmIChtYXNrICYmIG1hc2suZ3JhcGhpY3MgJiYgIW1hc2suZ3JhcGhpY3MuaXNFbXB0eSgpKSB7XHJcblx0XHRcdG1hc2suZ2V0TWF0cml4KG10eCk7XHJcblx0XHRcdGN0eC50cmFuc2Zvcm0obXR4LmEsICBtdHguYiwgbXR4LmMsIG10eC5kLCBtdHgudHgsIG10eC50eSk7XHJcblx0XHRcdFxyXG5cdFx0XHRtYXNrLmdyYXBoaWNzLmRyYXdBc1BhdGgoY3R4KTtcclxuXHRcdFx0Y3R4LmNsaXAoKTtcclxuXHRcdFx0XHJcblx0XHRcdG10eC5pbnZlcnQoKTtcclxuXHRcdFx0Y3R4LnRyYW5zZm9ybShtdHguYSwgIG10eC5iLCBtdHguYywgbXR4LmQsIG10eC50eCwgbXR4LnR5KTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0dGhpcy5nZXRNYXRyaXgobXR4KTtcclxuXHRcdHZhciB0eCA9IG10eC50eCwgdHkgPSBtdHgudHk7XHJcblx0XHRpZiAoRGlzcGxheU9iamVjdC5fc25hcFRvUGl4ZWxFbmFibGVkICYmIG8uc25hcFRvUGl4ZWwpIHtcclxuXHRcdFx0dHggPSB0eCArICh0eCA8IDAgPyAtMC41IDogMC41KSB8IDA7XHJcblx0XHRcdHR5ID0gdHkgKyAodHkgPCAwID8gLTAuNSA6IDAuNSkgfCAwO1xyXG5cdFx0fVxyXG5cdFx0Y3R4LnRyYW5zZm9ybShtdHguYSwgIG10eC5iLCBtdHguYywgbXR4LmQsIHR4LCB0eSk7XHJcblx0XHRjdHguZ2xvYmFsQWxwaGEgKj0gby5hbHBoYTtcclxuXHRcdGlmIChvLmNvbXBvc2l0ZU9wZXJhdGlvbikgeyBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gby5jb21wb3NpdGVPcGVyYXRpb247IH1cclxuXHRcdGlmIChvLnNoYWRvdykgeyB0aGlzLl9hcHBseVNoYWRvdyhjdHgsIG8uc2hhZG93KTsgfVxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIERyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRvIGEgbmV3IGNhbnZhcywgd2hpY2ggaXMgdGhlbiB1c2VkIGZvciBzdWJzZXF1ZW50IGRyYXdzLiBGb3IgY29tcGxleCBjb250ZW50XHJcblx0ICogdGhhdCBkb2VzIG5vdCBjaGFuZ2UgZnJlcXVlbnRseSAoZXguIGEgQ29udGFpbmVyIHdpdGggbWFueSBjaGlsZHJlbiB0aGF0IGRvIG5vdCBtb3ZlLCBvciBhIGNvbXBsZXggdmVjdG9yIFNoYXBlKSxcclxuXHQgKiB0aGlzIGNhbiBwcm92aWRlIGZvciBtdWNoIGZhc3RlciByZW5kZXJpbmcgYmVjYXVzZSB0aGUgY29udGVudCBkb2VzIG5vdCBuZWVkIHRvIGJlIHJlLXJlbmRlcmVkIGVhY2ggdGljay4gVGhlXHJcblx0ICogY2FjaGVkIGRpc3BsYXkgb2JqZWN0IGNhbiBiZSBtb3ZlZCwgcm90YXRlZCwgZmFkZWQsIGV0YyBmcmVlbHksIGhvd2V2ZXIgaWYgaXRzIGNvbnRlbnQgY2hhbmdlcywgeW91IG11c3RcclxuXHQgKiBtYW51YWxseSB1cGRhdGUgdGhlIGNhY2hlIGJ5IGNhbGxpbmcgPGNvZGU+dXBkYXRlQ2FjaGUoKTwvY29kZT4gb3IgPGNvZGU+Y2FjaGUoKTwvY29kZT4gYWdhaW4uIFlvdSBtdXN0IHNwZWNpZnlcclxuXHQgKiB0aGUgY2FjaGUgYXJlYSB2aWEgdGhlIHgsIHksIHcsIGFuZCBoIHBhcmFtZXRlcnMuIFRoaXMgZGVmaW5lcyB0aGUgcmVjdGFuZ2xlIHRoYXQgd2lsbCBiZSByZW5kZXJlZCBhbmQgY2FjaGVkXHJcblx0ICogdXNpbmcgdGhpcyBkaXNwbGF5IG9iamVjdCdzIGNvb3JkaW5hdGVzLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqIEZvciBleGFtcGxlIGlmIHlvdSBkZWZpbmVkIGEgU2hhcGUgdGhhdCBkcmV3IGEgY2lyY2xlIGF0IDAsIDAgd2l0aCBhIHJhZGl1cyBvZiAyNTpcclxuXHQgKlxyXG5cdCAqICAgICAgdmFyIHNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XHJcblx0ICogICAgICBzaGFwZS5ncmFwaGljcy5iZWdpbkZpbGwoXCIjZmYwMDAwXCIpLmRyYXdDaXJjbGUoMCwgMCwgMjUpO1xyXG5cdCAqICAgICAgbXlTaGFwZS5jYWNoZSgtMjUsIC0yNSwgNTAsIDUwKTtcclxuXHQgKlxyXG5cdCAqIE5vdGUgdGhhdCBmaWx0ZXJzIG5lZWQgdG8gYmUgZGVmaW5lZCA8ZW0+YmVmb3JlPC9lbT4gdGhlIGNhY2hlIGlzIGFwcGxpZWQuIENoZWNrIG91dCB0aGUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319XHJcblx0ICogY2xhc3MgZm9yIG1vcmUgaW5mb3JtYXRpb24uIFNvbWUgZmlsdGVycyAoZXguIEJsdXJGaWx0ZXIpIHdpbGwgbm90IHdvcmsgYXMgZXhwZWN0ZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgc2NhbGUgcGFyYW0uXHJcblx0ICogXHJcblx0ICogVXN1YWxseSwgdGhlIHJlc3VsdGluZyBjYWNoZUNhbnZhcyB3aWxsIGhhdmUgdGhlIGRpbWVuc2lvbnMgd2lkdGgqc2NhbGUgYnkgaGVpZ2h0KnNjYWxlLCBob3dldmVyIHNvbWUgZmlsdGVycyAoZXguIEJsdXJGaWx0ZXIpXHJcblx0ICogd2lsbCBhZGQgcGFkZGluZyB0byB0aGUgY2FudmFzIGRpbWVuc2lvbnMuXHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGNhY2hlXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggY29vcmRpbmF0ZSBvcmlnaW4gZm9yIHRoZSBjYWNoZSByZWdpb24uXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgY29vcmRpbmF0ZSBvcmlnaW4gZm9yIHRoZSBjYWNoZSByZWdpb24uXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgY2FjaGUgcmVnaW9uLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgY2FjaGUgcmVnaW9uLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGU9MV0gVGhlIHNjYWxlIGF0IHdoaWNoIHRoZSBjYWNoZSB3aWxsIGJlIGNyZWF0ZWQuIEZvciBleGFtcGxlLCBpZiB5b3UgY2FjaGUgYSB2ZWN0b3Igc2hhcGUgdXNpbmdcclxuXHQgKiBcdG15U2hhcGUuY2FjaGUoMCwwLDEwMCwxMDAsMikgdGhlbiB0aGUgcmVzdWx0aW5nIGNhY2hlQ2FudmFzIHdpbGwgYmUgMjAweDIwMCBweC4gVGhpcyBsZXRzIHlvdSBzY2FsZSBhbmQgcm90YXRlXHJcblx0ICogXHRjYWNoZWQgZWxlbWVudHMgd2l0aCBncmVhdGVyIGZpZGVsaXR5LiBEZWZhdWx0IGlzIDEuXHJcblx0ICoqL1xyXG5cdHAuY2FjaGUgPSBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzY2FsZSkge1xyXG5cdFx0Ly8gZHJhdyB0byBjYW52YXMuXHJcblx0XHRzY2FsZSA9IHNjYWxlfHwxO1xyXG5cdFx0aWYgKCF0aGlzLmNhY2hlQ2FudmFzKSB7IHRoaXMuY2FjaGVDYW52YXMgPSBjcmVhdGVqcy5jcmVhdGVDYW52YXM/Y3JlYXRlanMuY3JlYXRlQ2FudmFzKCk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTsgfVxyXG5cdFx0dGhpcy5fY2FjaGVXaWR0aCA9IHdpZHRoO1xyXG5cdFx0dGhpcy5fY2FjaGVIZWlnaHQgPSBoZWlnaHQ7XHJcblx0XHR0aGlzLl9jYWNoZU9mZnNldFggPSB4O1xyXG5cdFx0dGhpcy5fY2FjaGVPZmZzZXRZID0geTtcclxuXHRcdHRoaXMuX2NhY2hlU2NhbGUgPSBzY2FsZTtcclxuXHRcdHRoaXMudXBkYXRlQ2FjaGUoKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZWRyYXdzIHRoZSBkaXNwbGF5IG9iamVjdCB0byBpdHMgY2FjaGUuIENhbGxpbmcgdXBkYXRlQ2FjaGUgd2l0aG91dCBhbiBhY3RpdmUgY2FjaGUgd2lsbCB0aHJvdyBhbiBlcnJvci5cclxuXHQgKiBJZiBjb21wb3NpdGVPcGVyYXRpb24gaXMgbnVsbCB0aGUgY3VycmVudCBjYWNoZSB3aWxsIGJlIGNsZWFyZWQgcHJpb3IgdG8gZHJhd2luZy4gT3RoZXJ3aXNlIHRoZSBkaXNwbGF5IG9iamVjdFxyXG5cdCAqIHdpbGwgYmUgZHJhd24gb3ZlciB0aGUgZXhpc3RpbmcgY2FjaGUgdXNpbmcgdGhlIHNwZWNpZmllZCBjb21wb3NpdGVPcGVyYXRpb24uXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICogQ2xlYXIgdGhlIGN1cnJlbnQgZ3JhcGhpY3Mgb2YgYSBjYWNoZWQgc2hhcGUsIGRyYXcgc29tZSBuZXcgaW5zdHJ1Y3Rpb25zLCBhbmQgdGhlbiB1cGRhdGUgdGhlIGNhY2hlLiBUaGUgbmV3IGxpbmVcclxuXHQgKiB3aWxsIGJlIGRyYXduIG9uIHRvcCBvZiB0aGUgb2xkIG9uZS5cclxuXHQgKlxyXG5cdCAqICAgICAgLy8gTm90IHNob3duOiBDcmVhdGluZyB0aGUgc2hhcGUsIGFuZCBjYWNoaW5nIGl0LlxyXG5cdCAqICAgICAgc2hhcGVJbnN0YW5jZS5jbGVhcigpO1xyXG5cdCAqICAgICAgc2hhcGVJbnN0YW5jZS5zZXRTdHJva2VTdHlsZSgzKS5iZWdpblN0cm9rZShcIiNmZjAwMDBcIikubW92ZVRvKDEwMCwgMTAwKS5saW5lVG8oMjAwLDIwMCk7XHJcblx0ICogICAgICBzaGFwZUluc3RhbmNlLnVwZGF0ZUNhY2hlKCk7XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIHVwZGF0ZUNhY2hlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvc2l0ZU9wZXJhdGlvbiBUaGUgY29tcG9zaXRlT3BlcmF0aW9uIHRvIHVzZSwgb3IgbnVsbCB0byBjbGVhciB0aGUgY2FjaGUgYW5kIHJlZHJhdyBpdC5cclxuXHQgKiA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjY29tcG9zaXRpbmdcIj5cclxuXHQgKiB3aGF0d2cgc3BlYyBvbiBjb21wb3NpdGluZzwvYT4uXHJcblx0ICoqL1xyXG5cdHAudXBkYXRlQ2FjaGUgPSBmdW5jdGlvbihjb21wb3NpdGVPcGVyYXRpb24pIHtcclxuXHRcdHZhciBjYWNoZUNhbnZhcyA9IHRoaXMuY2FjaGVDYW52YXM7XHJcblx0XHRpZiAoIWNhY2hlQ2FudmFzKSB7IHRocm93IFwiY2FjaGUoKSBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgdXBkYXRlQ2FjaGUoKVwiOyB9XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLl9jYWNoZVNjYWxlLCBvZmZYID0gdGhpcy5fY2FjaGVPZmZzZXRYKnNjYWxlLCBvZmZZID0gdGhpcy5fY2FjaGVPZmZzZXRZKnNjYWxlO1xyXG5cdFx0dmFyIHcgPSB0aGlzLl9jYWNoZVdpZHRoLCBoID0gdGhpcy5fY2FjaGVIZWlnaHQsIGN0eCA9IGNhY2hlQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHRcdFxyXG5cdFx0dmFyIGZCb3VuZHMgPSB0aGlzLl9nZXRGaWx0ZXJCb3VuZHMoKTtcclxuXHRcdG9mZlggKz0gKHRoaXMuX2ZpbHRlck9mZnNldFggPSBmQm91bmRzLngpO1xyXG5cdFx0b2ZmWSArPSAodGhpcy5fZmlsdGVyT2Zmc2V0WSA9IGZCb3VuZHMueSk7XHJcblx0XHRcclxuXHRcdHcgPSBNYXRoLmNlaWwodypzY2FsZSkgKyBmQm91bmRzLndpZHRoO1xyXG5cdFx0aCA9IE1hdGguY2VpbChoKnNjYWxlKSArIGZCb3VuZHMuaGVpZ2h0O1xyXG5cdFx0aWYgKHcgIT0gY2FjaGVDYW52YXMud2lkdGggfHwgaCAhPSBjYWNoZUNhbnZhcy5oZWlnaHQpIHtcclxuXHRcdFx0Ly8gVE9ETzogaXQgd291bGQgYmUgbmljZSB0byBwcmVzZXJ2ZSB0aGUgY29udGVudCBpZiB0aGVyZSBpcyBhIGNvbXBvc2l0ZU9wZXJhdGlvbi5cclxuXHRcdFx0Y2FjaGVDYW52YXMud2lkdGggPSB3O1xyXG5cdFx0XHRjYWNoZUNhbnZhcy5oZWlnaHQgPSBoO1xyXG5cdFx0fSBlbHNlIGlmICghY29tcG9zaXRlT3BlcmF0aW9uKSB7XHJcblx0XHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgdysxLCBoKzEpO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRjdHguc2F2ZSgpO1xyXG5cdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGNvbXBvc2l0ZU9wZXJhdGlvbjtcclxuXHRcdGN0eC5zZXRUcmFuc2Zvcm0oc2NhbGUsIDAsIDAsIHNjYWxlLCAtb2ZmWCwgLW9mZlkpO1xyXG5cdFx0dGhpcy5kcmF3KGN0eCwgdHJ1ZSk7XHJcblx0XHQvLyBUT0RPOiBmaWx0ZXJzIGFuZCBjYWNoZSBzY2FsZSBkb24ndCBwbGF5IHdlbGwgdG9nZXRoZXIgYXQgcHJlc2VudC5cclxuXHRcdHRoaXMuX2FwcGx5RmlsdGVycygpO1xyXG5cdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHRcdHRoaXMuY2FjaGVJRCA9IERpc3BsYXlPYmplY3QuX25leHRDYWNoZUlEKys7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQ2xlYXJzIHRoZSBjdXJyZW50IGNhY2hlLiBTZWUge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9jYWNoZVwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuXHQgKiBAbWV0aG9kIHVuY2FjaGVcclxuXHQgKiovXHJcblx0cC51bmNhY2hlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLl9jYWNoZURhdGFVUkwgPSB0aGlzLmNhY2hlQ2FudmFzID0gbnVsbDtcclxuXHRcdHRoaXMuY2FjaGVJRCA9IHRoaXMuX2NhY2hlT2Zmc2V0WCA9IHRoaXMuX2NhY2hlT2Zmc2V0WSA9IHRoaXMuX2ZpbHRlck9mZnNldFggPSB0aGlzLl9maWx0ZXJPZmZzZXRZID0gMDtcclxuXHRcdHRoaXMuX2NhY2hlU2NhbGUgPSAxO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIGRhdGEgVVJMIGZvciB0aGUgY2FjaGUsIG9yIG51bGwgaWYgdGhpcyBkaXNwbGF5IG9iamVjdCBpcyBub3QgY2FjaGVkLlxyXG5cdCAqIFVzZXMgY2FjaGVJRCB0byBlbnN1cmUgYSBuZXcgZGF0YSBVUkwgaXMgbm90IGdlbmVyYXRlZCBpZiB0aGUgY2FjaGUgaGFzIG5vdCBjaGFuZ2VkLlxyXG5cdCAqIEBtZXRob2QgZ2V0Q2FjaGVEYXRhVVJMXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgaW1hZ2UgZGF0YSB1cmwgZm9yIHRoZSBjYWNoZS5cclxuXHQgKiovXHJcblx0cC5nZXRDYWNoZURhdGFVUkwgPSBmdW5jdGlvbigpIHtcclxuXHRcdGlmICghdGhpcy5jYWNoZUNhbnZhcykgeyByZXR1cm4gbnVsbDsgfVxyXG5cdFx0aWYgKHRoaXMuY2FjaGVJRCAhPSB0aGlzLl9jYWNoZURhdGFVUkxJRCkgeyB0aGlzLl9jYWNoZURhdGFVUkwgPSB0aGlzLmNhY2hlQ2FudmFzLnRvRGF0YVVSTCgpOyB9XHJcblx0XHRyZXR1cm4gdGhpcy5fY2FjaGVEYXRhVVJMO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRyYW5zZm9ybXMgdGhlIHNwZWNpZmllZCB4IGFuZCB5IHBvc2l0aW9uIGZyb20gdGhlIGNvb3JkaW5hdGUgc3BhY2Ugb2YgdGhlIGRpc3BsYXkgb2JqZWN0XHJcblx0ICogdG8gdGhlIGdsb2JhbCAoc3RhZ2UpIGNvb3JkaW5hdGUgc3BhY2UuIEZvciBleGFtcGxlLCB0aGlzIGNvdWxkIGJlIHVzZWQgdG8gcG9zaXRpb24gYW4gSFRNTCBsYWJlbFxyXG5cdCAqIG92ZXIgYSBzcGVjaWZpYyBwb2ludCBvbiBhIG5lc3RlZCBkaXNwbGF5IG9iamVjdC4gUmV0dXJucyBhIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzXHJcblx0ICogY29ycmVsYXRpbmcgdG8gdGhlIHRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzIG9uIHRoZSBzdGFnZS5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC54ID0gMzAwO1xyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC55ID0gMjAwO1xyXG5cdCAqICAgICAgc3RhZ2UuYWRkQ2hpbGQoZGlzcGxheU9iamVjdCk7XHJcblx0ICogICAgICB2YXIgcG9pbnQgPSBteURpc3BsYXlPYmplY3QubG9jYWxUb0dsb2JhbCgxMDAsIDEwMCk7XHJcblx0ICogICAgICAvLyBSZXN1bHRzIGluIHg9NDAwLCB5PTMwMFxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBsb2NhbFRvR2xvYmFsXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gaW4gdGhlIHNvdXJjZSBkaXNwbGF5IG9iamVjdCB0byB0cmFuc2Zvcm0uXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSBkaXNwbGF5IG9iamVjdCB0byB0cmFuc2Zvcm0uXHJcblx0ICogQHBhcmFtIHtQb2ludCB8IE9iamVjdH0gW3B0XSBBbiBvYmplY3QgdG8gY29weSB0aGUgcmVzdWx0IGludG8uIElmIG9taXR0ZWQgYSBuZXcgUG9pbnQgb2JqZWN0IHdpdGggeC95IHByb3BlcnRpZXMgd2lsbCBiZSByZXR1cm5lZC4gXHJcblx0ICogQHJldHVybiB7UG9pbnR9IEEgUG9pbnQgaW5zdGFuY2Ugd2l0aCB4IGFuZCB5IHByb3BlcnRpZXMgY29ycmVsYXRpbmcgdG8gdGhlIHRyYW5zZm9ybWVkIGNvb3JkaW5hdGVzXHJcblx0ICogb24gdGhlIHN0YWdlLlxyXG5cdCAqKi9cclxuXHRwLmxvY2FsVG9HbG9iYWwgPSBmdW5jdGlvbih4LCB5LCBwdCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29uY2F0ZW5hdGVkTWF0cml4KHRoaXMuX3Byb3BzLm1hdHJpeCkudHJhbnNmb3JtUG9pbnQoeCx5LCBwdHx8bmV3IGNyZWF0ZWpzLlBvaW50KCkpO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRyYW5zZm9ybXMgdGhlIHNwZWNpZmllZCB4IGFuZCB5IHBvc2l0aW9uIGZyb20gdGhlIGdsb2JhbCAoc3RhZ2UpIGNvb3JkaW5hdGUgc3BhY2UgdG8gdGhlXHJcblx0ICogY29vcmRpbmF0ZSBzcGFjZSBvZiB0aGUgZGlzcGxheSBvYmplY3QuIEZvciBleGFtcGxlLCB0aGlzIGNvdWxkIGJlIHVzZWQgdG8gZGV0ZXJtaW5lXHJcblx0ICogdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb24gd2l0aGluIHRoZSBkaXNwbGF5IG9iamVjdC4gUmV0dXJucyBhIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzXHJcblx0ICogY29ycmVsYXRpbmcgdG8gdGhlIHRyYW5zZm9ybWVkIHBvc2l0aW9uIGluIHRoZSBkaXNwbGF5IG9iamVjdCdzIGNvb3JkaW5hdGUgc3BhY2UuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QueCA9IDMwMDtcclxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QueSA9IDIwMDtcclxuXHQgKiAgICAgIHN0YWdlLmFkZENoaWxkKGRpc3BsYXlPYmplY3QpO1xyXG5cdCAqICAgICAgdmFyIHBvaW50ID0gbXlEaXNwbGF5T2JqZWN0Lmdsb2JhbFRvTG9jYWwoMTAwLCAxMDApO1xyXG5cdCAqICAgICAgLy8gUmVzdWx0cyBpbiB4PS0yMDAsIHk9LTEwMFxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBnbG9iYWxUb0xvY2FsXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gb24gdGhlIHN0YWdlIHRvIHRyYW5zZm9ybS5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiBvbiB0aGUgc3RhZ2UgdG8gdHJhbnNmb3JtLlxyXG5cdCAqIEBwYXJhbSB7UG9pbnQgfCBPYmplY3R9IFtwdF0gQW4gb2JqZWN0IHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvLiBJZiBvbWl0dGVkIGEgbmV3IFBvaW50IG9iamVjdCB3aXRoIHgveSBwcm9wZXJ0aWVzIHdpbGwgYmUgcmV0dXJuZWQuIFxyXG5cdCAqIEByZXR1cm4ge1BvaW50fSBBIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzIGNvcnJlbGF0aW5nIHRvIHRoZSB0cmFuc2Zvcm1lZCBwb3NpdGlvbiBpbiB0aGVcclxuXHQgKiBkaXNwbGF5IG9iamVjdCdzIGNvb3JkaW5hdGUgc3BhY2UuXHJcblx0ICoqL1xyXG5cdHAuZ2xvYmFsVG9Mb2NhbCA9IGZ1bmN0aW9uKHgsIHksIHB0KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRDb25jYXRlbmF0ZWRNYXRyaXgodGhpcy5fcHJvcHMubWF0cml4KS5pbnZlcnQoKS50cmFuc2Zvcm1Qb2ludCh4LHksIHB0fHxuZXcgY3JlYXRlanMuUG9pbnQoKSk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogVHJhbnNmb3JtcyB0aGUgc3BlY2lmaWVkIHggYW5kIHkgcG9zaXRpb24gZnJvbSB0aGUgY29vcmRpbmF0ZSBzcGFjZSBvZiB0aGlzIGRpc3BsYXkgb2JqZWN0IHRvIHRoZSBjb29yZGluYXRlXHJcblx0ICogc3BhY2Ugb2YgdGhlIHRhcmdldCBkaXNwbGF5IG9iamVjdC4gUmV0dXJucyBhIFBvaW50IGluc3RhbmNlIHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzIGNvcnJlbGF0aW5nIHRvIHRoZVxyXG5cdCAqIHRyYW5zZm9ybWVkIHBvc2l0aW9uIGluIHRoZSB0YXJnZXQncyBjb29yZGluYXRlIHNwYWNlLiBFZmZlY3RpdmVseSB0aGUgc2FtZSBhcyB1c2luZyB0aGUgZm9sbG93aW5nIGNvZGUgd2l0aFxyXG5cdCAqIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbG9jYWxUb0dsb2JhbFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9nbG9iYWxUb0xvY2FsXCJ9fXt7L2Nyb3NzTGlua319LlxyXG5cdCAqXHJcblx0ICogICAgICB2YXIgcHQgPSB0aGlzLmxvY2FsVG9HbG9iYWwoeCwgeSk7XHJcblx0ICogICAgICBwdCA9IHRhcmdldC5nbG9iYWxUb0xvY2FsKHB0LngsIHB0LnkpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBsb2NhbFRvTG9jYWxcclxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvbiBpbiB0aGUgc291cmNlIGRpc3BsYXkgb2JqZWN0IHRvIHRyYW5zZm9ybS5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBwb3NpdGlvbiBvbiB0aGUgc291cmNlIGRpc3BsYXkgb2JqZWN0IHRvIHRyYW5zZm9ybS5cclxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IGRpc3BsYXkgb2JqZWN0IHRvIHdoaWNoIHRoZSBjb29yZGluYXRlcyB3aWxsIGJlIHRyYW5zZm9ybWVkLlxyXG5cdCAqIEBwYXJhbSB7UG9pbnQgfCBPYmplY3R9IFtwdF0gQW4gb2JqZWN0IHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvLiBJZiBvbWl0dGVkIGEgbmV3IFBvaW50IG9iamVjdCB3aXRoIHgveSBwcm9wZXJ0aWVzIHdpbGwgYmUgcmV0dXJuZWQuIFxyXG5cdCAqIEByZXR1cm4ge1BvaW50fSBSZXR1cm5zIGEgUG9pbnQgaW5zdGFuY2Ugd2l0aCB4IGFuZCB5IHByb3BlcnRpZXMgY29ycmVsYXRpbmcgdG8gdGhlIHRyYW5zZm9ybWVkIHBvc2l0aW9uXHJcblx0ICogaW4gdGhlIHRhcmdldCdzIGNvb3JkaW5hdGUgc3BhY2UuXHJcblx0ICoqL1xyXG5cdHAubG9jYWxUb0xvY2FsID0gZnVuY3Rpb24oeCwgeSwgdGFyZ2V0LCBwdCkge1xyXG5cdFx0cHQgPSB0aGlzLmxvY2FsVG9HbG9iYWwoeCwgeSwgcHQpO1xyXG5cdFx0cmV0dXJuIHRhcmdldC5nbG9iYWxUb0xvY2FsKHB0LngsIHB0LnksIHB0KTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBTaG9ydGN1dCBtZXRob2QgdG8gcXVpY2tseSBzZXQgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0aWVzIG9uIHRoZSBkaXNwbGF5IG9iamVjdC4gQWxsIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLlxyXG5cdCAqIE9taXR0ZWQgcGFyYW1ldGVycyB3aWxsIGhhdmUgdGhlIGRlZmF1bHQgdmFsdWUgc2V0LlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnNldFRyYW5zZm9ybSgxMDAsIDEwMCwgMiwgMik7XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIHNldFRyYW5zZm9ybVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSBUaGUgaG9yaXpvbnRhbCB0cmFuc2xhdGlvbiAoeCBwb3NpdGlvbikgaW4gcGl4ZWxzXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIFRoZSB2ZXJ0aWNhbCB0cmFuc2xhdGlvbiAoeSBwb3NpdGlvbikgaW4gcGl4ZWxzXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZVg9MV0gVGhlIGhvcml6b250YWwgc2NhbGUsIGFzIGEgcGVyY2VudGFnZSBvZiAxXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZVk9MV0gdGhlIHZlcnRpY2FsIHNjYWxlLCBhcyBhIHBlcmNlbnRhZ2Ugb2YgMVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcm90YXRpb249MF0gVGhlIHJvdGF0aW9uLCBpbiBkZWdyZWVzXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtza2V3WD0wXSBUaGUgaG9yaXpvbnRhbCBza2V3IGZhY3RvclxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc2tld1k9MF0gVGhlIHZlcnRpY2FsIHNrZXcgZmFjdG9yXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtyZWdYPTBdIFRoZSBob3Jpem9udGFsIHJlZ2lzdHJhdGlvbiBwb2ludCBpbiBwaXhlbHNcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3JlZ1k9MF0gVGhlIHZlcnRpY2FsIHJlZ2lzdHJhdGlvbiBwb2ludCBpbiBwaXhlbHNcclxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBSZXR1cm5zIHRoaXMgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgY2hhaW5pbmcgY29tbWFuZHMuXHJcblx0ICogQGNoYWluYWJsZVxyXG5cdCovXHJcblx0cC5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbih4LCB5LCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHNrZXdYLCBza2V3WSwgcmVnWCwgcmVnWSkge1xyXG5cdFx0dGhpcy54ID0geCB8fCAwO1xyXG5cdFx0dGhpcy55ID0geSB8fCAwO1xyXG5cdFx0dGhpcy5zY2FsZVggPSBzY2FsZVggPT0gbnVsbCA/IDEgOiBzY2FsZVg7XHJcblx0XHR0aGlzLnNjYWxlWSA9IHNjYWxlWSA9PSBudWxsID8gMSA6IHNjYWxlWTtcclxuXHRcdHRoaXMucm90YXRpb24gPSByb3RhdGlvbiB8fCAwO1xyXG5cdFx0dGhpcy5za2V3WCA9IHNrZXdYIHx8IDA7XHJcblx0XHR0aGlzLnNrZXdZID0gc2tld1kgfHwgMDtcclxuXHRcdHRoaXMucmVnWCA9IHJlZ1ggfHwgMDtcclxuXHRcdHRoaXMucmVnWSA9IHJlZ1kgfHwgMDtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIG1hdHJpeCBiYXNlZCBvbiB0aGlzIG9iamVjdCdzIGN1cnJlbnQgdHJhbnNmb3JtLlxyXG5cdCAqIEBtZXRob2QgZ2V0TWF0cml4XHJcblx0ICogQHBhcmFtIHtNYXRyaXgyRH0gbWF0cml4IE9wdGlvbmFsLiBBIE1hdHJpeDJEIG9iamVjdCB0byBwb3B1bGF0ZSB3aXRoIHRoZSBjYWxjdWxhdGVkIHZhbHVlcy4gSWYgbnVsbCwgYSBuZXdcclxuXHQgKiBNYXRyaXggb2JqZWN0IGlzIHJldHVybmVkLlxyXG5cdCAqIEByZXR1cm4ge01hdHJpeDJEfSBBIG1hdHJpeCByZXByZXNlbnRpbmcgdGhpcyBkaXNwbGF5IG9iamVjdCdzIHRyYW5zZm9ybS5cclxuXHQgKiovXHJcblx0cC5nZXRNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcclxuXHRcdHZhciBvID0gdGhpcywgbXR4ID0gbWF0cml4JiZtYXRyaXguaWRlbnRpdHkoKSB8fCBuZXcgY3JlYXRlanMuTWF0cml4MkQoKTtcclxuXHRcdHJldHVybiBvLnRyYW5zZm9ybU1hdHJpeCA/ICBtdHguY29weShvLnRyYW5zZm9ybU1hdHJpeCkgOiBtdHguYXBwZW5kVHJhbnNmb3JtKG8ueCwgby55LCBvLnNjYWxlWCwgby5zY2FsZVksIG8ucm90YXRpb24sIG8uc2tld1gsIG8uc2tld1ksIG8ucmVnWCwgby5yZWdZKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlcyBhIE1hdHJpeDJEIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGNvbWJpbmVkIHRyYW5zZm9ybSBvZiB0aGUgZGlzcGxheSBvYmplY3QgYW5kIGFsbCBvZiBpdHNcclxuXHQgKiBwYXJlbnQgQ29udGFpbmVycyB1cCB0byB0aGUgaGlnaGVzdCBsZXZlbCBhbmNlc3RvciAodXN1YWxseSB0aGUge3sjY3Jvc3NMaW5rIFwiU3RhZ2VcIn19e3svY3Jvc3NMaW5rfX0pLiBUaGlzIGNhblxyXG5cdCAqIGJlIHVzZWQgdG8gdHJhbnNmb3JtIHBvc2l0aW9ucyBiZXR3ZWVuIGNvb3JkaW5hdGUgc3BhY2VzLCBzdWNoIGFzIHdpdGgge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9sb2NhbFRvR2xvYmFsXCJ9fXt7L2Nyb3NzTGlua319XHJcblx0ICogYW5kIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvZ2xvYmFsVG9Mb2NhbFwifX17ey9jcm9zc0xpbmt9fS5cclxuXHQgKiBAbWV0aG9kIGdldENvbmNhdGVuYXRlZE1hdHJpeFxyXG5cdCAqIEBwYXJhbSB7TWF0cml4MkR9IFttYXRyaXhdIEEge3sjY3Jvc3NMaW5rIFwiTWF0cml4MkRcIn19e3svY3Jvc3NMaW5rfX0gb2JqZWN0IHRvIHBvcHVsYXRlIHdpdGggdGhlIGNhbGN1bGF0ZWQgdmFsdWVzLlxyXG5cdCAqIElmIG51bGwsIGEgbmV3IE1hdHJpeDJEIG9iamVjdCBpcyByZXR1cm5lZC5cclxuXHQgKiBAcmV0dXJuIHtNYXRyaXgyRH0gVGhlIGNvbWJpbmVkIG1hdHJpeC5cclxuXHQgKiovXHJcblx0cC5nZXRDb25jYXRlbmF0ZWRNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcclxuXHRcdHZhciBvID0gdGhpcywgbXR4ID0gdGhpcy5nZXRNYXRyaXgobWF0cml4KTtcclxuXHRcdHdoaWxlIChvID0gby5wYXJlbnQpIHtcclxuXHRcdFx0bXR4LnByZXBlbmRNYXRyaXgoby5nZXRNYXRyaXgoby5fcHJvcHMubWF0cml4KSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbXR4O1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGVzIGEgRGlzcGxheVByb3BzIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGNvbWJpbmVkIGRpc3BsYXkgcHJvcGVydGllcyBvZiB0aGUgIG9iamVjdCBhbmQgYWxsIG9mIGl0c1xyXG5cdCAqIHBhcmVudCBDb250YWluZXJzIHVwIHRvIHRoZSBoaWdoZXN0IGxldmVsIGFuY2VzdG9yICh1c3VhbGx5IHRoZSB7eyNjcm9zc0xpbmsgXCJTdGFnZVwifX17ey9jcm9zc0xpbmt9fSkuXHJcblx0ICogQG1ldGhvZCBnZXRDb25jYXRlbmF0ZWREaXNwbGF5UHJvcHNcclxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlQcm9wc30gW3Byb3BzXSBBIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlQcm9wc1wifX17ey9jcm9zc0xpbmt9fSBvYmplY3QgdG8gcG9wdWxhdGUgd2l0aCB0aGUgY2FsY3VsYXRlZCB2YWx1ZXMuXHJcblx0ICogSWYgbnVsbCwgYSBuZXcgRGlzcGxheVByb3BzIG9iamVjdCBpcyByZXR1cm5lZC5cclxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5UHJvcHN9IFRoZSBjb21iaW5lZCBkaXNwbGF5IHByb3BlcnRpZXMuXHJcblx0ICoqL1xyXG5cdHAuZ2V0Q29uY2F0ZW5hdGVkRGlzcGxheVByb3BzID0gZnVuY3Rpb24ocHJvcHMpIHtcclxuXHRcdHByb3BzID0gcHJvcHMgPyBwcm9wcy5pZGVudGl0eSgpIDogbmV3IGNyZWF0ZWpzLkRpc3BsYXlQcm9wcygpO1xyXG5cdFx0dmFyIG8gPSB0aGlzLCBtdHggPSBvLmdldE1hdHJpeChwcm9wcy5tYXRyaXgpOyBcclxuXHRcdGRvIHtcclxuXHRcdFx0cHJvcHMucHJlcGVuZChvLnZpc2libGUsIG8uYWxwaGEsIG8uc2hhZG93LCBvLmNvbXBvc2l0ZU9wZXJhdGlvbik7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyB3ZSBkbyB0aGlzIHRvIGF2b2lkIHByb2JsZW1zIHdpdGggdGhlIG1hdHJpeCBiZWluZyB1c2VkIGZvciBib3RoIG9wZXJhdGlvbnMgd2hlbiBvLl9wcm9wcy5tYXRyaXggaXMgcGFzc2VkIGluIGFzIHRoZSBwcm9wcyBwYXJhbS5cclxuXHRcdFx0Ly8gdGhpcyBjb3VsZCBiZSBzaW1wbGlmaWVkIChpZS4ganVzdCBkb25lIGFzIHBhcnQgb2YgdGhlIHByZXBlbmQgYWJvdmUpIGlmIHdlIHN3aXRjaGVkIHRvIHVzaW5nIGEgcG9vbC5cclxuXHRcdFx0aWYgKG8gIT0gdGhpcykgeyBtdHgucHJlcGVuZE1hdHJpeChvLmdldE1hdHJpeChvLl9wcm9wcy5tYXRyaXgpKTsgfVxyXG5cdFx0fSB3aGlsZSAobyA9IG8ucGFyZW50KTtcclxuXHRcdHJldHVybiBwcm9wcztcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBUZXN0cyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCBpbnRlcnNlY3RzIHRoZSBzcGVjaWZpZWQgcG9pbnQgaW4gbG9jYWwgY29vcmRpbmF0ZXMgKGllLiBkcmF3cyBhIHBpeGVsIHdpdGggYWxwaGEgPiAwIGF0XHJcblx0ICogdGhlIHNwZWNpZmllZCBwb3NpdGlvbikuIFRoaXMgaWdub3JlcyB0aGUgYWxwaGEsIHNoYWRvdywgaGl0QXJlYSwgbWFzaywgYW5kIGNvbXBvc2l0ZU9wZXJhdGlvbiBvZiB0aGUgZGlzcGxheSBvYmplY3QuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIHN0YWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJzdGFnZW1vdXNlZG93blwiLCBoYW5kbGVNb3VzZURvd24pO1xyXG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50KSB7XHJcblx0ICogICAgICAgICAgdmFyIGhpdCA9IG15U2hhcGUuaGl0VGVzdChldmVudC5zdGFnZVgsIGV2ZW50LnN0YWdlWSk7XHJcblx0ICogICAgICB9XHJcblx0ICpcclxuXHQgKiBQbGVhc2Ugbm90ZSB0aGF0IHNoYXBlLXRvLXNoYXBlIGNvbGxpc2lvbiBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSBFYXNlbEpTLlxyXG5cdCAqIEBtZXRob2QgaGl0VGVzdFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIHRvIGNoZWNrIGluIHRoZSBkaXNwbGF5IG9iamVjdCdzIGxvY2FsIGNvb3JkaW5hdGVzLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uIHRvIGNoZWNrIGluIHRoZSBkaXNwbGF5IG9iamVjdCdzIGxvY2FsIGNvb3JkaW5hdGVzLlxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgYSB2aXNpYmxlIHBvcnRpb24gb2YgdGhlIERpc3BsYXlPYmplY3QgaW50ZXJzZWN0IHRoZSBzcGVjaWZpZWRcclxuXHQgKiBsb2NhbCBQb2ludC5cclxuXHQqL1xyXG5cdHAuaGl0VGVzdCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuXHRcdHZhciBjdHggPSBEaXNwbGF5T2JqZWN0Ll9oaXRUZXN0Q29udGV4dDtcclxuXHRcdGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgLXgsIC15KTtcclxuXHRcdHRoaXMuZHJhdyhjdHgpO1xyXG5cclxuXHRcdHZhciBoaXQgPSB0aGlzLl90ZXN0SGl0KGN0eCk7XHJcblx0XHRjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xyXG5cdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCAyLCAyKTtcclxuXHRcdHJldHVybiBoaXQ7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBQcm92aWRlcyBhIGNoYWluYWJsZSBzaG9ydGN1dCBtZXRob2QgZm9yIHNldHRpbmcgYSBudW1iZXIgb2YgcHJvcGVydGllcyBvbiB0aGUgaW5zdGFuY2UuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIHZhciBteUdyYXBoaWNzID0gbmV3IGNyZWF0ZWpzLkdyYXBoaWNzKCkuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3Q2lyY2xlKDAsIDAsIDI1KTtcclxuXHQgKiAgICAgIHZhciBzaGFwZSA9IHN0YWdlLmFkZENoaWxkKG5ldyBTaGFwZSgpKS5zZXQoe2dyYXBoaWNzOm15R3JhcGhpY3MsIHg6MTAwLCB5OjEwMCwgYWxwaGE6MC41fSk7XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIHNldFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBBIGdlbmVyaWMgb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBjb3B5IHRvIHRoZSBEaXNwbGF5T2JqZWN0IGluc3RhbmNlLlxyXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IFJldHVybnMgdGhlIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcclxuXHQgKiBAY2hhaW5hYmxlXHJcblx0Ki9cclxuXHRwLnNldCA9IGZ1bmN0aW9uKHByb3BzKSB7XHJcblx0XHRmb3IgKHZhciBuIGluIHByb3BzKSB7IHRoaXNbbl0gPSBwcm9wc1tuXTsgfVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgcmVjdGFuZ2xlIHJlcHJlc2VudGluZyB0aGlzIG9iamVjdCdzIGJvdW5kcyBpbiBpdHMgbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW0gKGllLiB3aXRoIG5vIHRyYW5zZm9ybWF0aW9uKS5cclxuXHQgKiBPYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGNhY2hlZCB3aWxsIHJldHVybiB0aGUgYm91bmRzIG9mIHRoZSBjYWNoZS5cclxuXHQgKiBcclxuXHQgKiBOb3QgYWxsIGRpc3BsYXkgb2JqZWN0cyBjYW4gY2FsY3VsYXRlIHRoZWlyIG93biBib3VuZHMgKGV4LiBTaGFwZSkuIEZvciB0aGVzZSBvYmplY3RzLCB5b3UgY2FuIHVzZSBcclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3NldEJvdW5kc1wifX17ey9jcm9zc0xpbmt9fSBzbyB0aGF0IHRoZXkgYXJlIGluY2x1ZGVkIHdoZW4gY2FsY3VsYXRpbmcgQ29udGFpbmVyXHJcblx0ICogYm91bmRzLlxyXG5cdCAqIFxyXG5cdCAqIDx0YWJsZT5cclxuXHQgKiBcdDx0cj48dGQ+PGI+QWxsPC9iPjwvdGQ+PHRkPlxyXG5cdCAqIFx0XHRBbGwgZGlzcGxheSBvYmplY3RzIHN1cHBvcnQgc2V0dGluZyBib3VuZHMgbWFudWFsbHkgdXNpbmcgc2V0Qm91bmRzKCkuIExpa2V3aXNlLCBkaXNwbGF5IG9iamVjdHMgdGhhdFxyXG5cdCAqIFx0XHRoYXZlIGJlZW4gY2FjaGVkIHVzaW5nIGNhY2hlKCkgd2lsbCByZXR1cm4gdGhlIGJvdW5kcyBvZiB0aGVpciBjYWNoZS4gTWFudWFsIGFuZCBjYWNoZSBib3VuZHMgd2lsbCBvdmVycmlkZVxyXG5cdCAqIFx0XHR0aGUgYXV0b21hdGljIGNhbGN1bGF0aW9ucyBsaXN0ZWQgYmVsb3cuXHJcblx0ICogXHQ8L3RkPjwvdHI+XHJcblx0ICogXHQ8dHI+PHRkPjxiPkJpdG1hcDwvYj48L3RkPjx0ZD5cclxuXHQgKiBcdFx0UmV0dXJucyB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgc291cmNlUmVjdCAoaWYgc3BlY2lmaWVkKSBvciBpbWFnZSwgZXh0ZW5kaW5nIGZyb20gKHg9MCx5PTApLlxyXG5cdCAqIFx0PC90ZD48L3RyPlxyXG5cdCAqIFx0PHRyPjx0ZD48Yj5TcHJpdGU8L2I+PC90ZD48dGQ+XHJcblx0ICogXHRcdFJldHVybnMgdGhlIGJvdW5kcyBvZiB0aGUgY3VycmVudCBmcmFtZS4gTWF5IGhhdmUgbm9uLXplcm8geC95IGlmIGEgZnJhbWUgcmVnaXN0cmF0aW9uIHBvaW50IHdhcyBzcGVjaWZpZWRcclxuXHQgKiBcdFx0aW4gdGhlIHNwcml0ZXNoZWV0IGRhdGEuIFNlZSBhbHNvIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0L2dldEZyYW1lQm91bmRzXCJ9fXt7L2Nyb3NzTGlua319XHJcblx0ICogXHQ8L3RkPjwvdHI+XHJcblx0ICogXHQ8dHI+PHRkPjxiPkNvbnRhaW5lcjwvYj48L3RkPjx0ZD5cclxuXHQgKiBcdFx0UmV0dXJucyB0aGUgYWdncmVnYXRlIChjb21iaW5lZCkgYm91bmRzIG9mIGFsbCBjaGlsZHJlbiB0aGF0IHJldHVybiBhIG5vbi1udWxsIHZhbHVlIGZyb20gZ2V0Qm91bmRzKCkuXHJcblx0ICogXHQ8L3RkPjwvdHI+XHJcblx0ICogXHQ8dHI+PHRkPjxiPlNoYXBlPC9iPjwvdGQ+PHRkPlxyXG5cdCAqIFx0XHREb2VzIG5vdCBjdXJyZW50bHkgc3VwcG9ydCBhdXRvbWF0aWMgYm91bmRzIGNhbGN1bGF0aW9ucy4gVXNlIHNldEJvdW5kcygpIHRvIG1hbnVhbGx5IGRlZmluZSBib3VuZHMuXHJcblx0ICogXHQ8L3RkPjwvdHI+XHJcblx0ICogXHQ8dHI+PHRkPjxiPlRleHQ8L2I+PC90ZD48dGQ+XHJcblx0ICogXHRcdFJldHVybnMgYXBwcm94aW1hdGUgYm91bmRzLiBIb3Jpem9udGFsIHZhbHVlcyAoeC93aWR0aCkgYXJlIHF1aXRlIGFjY3VyYXRlLCBidXQgdmVydGljYWwgdmFsdWVzICh5L2hlaWdodCkgYXJlXHJcblx0ICogXHRcdG5vdCwgZXNwZWNpYWxseSB3aGVuIHVzaW5nIHRleHRCYXNlbGluZSB2YWx1ZXMgb3RoZXIgdGhhbiBcInRvcFwiLlxyXG5cdCAqIFx0PC90ZD48L3RyPlxyXG5cdCAqIFx0PHRyPjx0ZD48Yj5CaXRtYXBUZXh0PC9iPjwvdGQ+PHRkPlxyXG5cdCAqIFx0XHRSZXR1cm5zIGFwcHJveGltYXRlIGJvdW5kcy4gVmFsdWVzIHdpbGwgYmUgbW9yZSBhY2N1cmF0ZSBpZiBzcHJpdGVzaGVldCBmcmFtZSByZWdpc3RyYXRpb24gcG9pbnRzIGFyZSBjbG9zZVxyXG5cdCAqIFx0XHR0byAoeD0wLHk9MCkuXHJcblx0ICogXHQ8L3RkPjwvdHI+XHJcblx0KiA8L3RhYmxlPlxyXG5cdCAqIFxyXG5cdCAqIEJvdW5kcyBjYW4gYmUgZXhwZW5zaXZlIHRvIGNhbGN1bGF0ZSBmb3Igc29tZSBvYmplY3RzIChleC4gdGV4dCwgb3IgY29udGFpbmVycyB3aXRoIG1hbnkgY2hpbGRyZW4pLCBhbmRcclxuXHQgKiBhcmUgcmVjYWxjdWxhdGVkIGVhY2ggdGltZSB5b3UgY2FsbCBnZXRCb3VuZHMoKS4gWW91IGNhbiBwcmV2ZW50IHJlY2FsY3VsYXRpb24gb24gc3RhdGljIG9iamVjdHMgYnkgc2V0dGluZyB0aGVcclxuXHQgKiBib3VuZHMgZXhwbGljaXRseTpcclxuXHQgKiBcclxuXHQgKiBcdHZhciBib3VuZHMgPSBvYmouZ2V0Qm91bmRzKCk7XHJcblx0ICogXHRvYmouc2V0Qm91bmRzKGJvdW5kcy54LCBib3VuZHMueSwgYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0KTtcclxuXHQgKiBcdC8vIGdldEJvdW5kcyB3aWxsIG5vdyB1c2UgdGhlIHNldCB2YWx1ZXMsIGluc3RlYWQgb2YgcmVjYWxjdWxhdGluZ1xyXG5cdCAqIFxyXG5cdCAqIFRvIHJlZHVjZSBtZW1vcnkgaW1wYWN0LCB0aGUgcmV0dXJuZWQgUmVjdGFuZ2xlIGluc3RhbmNlIG1heSBiZSByZXVzZWQgaW50ZXJuYWxseTsgY2xvbmUgdGhlIGluc3RhbmNlIG9yIGNvcHkgaXRzXHJcblx0ICogdmFsdWVzIGlmIHlvdSBuZWVkIHRvIHJldGFpbiBpdC5cclxuXHQgKiBcclxuXHQgKiBcdHZhciBteUJvdW5kcyA9IG9iai5nZXRCb3VuZHMoKS5jbG9uZSgpO1xyXG5cdCAqIFx0Ly8gT1I6XHJcblx0ICogXHRteVJlY3QuY29weShvYmouZ2V0Qm91bmRzKCkpO1xyXG5cdCAqIFxyXG5cdCAqIEBtZXRob2QgZ2V0Qm91bmRzXHJcblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBBIFJlY3RhbmdsZSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlIGJvdW5kcywgb3IgbnVsbCBpZiBib3VuZHMgYXJlIG5vdCBhdmFpbGFibGUgZm9yIHRoaXNcclxuXHQgKiBvYmplY3QuXHJcblx0ICoqL1xyXG5cdHAuZ2V0Qm91bmRzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZiAodGhpcy5fYm91bmRzKSB7IHJldHVybiB0aGlzLl9yZWN0YW5nbGUuY29weSh0aGlzLl9ib3VuZHMpOyB9XHJcblx0XHR2YXIgY2FjaGVDYW52YXMgPSB0aGlzLmNhY2hlQ2FudmFzO1xyXG5cdFx0aWYgKGNhY2hlQ2FudmFzKSB7XHJcblx0XHRcdHZhciBzY2FsZSA9IHRoaXMuX2NhY2hlU2NhbGU7XHJcblx0XHRcdHJldHVybiB0aGlzLl9yZWN0YW5nbGUuc2V0VmFsdWVzKHRoaXMuX2NhY2hlT2Zmc2V0WCwgdGhpcy5fY2FjaGVPZmZzZXRZLCBjYWNoZUNhbnZhcy53aWR0aC9zY2FsZSwgY2FjaGVDYW52YXMuaGVpZ2h0L3NjYWxlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogUmV0dXJucyBhIHJlY3RhbmdsZSByZXByZXNlbnRpbmcgdGhpcyBvYmplY3QncyBib3VuZHMgaW4gaXRzIHBhcmVudCdzIGNvb3JkaW5hdGUgc3lzdGVtIChpZS4gd2l0aCB0cmFuc2Zvcm1hdGlvbnMgYXBwbGllZCkuXHJcblx0ICogT2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBjYWNoZWQgd2lsbCByZXR1cm4gdGhlIHRyYW5zZm9ybWVkIGJvdW5kcyBvZiB0aGUgY2FjaGUuXHJcblx0ICogXHJcblx0ICogTm90IGFsbCBkaXNwbGF5IG9iamVjdHMgY2FuIGNhbGN1bGF0ZSB0aGVpciBvd24gYm91bmRzIChleC4gU2hhcGUpLiBGb3IgdGhlc2Ugb2JqZWN0cywgeW91IGNhbiB1c2UgXHJcblx0ICoge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9zZXRCb3VuZHNcIn19e3svY3Jvc3NMaW5rfX0gc28gdGhhdCB0aGV5IGFyZSBpbmNsdWRlZCB3aGVuIGNhbGN1bGF0aW5nIENvbnRhaW5lclxyXG5cdCAqIGJvdW5kcy5cclxuXHQgKiBcclxuXHQgKiBUbyByZWR1Y2UgbWVtb3J5IGltcGFjdCwgdGhlIHJldHVybmVkIFJlY3RhbmdsZSBpbnN0YW5jZSBtYXkgYmUgcmV1c2VkIGludGVybmFsbHk7IGNsb25lIHRoZSBpbnN0YW5jZSBvciBjb3B5IGl0c1xyXG5cdCAqIHZhbHVlcyBpZiB5b3UgbmVlZCB0byByZXRhaW4gaXQuXHJcblx0ICogXHJcblx0ICogQ29udGFpbmVyIGluc3RhbmNlcyBjYWxjdWxhdGUgYWdncmVnYXRlIGJvdW5kcyBmb3IgYWxsIGNoaWxkcmVuIHRoYXQgcmV0dXJuIGJvdW5kcyB2aWEgZ2V0Qm91bmRzLlxyXG5cdCAqIEBtZXRob2QgZ2V0VHJhbnNmb3JtZWRCb3VuZHNcclxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IEEgUmVjdGFuZ2xlIGluc3RhbmNlIHJlcHJlc2VudGluZyB0aGUgYm91bmRzLCBvciBudWxsIGlmIGJvdW5kcyBhcmUgbm90IGF2YWlsYWJsZSBmb3IgdGhpcyBvYmplY3QuXHJcblx0ICoqL1xyXG5cdHAuZ2V0VHJhbnNmb3JtZWRCb3VuZHMgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLl9nZXRCb3VuZHMoKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEFsbG93cyB5b3UgdG8gbWFudWFsbHkgc3BlY2lmeSB0aGUgYm91bmRzIG9mIGFuIG9iamVjdCB0aGF0IGVpdGhlciBjYW5ub3QgY2FsY3VsYXRlIHRoZWlyIG93biBib3VuZHMgKGV4LiBTaGFwZSAmXHJcblx0ICogVGV4dCkgZm9yIGZ1dHVyZSByZWZlcmVuY2UsIG9yIHNvIHRoZSBvYmplY3QgY2FuIGJlIGluY2x1ZGVkIGluIENvbnRhaW5lciBib3VuZHMuIE1hbnVhbGx5IHNldCBib3VuZHMgd2lsbCBhbHdheXNcclxuXHQgKiBvdmVycmlkZSBjYWxjdWxhdGVkIGJvdW5kcy5cclxuXHQgKiBcclxuXHQgKiBUaGUgYm91bmRzIHNob3VsZCBiZSBzcGVjaWZpZWQgaW4gdGhlIG9iamVjdCdzIGxvY2FsICh1bnRyYW5zZm9ybWVkKSBjb29yZGluYXRlcy4gRm9yIGV4YW1wbGUsIGEgU2hhcGUgaW5zdGFuY2VcclxuXHQgKiB3aXRoIGEgMjVweCByYWRpdXMgY2lyY2xlIGNlbnRlcmVkIGF0IDAsMCB3b3VsZCBoYXZlIGJvdW5kcyBvZiAoLTI1LCAtMjUsIDUwLCA1MCkuXHJcblx0ICogQG1ldGhvZCBzZXRCb3VuZHNcclxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBvcmlnaW4gb2YgdGhlIGJvdW5kcy4gUGFzcyBudWxsIHRvIHJlbW92ZSB0aGUgbWFudWFsIGJvdW5kcy5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBvcmlnaW4gb2YgdGhlIGJvdW5kcy5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSBib3VuZHMuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBib3VuZHMuXHJcblx0ICoqL1xyXG5cdHAuc2V0Qm91bmRzID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG5cdFx0aWYgKHggPT0gbnVsbCkgeyB0aGlzLl9ib3VuZHMgPSB4OyB9XHJcblx0XHR0aGlzLl9ib3VuZHMgPSAodGhpcy5fYm91bmRzIHx8IG5ldyBjcmVhdGVqcy5SZWN0YW5nbGUoKSkuc2V0VmFsdWVzKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGlzIERpc3BsYXlPYmplY3QuIFNvbWUgcHJvcGVydGllcyB0aGF0IGFyZSBzcGVjaWZpYyB0byB0aGlzIGluc3RhbmNlJ3MgY3VycmVudCBjb250ZXh0IGFyZVxyXG5cdCAqIHJldmVydGVkIHRvIHRoZWlyIGRlZmF1bHRzIChmb3IgZXhhbXBsZSAucGFyZW50KS4gQ2FjaGVzIGFyZSBub3QgbWFpbnRhaW5lZCBhY3Jvc3MgY2xvbmVzLCBhbmQgc29tZSBlbGVtZW50c1xyXG5cdCAqIGFyZSBjb3BpZWQgYnkgcmVmZXJlbmNlIChtYXNrcywgaW5kaXZpZHVhbCBmaWx0ZXIgaW5zdGFuY2VzLCBoaXQgYXJlYSlcclxuXHQgKiBAbWV0aG9kIGNsb25lXHJcblx0ICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gQSBjbG9uZSBvZiB0aGUgY3VycmVudCBEaXNwbGF5T2JqZWN0IGluc3RhbmNlLlxyXG5cdCAqKi9cclxuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmVQcm9wcyhuZXcgRGlzcGxheU9iamVjdCgpKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxyXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cclxuXHQgKiovXHJcblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIFwiW0Rpc3BsYXlPYmplY3QgKG5hbWU9XCIrICB0aGlzLm5hbWUgK1wiKV1cIjtcclxuXHR9O1xyXG5cclxuXHJcbi8vIHByaXZhdGUgbWV0aG9kczpcclxuXHQvLyBzZXBhcmF0ZWQgc28gaXQgY2FuIGJlIHVzZWQgbW9yZSBlYXNpbHkgaW4gc3ViY2xhc3NlczpcclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIF9jbG9uZVByb3BzXHJcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBvIFRoZSBEaXNwbGF5T2JqZWN0IGluc3RhbmNlIHdoaWNoIHdpbGwgaGF2ZSBwcm9wZXJ0aWVzIGZyb20gdGhlIGN1cnJlbnQgRGlzcGxheU9iamVjdFxyXG5cdCAqIGluc3RhbmNlIGNvcGllZCBpbnRvLlxyXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IG9cclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICoqL1xyXG5cdHAuX2Nsb25lUHJvcHMgPSBmdW5jdGlvbihvKSB7XHJcblx0XHRvLmFscGhhID0gdGhpcy5hbHBoYTtcclxuXHRcdG8ubW91c2VFbmFibGVkID0gdGhpcy5tb3VzZUVuYWJsZWQ7XHJcblx0XHRvLnRpY2tFbmFibGVkID0gdGhpcy50aWNrRW5hYmxlZDtcclxuXHRcdG8ubmFtZSA9IHRoaXMubmFtZTtcclxuXHRcdG8ucmVnWCA9IHRoaXMucmVnWDtcclxuXHRcdG8ucmVnWSA9IHRoaXMucmVnWTtcclxuXHRcdG8ucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xyXG5cdFx0by5zY2FsZVggPSB0aGlzLnNjYWxlWDtcclxuXHRcdG8uc2NhbGVZID0gdGhpcy5zY2FsZVk7XHJcblx0XHRvLnNoYWRvdyA9IHRoaXMuc2hhZG93O1xyXG5cdFx0by5za2V3WCA9IHRoaXMuc2tld1g7XHJcblx0XHRvLnNrZXdZID0gdGhpcy5za2V3WTtcclxuXHRcdG8udmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcclxuXHRcdG8ueCAgPSB0aGlzLng7XHJcblx0XHRvLnkgPSB0aGlzLnk7XHJcblx0XHRvLmNvbXBvc2l0ZU9wZXJhdGlvbiA9IHRoaXMuY29tcG9zaXRlT3BlcmF0aW9uO1xyXG5cdFx0by5zbmFwVG9QaXhlbCA9IHRoaXMuc25hcFRvUGl4ZWw7XHJcblx0XHRvLmZpbHRlcnMgPSB0aGlzLmZpbHRlcnM9PW51bGw/bnVsbDp0aGlzLmZpbHRlcnMuc2xpY2UoMCk7XHJcblx0XHRvLm1hc2sgPSB0aGlzLm1hc2s7XHJcblx0XHRvLmhpdEFyZWEgPSB0aGlzLmhpdEFyZWE7XHJcblx0XHRvLmN1cnNvciA9IHRoaXMuY3Vyc29yO1xyXG5cdFx0by5fYm91bmRzID0gdGhpcy5fYm91bmRzO1xyXG5cdFx0cmV0dXJuIG87XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQG1ldGhvZCBfYXBwbHlTaGFkb3dcclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxyXG5cdCAqIEBwYXJhbSB7U2hhZG93fSBzaGFkb3dcclxuXHQgKiovXHJcblx0cC5fYXBwbHlTaGFkb3cgPSBmdW5jdGlvbihjdHgsIHNoYWRvdykge1xyXG5cdFx0c2hhZG93ID0gc2hhZG93IHx8IFNoYWRvdy5pZGVudGl0eTtcclxuXHRcdGN0eC5zaGFkb3dDb2xvciA9IHNoYWRvdy5jb2xvcjtcclxuXHRcdGN0eC5zaGFkb3dPZmZzZXRYID0gc2hhZG93Lm9mZnNldFg7XHJcblx0XHRjdHguc2hhZG93T2Zmc2V0WSA9IHNoYWRvdy5vZmZzZXRZO1xyXG5cdFx0Y3R4LnNoYWRvd0JsdXIgPSBzaGFkb3cuYmx1cjtcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEBtZXRob2QgX3RpY2tcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZ0T2JqIEFuIGV2ZW50IG9iamVjdCB0aGF0IHdpbGwgYmUgZGlzcGF0Y2hlZCB0byBhbGwgdGljayBsaXN0ZW5lcnMuIFRoaXMgb2JqZWN0IGlzIHJldXNlZCBiZXR3ZWVuIGRpc3BhdGNoZXJzIHRvIHJlZHVjZSBjb25zdHJ1Y3Rpb24gJiBHQyBjb3N0cy5cclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICoqL1xyXG5cdHAuX3RpY2sgPSBmdW5jdGlvbihldnRPYmopIHtcclxuXHRcdC8vIGJlY2F1c2UgdGljayBjYW4gYmUgcmVhbGx5IHBlcmZvcm1hbmNlIHNlbnNpdGl2ZSwgY2hlY2sgZm9yIGxpc3RlbmVycyBiZWZvcmUgY2FsbGluZyBkaXNwYXRjaEV2ZW50LlxyXG5cdFx0dmFyIGxzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG5cdFx0aWYgKGxzICYmIGxzW1widGlja1wiXSkge1xyXG5cdFx0XHQvLyByZXNldCAmIHJldXNlIHRoZSBldmVudCBvYmplY3QgdG8gYXZvaWQgY29uc3RydWN0aW9uIC8gR0MgY29zdHM6XHJcblx0XHRcdGV2dE9iai50YXJnZXQgPSBudWxsO1xyXG5cdFx0XHRldnRPYmoucHJvcGFnYXRpb25TdG9wcGVkID0gZXZ0T2JqLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0T2JqKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIF90ZXN0SGl0XHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxyXG5cdCAqKi9cclxuXHRwLl90ZXN0SGl0ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHR0cnkge1xyXG5cdFx0XHR2YXIgaGl0ID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhWzNdID4gMTtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0aWYgKCFEaXNwbGF5T2JqZWN0LnN1cHByZXNzQ3Jvc3NEb21haW5FcnJvcnMpIHtcclxuXHRcdFx0XHR0aHJvdyBcIkFuIGVycm9yIGhhcyBvY2N1cnJlZC4gVGhpcyBpcyBtb3N0IGxpa2VseSBkdWUgdG8gc2VjdXJpdHkgcmVzdHJpY3Rpb25zIG9uIHJlYWRpbmcgY2FudmFzIHBpeGVsIGRhdGEgd2l0aCBsb2NhbCBvciBjcm9zcy1kb21haW4gaW1hZ2VzLlwiO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gaGl0O1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBtZXRob2QgX2FwcGx5RmlsdGVyc1xyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiovXHJcblx0cC5fYXBwbHlGaWx0ZXJzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZiAoIXRoaXMuZmlsdGVycyB8fCB0aGlzLmZpbHRlcnMubGVuZ3RoID09IDAgfHwgIXRoaXMuY2FjaGVDYW52YXMpIHsgcmV0dXJuOyB9XHJcblx0XHR2YXIgbCA9IHRoaXMuZmlsdGVycy5sZW5ndGg7XHJcblx0XHR2YXIgY3R4ID0gdGhpcy5jYWNoZUNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblx0XHR2YXIgdyA9IHRoaXMuY2FjaGVDYW52YXMud2lkdGg7XHJcblx0XHR2YXIgaCA9IHRoaXMuY2FjaGVDYW52YXMuaGVpZ2h0O1xyXG5cdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrKykge1xyXG5cdFx0XHR0aGlzLmZpbHRlcnNbaV0uYXBwbHlGaWx0ZXIoY3R4LCAwLCAwLCB3LCBoKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEBtZXRob2QgX2dldEZpbHRlckJvdW5kc1xyXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX1cclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICoqL1xyXG5cdHAuX2dldEZpbHRlckJvdW5kcyA9IGZ1bmN0aW9uKHJlY3QpIHtcclxuXHRcdHZhciBsLCBmaWx0ZXJzID0gdGhpcy5maWx0ZXJzLCBib3VuZHMgPSB0aGlzLl9yZWN0YW5nbGUuc2V0VmFsdWVzKDAsMCwwLDApO1xyXG5cdFx0aWYgKCFmaWx0ZXJzIHx8ICEobD1maWx0ZXJzLmxlbmd0aCkpIHsgcmV0dXJuIGJvdW5kczsgfVxyXG5cdFx0XHJcblx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7XHJcblx0XHRcdHZhciBmID0gdGhpcy5maWx0ZXJzW2ldO1xyXG5cdFx0XHRmLmdldEJvdW5kcyYmZi5nZXRCb3VuZHMoYm91bmRzKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBib3VuZHM7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIF9nZXRCb3VuZHNcclxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXhcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZVRyYW5zZm9ybSBJZiB0cnVlLCBkb2VzIG5vdCBhcHBseSB0aGlzIG9iamVjdCdzIHRyYW5zZm9ybS5cclxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9XHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqKi9cclxuXHRwLl9nZXRCb3VuZHMgPSBmdW5jdGlvbihtYXRyaXgsIGlnbm9yZVRyYW5zZm9ybSl7XHJcblx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtQm91bmRzKHRoaXMuZ2V0Qm91bmRzKCksIG1hdHJpeCwgaWdub3JlVHJhbnNmb3JtKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEBtZXRob2QgX3RyYW5zZm9ybUJvdW5kc1xyXG5cdCAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBib3VuZHNcclxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXhcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZVRyYW5zZm9ybVxyXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX1cclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICoqL1xyXG5cdHAuX3RyYW5zZm9ybUJvdW5kcyA9IGZ1bmN0aW9uKGJvdW5kcywgbWF0cml4LCBpZ25vcmVUcmFuc2Zvcm0pIHtcclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBib3VuZHM7IH1cclxuXHRcdHZhciB4ID0gYm91bmRzLngsIHkgPSBib3VuZHMueSwgd2lkdGggPSBib3VuZHMud2lkdGgsIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQsIG10eCA9IHRoaXMuX3Byb3BzLm1hdHJpeDtcclxuXHRcdG10eCA9IGlnbm9yZVRyYW5zZm9ybSA/IG10eC5pZGVudGl0eSgpIDogdGhpcy5nZXRNYXRyaXgobXR4KTtcclxuXHRcdFxyXG5cdFx0aWYgKHggfHwgeSkgeyBtdHguYXBwZW5kVHJhbnNmb3JtKDAsMCwxLDEsMCwwLDAsLXgsLXkpOyB9IC8vIFRPRE86IHNpbXBsaWZ5IHRoaXMuXHJcblx0XHRpZiAobWF0cml4KSB7IG10eC5wcmVwZW5kTWF0cml4KG1hdHJpeCk7IH1cclxuXHRcdFxyXG5cdFx0dmFyIHhfYSA9IHdpZHRoKm10eC5hLCB4X2IgPSB3aWR0aCptdHguYjtcclxuXHRcdHZhciB5X2MgPSBoZWlnaHQqbXR4LmMsIHlfZCA9IGhlaWdodCptdHguZDtcclxuXHRcdHZhciB0eCA9IG10eC50eCwgdHkgPSBtdHgudHk7XHJcblx0XHRcclxuXHRcdHZhciBtaW5YID0gdHgsIG1heFggPSB0eCwgbWluWSA9IHR5LCBtYXhZID0gdHk7XHJcblxyXG5cdFx0aWYgKCh4ID0geF9hICsgdHgpIDwgbWluWCkgeyBtaW5YID0geDsgfSBlbHNlIGlmICh4ID4gbWF4WCkgeyBtYXhYID0geDsgfVxyXG5cdFx0aWYgKCh4ID0geF9hICsgeV9jICsgdHgpIDwgbWluWCkgeyBtaW5YID0geDsgfSBlbHNlIGlmICh4ID4gbWF4WCkgeyBtYXhYID0geDsgfVxyXG5cdFx0aWYgKCh4ID0geV9jICsgdHgpIDwgbWluWCkgeyBtaW5YID0geDsgfSBlbHNlIGlmICh4ID4gbWF4WCkgeyBtYXhYID0geDsgfVxyXG5cdFx0XHJcblx0XHRpZiAoKHkgPSB4X2IgKyB0eSkgPCBtaW5ZKSB7IG1pblkgPSB5OyB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7IG1heFkgPSB5OyB9XHJcblx0XHRpZiAoKHkgPSB4X2IgKyB5X2QgKyB0eSkgPCBtaW5ZKSB7IG1pblkgPSB5OyB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7IG1heFkgPSB5OyB9XHJcblx0XHRpZiAoKHkgPSB5X2QgKyB0eSkgPCBtaW5ZKSB7IG1pblkgPSB5OyB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7IG1heFkgPSB5OyB9XHJcblx0XHRcclxuXHRcdHJldHVybiBib3VuZHMuc2V0VmFsdWVzKG1pblgsIG1pblksIG1heFgtbWluWCwgbWF4WS1taW5ZKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCBoYXMgYW55IG1vdXNlIGV2ZW50IGxpc3RlbmVycyBvciBhIGN1cnNvci5cclxuXHQgKiBAbWV0aG9kIF9pc01vdXNlT3BhcXVlXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICoqL1xyXG5cdHAuX2hhc01vdXNlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGV2dHMgPSBEaXNwbGF5T2JqZWN0Ll9NT1VTRV9FVkVOVFM7XHJcblx0XHRmb3IgKHZhciBpPSAwLCBsPWV2dHMubGVuZ3RoOyBpPGw7IGkrKykge1xyXG5cdFx0XHRpZiAodGhpcy5oYXNFdmVudExpc3RlbmVyKGV2dHNbaV0pKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gISF0aGlzLmN1cnNvcjtcclxuXHR9O1xyXG5cclxuXHRjcmVhdGVqcy5EaXNwbGF5T2JqZWN0ID0gY3JlYXRlanMucHJvbW90ZShEaXNwbGF5T2JqZWN0LCBcIkV2ZW50RGlzcGF0Y2hlclwiKTtcclxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIENvbnRhaW5lci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cdFxyXG5cclxuLy8gY29uc3RydWN0b3I6XHJcbi8qKlxyXG4gKiBBIENvbnRhaW5lciBpcyBhIG5lc3RhYmxlIGRpc3BsYXkgbGlzdCB0aGF0IGFsbG93cyB5b3UgdG8gd29yayB3aXRoIGNvbXBvdW5kIGRpc3BsYXkgZWxlbWVudHMuIEZvciAgZXhhbXBsZSB5b3UgY291bGRcclxuICogZ3JvdXAgYXJtLCBsZWcsIHRvcnNvIGFuZCBoZWFkIHt7I2Nyb3NzTGluayBcIkJpdG1hcFwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZXMgdG9nZXRoZXIgaW50byBhIFBlcnNvbiBDb250YWluZXIsIGFuZFxyXG4gKiB0cmFuc2Zvcm0gdGhlbSBhcyBhIGdyb3VwLCB3aGlsZSBzdGlsbCBiZWluZyBhYmxlIHRvIG1vdmUgdGhlIGluZGl2aWR1YWwgcGFydHMgcmVsYXRpdmUgdG8gZWFjaCBvdGhlci4gQ2hpbGRyZW4gb2ZcclxuICogY29udGFpbmVycyBoYXZlIHRoZWlyIDxjb2RlPnRyYW5zZm9ybTwvY29kZT4gYW5kIDxjb2RlPmFscGhhPC9jb2RlPiBwcm9wZXJ0aWVzIGNvbmNhdGVuYXRlZCB3aXRoIHRoZWlyIHBhcmVudFxyXG4gKiBDb250YWluZXIuXHJcbiAqXHJcbiAqIEZvciBleGFtcGxlLCBhIHt7I2Nyb3NzTGluayBcIlNoYXBlXCJ9fXt7L2Nyb3NzTGlua319IHdpdGggeD0xMDAgYW5kIGFscGhhPTAuNSwgcGxhY2VkIGluIGEgQ29udGFpbmVyIHdpdGggPGNvZGU+eD01MDwvY29kZT5cclxuICogYW5kIDxjb2RlPmFscGhhPTAuNzwvY29kZT4gd2lsbCBiZSByZW5kZXJlZCB0byB0aGUgY2FudmFzIGF0IDxjb2RlPng9MTUwPC9jb2RlPiBhbmQgPGNvZGU+YWxwaGE9MC4zNTwvY29kZT4uXHJcbiAqIENvbnRhaW5lcnMgaGF2ZSBzb21lIG92ZXJoZWFkLCBzbyB5b3UgZ2VuZXJhbGx5IHNob3VsZG4ndCBjcmVhdGUgYSBDb250YWluZXIgdG8gaG9sZCBhIHNpbmdsZSBjaGlsZC5cclxuICpcclxuICogPGg0PkV4YW1wbGU8L2g0PlxyXG4gKlxyXG4gKiAgICAgIHZhciBjb250YWluZXIgPSBuZXcgY3JlYXRlanMuQ29udGFpbmVyKCk7XHJcbiAqICAgICAgY29udGFpbmVyLmFkZENoaWxkKGJpdG1hcEluc3RhbmNlLCBzaGFwZUluc3RhbmNlKTtcclxuICogICAgICBjb250YWluZXIueCA9IDEwMDtcclxuICpcclxuICogQGNsYXNzIENvbnRhaW5lclxyXG4gKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0XHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiovXHJcblx0ZnVuY3Rpb24gQ29udGFpbmVyKCkge1xyXG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X2NvbnN0cnVjdG9yKCk7XHJcblx0XHRcclxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcclxuXHRcdC8qKlxyXG5cdFx0ICogVGhlIGFycmF5IG9mIGNoaWxkcmVuIGluIHRoZSBkaXNwbGF5IGxpc3QuIFlvdSBzaG91bGQgdXN1YWxseSB1c2UgdGhlIGNoaWxkIG1hbmFnZW1lbnQgbWV0aG9kcyBzdWNoIGFzXHJcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvYWRkQ2hpbGRcIn19e3svY3Jvc3NMaW5rfX0sIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lci9yZW1vdmVDaGlsZFwifX17ey9jcm9zc0xpbmt9fSxcclxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lci9zd2FwQ2hpbGRyZW5cIn19e3svY3Jvc3NMaW5rfX0sIGV0YywgcmF0aGVyIHRoYW4gYWNjZXNzaW5nIHRoaXMgZGlyZWN0bHksIGJ1dCBpdCBpc1xyXG5cdFx0ICogaW5jbHVkZWQgZm9yIGFkdmFuY2VkIHVzZXMuXHJcblx0XHQgKiBAcHJvcGVydHkgY2hpbGRyZW5cclxuXHRcdCAqIEB0eXBlIEFycmF5XHJcblx0XHQgKiBAZGVmYXVsdCBudWxsXHJcblx0XHQgKiovXHJcblx0XHR0aGlzLmNoaWxkcmVuID0gW107XHJcblx0XHRcclxuXHRcdC8qKlxyXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNoaWxkcmVuIG9mIHRoaXMgY29udGFpbmVyIGFyZSBpbmRlcGVuZGVudGx5IGVuYWJsZWQgZm9yIG1vdXNlL3BvaW50ZXIgaW50ZXJhY3Rpb24uXHJcblx0XHQgKiBJZiBmYWxzZSwgdGhlIGNoaWxkcmVuIHdpbGwgYmUgYWdncmVnYXRlZCB1bmRlciB0aGUgY29udGFpbmVyIC0gZm9yIGV4YW1wbGUsIGEgY2xpY2sgb24gYSBjaGlsZCBzaGFwZSB3b3VsZFxyXG5cdFx0ICogdHJpZ2dlciBhIGNsaWNrIGV2ZW50IG9uIHRoZSBjb250YWluZXIuXHJcblx0XHQgKiBAcHJvcGVydHkgbW91c2VDaGlsZHJlblxyXG5cdFx0ICogQHR5cGUgQm9vbGVhblxyXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5tb3VzZUNoaWxkcmVuID0gdHJ1ZTtcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBJZiBmYWxzZSwgdGhlIHRpY2sgd2lsbCBub3QgYmUgcHJvcGFnYXRlZCB0byBjaGlsZHJlbiBvZiB0aGlzIENvbnRhaW5lci4gVGhpcyBjYW4gcHJvdmlkZSBzb21lIHBlcmZvcm1hbmNlIGJlbmVmaXRzLlxyXG5cdFx0ICogSW4gYWRkaXRpb24gdG8gcHJldmVudGluZyB0aGUgXCJ0aWNrXCIgZXZlbnQgZnJvbSBiZWluZyBkaXNwYXRjaGVkLCBpdCB3aWxsIGFsc28gcHJldmVudCB0aWNrIHJlbGF0ZWQgdXBkYXRlc1xyXG5cdFx0ICogb24gc29tZSBkaXNwbGF5IG9iamVjdHMgKGV4LiBTcHJpdGUgJiBNb3ZpZUNsaXAgZnJhbWUgYWR2YW5jaW5nLCBET01FbGVtZW50IHZpc2liaWxpdHkgaGFuZGxpbmcpLlxyXG5cdFx0ICogQHByb3BlcnR5IHRpY2tDaGlsZHJlblxyXG5cdFx0ICogQHR5cGUgQm9vbGVhblxyXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy50aWNrQ2hpbGRyZW4gPSB0cnVlO1xyXG5cdH1cclxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChDb250YWluZXIsIGNyZWF0ZWpzLkRpc3BsYXlPYmplY3QpO1xyXG5cdFxyXG5cdFxyXG4vLyBnZXR0ZXIgLyBzZXR0ZXJzOlxyXG5cdC8qKlxyXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyL251bUNoaWxkcmVuOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXHJcblx0ICogQG1ldGhvZCBnZXROdW1DaGlsZHJlblxyXG5cdCAqIEByZXR1cm4ge051bWJlcn1cclxuXHQgKiBAZGVwcmVjYXRlZFxyXG5cdCAqKi9cclxuXHRwLmdldE51bUNoaWxkcmVuID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoZSBjb250YWluZXIuXHJcblx0ICogQHByb3BlcnR5IG51bUNoaWxkcmVuXHJcblx0ICogQHR5cGUge051bWJlcn1cclxuXHQgKiBAcmVhZG9ubHlcclxuXHQgKiovXHJcblx0dHJ5IHtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHAsIHtcclxuXHRcdFx0bnVtQ2hpbGRyZW46IHsgZ2V0OiBwLmdldE51bUNoaWxkcmVuIH1cclxuXHRcdH0pO1xyXG5cdH0gY2F0Y2ggKGUpIHt9XHJcblx0XHJcblxyXG4vLyBwdWJsaWMgbWV0aG9kczpcclxuXHQvKipcclxuXHQgKiBDb25zdHJ1Y3RvciBhbGlhcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIFRoaXMgbWV0aG9kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMuXHJcblx0ICogU3ViY2xhc3NlcyBzaG91bGQgYmUgdXBkYXRlZCB0byB1c2Uge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZHNcIn19e3svY3Jvc3NMaW5rfX0uXHJcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXHJcblx0ICogQGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIGBjcmVhdGVqcy5wcm9tb3RlKClgXHJcblx0ICoqL1xyXG5cdHAuaW5pdGlhbGl6ZSA9IENvbnRhaW5lcjsgLy8gVE9ETzogZGVwcmVjYXRlZC5cclxuXHRcclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxyXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXHJcblx0ICpcclxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXHJcblx0ICogQG1ldGhvZCBpc1Zpc2libGVcclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhc1xyXG5cdCAqKi9cclxuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGhhc0NvbnRlbnQgPSB0aGlzLmNhY2hlQ2FudmFzIHx8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xyXG5cdFx0cmV0dXJuICEhKHRoaXMudmlzaWJsZSAmJiB0aGlzLmFscGhhID4gMCAmJiB0aGlzLnNjYWxlWCAhPSAwICYmIHRoaXMuc2NhbGVZICE9IDAgJiYgaGFzQ29udGVudCk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogRHJhd3MgdGhlIGRpc3BsYXkgb2JqZWN0IGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IGlnbm9yaW5nIGl0cyB2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBhbmQgdHJhbnNmb3JtLlxyXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZHJhdyB3YXMgaGFuZGxlZCAodXNlZnVsIGZvciBvdmVycmlkaW5nIGZ1bmN0aW9uYWxpdHkpLlxyXG5cdCAqXHJcblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxyXG5cdCAqIEBtZXRob2QgZHJhd1xyXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbaWdub3JlQ2FjaGU9ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkcmF3IG9wZXJhdGlvbiBzaG91bGQgaWdub3JlIGFueSBjdXJyZW50IGNhY2hlLlxyXG5cdCAqIEZvciBleGFtcGxlLCB1c2VkIGZvciBkcmF3aW5nIHRoZSBjYWNoZSAodG8gcHJldmVudCBpdCBmcm9tIHNpbXBseSBkcmF3aW5nIGFuIGV4aXN0aW5nIGNhY2hlIGJhY2tcclxuXHQgKiBpbnRvIGl0c2VsZikuXHJcblx0ICoqL1xyXG5cdHAuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgaWdub3JlQ2FjaGUpIHtcclxuXHRcdGlmICh0aGlzLkRpc3BsYXlPYmplY3RfZHJhdyhjdHgsIGlnbm9yZUNhY2hlKSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cdFx0XHJcblx0XHQvLyB0aGlzIGVuc3VyZXMgd2UgZG9uJ3QgaGF2ZSBpc3N1ZXMgd2l0aCBkaXNwbGF5IGxpc3QgY2hhbmdlcyB0aGF0IG9jY3VyIGR1cmluZyBhIGRyYXc6XHJcblx0XHR2YXIgbGlzdCA9IHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcclxuXHRcdGZvciAodmFyIGk9MCxsPWxpc3QubGVuZ3RoOyBpPGw7IGkrKykge1xyXG5cdFx0XHR2YXIgY2hpbGQgPSBsaXN0W2ldO1xyXG5cdFx0XHRpZiAoIWNoaWxkLmlzVmlzaWJsZSgpKSB7IGNvbnRpbnVlOyB9XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBkcmF3IHRoZSBjaGlsZDpcclxuXHRcdFx0Y3R4LnNhdmUoKTtcclxuXHRcdFx0Y2hpbGQudXBkYXRlQ29udGV4dChjdHgpO1xyXG5cdFx0XHRjaGlsZC5kcmF3KGN0eCk7XHJcblx0XHRcdGN0eC5yZXN0b3JlKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYSBjaGlsZCB0byB0aGUgdG9wIG9mIHRoZSBkaXNwbGF5IGxpc3QuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiBcdFx0Y29udGFpbmVyLmFkZENoaWxkKGJpdG1hcEluc3RhbmNlKTtcclxuXHQgKlxyXG5cdCAqIFlvdSBjYW4gYWxzbyBhZGQgbXVsdGlwbGUgY2hpbGRyZW4gYXQgb25jZTpcclxuXHQgKlxyXG5cdCAqIFx0XHRjb250YWluZXIuYWRkQ2hpbGQoYml0bWFwSW5zdGFuY2UsIHNoYXBlSW5zdGFuY2UsIHRleHRJbnN0YW5jZSk7XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGFkZENoaWxkXHJcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBjaGlsZCBUaGUgZGlzcGxheSBvYmplY3QgdG8gYWRkLlxyXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCB0aGF0IHdhcyBhZGRlZCwgb3IgdGhlIGxhc3QgY2hpbGQgaWYgbXVsdGlwbGUgY2hpbGRyZW4gd2VyZSBhZGRlZC5cclxuXHQgKiovXHJcblx0cC5hZGRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XHJcblx0XHRpZiAoY2hpbGQgPT0gbnVsbCkgeyByZXR1cm4gY2hpbGQ7IH1cclxuXHRcdHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcclxuXHRcdGlmIChsID4gMSkge1xyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7IHRoaXMuYWRkQ2hpbGQoYXJndW1lbnRzW2ldKTsgfVxyXG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzW2wtMV07XHJcblx0XHR9XHJcblx0XHRpZiAoY2hpbGQucGFyZW50KSB7IGNoaWxkLnBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7IH1cclxuXHRcdGNoaWxkLnBhcmVudCA9IHRoaXM7XHJcblx0XHR0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG5cdFx0Y2hpbGQuZGlzcGF0Y2hFdmVudChcImFkZGVkXCIpO1xyXG5cdFx0cmV0dXJuIGNoaWxkO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgYSBjaGlsZCB0byB0aGUgZGlzcGxheSBsaXN0IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXgsIGJ1bXBpbmcgY2hpbGRyZW4gYXQgZXF1YWwgb3IgZ3JlYXRlciBpbmRleGVzIHVwIG9uZSwgYW5kXHJcblx0ICogc2V0dGluZyBpdHMgcGFyZW50IHRvIHRoaXMgQ29udGFpbmVyLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICBhZGRDaGlsZEF0KGNoaWxkMSwgaW5kZXgpO1xyXG5cdCAqXHJcblx0ICogWW91IGNhbiBhbHNvIGFkZCBtdWx0aXBsZSBjaGlsZHJlbiwgc3VjaCBhczpcclxuXHQgKlxyXG5cdCAqICAgICAgYWRkQ2hpbGRBdChjaGlsZDEsIGNoaWxkMiwgLi4uLCBpbmRleCk7XHJcblx0ICpcclxuXHQgKiBUaGUgaW5kZXggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIG51bUNoaWxkcmVuLiBGb3IgZXhhbXBsZSwgdG8gYWRkIG15U2hhcGUgdW5kZXIgb3RoZXJTaGFwZSBpbiB0aGUgZGlzcGxheSBsaXN0LFxyXG5cdCAqIHlvdSBjb3VsZCB1c2U6XHJcblx0ICpcclxuXHQgKiAgICAgIGNvbnRhaW5lci5hZGRDaGlsZEF0KG15U2hhcGUsIGNvbnRhaW5lci5nZXRDaGlsZEluZGV4KG90aGVyU2hhcGUpKTtcclxuXHQgKlxyXG5cdCAqIFRoaXMgd291bGQgYWxzbyBidW1wIG90aGVyU2hhcGUncyBpbmRleCB1cCBieSBvbmUuIEZhaWxzIHNpbGVudGx5IGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGFkZENoaWxkQXRcclxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IGNoaWxkIFRoZSBkaXNwbGF5IG9iamVjdCB0byBhZGQuXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byBhZGQgdGhlIGNoaWxkIGF0LlxyXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IFJldHVybnMgdGhlIGxhc3QgY2hpbGQgdGhhdCB3YXMgYWRkZWQsIG9yIHRoZSBsYXN0IGNoaWxkIGlmIG11bHRpcGxlIGNoaWxkcmVuIHdlcmUgYWRkZWQuXHJcblx0ICoqL1xyXG5cdHAuYWRkQ2hpbGRBdCA9IGZ1bmN0aW9uKGNoaWxkLCBpbmRleCkge1xyXG5cdFx0dmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xyXG5cdFx0dmFyIGluZHggPSBhcmd1bWVudHNbbC0xXTsgLy8gY2FuJ3QgdXNlIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGluZGV4IHBhcmFtIG9yIGl0IHJlcGxhY2VzIGFyZ3VtZW50c1sxXVxyXG5cdFx0aWYgKGluZHggPCAwIHx8IGluZHggPiB0aGlzLmNoaWxkcmVuLmxlbmd0aCkgeyByZXR1cm4gYXJndW1lbnRzW2wtMl07IH1cclxuXHRcdGlmIChsID4gMikge1xyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bC0xOyBpKyspIHsgdGhpcy5hZGRDaGlsZEF0KGFyZ3VtZW50c1tpXSwgaW5keCtpKTsgfVxyXG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzW2wtMl07XHJcblx0XHR9XHJcblx0XHRpZiAoY2hpbGQucGFyZW50KSB7IGNoaWxkLnBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7IH1cclxuXHRcdGNoaWxkLnBhcmVudCA9IHRoaXM7XHJcblx0XHR0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpO1xyXG5cdFx0Y2hpbGQuZGlzcGF0Y2hFdmVudChcImFkZGVkXCIpO1xyXG5cdFx0cmV0dXJuIGNoaWxkO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBjaGlsZCBmcm9tIHRoZSBkaXNwbGF5IGxpc3QuIE5vdGUgdGhhdCBpdCBpcyBmYXN0ZXIgdG8gdXNlIHJlbW92ZUNoaWxkQXQoKSBpZiB0aGUgaW5kZXggaXNcclxuXHQgKiBhbHJlYWR5IGtub3duLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2hpbGQpO1xyXG5cdCAqXHJcblx0ICogWW91IGNhbiBhbHNvIHJlbW92ZSBtdWx0aXBsZSBjaGlsZHJlbjpcclxuXHQgKlxyXG5cdCAqICAgICAgcmVtb3ZlQ2hpbGQoY2hpbGQxLCBjaGlsZDIsIC4uLik7XHJcblx0ICpcclxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNoaWxkIChvciBjaGlsZHJlbikgd2FzIHJlbW92ZWQsIG9yIGZhbHNlIGlmIGl0IHdhcyBub3QgaW4gdGhlIGRpc3BsYXkgbGlzdC5cclxuXHQgKiBAbWV0aG9kIHJlbW92ZUNoaWxkXHJcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBjaGlsZCBUaGUgY2hpbGQgdG8gcmVtb3ZlLlxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGNoaWxkIChvciBjaGlsZHJlbikgd2FzIHJlbW92ZWQsIG9yIGZhbHNlIGlmIGl0IHdhcyBub3QgaW4gdGhlIGRpc3BsYXkgbGlzdC5cclxuXHQgKiovXHJcblx0cC5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XHJcblx0XHR2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcblx0XHRpZiAobCA+IDEpIHtcclxuXHRcdFx0dmFyIGdvb2QgPSB0cnVlO1xyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7IGdvb2QgPSBnb29kICYmIHRoaXMucmVtb3ZlQ2hpbGQoYXJndW1lbnRzW2ldKTsgfVxyXG5cdFx0XHRyZXR1cm4gZ29vZDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLnJlbW92ZUNoaWxkQXQoY3JlYXRlanMuaW5kZXhPZih0aGlzLmNoaWxkcmVuLCBjaGlsZCkpO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZXMgdGhlIGNoaWxkIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggZnJvbSB0aGUgZGlzcGxheSBsaXN0LCBhbmQgc2V0cyBpdHMgcGFyZW50IHRvIG51bGwuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZEF0KDIpO1xyXG5cdCAqXHJcblx0ICogWW91IGNhbiBhbHNvIHJlbW92ZSBtdWx0aXBsZSBjaGlsZHJlbjpcclxuXHQgKlxyXG5cdCAqICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKDIsIDcsIC4uLilcclxuXHQgKlxyXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2hpbGQgKG9yIGNoaWxkcmVuKSB3YXMgcmVtb3ZlZCwgb3IgZmFsc2UgaWYgYW55IGluZGV4IHdhcyBvdXQgb2YgcmFuZ2UuXHJcblx0ICogQG1ldGhvZCByZW1vdmVDaGlsZEF0XHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgY2hpbGQgdG8gcmVtb3ZlLlxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGNoaWxkIChvciBjaGlsZHJlbikgd2FzIHJlbW92ZWQsIG9yIGZhbHNlIGlmIGFueSBpbmRleCB3YXMgb3V0IG9mIHJhbmdlLlxyXG5cdCAqKi9cclxuXHRwLnJlbW92ZUNoaWxkQXQgPSBmdW5jdGlvbihpbmRleCkge1xyXG5cdFx0dmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xyXG5cdFx0aWYgKGwgPiAxKSB7XHJcblx0XHRcdHZhciBhID0gW107XHJcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKyspIHsgYVtpXSA9IGFyZ3VtZW50c1tpXTsgfVxyXG5cdFx0XHRhLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYi1hOyB9KTtcclxuXHRcdFx0dmFyIGdvb2QgPSB0cnVlO1xyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7IGdvb2QgPSBnb29kICYmIHRoaXMucmVtb3ZlQ2hpbGRBdChhW2ldKTsgfVxyXG5cdFx0XHRyZXR1cm4gZ29vZDtcclxuXHRcdH1cclxuXHRcdGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLmNoaWxkcmVuLmxlbmd0aC0xKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpbmRleF07XHJcblx0XHRpZiAoY2hpbGQpIHsgY2hpbGQucGFyZW50ID0gbnVsbDsgfVxyXG5cdFx0dGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cdFx0Y2hpbGQuZGlzcGF0Y2hFdmVudChcInJlbW92ZWRcIik7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIGFsbCBjaGlsZHJlbiBmcm9tIHRoZSBkaXNwbGF5IGxpc3QuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiBcdGNvbnRhaW5lci5yZW1vdmVBbGxDaGlsZHJlbigpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCByZW1vdmVBbGxDaGlsZHJlblxyXG5cdCAqKi9cclxuXHRwLnJlbW92ZUFsbENoaWxkcmVuID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIga2lkcyA9IHRoaXMuY2hpbGRyZW47XHJcblx0XHR3aGlsZSAoa2lkcy5sZW5ndGgpIHsgdGhpcy5yZW1vdmVDaGlsZEF0KDApOyB9XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgY2hpbGQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgY29udGFpbmVyLmdldENoaWxkQXQoMik7XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGdldENoaWxkQXRcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBjaGlsZCB0byByZXR1cm4uXHJcblx0ICogQHJldHVybiB7RGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguIFJldHVybnMgbnVsbCBpZiB0aGVyZSBpcyBubyBjaGlsZCBhdCB0aGUgaW5kZXguXHJcblx0ICoqL1xyXG5cdHAuZ2V0Q2hpbGRBdCA9IGZ1bmN0aW9uKGluZGV4KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jaGlsZHJlbltpbmRleF07XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBjaGlsZCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuXHQgKiBAbWV0aG9kIGdldENoaWxkQnlOYW1lXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGNoaWxkIHRvIHJldHVybi5cclxuXHQgKiBAcmV0dXJuIHtEaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcblx0ICoqL1xyXG5cdHAuZ2V0Q2hpbGRCeU5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XHJcblx0XHR2YXIga2lkcyA9IHRoaXMuY2hpbGRyZW47XHJcblx0XHRmb3IgKHZhciBpPTAsbD1raWRzLmxlbmd0aDtpPGw7aSsrKSB7XHJcblx0XHRcdGlmKGtpZHNbaV0ubmFtZSA9PSBuYW1lKSB7IHJldHVybiBraWRzW2ldOyB9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBQZXJmb3JtcyBhbiBhcnJheSBzb3J0IG9wZXJhdGlvbiBvbiB0aGUgY2hpbGQgbGlzdC5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlOiBEaXNwbGF5IGNoaWxkcmVuIHdpdGggYSBoaWdoZXIgeSBpbiBmcm9udC48L2g0PlxyXG5cdCAqIFxyXG5cdCAqICAgICAgdmFyIHNvcnRGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iajEsIG9iajIsIG9wdGlvbnMpIHtcclxuXHQgKiAgICAgICAgICBpZiAob2JqMS55ID4gb2JqMi55KSB7IHJldHVybiAxOyB9XHJcblx0ICogICAgICAgICAgaWYgKG9iajEueSA8IG9iajIueSkgeyByZXR1cm4gLTE7IH1cclxuXHQgKiAgICAgICAgICByZXR1cm4gMDtcclxuXHQgKiAgICAgIH1cclxuXHQgKiAgICAgIGNvbnRhaW5lci5zb3J0Q2hpbGRyZW4oc29ydEZ1bmN0aW9uKTtcclxuXHQgKlxyXG5cdCAqIEBtZXRob2Qgc29ydENoaWxkcmVuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gc29ydEZ1bmN0aW9uIHRoZSBmdW5jdGlvbiB0byB1c2UgdG8gc29ydCB0aGUgY2hpbGQgbGlzdC4gU2VlIEphdmFTY3JpcHQncyA8Y29kZT5BcnJheS5zb3J0PC9jb2RlPlxyXG5cdCAqIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuXHJcblx0ICoqL1xyXG5cdHAuc29ydENoaWxkcmVuID0gZnVuY3Rpb24oc29ydEZ1bmN0aW9uKSB7XHJcblx0XHR0aGlzLmNoaWxkcmVuLnNvcnQoc29ydEZ1bmN0aW9uKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgc3BlY2lmaWVkIGNoaWxkIGluIHRoZSBkaXNwbGF5IGxpc3QsIG9yIC0xIGlmIGl0IGlzIG5vdCBpbiB0aGUgZGlzcGxheSBsaXN0LlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICB2YXIgaW5kZXggPSBjb250YWluZXIuZ2V0Q2hpbGRJbmRleChjaGlsZCk7XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGdldENoaWxkSW5kZXhcclxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IGNoaWxkIFRoZSBjaGlsZCB0byByZXR1cm4gdGhlIGluZGV4IG9mLlxyXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBzcGVjaWZpZWQgY2hpbGQuIC0xIGlmIHRoZSBjaGlsZCBpcyBub3QgZm91bmQuXHJcblx0ICoqL1xyXG5cdHAuZ2V0Q2hpbGRJbmRleCA9IGZ1bmN0aW9uKGNoaWxkKSB7XHJcblx0XHRyZXR1cm4gY3JlYXRlanMuaW5kZXhPZih0aGlzLmNoaWxkcmVuLCBjaGlsZCk7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBTd2FwcyB0aGUgY2hpbGRyZW4gYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzLiBGYWlscyBzaWxlbnRseSBpZiBlaXRoZXIgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxyXG5cdCAqIEBtZXRob2Qgc3dhcENoaWxkcmVuQXRcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXgxXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4MlxyXG5cdCAqKi9cclxuXHRwLnN3YXBDaGlsZHJlbkF0ID0gZnVuY3Rpb24oaW5kZXgxLCBpbmRleDIpIHtcclxuXHRcdHZhciBraWRzID0gdGhpcy5jaGlsZHJlbjtcclxuXHRcdHZhciBvMSA9IGtpZHNbaW5kZXgxXTtcclxuXHRcdHZhciBvMiA9IGtpZHNbaW5kZXgyXTtcclxuXHRcdGlmICghbzEgfHwgIW8yKSB7IHJldHVybjsgfVxyXG5cdFx0a2lkc1tpbmRleDFdID0gbzI7XHJcblx0XHRraWRzW2luZGV4Ml0gPSBvMTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIFN3YXBzIHRoZSBzcGVjaWZpZWQgY2hpbGRyZW4ncyBkZXB0aCBpbiB0aGUgZGlzcGxheSBsaXN0LiBGYWlscyBzaWxlbnRseSBpZiBlaXRoZXIgY2hpbGQgaXMgbm90IGEgY2hpbGQgb2YgdGhpc1xyXG5cdCAqIENvbnRhaW5lci5cclxuXHQgKiBAbWV0aG9kIHN3YXBDaGlsZHJlblxyXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gY2hpbGQxXHJcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBjaGlsZDJcclxuXHQgKiovXHJcblx0cC5zd2FwQ2hpbGRyZW4gPSBmdW5jdGlvbihjaGlsZDEsIGNoaWxkMikge1xyXG5cdFx0dmFyIGtpZHMgPSB0aGlzLmNoaWxkcmVuO1xyXG5cdFx0dmFyIGluZGV4MSxpbmRleDI7XHJcblx0XHRmb3IgKHZhciBpPTAsbD1raWRzLmxlbmd0aDtpPGw7aSsrKSB7XHJcblx0XHRcdGlmIChraWRzW2ldID09IGNoaWxkMSkgeyBpbmRleDEgPSBpOyB9XHJcblx0XHRcdGlmIChraWRzW2ldID09IGNoaWxkMikgeyBpbmRleDIgPSBpOyB9XHJcblx0XHRcdGlmIChpbmRleDEgIT0gbnVsbCAmJiBpbmRleDIgIT0gbnVsbCkgeyBicmVhazsgfVxyXG5cdFx0fVxyXG5cdFx0aWYgKGk9PWwpIHsgcmV0dXJuOyB9IC8vIFRPRE86IHRocm93IGVycm9yP1xyXG5cdFx0a2lkc1tpbmRleDFdID0gY2hpbGQyO1xyXG5cdFx0a2lkc1tpbmRleDJdID0gY2hpbGQxO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogQ2hhbmdlcyB0aGUgZGVwdGggb2YgdGhlIHNwZWNpZmllZCBjaGlsZC4gRmFpbHMgc2lsZW50bHkgaWYgdGhlIGNoaWxkIGlzIG5vdCBhIGNoaWxkIG9mIHRoaXMgY29udGFpbmVyLCBvciB0aGUgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxyXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gY2hpbGRcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggIFxyXG5cdCAqIEBtZXRob2Qgc2V0Q2hpbGRJbmRleFxyXG5cdCAqKi9cclxuXHRwLnNldENoaWxkSW5kZXggPSBmdW5jdGlvbihjaGlsZCwgaW5kZXgpIHtcclxuXHRcdHZhciBraWRzID0gdGhpcy5jaGlsZHJlbiwgbD1raWRzLmxlbmd0aDtcclxuXHRcdGlmIChjaGlsZC5wYXJlbnQgIT0gdGhpcyB8fCBpbmRleCA8IDAgfHwgaW5kZXggPj0gbCkgeyByZXR1cm47IH1cclxuXHRcdGZvciAodmFyIGk9MDtpPGw7aSsrKSB7XHJcblx0XHRcdGlmIChraWRzW2ldID09IGNoaWxkKSB7IGJyZWFrOyB9XHJcblx0XHR9XHJcblx0XHRpZiAoaT09bCB8fCBpID09IGluZGV4KSB7IHJldHVybjsgfVxyXG5cdFx0a2lkcy5zcGxpY2UoaSwxKTtcclxuXHRcdGtpZHMuc3BsaWNlKGluZGV4LDAsY2hpbGQpO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGRpc3BsYXkgb2JqZWN0IGVpdGhlciBpcyB0aGlzIGNvbnRhaW5lciBvciBpcyBhIGRlc2NlbmRlbnQgKGNoaWxkLCBncmFuZGNoaWxkLCBldGMpXHJcblx0ICogb2YgdGhpcyBjb250YWluZXIuXHJcblx0ICogQG1ldGhvZCBjb250YWluc1xyXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gY2hpbGQgVGhlIERpc3BsYXlPYmplY3QgdG8gYmUgY2hlY2tlZC5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgZGlzcGxheSBvYmplY3QgZWl0aGVyIGlzIHRoaXMgY29udGFpbmVyIG9yIGlzIGEgZGVzY2VuZGVudC5cclxuXHQgKiovXHJcblx0cC5jb250YWlucyA9IGZ1bmN0aW9uKGNoaWxkKSB7XHJcblx0XHR3aGlsZSAoY2hpbGQpIHtcclxuXHRcdFx0aWYgKGNoaWxkID09IHRoaXMpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0Y2hpbGQgPSBjaGlsZC5wYXJlbnQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogVGVzdHMgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3QgaW50ZXJzZWN0cyB0aGUgc3BlY2lmaWVkIGxvY2FsIHBvaW50IChpZS4gZHJhd3MgYSBwaXhlbCB3aXRoIGFscGhhID4gMCBhdCB0aGVcclxuXHQgKiBzcGVjaWZpZWQgcG9zaXRpb24pLiBUaGlzIGlnbm9yZXMgdGhlIGFscGhhLCBzaGFkb3cgYW5kIGNvbXBvc2l0ZU9wZXJhdGlvbiBvZiB0aGUgZGlzcGxheSBvYmplY3QsIGFuZCBhbGxcclxuXHQgKiB0cmFuc2Zvcm0gcHJvcGVydGllcyBpbmNsdWRpbmcgcmVnWC9ZLlxyXG5cdCAqIEBtZXRob2QgaGl0VGVzdFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHBvc2l0aW9uIHRvIGNoZWNrIGluIHRoZSBkaXNwbGF5IG9iamVjdCdzIGxvY2FsIGNvb3JkaW5hdGVzLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uIHRvIGNoZWNrIGluIHRoZSBkaXNwbGF5IG9iamVjdCdzIGxvY2FsIGNvb3JkaW5hdGVzLlxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlcmUgaXMgYSB2aXNpYmxlIHNlY3Rpb24gb2YgYSBEaXNwbGF5T2JqZWN0IHRoYXQgb3ZlcmxhcHMgdGhlIHNwZWNpZmllZFxyXG5cdCAqIGNvb3JkaW5hdGVzLlxyXG5cdCAqKi9cclxuXHRwLmhpdFRlc3QgPSBmdW5jdGlvbih4LCB5KSB7XHJcblx0XHQvLyBUT0RPOiBvcHRpbWl6ZSB0byB1c2UgdGhlIGZhc3QgY2FjaGUgY2hlY2sgd2hlcmUgcG9zc2libGUuXHJcblx0XHRyZXR1cm4gKHRoaXMuZ2V0T2JqZWN0VW5kZXJQb2ludCh4LCB5KSAhPSBudWxsKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBkaXNwbGF5IG9iamVjdHMgdW5kZXIgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlcyB0aGF0IGFyZSBpbiB0aGlzIGNvbnRhaW5lcidzIGRpc3BsYXlcclxuXHQgKiBsaXN0LiBUaGlzIHJvdXRpbmUgaWdub3JlcyBhbnkgZGlzcGxheSBvYmplY3RzIHdpdGgge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9tb3VzZUVuYWJsZWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cclxuXHQgKiBzZXQgdG8gYGZhbHNlYC4gVGhlIGFycmF5IHdpbGwgYmUgc29ydGVkIGluIG9yZGVyIG9mIHZpc3VhbCBkZXB0aCwgd2l0aCB0aGUgdG9wLW1vc3QgZGlzcGxheSBvYmplY3QgYXQgaW5kZXggMC5cclxuXHQgKiBUaGlzIHVzZXMgc2hhcGUgYmFzZWQgaGl0IGRldGVjdGlvbiwgYW5kIGNhbiBiZSBhbiBleHBlbnNpdmUgb3BlcmF0aW9uIHRvIHJ1biwgc28gaXQgaXMgYmVzdCB0byB1c2UgaXQgY2FyZWZ1bGx5LlxyXG5cdCAqIEZvciBleGFtcGxlLCBpZiB0ZXN0aW5nIGZvciBvYmplY3RzIHVuZGVyIHRoZSBtb3VzZSwgdGVzdCBvbiB0aWNrIChpbnN0ZWFkIG9mIG9uIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2Vtb3ZlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319KSxcclxuXHQgKiBhbmQgb25seSBpZiB0aGUgbW91c2UncyBwb3NpdGlvbiBoYXMgY2hhbmdlZC5cclxuXHQgKiBcclxuXHQgKiA8dWw+XHJcblx0ICogICAgIDxsaT5CeSBkZWZhdWx0IChtb2RlPTApIHRoaXMgbWV0aG9kIGV2YWx1YXRlcyBhbGwgZGlzcGxheSBvYmplY3RzLjwvbGk+XHJcblx0ICogICAgIDxsaT5CeSBzZXR0aW5nIHRoZSBgbW9kZWAgcGFyYW1ldGVyIHRvIGAxYCwgdGhlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2VFbmFibGVkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XHJcblx0ICogXHRcdGFuZCB7eyNjcm9zc0xpbmsgXCJtb3VzZUNoaWxkcmVuOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnRpZXMgd2lsbCBiZSByZXNwZWN0ZWQuPC9saT5cclxuXHQgKiBcdCAgIDxsaT5TZXR0aW5nIHRoZSBgbW9kZWAgdG8gYDJgIGFkZGl0aW9uYWxseSBleGNsdWRlcyBkaXNwbGF5IG9iamVjdHMgdGhhdCBkbyBub3QgaGF2ZSBhY3RpdmUgbW91c2UgZXZlbnRcclxuXHQgKiBcdCAgIFx0bGlzdGVuZXJzIG9yIGEge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdDpjdXJzb3I6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkuIFRoYXQgaXMsIG9ubHkgb2JqZWN0c1xyXG5cdCAqIFx0ICAgXHR0aGF0IHdvdWxkIG5vcm1hbGx5IGludGVyY2VwdCBtb3VzZSBpbnRlcmFjdGlvbiB3aWxsIGJlIGluY2x1ZGVkLiBUaGlzIGNhbiBzaWduaWZpY2FudGx5IGltcHJvdmUgcGVyZm9ybWFuY2VcclxuXHQgKiBcdCAgIFx0aW4gc29tZSBjYXNlcyBieSByZWR1Y2luZyB0aGUgbnVtYmVyIG9mIGRpc3BsYXkgb2JqZWN0cyB0aGF0IG5lZWQgdG8gYmUgdGVzdGVkLjwvbGk+XHJcblx0ICogPC9saT5cclxuXHQgKiBcclxuXHQgKiBUaGlzIG1ldGhvZCBhY2NvdW50cyBmb3IgYm90aCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2hpdEFyZWE6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbWFzazpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cclxuXHQgKiBAbWV0aG9kIGdldE9iamVjdHNVbmRlclBvaW50XHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gaW4gdGhlIGNvbnRhaW5lciB0byB0ZXN0LlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uIGluIHRoZSBjb250YWluZXIgdG8gdGVzdC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW21vZGU9MF0gVGhlIG1vZGUgdG8gdXNlIHRvIGRldGVybWluZSB3aGljaCBkaXNwbGF5IG9iamVjdHMgdG8gaW5jbHVkZS4gMC1hbGwsIDEtcmVzcGVjdCBtb3VzZUVuYWJsZWQvbW91c2VDaGlsZHJlbiwgMi1vbmx5IG1vdXNlIG9wYXF1ZSBvYmplY3RzLlxyXG5cdCAqIEByZXR1cm4ge0FycmF5fSBBbiBBcnJheSBvZiBEaXNwbGF5T2JqZWN0cyB1bmRlciB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGVzLlxyXG5cdCAqKi9cclxuXHRwLmdldE9iamVjdHNVbmRlclBvaW50ID0gZnVuY3Rpb24oeCwgeSwgbW9kZSkge1xyXG5cdFx0dmFyIGFyciA9IFtdO1xyXG5cdFx0dmFyIHB0ID0gdGhpcy5sb2NhbFRvR2xvYmFsKHgsIHkpO1xyXG5cdFx0dGhpcy5fZ2V0T2JqZWN0c1VuZGVyUG9pbnQocHQueCwgcHQueSwgYXJyLCBtb2RlPjAsIG1vZGU9PTEpO1xyXG5cdFx0cmV0dXJuIGFycjtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBTaW1pbGFyIHRvIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lci9nZXRPYmplY3RzVW5kZXJQb2ludFwifX17ey9jcm9zc0xpbmt9fSwgYnV0IHJldHVybnMgb25seSB0aGUgdG9wLW1vc3QgZGlzcGxheVxyXG5cdCAqIG9iamVjdC4gVGhpcyBydW5zIHNpZ25pZmljYW50bHkgZmFzdGVyIHRoYW4gPGNvZGU+Z2V0T2JqZWN0c1VuZGVyUG9pbnQoKTwvY29kZT4sIGJ1dCBpcyBzdGlsbCBwb3RlbnRpYWxseSBhbiBleHBlbnNpdmVcclxuXHQgKiBvcGVyYXRpb24uIFNlZSB7eyNjcm9zc0xpbmsgXCJDb250YWluZXIvZ2V0T2JqZWN0c1VuZGVyUG9pbnRcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcblx0ICogQG1ldGhvZCBnZXRPYmplY3RVbmRlclBvaW50XHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gaW4gdGhlIGNvbnRhaW5lciB0byB0ZXN0LlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uIGluIHRoZSBjb250YWluZXIgdG8gdGVzdC5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gbW9kZSBUaGUgbW9kZSB0byB1c2UgdG8gZGV0ZXJtaW5lIHdoaWNoIGRpc3BsYXkgb2JqZWN0cyB0byBpbmNsdWRlLiAgMC1hbGwsIDEtcmVzcGVjdCBtb3VzZUVuYWJsZWQvbW91c2VDaGlsZHJlbiwgMi1vbmx5IG1vdXNlIG9wYXF1ZSBvYmplY3RzLlxyXG5cdCAqIEByZXR1cm4ge0Rpc3BsYXlPYmplY3R9IFRoZSB0b3AtbW9zdCBkaXNwbGF5IG9iamVjdCB1bmRlciB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGVzLlxyXG5cdCAqKi9cclxuXHRwLmdldE9iamVjdFVuZGVyUG9pbnQgPSBmdW5jdGlvbih4LCB5LCBtb2RlKSB7XHJcblx0XHR2YXIgcHQgPSB0aGlzLmxvY2FsVG9HbG9iYWwoeCwgeSk7XHJcblx0XHRyZXR1cm4gdGhpcy5fZ2V0T2JqZWN0c1VuZGVyUG9pbnQocHQueCwgcHQueSwgbnVsbCwgbW9kZT4wLCBtb2RlPT0xKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIERvY2NlZCBpbiBzdXBlcmNsYXNzLlxyXG5cdCAqL1xyXG5cdHAuZ2V0Qm91bmRzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fZ2V0Qm91bmRzKG51bGwsIHRydWUpO1xyXG5cdH07XHJcblx0XHJcblx0XHJcblx0LyoqXHJcblx0ICogRG9jY2VkIGluIHN1cGVyY2xhc3MuXHJcblx0ICovXHJcblx0cC5nZXRUcmFuc2Zvcm1lZEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2dldEJvdW5kcygpO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGlzIENvbnRhaW5lci4gU29tZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIHNwZWNpZmljIHRvIHRoaXMgaW5zdGFuY2UncyBjdXJyZW50IGNvbnRleHQgYXJlXHJcblx0ICogcmV2ZXJ0ZWQgdG8gdGhlaXIgZGVmYXVsdHMgKGZvciBleGFtcGxlIC5wYXJlbnQpLlxyXG5cdCAqIEBtZXRob2QgY2xvbmVcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWN1cnNpdmU9ZmFsc2VdIElmIHRydWUsIGFsbCBvZiB0aGUgZGVzY2VuZGFudHMgb2YgdGhpcyBjb250YWluZXIgd2lsbCBiZSBjbG9uZWQgcmVjdXJzaXZlbHkuIElmIGZhbHNlLCB0aGVcclxuXHQgKiBwcm9wZXJ0aWVzIG9mIHRoZSBjb250YWluZXIgd2lsbCBiZSBjbG9uZWQsIGJ1dCB0aGUgbmV3IGluc3RhbmNlIHdpbGwgbm90IGhhdmUgYW55IGNoaWxkcmVuLlxyXG5cdCAqIEByZXR1cm4ge0NvbnRhaW5lcn0gQSBjbG9uZSBvZiB0aGUgY3VycmVudCBDb250YWluZXIgaW5zdGFuY2UuXHJcblx0ICoqL1xyXG5cdHAuY2xvbmUgPSBmdW5jdGlvbihyZWN1cnNpdmUpIHtcclxuXHRcdHZhciBvID0gdGhpcy5fY2xvbmVQcm9wcyhuZXcgQ29udGFpbmVyKCkpO1xyXG5cdFx0aWYgKHJlY3Vyc2l2ZSkgeyB0aGlzLl9jbG9uZUNoaWxkcmVuKG8pOyB9XHJcblx0XHRyZXR1cm4gbztcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxyXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cclxuXHQgKiovXHJcblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIFwiW0NvbnRhaW5lciAobmFtZT1cIisgIHRoaXMubmFtZSArXCIpXVwiO1xyXG5cdH07XHJcblxyXG5cclxuLy8gcHJpdmF0ZSBtZXRob2RzOlxyXG5cdC8qKlxyXG5cdCAqIEBtZXRob2QgX3RpY2tcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZ0T2JqIEFuIGV2ZW50IG9iamVjdCB0aGF0IHdpbGwgYmUgZGlzcGF0Y2hlZCB0byBhbGwgdGljayBsaXN0ZW5lcnMuIFRoaXMgb2JqZWN0IGlzIHJldXNlZCBiZXR3ZWVuIGRpc3BhdGNoZXJzIHRvIHJlZHVjZSBjb25zdHJ1Y3Rpb24gJiBHQyBjb3N0cy5cclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICoqL1xyXG5cdHAuX3RpY2sgPSBmdW5jdGlvbihldnRPYmopIHtcclxuXHRcdGlmICh0aGlzLnRpY2tDaGlsZHJlbikge1xyXG5cdFx0XHRmb3IgKHZhciBpPXRoaXMuY2hpbGRyZW4ubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xyXG5cdFx0XHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XHJcblx0XHRcdFx0aWYgKGNoaWxkLnRpY2tFbmFibGVkICYmIGNoaWxkLl90aWNrKSB7IGNoaWxkLl90aWNrKGV2dE9iaik7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X190aWNrKGV2dE9iaik7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBSZWN1cnNpdmVseSBjbG9uZXMgYWxsIGNoaWxkcmVuIG9mIHRoaXMgY29udGFpbmVyLCBhbmQgYWRkcyB0aGVtIHRvIHRoZSB0YXJnZXQgY29udGFpbmVyLlxyXG5cdCAqIEBtZXRob2QgY2xvbmVDaGlsZHJlblxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiBAcGFyYW0ge0NvbnRhaW5lcn0gbyBUaGUgdGFyZ2V0IGNvbnRhaW5lci5cclxuXHQgKiovXHJcblx0cC5fY2xvbmVDaGlsZHJlbiA9IGZ1bmN0aW9uKG8pIHtcclxuXHRcdGlmIChvLmNoaWxkcmVuLmxlbmd0aCkgeyBvLnJlbW92ZUFsbENoaWxkcmVuKCk7IH1cclxuXHRcdHZhciBhcnIgPSBvLmNoaWxkcmVuO1xyXG5cdFx0Zm9yICh2YXIgaT0wLCBsPXRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpPGw7IGkrKykge1xyXG5cdFx0XHR2YXIgY2xvbmUgPSB0aGlzLmNoaWxkcmVuW2ldLmNsb25lKHRydWUpO1xyXG5cdFx0XHRjbG9uZS5wYXJlbnQgPSBvO1xyXG5cdFx0XHRhcnIucHVzaChjbG9uZSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQG1ldGhvZCBfZ2V0T2JqZWN0c1VuZGVyUG9pbnRcclxuXHQgKiBAcGFyYW0ge051bWJlcn0geFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XHJcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBtb3VzZSBJZiB0cnVlLCBpdCB3aWxsIHJlc3BlY3QgbW91c2UgaW50ZXJhY3Rpb24gcHJvcGVydGllcyBsaWtlIG1vdXNlRW5hYmxlZCwgbW91c2VDaGlsZHJlbiwgYW5kIGFjdGl2ZSBsaXN0ZW5lcnMuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBhY3RpdmVMaXN0ZW5lciBJZiB0cnVlLCB0aGVyZSBpcyBhbiBhY3RpdmUgbW91c2UgZXZlbnQgbGlzdGVuZXIgb24gYSBwYXJlbnQgb2JqZWN0LlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjdXJyZW50RGVwdGggSW5kaWNhdGVzIHRoZSBjdXJyZW50IGRlcHRoIG9mIHRoZSBzZWFyY2guXHJcblx0ICogQHJldHVybiB7RGlzcGxheU9iamVjdH1cclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICoqL1xyXG5cdHAuX2dldE9iamVjdHNVbmRlclBvaW50ID0gZnVuY3Rpb24oeCwgeSwgYXJyLCBtb3VzZSwgYWN0aXZlTGlzdGVuZXIsIGN1cnJlbnREZXB0aCkge1xyXG5cdFx0Y3VycmVudERlcHRoID0gY3VycmVudERlcHRoIHx8IDA7XHJcblx0XHRpZiAoIWN1cnJlbnREZXB0aCAmJiAhdGhpcy5fdGVzdE1hc2sodGhpcywgeCwgeSkpIHsgcmV0dXJuIG51bGw7IH1cclxuXHRcdHZhciBtdHgsIGN0eCA9IGNyZWF0ZWpzLkRpc3BsYXlPYmplY3QuX2hpdFRlc3RDb250ZXh0O1xyXG5cdFx0YWN0aXZlTGlzdGVuZXIgPSBhY3RpdmVMaXN0ZW5lciB8fCAobW91c2UmJnRoaXMuX2hhc01vdXNlRXZlbnRMaXN0ZW5lcigpKTtcclxuXHJcblx0XHQvLyBkcmF3IGNoaWxkcmVuIG9uZSBhdCBhIHRpbWUsIGFuZCBjaGVjayBpZiB3ZSBnZXQgYSBoaXQ6XHJcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLCBsID0gY2hpbGRyZW4ubGVuZ3RoO1xyXG5cdFx0Zm9yICh2YXIgaT1sLTE7IGk+PTA7IGktLSkge1xyXG5cdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuXHRcdFx0dmFyIGhpdEFyZWEgPSBjaGlsZC5oaXRBcmVhO1xyXG5cdFx0XHRpZiAoIWNoaWxkLnZpc2libGUgfHwgKCFoaXRBcmVhICYmICFjaGlsZC5pc1Zpc2libGUoKSkgfHwgKG1vdXNlICYmICFjaGlsZC5tb3VzZUVuYWJsZWQpKSB7IGNvbnRpbnVlOyB9XHJcblx0XHRcdGlmICghaGl0QXJlYSAmJiAhdGhpcy5fdGVzdE1hc2soY2hpbGQsIHgsIHkpKSB7IGNvbnRpbnVlOyB9XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBpZiBhIGNoaWxkIGNvbnRhaW5lciBoYXMgYSBoaXRBcmVhIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGl0cyBoaXRBcmVhLCBzbyB3ZSBjYW4gdHJlYXQgaXQgYXMgYSBub3JtYWwgRE86XHJcblx0XHRcdGlmICghaGl0QXJlYSAmJiBjaGlsZCBpbnN0YW5jZW9mIENvbnRhaW5lcikge1xyXG5cdFx0XHRcdHZhciByZXN1bHQgPSBjaGlsZC5fZ2V0T2JqZWN0c1VuZGVyUG9pbnQoeCwgeSwgYXJyLCBtb3VzZSwgYWN0aXZlTGlzdGVuZXIsIGN1cnJlbnREZXB0aCsxKTtcclxuXHRcdFx0XHRpZiAoIWFyciAmJiByZXN1bHQpIHsgcmV0dXJuIChtb3VzZSAmJiAhdGhpcy5tb3VzZUNoaWxkcmVuKSA/IHRoaXMgOiByZXN1bHQ7IH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiAobW91c2UgJiYgIWFjdGl2ZUxpc3RlbmVyICYmICFjaGlsZC5faGFzTW91c2VFdmVudExpc3RlbmVyKCkpIHsgY29udGludWU7IH1cclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBUT0RPOiBjYW4gd2UgcGFzcyBkaXNwbGF5UHJvcHMgZm9yd2FyZCwgdG8gYXZvaWQgaGF2aW5nIHRvIGNhbGN1bGF0ZSB0aGlzIGJhY2t3YXJkcyBldmVyeSB0aW1lPyBJdCdzIGtpbmQgb2YgYSBtaXhlZCBiYWcuIFdoZW4gd2UncmUgb25seSBodW50aW5nIGZvciBET3Mgd2l0aCBldmVudCBsaXN0ZW5lcnMsIGl0IG1heSBub3QgbWFrZSBzZW5zZS5cclxuXHRcdFx0XHR2YXIgcHJvcHMgPSBjaGlsZC5nZXRDb25jYXRlbmF0ZWREaXNwbGF5UHJvcHMoY2hpbGQuX3Byb3BzKTtcclxuXHRcdFx0XHRtdHggPSBwcm9wcy5tYXRyaXg7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0aWYgKGhpdEFyZWEpIHtcclxuXHRcdFx0XHRcdG10eC5hcHBlbmRNYXRyaXgoaGl0QXJlYS5nZXRNYXRyaXgoaGl0QXJlYS5fcHJvcHMubWF0cml4KSk7XHJcblx0XHRcdFx0XHRwcm9wcy5hbHBoYSA9IGhpdEFyZWEuYWxwaGE7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IHByb3BzLmFscGhhO1xyXG5cdFx0XHRcdGN0eC5zZXRUcmFuc2Zvcm0obXR4LmEsICBtdHguYiwgbXR4LmMsIG10eC5kLCBtdHgudHgteCwgbXR4LnR5LXkpO1xyXG5cdFx0XHRcdChoaXRBcmVhfHxjaGlsZCkuZHJhdyhjdHgpO1xyXG5cdFx0XHRcdGlmICghdGhpcy5fdGVzdEhpdChjdHgpKSB7IGNvbnRpbnVlOyB9XHJcblx0XHRcdFx0Y3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcclxuXHRcdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIDIsIDIpO1xyXG5cdFx0XHRcdGlmIChhcnIpIHsgYXJyLnB1c2goY2hpbGQpOyB9XHJcblx0XHRcdFx0ZWxzZSB7IHJldHVybiAobW91c2UgJiYgIXRoaXMubW91c2VDaGlsZHJlbikgPyB0aGlzIDogY2hpbGQ7IH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIF90ZXN0TWFza1xyXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gdGFyZ2V0XHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuXHQgKiBAcGFyYW0ge051bWJlcn0geVxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEluZGljYXRlcyB3aGV0aGVyIHRoZSB4L3kgaXMgd2l0aGluIHRoZSBtYXNrZWQgcmVnaW9uLlxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiovXHJcblx0cC5fdGVzdE1hc2sgPSBmdW5jdGlvbih0YXJnZXQsIHgsIHkpIHtcclxuXHRcdHZhciBtYXNrID0gdGFyZ2V0Lm1hc2s7XHJcblx0XHRpZiAoIW1hc2sgfHwgIW1hc2suZ3JhcGhpY3MgfHwgbWFzay5ncmFwaGljcy5pc0VtcHR5KCkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFxyXG5cdFx0dmFyIG10eCA9IHRoaXMuX3Byb3BzLm1hdHJpeCwgcGFyZW50ID0gdGFyZ2V0LnBhcmVudDtcclxuXHRcdG10eCA9IHBhcmVudCA/IHBhcmVudC5nZXRDb25jYXRlbmF0ZWRNYXRyaXgobXR4KSA6IG10eC5pZGVudGl0eSgpO1xyXG5cdFx0bXR4ID0gbWFzay5nZXRNYXRyaXgobWFzay5fcHJvcHMubWF0cml4KS5wcmVwZW5kTWF0cml4KG10eCk7XHJcblx0XHRcclxuXHRcdHZhciBjdHggPSBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0Ll9oaXRUZXN0Q29udGV4dDtcclxuXHRcdGN0eC5zZXRUcmFuc2Zvcm0obXR4LmEsICBtdHguYiwgbXR4LmMsIG10eC5kLCBtdHgudHgteCwgbXR4LnR5LXkpO1xyXG5cdFx0XHJcblx0XHQvLyBkcmF3IHRoZSBtYXNrIGFzIGEgc29saWQgZmlsbDpcclxuXHRcdG1hc2suZ3JhcGhpY3MuZHJhd0FzUGF0aChjdHgpO1xyXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IFwiIzAwMFwiO1xyXG5cdFx0Y3R4LmZpbGwoKTtcclxuXHRcdFxyXG5cdFx0aWYgKCF0aGlzLl90ZXN0SGl0KGN0eCkpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xyXG5cdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCAyLCAyKTtcclxuXHRcdFxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIF9nZXRCb3VuZHNcclxuXHQgKiBAcGFyYW0ge01hdHJpeDJEfSBtYXRyaXhcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZVRyYW5zZm9ybSBJZiB0cnVlLCBkb2VzIG5vdCBhcHBseSB0aGlzIG9iamVjdCdzIHRyYW5zZm9ybS5cclxuXHQgKiBAcmV0dXJuIHtSZWN0YW5nbGV9XHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqKi9cclxuXHRwLl9nZXRCb3VuZHMgPSBmdW5jdGlvbihtYXRyaXgsIGlnbm9yZVRyYW5zZm9ybSkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuRGlzcGxheU9iamVjdF9nZXRCb3VuZHMoKTtcclxuXHRcdGlmIChib3VuZHMpIHsgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybUJvdW5kcyhib3VuZHMsIG1hdHJpeCwgaWdub3JlVHJhbnNmb3JtKTsgfVxyXG5cdFx0XHJcblx0XHR2YXIgbXR4ID0gdGhpcy5fcHJvcHMubWF0cml4O1xyXG5cdFx0bXR4ID0gaWdub3JlVHJhbnNmb3JtID8gbXR4LmlkZW50aXR5KCkgOiB0aGlzLmdldE1hdHJpeChtdHgpO1xyXG5cdFx0aWYgKG1hdHJpeCkgeyBtdHgucHJlcGVuZE1hdHJpeChtYXRyaXgpOyB9XHJcblx0XHRcclxuXHRcdHZhciBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGgsIHJlY3Q9bnVsbDtcclxuXHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKyspIHtcclxuXHRcdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcclxuXHRcdFx0aWYgKCFjaGlsZC52aXNpYmxlIHx8ICEoYm91bmRzID0gY2hpbGQuX2dldEJvdW5kcyhtdHgpKSkgeyBjb250aW51ZTsgfVxyXG5cdFx0XHRpZiAocmVjdCkgeyByZWN0LmV4dGVuZChib3VuZHMueCwgYm91bmRzLnksIGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCk7IH1cclxuXHRcdFx0ZWxzZSB7IHJlY3QgPSBib3VuZHMuY2xvbmUoKTsgfVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlY3Q7XHJcblx0fTtcclxuXHJcblxyXG5cdGNyZWF0ZWpzLkNvbnRhaW5lciA9IGNyZWF0ZWpzLnByb21vdGUoQ29udGFpbmVyLCBcIkRpc3BsYXlPYmplY3RcIik7XHJcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTdGFnZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogQSBzdGFnZSBpcyB0aGUgcm9vdCBsZXZlbCB7eyNjcm9zc0xpbmsgXCJDb250YWluZXJcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGEgZGlzcGxheSBsaXN0LiBFYWNoIHRpbWUgaXRzIHt7I2Nyb3NzTGluayBcIlN0YWdlL3RpY2tcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kIGlzIGNhbGxlZCwgaXQgd2lsbCByZW5kZXIgaXRzIGRpc3BsYXkgbGlzdCB0byBpdHMgdGFyZ2V0IGNhbnZhcy5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBUaGlzIGV4YW1wbGUgY3JlYXRlcyBhIHN0YWdlLCBhZGRzIGEgY2hpbGQgdG8gaXQsIHRoZW4gdXNlcyB7eyNjcm9zc0xpbmsgXCJUaWNrZXJcIn19e3svY3Jvc3NMaW5rfX0gdG8gdXBkYXRlIHRoZSBjaGlsZFxuXHQgKiBhbmQgcmVkcmF3IHRoZSBzdGFnZSB1c2luZyB7eyNjcm9zc0xpbmsgXCJTdGFnZS91cGRhdGVcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqICAgICAgdmFyIHN0YWdlID0gbmV3IGNyZWF0ZWpzLlN0YWdlKFwiY2FudmFzRWxlbWVudElkXCIpO1xuXHQgKiAgICAgIHZhciBpbWFnZSA9IG5ldyBjcmVhdGVqcy5CaXRtYXAoXCJpbWFnZVBhdGgucG5nXCIpO1xuXHQgKiAgICAgIHN0YWdlLmFkZENoaWxkKGltYWdlKTtcblx0ICogICAgICBjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgaGFuZGxlVGljayk7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlVGljayhldmVudCkge1xuXHQgKiAgICAgICAgICBpbWFnZS54ICs9IDEwO1xuXHQgKiAgICAgICAgICBzdGFnZS51cGRhdGUoKTtcblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBjbGFzcyBTdGFnZVxuXHQgKiBAZXh0ZW5kcyBDb250YWluZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnQgfCBTdHJpbmcgfCBPYmplY3R9IGNhbnZhcyBBIGNhbnZhcyBvYmplY3QgdGhhdCB0aGUgU3RhZ2Ugd2lsbCByZW5kZXIgdG8sIG9yIHRoZSBzdHJpbmcgaWRcblx0ICogb2YgYSBjYW52YXMgb2JqZWN0IGluIHRoZSBjdXJyZW50IGRvY3VtZW50LlxuXHQgKiovXG5cdGZ1bmN0aW9uIFN0YWdlKGNhbnZhcykge1xuXHRcdHRoaXMuQ29udGFpbmVyX2NvbnN0cnVjdG9yKCk7XG5cdFxuXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN0YWdlIHNob3VsZCBhdXRvbWF0aWNhbGx5IGNsZWFyIHRoZSBjYW52YXMgYmVmb3JlIGVhY2ggcmVuZGVyLiBZb3UgY2FuIHNldCB0aGlzIHRvIDxjb2RlPmZhbHNlPC9jb2RlPlxuXHRcdCAqIHRvIG1hbnVhbGx5IGNvbnRyb2wgY2xlYXJpbmcgKGZvciBnZW5lcmF0aXZlIGFydCwgb3Igd2hlbiBwb2ludGluZyBtdWx0aXBsZSBzdGFnZXMgYXQgdGhlIHNhbWUgY2FudmFzIGZvclxuXHRcdCAqIGV4YW1wbGUpLlxuXHRcdCAqXG5cdFx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHRcdCAqXG5cdFx0ICogICAgICB2YXIgc3RhZ2UgPSBuZXcgY3JlYXRlanMuU3RhZ2UoXCJjYW52YXNJZFwiKTtcblx0XHQgKiAgICAgIHN0YWdlLmF1dG9DbGVhciA9IGZhbHNlO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IGF1dG9DbGVhclxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICoqL1xuXHRcdHRoaXMuYXV0b0NsZWFyID0gdHJ1ZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGNhbnZhcyB0aGUgc3RhZ2Ugd2lsbCByZW5kZXIgdG8uIE11bHRpcGxlIHN0YWdlcyBjYW4gc2hhcmUgYSBzaW5nbGUgY2FudmFzLCBidXQgeW91IG11c3QgZGlzYWJsZSBhdXRvQ2xlYXIgZm9yIGFsbCBidXQgdGhlXG5cdFx0ICogZmlyc3Qgc3RhZ2UgdGhhdCB3aWxsIGJlIHRpY2tlZCAob3IgdGhleSB3aWxsIGNsZWFyIGVhY2ggb3RoZXIncyByZW5kZXIpLlxuXHRcdCAqXG5cdFx0ICogV2hlbiBjaGFuZ2luZyB0aGUgY2FudmFzIHByb3BlcnR5IHlvdSBtdXN0IGRpc2FibGUgdGhlIGV2ZW50cyBvbiB0aGUgb2xkIGNhbnZhcywgYW5kIGVuYWJsZSBldmVudHMgb24gdGhlXG5cdFx0ICogbmV3IGNhbnZhcyBvciBtb3VzZSBldmVudHMgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZC4gRm9yIGV4YW1wbGU6XG5cdFx0ICpcblx0XHQgKiAgICAgIG15U3RhZ2UuZW5hYmxlRE9NRXZlbnRzKGZhbHNlKTtcblx0XHQgKiAgICAgIG15U3RhZ2UuY2FudmFzID0gYW5vdGhlckNhbnZhcztcblx0XHQgKiAgICAgIG15U3RhZ2UuZW5hYmxlRE9NRXZlbnRzKHRydWUpO1xuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IGNhbnZhc1xuXHRcdCAqIEB0eXBlIEhUTUxDYW52YXNFbGVtZW50IHwgT2JqZWN0XG5cdFx0ICoqL1xuXHRcdHRoaXMuY2FudmFzID0gKHR5cGVvZiBjYW52YXMgPT0gXCJzdHJpbmdcIikgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXMpIDogY2FudmFzO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgY3VycmVudCBtb3VzZSBYIHBvc2l0aW9uIG9uIHRoZSBjYW52YXMuIElmIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIGNhbnZhcywgdGhpcyB3aWxsIGluZGljYXRlIHRoZSBtb3N0IHJlY2VudFxuXHRcdCAqIHBvc2l0aW9uIG92ZXIgdGhlIGNhbnZhcywgYW5kIG1vdXNlSW5Cb3VuZHMgd2lsbCBiZSBzZXQgdG8gZmFsc2UuXG5cdFx0ICogQHByb3BlcnR5IG1vdXNlWFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLm1vdXNlWCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IG1vdXNlIFkgcG9zaXRpb24gb24gdGhlIGNhbnZhcy4gSWYgdGhlIG1vdXNlIGxlYXZlcyB0aGUgY2FudmFzLCB0aGlzIHdpbGwgaW5kaWNhdGUgdGhlIG1vc3QgcmVjZW50XG5cdFx0ICogcG9zaXRpb24gb3ZlciB0aGUgY2FudmFzLCBhbmQgbW91c2VJbkJvdW5kcyB3aWxsIGJlIHNldCB0byBmYWxzZS5cblx0XHQgKiBAcHJvcGVydHkgbW91c2VZXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMubW91c2VZID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogU3BlY2lmaWVzIHRoZSBhcmVhIG9mIHRoZSBzdGFnZSB0byBhZmZlY3Qgd2hlbiBjYWxsaW5nIHVwZGF0ZS4gVGhpcyBjYW4gYmUgdXNlIHRvIHNlbGVjdGl2ZWx5XG5cdFx0ICogcmUtZHJhdyBzcGVjaWZpYyByZWdpb25zIG9mIHRoZSBjYW52YXMuIElmIG51bGwsIHRoZSB3aG9sZSBjYW52YXMgYXJlYSBpcyBkcmF3bi5cblx0XHQgKiBAcHJvcGVydHkgZHJhd1JlY3Rcblx0XHQgKiBAdHlwZSB7UmVjdGFuZ2xlfVxuXHRcdCAqL1xuXHRcdHRoaXMuZHJhd1JlY3QgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciBkaXNwbGF5IG9iamVjdHMgc2hvdWxkIGJlIHJlbmRlcmVkIG9uIHdob2xlIHBpeGVscy4gWW91IGNhbiBzZXQgdGhlXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9zbmFwVG9QaXhlbFwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBvZlxuXHRcdCAqIGRpc3BsYXkgb2JqZWN0cyB0byBmYWxzZSB0byBlbmFibGUvZGlzYWJsZSB0aGlzIGJlaGF2aW91ciBvbiBhIHBlciBpbnN0YW5jZSBiYXNpcy5cblx0XHQgKiBAcHJvcGVydHkgc25hcFRvUGl4ZWxFbmFibGVkXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICoqL1xuXHRcdHRoaXMuc25hcFRvUGl4ZWxFbmFibGVkID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBtb3VzZSBpcyBjdXJyZW50bHkgd2l0aGluIHRoZSBib3VuZHMgb2YgdGhlIGNhbnZhcy5cblx0XHQgKiBAcHJvcGVydHkgbW91c2VJbkJvdW5kc1xuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqKi9cblx0XHR0aGlzLm1vdXNlSW5Cb3VuZHMgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgdHJ1ZSwgdGljayBjYWxsYmFja3Mgd2lsbCBiZSBjYWxsZWQgb24gYWxsIGRpc3BsYXkgb2JqZWN0cyBvbiB0aGUgc3RhZ2UgcHJpb3IgdG8gcmVuZGVyaW5nIHRvIHRoZSBjYW52YXMuXG5cdFx0ICogQHByb3BlcnR5IHRpY2tPblVwZGF0ZVxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICoqL1xuXHRcdHRoaXMudGlja09uVXBkYXRlID0gdHJ1ZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgdHJ1ZSwgbW91c2UgbW92ZSBldmVudHMgd2lsbCBjb250aW51ZSB0byBiZSBjYWxsZWQgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSB0YXJnZXQgY2FudmFzLiBTZWVcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJTdGFnZS9tb3VzZUluQm91bmRzOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LCBhbmQge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIHgveS9yYXdYL3Jhd1kuXG5cdFx0ICogQHByb3BlcnR5IG1vdXNlTW92ZU91dHNpZGVcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiovXG5cdFx0dGhpcy5tb3VzZU1vdmVPdXRzaWRlID0gZmFsc2U7XG5cdFx0XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogUHJldmVudHMgc2VsZWN0aW9uIG9mIG90aGVyIGVsZW1lbnRzIGluIHRoZSBodG1sIHBhZ2UgaWYgdGhlIHVzZXIgY2xpY2tzIGFuZCBkcmFncywgb3IgZG91YmxlIGNsaWNrcyBvbiB0aGUgY2FudmFzLlxuXHRcdCAqIFRoaXMgd29ya3MgYnkgY2FsbGluZyBgcHJldmVudERlZmF1bHQoKWAgb24gYW55IG1vdXNlZG93biBldmVudHMgKG9yIHRvdWNoIGVxdWl2YWxlbnQpIG9yaWdpbmF0aW5nIG9uIHRoZSBjYW52YXMuXG5cdFx0ICogQHByb3BlcnR5IHByZXZlbnRTZWxlY3Rpb25cblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgdHJ1ZVxuXHRcdCAqKi9cblx0XHR0aGlzLnByZXZlbnRTZWxlY3Rpb24gPSB0cnVlO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgaGl0QXJlYSBwcm9wZXJ0eSBpcyBub3Qgc3VwcG9ydGVkIGZvciBTdGFnZS5cblx0XHQgKiBAcHJvcGVydHkgaGl0QXJlYVxuXHRcdCAqIEB0eXBlIHtEaXNwbGF5T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHQgXG5cdFx0IFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogSG9sZHMgb2JqZWN0cyB3aXRoIGRhdGEgZm9yIGVhY2ggYWN0aXZlIHBvaW50ZXIgaWQuIEVhY2ggb2JqZWN0IGhhcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cdFx0ICogeCwgeSwgZXZlbnQsIHRhcmdldCwgb3ZlclRhcmdldCwgb3ZlclgsIG92ZXJZLCBpbkJvdW5kcywgcG9zRXZ0T2JqIChuYXRpdmUgZXZlbnQgdGhhdCBsYXN0IHVwZGF0ZWQgcG9zaXRpb24pXG5cdFx0ICogQHByb3BlcnR5IF9wb2ludGVyRGF0YVxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9wb2ludGVyRGF0YSA9IHt9O1xuXHRcblx0XHQvKipcblx0XHQgKiBOdW1iZXIgb2YgYWN0aXZlIHBvaW50ZXJzLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcG9pbnRlckNvdW50XG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3BvaW50ZXJDb3VudCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBJRCBvZiB0aGUgcHJpbWFyeSBwb2ludGVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcHJpbWFyeVBvaW50ZXJJRFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9wcmltYXJ5UG9pbnRlcklEID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9tb3VzZU92ZXJJbnRlcnZhbElEXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9tb3VzZU92ZXJJbnRlcnZhbElEID0gbnVsbDtcblx0XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX25leHRTdGFnZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBTdGFnZVxuXHRcdCAqKi9cblx0XHR0aGlzLl9uZXh0U3RhZ2UgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfcHJldlN0YWdlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIFN0YWdlXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3ByZXZTdGFnZSA9IG51bGw7XG5cdFx0XG5cdFx0XG5cdC8vIGluaXRpYWxpemU6XG5cdFx0dGhpcy5lbmFibGVET01FdmVudHModHJ1ZSk7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoU3RhZ2UsIGNyZWF0ZWpzLkNvbnRhaW5lcik7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cbi8vIGV2ZW50czpcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiB0aGUgdXNlciBtb3ZlcyB0aGUgbW91c2Ugb3ZlciB0aGUgY2FudmFzLlxuXHQgKiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxuXHQgKiBAZXZlbnQgc3RhZ2Vtb3VzZW1vdmVcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyB0aGVpciBsZWZ0IG1vdXNlIGJ1dHRvbiBvbiB0aGUgY2FudmFzLiBTZWUgdGhlIHt7I2Nyb3NzTGluayBcIk1vdXNlRXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogY2xhc3MgZm9yIGEgbGlzdGluZyBvZiBldmVudCBwcm9wZXJ0aWVzLlxuXHQgKiBAZXZlbnQgc3RhZ2Vtb3VzZWRvd25cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIHVzZXIgdGhlIHVzZXIgcHJlc3NlcyBzb21ld2hlcmUgb24gdGhlIHN0YWdlLCB0aGVuIHJlbGVhc2VzIHRoZSBtb3VzZSBidXR0b24gYW55d2hlcmUgdGhhdCB0aGUgcGFnZSBjYW4gZGV0ZWN0IGl0ICh0aGlzIHZhcmllcyBzbGlnaHRseSBiZXR3ZWVuIGJyb3dzZXJzKS5cblx0ICogWW91IGNhbiB1c2Uge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvbW91c2VJbkJvdW5kczpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSB0byBjaGVjayB3aGV0aGVyIHRoZSBtb3VzZSBpcyBjdXJyZW50bHkgd2l0aGluIHRoZSBzdGFnZSBib3VuZHMuXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXG5cdCAqIEBldmVudCBzdGFnZW1vdXNldXBcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIG1vdXNlIG1vdmVzIGZyb20gd2l0aGluIHRoZSBjYW52YXMgYXJlYSAobW91c2VJbkJvdW5kcyA9PSB0cnVlKSB0byBvdXRzaWRlIGl0IChtb3VzZUluQm91bmRzID09IGZhbHNlKS5cblx0ICogVGhpcyBpcyBjdXJyZW50bHkgb25seSBkaXNwYXRjaGVkIGZvciBtb3VzZSBpbnB1dCAobm90IHRvdWNoKS4gU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGNsYXNzIGZvciBhIGxpc3Rpbmcgb2YgZXZlbnQgcHJvcGVydGllcy5cblx0ICogQGV2ZW50IG1vdXNlbGVhdmVcblx0ICogQHNpbmNlIDAuNy4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIHdoZW4gdGhlIG1vdXNlIG1vdmVzIGludG8gdGhlIGNhbnZhcyBhcmVhIChtb3VzZUluQm91bmRzID09IGZhbHNlKSBmcm9tIG91dHNpZGUgaXQgKG1vdXNlSW5Cb3VuZHMgPT0gdHJ1ZSkuXG5cdCAqIFRoaXMgaXMgY3VycmVudGx5IG9ubHkgZGlzcGF0Y2hlZCBmb3IgbW91c2UgaW5wdXQgKG5vdCB0b3VjaCkuIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBjbGFzcyBmb3IgYSBsaXN0aW5nIG9mIGV2ZW50IHByb3BlcnRpZXMuXG5cdCAqIEBldmVudCBtb3VzZWVudGVyXG5cdCAqIEBzaW5jZSAwLjcuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCBlYWNoIHVwZGF0ZSBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIHRpY2sgZXZlbnQgaXMgcHJvcGFnYXRlZCB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuXG5cdCAqIFlvdSBjYW4gY2FsbCBwcmV2ZW50RGVmYXVsdCBvbiB0aGUgZXZlbnQgb2JqZWN0IHRvIGNhbmNlbCBwcm9wYWdhdGluZyB0aGUgdGljayBldmVudC5cblx0ICogQGV2ZW50IHRpY2tzdGFydFxuXHQgKiBAc2luY2UgMC43LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgZWFjaCB1cGRhdGUgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHRpY2sgZXZlbnQgaXMgcHJvcGFnYXRlZCB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuIERvZXMgbm90IGZpcmUgaWZcblx0ICogdGlja09uVXBkYXRlIGlzIGZhbHNlLiBQcmVjZWRlcyB0aGUgXCJkcmF3c3RhcnRcIiBldmVudC5cblx0ICogQGV2ZW50IHRpY2tlbmRcblx0ICogQHNpbmNlIDAuNy4wXG5cdCAqL1xuXHQgXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIGVhY2ggdXBkYXRlIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY2FudmFzIGlzIGNsZWFyZWQgYW5kIHRoZSBkaXNwbGF5IGxpc3QgaXMgZHJhd24gdG8gaXQuXG5cdCAqIFlvdSBjYW4gY2FsbCBwcmV2ZW50RGVmYXVsdCBvbiB0aGUgZXZlbnQgb2JqZWN0IHRvIGNhbmNlbCB0aGUgZHJhdy5cblx0ICogQGV2ZW50IGRyYXdzdGFydFxuXHQgKiBAc2luY2UgMC43LjBcblx0ICovXG5cdCBcblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgZWFjaCB1cGRhdGUgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGRpc3BsYXkgbGlzdCBpcyBkcmF3biB0byB0aGUgY2FudmFzIGFuZCB0aGUgY2FudmFzIGNvbnRleHQgaXMgcmVzdG9yZWQuXG5cdCAqIEBldmVudCBkcmF3ZW5kXG5cdCAqIEBzaW5jZSAwLjcuMFxuXHQgKi9cblxuXHQgXG4vLyBnZXR0ZXIgLyBzZXR0ZXJzOlxuXHQvKipcblx0ICogU3BlY2lmaWVzIGEgdGFyZ2V0IHN0YWdlIHRoYXQgd2lsbCBoYXZlIG1vdXNlIC8gdG91Y2ggaW50ZXJhY3Rpb25zIHJlbGF5ZWQgdG8gaXQgYWZ0ZXIgdGhpcyBzdGFnZSBoYW5kbGVzIHRoZW0uXG5cdCAqIFRoaXMgY2FuIGJlIHVzZWZ1bCBpbiBjYXNlcyB3aGVyZSB5b3UgaGF2ZSBtdWx0aXBsZSBsYXllcmVkIGNhbnZhc2VzIGFuZCB3YW50IHVzZXIgaW50ZXJhY3Rpb25zXG5cdCAqIGV2ZW50cyB0byBwYXNzIHRocm91Z2guIEZvciBleGFtcGxlLCB0aGlzIHdvdWxkIHJlbGF5IG1vdXNlIGV2ZW50cyBmcm9tIHRvcFN0YWdlIHRvIGJvdHRvbVN0YWdlOlxuXHQgKlxuXHQgKiAgICAgIHRvcFN0YWdlLm5leHRTdGFnZSA9IGJvdHRvbVN0YWdlO1xuXHQgKlxuXHQgKiBUbyBkaXNhYmxlIHJlbGF5aW5nLCBzZXQgbmV4dFN0YWdlIHRvIG51bGwuXG5cdCAqIFxuXHQgKiBNb3VzZU92ZXIsIE1vdXNlT3V0LCBSb2xsT3ZlciwgYW5kIFJvbGxPdXQgaW50ZXJhY3Rpb25zIGFyZSBhbHNvIHBhc3NlZCB0aHJvdWdoIHVzaW5nIHRoZSBtb3VzZSBvdmVyIHNldHRpbmdzXG5cdCAqIG9mIHRoZSB0b3AtbW9zdCBzdGFnZSwgYnV0IGFyZSBvbmx5IHByb2Nlc3NlZCBpZiB0aGUgdGFyZ2V0IHN0YWdlIGhhcyBtb3VzZSBvdmVyIGludGVyYWN0aW9ucyBlbmFibGVkLlxuXHQgKiBDb25zaWRlcmF0aW9ucyB3aGVuIHVzaW5nIHJvbGwgb3ZlciBpbiByZWxheSB0YXJnZXRzOjxPTD5cblx0ICogPExJPiBUaGUgdG9wLW1vc3QgKGZpcnN0KSBzdGFnZSBtdXN0IGhhdmUgbW91c2Ugb3ZlciBpbnRlcmFjdGlvbnMgZW5hYmxlZCAodmlhIGVuYWJsZU1vdXNlT3Zlcik8L0xJPlxuXHQgKiA8TEk+IEFsbCBzdGFnZXMgdGhhdCB3aXNoIHRvIHBhcnRpY2lwYXRlIGluIG1vdXNlIG92ZXIgaW50ZXJhY3Rpb24gbXVzdCBlbmFibGUgdGhlbSB2aWEgZW5hYmxlTW91c2VPdmVyPC9MST5cblx0ICogPExJPiBBbGwgcmVsYXkgdGFyZ2V0cyB3aWxsIHNoYXJlIHRoZSBmcmVxdWVuY3kgdmFsdWUgb2YgdGhlIHRvcC1tb3N0IHN0YWdlPC9MST5cblx0ICogPC9PTD5cblx0ICogVG8gaWxsdXN0cmF0ZSwgaW4gdGhpcyBleGFtcGxlIHRoZSB0YXJnZXRTdGFnZSB3b3VsZCBwcm9jZXNzIG1vdXNlIG92ZXIgaW50ZXJhY3Rpb25zIGF0IDEwaHogKGRlc3BpdGUgcGFzc2luZ1xuXHQgKiAzMCBhcyBpdCdzIGRlc2lyZWQgZnJlcXVlbmN5KTpcblx0ICogXHR0b3BTdGFnZS5uZXh0U3RhZ2UgPSB0YXJnZXRTdGFnZTtcblx0ICogXHR0b3BTdGFnZS5lbmFibGVNb3VzZU92ZXIoMTApO1xuXHQgKiBcdHRhcmdldFN0YWdlLmVuYWJsZU1vdXNlT3ZlcigzMCk7XG5cdCAqIFxuXHQgKiBJZiB0aGUgdGFyZ2V0IHN0YWdlJ3MgY2FudmFzIGlzIGNvbXBsZXRlbHkgY292ZXJlZCBieSB0aGlzIHN0YWdlJ3MgY2FudmFzLCB5b3UgbWF5IGFsc28gd2FudCB0byBkaXNhYmxlIGl0c1xuXHQgKiBET00gZXZlbnRzIHVzaW5nOlxuXHQgKiBcblx0ICpcdHRhcmdldFN0YWdlLmVuYWJsZURPTUV2ZW50cyhmYWxzZSk7XG5cdCAqIFxuXHQgKiBAcHJvcGVydHkgbmV4dFN0YWdlXG5cdCAqIEB0eXBlIHtTdGFnZX1cblx0ICoqL1xuXHRwLl9nZXRfbmV4dFN0YWdlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX25leHRTdGFnZTtcblx0fTtcblx0cC5fc2V0X25leHRTdGFnZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHRoaXMuX25leHRTdGFnZSkgeyB0aGlzLl9uZXh0U3RhZ2UuX3ByZXZTdGFnZSA9IG51bGw7IH1cblx0XHRpZiAodmFsdWUpIHsgdmFsdWUuX3ByZXZTdGFnZSA9IHRoaXM7IH1cblx0XHR0aGlzLl9uZXh0U3RhZ2UgPSB2YWx1ZTtcblx0fTtcblx0XG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMocCwge1xuXHRcdFx0bmV4dFN0YWdlOiB7IGdldDogcC5fZ2V0X25leHRTdGFnZSwgc2V0OiBwLl9zZXRfbmV4dFN0YWdlIH1cblx0XHR9KTtcblx0fSBjYXRjaCAoZSkge30gLy8gVE9ETzogdXNlIExvZ1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogRWFjaCB0aW1lIHRoZSB1cGRhdGUgbWV0aG9kIGlzIGNhbGxlZCwgdGhlIHN0YWdlIHdpbGwgY2FsbCB7eyNjcm9zc0xpbmsgXCJTdGFnZS90aWNrXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHVubGVzcyB7eyNjcm9zc0xpbmsgXCJTdGFnZS90aWNrT25VcGRhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaXMgc2V0IHRvIGZhbHNlLFxuXHQgKiBhbmQgdGhlbiByZW5kZXIgdGhlIGRpc3BsYXkgbGlzdCB0byB0aGUgY2FudmFzLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHVwZGF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXSBQcm9wcyBvYmplY3QgdG8gcGFzcyB0byBgdGljaygpYC4gU2hvdWxkIHVzdWFsbHkgYmUgYSB7eyNjcm9zc0xpbmsgXCJUaWNrZXJcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgb2JqZWN0LCBvciBzaW1pbGFyIG9iamVjdCB3aXRoIGEgZGVsdGEgcHJvcGVydHkuXG5cdCAqKi9cblx0cC51cGRhdGUgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdGlmICghdGhpcy5jYW52YXMpIHsgcmV0dXJuOyB9XG5cdFx0aWYgKHRoaXMudGlja09uVXBkYXRlKSB7IHRoaXMudGljayhwcm9wcyk7IH1cblx0XHRpZiAodGhpcy5kaXNwYXRjaEV2ZW50KFwiZHJhd3N0YXJ0XCIsIGZhbHNlLCB0cnVlKSA9PT0gZmFsc2UpIHsgcmV0dXJuOyB9XG5cdFx0Y3JlYXRlanMuRGlzcGxheU9iamVjdC5fc25hcFRvUGl4ZWxFbmFibGVkID0gdGhpcy5zbmFwVG9QaXhlbEVuYWJsZWQ7XG5cdFx0dmFyIHIgPSB0aGlzLmRyYXdSZWN0LCBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0Y3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblx0XHRpZiAodGhpcy5hdXRvQ2xlYXIpIHtcblx0XHRcdGlmIChyKSB7IGN0eC5jbGVhclJlY3Qoci54LCByLnksIHIud2lkdGgsIHIuaGVpZ2h0KTsgfVxuXHRcdFx0ZWxzZSB7IGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgrMSwgdGhpcy5jYW52YXMuaGVpZ2h0KzEpOyB9XG5cdFx0fVxuXHRcdGN0eC5zYXZlKCk7XG5cdFx0aWYgKHRoaXMuZHJhd1JlY3QpIHtcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGN0eC5yZWN0KHIueCwgci55LCByLndpZHRoLCByLmhlaWdodCk7XG5cdFx0XHRjdHguY2xpcCgpO1xuXHRcdH1cblx0XHR0aGlzLnVwZGF0ZUNvbnRleHQoY3R4KTtcblx0XHR0aGlzLmRyYXcoY3R4LCBmYWxzZSk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJkcmF3ZW5kXCIpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFByb3BhZ2F0ZXMgYSB0aWNrIGV2ZW50IHRocm91Z2ggdGhlIGRpc3BsYXkgbGlzdC4gVGhpcyBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSB7eyNjcm9zc0xpbmsgXCJTdGFnZS91cGRhdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogdW5sZXNzIHt7I2Nyb3NzTGluayBcIlN0YWdlL3RpY2tPblVwZGF0ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpcyBzZXQgdG8gZmFsc2UuXG5cdCAqXG5cdCAqIElmIGEgcHJvcHMgb2JqZWN0IGlzIHBhc3NlZCB0byBgdGljaygpYCwgdGhlbiBhbGwgb2YgaXRzIHByb3BlcnRpZXMgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIGV2ZW50IG9iamVjdCB0aGF0IGlzXG5cdCAqIHByb3BhZ2F0ZWQgdG8gbGlzdGVuZXJzLlxuXHQgKlxuXHQgKiBTb21lIHRpbWUtYmFzZWQgZmVhdHVyZXMgaW4gRWFzZWxKUyAoZm9yIGV4YW1wbGUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2ZyYW1lcmF0ZVwifX17ey9jcm9zc0xpbmt9fSByZXF1aXJlIHRoYXRcblx0ICogYSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBvYmplY3QgKG9yIGVxdWl2YWxlbnQgb2JqZWN0IHdpdGggYSBkZWx0YSBwcm9wZXJ0eSkgYmVcblx0ICogcGFzc2VkIGFzIHRoZSBgcHJvcHNgIHBhcmFtZXRlciB0byBgdGljaygpYC4gRm9yIGV4YW1wbGU6XG5cdCAqXG5cdCAqIFx0VGlja2VyLm9uKFwidGlja1wiLCBoYW5kbGVUaWNrKTtcblx0ICogXHRmdW5jdGlvbiBoYW5kbGVUaWNrKGV2dE9iaikge1xuXHQgKiBcdFx0Ly8gY2xvbmUgdGhlIGV2ZW50IG9iamVjdCBmcm9tIFRpY2tlciwgYW5kIGFkZCBzb21lIGN1c3RvbSBkYXRhIHRvIGl0OlxuXHQgKiBcdFx0dmFyIGV2dCA9IGV2dE9iai5jbG9uZSgpLnNldCh7Z3JlZXRpbmc6XCJoZWxsb1wiLCBuYW1lOlwid29ybGRcIn0pO1xuXHQgKiBcdFx0XG5cdCAqIFx0XHQvLyBwYXNzIGl0IHRvIHN0YWdlLnVwZGF0ZSgpOlxuXHQgKiBcdFx0bXlTdGFnZS51cGRhdGUoZXZ0KTsgLy8gc3Vic2VxdWVudGx5IGNhbGxzIHRpY2soKSB3aXRoIHRoZSBzYW1lIHBhcmFtXG5cdCAqIFx0fVxuXHQgKiBcdFxuXHQgKiBcdC8vIC4uLlxuXHQgKiBcdG15RGlzcGxheU9iamVjdC5vbihcInRpY2tcIiwgaGFuZGxlRGlzcGxheU9iamVjdFRpY2spO1xuXHQgKiBcdGZ1bmN0aW9uIGhhbmRsZURpc3BsYXlPYmplY3RUaWNrKGV2dCkge1xuXHQgKiBcdFx0Y29uc29sZS5sb2coZXZ0LmRlbHRhKTsgLy8gdGhlIGRlbHRhIHByb3BlcnR5IGZyb20gdGhlIFRpY2tlciB0aWNrIGV2ZW50IG9iamVjdFxuXHQgKiBcdFx0Y29uc29sZS5sb2coZXZ0LmdyZWV0aW5nLCBldnQubmFtZSk7IC8vIGN1c3RvbSBkYXRhOiBcImhlbGxvIHdvcmxkXCJcblx0ICogXHR9XG5cdCAqIFxuXHQgKiBAbWV0aG9kIHRpY2tcblx0ICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gQW4gb2JqZWN0IHdpdGggcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBjb3BpZWQgdG8gdGhlIGV2ZW50IG9iamVjdC4gU2hvdWxkIHVzdWFsbHkgYmUgYSBUaWNrZXIgZXZlbnQgb2JqZWN0LCBvciBzaW1pbGFyIG9iamVjdCB3aXRoIGEgZGVsdGEgcHJvcGVydHkuXG5cdCAqKi9cblx0cC50aWNrID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRpZiAoIXRoaXMudGlja0VuYWJsZWQgfHwgdGhpcy5kaXNwYXRjaEV2ZW50KFwidGlja3N0YXJ0XCIsIGZhbHNlLCB0cnVlKSA9PT0gZmFsc2UpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIGV2dE9iaiA9IG5ldyBjcmVhdGVqcy5FdmVudChcInRpY2tcIik7XG5cdFx0aWYgKHByb3BzKSB7XG5cdFx0XHRmb3IgKHZhciBuIGluIHByb3BzKSB7XG5cdFx0XHRcdGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShuKSkgeyBldnRPYmpbbl0gPSBwcm9wc1tuXTsgfVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl90aWNrKGV2dE9iaik7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KFwidGlja2VuZFwiKTtcblx0fTtcblxuXHQvKipcblx0ICogRGVmYXVsdCBldmVudCBoYW5kbGVyIHRoYXQgY2FsbHMgdGhlIFN0YWdlIHt7I2Nyb3NzTGluayBcIlN0YWdlL3VwZGF0ZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2Qgd2hlbiBhIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBpcyByZWNlaXZlZC4gVGhpcyBhbGxvd3MgeW91IHRvIHJlZ2lzdGVyIGEgU3RhZ2UgaW5zdGFuY2UgYXMgYSBldmVudCBsaXN0ZW5lciBvbiB7eyNjcm9zc0xpbmsgXCJUaWNrZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZGlyZWN0bHksIHVzaW5nOlxuXHQgKlxuXHQgKiAgICAgIFRpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBteVN0YWdlXCIpO1xuXHQgKlxuXHQgKiBOb3RlIHRoYXQgaWYgeW91IHN1YnNjcmliZSB0byB0aWNrcyB1c2luZyB0aGlzIHBhdHRlcm4sIHRoZW4gdGhlIHRpY2sgZXZlbnQgb2JqZWN0IHdpbGwgYmUgcGFzc2VkIHRocm91Z2ggdG9cblx0ICogZGlzcGxheSBvYmplY3QgdGljayBoYW5kbGVycywgaW5zdGVhZCBvZiA8Y29kZT5kZWx0YTwvY29kZT4gYW5kIDxjb2RlPnBhdXNlZDwvY29kZT4gcGFyYW1ldGVycy5cblx0ICogQHByb3BlcnR5IGhhbmRsZUV2ZW50XG5cdCAqIEB0eXBlIEZ1bmN0aW9uXG5cdCAqKi9cblx0cC5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKGV2dCkge1xuXHRcdGlmIChldnQudHlwZSA9PSBcInRpY2tcIikgeyB0aGlzLnVwZGF0ZShldnQpOyB9XG5cdH07XG5cblx0LyoqXG5cdCAqIENsZWFycyB0aGUgdGFyZ2V0IGNhbnZhcy4gVXNlZnVsIGlmIHt7I2Nyb3NzTGluayBcIlN0YWdlL2F1dG9DbGVhcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpcyBzZXQgdG8gYGZhbHNlYC5cblx0ICogQG1ldGhvZCBjbGVhclxuXHQgKiovXG5cdHAuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuY2FudmFzKSB7IHJldHVybjsgfVxuXHRcdHZhciBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0Y3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoKzEsIHRoaXMuY2FudmFzLmhlaWdodCsxKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGRhdGEgdXJsIHRoYXQgY29udGFpbnMgYSBCYXNlNjQtZW5jb2RlZCBpbWFnZSBvZiB0aGUgY29udGVudHMgb2YgdGhlIHN0YWdlLiBUaGUgcmV0dXJuZWQgZGF0YSB1cmwgY2FuXG5cdCAqIGJlIHNwZWNpZmllZCBhcyB0aGUgc3JjIHZhbHVlIG9mIGFuIGltYWdlIGVsZW1lbnQuXG5cdCAqIEBtZXRob2QgdG9EYXRhVVJMXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbYmFja2dyb3VuZENvbG9yXSBUaGUgYmFja2dyb3VuZCBjb2xvciB0byBiZSB1c2VkIGZvciB0aGUgZ2VuZXJhdGVkIGltYWdlLiBBbnkgdmFsaWQgQ1NTIGNvbG9yXG5cdCAqIHZhbHVlIGlzIGFsbG93ZWQuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgdHJhbnNwYXJlbnQgYmFja2dyb3VuZC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFttaW1lVHlwZT1cImltYWdlL3BuZ1wiXSBUaGUgTUlNRSB0eXBlIG9mIHRoZSBpbWFnZSBmb3JtYXQgdG8gYmUgY3JlYXRlLiBUaGUgZGVmYXVsdCBpcyBcImltYWdlL3BuZ1wiLiBJZiBhbiB1bmtub3duIE1JTUUgdHlwZVxuXHQgKiBpcyBwYXNzZWQgaW4sIG9yIGlmIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdGhlIHNwZWNpZmllZCBNSU1FIHR5cGUsIHRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgdXNlZC5cblx0ICogQHJldHVybiB7U3RyaW5nfSBhIEJhc2U2NCBlbmNvZGVkIGltYWdlLlxuXHQgKiovXG5cdHAudG9EYXRhVVJMID0gZnVuY3Rpb24oYmFja2dyb3VuZENvbG9yLCBtaW1lVHlwZSkge1xuXHRcdHZhciBkYXRhLCBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLCB3ID0gdGhpcy5jYW52YXMud2lkdGgsIGggPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XG5cblx0XHRpZiAoYmFja2dyb3VuZENvbG9yKSB7XG5cdFx0XHRkYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3LCBoKTtcblx0XHRcdHZhciBjb21wb3NpdGVPcGVyYXRpb24gPSBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuXHRcdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24tb3ZlclwiO1xuXHRcdFx0XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuXHRcdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIHcsIGgpO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVVJMID0gdGhpcy5jYW52YXMudG9EYXRhVVJMKG1pbWVUeXBlfHxcImltYWdlL3BuZ1wiKTtcblxuXHRcdGlmKGJhY2tncm91bmRDb2xvcikge1xuXHRcdFx0Y3R4LnB1dEltYWdlRGF0YShkYXRhLCAwLCAwKTtcblx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBjb21wb3NpdGVPcGVyYXRpb247XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGFVUkw7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgKGJ5IHBhc3NpbmcgYSBmcmVxdWVuY3kgb2YgMCkgbW91c2Ugb3ZlciAoe3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9tb3VzZW92ZXI6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogYW5kIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbW91c2VvdXQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0pIGFuZCByb2xsIG92ZXIgZXZlbnRzICh7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3JvbGxvdmVyOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFuZCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3JvbGxvdXQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0pIGZvciB0aGlzIHN0YWdlJ3MgZGlzcGxheSBsaXN0LiBUaGVzZSBldmVudHMgY2FuXG5cdCAqIGJlIGV4cGVuc2l2ZSB0byBnZW5lcmF0ZSwgc28gdGhleSBhcmUgZGlzYWJsZWQgYnkgZGVmYXVsdC4gVGhlIGZyZXF1ZW5jeSBvZiB0aGUgZXZlbnRzIGNhbiBiZSBjb250cm9sbGVkXG5cdCAqIGluZGVwZW5kZW50bHkgb2YgbW91c2UgbW92ZSBldmVudHMgdmlhIHRoZSBvcHRpb25hbCBgZnJlcXVlbmN5YCBwYXJhbWV0ZXIuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgc3RhZ2UgPSBuZXcgY3JlYXRlanMuU3RhZ2UoXCJjYW52YXNJZFwiKTtcblx0ICogICAgICBzdGFnZS5lbmFibGVNb3VzZU92ZXIoMTApOyAvLyAxMCB1cGRhdGVzIHBlciBzZWNvbmRcblx0ICpcblx0ICogQG1ldGhvZCBlbmFibGVNb3VzZU92ZXJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtmcmVxdWVuY3k9MjBdIE9wdGlvbmFsIHBhcmFtIHNwZWNpZnlpbmcgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpbWVzIHBlciBzZWNvbmQgdG8gYnJvYWRjYXN0XG5cdCAqIG1vdXNlIG92ZXIvb3V0IGV2ZW50cy4gU2V0IHRvIDAgdG8gZGlzYWJsZSBtb3VzZSBvdmVyIGV2ZW50cyBjb21wbGV0ZWx5LiBNYXhpbXVtIGlzIDUwLiBBIGxvd2VyIGZyZXF1ZW5jeSBpcyBsZXNzXG5cdCAqIHJlc3BvbnNpdmUsIGJ1dCB1c2VzIGxlc3MgQ1BVLlxuXHQgKiovXG5cdHAuZW5hYmxlTW91c2VPdmVyID0gZnVuY3Rpb24oZnJlcXVlbmN5KSB7XG5cdFx0aWYgKHRoaXMuX21vdXNlT3ZlckludGVydmFsSUQpIHtcblx0XHRcdGNsZWFySW50ZXJ2YWwodGhpcy5fbW91c2VPdmVySW50ZXJ2YWxJRCk7XG5cdFx0XHR0aGlzLl9tb3VzZU92ZXJJbnRlcnZhbElEID0gbnVsbDtcblx0XHRcdGlmIChmcmVxdWVuY3kgPT0gMCkge1xuXHRcdFx0XHR0aGlzLl90ZXN0TW91c2VPdmVyKHRydWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoZnJlcXVlbmN5ID09IG51bGwpIHsgZnJlcXVlbmN5ID0gMjA7IH1cblx0XHRlbHNlIGlmIChmcmVxdWVuY3kgPD0gMCkgeyByZXR1cm47IH1cblx0XHR2YXIgbyA9IHRoaXM7XG5cdFx0dGhpcy5fbW91c2VPdmVySW50ZXJ2YWxJRCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCl7IG8uX3Rlc3RNb3VzZU92ZXIoKTsgfSwgMTAwMC9NYXRoLm1pbig1MCxmcmVxdWVuY3kpKTtcblx0fTtcblxuXHQvKipcblx0ICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgc3RhZ2UgYWRkcyB0byBET00gZWxlbWVudHMgKHdpbmRvdywgZG9jdW1lbnQgYW5kIGNhbnZhcykuIEl0IGlzIGdvb2Rcblx0ICogcHJhY3RpY2UgdG8gZGlzYWJsZSBldmVudHMgd2hlbiBkaXNwb3Npbmcgb2YgYSBTdGFnZSBpbnN0YW5jZSwgb3RoZXJ3aXNlIHRoZSBzdGFnZSB3aWxsIGNvbnRpbnVlIHRvIHJlY2VpdmVcblx0ICogZXZlbnRzIGZyb20gdGhlIHBhZ2UuXG5cdCAqXG5cdCAqIFdoZW4gY2hhbmdpbmcgdGhlIGNhbnZhcyBwcm9wZXJ0eSB5b3UgbXVzdCBkaXNhYmxlIHRoZSBldmVudHMgb24gdGhlIG9sZCBjYW52YXMsIGFuZCBlbmFibGUgZXZlbnRzIG9uIHRoZVxuXHQgKiBuZXcgY2FudmFzIG9yIG1vdXNlIGV2ZW50cyB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkLiBGb3IgZXhhbXBsZTpcblx0ICpcblx0ICogICAgICBteVN0YWdlLmVuYWJsZURPTUV2ZW50cyhmYWxzZSk7XG5cdCAqICAgICAgbXlTdGFnZS5jYW52YXMgPSBhbm90aGVyQ2FudmFzO1xuXHQgKiAgICAgIG15U3RhZ2UuZW5hYmxlRE9NRXZlbnRzKHRydWUpO1xuXHQgKlxuXHQgKiBAbWV0aG9kIGVuYWJsZURPTUV2ZW50c1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtlbmFibGU9dHJ1ZV0gSW5kaWNhdGVzIHdoZXRoZXIgdG8gZW5hYmxlIG9yIGRpc2FibGUgdGhlIGV2ZW50cy4gRGVmYXVsdCBpcyB0cnVlLlxuXHQgKiovXG5cdHAuZW5hYmxlRE9NRXZlbnRzID0gZnVuY3Rpb24oZW5hYmxlKSB7XG5cdFx0aWYgKGVuYWJsZSA9PSBudWxsKSB7IGVuYWJsZSA9IHRydWU7IH1cblx0XHR2YXIgbiwgbywgbHMgPSB0aGlzLl9ldmVudExpc3RlbmVycztcblx0XHRpZiAoIWVuYWJsZSAmJiBscykge1xuXHRcdFx0Zm9yIChuIGluIGxzKSB7XG5cdFx0XHRcdG8gPSBsc1tuXTtcblx0XHRcdFx0by50LnJlbW92ZUV2ZW50TGlzdGVuZXIobiwgby5mLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9ldmVudExpc3RlbmVycyA9IG51bGw7XG5cdFx0fSBlbHNlIGlmIChlbmFibGUgJiYgIWxzICYmIHRoaXMuY2FudmFzKSB7XG5cdFx0XHR2YXIgdCA9IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyID8gd2luZG93IDogZG9jdW1lbnQ7XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdFx0bHMgPSB0aGlzLl9ldmVudExpc3RlbmVycyA9IHt9O1xuXHRcdFx0bHNbXCJtb3VzZXVwXCJdID0ge3Q6dCwgZjpmdW5jdGlvbihlKSB7IF90aGlzLl9oYW5kbGVNb3VzZVVwKGUpfSB9O1xuXHRcdFx0bHNbXCJtb3VzZW1vdmVcIl0gPSB7dDp0LCBmOmZ1bmN0aW9uKGUpIHsgX3RoaXMuX2hhbmRsZU1vdXNlTW92ZShlKX0gfTtcblx0XHRcdGxzW1wiZGJsY2xpY2tcIl0gPSB7dDp0aGlzLmNhbnZhcywgZjpmdW5jdGlvbihlKSB7IF90aGlzLl9oYW5kbGVEb3VibGVDbGljayhlKX0gfTtcblx0XHRcdGxzW1wibW91c2Vkb3duXCJdID0ge3Q6dGhpcy5jYW52YXMsIGY6ZnVuY3Rpb24oZSkgeyBfdGhpcy5faGFuZGxlTW91c2VEb3duKGUpfSB9O1xuXG5cdFx0XHRmb3IgKG4gaW4gbHMpIHtcblx0XHRcdFx0byA9IGxzW25dO1xuXHRcdFx0XHRvLnQuYWRkRXZlbnRMaXN0ZW5lcihuLCBvLmYsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0YWdlIGluc3RhbmNlcyBjYW5ub3QgYmUgY2xvbmVkLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRocm93KFwiU3RhZ2UgY2Fubm90IGJlIGNsb25lZC5cIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltTdGFnZSAobmFtZT1cIisgIHRoaXMubmFtZSArXCIpXVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldEVsZW1lbnRSZWN0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZVxuXHQgKiovXG5cdHAuX2dldEVsZW1lbnRSZWN0ID0gZnVuY3Rpb24oZSkge1xuXHRcdHZhciBib3VuZHM7XG5cdFx0dHJ5IHsgYm91bmRzID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgfSAvLyB0aGlzIGNhbiBmYWlsIG9uIGRpc2Nvbm5lY3RlZCBET00gZWxlbWVudHMgaW4gSUU5XG5cdFx0Y2F0Y2ggKGVycikgeyBib3VuZHMgPSB7dG9wOiBlLm9mZnNldFRvcCwgbGVmdDogZS5vZmZzZXRMZWZ0LCB3aWR0aDplLm9mZnNldFdpZHRoLCBoZWlnaHQ6ZS5vZmZzZXRIZWlnaHR9OyB9XG5cblx0XHR2YXIgb2ZmWCA9ICh3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuc2Nyb2xsTGVmdCB8fCAwKSAtIChkb2N1bWVudC5jbGllbnRMZWZ0IHx8IGRvY3VtZW50LmJvZHkuY2xpZW50TGVmdCB8fCAwKTtcblx0XHR2YXIgb2ZmWSA9ICh3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuc2Nyb2xsVG9wIHx8IDApIC0gKGRvY3VtZW50LmNsaWVudFRvcCAgfHwgZG9jdW1lbnQuYm9keS5jbGllbnRUb3AgIHx8IDApO1xuXG5cdFx0dmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID8gZ2V0Q29tcHV0ZWRTdHlsZShlLG51bGwpIDogZS5jdXJyZW50U3R5bGU7IC8vIElFIDw5IGNvbXBhdGliaWxpdHkuXG5cdFx0dmFyIHBhZEwgPSBwYXJzZUludChzdHlsZXMucGFkZGluZ0xlZnQpK3BhcnNlSW50KHN0eWxlcy5ib3JkZXJMZWZ0V2lkdGgpO1xuXHRcdHZhciBwYWRUID0gcGFyc2VJbnQoc3R5bGVzLnBhZGRpbmdUb3ApK3BhcnNlSW50KHN0eWxlcy5ib3JkZXJUb3BXaWR0aCk7XG5cdFx0dmFyIHBhZFIgPSBwYXJzZUludChzdHlsZXMucGFkZGluZ1JpZ2h0KStwYXJzZUludChzdHlsZXMuYm9yZGVyUmlnaHRXaWR0aCk7XG5cdFx0dmFyIHBhZEIgPSBwYXJzZUludChzdHlsZXMucGFkZGluZ0JvdHRvbSkrcGFyc2VJbnQoc3R5bGVzLmJvcmRlckJvdHRvbVdpZHRoKTtcblxuXHRcdC8vIG5vdGU6IGluIHNvbWUgYnJvd3NlcnMgYm91bmRzIHByb3BlcnRpZXMgYXJlIHJlYWQgb25seS5cblx0XHRyZXR1cm4ge1xuXHRcdFx0bGVmdDogYm91bmRzLmxlZnQrb2ZmWCtwYWRMLFxuXHRcdFx0cmlnaHQ6IGJvdW5kcy5yaWdodCtvZmZYLXBhZFIsXG5cdFx0XHR0b3A6IGJvdW5kcy50b3Arb2ZmWStwYWRULFxuXHRcdFx0Ym90dG9tOiBib3VuZHMuYm90dG9tK29mZlktcGFkQlxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0UG9pbnRlckRhdGFcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaWRcblx0ICoqL1xuXHRwLl9nZXRQb2ludGVyRGF0YSA9IGZ1bmN0aW9uKGlkKSB7XG5cdFx0dmFyIGRhdGEgPSB0aGlzLl9wb2ludGVyRGF0YVtpZF07XG5cdFx0aWYgKCFkYXRhKSB7IGRhdGEgPSB0aGlzLl9wb2ludGVyRGF0YVtpZF0gPSB7eDowLHk6MH07IH1cblx0XHRyZXR1cm4gZGF0YTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlTW91c2VNb3ZlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlXG5cdCAqKi9cblx0cC5faGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24oZSkge1xuXHRcdGlmKCFlKXsgZSA9IHdpbmRvdy5ldmVudDsgfVxuXHRcdHRoaXMuX2hhbmRsZVBvaW50ZXJNb3ZlKC0xLCBlLCBlLnBhZ2VYLCBlLnBhZ2VZKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlUG9pbnRlck1vdmVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaWRcblx0ICogQHBhcmFtIHtFdmVudH0gZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGFnZVhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2VZXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IG93bmVyIEluZGljYXRlcyB0aGF0IHRoZSBldmVudCBoYXMgYWxyZWFkeSBiZWVuIGNhcHR1cmVkICYgaGFuZGxlZCBieSB0aGUgaW5kaWNhdGVkIHN0YWdlLlxuXHQgKiovXG5cdHAuX2hhbmRsZVBvaW50ZXJNb3ZlID0gZnVuY3Rpb24oaWQsIGUsIHBhZ2VYLCBwYWdlWSwgb3duZXIpIHtcblx0XHRpZiAodGhpcy5fcHJldlN0YWdlICYmIG93bmVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuOyB9IC8vIHJlZHVuZGFudCBsaXN0ZW5lci5cblx0XHRpZiAoIXRoaXMuY2FudmFzKSB7IHJldHVybjsgfVxuXHRcdHZhciBuZXh0U3RhZ2U9dGhpcy5fbmV4dFN0YWdlLCBvPXRoaXMuX2dldFBvaW50ZXJEYXRhKGlkKTtcblxuXHRcdHZhciBpbkJvdW5kcyA9IG8uaW5Cb3VuZHM7XG5cdFx0dGhpcy5fdXBkYXRlUG9pbnRlclBvc2l0aW9uKGlkLCBlLCBwYWdlWCwgcGFnZVkpO1xuXHRcdGlmIChpbkJvdW5kcyB8fCBvLmluQm91bmRzIHx8IHRoaXMubW91c2VNb3ZlT3V0c2lkZSkge1xuXHRcdFx0aWYgKGlkID09PSAtMSAmJiBvLmluQm91bmRzID09ICFpbkJvdW5kcykge1xuXHRcdFx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQodGhpcywgKGluQm91bmRzID8gXCJtb3VzZWxlYXZlXCIgOiBcIm1vdXNlZW50ZXJcIiksIGZhbHNlLCBpZCwgbywgZSk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHRoaXMuX2Rpc3BhdGNoTW91c2VFdmVudCh0aGlzLCBcInN0YWdlbW91c2Vtb3ZlXCIsIGZhbHNlLCBpZCwgbywgZSk7XG5cdFx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQoby50YXJnZXQsIFwicHJlc3Ntb3ZlXCIsIHRydWUsIGlkLCBvLCBlKTtcblx0XHR9XG5cdFx0XG5cdFx0bmV4dFN0YWdlJiZuZXh0U3RhZ2UuX2hhbmRsZVBvaW50ZXJNb3ZlKGlkLCBlLCBwYWdlWCwgcGFnZVksIG51bGwpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF91cGRhdGVQb2ludGVyUG9zaXRpb25cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gaWRcblx0ICogQHBhcmFtIHtFdmVudH0gZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGFnZVhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2VZXG5cdCAqKi9cblx0cC5fdXBkYXRlUG9pbnRlclBvc2l0aW9uID0gZnVuY3Rpb24oaWQsIGUsIHBhZ2VYLCBwYWdlWSkge1xuXHRcdHZhciByZWN0ID0gdGhpcy5fZ2V0RWxlbWVudFJlY3QodGhpcy5jYW52YXMpO1xuXHRcdHBhZ2VYIC09IHJlY3QubGVmdDtcblx0XHRwYWdlWSAtPSByZWN0LnRvcDtcblxuXHRcdHZhciB3ID0gdGhpcy5jYW52YXMud2lkdGg7XG5cdFx0dmFyIGggPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XG5cdFx0cGFnZVggLz0gKHJlY3QucmlnaHQtcmVjdC5sZWZ0KS93O1xuXHRcdHBhZ2VZIC89IChyZWN0LmJvdHRvbS1yZWN0LnRvcCkvaDtcblx0XHR2YXIgbyA9IHRoaXMuX2dldFBvaW50ZXJEYXRhKGlkKTtcblx0XHRpZiAoby5pbkJvdW5kcyA9IChwYWdlWCA+PSAwICYmIHBhZ2VZID49IDAgJiYgcGFnZVggPD0gdy0xICYmIHBhZ2VZIDw9IGgtMSkpIHtcblx0XHRcdG8ueCA9IHBhZ2VYO1xuXHRcdFx0by55ID0gcGFnZVk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLm1vdXNlTW92ZU91dHNpZGUpIHtcblx0XHRcdG8ueCA9IHBhZ2VYIDwgMCA/IDAgOiAocGFnZVggPiB3LTEgPyB3LTEgOiBwYWdlWCk7XG5cdFx0XHRvLnkgPSBwYWdlWSA8IDAgPyAwIDogKHBhZ2VZID4gaC0xID8gaC0xIDogcGFnZVkpO1xuXHRcdH1cblxuXHRcdG8ucG9zRXZ0T2JqID0gZTtcblx0XHRvLnJhd1ggPSBwYWdlWDtcblx0XHRvLnJhd1kgPSBwYWdlWTtcblxuXHRcdGlmIChpZCA9PT0gdGhpcy5fcHJpbWFyeVBvaW50ZXJJRCB8fCBpZCA9PT0gLTEpIHtcblx0XHRcdHRoaXMubW91c2VYID0gby54O1xuXHRcdFx0dGhpcy5tb3VzZVkgPSBvLnk7XG5cdFx0XHR0aGlzLm1vdXNlSW5Cb3VuZHMgPSBvLmluQm91bmRzO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlTW91c2VVcFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuXHQgKiovXG5cdHAuX2hhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbihlKSB7XG5cdFx0dGhpcy5faGFuZGxlUG9pbnRlclVwKC0xLCBlLCBmYWxzZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVBvaW50ZXJVcFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xlYXJcblx0ICogQHBhcmFtIHtTdGFnZX0gb3duZXIgSW5kaWNhdGVzIHRoYXQgdGhlIGV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gY2FwdHVyZWQgJiBoYW5kbGVkIGJ5IHRoZSBpbmRpY2F0ZWQgc3RhZ2UuXG5cdCAqKi9cblx0cC5faGFuZGxlUG9pbnRlclVwID0gZnVuY3Rpb24oaWQsIGUsIGNsZWFyLCBvd25lcikge1xuXHRcdHZhciBuZXh0U3RhZ2UgPSB0aGlzLl9uZXh0U3RhZ2UsIG8gPSB0aGlzLl9nZXRQb2ludGVyRGF0YShpZCk7XG5cdFx0aWYgKHRoaXMuX3ByZXZTdGFnZSAmJiBvd25lciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybjsgfSAvLyByZWR1bmRhbnQgbGlzdGVuZXIuXG5cdFx0XG5cdFx0dmFyIHRhcmdldD1udWxsLCBvVGFyZ2V0ID0gby50YXJnZXQ7XG5cdFx0aWYgKCFvd25lciAmJiAob1RhcmdldCB8fCBuZXh0U3RhZ2UpKSB7IHRhcmdldCA9IHRoaXMuX2dldE9iamVjdHNVbmRlclBvaW50KG8ueCwgby55LCBudWxsLCB0cnVlKTsgfVxuXHRcdFxuXHRcdGlmIChvLmRvd24pIHsgdGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KHRoaXMsIFwic3RhZ2Vtb3VzZXVwXCIsIGZhbHNlLCBpZCwgbywgZSwgdGFyZ2V0KTsgby5kb3duID0gZmFsc2U7IH1cblx0XHRcblx0XHRpZiAodGFyZ2V0ID09IG9UYXJnZXQpIHsgdGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KG9UYXJnZXQsIFwiY2xpY2tcIiwgdHJ1ZSwgaWQsIG8sIGUpOyB9XG5cdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KG9UYXJnZXQsIFwicHJlc3N1cFwiLCB0cnVlLCBpZCwgbywgZSk7XG5cdFx0XG5cdFx0aWYgKGNsZWFyKSB7XG5cdFx0XHRpZiAoaWQ9PXRoaXMuX3ByaW1hcnlQb2ludGVySUQpIHsgdGhpcy5fcHJpbWFyeVBvaW50ZXJJRCA9IG51bGw7IH1cblx0XHRcdGRlbGV0ZSh0aGlzLl9wb2ludGVyRGF0YVtpZF0pO1xuXHRcdH0gZWxzZSB7IG8udGFyZ2V0ID0gbnVsbDsgfVxuXHRcdFxuXHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl9oYW5kbGVQb2ludGVyVXAoaWQsIGUsIGNsZWFyLCBvd25lciB8fCB0YXJnZXQgJiYgdGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1vdXNlRG93blxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuXHQgKiovXG5cdHAuX2hhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uKGUpIHtcblx0XHR0aGlzLl9oYW5kbGVQb2ludGVyRG93bigtMSwgZSwgZS5wYWdlWCwgZS5wYWdlWSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVBvaW50ZXJEb3duXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGlkXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBhZ2VYXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwYWdlWVxuXHQgKiBAcGFyYW0ge1N0YWdlfSBvd25lciBJbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgaGFzIGFscmVhZHkgYmVlbiBjYXB0dXJlZCAmIGhhbmRsZWQgYnkgdGhlIGluZGljYXRlZCBzdGFnZS5cblx0ICoqL1xuXHRwLl9oYW5kbGVQb2ludGVyRG93biA9IGZ1bmN0aW9uKGlkLCBlLCBwYWdlWCwgcGFnZVksIG93bmVyKSB7XG5cdFx0aWYgKHRoaXMucHJldmVudFNlbGVjdGlvbikgeyBlLnByZXZlbnREZWZhdWx0KCk7IH1cblx0XHRpZiAodGhpcy5fcHJpbWFyeVBvaW50ZXJJRCA9PSBudWxsIHx8IGlkID09PSAtMSkgeyB0aGlzLl9wcmltYXJ5UG9pbnRlcklEID0gaWQ7IH0gLy8gbW91c2UgYWx3YXlzIHRha2VzIG92ZXIuXG5cdFx0XG5cdFx0aWYgKHBhZ2VZICE9IG51bGwpIHsgdGhpcy5fdXBkYXRlUG9pbnRlclBvc2l0aW9uKGlkLCBlLCBwYWdlWCwgcGFnZVkpOyB9XG5cdFx0dmFyIHRhcmdldCA9IG51bGwsIG5leHRTdGFnZSA9IHRoaXMuX25leHRTdGFnZSwgbyA9IHRoaXMuX2dldFBvaW50ZXJEYXRhKGlkKTtcblx0XHRpZiAoIW93bmVyKSB7IHRhcmdldCA9IG8udGFyZ2V0ID0gdGhpcy5fZ2V0T2JqZWN0c1VuZGVyUG9pbnQoby54LCBvLnksIG51bGwsIHRydWUpOyB9XG5cblx0XHRpZiAoby5pbkJvdW5kcykgeyB0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQodGhpcywgXCJzdGFnZW1vdXNlZG93blwiLCBmYWxzZSwgaWQsIG8sIGUsIHRhcmdldCk7IG8uZG93biA9IHRydWU7IH1cblx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQodGFyZ2V0LCBcIm1vdXNlZG93blwiLCB0cnVlLCBpZCwgbywgZSk7XG5cdFx0XG5cdFx0bmV4dFN0YWdlJiZuZXh0U3RhZ2UuX2hhbmRsZVBvaW50ZXJEb3duKGlkLCBlLCBwYWdlWCwgcGFnZVksIG93bmVyIHx8IHRhcmdldCAmJiB0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfdGVzdE1vdXNlT3ZlclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNsZWFyIElmIHRydWUsIGNsZWFycyB0aGUgbW91c2VvdmVyIC8gcm9sbG92ZXIgKGllLiBubyB0YXJnZXQpXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IG93bmVyIEluZGljYXRlcyB0aGF0IHRoZSBldmVudCBoYXMgYWxyZWFkeSBiZWVuIGNhcHR1cmVkICYgaGFuZGxlZCBieSB0aGUgaW5kaWNhdGVkIHN0YWdlLlxuXHQgKiBAcGFyYW0ge1N0YWdlfSBldmVudFRhcmdldCBUaGUgc3RhZ2UgdGhhdCB0aGUgY3Vyc29yIGlzIGFjdGl2ZWx5IG92ZXIuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl90ZXN0TW91c2VPdmVyID0gZnVuY3Rpb24oY2xlYXIsIG93bmVyLCBldmVudFRhcmdldCkge1xuXHRcdGlmICh0aGlzLl9wcmV2U3RhZ2UgJiYgb3duZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm47IH0gLy8gcmVkdW5kYW50IGxpc3RlbmVyLlxuXHRcdFxuXHRcdHZhciBuZXh0U3RhZ2UgPSB0aGlzLl9uZXh0U3RhZ2U7XG5cdFx0aWYgKCF0aGlzLl9tb3VzZU92ZXJJbnRlcnZhbElEKSB7XG5cdFx0XHQvLyBub3QgZW5hYmxlZCBmb3IgbW91c2VvdmVyLCBidXQgc2hvdWxkIHN0aWxsIHJlbGF5IHRoZSBldmVudC5cblx0XHRcdG5leHRTdGFnZSYmbmV4dFN0YWdlLl90ZXN0TW91c2VPdmVyKGNsZWFyLCBvd25lciwgZXZlbnRUYXJnZXQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgbyA9IHRoaXMuX2dldFBvaW50ZXJEYXRhKC0xKTtcblx0XHQvLyBvbmx5IHVwZGF0ZSBpZiB0aGUgbW91c2UgcG9zaXRpb24gaGFzIGNoYW5nZWQuIFRoaXMgcHJvdmlkZXMgYSBsb3Qgb2Ygb3B0aW1pemF0aW9uLCBidXQgaGFzIHNvbWUgdHJhZGUtb2Zmcy5cblx0XHRpZiAoIW8gfHwgKCFjbGVhciAmJiB0aGlzLm1vdXNlWCA9PSB0aGlzLl9tb3VzZU92ZXJYICYmIHRoaXMubW91c2VZID09IHRoaXMuX21vdXNlT3ZlclkgJiYgdGhpcy5tb3VzZUluQm91bmRzKSkgeyByZXR1cm47IH1cblx0XHRcblx0XHR2YXIgZSA9IG8ucG9zRXZ0T2JqO1xuXHRcdHZhciBpc0V2ZW50VGFyZ2V0ID0gZXZlbnRUYXJnZXQgfHwgZSYmKGUudGFyZ2V0ID09IHRoaXMuY2FudmFzKTtcblx0XHR2YXIgdGFyZ2V0PW51bGwsIGNvbW1vbiA9IC0xLCBjdXJzb3I9XCJcIiwgdCwgaSwgbDtcblx0XHRcblx0XHRpZiAoIW93bmVyICYmIChjbGVhciB8fCB0aGlzLm1vdXNlSW5Cb3VuZHMgJiYgaXNFdmVudFRhcmdldCkpIHtcblx0XHRcdHRhcmdldCA9IHRoaXMuX2dldE9iamVjdHNVbmRlclBvaW50KHRoaXMubW91c2VYLCB0aGlzLm1vdXNlWSwgbnVsbCwgdHJ1ZSk7XG5cdFx0XHR0aGlzLl9tb3VzZU92ZXJYID0gdGhpcy5tb3VzZVg7XG5cdFx0XHR0aGlzLl9tb3VzZU92ZXJZID0gdGhpcy5tb3VzZVk7XG5cdFx0fVxuXG5cdFx0dmFyIG9sZExpc3QgPSB0aGlzLl9tb3VzZU92ZXJUYXJnZXR8fFtdO1xuXHRcdHZhciBvbGRUYXJnZXQgPSBvbGRMaXN0W29sZExpc3QubGVuZ3RoLTFdO1xuXHRcdHZhciBsaXN0ID0gdGhpcy5fbW91c2VPdmVyVGFyZ2V0ID0gW107XG5cblx0XHQvLyBnZW5lcmF0ZSBhbmNlc3RvciBsaXN0IGFuZCBjaGVjayBmb3IgY3Vyc29yOlxuXHRcdHQgPSB0YXJnZXQ7XG5cdFx0d2hpbGUgKHQpIHtcblx0XHRcdGxpc3QudW5zaGlmdCh0KTtcblx0XHRcdGlmICghY3Vyc29yKSB7IGN1cnNvciA9IHQuY3Vyc29yOyB9XG5cdFx0XHR0ID0gdC5wYXJlbnQ7XG5cdFx0fVxuXHRcdHRoaXMuY2FudmFzLnN0eWxlLmN1cnNvciA9IGN1cnNvcjtcblx0XHRpZiAoIW93bmVyICYmIGV2ZW50VGFyZ2V0KSB7IGV2ZW50VGFyZ2V0LmNhbnZhcy5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7IH1cblxuXHRcdC8vIGZpbmQgY29tbW9uIGFuY2VzdG9yOlxuXHRcdGZvciAoaT0wLGw9bGlzdC5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRpZiAobGlzdFtpXSAhPSBvbGRMaXN0W2ldKSB7IGJyZWFrOyB9XG5cdFx0XHRjb21tb24gPSBpO1xuXHRcdH1cblxuXHRcdGlmIChvbGRUYXJnZXQgIT0gdGFyZ2V0KSB7XG5cdFx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQob2xkVGFyZ2V0LCBcIm1vdXNlb3V0XCIsIHRydWUsIC0xLCBvLCBlLCB0YXJnZXQpO1xuXHRcdH1cblxuXHRcdGZvciAoaT1vbGRMaXN0Lmxlbmd0aC0xOyBpPmNvbW1vbjsgaS0tKSB7XG5cdFx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQob2xkTGlzdFtpXSwgXCJyb2xsb3V0XCIsIGZhbHNlLCAtMSwgbywgZSwgdGFyZ2V0KTtcblx0XHR9XG5cblx0XHRmb3IgKGk9bGlzdC5sZW5ndGgtMTsgaT5jb21tb247IGktLSkge1xuXHRcdFx0dGhpcy5fZGlzcGF0Y2hNb3VzZUV2ZW50KGxpc3RbaV0sIFwicm9sbG92ZXJcIiwgZmFsc2UsIC0xLCBvLCBlLCBvbGRUYXJnZXQpO1xuXHRcdH1cblxuXHRcdGlmIChvbGRUYXJnZXQgIT0gdGFyZ2V0KSB7XG5cdFx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQodGFyZ2V0LCBcIm1vdXNlb3ZlclwiLCB0cnVlLCAtMSwgbywgZSwgb2xkVGFyZ2V0KTtcblx0XHR9XG5cdFx0XG5cdFx0bmV4dFN0YWdlJiZuZXh0U3RhZ2UuX3Rlc3RNb3VzZU92ZXIoY2xlYXIsIG93bmVyIHx8IHRhcmdldCAmJiB0aGlzLCBldmVudFRhcmdldCB8fCBpc0V2ZW50VGFyZ2V0ICYmIHRoaXMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVEb3VibGVDbGlja1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuXHQgKiBAcGFyYW0ge1N0YWdlfSBvd25lciBJbmRpY2F0ZXMgdGhhdCB0aGUgZXZlbnQgaGFzIGFscmVhZHkgYmVlbiBjYXB0dXJlZCAmIGhhbmRsZWQgYnkgdGhlIGluZGljYXRlZCBzdGFnZS5cblx0ICoqL1xuXHRwLl9oYW5kbGVEb3VibGVDbGljayA9IGZ1bmN0aW9uKGUsIG93bmVyKSB7XG5cdFx0dmFyIHRhcmdldD1udWxsLCBuZXh0U3RhZ2U9dGhpcy5fbmV4dFN0YWdlLCBvPXRoaXMuX2dldFBvaW50ZXJEYXRhKC0xKTtcblx0XHRpZiAoIW93bmVyKSB7XG5cdFx0XHR0YXJnZXQgPSB0aGlzLl9nZXRPYmplY3RzVW5kZXJQb2ludChvLngsIG8ueSwgbnVsbCwgdHJ1ZSk7XG5cdFx0XHR0aGlzLl9kaXNwYXRjaE1vdXNlRXZlbnQodGFyZ2V0LCBcImRibGNsaWNrXCIsIHRydWUsIC0xLCBvLCBlKTtcblx0XHR9XG5cdFx0bmV4dFN0YWdlJiZuZXh0U3RhZ2UuX2hhbmRsZURvdWJsZUNsaWNrKGUsIG93bmVyIHx8IHRhcmdldCAmJiB0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZGlzcGF0Y2hNb3VzZUV2ZW50XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSB0YXJnZXRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcblx0ICogQHBhcmFtIHtCb29sZWFufSBidWJibGVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludGVySWRcblx0ICogQHBhcmFtIHtPYmplY3R9IG9cblx0ICogQHBhcmFtIHtNb3VzZUV2ZW50fSBbbmF0aXZlRXZlbnRdXG5cdCAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gW3JlbGF0ZWRUYXJnZXRdXG5cdCAqKi9cblx0cC5fZGlzcGF0Y2hNb3VzZUV2ZW50ID0gZnVuY3Rpb24odGFyZ2V0LCB0eXBlLCBidWJibGVzLCBwb2ludGVySWQsIG8sIG5hdGl2ZUV2ZW50LCByZWxhdGVkVGFyZ2V0KSB7XG5cdFx0Ly8gVE9ETzogbWlnaHQgYmUgd29ydGggZWl0aGVyIHJldXNpbmcgTW91c2VFdmVudCBpbnN0YW5jZXMsIG9yIGFkZGluZyBhIHdpbGxUcmlnZ2VyIG1ldGhvZCB0byBhdm9pZCBHQy5cblx0XHRpZiAoIXRhcmdldCB8fCAoIWJ1YmJsZXMgJiYgIXRhcmdldC5oYXNFdmVudExpc3RlbmVyKHR5cGUpKSkgeyByZXR1cm47IH1cblx0XHQvKlxuXHRcdC8vIFRPRE86IGFjY291bnQgZm9yIHN0YWdlIHRyYW5zZm9ybWF0aW9ucz9cblx0XHR0aGlzLl9tdHggPSB0aGlzLmdldENvbmNhdGVuYXRlZE1hdHJpeCh0aGlzLl9tdHgpLmludmVydCgpO1xuXHRcdHZhciBwdCA9IHRoaXMuX210eC50cmFuc2Zvcm1Qb2ludChvLngsIG8ueSk7XG5cdFx0dmFyIGV2dCA9IG5ldyBjcmVhdGVqcy5Nb3VzZUV2ZW50KHR5cGUsIGJ1YmJsZXMsIGZhbHNlLCBwdC54LCBwdC55LCBuYXRpdmVFdmVudCwgcG9pbnRlcklkLCBwb2ludGVySWQ9PXRoaXMuX3ByaW1hcnlQb2ludGVySUQgfHwgcG9pbnRlcklkPT0tMSwgby5yYXdYLCBvLnJhd1kpO1xuXHRcdCovXG5cdFx0dmFyIGV2dCA9IG5ldyBjcmVhdGVqcy5Nb3VzZUV2ZW50KHR5cGUsIGJ1YmJsZXMsIGZhbHNlLCBvLngsIG8ueSwgbmF0aXZlRXZlbnQsIHBvaW50ZXJJZCwgcG9pbnRlcklkID09PSB0aGlzLl9wcmltYXJ5UG9pbnRlcklEIHx8IHBvaW50ZXJJZCA9PT0gLTEsIG8ucmF3WCwgby5yYXdZLCByZWxhdGVkVGFyZ2V0KTtcblx0XHR0YXJnZXQuZGlzcGF0Y2hFdmVudChldnQpO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuU3RhZ2UgPSBjcmVhdGVqcy5wcm9tb3RlKFN0YWdlLCBcIkNvbnRhaW5lclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBCaXRtYXAuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcblx0LyoqXG5cdCAqIEEgQml0bWFwIHJlcHJlc2VudHMgYW4gSW1hZ2UsIENhbnZhcywgb3IgVmlkZW8gaW4gdGhlIGRpc3BsYXkgbGlzdC4gQSBCaXRtYXAgY2FuIGJlIGluc3RhbnRpYXRlZCB1c2luZyBhbiBleGlzdGluZ1xuXHQgKiBIVE1MIGVsZW1lbnQsIG9yIGEgc3RyaW5nLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgdmFyIGJpdG1hcCA9IG5ldyBjcmVhdGVqcy5CaXRtYXAoXCJpbWFnZVBhdGguanBnXCIpO1xuXHQgKlxuXHQgKiA8c3Ryb25nPk5vdGVzOjwvc3Ryb25nPlxuXHQgKiA8b2w+XG5cdCAqICAgICA8bGk+V2hlbiBhIHN0cmluZyBwYXRoIG9yIGltYWdlIHRhZyB0aGF0IGlzIG5vdCB5ZXQgbG9hZGVkIGlzIHVzZWQsIHRoZSBzdGFnZSBtYXkgbmVlZCB0byBiZSByZWRyYXduIGJlZm9yZSBpdFxuXHQgKiAgICAgIHdpbGwgYmUgZGlzcGxheWVkLjwvbGk+XG5cdCAqICAgICA8bGk+Qml0bWFwcyB3aXRoIGFuIFNWRyBzb3VyY2UgY3VycmVudGx5IHdpbGwgbm90IHJlc3BlY3QgYW4gYWxwaGEgdmFsdWUgb3RoZXIgdGhhbiAwIG9yIDEuIFRvIGdldCBhcm91bmQgdGhpcyxcblx0ICogICAgIHRoZSBCaXRtYXAgY2FuIGJlIGNhY2hlZC48L2xpPlxuXHQgKiAgICAgPGxpPkJpdG1hcHMgd2l0aCBhbiBTVkcgc291cmNlIHdpbGwgdGFpbnQgdGhlIGNhbnZhcyB3aXRoIGNyb3NzLW9yaWdpbiBkYXRhLCB3aGljaCBwcmV2ZW50cyBpbnRlcmFjdGl2aXR5LiBUaGlzXG5cdCAqICAgICBoYXBwZW5zIGluIGFsbCBicm93c2VycyBleGNlcHQgcmVjZW50IEZpcmVmb3ggYnVpbGRzLjwvbGk+XG5cdCAqICAgICA8bGk+SW1hZ2VzIGxvYWRlZCBjcm9zcy1vcmlnaW4gd2lsbCB0aHJvdyBjcm9zcy1vcmlnaW4gc2VjdXJpdHkgZXJyb3JzIHdoZW4gaW50ZXJhY3RlZCB3aXRoIHVzaW5nIGEgbW91c2UsIHVzaW5nXG5cdCAqICAgICBtZXRob2RzIHN1Y2ggYXMgYGdldE9iamVjdFVuZGVyUG9pbnRgLCBvciB1c2luZyBmaWx0ZXJzLCBvciBjYWNoaW5nLiBZb3UgY2FuIGdldCBhcm91bmQgdGhpcyBieSBzZXR0aW5nXG5cdCAqICAgICBgY3Jvc3NPcmlnaW5gIGZsYWdzIG9uIHlvdXIgaW1hZ2VzIGJlZm9yZSBwYXNzaW5nIHRoZW0gdG8gRWFzZWxKUywgZWc6IGBpbWcuY3Jvc3NPcmlnaW49XCJBbm9ueW1vdXNcIjtgPC9saT5cblx0ICogPC9vbD5cblx0ICpcblx0ICogQGNsYXNzIEJpdG1hcFxuXHQgKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnQgfCBTdHJpbmd9IGltYWdlT3JVcmkgVGhlIHNvdXJjZSBvYmplY3Qgb3IgVVJJIHRvIGFuIGltYWdlIHRvXG5cdCAqIGRpc3BsYXkuIFRoaXMgY2FuIGJlIGVpdGhlciBhbiBJbWFnZSwgQ2FudmFzLCBvciBWaWRlbyBvYmplY3QsIG9yIGEgc3RyaW5nIFVSSSB0byBhbiBpbWFnZSBmaWxlIHRvIGxvYWQgYW5kIHVzZS5cblx0ICogSWYgaXQgaXMgYSBVUkksIGEgbmV3IEltYWdlIG9iamVjdCB3aWxsIGJlIGNvbnN0cnVjdGVkIGFuZCBhc3NpZ25lZCB0byB0aGUgLmltYWdlIHByb3BlcnR5LlxuXHQgKiovXG5cdGZ1bmN0aW9uIEJpdG1hcChpbWFnZU9yVXJpKSB7XG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X2NvbnN0cnVjdG9yKCk7XG5cdFx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSBpbWFnZSB0byByZW5kZXIuIFRoaXMgY2FuIGJlIGFuIEltYWdlLCBhIENhbnZhcywgb3IgYSBWaWRlby4gTm90IGFsbCBicm93c2VycyAoZXNwZWNpYWxseVxuXHRcdCAqIG1vYmlsZSBicm93c2Vycykgc3VwcG9ydCBkcmF3aW5nIHZpZGVvIHRvIGEgY2FudmFzLlxuXHRcdCAqIEBwcm9wZXJ0eSBpbWFnZVxuXHRcdCAqIEB0eXBlIEhUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnRcblx0XHQgKiovXG5cdFx0aWYgKHR5cGVvZiBpbWFnZU9yVXJpID09IFwic3RyaW5nXCIpIHtcblx0XHRcdHRoaXMuaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuXHRcdFx0dGhpcy5pbWFnZS5zcmMgPSBpbWFnZU9yVXJpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmltYWdlID0gaW1hZ2VPclVyaTtcblx0XHR9XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFNwZWNpZmllcyBhbiBhcmVhIG9mIHRoZSBzb3VyY2UgaW1hZ2UgdG8gZHJhdy4gSWYgb21pdHRlZCwgdGhlIHdob2xlIGltYWdlIHdpbGwgYmUgZHJhd24uXG5cdFx0ICogTm90ZSB0aGF0IHZpZGVvIHNvdXJjZXMgbXVzdCBoYXZlIGEgd2lkdGggLyBoZWlnaHQgc2V0IHRvIHdvcmsgY29ycmVjdGx5IHdpdGggYHNvdXJjZVJlY3RgLlxuXHRcdCAqIEBwcm9wZXJ0eSBzb3VyY2VSZWN0XG5cdFx0ICogQHR5cGUgUmVjdGFuZ2xlXG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMuc291cmNlUmVjdCA9IG51bGw7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQml0bWFwLCBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0KTtcblx0XG5cdFxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RvciBhbGlhcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIFRoaXMgbWV0aG9kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMuXG5cdCAqIFN1YmNsYXNzZXMgc2hvdWxkIGJlIHVwZGF0ZWQgdG8gdXNlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRzXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIGBjcmVhdGVqcy5wcm9tb3RlKClgXG5cdCAqKi9cblx0cC5pbml0aWFsaXplID0gQml0bWFwOyAvLyBUT0RPOiBkZXByZWNhdGVkLlxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzLlxuXHQgKiBUaGlzIGRvZXMgbm90IGFjY291bnQgZm9yIHdoZXRoZXIgaXQgd291bGQgYmUgdmlzaWJsZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHN0YWdlLlxuXHQgKlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkaXNwbGF5IG9iamVjdCB3b3VsZCBiZSB2aXNpYmxlIGlmIGRyYXduIHRvIGEgY2FudmFzXG5cdCAqKi9cblx0cC5pc1Zpc2libGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xuXHRcdHZhciBoYXNDb250ZW50ID0gdGhpcy5jYWNoZUNhbnZhcyB8fCAoaW1hZ2UgJiYgKGltYWdlLm5hdHVyYWxXaWR0aCB8fCBpbWFnZS5nZXRDb250ZXh0IHx8IGltYWdlLnJlYWR5U3RhdGUgPj0gMikpO1xuXHRcdHJldHVybiAhISh0aGlzLnZpc2libGUgJiYgdGhpcy5hbHBoYSA+IDAgJiYgdGhpcy5zY2FsZVggIT0gMCAmJiB0aGlzLnNjYWxlWSAhPSAwICYmIGhhc0NvbnRlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyB0aGUgZGlzcGxheSBvYmplY3QgaW50byB0aGUgc3BlY2lmaWVkIGNvbnRleHQgaWdub3JpbmcgaXRzIHZpc2libGUsIGFscGhhLCBzaGFkb3csIGFuZCB0cmFuc2Zvcm0uXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZHJhdyB3YXMgaGFuZGxlZCAodXNlZnVsIGZvciBvdmVycmlkaW5nIGZ1bmN0aW9uYWxpdHkpLlxuXHQgKlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgZHJhd1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtpZ25vcmVDYWNoZT1mYWxzZV0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRyYXcgb3BlcmF0aW9uIHNob3VsZCBpZ25vcmUgYW55IGN1cnJlbnQgY2FjaGUuXG5cdCAqIEZvciBleGFtcGxlLCB1c2VkIGZvciBkcmF3aW5nIHRoZSBjYWNoZSAodG8gcHJldmVudCBpdCBmcm9tIHNpbXBseSBkcmF3aW5nIGFuIGV4aXN0aW5nIGNhY2hlIGJhY2tcblx0ICogaW50byBpdHNlbGYpLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiovXG5cdHAuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgaWdub3JlQ2FjaGUpIHtcblx0XHRpZiAodGhpcy5EaXNwbGF5T2JqZWN0X2RyYXcoY3R4LCBpZ25vcmVDYWNoZSkgfHwgIXRoaXMuaW1hZ2UpIHsgcmV0dXJuIHRydWU7IH1cblx0XHR2YXIgaW1nID0gdGhpcy5pbWFnZSwgcmVjdCA9IHRoaXMuc291cmNlUmVjdDtcblx0XHRpZiAocmVjdCkge1xuXHRcdFx0Ly8gc29tZSBicm93c2VycyBjaG9rZSBvbiBvdXQgb2YgYm91bmQgdmFsdWVzLCBzbyB3ZSdsbCBmaXggdGhlbTpcblx0XHRcdHZhciB4MSA9IHJlY3QueCwgeTEgPSByZWN0LnksIHgyID0geDEgKyByZWN0LndpZHRoLCB5MiA9IHkxICsgcmVjdC5oZWlnaHQsIHggPSAwLCB5ID0gMCwgdyA9IGltZy53aWR0aCwgaCA9IGltZy5oZWlnaHQ7XG5cdFx0XHRpZiAoeDEgPCAwKSB7IHggLT0geDE7IHgxID0gMDsgfVxuXHRcdFx0aWYgKHgyID4gdykgeyB4MiA9IHc7IH1cblx0XHRcdGlmICh5MSA8IDApIHsgeSAtPSB5MTsgeTEgPSAwOyB9XG5cdFx0XHRpZiAoeTIgPiBoKSB7IHkyID0gaDsgfVxuXHRcdFx0Y3R4LmRyYXdJbWFnZShpbWcsIHgxLCB5MSwgeDIteDEsIHkyLXkxLCB4LCB5LCB4Mi14MSwgeTIteTEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdHguZHJhd0ltYWdlKGltZywgMCwgMCk7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHRcblx0Ly9Ob3RlLCB0aGUgZG9jIHNlY3Rpb25zIGJlbG93IGRvY3VtZW50IHVzaW5nIHRoZSBzcGVjaWZpZWQgQVBJcyAoZnJvbSBEaXNwbGF5T2JqZWN0KSAgZnJvbVxuXHQvL0JpdG1hcC4gVGhpcyBpcyB3aHkgdGhleSBoYXZlIG5vIG1ldGhvZCBpbXBsZW1lbnRhdGlvbnMuXG5cdFxuXHQvKipcblx0ICogQmVjYXVzZSB0aGUgY29udGVudCBvZiBhIEJpdG1hcCBpcyBhbHJlYWR5IGluIGEgc2ltcGxlIGZvcm1hdCwgY2FjaGUgaXMgdW5uZWNlc3NhcnkgZm9yIEJpdG1hcCBpbnN0YW5jZXMuXG5cdCAqIFlvdSBzaG91bGQgPGI+bm90PC9iPiBjYWNoZSBCaXRtYXAgaW5zdGFuY2VzIGFzIGl0IGNhbiBkZWdyYWRlIHBlcmZvcm1hbmNlLlxuXHQgKlxuXHQgKiA8c3Ryb25nPkhvd2V2ZXI6IElmIHlvdSB3YW50IHRvIHVzZSBhIGZpbHRlciBvbiBhIEJpdG1hcCwgeW91IDxlbT5NVVNUPC9lbT4gY2FjaGUgaXQsIG9yIGl0IHdpbGwgbm90IHdvcmsuPC9zdHJvbmc+XG5cdCAqIFRvIHNlZSB0aGUgQVBJIGZvciBjYWNoaW5nLCBwbGVhc2UgdmlzaXQgdGhlIERpc3BsYXlPYmplY3Qge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9jYWNoZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuXG5cdCAqIEBtZXRob2QgY2FjaGVcblx0ICoqL1xuXHRcblx0LyoqXG5cdCAqIEJlY2F1c2UgdGhlIGNvbnRlbnQgb2YgYSBCaXRtYXAgaXMgYWxyZWFkeSBpbiBhIHNpbXBsZSBmb3JtYXQsIGNhY2hlIGlzIHVubmVjZXNzYXJ5IGZvciBCaXRtYXAgaW5zdGFuY2VzLlxuXHQgKiBZb3Ugc2hvdWxkIDxiPm5vdDwvYj4gY2FjaGUgQml0bWFwIGluc3RhbmNlcyBhcyBpdCBjYW4gZGVncmFkZSBwZXJmb3JtYW5jZS5cblx0ICpcblx0ICogPHN0cm9uZz5Ib3dldmVyOiBJZiB5b3Ugd2FudCB0byB1c2UgYSBmaWx0ZXIgb24gYSBCaXRtYXAsIHlvdSA8ZW0+TVVTVDwvZW0+IGNhY2hlIGl0LCBvciBpdCB3aWxsIG5vdCB3b3JrLjwvc3Ryb25nPlxuXHQgKiBUbyBzZWUgdGhlIEFQSSBmb3IgY2FjaGluZywgcGxlYXNlIHZpc2l0IHRoZSBEaXNwbGF5T2JqZWN0IHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvY2FjaGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLlxuXHQgKiBAbWV0aG9kIHVwZGF0ZUNhY2hlXG5cdCAqKi9cblx0XG5cdC8qKlxuXHQgKiBCZWNhdXNlIHRoZSBjb250ZW50IG9mIGEgQml0bWFwIGlzIGFscmVhZHkgaW4gYSBzaW1wbGUgZm9ybWF0LCBjYWNoZSBpcyB1bm5lY2Vzc2FyeSBmb3IgQml0bWFwIGluc3RhbmNlcy5cblx0ICogWW91IHNob3VsZCA8Yj5ub3Q8L2I+IGNhY2hlIEJpdG1hcCBpbnN0YW5jZXMgYXMgaXQgY2FuIGRlZ3JhZGUgcGVyZm9ybWFuY2UuXG5cdCAqXG5cdCAqIDxzdHJvbmc+SG93ZXZlcjogSWYgeW91IHdhbnQgdG8gdXNlIGEgZmlsdGVyIG9uIGEgQml0bWFwLCB5b3UgPGVtPk1VU1Q8L2VtPiBjYWNoZSBpdCwgb3IgaXQgd2lsbCBub3Qgd29yay48L3N0cm9uZz5cblx0ICogVG8gc2VlIHRoZSBBUEkgZm9yIGNhY2hpbmcsIHBsZWFzZSB2aXNpdCB0aGUgRGlzcGxheU9iamVjdCB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L2NhY2hlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC5cblx0ICogQG1ldGhvZCB1bmNhY2hlXG5cdCAqKi9cblxuXHQvKipcblx0ICogRG9jY2VkIGluIHN1cGVyY2xhc3MuXG5cdCAqL1xuXHRwLmdldEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gdGhpcy5EaXNwbGF5T2JqZWN0X2dldEJvdW5kcygpO1xuXHRcdGlmIChyZWN0KSB7IHJldHVybiByZWN0OyB9XG5cdFx0dmFyIGltYWdlID0gdGhpcy5pbWFnZSwgbyA9IHRoaXMuc291cmNlUmVjdCB8fCBpbWFnZTtcblx0XHR2YXIgaGFzQ29udGVudCA9IChpbWFnZSAmJiAoaW1hZ2UubmF0dXJhbFdpZHRoIHx8IGltYWdlLmdldENvbnRleHQgfHwgaW1hZ2UucmVhZHlTdGF0ZSA+PSAyKSk7XG5cdFx0cmV0dXJuIGhhc0NvbnRlbnQgPyB0aGlzLl9yZWN0YW5nbGUuc2V0VmFsdWVzKDAsIDAsIG8ud2lkdGgsIG8uaGVpZ2h0KSA6IG51bGw7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBCaXRtYXAgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7Qml0bWFwfSBhIGNsb25lIG9mIHRoZSBCaXRtYXAgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvID0gbmV3IEJpdG1hcCh0aGlzLmltYWdlKTtcblx0XHRpZiAodGhpcy5zb3VyY2VSZWN0KSB7IG8uc291cmNlUmVjdCA9IHRoaXMuc291cmNlUmVjdC5jbG9uZSgpOyB9XG5cdFx0dGhpcy5fY2xvbmVQcm9wcyhvKTtcblx0XHRyZXR1cm4gbztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbQml0bWFwIChuYW1lPVwiKyAgdGhpcy5uYW1lICtcIildXCI7XG5cdH07XG5cblx0XG5cdGNyZWF0ZWpzLkJpdG1hcCA9IGNyZWF0ZWpzLnByb21vdGUoQml0bWFwLCBcIkRpc3BsYXlPYmplY3RcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU3ByaXRlLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBEaXNwbGF5cyBhIGZyYW1lIG9yIHNlcXVlbmNlIG9mIGZyYW1lcyAoaWUuIGFuIGFuaW1hdGlvbikgZnJvbSBhIFNwcml0ZVNoZWV0IGluc3RhbmNlLiBBIHNwcml0ZSBzaGVldCBpcyBhIHNlcmllcyBvZlxuXHQgKiBpbWFnZXMgKHVzdWFsbHkgYW5pbWF0aW9uIGZyYW1lcykgY29tYmluZWQgaW50byBhIHNpbmdsZSBpbWFnZS4gRm9yIGV4YW1wbGUsIGFuIGFuaW1hdGlvbiBjb25zaXN0aW5nIG9mIDggMTAweDEwMFxuXHQgKiBpbWFnZXMgY291bGQgYmUgY29tYmluZWQgaW50byBhIDQwMHgyMDAgc3ByaXRlIHNoZWV0ICg0IGZyYW1lcyBhY3Jvc3MgYnkgMiBoaWdoKS4gWW91IGNhbiBkaXNwbGF5IGluZGl2aWR1YWwgZnJhbWVzLFxuXHQgKiBwbGF5IGZyYW1lcyBhcyBhbiBhbmltYXRpb24sIGFuZCBldmVuIHNlcXVlbmNlIGFuaW1hdGlvbnMgdG9nZXRoZXIuXG5cdCAqXG5cdCAqIFNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gc2V0dGluZyB1cCBmcmFtZXMgYW5kIGFuaW1hdGlvbnMuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgY3JlYXRlanMuU3ByaXRlKHNwcml0ZVNoZWV0KTtcblx0ICogICAgICBpbnN0YW5jZS5nb3RvQW5kU3RvcChcImZyYW1lTmFtZVwiKTtcblx0ICpcblx0ICogVW50aWwge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2dvdG9BbmRTdG9wXCJ9fXt7L2Nyb3NzTGlua319IG9yIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9nb3RvQW5kUGxheVwifX17ey9jcm9zc0xpbmt9fSBpcyBjYWxsZWQsXG5cdCAqIG9ubHkgdGhlIGZpcnN0IGRlZmluZWQgZnJhbWUgZGVmaW5lZCBpbiB0aGUgc3ByaXRlIHNoZWV0IHdpbGwgYmUgZGlzcGxheWVkLlxuXHQgKlxuXHQgKiBAY2xhc3MgU3ByaXRlXG5cdCAqIEBleHRlbmRzIERpc3BsYXlPYmplY3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IHNwcml0ZVNoZWV0IFRoZSBTcHJpdGVTaGVldCBpbnN0YW5jZSB0byBwbGF5IGJhY2suIFRoaXMgaW5jbHVkZXMgdGhlIHNvdXJjZSBpbWFnZShzKSwgZnJhbWVcblx0ICogZGltZW5zaW9ucywgYW5kIGZyYW1lIGRhdGEuIFNlZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbZnJhbWVPckFuaW1hdGlvbl0gVGhlIGZyYW1lIG51bWJlciBvciBhbmltYXRpb24gdG8gcGxheSBpbml0aWFsbHkuXG5cdCAqKi9cblx0ZnVuY3Rpb24gU3ByaXRlKHNwcml0ZVNoZWV0LCBmcmFtZU9yQW5pbWF0aW9uKSB7XG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X2NvbnN0cnVjdG9yKCk7XG5cdFx0XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSBmcmFtZSBpbmRleCB0aGF0IHdpbGwgYmUgZHJhd24gd2hlbiBkcmF3IGlzIGNhbGxlZC4gTm90ZSB0aGF0IHdpdGggc29tZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIGRlZmluaXRpb25zLCB0aGlzIHdpbGwgYWR2YW5jZSBub24tc2VxdWVudGlhbGx5LiBUaGlzIHdpbGwgYWx3YXlzIGJlIGFuIGludGVnZXIgdmFsdWUuXG5cdFx0ICogQHByb3BlcnR5IGN1cnJlbnRGcmFtZVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBwbGF5aW5nIGFuaW1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgY3VycmVudEFuaW1hdGlvblxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGZpbmFsXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICoqL1xuXHRcdHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFByZXZlbnRzIHRoZSBhbmltYXRpb24gZnJvbSBhZHZhbmNpbmcgZWFjaCB0aWNrIGF1dG9tYXRpY2FsbHkuIEZvciBleGFtcGxlLCB5b3UgY291bGQgY3JlYXRlIGEgc3ByaXRlXG5cdFx0ICogc2hlZXQgb2YgaWNvbnMsIHNldCBwYXVzZWQgdG8gdHJ1ZSwgYW5kIGRpc3BsYXkgdGhlIGFwcHJvcHJpYXRlIGljb24gYnkgc2V0dGluZyA8Y29kZT5jdXJyZW50RnJhbWU8L2NvZGU+LlxuXHRcdCAqIEBwcm9wZXJ0eSBwYXVzZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqKi9cblx0XHR0aGlzLnBhdXNlZCA9IHRydWU7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBTcHJpdGVTaGVldCBpbnN0YW5jZSB0byBwbGF5IGJhY2suIFRoaXMgaW5jbHVkZXMgdGhlIHNvdXJjZSBpbWFnZSwgZnJhbWUgZGltZW5zaW9ucywgYW5kIGZyYW1lXG5cdFx0ICogZGF0YS4gU2VlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBzcHJpdGVTaGVldFxuXHRcdCAqIEB0eXBlIHtTcHJpdGVTaGVldH1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5zcHJpdGVTaGVldCA9IHNwcml0ZVNoZWV0O1xuXHRcblx0XHQvKipcblx0XHQgKiBTcGVjaWZpZXMgdGhlIGN1cnJlbnQgZnJhbWUgaW5kZXggd2l0aGluIHRoZSBjdXJyZW50bHkgcGxheWluZyBhbmltYXRpb24uIFdoZW4gcGxheWluZyBub3JtYWxseSwgdGhpcyB3aWxsIGluY3JlYXNlXG5cdFx0ICogZnJvbSAwIHRvIG4tMSwgd2hlcmUgbiBpcyB0aGUgbnVtYmVyIG9mIGZyYW1lcyBpbiB0aGUgY3VycmVudCBhbmltYXRpb24uXG5cdFx0ICpcblx0XHQgKiBUaGlzIGNvdWxkIGJlIGEgbm9uLWludGVnZXIgdmFsdWUgaWZcblx0XHQgKiB1c2luZyB0aW1lLWJhc2VkIHBsYXliYWNrIChzZWUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL2ZyYW1lcmF0ZVwifX17ey9jcm9zc0xpbmt9fSwgb3IgaWYgdGhlIGFuaW1hdGlvbidzIHNwZWVkIGlzXG5cdFx0ICogbm90IGFuIGludGVnZXIuXG5cdFx0ICogQHByb3BlcnR5IGN1cnJlbnRBbmltYXRpb25GcmFtZVxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqKi9cblx0XHR0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZSA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEJ5IGRlZmF1bHQgU3ByaXRlIGluc3RhbmNlcyBhZHZhbmNlIG9uZSBmcmFtZSBwZXIgdGljay4gU3BlY2lmeWluZyBhIGZyYW1lcmF0ZSBmb3IgdGhlIFNwcml0ZSAob3IgaXRzIHJlbGF0ZWRcblx0XHQgKiBTcHJpdGVTaGVldCkgd2lsbCBjYXVzZSBpdCB0byBhZHZhbmNlIGJhc2VkIG9uIGVsYXBzZWQgdGltZSBiZXR3ZWVuIHRpY2tzIGFzIGFwcHJvcHJpYXRlIHRvIG1haW50YWluIHRoZSB0YXJnZXRcblx0XHQgKiBmcmFtZXJhdGUuXG5cdFx0ICpcblx0XHQgKiBGb3IgZXhhbXBsZSwgaWYgYSBTcHJpdGUgd2l0aCBhIGZyYW1lcmF0ZSBvZiAxMCBpcyBwbGFjZWQgb24gYSBTdGFnZSBiZWluZyB1cGRhdGVkIGF0IDQwZnBzLCB0aGVuIHRoZSBTcHJpdGUgd2lsbFxuXHRcdCAqIGFkdmFuY2Ugcm91Z2hseSBvbmUgZnJhbWUgZXZlcnkgNCB0aWNrcy4gVGhpcyB3aWxsIG5vdCBiZSBleGFjdCwgYmVjYXVzZSB0aGUgdGltZSBiZXR3ZWVuIGVhY2ggdGljayB3aWxsXG5cdFx0ICogdmFyeSBzbGlnaHRseSBiZXR3ZWVuIGZyYW1lcy5cblx0XHQgKlxuXHRcdCAqIFRoaXMgZmVhdHVyZSBpcyBkZXBlbmRlbnQgb24gdGhlIHRpY2sgZXZlbnQgb2JqZWN0IChvciBhbiBvYmplY3Qgd2l0aCBhbiBhcHByb3ByaWF0ZSBcImRlbHRhXCIgcHJvcGVydHkpIGJlaW5nXG5cdFx0ICogcGFzc2VkIGludG8ge3sjY3Jvc3NMaW5rIFwiU3RhZ2UvdXBkYXRlXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBmcmFtZXJhdGVcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5mcmFtZXJhdGUgPSAwO1xuXHRcblx0XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBDdXJyZW50IGFuaW1hdGlvbiBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IF9hbmltYXRpb25cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2FuaW1hdGlvbiA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEN1cnJlbnQgZnJhbWUgaW5kZXguXG5cdFx0ICogQHByb3BlcnR5IF9jdXJyZW50RnJhbWVcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2N1cnJlbnRGcmFtZSA9IG51bGw7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogU2tpcHMgdGhlIG5leHQgYXV0byBhZHZhbmNlLiBVc2VkIGJ5IGdvdG9BbmRQbGF5IHRvIGF2b2lkIGltbWVkaWF0ZWx5IGp1bXBpbmcgdG8gdGhlIG5leHQgZnJhbWVcblx0XHQgKiBAcHJvcGVydHkgX3NraXBBZHZhbmNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3NraXBBZHZhbmNlID0gZmFsc2U7XG5cdFx0XG5cdFx0XG5cdFx0aWYgKGZyYW1lT3JBbmltYXRpb24gIT0gbnVsbCkgeyB0aGlzLmdvdG9BbmRQbGF5KGZyYW1lT3JBbmltYXRpb24pOyB9XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoU3ByaXRlLCBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0KTtcblxuXHQvKipcblx0ICogQ29uc3RydWN0b3IgYWxpYXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBUaGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zLlxuXHQgKiBTdWJjbGFzc2VzIHNob3VsZCBiZSB1cGRhdGVkIHRvIHVzZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kc1wifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBkZXByZWNhdGVkIGluIGZhdm91ciBvZiBgY3JlYXRlanMucHJvbW90ZSgpYFxuXHQgKiovXG5cdHAuaW5pdGlhbGl6ZSA9IFNwcml0ZTsgLy8gVE9ETzogRGVwcmVjYXRlZC4gVGhpcyBpcyBmb3IgYmFja3dhcmRzIHN1cHBvcnQgb2YgRmxhc2hDQyBzcHJpdGVzaGVldCBleHBvcnQuXG5cblxuLy8gZXZlbnRzOlxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIGFuIGFuaW1hdGlvbiByZWFjaGVzIGl0cyBlbmRzLlxuXHQgKiBAZXZlbnQgYW5pbWF0aW9uZW5kXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0aGF0IGp1c3QgZW5kZWQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuZXh0IFRoZSBuYW1lIG9mIHRoZSBuZXh0IGFuaW1hdGlvbiB0aGF0IHdpbGwgYmUgcGxheWVkLCBvciBudWxsLiBUaGlzIHdpbGwgYmUgdGhlIHNhbWUgYXMgbmFtZSBpZiB0aGUgYW5pbWF0aW9uIGlzIGxvb3BpbmcuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0IFxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCBhbnkgdGltZSB0aGUgY3VycmVudCBmcmFtZSBjaGFuZ2VzLiBGb3IgZXhhbXBsZSwgdGhpcyBjb3VsZCBiZSBkdWUgdG8gYXV0b21hdGljIGFkdmFuY2VtZW50IG9uIGEgdGljayxcblx0ICogb3IgY2FsbGluZyBnb3RvQW5kUGxheSgpIG9yIGdvdG9BbmRTdG9wKCkuXG5cdCAqIEBldmVudCBjaGFuZ2Vcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKi9cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXMuXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBpc1Zpc2libGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcblx0ICoqL1xuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYXNDb250ZW50ID0gdGhpcy5jYWNoZUNhbnZhcyB8fCB0aGlzLnNwcml0ZVNoZWV0LmNvbXBsZXRlO1xuXHRcdHJldHVybiAhISh0aGlzLnZpc2libGUgJiYgdGhpcy5hbHBoYSA+IDAgJiYgdGhpcy5zY2FsZVggIT0gMCAmJiB0aGlzLnNjYWxlWSAhPSAwICYmIGhhc0NvbnRlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyB0aGUgZGlzcGxheSBvYmplY3QgaW50byB0aGUgc3BlY2lmaWVkIGNvbnRleHQgaWdub3JpbmcgaXRzIHZpc2libGUsIGFscGhhLCBzaGFkb3csIGFuZCB0cmFuc2Zvcm0uXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZHJhdyB3YXMgaGFuZGxlZCAodXNlZnVsIGZvciBvdmVycmlkaW5nIGZ1bmN0aW9uYWxpdHkpLlxuXHQgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuXG5cdCAqIEBtZXRob2QgZHJhd1xuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSBjYW52YXMgMkQgY29udGV4dCBvYmplY3QgdG8gZHJhdyBpbnRvLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZUNhY2hlIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkcmF3IG9wZXJhdGlvbiBzaG91bGQgaWdub3JlIGFueSBjdXJyZW50IGNhY2hlLlxuXHQgKiBGb3IgZXhhbXBsZSwgdXNlZCBmb3IgZHJhd2luZyB0aGUgY2FjaGUgKHRvIHByZXZlbnQgaXQgZnJvbSBzaW1wbHkgZHJhd2luZyBhbiBleGlzdGluZyBjYWNoZSBiYWNrXG5cdCAqIGludG8gaXRzZWxmKS5cblx0ICoqL1xuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGlnbm9yZUNhY2hlKSB7XG5cdFx0aWYgKHRoaXMuRGlzcGxheU9iamVjdF9kcmF3KGN0eCwgaWdub3JlQ2FjaGUpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0dGhpcy5fbm9ybWFsaXplRnJhbWUoKTtcblx0XHR2YXIgbyA9IHRoaXMuc3ByaXRlU2hlZXQuZ2V0RnJhbWUodGhpcy5fY3VycmVudEZyYW1lfDApO1xuXHRcdGlmICghbykgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR2YXIgcmVjdCA9IG8ucmVjdDtcblx0XHRpZiAocmVjdC53aWR0aCAmJiByZWN0LmhlaWdodCkgeyBjdHguZHJhd0ltYWdlKG8uaW1hZ2UsIHJlY3QueCwgcmVjdC55LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCwgLW8ucmVnWCwgLW8ucmVnWSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpOyB9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0Ly9Ob3RlLCB0aGUgZG9jIHNlY3Rpb25zIGJlbG93IGRvY3VtZW50IHVzaW5nIHRoZSBzcGVjaWZpZWQgQVBJcyAoZnJvbSBEaXNwbGF5T2JqZWN0KSAgZnJvbVxuXHQvL0JpdG1hcC4gVGhpcyBpcyB3aHkgdGhleSBoYXZlIG5vIG1ldGhvZCBpbXBsZW1lbnRhdGlvbnMuXG5cblx0LyoqXG5cdCAqIEJlY2F1c2UgdGhlIGNvbnRlbnQgb2YgYSBTcHJpdGUgaXMgYWxyZWFkeSBpbiBhIHJhc3RlciBmb3JtYXQsIGNhY2hlIGlzIHVubmVjZXNzYXJ5IGZvciBTcHJpdGUgaW5zdGFuY2VzLlxuXHQgKiBZb3Ugc2hvdWxkIG5vdCBjYWNoZSBTcHJpdGUgaW5zdGFuY2VzIGFzIGl0IGNhbiBkZWdyYWRlIHBlcmZvcm1hbmNlLlxuXHQgKiBAbWV0aG9kIGNhY2hlXG5cdCAqKi9cblxuXHQvKipcblx0ICogQmVjYXVzZSB0aGUgY29udGVudCBvZiBhIFNwcml0ZSBpcyBhbHJlYWR5IGluIGEgcmFzdGVyIGZvcm1hdCwgY2FjaGUgaXMgdW5uZWNlc3NhcnkgZm9yIFNwcml0ZSBpbnN0YW5jZXMuXG5cdCAqIFlvdSBzaG91bGQgbm90IGNhY2hlIFNwcml0ZSBpbnN0YW5jZXMgYXMgaXQgY2FuIGRlZ3JhZGUgcGVyZm9ybWFuY2UuXG5cdCAqIEBtZXRob2QgdXBkYXRlQ2FjaGVcblx0ICoqL1xuXG5cdC8qKlxuXHQgKiBCZWNhdXNlIHRoZSBjb250ZW50IG9mIGEgU3ByaXRlIGlzIGFscmVhZHkgaW4gYSByYXN0ZXIgZm9ybWF0LCBjYWNoZSBpcyB1bm5lY2Vzc2FyeSBmb3IgU3ByaXRlIGluc3RhbmNlcy5cblx0ICogWW91IHNob3VsZCBub3QgY2FjaGUgU3ByaXRlIGluc3RhbmNlcyBhcyBpdCBjYW4gZGVncmFkZSBwZXJmb3JtYW5jZS5cblx0ICogQG1ldGhvZCB1bmNhY2hlXG5cdCAqKi9cblxuXHQvKipcblx0ICogUGxheSAodW5wYXVzZSkgdGhlIGN1cnJlbnQgYW5pbWF0aW9uLiBUaGUgU3ByaXRlIHdpbGwgYmUgcGF1c2VkIGlmIGVpdGhlciB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvc3RvcFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvciB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFN0b3BcIn19e3svY3Jvc3NMaW5rfX0gaXMgY2FsbGVkLiBTaW5nbGUgZnJhbWUgYW5pbWF0aW9ucyB3aWxsIHJlbWFpblxuXHQgKiB1bmNoYW5nZWQuXG5cdCAqIEBtZXRob2QgcGxheVxuXHQgKiovXG5cdHAucGxheSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucGF1c2VkID0gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3AgcGxheWluZyBhIHJ1bm5pbmcgYW5pbWF0aW9uLiBUaGUgU3ByaXRlIHdpbGwgYmUgcGxheWluZyBpZiB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaXMgY2FsbGVkLiBOb3RlIHRoYXQgY2FsbGluZyB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX0gb3Ige3sjY3Jvc3NMaW5rIFwiU3ByaXRlL3BsYXlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2lsbCByZXN1bWUgcGxheWJhY2suXG5cdCAqIEBtZXRob2Qgc3RvcFxuXHQgKiovXG5cdHAuc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyBwYXVzZWQgdG8gZmFsc2UgYW5kIHBsYXlzIHRoZSBzcGVjaWZpZWQgYW5pbWF0aW9uIG5hbWUsIG5hbWVkIGZyYW1lLCBvciBmcmFtZSBudW1iZXIuXG5cdCAqIEBtZXRob2QgZ290b0FuZFBsYXlcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBmcmFtZU9yQW5pbWF0aW9uIFRoZSBmcmFtZSBudW1iZXIgb3IgYW5pbWF0aW9uIG5hbWUgdGhhdCB0aGUgcGxheWhlYWQgc2hvdWxkIG1vdmUgdG9cblx0ICogYW5kIGJlZ2luIHBsYXlpbmcuXG5cdCAqKi9cblx0cC5nb3RvQW5kUGxheSA9IGZ1bmN0aW9uKGZyYW1lT3JBbmltYXRpb24pIHtcblx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3NraXBBZHZhbmNlID0gdHJ1ZTtcblx0XHR0aGlzLl9nb3RvKGZyYW1lT3JBbmltYXRpb24pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHBhdXNlZCB0byB0cnVlIGFuZCBzZWVrcyB0byB0aGUgc3BlY2lmaWVkIGFuaW1hdGlvbiBuYW1lLCBuYW1lZCBmcmFtZSwgb3IgZnJhbWUgbnVtYmVyLlxuXHQgKiBAbWV0aG9kIGdvdG9BbmRTdG9wXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gZnJhbWVPckFuaW1hdGlvbiBUaGUgZnJhbWUgbnVtYmVyIG9yIGFuaW1hdGlvbiBuYW1lIHRoYXQgdGhlIHBsYXloZWFkIHNob3VsZCBtb3ZlIHRvXG5cdCAqIGFuZCBzdG9wLlxuXHQgKiovXG5cdHAuZ290b0FuZFN0b3AgPSBmdW5jdGlvbihmcmFtZU9yQW5pbWF0aW9uKSB7XG5cdFx0dGhpcy5wYXVzZWQgPSB0cnVlO1xuXHRcdHRoaXMuX2dvdG8oZnJhbWVPckFuaW1hdGlvbik7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoZSBwbGF5aGVhZC4gVGhpcyBvY2N1cnMgYXV0b21hdGljYWxseSBlYWNoIHRpY2sgYnkgZGVmYXVsdC5cblx0ICogQHBhcmFtIFt0aW1lXSB7TnVtYmVyfSBUaGUgYW1vdW50IG9mIHRpbWUgaW4gbXMgdG8gYWR2YW5jZSBieS4gT25seSBhcHBsaWNhYmxlIGlmIGZyYW1lcmF0ZSBpcyBzZXQgb24gdGhlIFNwcml0ZVxuXHQgKiBvciBpdHMgU3ByaXRlU2hlZXQuXG5cdCAqIEBtZXRob2QgYWR2YW5jZVxuXHQqL1xuXHRwLmFkdmFuY2UgPSBmdW5jdGlvbih0aW1lKSB7XG5cdFx0dmFyIGZwcyA9IHRoaXMuZnJhbWVyYXRlIHx8IHRoaXMuc3ByaXRlU2hlZXQuZnJhbWVyYXRlO1xuXHRcdHZhciB0ID0gKGZwcyAmJiB0aW1lICE9IG51bGwpID8gdGltZS8oMTAwMC9mcHMpIDogMTtcblx0XHR0aGlzLl9ub3JtYWxpemVGcmFtZSh0KTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEge3sjY3Jvc3NMaW5rIFwiUmVjdGFuZ2xlXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlIGRlZmluaW5nIHRoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnQgZnJhbWUgcmVsYXRpdmUgdG9cblx0ICogdGhlIG9yaWdpbi4gRm9yIGV4YW1wbGUsIGEgOTAgeCA3MCBmcmFtZSB3aXRoIDxjb2RlPnJlZ1g9NTA8L2NvZGU+IGFuZCA8Y29kZT5yZWdZPTQwPC9jb2RlPiB3b3VsZCByZXR1cm4gYVxuXHQgKiByZWN0YW5nbGUgd2l0aCBbeD0tNTAsIHk9LTQwLCB3aWR0aD05MCwgaGVpZ2h0PTcwXS4gVGhpcyBpZ25vcmVzIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgZGlzcGxheSBvYmplY3QuXG5cdCAqXG5cdCAqIEFsc28gc2VlIHRoZSBTcHJpdGVTaGVldCB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldC9nZXRGcmFtZUJvdW5kc1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cdCAqIEBtZXRob2QgZ2V0Qm91bmRzXG5cdCAqIEByZXR1cm4ge1JlY3RhbmdsZX0gQSBSZWN0YW5nbGUgaW5zdGFuY2UuIFJldHVybnMgbnVsbCBpZiB0aGUgZnJhbWUgZG9lcyBub3QgZXhpc3QsIG9yIHRoZSBpbWFnZSBpcyBub3QgZnVsbHlcblx0ICogbG9hZGVkLlxuXHQgKiovXG5cdHAuZ2V0Qm91bmRzID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gVE9ETzogc2hvdWxkIHRoaXMgbm9ybWFsaXplRnJhbWU/XG5cdFx0cmV0dXJuIHRoaXMuRGlzcGxheU9iamVjdF9nZXRCb3VuZHMoKSB8fCB0aGlzLnNwcml0ZVNoZWV0LmdldEZyYW1lQm91bmRzKHRoaXMuY3VycmVudEZyYW1lLCB0aGlzLl9yZWN0YW5nbGUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFNwcml0ZSBpbnN0YW5jZS4gTm90ZSB0aGF0IHRoZSBzYW1lIFNwcml0ZVNoZWV0IGlzIHNoYXJlZCBiZXR3ZWVuIGNsb25lZFxuXHQgKiBpbnN0YW5jZXMuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7U3ByaXRlfSBhIGNsb25lIG9mIHRoZSBTcHJpdGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZVByb3BzKG5ldyBTcHJpdGUodGhpcy5zcHJpdGVTaGVldCkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbU3ByaXRlIChuYW1lPVwiKyAgdGhpcy5uYW1lICtcIildXCI7XG5cdH07XG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX2Nsb25lUHJvcHNcblx0ICogQHBhcmFtIHtTcHJpdGV9IG9cblx0ICogQHJldHVybiB7U3ByaXRlfSBvXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9jbG9uZVByb3BzID0gZnVuY3Rpb24obykge1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9fY2xvbmVQcm9wcyhvKTtcblx0XHRvLmN1cnJlbnRGcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuXHRcdG8uY3VycmVudEFuaW1hdGlvbiA9IHRoaXMuY3VycmVudEFuaW1hdGlvbjtcblx0XHRvLnBhdXNlZCA9IHRoaXMucGF1c2VkO1xuXHRcdG8uY3VycmVudEFuaW1hdGlvbkZyYW1lID0gdGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWU7XG5cdFx0by5mcmFtZXJhdGUgPSB0aGlzLmZyYW1lcmF0ZTtcblx0XHRcblx0XHRvLl9hbmltYXRpb24gPSB0aGlzLl9hbmltYXRpb247XG5cdFx0by5fY3VycmVudEZyYW1lID0gdGhpcy5fY3VycmVudEZyYW1lO1xuXHRcdG8uX3NraXBBZHZhbmNlID0gdGhpcy5fc2tpcEFkdmFuY2U7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cdFxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhlIDxjb2RlPmN1cnJlbnRGcmFtZTwvY29kZT4gaWYgcGF1c2VkIGlzIG5vdCB0cnVlLiBUaGlzIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIHt7I2Nyb3NzTGluayBcIlN0YWdlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHRpY2tzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZ0T2JqIEFuIGV2ZW50IG9iamVjdCB0aGF0IHdpbGwgYmUgZGlzcGF0Y2hlZCB0byBhbGwgdGljayBsaXN0ZW5lcnMuIFRoaXMgb2JqZWN0IGlzIHJldXNlZCBiZXR3ZWVuIGRpc3BhdGNoZXJzIHRvIHJlZHVjZSBjb25zdHJ1Y3Rpb24gJiBHQyBjb3N0cy5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAbWV0aG9kIF90aWNrXG5cdCAqKi9cblx0cC5fdGljayA9IGZ1bmN0aW9uKGV2dE9iaikge1xuXHRcdGlmICghdGhpcy5wYXVzZWQpIHtcblx0XHRcdGlmICghdGhpcy5fc2tpcEFkdmFuY2UpIHsgdGhpcy5hZHZhbmNlKGV2dE9iaiYmZXZ0T2JqLmRlbHRhKTsgfVxuXHRcdFx0dGhpcy5fc2tpcEFkdmFuY2UgPSBmYWxzZTtcblx0XHR9XG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X190aWNrKGV2dE9iaik7XG5cdH07XG5cblxuXHQvKipcblx0ICogTm9ybWFsaXplcyB0aGUgY3VycmVudCBmcmFtZSwgYWR2YW5jaW5nIGFuaW1hdGlvbnMgYW5kIGRpc3BhdGNoaW5nIGNhbGxiYWNrcyBhcyBhcHByb3ByaWF0ZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAbWV0aG9kIF9ub3JtYWxpemVGcmFtZVxuXHQgKiovXG5cdHAuX25vcm1hbGl6ZUZyYW1lID0gZnVuY3Rpb24oZnJhbWVEZWx0YSkge1xuXHRcdGZyYW1lRGVsdGEgPSBmcmFtZURlbHRhIHx8IDA7XG5cdFx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuX2FuaW1hdGlvbjtcblx0XHR2YXIgcGF1c2VkID0gdGhpcy5wYXVzZWQ7XG5cdFx0dmFyIGZyYW1lID0gdGhpcy5fY3VycmVudEZyYW1lO1xuXHRcdHZhciBsO1xuXHRcdFxuXHRcdGlmIChhbmltYXRpb24pIHtcblx0XHRcdHZhciBzcGVlZCA9IGFuaW1hdGlvbi5zcGVlZCB8fCAxO1xuXHRcdFx0dmFyIGFuaW1GcmFtZSA9IHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lO1xuXHRcdFx0bCA9IGFuaW1hdGlvbi5mcmFtZXMubGVuZ3RoO1xuXHRcdFx0aWYgKGFuaW1GcmFtZSArIGZyYW1lRGVsdGEgKiBzcGVlZCA+PSBsKSB7XG5cdFx0XHRcdHZhciBuZXh0ID0gYW5pbWF0aW9uLm5leHQ7XG5cdFx0XHRcdGlmICh0aGlzLl9kaXNwYXRjaEFuaW1hdGlvbkVuZChhbmltYXRpb24sIGZyYW1lLCBwYXVzZWQsIG5leHQsIGwgLSAxKSkge1xuXHRcdFx0XHRcdC8vIHNvbWV0aGluZyBjaGFuZ2VkIGluIHRoZSBldmVudCBzdGFjaywgc28gd2Ugc2hvdWxkbid0IG1ha2UgYW55IG1vcmUgY2hhbmdlcyBoZXJlLlxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0Ly8gc2VxdWVuY2UuIEF1dG9tYXRpY2FsbHkgY2FsbHMgX25vcm1hbGl6ZUZyYW1lIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBmcmFtZXMuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2dvdG8obmV4dCwgZnJhbWVEZWx0YSAtIChsIC0gYW5pbUZyYW1lKSAvIHNwZWVkKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBlbmQuXG5cdFx0XHRcdFx0dGhpcy5wYXVzZWQgPSB0cnVlO1xuXHRcdFx0XHRcdGFuaW1GcmFtZSA9IGFuaW1hdGlvbi5mcmFtZXMubGVuZ3RoIC0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YW5pbUZyYW1lICs9IGZyYW1lRGVsdGEgKiBzcGVlZDtcblx0XHRcdH1cblx0XHRcdHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lID0gYW5pbUZyYW1lO1xuXHRcdFx0dGhpcy5fY3VycmVudEZyYW1lID0gYW5pbWF0aW9uLmZyYW1lc1thbmltRnJhbWUgfCAwXVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmcmFtZSA9ICh0aGlzLl9jdXJyZW50RnJhbWUgKz0gZnJhbWVEZWx0YSk7XG5cdFx0XHRsID0gdGhpcy5zcHJpdGVTaGVldC5nZXROdW1GcmFtZXMoKTtcblx0XHRcdGlmIChmcmFtZSA+PSBsICYmIGwgPiAwKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fZGlzcGF0Y2hBbmltYXRpb25FbmQoYW5pbWF0aW9uLCBmcmFtZSwgcGF1c2VkLCBsIC0gMSkpIHtcblx0XHRcdFx0XHQvLyBsb29wZWQuXG5cdFx0XHRcdFx0aWYgKCh0aGlzLl9jdXJyZW50RnJhbWUgLT0gbCkgPj0gbCkgeyByZXR1cm4gdGhpcy5fbm9ybWFsaXplRnJhbWUoKTsgfVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZyYW1lID0gdGhpcy5fY3VycmVudEZyYW1lIHwgMDtcblx0XHRpZiAodGhpcy5jdXJyZW50RnJhbWUgIT0gZnJhbWUpIHtcblx0XHRcdHRoaXMuY3VycmVudEZyYW1lID0gZnJhbWU7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJjaGFuZ2VcIik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVzIHRoZSBcImFuaW1hdGlvbmVuZFwiIGV2ZW50LiBSZXR1cm5zIHRydWUgaWYgYSBoYW5kbGVyIGNoYW5nZWQgdGhlIGFuaW1hdGlvbiAoZXguIGNhbGxpbmcge3sjY3Jvc3NMaW5rIFwiU3ByaXRlL3N0b3BcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIHt7I2Nyb3NzTGluayBcIlNwcml0ZS9nb3RvQW5kUGxheVwifX17ey9jcm9zc0xpbmt9fSwgZXRjLilcblx0ICogQHByb3BlcnR5IF9kaXNwYXRjaEFuaW1hdGlvbkVuZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdCAqKi9cblx0cC5fZGlzcGF0Y2hBbmltYXRpb25FbmQgPSBmdW5jdGlvbihhbmltYXRpb24sIGZyYW1lLCBwYXVzZWQsIG5leHQsIGVuZCkge1xuXHRcdHZhciBuYW1lID0gYW5pbWF0aW9uID8gYW5pbWF0aW9uLm5hbWUgOiBudWxsO1xuXHRcdGlmICh0aGlzLmhhc0V2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIikpIHtcblx0XHRcdHZhciBldnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJhbmltYXRpb25lbmRcIik7XG5cdFx0XHRldnQubmFtZSA9IG5hbWU7XG5cdFx0XHRldnQubmV4dCA9IG5leHQ7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblx0XHR9XG5cdFx0Ly8gZGlkIHRoZSBhbmltYXRpb24gZ2V0IGNoYW5nZWQgaW4gdGhlIGV2ZW50IHN0YWNrPzpcblx0XHR2YXIgY2hhbmdlZCA9ICh0aGlzLl9hbmltYXRpb24gIT0gYW5pbWF0aW9uIHx8IHRoaXMuX2N1cnJlbnRGcmFtZSAhPSBmcmFtZSk7XG5cdFx0Ly8gaWYgdGhlIGFuaW1hdGlvbiBoYXNuJ3QgY2hhbmdlZCwgYnV0IHRoZSBzcHJpdGUgd2FzIHBhdXNlZCwgdGhlbiB3ZSB3YW50IHRvIHN0aWNrIHRvIHRoZSBsYXN0IGZyYW1lOlxuXHRcdGlmICghY2hhbmdlZCAmJiAhcGF1c2VkICYmIHRoaXMucGF1c2VkKSB7IHRoaXMuY3VycmVudEFuaW1hdGlvbkZyYW1lID0gZW5kOyBjaGFuZ2VkID0gdHJ1ZTsgfVxuXHRcdHJldHVybiBjaGFuZ2VkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBNb3ZlcyB0aGUgcGxheWhlYWQgdG8gdGhlIHNwZWNpZmllZCBmcmFtZSBudW1iZXIgb3IgYW5pbWF0aW9uLlxuXHQgKiBAbWV0aG9kIF9nb3RvXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gZnJhbWVPckFuaW1hdGlvbiBUaGUgZnJhbWUgbnVtYmVyIG9yIGFuaW1hdGlvbiB0aGF0IHRoZSBwbGF5aGVhZCBzaG91bGQgbW92ZSB0by5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbZnJhbWVdIFRoZSBmcmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIGdvIHRvLiBEZWZhdWx0cyB0byAwLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ290byA9IGZ1bmN0aW9uKGZyYW1lT3JBbmltYXRpb24sIGZyYW1lKSB7XG5cdFx0dGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWUgPSAwO1xuXHRcdGlmIChpc05hTihmcmFtZU9yQW5pbWF0aW9uKSkge1xuXHRcdFx0dmFyIGRhdGEgPSB0aGlzLnNwcml0ZVNoZWV0LmdldEFuaW1hdGlvbihmcmFtZU9yQW5pbWF0aW9uKTtcblx0XHRcdGlmIChkYXRhKSB7XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvbiA9IGRhdGE7XG5cdFx0XHRcdHRoaXMuY3VycmVudEFuaW1hdGlvbiA9IGZyYW1lT3JBbmltYXRpb247XG5cdFx0XHRcdHRoaXMuX25vcm1hbGl6ZUZyYW1lKGZyYW1lKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jdXJyZW50QW5pbWF0aW9uID0gdGhpcy5fYW5pbWF0aW9uID0gbnVsbDtcblx0XHRcdHRoaXMuX2N1cnJlbnRGcmFtZSA9IGZyYW1lT3JBbmltYXRpb247XG5cdFx0XHR0aGlzLl9ub3JtYWxpemVGcmFtZSgpO1xuXHRcdH1cblx0fTtcblxuXG5cdGNyZWF0ZWpzLlNwcml0ZSA9IGNyZWF0ZWpzLnByb21vdGUoU3ByaXRlLCBcIkRpc3BsYXlPYmplY3RcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU2hhcGUuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEEgU2hhcGUgYWxsb3dzIHlvdSB0byBkaXNwbGF5IHZlY3RvciBhcnQgaW4gdGhlIGRpc3BsYXkgbGlzdC4gSXQgY29tcG9zaXRlcyBhIHt7I2Nyb3NzTGluayBcIkdyYXBoaWNzXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGluc3RhbmNlIHdoaWNoIGV4cG9zZXMgYWxsIG9mIHRoZSB2ZWN0b3IgZHJhd2luZyBtZXRob2RzLiBUaGUgR3JhcGhpY3MgaW5zdGFuY2UgY2FuIGJlIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIFNoYXBlXG5cdCAqIGluc3RhbmNlcyB0byBkaXNwbGF5IHRoZSBzYW1lIHZlY3RvciBncmFwaGljcyB3aXRoIGRpZmZlcmVudCBwb3NpdGlvbnMgb3IgdHJhbnNmb3Jtcy5cblx0ICpcblx0ICogSWYgdGhlIHZlY3RvciBhcnQgd2lsbCBub3Rcblx0ICogY2hhbmdlIGJldHdlZW4gZHJhd3MsIHlvdSBtYXkgd2FudCB0byB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvY2FjaGVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIHRvIHJlZHVjZSB0aGVcblx0ICogcmVuZGVyaW5nIGNvc3QuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgZ3JhcGhpY3MgPSBuZXcgY3JlYXRlanMuR3JhcGhpY3MoKS5iZWdpbkZpbGwoXCIjZmYwMDAwXCIpLmRyYXdSZWN0KDAsIDAsIDEwMCwgMTAwKTtcblx0ICogICAgICB2YXIgc2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoZ3JhcGhpY3MpO1xuXHQgKlxuXHQgKiAgICAgIC8vQWx0ZXJuYXRpdmVseSB1c2UgY2FuIGFsc28gdXNlIHRoZSBncmFwaGljcyBwcm9wZXJ0eSBvZiB0aGUgU2hhcGUgY2xhc3MgdG8gcmVuZGVyZXIgdGhlIHNhbWUgYXMgYWJvdmUuXG5cdCAqICAgICAgdmFyIHNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG5cdCAqICAgICAgc2hhcGUuZ3JhcGhpY3MuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3UmVjdCgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqXG5cdCAqIEBjbGFzcyBTaGFwZVxuXHQgKiBAZXh0ZW5kcyBEaXNwbGF5T2JqZWN0XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0dyYXBoaWNzfSBncmFwaGljcyBPcHRpb25hbC4gVGhlIGdyYXBoaWNzIGluc3RhbmNlIHRvIGRpc3BsYXkuIElmIG51bGwsIGEgbmV3IEdyYXBoaWNzIGluc3RhbmNlIHdpbGwgYmUgY3JlYXRlZC5cblx0ICoqL1xuXHRmdW5jdGlvbiBTaGFwZShncmFwaGljcykge1xuXHRcdHRoaXMuRGlzcGxheU9iamVjdF9jb25zdHJ1Y3RvcigpO1xuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgZ3JhcGhpY3MgaW5zdGFuY2UgdG8gZGlzcGxheS5cblx0XHQgKiBAcHJvcGVydHkgZ3JhcGhpY3Ncblx0XHQgKiBAdHlwZSBHcmFwaGljc1xuXHRcdCAqKi9cblx0XHR0aGlzLmdyYXBoaWNzID0gZ3JhcGhpY3MgPyBncmFwaGljcyA6IG5ldyBjcmVhdGVqcy5HcmFwaGljcygpO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFNoYXBlLCBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0KTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIFNoYXBlIHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXMuXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBpc1Zpc2libGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIFNoYXBlIHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcblx0ICoqL1xuXHRwLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYXNDb250ZW50ID0gdGhpcy5jYWNoZUNhbnZhcyB8fCAodGhpcy5ncmFwaGljcyAmJiAhdGhpcy5ncmFwaGljcy5pc0VtcHR5KCkpO1xuXHRcdHJldHVybiAhISh0aGlzLnZpc2libGUgJiYgdGhpcy5hbHBoYSA+IDAgJiYgdGhpcy5zY2FsZVggIT0gMCAmJiB0aGlzLnNjYWxlWSAhPSAwICYmIGhhc0NvbnRlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyB0aGUgU2hhcGUgaW50byB0aGUgc3BlY2lmaWVkIGNvbnRleHQgaWdub3JpbmcgaXRzIHZpc2libGUsIGFscGhhLCBzaGFkb3csIGFuZCB0cmFuc2Zvcm0uIFJldHVybnMgdHJ1ZSBpZlxuXHQgKiB0aGUgZHJhdyB3YXMgaGFuZGxlZCAodXNlZnVsIGZvciBvdmVycmlkaW5nIGZ1bmN0aW9uYWxpdHkpLlxuXHQgKlxuXHQgKiA8aT5OT1RFOiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgZm9yIGludGVybmFsIHVzZSwgdGhvdWdoIGl0IG1heSBiZSB1c2VmdWwgZm9yIGFkdmFuY2VkIHVzZXMuPC9pPlxuXHQgKiBAbWV0aG9kIGRyYXdcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbaWdub3JlQ2FjaGU9ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkcmF3IG9wZXJhdGlvbiBzaG91bGQgaWdub3JlIGFueSBjdXJyZW50IGNhY2hlLiBGb3IgZXhhbXBsZSxcblx0ICogdXNlZCBmb3IgZHJhd2luZyB0aGUgY2FjaGUgKHRvIHByZXZlbnQgaXQgZnJvbSBzaW1wbHkgZHJhd2luZyBhbiBleGlzdGluZyBjYWNoZSBiYWNrIGludG8gaXRzZWxmKS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICoqL1xuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGlnbm9yZUNhY2hlKSB7XG5cdFx0aWYgKHRoaXMuRGlzcGxheU9iamVjdF9kcmF3KGN0eCwgaWdub3JlQ2FjaGUpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0dGhpcy5ncmFwaGljcy5kcmF3KGN0eCwgdGhpcyk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGlzIFNoYXBlLiBTb21lIHByb3BlcnRpZXMgdGhhdCBhcmUgc3BlY2lmaWMgdG8gdGhpcyBpbnN0YW5jZSdzIGN1cnJlbnQgY29udGV4dCBhcmUgcmV2ZXJ0ZWQgdG9cblx0ICogdGhlaXIgZGVmYXVsdHMgKGZvciBleGFtcGxlIC5wYXJlbnQpLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVjdXJzaXZlIElmIHRydWUsIHRoaXMgU2hhcGUncyB7eyNjcm9zc0xpbmsgXCJHcmFwaGljc1wifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZSB3aWxsIGFsc28gYmVcblx0ICogY2xvbmVkLiBJZiBmYWxzZSwgdGhlIEdyYXBoaWNzIGluc3RhbmNlIHdpbGwgYmUgc2hhcmVkIHdpdGggdGhlIG5ldyBTaGFwZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24ocmVjdXJzaXZlKSB7XG5cdFx0dmFyIGcgPSAocmVjdXJzaXZlICYmIHRoaXMuZ3JhcGhpY3MpID8gdGhpcy5ncmFwaGljcy5jbG9uZSgpIDogdGhpcy5ncmFwaGljcztcblx0XHRyZXR1cm4gIHRoaXMuX2Nsb25lUHJvcHMobmV3IFNoYXBlKGcpKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1NoYXBlIChuYW1lPVwiKyAgdGhpcy5uYW1lICtcIildXCI7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5TaGFwZSA9IGNyZWF0ZWpzLnByb21vdGUoU2hhcGUsIFwiRGlzcGxheU9iamVjdFwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUZXh0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBEaXNwbGF5IG9uZSBvciBtb3JlIGxpbmVzIG9mIGR5bmFtaWMgdGV4dCAobm90IHVzZXIgZWRpdGFibGUpIGluIHRoZSBkaXNwbGF5IGxpc3QuIExpbmUgd3JhcHBpbmcgc3VwcG9ydCAodXNpbmcgdGhlXG5cdCAqIGxpbmVXaWR0aCkgaXMgdmVyeSBiYXNpYywgd3JhcHBpbmcgb24gc3BhY2VzIGFuZCB0YWJzIG9ubHkuIE5vdGUgdGhhdCBhcyBhbiBhbHRlcm5hdGl2ZSB0byBUZXh0LCB5b3UgY2FuIHBvc2l0aW9uIEhUTUxcblx0ICogdGV4dCBhYm92ZSBvciBiZWxvdyB0aGUgY2FudmFzIHJlbGF0aXZlIHRvIGl0ZW1zIGluIHRoZSBkaXNwbGF5IGxpc3QgdXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3QvbG9jYWxUb0dsb2JhbFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QsIG9yIHVzaW5nIHt7I2Nyb3NzTGluayBcIkRPTUVsZW1lbnRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIDxiPlBsZWFzZSBub3RlIHRoYXQgVGV4dCBkb2VzIG5vdCBzdXBwb3J0IEhUTUwgdGV4dCwgYW5kIGNhbiBvbmx5IGRpc3BsYXkgb25lIGZvbnQgc3R5bGUgYXQgYSB0aW1lLjwvYj4gVG8gdXNlXG5cdCAqIG11bHRpcGxlIGZvbnQgc3R5bGVzLCB5b3Ugd2lsbCBuZWVkIHRvIGNyZWF0ZSBtdWx0aXBsZSB0ZXh0IGluc3RhbmNlcywgYW5kIHBvc2l0aW9uIHRoZW0gbWFudWFsbHkuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgdGV4dCA9IG5ldyBjcmVhdGVqcy5UZXh0KFwiSGVsbG8gV29ybGRcIiwgXCIyMHB4IEFyaWFsXCIsIFwiI2ZmNzcwMFwiKTtcblx0ICogICAgICB0ZXh0LnggPSAxMDA7XG5cdCAqICAgICAgdGV4dC50ZXh0QmFzZWxpbmUgPSBcImFscGhhYmV0aWNcIjtcblx0ICpcblx0ICogQ3JlYXRlSlMgVGV4dCBzdXBwb3J0cyB3ZWIgZm9udHMgKHRoZSBzYW1lIHJ1bGVzIGFzIENhbnZhcykuIFRoZSBmb250IG11c3QgYmUgbG9hZGVkIGFuZCBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXJcblx0ICogYmVmb3JlIGl0IGNhbiBiZSBkaXNwbGF5ZWQuXG5cdCAqXG5cdCAqIDxzdHJvbmc+Tm90ZTo8L3N0cm9uZz4gVGV4dCBjYW4gYmUgZXhwZW5zaXZlIHRvIGdlbmVyYXRlLCBzbyBjYWNoZSBpbnN0YW5jZXMgd2hlcmUgcG9zc2libGUuIEJlIGF3YXJlIHRoYXQgbm90IGFsbFxuXHQgKiBicm93c2VycyB3aWxsIHJlbmRlciBUZXh0IGV4YWN0bHkgdGhlIHNhbWUuXG5cdCAqIEBjbGFzcyBUZXh0XG5cdCAqIEBleHRlbmRzIERpc3BsYXlPYmplY3Rcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbdGV4dF0gVGhlIHRleHQgdG8gZGlzcGxheS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtmb250XSBUaGUgZm9udCBzdHlsZSB0byB1c2UuIEFueSB2YWxpZCB2YWx1ZSBmb3IgdGhlIENTUyBmb250IGF0dHJpYnV0ZSBpcyBhY2NlcHRhYmxlIChleC4gXCJib2xkXG5cdCAqIDM2cHggQXJpYWxcIikuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbY29sb3JdIFRoZSBjb2xvciB0byBkcmF3IHRoZSB0ZXh0IGluLiBBbnkgdmFsaWQgdmFsdWUgZm9yIHRoZSBDU1MgY29sb3IgYXR0cmlidXRlIGlzIGFjY2VwdGFibGUgKGV4LlxuXHQgKiBcIiNGMDBcIiwgXCJyZWRcIiwgb3IgXCIjRkYwMDAwXCIpLlxuXHQgKiovXG5cdGZ1bmN0aW9uIFRleHQodGV4dCwgZm9udCwgY29sb3IpIHtcblx0XHR0aGlzLkRpc3BsYXlPYmplY3RfY29uc3RydWN0b3IoKTtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIHRleHQgdG8gZGlzcGxheS5cblx0XHQgKiBAcHJvcGVydHkgdGV4dFxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqKi9cblx0XHR0aGlzLnRleHQgPSB0ZXh0O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgZm9udCBzdHlsZSB0byB1c2UuIEFueSB2YWxpZCB2YWx1ZSBmb3IgdGhlIENTUyBmb250IGF0dHJpYnV0ZSBpcyBhY2NlcHRhYmxlIChleC4gXCJib2xkIDM2cHggQXJpYWxcIikuXG5cdFx0ICogQHByb3BlcnR5IGZvbnRcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKiovXG5cdFx0dGhpcy5mb250ID0gZm9udDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGNvbG9yIHRvIGRyYXcgdGhlIHRleHQgaW4uIEFueSB2YWxpZCB2YWx1ZSBmb3IgdGhlIENTUyBjb2xvciBhdHRyaWJ1dGUgaXMgYWNjZXB0YWJsZSAoZXguIFwiI0YwMFwiKS4gRGVmYXVsdCBpcyBcIiMwMDBcIi5cblx0XHQgKiBJdCB3aWxsIGFsc28gYWNjZXB0IHZhbGlkIGNhbnZhcyBmaWxsU3R5bGUgdmFsdWVzLlxuXHRcdCAqIEBwcm9wZXJ0eSBjb2xvclxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqKi9cblx0XHR0aGlzLmNvbG9yID0gY29sb3I7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBob3Jpem9udGFsIHRleHQgYWxpZ25tZW50LiBBbnkgb2YgXCJzdGFydFwiLCBcImVuZFwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBhbmQgXCJjZW50ZXJcIi4gRm9yIGRldGFpbGVkXG5cdFx0ICogaW5mb3JtYXRpb24gdmlldyB0aGVcblx0XHQgKiA8YSBocmVmPVwiaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWwjdGV4dC1zdHlsZXNcIj5cblx0XHQgKiB3aGF0d2cgc3BlYzwvYT4uIERlZmF1bHQgaXMgXCJsZWZ0XCIuXG5cdFx0ICogQHByb3BlcnR5IHRleHRBbGlnblxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqKi9cblx0XHR0aGlzLnRleHRBbGlnbiA9IFwibGVmdFwiO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgdmVydGljYWwgYWxpZ25tZW50IHBvaW50IG9uIHRoZSBmb250LiBBbnkgb2YgXCJ0b3BcIiwgXCJoYW5naW5nXCIsIFwibWlkZGxlXCIsIFwiYWxwaGFiZXRpY1wiLCBcImlkZW9ncmFwaGljXCIsIG9yXG5cdFx0ICogXCJib3R0b21cIi4gRm9yIGRldGFpbGVkIGluZm9ybWF0aW9uIHZpZXcgdGhlIDxhIGhyZWY9XCJodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCN0ZXh0LXN0eWxlc1wiPlxuXHRcdCAqIHdoYXR3ZyBzcGVjPC9hPi4gRGVmYXVsdCBpcyBcInRvcFwiLlxuXHRcdCAqIEBwcm9wZXJ0eSB0ZXh0QmFzZWxpbmVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQqL1xuXHRcdHRoaXMudGV4dEJhc2VsaW5lID0gXCJ0b3BcIjtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIG1heGltdW0gd2lkdGggdG8gZHJhdyB0aGUgdGV4dC4gSWYgbWF4V2lkdGggaXMgc3BlY2lmaWVkIChub3QgbnVsbCksIHRoZSB0ZXh0IHdpbGwgYmUgY29uZGVuc2VkIG9yXG5cdFx0ICogc2hydW5rIHRvIG1ha2UgaXQgZml0IGluIHRoaXMgd2lkdGguIEZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiB2aWV3IHRoZVxuXHRcdCAqIDxhIGhyZWY9XCJodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtY2FudmFzLWVsZW1lbnQuaHRtbCN0ZXh0LXN0eWxlc1wiPlxuXHRcdCAqIHdoYXR3ZyBzcGVjPC9hPi5cblx0XHQgKiBAcHJvcGVydHkgbWF4V2lkdGhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQqL1xuXHRcdHRoaXMubWF4V2lkdGggPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBJZiBncmVhdGVyIHRoYW4gMCwgdGhlIHRleHQgd2lsbCBiZSBkcmF3biBhcyBhIHN0cm9rZSAob3V0bGluZSkgb2YgdGhlIHNwZWNpZmllZCB3aWR0aC5cblx0XHQgKiBAcHJvcGVydHkgb3V0bGluZVxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLm91dGxpbmUgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgdGhlIGxpbmUgaGVpZ2h0ICh2ZXJ0aWNhbCBkaXN0YW5jZSBiZXR3ZWVuIGJhc2VsaW5lcykgZm9yIG11bHRpLWxpbmUgdGV4dC4gSWYgbnVsbCBvciAwLFxuXHRcdCAqIHRoZSB2YWx1ZSBvZiBnZXRNZWFzdXJlZExpbmVIZWlnaHQgaXMgdXNlZC5cblx0XHQgKiBAcHJvcGVydHkgbGluZUhlaWdodFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmxpbmVIZWlnaHQgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgdGhlIG1heGltdW0gd2lkdGggZm9yIGEgbGluZSBvZiB0ZXh0IGJlZm9yZSBpdCBpcyB3cmFwcGVkIHRvIG11bHRpcGxlIGxpbmVzLiBJZiBudWxsLFxuXHRcdCAqIHRoZSB0ZXh0IHdpbGwgbm90IGJlIHdyYXBwZWQuXG5cdFx0ICogQHByb3BlcnR5IGxpbmVXaWR0aFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmxpbmVXaWR0aCA9IG51bGw7XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoVGV4dCwgY3JlYXRlanMuRGlzcGxheU9iamVjdCk7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblx0XG4vLyBzdGF0aWMgcHJvcGVydGllczpcblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfd29ya2luZ0NvbnRleHRcblx0ICogQHR5cGUgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXG5cdCAqIEBwcml2YXRlXG5cdCAqKi9cblx0dmFyIGNhbnZhcyA9IChjcmVhdGVqcy5jcmVhdGVDYW52YXM/Y3JlYXRlanMuY3JlYXRlQ2FudmFzKCk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSk7XG5cdGlmIChjYW52YXMuZ2V0Q29udGV4dCkgeyBUZXh0Ll93b3JraW5nQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7IGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAxOyB9XG5cdFxuXHRcbi8vIGNvbnN0YW50czpcblx0LyoqXG5cdCAqIExvb2t1cCB0YWJsZSBmb3IgdGhlIHJhdGlvIHRvIG9mZnNldCBib3VuZHMgeCBjYWxjdWxhdGlvbnMgYmFzZWQgb24gdGhlIHRleHRBbGlnbiBwcm9wZXJ0eS5cblx0ICogQHByb3BlcnR5IEhfT0ZGU0VUU1xuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VGV4dC5IX09GRlNFVFMgPSB7c3RhcnQ6IDAsIGxlZnQ6IDAsIGNlbnRlcjogLTAuNSwgZW5kOiAtMSwgcmlnaHQ6IC0xfTtcblx0XG5cdC8qKlxuXHQgKiBMb29rdXAgdGFibGUgZm9yIHRoZSByYXRpbyB0byBvZmZzZXQgYm91bmRzIHkgY2FsY3VsYXRpb25zIGJhc2VkIG9uIHRoZSB0ZXh0QmFzZWxpbmUgcHJvcGVydHkuXG5cdCAqIEBwcm9wZXJ0eSBIX09GRlNFVFNcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRleHQuVl9PRkZTRVRTID0ge3RvcDogMCwgaGFuZ2luZzogLTAuMDEsIG1pZGRsZTogLTAuNCwgYWxwaGFiZXRpYzogLTAuOCwgaWRlb2dyYXBoaWM6IC0wLjg1LCBib3R0b206IC0xfTtcblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXMuXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBpc1Zpc2libGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhc1xuXHQgKiovXG5cdHAuaXNWaXNpYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhhc0NvbnRlbnQgPSB0aGlzLmNhY2hlQ2FudmFzIHx8ICh0aGlzLnRleHQgIT0gbnVsbCAmJiB0aGlzLnRleHQgIT09IFwiXCIpO1xuXHRcdHJldHVybiAhISh0aGlzLnZpc2libGUgJiYgdGhpcy5hbHBoYSA+IDAgJiYgdGhpcy5zY2FsZVggIT0gMCAmJiB0aGlzLnNjYWxlWSAhPSAwICYmIGhhc0NvbnRlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyB0aGUgVGV4dCBpbnRvIHRoZSBzcGVjaWZpZWQgY29udGV4dCBpZ25vcmluZyBpdHMgdmlzaWJsZSwgYWxwaGEsIHNoYWRvdywgYW5kIHRyYW5zZm9ybS5cblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBkcmF3IHdhcyBoYW5kbGVkICh1c2VmdWwgZm9yIG92ZXJyaWRpbmcgZnVuY3Rpb25hbGl0eSkuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBkcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIGNhbnZhcyAyRCBjb250ZXh0IG9iamVjdCB0byBkcmF3IGludG8uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaWdub3JlQ2FjaGUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRyYXcgb3BlcmF0aW9uIHNob3VsZCBpZ25vcmUgYW55IGN1cnJlbnQgY2FjaGUuXG5cdCAqIEZvciBleGFtcGxlLCB1c2VkIGZvciBkcmF3aW5nIHRoZSBjYWNoZSAodG8gcHJldmVudCBpdCBmcm9tIHNpbXBseSBkcmF3aW5nIGFuIGV4aXN0aW5nIGNhY2hlIGJhY2tcblx0ICogaW50byBpdHNlbGYpLlxuXHQgKiovXG5cdHAuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgaWdub3JlQ2FjaGUpIHtcblx0XHRpZiAodGhpcy5EaXNwbGF5T2JqZWN0X2RyYXcoY3R4LCBpZ25vcmVDYWNoZSkpIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdHZhciBjb2wgPSB0aGlzLmNvbG9yIHx8IFwiIzAwMFwiO1xuXHRcdGlmICh0aGlzLm91dGxpbmUpIHsgY3R4LnN0cm9rZVN0eWxlID0gY29sOyBjdHgubGluZVdpZHRoID0gdGhpcy5vdXRsaW5lKjE7IH1cblx0XHRlbHNlIHsgY3R4LmZpbGxTdHlsZSA9IGNvbDsgfVxuXHRcdFxuXHRcdHRoaXMuX2RyYXdUZXh0KHRoaXMuX3ByZXBDb250ZXh0KGN0eCkpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtZWFzdXJlZCwgdW50cmFuc2Zvcm1lZCB3aWR0aCBvZiB0aGUgdGV4dCB3aXRob3V0IHdyYXBwaW5nLiBVc2UgZ2V0Qm91bmRzIGZvciBhIG1vcmUgcm9idXN0IHZhbHVlLlxuXHQgKiBAbWV0aG9kIGdldE1lYXN1cmVkV2lkdGhcblx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgbWVhc3VyZWQsIHVudHJhbnNmb3JtZWQgd2lkdGggb2YgdGhlIHRleHQuXG5cdCAqKi9cblx0cC5nZXRNZWFzdXJlZFdpZHRoID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldE1lYXN1cmVkV2lkdGgodGhpcy50ZXh0KTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBhcHByb3hpbWF0ZSBsaW5lIGhlaWdodCBvZiB0aGUgdGV4dCwgaWdub3JpbmcgdGhlIGxpbmVIZWlnaHQgcHJvcGVydHkuIFRoaXMgaXMgYmFzZWQgb24gdGhlIG1lYXN1cmVkXG5cdCAqIHdpZHRoIG9mIGEgXCJNXCIgY2hhcmFjdGVyIG11bHRpcGxpZWQgYnkgMS4yLCB3aGljaCBwcm92aWRlcyBhbiBhcHByb3hpbWF0ZSBsaW5lIGhlaWdodCBmb3IgbW9zdCBmb250cy5cblx0ICogQG1ldGhvZCBnZXRNZWFzdXJlZExpbmVIZWlnaHRcblx0ICogQHJldHVybiB7TnVtYmVyfSBhbiBhcHByb3hpbWF0ZSBsaW5lIGhlaWdodCBvZiB0aGUgdGV4dCwgaWdub3JpbmcgdGhlIGxpbmVIZWlnaHQgcHJvcGVydHkuIFRoaXMgaXNcblx0ICogYmFzZWQgb24gdGhlIG1lYXN1cmVkIHdpZHRoIG9mIGEgXCJNXCIgY2hhcmFjdGVyIG11bHRpcGxpZWQgYnkgMS4yLCB3aGljaCBhcHByb3hpbWF0ZXMgZW0gZm9yIG1vc3QgZm9udHMuXG5cdCAqKi9cblx0cC5nZXRNZWFzdXJlZExpbmVIZWlnaHQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0TWVhc3VyZWRXaWR0aChcIk1cIikqMS4yO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhcHByb3hpbWF0ZSBoZWlnaHQgb2YgbXVsdGktbGluZSB0ZXh0IGJ5IG11bHRpcGx5aW5nIHRoZSBudW1iZXIgb2YgbGluZXMgYWdhaW5zdCBlaXRoZXIgdGhlXG5cdCAqIDxjb2RlPmxpbmVIZWlnaHQ8L2NvZGU+IChpZiBzcGVjaWZpZWQpIG9yIHt7I2Nyb3NzTGluayBcIlRleHQvZ2V0TWVhc3VyZWRMaW5lSGVpZ2h0XCJ9fXt7L2Nyb3NzTGlua319LiBOb3RlIHRoYXRcblx0ICogdGhpcyBvcGVyYXRpb24gcmVxdWlyZXMgdGhlIHRleHQgZmxvd2luZyBsb2dpYyB0byBydW4sIHdoaWNoIGhhcyBhbiBhc3NvY2lhdGVkIENQVSBjb3N0LlxuXHQgKiBAbWV0aG9kIGdldE1lYXN1cmVkSGVpZ2h0XG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGFwcHJveGltYXRlIGhlaWdodCBvZiB0aGUgdW50cmFuc2Zvcm1lZCBtdWx0aS1saW5lIHRleHQuXG5cdCAqKi9cblx0cC5nZXRNZWFzdXJlZEhlaWdodCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kcmF3VGV4dChudWxsLHt9KS5oZWlnaHQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIERvY2NlZCBpbiBzdXBlcmNsYXNzLlxuXHQgKi9cblx0cC5nZXRCb3VuZHMgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IHRoaXMuRGlzcGxheU9iamVjdF9nZXRCb3VuZHMoKTtcblx0XHRpZiAocmVjdCkgeyByZXR1cm4gcmVjdDsgfVxuXHRcdGlmICh0aGlzLnRleHQgPT0gbnVsbCB8fCB0aGlzLnRleHQgPT09IFwiXCIpIHsgcmV0dXJuIG51bGw7IH1cblx0XHR2YXIgbyA9IHRoaXMuX2RyYXdUZXh0KG51bGwsIHt9KTtcblx0XHR2YXIgdyA9ICh0aGlzLm1heFdpZHRoICYmIHRoaXMubWF4V2lkdGggPCBvLndpZHRoKSA/IHRoaXMubWF4V2lkdGggOiBvLndpZHRoO1xuXHRcdHZhciB4ID0gdyAqIFRleHQuSF9PRkZTRVRTW3RoaXMudGV4dEFsaWdufHxcImxlZnRcIl07XG5cdFx0dmFyIGxpbmVIZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHR8fHRoaXMuZ2V0TWVhc3VyZWRMaW5lSGVpZ2h0KCk7XG5cdFx0dmFyIHkgPSBsaW5lSGVpZ2h0ICogVGV4dC5WX09GRlNFVFNbdGhpcy50ZXh0QmFzZWxpbmV8fFwidG9wXCJdO1xuXHRcdHJldHVybiB0aGlzLl9yZWN0YW5nbGUuc2V0VmFsdWVzKHgsIHksIHcsIG8uaGVpZ2h0KTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHdpZHRoLCBoZWlnaHQsIGFuZCBsaW5lcyBwcm9wZXJ0aWVzLiBUaGUgd2lkdGggYW5kIGhlaWdodCBhcmUgdGhlIHZpc3VhbCB3aWR0aCBhbmQgaGVpZ2h0XG5cdCAqIG9mIHRoZSBkcmF3biB0ZXh0LiBUaGUgbGluZXMgcHJvcGVydHkgY29udGFpbnMgYW4gYXJyYXkgb2Ygc3RyaW5ncywgb25lIGZvclxuXHQgKiBlYWNoIGxpbmUgb2YgdGV4dCB0aGF0IHdpbGwgYmUgZHJhd24sIGFjY291bnRpbmcgZm9yIGxpbmUgYnJlYWtzIGFuZCB3cmFwcGluZy4gVGhlc2Ugc3RyaW5ncyBoYXZlIHRyYWlsaW5nXG5cdCAqIHdoaXRlc3BhY2UgcmVtb3ZlZC5cblx0ICogQG1ldGhvZCBnZXRNZXRyaWNzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggd2lkdGgsIGhlaWdodCwgYW5kIGxpbmVzIHByb3BlcnRpZXMuXG5cdCAqKi9cblx0cC5nZXRNZXRyaWNzID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG8gPSB7bGluZXM6W119O1xuXHRcdG8ubGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodCB8fCB0aGlzLmdldE1lYXN1cmVkTGluZUhlaWdodCgpO1xuXHRcdG8udk9mZnNldCA9IG8ubGluZUhlaWdodCAqIFRleHQuVl9PRkZTRVRTW3RoaXMudGV4dEJhc2VsaW5lfHxcInRvcFwiXTtcblx0XHRyZXR1cm4gdGhpcy5fZHJhd1RleHQobnVsbCwgbywgby5saW5lcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgVGV4dCBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtUZXh0fSBhIGNsb25lIG9mIHRoZSBUZXh0IGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmVQcm9wcyhuZXcgVGV4dCh0aGlzLnRleHQsIHRoaXMuZm9udCwgdGhpcy5jb2xvcikpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbVGV4dCAodGV4dD1cIisgICh0aGlzLnRleHQubGVuZ3RoID4gMjAgPyB0aGlzLnRleHQuc3Vic3RyKDAsIDE3KStcIi4uLlwiIDogdGhpcy50ZXh0KSArXCIpXVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX2Nsb25lUHJvcHNcblx0ICogQHBhcmFtIHtUZXh0fSBvXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7VGV4dH0gb1xuXHQgKiovXG5cdHAuX2Nsb25lUHJvcHMgPSBmdW5jdGlvbihvKSB7XG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X19jbG9uZVByb3BzKG8pO1xuXHRcdG8udGV4dEFsaWduID0gdGhpcy50ZXh0QWxpZ247XG5cdFx0by50ZXh0QmFzZWxpbmUgPSB0aGlzLnRleHRCYXNlbGluZTtcblx0XHRvLm1heFdpZHRoID0gdGhpcy5tYXhXaWR0aDtcblx0XHRvLm91dGxpbmUgPSB0aGlzLm91dGxpbmU7XG5cdFx0by5saW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0O1xuXHRcdG8ubGluZVdpZHRoID0gdGhpcy5saW5lV2lkdGg7XG5cdFx0cmV0dXJuIG87XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldFdvcmtpbmdDb250ZXh0XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICogQHJldHVybiB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fcHJlcENvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcblx0XHRjdHguZm9udCA9IHRoaXMuZm9udHx8XCIxMHB4IHNhbnMtc2VyaWZcIjtcblx0XHRjdHgudGV4dEFsaWduID0gdGhpcy50ZXh0QWxpZ258fFwibGVmdFwiO1xuXHRcdGN0eC50ZXh0QmFzZWxpbmUgPSB0aGlzLnRleHRCYXNlbGluZXx8XCJ0b3BcIjtcblx0XHRyZXR1cm4gY3R4O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyBtdWx0aWxpbmUgdGV4dC5cblx0ICogQG1ldGhvZCBfZHJhd1RleHRcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb1xuXHQgKiBAcGFyYW0ge0FycmF5fSBsaW5lc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9kcmF3VGV4dCA9IGZ1bmN0aW9uKGN0eCwgbywgbGluZXMpIHtcblx0XHR2YXIgcGFpbnQgPSAhIWN0eDtcblx0XHRpZiAoIXBhaW50KSB7XG5cdFx0XHRjdHggPSBUZXh0Ll93b3JraW5nQ29udGV4dDtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHR0aGlzLl9wcmVwQ29udGV4dChjdHgpO1xuXHRcdH1cblx0XHR2YXIgbGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodHx8dGhpcy5nZXRNZWFzdXJlZExpbmVIZWlnaHQoKTtcblx0XHRcblx0XHR2YXIgbWF4VyA9IDAsIGNvdW50ID0gMDtcblx0XHR2YXIgaGFyZExpbmVzID0gU3RyaW5nKHRoaXMudGV4dCkuc3BsaXQoLyg/OlxcclxcbnxcXHJ8XFxuKS8pO1xuXHRcdGZvciAodmFyIGk9MCwgbD1oYXJkTGluZXMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0dmFyIHN0ciA9IGhhcmRMaW5lc1tpXTtcblx0XHRcdHZhciB3ID0gbnVsbDtcblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMubGluZVdpZHRoICE9IG51bGwgJiYgKHcgPSBjdHgubWVhc3VyZVRleHQoc3RyKS53aWR0aCkgPiB0aGlzLmxpbmVXaWR0aCkge1xuXHRcdFx0XHQvLyB0ZXh0IHdyYXBwaW5nOlxuXHRcdFx0XHR2YXIgd29yZHMgPSBzdHIuc3BsaXQoLyhcXHMpLyk7XG5cdFx0XHRcdHN0ciA9IHdvcmRzWzBdO1xuXHRcdFx0XHR3ID0gY3R4Lm1lYXN1cmVUZXh0KHN0cikud2lkdGg7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKHZhciBqPTEsIGpsPXdvcmRzLmxlbmd0aDsgajxqbDsgais9Mikge1xuXHRcdFx0XHRcdC8vIExpbmUgbmVlZHMgdG8gd3JhcDpcblx0XHRcdFx0XHR2YXIgd29yZFcgPSBjdHgubWVhc3VyZVRleHQod29yZHNbal0gKyB3b3Jkc1tqKzFdKS53aWR0aDtcblx0XHRcdFx0XHRpZiAodyArIHdvcmRXID4gdGhpcy5saW5lV2lkdGgpIHtcblx0XHRcdFx0XHRcdGlmIChwYWludCkgeyB0aGlzLl9kcmF3VGV4dExpbmUoY3R4LCBzdHIsIGNvdW50KmxpbmVIZWlnaHQpOyB9XG5cdFx0XHRcdFx0XHRpZiAobGluZXMpIHsgbGluZXMucHVzaChzdHIpOyB9XG5cdFx0XHRcdFx0XHRpZiAodyA+IG1heFcpIHsgbWF4VyA9IHc7IH1cblx0XHRcdFx0XHRcdHN0ciA9IHdvcmRzW2orMV07XG5cdFx0XHRcdFx0XHR3ID0gY3R4Lm1lYXN1cmVUZXh0KHN0cikud2lkdGg7XG5cdFx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdHIgKz0gd29yZHNbal0gKyB3b3Jkc1tqKzFdO1xuXHRcdFx0XHRcdFx0dyArPSB3b3JkVztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHBhaW50KSB7IHRoaXMuX2RyYXdUZXh0TGluZShjdHgsIHN0ciwgY291bnQqbGluZUhlaWdodCk7IH1cblx0XHRcdGlmIChsaW5lcykgeyBsaW5lcy5wdXNoKHN0cik7IH1cblx0XHRcdGlmIChvICYmIHcgPT0gbnVsbCkgeyB3ID0gY3R4Lm1lYXN1cmVUZXh0KHN0cikud2lkdGg7IH1cblx0XHRcdGlmICh3ID4gbWF4VykgeyBtYXhXID0gdzsgfVxuXHRcdFx0Y291bnQrKztcblx0XHR9XG5cdFx0XG5cdFx0aWYgKG8pIHtcblx0XHRcdG8ud2lkdGggPSBtYXhXO1xuXHRcdFx0by5oZWlnaHQgPSBjb3VudCpsaW5lSGVpZ2h0O1xuXHRcdH1cblx0XHRpZiAoIXBhaW50KSB7IGN0eC5yZXN0b3JlKCk7IH1cblx0XHRyZXR1cm4gbztcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfZHJhd1RleHRMaW5lXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2RyYXdUZXh0TGluZSA9IGZ1bmN0aW9uKGN0eCwgdGV4dCwgeSkge1xuXHRcdC8vIENocm9tZSAxNyB3aWxsIGZhaWwgdG8gZHJhdyB0aGUgdGV4dCBpZiB0aGUgbGFzdCBwYXJhbSBpcyBpbmNsdWRlZCBidXQgbnVsbCwgc28gd2UgZmVlZCBpdCBhIGxhcmdlIHZhbHVlIGluc3RlYWQ6XG5cdFx0aWYgKHRoaXMub3V0bGluZSkgeyBjdHguc3Ryb2tlVGV4dCh0ZXh0LCAwLCB5LCB0aGlzLm1heFdpZHRofHwweEZGRkYpOyB9XG5cdFx0ZWxzZSB7IGN0eC5maWxsVGV4dCh0ZXh0LCAwLCB5LCB0aGlzLm1heFdpZHRofHwweEZGRkYpOyB9XG5cdH07XG5cdFxuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldE1lYXN1cmVkV2lkdGhcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHRcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dldE1lYXN1cmVkV2lkdGggPSBmdW5jdGlvbih0ZXh0KSB7XG5cdFx0dmFyIGN0eCA9IFRleHQuX3dvcmtpbmdDb250ZXh0O1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0dmFyIHcgPSB0aGlzLl9wcmVwQ29udGV4dChjdHgpLm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0cmV0dXJuIHc7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5UZXh0ID0gY3JlYXRlanMucHJvbW90ZShUZXh0LCBcIkRpc3BsYXlPYmplY3RcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQml0bWFwVGV4dC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogRGlzcGxheXMgdGV4dCB1c2luZyBiaXRtYXAgZ2x5cGhzIGRlZmluZWQgaW4gYSBzcHJpdGUgc2hlZXQuIE11bHRpLWxpbmUgdGV4dCBpcyBzdXBwb3J0ZWRcblx0ICogdXNpbmcgbmV3IGxpbmUgY2hhcmFjdGVycywgYnV0IGF1dG9tYXRpYyB3cmFwcGluZyBpcyBub3Qgc3VwcG9ydGVkLiBTZWUgdGhlIFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJCaXRtYXBUZXh0L3Nwcml0ZVNoZWV0OnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHByb3BlcnR5IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGRlZmluaW5nIGdseXBocy5cblx0ICogXG5cdCAqIDxzdHJvbmc+SW1wb3J0YW50Ojwvc3Ryb25nPiBCaXRtYXBUZXh0IGV4dGVuZHMgQ29udGFpbmVyLCBidXQgaXMgbm90IGRlc2lnbmVkIHRvIGJlIHVzZWQgYXMgb25lLlxuXHQgKiBBcyBzdWNoLCBtZXRob2RzIGxpa2UgYWRkQ2hpbGQgYW5kIHJlbW92ZUNoaWxkIGFyZSBkaXNhYmxlZC5cblx0ICogQGNsYXNzIEJpdG1hcFRleHRcblx0ICogQGV4dGVuZHMgRGlzcGxheU9iamVjdFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3RleHQ9XCJcIl0gVGhlIHRleHQgdG8gZGlzcGxheS5cblx0ICogQHBhcmFtIHtTcHJpdGVTaGVldH0gW3Nwcml0ZVNoZWV0PW51bGxdIFRoZSBzcHJpdGVzaGVldCB0aGF0IGRlZmluZXMgdGhlIGNoYXJhY3RlciBnbHlwaHMuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIEJpdG1hcFRleHQodGV4dCwgc3ByaXRlU2hlZXQpIHtcblx0XHR0aGlzLkNvbnRhaW5lcl9jb25zdHJ1Y3RvcigpO1xuXHRcdFxuXHRcdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgdGV4dCB0byBkaXNwbGF5LlxuXHRcdCAqIEBwcm9wZXJ0eSB0ZXh0XG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICogQGRlZmF1bHQgXCJcIlxuXHRcdCAqKi9cblx0XHR0aGlzLnRleHQgPSB0ZXh0fHxcIlwiO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEEgU3ByaXRlU2hlZXQgaW5zdGFuY2UgdGhhdCBkZWZpbmVzIHRoZSBnbHlwaHMgZm9yIHRoaXMgYml0bWFwIHRleHQuIEVhY2ggZ2x5cGgvY2hhcmFjdGVyXG5cdFx0ICogc2hvdWxkIGhhdmUgYSBzaW5nbGUgZnJhbWUgYW5pbWF0aW9uIGRlZmluZWQgaW4gdGhlIHNwcml0ZSBzaGVldCBuYW1lZCB0aGUgc2FtZSBhc1xuXHRcdCAqIGNvcnJlc3BvbmRpbmcgY2hhcmFjdGVyLiBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyBhbmltYXRpb24gZGVmaW5pdGlvbjpcblx0XHQgKlxuXHRcdCAqIFx0XHRcIkFcIjoge2ZyYW1lczogWzBdfVxuXHRcdCAqXG5cdFx0ICogd291bGQgaW5kaWNhdGUgdGhhdCB0aGUgZnJhbWUgYXQgaW5kZXggMCBvZiB0aGUgc3ByaXRlc2hlZXQgc2hvdWxkIGJlIGRyYXduIGZvciB0aGUgXCJBXCIgY2hhcmFjdGVyLiBUaGUgc2hvcnQgZm9ybVxuXHRcdCAqIGlzIGFsc28gYWNjZXB0YWJsZTpcblx0XHQgKiBcblx0XHQgKiBcdFx0XCJBXCI6IDBcblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCBpZiBhIGNoYXJhY3RlciBpbiB0aGUgdGV4dCBpcyBub3QgZm91bmQgaW4gdGhlIHNwcml0ZSBzaGVldCwgaXQgd2lsbCBhbHNvXG5cdFx0ICogdHJ5IHRvIHVzZSB0aGUgYWx0ZXJuYXRlIGNhc2UgKHVwcGVyIG9yIGxvd2VyKS5cblx0XHQgKlxuXHRcdCAqIFNlZSBTcHJpdGVTaGVldCBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBkZWZpbmluZyBzcHJpdGUgc2hlZXQgZGF0YS5cblx0XHQgKiBAcHJvcGVydHkgc3ByaXRlU2hlZXRcblx0XHQgKiBAdHlwZSBTcHJpdGVTaGVldFxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKiovXG5cdFx0dGhpcy5zcHJpdGVTaGVldCA9IHNwcml0ZVNoZWV0O1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgaGVpZ2h0IG9mIGVhY2ggbGluZSBvZiB0ZXh0LiBJZiAwLCB0aGVuIGl0IHdpbGwgdXNlIGEgbGluZSBoZWlnaHQgY2FsY3VsYXRlZFxuXHRcdCAqIGJ5IGNoZWNraW5nIGZvciB0aGUgaGVpZ2h0IG9mIHRoZSBcIjFcIiwgXCJUXCIsIG9yIFwiTFwiIGNoYXJhY3RlciAoaW4gdGhhdCBvcmRlcikuIElmXG5cdFx0ICogdGhvc2UgY2hhcmFjdGVycyBhcmUgbm90IGRlZmluZWQsIGl0IHdpbGwgdXNlIHRoZSBoZWlnaHQgb2YgdGhlIGZpcnN0IGZyYW1lIG9mIHRoZVxuXHRcdCAqIHNwcml0ZSBzaGVldC5cblx0XHQgKiBAcHJvcGVydHkgbGluZUhlaWdodFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5saW5lSGVpZ2h0ID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhpcyBzcGFjaW5nIChpbiBwaXhlbHMpIHdpbGwgYmUgYWRkZWQgYWZ0ZXIgZWFjaCBjaGFyYWN0ZXIgaW4gdGhlIG91dHB1dC5cblx0XHQgKiBAcHJvcGVydHkgbGV0dGVyU3BhY2luZ1xuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5sZXR0ZXJTcGFjaW5nID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgYSBzcGFjZSBjaGFyYWN0ZXIgaXMgbm90IGRlZmluZWQgaW4gdGhlIHNwcml0ZSBzaGVldCwgdGhlbiBlbXB0eSBwaXhlbHMgZXF1YWwgdG9cblx0XHQgKiBzcGFjZVdpZHRoIHdpbGwgYmUgaW5zZXJ0ZWQgaW5zdGVhZC4gSWYgMCwgdGhlbiBpdCB3aWxsIHVzZSBhIHZhbHVlIGNhbGN1bGF0ZWRcblx0XHQgKiBieSBjaGVja2luZyBmb3IgdGhlIHdpZHRoIG9mIHRoZSBcIjFcIiwgXCJsXCIsIFwiRVwiLCBvciBcIkFcIiBjaGFyYWN0ZXIgKGluIHRoYXQgb3JkZXIpLiBJZlxuXHRcdCAqIHRob3NlIGNoYXJhY3RlcnMgYXJlIG5vdCBkZWZpbmVkLCBpdCB3aWxsIHVzZSB0aGUgd2lkdGggb2YgdGhlIGZpcnN0IGZyYW1lIG9mIHRoZVxuXHRcdCAqIHNwcml0ZSBzaGVldC5cblx0XHQgKiBAcHJvcGVydHkgc3BhY2VXaWR0aFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiovXG5cdFx0dGhpcy5zcGFjZVdpZHRoID0gMDtcblx0XHRcblx0XHRcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxuXHQgXHQvKipcblx0XHQgKiBAcHJvcGVydHkgX29sZFByb3BzXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqKi9cblx0XHR0aGlzLl9vbGRQcm9wcyA9IHt0ZXh0OjAsc3ByaXRlU2hlZXQ6MCxsaW5lSGVpZ2h0OjAsbGV0dGVyU3BhY2luZzowLHNwYWNlV2lkdGg6MH07XG5cdH1cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQml0bWFwVGV4dCwgY3JlYXRlanMuQ29udGFpbmVyKTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cbi8vIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQml0bWFwVGV4dCB1c2VzIFNwcml0ZSBpbnN0YW5jZXMgdG8gZHJhdyB0ZXh0LiBUbyByZWR1Y2UgdGhlIGNyZWF0aW9uIGFuZCBkZXN0cnVjdGlvbiBvZiBpbnN0YW5jZXMgKGFuZCB0aHVzIGdhcmJhZ2UgY29sbGVjdGlvbiksIGl0IG1haW50YWluc1xuXHQgKiBhbiBpbnRlcm5hbCBvYmplY3QgcG9vbCBvZiBzcHJpdGUgaW5zdGFuY2VzIHRvIHJldXNlLiBJbmNyZWFzaW5nIHRoaXMgdmFsdWUgY2FuIGNhdXNlIG1vcmUgc3ByaXRlcyB0byBiZVxuXHQgKiByZXRhaW5lZCwgc2xpZ2h0bHkgaW5jcmVhc2luZyBtZW1vcnkgdXNlLCBidXQgcmVkdWNpbmcgaW5zdGFudGlhdGlvbi5cblx0ICogQHByb3BlcnR5IG1heFBvb2xTaXplXG5cdCAqIEB0eXBlIE51bWJlclxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZWZhdWx0IDEwMFxuXHQgKiovXG5cdEJpdG1hcFRleHQubWF4UG9vbFNpemUgPSAxMDA7XG5cdFxuXHQvKipcblx0ICogU3ByaXRlIG9iamVjdCBwb29sLlxuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEBzdGF0aWNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdEJpdG1hcFRleHQuX3Nwcml0ZVBvb2wgPSBbXTtcblxuXHRcbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogRG9jY2VkIGluIHN1cGVyY2xhc3MuXG5cdCAqKi9cblx0cC5kcmF3ID0gZnVuY3Rpb24oY3R4LCBpZ25vcmVDYWNoZSkge1xuXHRcdGlmICh0aGlzLkRpc3BsYXlPYmplY3RfZHJhdyhjdHgsIGlnbm9yZUNhY2hlKSkgeyByZXR1cm47IH1cblx0XHR0aGlzLl91cGRhdGVUZXh0KCk7XG5cdFx0dGhpcy5Db250YWluZXJfZHJhdyhjdHgsIGlnbm9yZUNhY2hlKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBEb2NjZWQgaW4gc3VwZXJjbGFzcy5cblx0ICoqL1xuXHRwLmdldEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3VwZGF0ZVRleHQoKTtcblx0XHRyZXR1cm4gdGhpcy5Db250YWluZXJfZ2V0Qm91bmRzKCk7XG5cdH07XG5cdFxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIG9yIGZhbHNlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhcy5cblx0ICogVGhpcyBkb2VzIG5vdCBhY2NvdW50IGZvciB3aGV0aGVyIGl0IHdvdWxkIGJlIHZpc2libGUgd2l0aGluIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBzdGFnZS5cblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGlzVmlzaWJsZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGlzcGxheSBvYmplY3Qgd291bGQgYmUgdmlzaWJsZSBpZiBkcmF3biB0byBhIGNhbnZhc1xuXHQgKiovXG5cdHAuaXNWaXNpYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhhc0NvbnRlbnQgPSB0aGlzLmNhY2hlQ2FudmFzIHx8ICh0aGlzLnNwcml0ZVNoZWV0ICYmIHRoaXMuc3ByaXRlU2hlZXQuY29tcGxldGUgJiYgdGhpcy50ZXh0KTtcblx0XHRyZXR1cm4gISEodGhpcy52aXNpYmxlICYmIHRoaXMuYWxwaGEgPiAwICYmIHRoaXMuc2NhbGVYICE9PSAwICYmIHRoaXMuc2NhbGVZICE9PSAwICYmIGhhc0NvbnRlbnQpO1xuXHR9O1xuXHRcblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZVByb3BzKG5ldyBCaXRtYXBUZXh0KHRoaXMudGV4dCwgdGhpcy5zcHJpdGVTaGVldCkpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIDxzdHJvbmc+RGlzYWJsZWQgaW4gQml0bWFwVGV4dC48L3N0cm9uZz5cblx0ICogQG1ldGhvZCBhZGRDaGlsZFxuXHQgKiovXG5cdC8qKlxuXHQgKiA8c3Ryb25nPkRpc2FibGVkIGluIEJpdG1hcFRleHQuPC9zdHJvbmc+XG5cdCAqIEBtZXRob2QgYWRkQ2hpbGRBdFxuXHQgKiovXG5cdC8qKlxuXHQgKiA8c3Ryb25nPkRpc2FibGVkIGluIEJpdG1hcFRleHQuPC9zdHJvbmc+XG5cdCAqIEBtZXRob2QgcmVtb3ZlQ2hpbGRcblx0ICoqL1xuXHQvKipcblx0ICogPHN0cm9uZz5EaXNhYmxlZCBpbiBCaXRtYXBUZXh0Ljwvc3Ryb25nPlxuXHQgKiBAbWV0aG9kIHJlbW92ZUNoaWxkQXRcblx0ICoqL1xuXHQvKipcblx0ICogPHN0cm9uZz5EaXNhYmxlZCBpbiBCaXRtYXBUZXh0Ljwvc3Ryb25nPlxuXHQgKiBAbWV0aG9kIHJlbW92ZUFsbENoaWxkcmVuXG5cdCAqKi9cblx0cC5hZGRDaGlsZCA9IHAuYWRkQ2hpbGRBdCA9IHAucmVtb3ZlQ2hpbGQgPSBwLnJlbW92ZUNoaWxkQXQgPSBwLnJlbW92ZUFsbENoaWxkcmVuID0gZnVuY3Rpb24oKSB7fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG4gXHQvKipcblx0ICogQG1ldGhvZCBfY2xvbmVQcm9wc1xuXHQgKiBAcGFyYW0ge0JpdG1hcFRleHR9IG9cblx0ICogQHJldHVybiB7Qml0bWFwVGV4dH0gb1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fY2xvbmVQcm9wcyA9IGZ1bmN0aW9uKG8pIHtcblx0XHR0aGlzLkNvbnRhaW5lcl9fY2xvbmVQcm9wcyhvKTtcblx0XHRvLmxpbmVIZWlnaHQgPSB0aGlzLmxpbmVIZWlnaHQ7XG5cdFx0by5sZXR0ZXJTcGFjaW5nID0gdGhpcy5sZXR0ZXJTcGFjaW5nO1xuXHRcdG8uc3BhY2VXaWR0aCA9IHRoaXMuc3BhY2VXaWR0aDtcblx0XHRyZXR1cm4gbztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nZXRGcmFtZUluZGV4XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjaGFyYWN0ZXJcblx0ICogQHBhcmFtIHtTcHJpdGVTaGVldH0gc3ByaXRlU2hlZXRcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ2V0RnJhbWVJbmRleCA9IGZ1bmN0aW9uKGNoYXJhY3Rlciwgc3ByaXRlU2hlZXQpIHtcblx0XHR2YXIgYywgbyA9IHNwcml0ZVNoZWV0LmdldEFuaW1hdGlvbihjaGFyYWN0ZXIpO1xuXHRcdGlmICghbykge1xuXHRcdFx0KGNoYXJhY3RlciAhPSAoYyA9IGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpKSkgfHwgKGNoYXJhY3RlciAhPSAoYyA9IGNoYXJhY3Rlci50b0xvd2VyQ2FzZSgpKSkgfHwgKGM9bnVsbCk7XG5cdFx0XHRpZiAoYykgeyBvID0gc3ByaXRlU2hlZXQuZ2V0QW5pbWF0aW9uKGMpOyB9XG5cdFx0fVxuXHRcdHJldHVybiBvICYmIG8uZnJhbWVzWzBdO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldEZyYW1lXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjaGFyYWN0ZXJcblx0ICogQHBhcmFtIHtTcHJpdGVTaGVldH0gc3ByaXRlU2hlZXRcblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ2V0RnJhbWUgPSBmdW5jdGlvbihjaGFyYWN0ZXIsIHNwcml0ZVNoZWV0KSB7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5fZ2V0RnJhbWVJbmRleChjaGFyYWN0ZXIsIHNwcml0ZVNoZWV0KTtcblx0XHRyZXR1cm4gaW5kZXggPT0gbnVsbCA/IGluZGV4IDogc3ByaXRlU2hlZXQuZ2V0RnJhbWUoaW5kZXgpO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldExpbmVIZWlnaHRcblx0ICogQHBhcmFtIHtTcHJpdGVTaGVldH0gc3Ncblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZ2V0TGluZUhlaWdodCA9IGZ1bmN0aW9uKHNzKSB7XG5cdFx0dmFyIGZyYW1lID0gdGhpcy5fZ2V0RnJhbWUoXCIxXCIsc3MpIHx8IHRoaXMuX2dldEZyYW1lKFwiVFwiLHNzKSB8fCB0aGlzLl9nZXRGcmFtZShcIkxcIixzcykgfHwgc3MuZ2V0RnJhbWUoMCk7XG5cdFx0cmV0dXJuIGZyYW1lID8gZnJhbWUucmVjdC5oZWlnaHQgOiAxO1xuXHR9O1xuXHQvKipcblx0ICogQG1ldGhvZCBfZ2V0U3BhY2VXaWR0aFxuXHQgKiBAcGFyYW0ge1Nwcml0ZVNoZWV0fSBzc1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9nZXRTcGFjZVdpZHRoID0gZnVuY3Rpb24oc3MpIHtcblx0XHR2YXIgZnJhbWUgPSB0aGlzLl9nZXRGcmFtZShcIjFcIixzcykgfHwgdGhpcy5fZ2V0RnJhbWUoXCJsXCIsc3MpIHx8IHRoaXMuX2dldEZyYW1lKFwiZVwiLHNzKSB8fCB0aGlzLl9nZXRGcmFtZShcImFcIixzcykgfHwgc3MuZ2V0RnJhbWUoMCk7XG5cdFx0cmV0dXJuIGZyYW1lID8gZnJhbWUucmVjdC53aWR0aCA6IDE7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfZHJhd1RleHRcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3VwZGF0ZVRleHQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgeD0wLCB5PTAsIG89dGhpcy5fb2xkUHJvcHMsIGNoYW5nZT1mYWxzZSwgc3BhY2VXPXRoaXMuc3BhY2VXaWR0aCwgbGluZUg9dGhpcy5saW5lSGVpZ2h0LCBzcz10aGlzLnNwcml0ZVNoZWV0O1xuXHRcdHZhciBwb29sPUJpdG1hcFRleHQuX3Nwcml0ZVBvb2wsIGtpZHM9dGhpcy5jaGlsZHJlbiwgY2hpbGRJbmRleD0wLCBudW1LaWRzPWtpZHMubGVuZ3RoLCBzcHJpdGU7XG5cdFx0XG5cdFx0Zm9yICh2YXIgbiBpbiBvKSB7XG5cdFx0XHRpZiAob1tuXSAhPSB0aGlzW25dKSB7XG5cdFx0XHRcdG9bbl0gPSB0aGlzW25dO1xuXHRcdFx0XHRjaGFuZ2UgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIWNoYW5nZSkgeyByZXR1cm47IH1cblx0XHRcblx0XHR2YXIgaGFzU3BhY2UgPSAhIXRoaXMuX2dldEZyYW1lKFwiIFwiLCBzcyk7XG5cdFx0aWYgKCFoYXNTcGFjZSAmJiAhc3BhY2VXKSB7IHNwYWNlVyA9IHRoaXMuX2dldFNwYWNlV2lkdGgoc3MpOyB9XG5cdFx0aWYgKCFsaW5lSCkgeyBsaW5lSCA9IHRoaXMuX2dldExpbmVIZWlnaHQoc3MpOyB9XG5cdFx0XG5cdFx0Zm9yKHZhciBpPTAsIGw9dGhpcy50ZXh0Lmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdHZhciBjaGFyYWN0ZXIgPSB0aGlzLnRleHQuY2hhckF0KGkpO1xuXHRcdFx0aWYgKGNoYXJhY3RlciA9PSBcIiBcIiAmJiAhaGFzU3BhY2UpIHtcblx0XHRcdFx0eCArPSBzcGFjZVc7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fSBlbHNlIGlmIChjaGFyYWN0ZXI9PVwiXFxuXCIgfHwgY2hhcmFjdGVyPT1cIlxcclwiKSB7XG5cdFx0XHRcdGlmIChjaGFyYWN0ZXI9PVwiXFxyXCIgJiYgdGhpcy50ZXh0LmNoYXJBdChpKzEpID09IFwiXFxuXCIpIHsgaSsrOyB9IC8vIGNybGZcblx0XHRcdFx0eCA9IDA7XG5cdFx0XHRcdHkgKz0gbGluZUg7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaW5kZXggPSB0aGlzLl9nZXRGcmFtZUluZGV4KGNoYXJhY3Rlciwgc3MpO1xuXHRcdFx0aWYgKGluZGV4ID09IG51bGwpIHsgY29udGludWU7IH1cblx0XHRcdFxuXHRcdFx0aWYgKGNoaWxkSW5kZXggPCBudW1LaWRzKSB7XG5cdFx0XHRcdHNwcml0ZSA9IGtpZHNbY2hpbGRJbmRleF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRraWRzLnB1c2goc3ByaXRlID0gcG9vbC5sZW5ndGggPyBwb29sLnBvcCgpIDogbmV3IGNyZWF0ZWpzLlNwcml0ZSgpKTtcblx0XHRcdFx0c3ByaXRlLnBhcmVudCA9IHRoaXM7XG5cdFx0XHRcdG51bUtpZHMrKztcblx0XHRcdH1cblx0XHRcdHNwcml0ZS5zcHJpdGVTaGVldCA9IHNzO1xuXHRcdFx0c3ByaXRlLmdvdG9BbmRTdG9wKGluZGV4KTtcblx0XHRcdHNwcml0ZS54ID0geDtcblx0XHRcdHNwcml0ZS55ID0geTtcblx0XHRcdGNoaWxkSW5kZXgrKztcblx0XHRcdFxuXHRcdFx0eCArPSBzcHJpdGUuZ2V0Qm91bmRzKCkud2lkdGggKyB0aGlzLmxldHRlclNwYWNpbmc7XG5cdFx0fVxuXHRcdHdoaWxlIChudW1LaWRzID4gY2hpbGRJbmRleCkge1xuXHRcdFx0IC8vIGZhc3RlciB0aGFuIHJlbW92ZUNoaWxkLlxuXHRcdFx0cG9vbC5wdXNoKHNwcml0ZSA9IGtpZHMucG9wKCkpO1xuXHRcdFx0c3ByaXRlLnBhcmVudCA9IG51bGw7XG5cdFx0XHRudW1LaWRzLS07XG5cdFx0fVxuXHRcdGlmIChwb29sLmxlbmd0aCA+IEJpdG1hcFRleHQubWF4UG9vbFNpemUpIHsgcG9vbC5sZW5ndGggPSBCaXRtYXBUZXh0Lm1heFBvb2xTaXplOyB9XG5cdH07XG5cblxuXHRjcmVhdGVqcy5CaXRtYXBUZXh0ID0gY3JlYXRlanMucHJvbW90ZShCaXRtYXBUZXh0LCBcIkNvbnRhaW5lclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTcHJpdGVTaGVldFV0aWxzLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0XHJcblx0XHJcbi8vIGNvbnN0cnVjdG9yOlxyXG5cdC8qKlxyXG5cdCAqIFRoZSBTcHJpdGVTaGVldFV0aWxzIGNsYXNzIGlzIGEgY29sbGVjdGlvbiBvZiBzdGF0aWMgbWV0aG9kcyBmb3Igd29ya2luZyB3aXRoIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0XCJ9fXt7L2Nyb3NzTGlua319cy5cclxuXHQgKiBBIHNwcml0ZSBzaGVldCBpcyBhIHNlcmllcyBvZiBpbWFnZXMgKHVzdWFsbHkgYW5pbWF0aW9uIGZyYW1lcykgY29tYmluZWQgaW50byBhIHNpbmdsZSBpbWFnZSBvbiBhIHJlZ3VsYXIgZ3JpZC4gRm9yXHJcblx0ICogZXhhbXBsZSwgYW4gYW5pbWF0aW9uIGNvbnNpc3Rpbmcgb2YgOCAxMDB4MTAwIGltYWdlcyBjb3VsZCBiZSBjb21iaW5lZCBpbnRvIGEgNDAweDIwMCBzcHJpdGUgc2hlZXQgKDQgZnJhbWVzIGFjcm9zc1xyXG5cdCAqIGJ5IDIgaGlnaCkuIFRoZSBTcHJpdGVTaGVldFV0aWxzIGNsYXNzIHVzZXMgYSBzdGF0aWMgaW50ZXJmYWNlIGFuZCBzaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZC5cclxuXHQgKiBAY2xhc3MgU3ByaXRlU2hlZXRVdGlsc1xyXG5cdCAqIEBzdGF0aWNcclxuXHQgKiovXHJcblx0ZnVuY3Rpb24gU3ByaXRlU2hlZXRVdGlscygpIHtcclxuXHRcdHRocm93IFwiU3ByaXRlU2hlZXRVdGlscyBjYW5ub3QgYmUgaW5zdGFudGlhdGVkXCI7XHJcblx0fVxyXG5cclxuXHJcbi8vIHByaXZhdGUgc3RhdGljIHByb3BlcnRpZXM6XHJcblx0LyoqXHJcblx0ICogQHByb3BlcnR5IF93b3JraW5nQ2FudmFzXHJcblx0ICogQHN0YXRpY1xyXG5cdCAqIEB0eXBlIEhUTUxDYW52YXNFbGVtZW50IHwgT2JqZWN0XHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCovXHJcblx0LyoqXHJcblx0ICogQHByb3BlcnR5IF93b3JraW5nQ29udGV4dFxyXG5cdCAqIEBzdGF0aWNcclxuXHQgKiBAdHlwZSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0Ki9cclxuXHR2YXIgY2FudmFzID0gKGNyZWF0ZWpzLmNyZWF0ZUNhbnZhcz9jcmVhdGVqcy5jcmVhdGVDYW52YXMoKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpKTtcclxuXHRpZiAoY2FudmFzLmdldENvbnRleHQpIHtcclxuXHRcdFNwcml0ZVNoZWV0VXRpbHMuX3dvcmtpbmdDYW52YXMgPSBjYW52YXM7XHJcblx0XHRTcHJpdGVTaGVldFV0aWxzLl93b3JraW5nQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblx0XHRjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMTtcclxuXHR9XHJcblxyXG5cclxuLy8gcHVibGljIHN0YXRpYyBtZXRob2RzOlxyXG5cdC8qKlxyXG5cdCAqIDxiPlRoaXMgaXMgYW4gZXhwZXJpbWVudGFsIG1ldGhvZCwgYW5kIG1heSBiZSBidWdneS4gUGxlYXNlIHJlcG9ydCBpc3N1ZXMuPC9iPjxici8+PGJyLz5cclxuXHQgKiBFeHRlbmRzIHRoZSBleGlzdGluZyBzcHJpdGUgc2hlZXQgYnkgZmxpcHBpbmcgdGhlIG9yaWdpbmFsIGZyYW1lcyBob3Jpem9udGFsbHksIHZlcnRpY2FsbHksIG9yIGJvdGgsXHJcblx0ICogYW5kIGFkZGluZyBhcHByb3ByaWF0ZSBhbmltYXRpb24gJiBmcmFtZSBkYXRhLiBUaGUgZmxpcHBlZCBhbmltYXRpb25zIHdpbGwgaGF2ZSBhIHN1ZmZpeCBhZGRlZCB0byB0aGVpciBuYW1lc1xyXG5cdCAqIChfaCwgX3YsIF9odiBhcyBhcHByb3ByaWF0ZSkuIE1ha2Ugc3VyZSB0aGUgc3ByaXRlIHNoZWV0IGltYWdlcyBhcmUgZnVsbHkgbG9hZGVkIGJlZm9yZSB1c2luZyB0aGlzIG1ldGhvZC5cclxuXHQgKiA8YnIvPjxici8+XHJcblx0ICogRm9yIGV4YW1wbGU6PGJyLz5cclxuXHQgKiBTcHJpdGVTaGVldFV0aWxzLmFkZEZsaXBwZWRGcmFtZXMobXlTcHJpdGVTaGVldCwgdHJ1ZSwgdHJ1ZSk7XHJcblx0ICogVGhlIGFib3ZlIHdvdWxkIGFkZCBmcmFtZXMgdGhhdCBhcmUgZmxpcHBlZCBob3Jpem9udGFsbHkgQU5EIGZyYW1lcyB0aGF0IGFyZSBmbGlwcGVkIHZlcnRpY2FsbHkuXHJcblx0ICogPGJyLz48YnIvPlxyXG5cdCAqIE5vdGUgdGhhdCB5b3UgY2FuIGFsc28gZmxpcCBhbnkgZGlzcGxheSBvYmplY3QgYnkgc2V0dGluZyBpdHMgc2NhbGVYIG9yIHNjYWxlWSB0byBhIG5lZ2F0aXZlIHZhbHVlLiBPbiBzb21lXHJcblx0ICogYnJvd3NlcnMgKGVzcGVjaWFsbHkgdGhvc2Ugd2l0aG91dCBoYXJkd2FyZSBhY2NlbGVyYXRlZCBjYW52YXMpIHRoaXMgY2FuIHJlc3VsdCBpbiBzbGlnaHRseSBkZWdyYWRlZCBwZXJmb3JtYW5jZSxcclxuXHQgKiB3aGljaCBpcyB3aHkgYWRkRmxpcHBlZEZyYW1lcyBpcyBhdmFpbGFibGUuXHJcblx0ICogQG1ldGhvZCBhZGRGbGlwcGVkRnJhbWVzXHJcblx0ICogQHN0YXRpY1xyXG5cdCAqIEBwYXJhbSB7U3ByaXRlU2hlZXR9IHNwcml0ZVNoZWV0XHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBob3Jpem9udGFsIElmIHRydWUsIGhvcml6b250YWxseSBmbGlwcGVkIGZyYW1lcyB3aWxsIGJlIGFkZGVkLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmVydGljYWwgSWYgdHJ1ZSwgdmVydGljYWxseSBmbGlwcGVkIGZyYW1lcyB3aWxsIGJlIGFkZGVkLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYm90aCBJZiB0cnVlLCBmcmFtZXMgdGhhdCBhcmUgZmxpcHBlZCBib3RoIGhvcml6b250YWxseSBhbmQgdmVydGljYWxseSB3aWxsIGJlIGFkZGVkLlxyXG5cdCAqIEBkZXByZWNhdGVkIE1vZGVybiBicm93c2VycyBwZXJmb3JtIGJldHRlciB3aGVuIGZsaXBwaW5nIHZpYSBhIHRyYW5zZm9ybSAoZXguIHNjYWxlWD0tMSkgcmVuZGVyaW5nIHRoaXMgb2Jzb2xldGUuXHJcblx0ICoqL1xyXG5cdFNwcml0ZVNoZWV0VXRpbHMuYWRkRmxpcHBlZEZyYW1lcyA9IGZ1bmN0aW9uKHNwcml0ZVNoZWV0LCBob3Jpem9udGFsLCB2ZXJ0aWNhbCwgYm90aCkge1xyXG5cdFx0aWYgKCFob3Jpem9udGFsICYmICF2ZXJ0aWNhbCAmJiAhYm90aCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgY291bnQgPSAwO1xyXG5cdFx0aWYgKGhvcml6b250YWwpIHsgU3ByaXRlU2hlZXRVdGlscy5fZmxpcChzcHJpdGVTaGVldCwrK2NvdW50LHRydWUsZmFsc2UpOyB9XHJcblx0XHRpZiAodmVydGljYWwpIHsgU3ByaXRlU2hlZXRVdGlscy5fZmxpcChzcHJpdGVTaGVldCwrK2NvdW50LGZhbHNlLHRydWUpOyB9XHJcblx0XHRpZiAoYm90aCkgeyBTcHJpdGVTaGVldFV0aWxzLl9mbGlwKHNwcml0ZVNoZWV0LCsrY291bnQsdHJ1ZSx0cnVlKTsgfVxyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgYSBzaW5nbGUgZnJhbWUgb2YgdGhlIHNwZWNpZmllZCBzcHJpdGUgc2hlZXQgYXMgYSBuZXcgUE5HIGltYWdlLiBBbiBleGFtcGxlIG9mIHdoZW4gdGhpcyBtYXkgYmUgdXNlZnVsIGlzXHJcblx0ICogdG8gdXNlIGEgc3ByaXRlc2hlZXQgZnJhbWUgYXMgdGhlIHNvdXJjZSBmb3IgYSBiaXRtYXAgZmlsbC5cclxuXHQgKlxyXG5cdCAqIDxzdHJvbmc+V0FSTklORzo8L3N0cm9uZz4gSW4gYWxtb3N0IGFsbCBjYXNlcyBpdCBpcyBiZXR0ZXIgdG8gZGlzcGxheSBhIHNpbmdsZSBmcmFtZSB1c2luZyBhIHt7I2Nyb3NzTGluayBcIlNwcml0ZVwifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIHdpdGggYSB7eyNjcm9zc0xpbmsgXCJTcHJpdGUvZ290b0FuZFN0b3BcIn19e3svY3Jvc3NMaW5rfX0gY2FsbCB0aGFuIGl0IGlzIHRvIHNsaWNlIG91dCBhIGZyYW1lIHVzaW5nIHRoaXNcclxuXHQgKiBtZXRob2QgYW5kIGRpc3BsYXkgaXQgd2l0aCBhIEJpdG1hcCBpbnN0YW5jZS4gWW91IGNhbiBhbHNvIGNyb3AgYW4gaW1hZ2UgdXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcIkJpdG1hcC9zb3VyY2VSZWN0XCJ9fXt7L2Nyb3NzTGlua319XHJcblx0ICogcHJvcGVydHkgb2Yge3sjY3Jvc3NMaW5rIFwiQml0bWFwXCJ9fXt7L2Nyb3NzTGlua319LlxyXG5cdCAqXHJcblx0ICogVGhlIGV4dHJhY3RGcmFtZSBtZXRob2QgbWF5IGNhdXNlIGNyb3NzLWRvbWFpbiB3YXJuaW5ncyBzaW5jZSBpdCBhY2Nlc3NlcyBwaXhlbHMgZGlyZWN0bHkgb24gdGhlIGNhbnZhcy5cclxuXHQgKiBAbWV0aG9kIGV4dHJhY3RGcmFtZVxyXG5cdCAqIEBzdGF0aWNcclxuXHQgKiBAcGFyYW0ge1Nwcml0ZVNoZWV0fSBzcHJpdGVTaGVldCBUaGUgU3ByaXRlU2hlZXQgaW5zdGFuY2UgdG8gZXh0cmFjdCBhIGZyYW1lIGZyb20uXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBmcmFtZU9yQW5pbWF0aW9uIFRoZSBmcmFtZSBudW1iZXIgb3IgYW5pbWF0aW9uIG5hbWUgdG8gZXh0cmFjdC4gSWYgYW4gYW5pbWF0aW9uXHJcblx0ICogbmFtZSBpcyBzcGVjaWZpZWQsIG9ubHkgdGhlIGZpcnN0IGZyYW1lIG9mIHRoZSBhbmltYXRpb24gd2lsbCBiZSBleHRyYWN0ZWQuXHJcblx0ICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gYSBzaW5nbGUgZnJhbWUgb2YgdGhlIHNwZWNpZmllZCBzcHJpdGUgc2hlZXQgYXMgYSBuZXcgUE5HIGltYWdlLlxyXG5cdCovXHJcblx0U3ByaXRlU2hlZXRVdGlscy5leHRyYWN0RnJhbWUgPSBmdW5jdGlvbihzcHJpdGVTaGVldCwgZnJhbWVPckFuaW1hdGlvbikge1xyXG5cdFx0aWYgKGlzTmFOKGZyYW1lT3JBbmltYXRpb24pKSB7XHJcblx0XHRcdGZyYW1lT3JBbmltYXRpb24gPSBzcHJpdGVTaGVldC5nZXRBbmltYXRpb24oZnJhbWVPckFuaW1hdGlvbikuZnJhbWVzWzBdO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGRhdGEgPSBzcHJpdGVTaGVldC5nZXRGcmFtZShmcmFtZU9yQW5pbWF0aW9uKTtcclxuXHRcdGlmICghZGF0YSkgeyByZXR1cm4gbnVsbDsgfVxyXG5cdFx0dmFyIHIgPSBkYXRhLnJlY3Q7XHJcblx0XHR2YXIgY2FudmFzID0gU3ByaXRlU2hlZXRVdGlscy5fd29ya2luZ0NhbnZhcztcclxuXHRcdGNhbnZhcy53aWR0aCA9IHIud2lkdGg7XHJcblx0XHRjYW52YXMuaGVpZ2h0ID0gci5oZWlnaHQ7XHJcblx0XHRTcHJpdGVTaGVldFV0aWxzLl93b3JraW5nQ29udGV4dC5kcmF3SW1hZ2UoZGF0YS5pbWFnZSwgci54LCByLnksIHIud2lkdGgsIHIuaGVpZ2h0LCAwLCAwLCByLndpZHRoLCByLmhlaWdodCk7XHJcblx0XHR2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcclxuXHRcdGltZy5zcmMgPSBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xyXG5cdFx0cmV0dXJuIGltZztcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBNZXJnZXMgdGhlIHJnYiBjaGFubmVscyBvZiBvbmUgaW1hZ2Ugd2l0aCB0aGUgYWxwaGEgY2hhbm5lbCBvZiBhbm90aGVyLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGNvbWJpbmUgYSBjb21wcmVzc2VkXHJcblx0ICogSlBFRyBpbWFnZSBjb250YWluaW5nIGNvbG9yIGRhdGEgd2l0aCBhIFBORzMyIG1vbm9jaHJvbWF0aWMgaW1hZ2UgY29udGFpbmluZyBhbHBoYSBkYXRhLiBXaXRoIGNlcnRhaW4gdHlwZXMgb2ZcclxuXHQgKiBpbWFnZXMgKHRob3NlIHdpdGggZGV0YWlsIHRoYXQgbGVuZCBpdHNlbGYgdG8gSlBFRyBjb21wcmVzc2lvbikgdGhpcyBjYW4gcHJvdmlkZSBzaWduaWZpY2FudCBmaWxlIHNpemUgc2F2aW5nc1xyXG5cdCAqIHZlcnN1cyBhIHNpbmdsZSBSR0JBIFBORzMyLiBUaGlzIG1ldGhvZCBpcyB2ZXJ5IGZhc3QgKGdlbmVyYWxseSBvbiB0aGUgb3JkZXIgb2YgMS0yIG1zIHRvIHJ1bikuXHJcblx0ICogQG1ldGhvZCBtZXJnZUFscGhhXHJcblx0ICogQHN0YXRpY1xyXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gcmJnSW1hZ2UgVGhlIGltYWdlIChvciBjYW52YXMpIGNvbnRhaW5pbmcgdGhlIFJHQiBjaGFubmVscyB0byB1c2UuXHJcblx0ICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBhbHBoYUltYWdlIFRoZSBpbWFnZSAob3IgY2FudmFzKSBjb250YWluaW5nIHRoZSBhbHBoYSBjaGFubmVsIHRvIHVzZS5cclxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgT3B0aW9uYWwuIElmIHNwZWNpZmllZCwgdGhpcyBjYW52YXMgd2lsbCBiZSB1c2VkIGFuZCByZXR1cm5lZC4gSWYgbm90LCBhIG5ldyBjYW52YXMgd2lsbCBiZSBjcmVhdGVkLlxyXG5cdCAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBBIGNhbnZhcyB3aXRoIHRoZSBjb21iaW5lZCBpbWFnZSBkYXRhLiBUaGlzIGNhbiBiZSB1c2VkIGFzIGEgc291cmNlIGZvciBCaXRtYXAgb3IgU3ByaXRlU2hlZXQuXHJcblx0ICogQGRlcHJlY2F0ZWQgVG9vbHMgc3VjaCBhcyBJbWFnZUFscGhhIGdlbmVyYWxseSBwcm92aWRlIGJldHRlciByZXN1bHRzLiBUaGlzIHdpbGwgYmUgbW92ZWQgdG8gc2FuZGJveCBpbiB0aGUgZnV0dXJlLlxyXG5cdCovXHJcblx0U3ByaXRlU2hlZXRVdGlscy5tZXJnZUFscGhhID0gZnVuY3Rpb24ocmdiSW1hZ2UsIGFscGhhSW1hZ2UsIGNhbnZhcykge1xyXG5cdFx0aWYgKCFjYW52YXMpIHsgY2FudmFzID0gY3JlYXRlanMuY3JlYXRlQ2FudmFzP2NyZWF0ZWpzLmNyZWF0ZUNhbnZhcygpOmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7IH1cclxuXHRcdGNhbnZhcy53aWR0aCA9IE1hdGgubWF4KGFscGhhSW1hZ2Uud2lkdGgsIHJnYkltYWdlLndpZHRoKTtcclxuXHRcdGNhbnZhcy5oZWlnaHQgPSBNYXRoLm1heChhbHBoYUltYWdlLmhlaWdodCwgcmdiSW1hZ2UuaGVpZ2h0KTtcclxuXHRcdHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cdFx0Y3R4LnNhdmUoKTtcclxuXHRcdGN0eC5kcmF3SW1hZ2UocmdiSW1hZ2UsMCwwKTtcclxuXHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLWluXCI7XHJcblx0XHRjdHguZHJhd0ltYWdlKGFscGhhSW1hZ2UsMCwwKTtcclxuXHRcdGN0eC5yZXN0b3JlKCk7XHJcblx0XHRyZXR1cm4gY2FudmFzO1xyXG5cdH07XHJcblxyXG5cclxuLy8gcHJpdmF0ZSBzdGF0aWMgbWV0aG9kczpcclxuXHRTcHJpdGVTaGVldFV0aWxzLl9mbGlwID0gZnVuY3Rpb24oc3ByaXRlU2hlZXQsIGNvdW50LCBoLCB2KSB7XHJcblx0XHR2YXIgaW1ncyA9IHNwcml0ZVNoZWV0Ll9pbWFnZXM7XHJcblx0XHR2YXIgY2FudmFzID0gU3ByaXRlU2hlZXRVdGlscy5fd29ya2luZ0NhbnZhcztcclxuXHRcdHZhciBjdHggPSBTcHJpdGVTaGVldFV0aWxzLl93b3JraW5nQ29udGV4dDtcclxuXHRcdHZhciBpbCA9IGltZ3MubGVuZ3RoL2NvdW50O1xyXG5cdFx0Zm9yICh2YXIgaT0wO2k8aWw7aSsrKSB7XHJcblx0XHRcdHZhciBzcmMgPSBpbWdzW2ldO1xyXG5cdFx0XHRzcmMuX190bXAgPSBpOyAvLyBhIGJpdCBoYWNreSwgYnV0IGZhc3RlciB0aGFuIGRvaW5nIGluZGV4T2YgYmVsb3cuXHJcblx0XHRcdGN0eC5zZXRUcmFuc2Zvcm0oMSwwLDAsMSwwLDApO1xyXG5cdFx0XHRjdHguY2xlYXJSZWN0KDAsMCxjYW52YXMud2lkdGgrMSxjYW52YXMuaGVpZ2h0KzEpO1xyXG5cdFx0XHRjYW52YXMud2lkdGggPSBzcmMud2lkdGg7XHJcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBzcmMuaGVpZ2h0O1xyXG5cdFx0XHRjdHguc2V0VHJhbnNmb3JtKGg/LTE6MSwgMCwgMCwgdj8tMToxLCBoP3NyYy53aWR0aDowLCB2P3NyYy5oZWlnaHQ6MCk7XHJcblx0XHRcdGN0eC5kcmF3SW1hZ2Uoc3JjLDAsMCk7XHJcblx0XHRcdHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xyXG5cdFx0XHRpbWcuc3JjID0gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcclxuXHRcdFx0Ly8gd29yayBhcm91bmQgYSBzdHJhbmdlIGJ1ZyBpbiBTYWZhcmk6XHJcblx0XHRcdGltZy53aWR0aCA9IHNyYy53aWR0aDtcclxuXHRcdFx0aW1nLmhlaWdodCA9IHNyYy5oZWlnaHQ7XHJcblx0XHRcdGltZ3MucHVzaChpbWcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmcmFtZXMgPSBzcHJpdGVTaGVldC5fZnJhbWVzO1xyXG5cdFx0dmFyIGZsID0gZnJhbWVzLmxlbmd0aC9jb3VudDtcclxuXHRcdGZvciAoaT0wO2k8Zmw7aSsrKSB7XHJcblx0XHRcdHNyYyA9IGZyYW1lc1tpXTtcclxuXHRcdFx0dmFyIHJlY3QgPSBzcmMucmVjdC5jbG9uZSgpO1xyXG5cdFx0XHRpbWcgPSBpbWdzW3NyYy5pbWFnZS5fX3RtcCtpbCpjb3VudF07XHJcblxyXG5cdFx0XHR2YXIgZnJhbWUgPSB7aW1hZ2U6aW1nLHJlY3Q6cmVjdCxyZWdYOnNyYy5yZWdYLHJlZ1k6c3JjLnJlZ1l9O1xyXG5cdFx0XHRpZiAoaCkge1xyXG5cdFx0XHRcdHJlY3QueCA9IGltZy53aWR0aC1yZWN0LngtcmVjdC53aWR0aDsgLy8gdXBkYXRlIHJlY3RcclxuXHRcdFx0XHRmcmFtZS5yZWdYID0gcmVjdC53aWR0aC1zcmMucmVnWDsgLy8gdXBkYXRlIHJlZ2lzdHJhdGlvbiBwb2ludFxyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh2KSB7XHJcblx0XHRcdFx0cmVjdC55ID0gaW1nLmhlaWdodC1yZWN0LnktcmVjdC5oZWlnaHQ7ICAvLyB1cGRhdGUgcmVjdFxyXG5cdFx0XHRcdGZyYW1lLnJlZ1kgPSByZWN0LmhlaWdodC1zcmMucmVnWTsgLy8gdXBkYXRlIHJlZ2lzdHJhdGlvbiBwb2ludFxyXG5cdFx0XHR9XHJcblx0XHRcdGZyYW1lcy5wdXNoKGZyYW1lKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc2Z4ID0gXCJfXCIrKGg/XCJoXCI6XCJcIikrKHY/XCJ2XCI6XCJcIik7XHJcblx0XHR2YXIgbmFtZXMgPSBzcHJpdGVTaGVldC5fYW5pbWF0aW9ucztcclxuXHRcdHZhciBkYXRhID0gc3ByaXRlU2hlZXQuX2RhdGE7XHJcblx0XHR2YXIgYWwgPSBuYW1lcy5sZW5ndGgvY291bnQ7XHJcblx0XHRmb3IgKGk9MDtpPGFsO2krKykge1xyXG5cdFx0XHR2YXIgbmFtZSA9IG5hbWVzW2ldO1xyXG5cdFx0XHRzcmMgPSBkYXRhW25hbWVdO1xyXG5cdFx0XHR2YXIgYW5pbSA9IHtuYW1lOm5hbWUrc2Z4LHNwZWVkOnNyYy5zcGVlZCxuZXh0OnNyYy5uZXh0LGZyYW1lczpbXX07XHJcblx0XHRcdGlmIChzcmMubmV4dCkgeyBhbmltLm5leHQgKz0gc2Z4OyB9XHJcblx0XHRcdGZyYW1lcyA9IHNyYy5mcmFtZXM7XHJcblx0XHRcdGZvciAodmFyIGo9MCxsPWZyYW1lcy5sZW5ndGg7ajxsO2orKykge1xyXG5cdFx0XHRcdGFuaW0uZnJhbWVzLnB1c2goZnJhbWVzW2pdK2ZsKmNvdW50KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRkYXRhW2FuaW0ubmFtZV0gPSBhbmltO1xyXG5cdFx0XHRuYW1lcy5wdXNoKGFuaW0ubmFtZSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblxyXG5cdGNyZWF0ZWpzLlNwcml0ZVNoZWV0VXRpbHMgPSBTcHJpdGVTaGVldFV0aWxzO1xyXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU3ByaXRlU2hlZXRCdWlsZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBUaGUgU3ByaXRlU2hlZXRCdWlsZGVyIGFsbG93cyB5b3UgdG8gZ2VuZXJhdGUgc3ByaXRlIHNoZWV0cyBhdCBydW4gdGltZSBmcm9tIGFueSBkaXNwbGF5IG9iamVjdC4gVGhpcyBjYW4gYWxsb3dcblx0ICogeW91IHRvIG1haW50YWluIHlvdXIgYXNzZXRzIGFzIHZlY3RvciBncmFwaGljcyAoZm9yIGxvdyBmaWxlIHNpemUpLCBhbmQgcmVuZGVyIHRoZW0gYXQgcnVuIHRpbWUgYXMgc3ByaXRlIHNoZWV0c1xuXHQgKiBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlxuXHQgKlxuXHQgKiBTcHJpdGUgc2hlZXRzIGNhbiBiZSBidWlsdCBlaXRoZXIgc3luY2hyb25vdXNseSwgb3IgYXN5bmNocm9ub3VzbHksIHNvIHRoYXQgbGFyZ2Ugc3ByaXRlIHNoZWV0cyBjYW4gYmUgZ2VuZXJhdGVkXG5cdCAqIHdpdGhvdXQgbG9ja2luZyB0aGUgVUkuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUgXCJpbWFnZXNcIiB1c2VkIGluIHRoZSBnZW5lcmF0ZWQgc3ByaXRlIHNoZWV0IGFyZSBhY3R1YWxseSBjYW52YXMgZWxlbWVudHMsIGFuZCB0aGF0IHRoZXkgd2lsbCBiZSBzaXplZFxuXHQgKiB0byB0aGUgbmVhcmVzdCBwb3dlciBvZiAyIHVwIHRvIHRoZSB2YWx1ZSBvZiA8Y29kZT5tYXhXaWR0aDwvY29kZT4gb3IgPGNvZGU+bWF4SGVpZ2h0PC9jb2RlPi5cblx0ICogQGNsYXNzIFNwcml0ZVNoZWV0QnVpbGRlclxuXHQgKiBAZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gU3ByaXRlU2hlZXRCdWlsZGVyKCkge1xuXHRcdHRoaXMuRXZlbnREaXNwYXRjaGVyX2NvbnN0cnVjdG9yKCk7XG5cdFx0XG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzOlxuXHRcdC8qKlxuXHRcdCAqIFRoZSBtYXhpbXVtIHdpZHRoIGZvciB0aGUgaW1hZ2VzIChub3QgaW5kaXZpZHVhbCBmcmFtZXMpIGluIHRoZSBnZW5lcmF0ZWQgc3ByaXRlIHNoZWV0LiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2Vcblx0XHQgKiBhIHBvd2VyIG9mIDIgZm9yIHRoaXMgdmFsdWUgKGV4LiAxMDI0LCAyMDQ4LCA0MDk2KS4gSWYgdGhlIGZyYW1lcyBjYW5ub3QgYWxsIGZpdCB3aXRoaW4gdGhlIG1heCBkaW1lbnNpb25zLCB0aGVuXG5cdFx0ICogYWRkaXRpb25hbCBpbWFnZXMgd2lsbCBiZSBjcmVhdGVkIGFzIG5lZWRlZC5cblx0XHQgKiBAcHJvcGVydHkgbWF4V2lkdGhcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAyMDQ4XG5cdFx0Ki9cblx0XHR0aGlzLm1heFdpZHRoID0gMjA0ODtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIG1heGltdW0gaGVpZ2h0IGZvciB0aGUgaW1hZ2VzIChub3QgaW5kaXZpZHVhbCBmcmFtZXMpIGluIHRoZSBnZW5lcmF0ZWQgc3ByaXRlIHNoZWV0LiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2Vcblx0XHQgKiBhIHBvd2VyIG9mIDIgZm9yIHRoaXMgdmFsdWUgKGV4LiAxMDI0LCAyMDQ4LCA0MDk2KS4gSWYgdGhlIGZyYW1lcyBjYW5ub3QgYWxsIGZpdCB3aXRoaW4gdGhlIG1heCBkaW1lbnNpb25zLCB0aGVuXG5cdFx0ICogYWRkaXRpb25hbCBpbWFnZXMgd2lsbCBiZSBjcmVhdGVkIGFzIG5lZWRlZC5cblx0XHQgKiBAcHJvcGVydHkgbWF4SGVpZ2h0XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMjA0OFxuXHRcdCAqKi9cblx0XHR0aGlzLm1heEhlaWdodCA9IDIwNDg7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBzcHJpdGUgc2hlZXQgdGhhdCB3YXMgZ2VuZXJhdGVkLiBUaGlzIHdpbGwgYmUgbnVsbCBiZWZvcmUgYSBidWlsZCBpcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuXHRcdCAqIEBwcm9wZXJ0eSBzcHJpdGVTaGVldFxuXHRcdCAqIEB0eXBlIFNwcml0ZVNoZWV0XG5cdFx0ICoqL1xuXHRcdHRoaXMuc3ByaXRlU2hlZXQgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgc2NhbGUgdG8gYXBwbHkgd2hlbiBkcmF3aW5nIGFsbCBmcmFtZXMgdG8gdGhlIHNwcml0ZSBzaGVldC4gVGhpcyBpcyBtdWx0aXBsaWVkIGFnYWluc3QgYW55IHNjYWxlIHNwZWNpZmllZFxuXHRcdCAqIGluIHRoZSBhZGRGcmFtZSBjYWxsLiBUaGlzIGNhbiBiZSB1c2VkLCBmb3IgZXhhbXBsZSwgdG8gZ2VuZXJhdGUgYSBzcHJpdGUgc2hlZXQgYXQgcnVuIHRpbWUgdGhhdCBpcyB0YWlsb3JlZCB0b1xuXHRcdCAqIHRoZSBhIHNwZWNpZmljIGRldmljZSByZXNvbHV0aW9uIChleC4gdGFibGV0IHZzIG1vYmlsZSkuXG5cdFx0ICogQHByb3BlcnR5IHNjYWxlXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqKi9cblx0XHR0aGlzLnNjYWxlID0gMTtcblx0XG5cdFx0LyoqXG5cdFx0KiBUaGUgcGFkZGluZyB0byB1c2UgYmV0d2VlbiBmcmFtZXMuIFRoaXMgaXMgaGVscGZ1bCB0byBwcmVzZXJ2ZSBhbnRpYWxpYXNpbmcgb24gZHJhd24gdmVjdG9yIGNvbnRlbnQuXG5cdFx0KiBAcHJvcGVydHkgcGFkZGluZ1xuXHRcdCogQHR5cGUgTnVtYmVyXG5cdFx0KiBAZGVmYXVsdCAxXG5cdFx0KiovXG5cdFx0dGhpcy5wYWRkaW5nID0gMTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQSBudW1iZXIgZnJvbSAwLjAxIHRvIDAuOTkgdGhhdCBpbmRpY2F0ZXMgd2hhdCBwZXJjZW50YWdlIG9mIHRpbWUgdGhlIGJ1aWxkZXIgY2FuIHVzZS4gVGhpcyBjYW4gYmVcblx0XHQgKiB0aG91Z2h0IG9mIGFzIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBwZXIgc2Vjb25kIHRoZSBidWlsZGVyIHdpbGwgdXNlLiBGb3IgZXhhbXBsZSwgd2l0aCBhIHRpbWVTbGljZSB2YWx1ZSBvZiAwLjMsXG5cdFx0ICogdGhlIGJ1aWxkZXIgd2lsbCBydW4gMjAgdGltZXMgcGVyIHNlY29uZCwgdXNpbmcgYXBwcm94aW1hdGVseSAxNW1zIHBlciBidWlsZCAoMzAlIG9mIGF2YWlsYWJsZSB0aW1lLCBvciAwLjNzIHBlciBzZWNvbmQpLlxuXHRcdCAqIERlZmF1bHRzIHRvIDAuMy5cblx0XHQgKiBAcHJvcGVydHkgdGltZVNsaWNlXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMC4zXG5cdFx0ICoqL1xuXHRcdHRoaXMudGltZVNsaWNlID0gMC4zO1xuXHRcblx0XHQvKipcblx0XHQgKiBBIHZhbHVlIGJldHdlZW4gMCBhbmQgMSB0aGF0IGluZGljYXRlcyB0aGUgcHJvZ3Jlc3Mgb2YgYSBidWlsZCwgb3IgLTEgaWYgYSBidWlsZCBoYXMgbm90XG5cdFx0ICogYmVlbiBpbml0aWF0ZWQuXG5cdFx0ICogQHByb3BlcnR5IHByb2dyZXNzXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgLTFcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5wcm9ncmVzcyA9IC0xO1xuXHRcblx0XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2ZyYW1lc1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBBcnJheVxuXHRcdCAqKi9cblx0XHR0aGlzLl9mcmFtZXMgPSBbXTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9hbmltYXRpb25zXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIEFycmF5XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2FuaW1hdGlvbnMgPSB7fTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9kYXRhXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIEFycmF5XG5cdFx0ICoqL1xuXHRcdHRoaXMuX2RhdGEgPSBudWxsO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX25leHRGcmFtZUluZGV4XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl9uZXh0RnJhbWVJbmRleCA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfaW5kZXhcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2luZGV4ID0gMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF90aW1lcklEXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLl90aW1lcklEID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9zY2FsZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5fc2NhbGUgPSAxO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFNwcml0ZVNoZWV0QnVpbGRlciwgY3JlYXRlanMuRXZlbnREaXNwYXRjaGVyKTtcblxuXHQvKipcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL2V4dGVuZFwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiVXRpbGl0eSBNZXRob2RzL3Byb21vdGVcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqIFRoZXJlIGlzIGFuIGluaGVyaXRhbmNlIHR1dG9yaWFsIGRpc3RyaWJ1dGVkIHdpdGggRWFzZWxKUyBpbiAvdHV0b3JpYWxzL0luaGVyaXRhbmNlLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKi9cblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuXG5cblxuLy8gY29uc3RhbnRzOlxuXHRTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX0RJTUVOU0lPTlMgPSBcImZyYW1lIGRpbWVuc2lvbnMgZXhjZWVkIG1heCBzcHJpdGVzaGVldCBkaW1lbnNpb25zXCI7XG5cdFNwcml0ZVNoZWV0QnVpbGRlci5FUlJfUlVOTklORyA9IFwiYSBidWlsZCBpcyBhbHJlYWR5IHJ1bm5pbmdcIjtcblxuLy8gZXZlbnRzOlxuXHQvKipcblx0ICogRGlzcGF0Y2hlZCB3aGVuIGEgYnVpbGQgY29tcGxldGVzLlxuXHQgKiBAZXZlbnQgY29tcGxldGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblx0LyoqXG5cdCAqIERpc3BhdGNoZWQgd2hlbiBhbiBhc3luY2hyb25vdXMgYnVpbGQgaGFzIHByb2dyZXNzLlxuXHQgKiBAZXZlbnQgcHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcHJvZ3Jlc3MgVGhlIGN1cnJlbnQgcHJvZ3Jlc3MgdmFsdWUgKDAtMSkuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEFkZHMgYSBmcmFtZSB0byB0aGUge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRcIn19e3svY3Jvc3NMaW5rfX0uIE5vdGUgdGhhdCB0aGUgZnJhbWUgd2lsbCBub3QgYmUgZHJhd24gdW50aWwgeW91XG5cdCAqIGNhbGwge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRCdWlsZGVyL2J1aWxkXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC4gVGhlIG9wdGlvbmFsIHNldHVwIHBhcmFtcyBhbGxvdyB5b3UgdG8gaGF2ZVxuXHQgKiBhIGZ1bmN0aW9uIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRyYXcgb2NjdXJzLiBGb3IgZXhhbXBsZSwgdGhpcyBhbGxvd3MgeW91IHRvIGFkZCBhIHNpbmdsZSBzb3VyY2UgbXVsdGlwbGVcblx0ICogdGltZXMsIGJ1dCBtYW5pcHVsYXRlIGl0IG9yIGl0cyBjaGlsZHJlbiB0byBjaGFuZ2UgaXQgdG8gZ2VuZXJhdGUgZGlmZmVyZW50IGZyYW1lcy5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoZSBzb3VyY2UncyB0cmFuc2Zvcm1hdGlvbnMgKHgsIHksIHNjYWxlLCByb3RhdGUsIGFscGhhKSB3aWxsIGJlIGlnbm9yZWQsIGV4Y2VwdCBmb3IgcmVnWC9ZLiBUbyBhcHBseVxuXHQgKiB0cmFuc2Zvcm1zIHRvIGEgc291cmNlIG9iamVjdCBhbmQgaGF2ZSB0aGVtIGNhcHR1cmVkIGluIHRoZSBzcHJpdGUgc2hlZXQsIHNpbXBseSBwbGFjZSBpdCBpbnRvIGEge3sjY3Jvc3NMaW5rIFwiQ29udGFpbmVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFuZCBwYXNzIGluIHRoZSBDb250YWluZXIgYXMgdGhlIHNvdXJjZS5cblx0ICogQG1ldGhvZCBhZGRGcmFtZVxuXHQgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIHt7I2Nyb3NzTGluayBcIkRpc3BsYXlPYmplY3RcIn19e3svY3Jvc3NMaW5rfX0gIHRvIGRyYXcgYXMgdGhlIGZyYW1lLlxuXHQgKiBAcGFyYW0ge1JlY3RhbmdsZX0gW3NvdXJjZVJlY3RdIEEge3sjY3Jvc3NMaW5rIFwiUmVjdGFuZ2xlXCJ9fXt7L2Nyb3NzTGlua319IGRlZmluaW5nIHRoZSBwb3J0aW9uIG9mIHRoZVxuXHQgKiBzb3VyY2UgdG8gZHJhdyB0byB0aGUgZnJhbWUuIElmIG5vdCBzcGVjaWZpZWQsIGl0IHdpbGwgbG9vayBmb3IgYSA8Y29kZT5nZXRCb3VuZHM8L2NvZGU+IG1ldGhvZCwgYm91bmRzIHByb3BlcnR5LFxuXHQgKiBvciA8Y29kZT5ub21pbmFsQm91bmRzPC9jb2RlPiBwcm9wZXJ0eSBvbiB0aGUgc291cmNlIHRvIHVzZS4gSWYgb25lIGlzIG5vdCBmb3VuZCwgdGhlIGZyYW1lIHdpbGwgYmUgc2tpcHBlZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZT0xXSBPcHRpb25hbC4gVGhlIHNjYWxlIHRvIGRyYXcgdGhpcyBmcmFtZSBhdC4gRGVmYXVsdCBpcyAxLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc2V0dXBGdW5jdGlvbl0gQSBmdW5jdGlvbiB0byBjYWxsIGltbWVkaWF0ZWx5IGJlZm9yZSBkcmF3aW5nIHRoaXMgZnJhbWUuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdHdvIHBhcmFtZXRlcnM6IHRoZSBzb3VyY2UsIGFuZCBzZXR1cERhdGEuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbc2V0dXBEYXRhXSBBcmJpdHJhcnkgc2V0dXAgZGF0YSB0byBwYXNzIHRvIHNldHVwRnVuY3Rpb24gYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBmcmFtZSB0aGF0IHdhcyBqdXN0IGFkZGVkLCBvciBudWxsIGlmIGEgc291cmNlUmVjdCBjb3VsZCBub3QgYmUgZGV0ZXJtaW5lZC5cblx0ICoqL1xuXHRwLmFkZEZyYW1lID0gZnVuY3Rpb24oc291cmNlLCBzb3VyY2VSZWN0LCBzY2FsZSwgc2V0dXBGdW5jdGlvbiwgc2V0dXBEYXRhKSB7XG5cdFx0aWYgKHRoaXMuX2RhdGEpIHsgdGhyb3cgU3ByaXRlU2hlZXRCdWlsZGVyLkVSUl9SVU5OSU5HOyB9XG5cdFx0dmFyIHJlY3QgPSBzb3VyY2VSZWN0fHxzb3VyY2UuYm91bmRzfHxzb3VyY2Uubm9taW5hbEJvdW5kcztcblx0XHRpZiAoIXJlY3QmJnNvdXJjZS5nZXRCb3VuZHMpIHsgcmVjdCA9IHNvdXJjZS5nZXRCb3VuZHMoKTsgfVxuXHRcdGlmICghcmVjdCkgeyByZXR1cm4gbnVsbDsgfVxuXHRcdHNjYWxlID0gc2NhbGV8fDE7XG5cdFx0cmV0dXJuIHRoaXMuX2ZyYW1lcy5wdXNoKHtzb3VyY2U6c291cmNlLCBzb3VyY2VSZWN0OnJlY3QsIHNjYWxlOnNjYWxlLCBmdW5jdDpzZXR1cEZ1bmN0aW9uLCBkYXRhOnNldHVwRGF0YSwgaW5kZXg6dGhpcy5fZnJhbWVzLmxlbmd0aCwgaGVpZ2h0OnJlY3QuaGVpZ2h0KnNjYWxlfSktMTtcblx0fTtcblxuXHQvKipcblx0ICogQWRkcyBhbiBhbmltYXRpb24gdGhhdCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBjcmVhdGVkIHNwcml0ZSBzaGVldC5cblx0ICogQG1ldGhvZCBhZGRBbmltYXRpb25cblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgZm9yIHRoZSBhbmltYXRpb24uXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGZyYW1lcyBBbiBhcnJheSBvZiBmcmFtZSBpbmRleGVzIHRoYXQgY29tcHJpc2UgdGhlIGFuaW1hdGlvbi4gRXguIFszLDYsNV0gd291bGQgZGVzY3JpYmUgYW4gYW5pbWF0aW9uXG5cdCAqIHRoYXQgcGxheWVkIGZyYW1lIGluZGV4ZXMgMywgNiwgYW5kIDUgaW4gdGhhdCBvcmRlci5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtuZXh0XSBTcGVjaWZpZXMgdGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBjb250aW51ZSB0byBhZnRlciB0aGlzIGFuaW1hdGlvbiBlbmRzLiBZb3UgY2FuXG5cdCAqIGFsc28gcGFzcyBmYWxzZSB0byBoYXZlIHRoZSBhbmltYXRpb24gc3RvcCB3aGVuIGl0IGVuZHMuIEJ5IGRlZmF1bHQgaXQgd2lsbCBsb29wIHRvIHRoZSBzdGFydCBvZiB0aGUgc2FtZSBhbmltYXRpb24uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZnJlcXVlbmN5XSBTcGVjaWZpZXMgYSBmcmFtZSBhZHZhbmNlIGZyZXF1ZW5jeSBmb3IgdGhpcyBhbmltYXRpb24uIEZvciBleGFtcGxlLCBhIHZhbHVlXG5cdCAqIG9mIDIgd291bGQgY2F1c2UgdGhlIGFuaW1hdGlvbiB0byBhZHZhbmNlIGV2ZXJ5IHNlY29uZCB0aWNrLlxuXHQgKiovXG5cdHAuYWRkQW5pbWF0aW9uID0gZnVuY3Rpb24obmFtZSwgZnJhbWVzLCBuZXh0LCBmcmVxdWVuY3kpIHtcblx0XHRpZiAodGhpcy5fZGF0YSkgeyB0aHJvdyBTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX1JVTk5JTkc7IH1cblx0XHR0aGlzLl9hbmltYXRpb25zW25hbWVdID0ge2ZyYW1lczpmcmFtZXMsIG5leHQ6bmV4dCwgZnJlcXVlbmN5OmZyZXF1ZW5jeX07XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoaXMgd2lsbCB0YWtlIGEgTW92aWVDbGlwIGluc3RhbmNlLCBhbmQgYWRkIGl0cyBmcmFtZXMgYW5kIGxhYmVscyB0byB0aGlzIGJ1aWxkZXIuIExhYmVscyB3aWxsIGJlIGFkZGVkIGFzIGFuIGFuaW1hdGlvblxuXHQgKiBydW5uaW5nIGZyb20gdGhlIGxhYmVsIGluZGV4IHRvIHRoZSBuZXh0IGxhYmVsLiBGb3IgZXhhbXBsZSwgaWYgdGhlcmUgaXMgYSBsYWJlbCBuYW1lZCBcImZvb1wiIGF0IGZyYW1lIDAgYW5kIGEgbGFiZWxcblx0ICogbmFtZWQgXCJiYXJcIiBhdCBmcmFtZSAxMCwgaW4gYSBNb3ZpZUNsaXAgd2l0aCAxNSBmcmFtZXMsIGl0IHdpbGwgYWRkIGFuIGFuaW1hdGlvbiBuYW1lZCBcImZvb1wiIHRoYXQgcnVucyBmcm9tIGZyYW1lXG5cdCAqIGluZGV4IDAgdG8gOSwgYW5kIGFuIGFuaW1hdGlvbiBuYW1lZCBcImJhclwiIHRoYXQgcnVucyBmcm9tIGZyYW1lIGluZGV4IDEwIHRvIDE0LlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIGl0ZXJhdGUgdGhyb3VnaCB0aGUgZnVsbCBNb3ZpZUNsaXAgd2l0aCBhY3Rpb25zRW5hYmxlZCBzZXQgdG8gZmFsc2UsIGVuZGluZyBvbiB0aGUgbGFzdCBmcmFtZS5cblx0ICogQG1ldGhvZCBhZGRNb3ZpZUNsaXBcblx0ICogQHBhcmFtIHtNb3ZpZUNsaXB9IHNvdXJjZSBUaGUgc291cmNlIE1vdmllQ2xpcCBpbnN0YW5jZSB0byBhZGQgdG8gdGhlIHNwcml0ZSBzaGVldC5cblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IFtzb3VyY2VSZWN0XSBBIHt7I2Nyb3NzTGluayBcIlJlY3RhbmdsZVwifX17ey9jcm9zc0xpbmt9fSBkZWZpbmluZyB0aGUgcG9ydGlvbiBvZiB0aGUgc291cmNlIHRvXG5cdCAqIGRyYXcgdG8gdGhlIGZyYW1lLiBJZiBub3Qgc3BlY2lmaWVkLCBpdCB3aWxsIGxvb2sgZm9yIGEgPGNvZGU+Z2V0Qm91bmRzPC9jb2RlPiBtZXRob2QsIDxjb2RlPmZyYW1lQm91bmRzPC9jb2RlPlxuXHQgKiBBcnJheSwgPGNvZGU+Ym91bmRzPC9jb2RlPiBwcm9wZXJ0eSwgb3IgPGNvZGU+bm9taW5hbEJvdW5kczwvY29kZT4gcHJvcGVydHkgb24gdGhlIHNvdXJjZSB0byB1c2UuIElmIG9uZSBpcyBub3Rcblx0ICogZm91bmQsIHRoZSBNb3ZpZUNsaXAgd2lsbCBiZSBza2lwcGVkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlPTFdIFRoZSBzY2FsZSB0byBkcmF3IHRoZSBtb3ZpZSBjbGlwIGF0LlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc2V0dXBGdW5jdGlvbl0gQSBmdW5jdGlvbiB0byBjYWxsIGltbWVkaWF0ZWx5IGJlZm9yZSBkcmF3aW5nIGVhY2ggZnJhbWUuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhyZWUgcGFyYW1ldGVyczogdGhlIHNvdXJjZSwgc2V0dXBEYXRhLCBhbmQgdGhlIGZyYW1lIGluZGV4LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3NldHVwRGF0YV0gQXJiaXRyYXJ5IHNldHVwIGRhdGEgdG8gcGFzcyB0byBzZXR1cEZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbbGFiZWxGdW5jdGlvbl0gVGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggbW92aWVjbGlwIGxhYmVsIHRoYXQgaXMgYWRkZWQgd2l0aCBmb3VyIHBhcmFtZXRlcnM6IHRoZSBsYWJlbCBuYW1lLCB0aGUgc291cmNlIG1vdmllY2xpcCBpbnN0YW5jZSwgdGhlIHN0YXJ0aW5nIGZyYW1lIGluZGV4IChpbiB0aGUgbW92aWVjbGlwIHRpbWVsaW5lKSBhbmQgdGhlIGVuZCBpbmRleC4gSXQgbXVzdCByZXR1cm4gYSBuZXcgbmFtZSBmb3IgdGhlIGxhYmVsL2FuaW1hdGlvbiwgb3IgZmFsc2UgdG8gZXhjbHVkZSB0aGUgbGFiZWwuXG5cdCAqKi9cblx0cC5hZGRNb3ZpZUNsaXAgPSBmdW5jdGlvbihzb3VyY2UsIHNvdXJjZVJlY3QsIHNjYWxlLCBzZXR1cEZ1bmN0aW9uLCBzZXR1cERhdGEsIGxhYmVsRnVuY3Rpb24pIHtcblx0XHRpZiAodGhpcy5fZGF0YSkgeyB0aHJvdyBTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX1JVTk5JTkc7IH1cblx0XHR2YXIgcmVjdHMgPSBzb3VyY2UuZnJhbWVCb3VuZHM7XG5cdFx0dmFyIHJlY3QgPSBzb3VyY2VSZWN0fHxzb3VyY2UuYm91bmRzfHxzb3VyY2Uubm9taW5hbEJvdW5kcztcblx0XHRpZiAoIXJlY3QmJnNvdXJjZS5nZXRCb3VuZHMpIHsgcmVjdCA9IHNvdXJjZS5nZXRCb3VuZHMoKTsgfVxuXHRcdGlmICghcmVjdCAmJiAhcmVjdHMpIHsgcmV0dXJuOyB9XG5cblx0XHR2YXIgaSwgbCwgYmFzZUZyYW1lSW5kZXggPSB0aGlzLl9mcmFtZXMubGVuZ3RoO1xuXHRcdHZhciBkdXJhdGlvbiA9IHNvdXJjZS50aW1lbGluZS5kdXJhdGlvbjtcblx0XHRmb3IgKGk9MDsgaTxkdXJhdGlvbjsgaSsrKSB7XG5cdFx0XHR2YXIgciA9IChyZWN0cyYmcmVjdHNbaV0pID8gcmVjdHNbaV0gOiByZWN0O1xuXHRcdFx0dGhpcy5hZGRGcmFtZShzb3VyY2UsIHIsIHNjYWxlLCB0aGlzLl9zZXR1cE1vdmllQ2xpcEZyYW1lLCB7aTppLCBmOnNldHVwRnVuY3Rpb24sIGQ6c2V0dXBEYXRhfSk7XG5cdFx0fVxuXHRcdHZhciBsYWJlbHMgPSBzb3VyY2UudGltZWxpbmUuX2xhYmVscztcblx0XHR2YXIgbGJscyA9IFtdO1xuXHRcdGZvciAodmFyIG4gaW4gbGFiZWxzKSB7XG5cdFx0XHRsYmxzLnB1c2goe2luZGV4OmxhYmVsc1tuXSwgbGFiZWw6bn0pO1xuXHRcdH1cblx0XHRpZiAobGJscy5sZW5ndGgpIHtcblx0XHRcdGxibHMuc29ydChmdW5jdGlvbihhLGIpeyByZXR1cm4gYS5pbmRleC1iLmluZGV4OyB9KTtcblx0XHRcdGZvciAoaT0wLGw9bGJscy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHRcdHZhciBsYWJlbCA9IGxibHNbaV0ubGFiZWw7XG5cdFx0XHRcdHZhciBzdGFydCA9IGJhc2VGcmFtZUluZGV4K2xibHNbaV0uaW5kZXg7XG5cdFx0XHRcdHZhciBlbmQgPSBiYXNlRnJhbWVJbmRleCsoKGkgPT0gbC0xKSA/IGR1cmF0aW9uIDogbGJsc1tpKzFdLmluZGV4KTtcblx0XHRcdFx0dmFyIGZyYW1lcyA9IFtdO1xuXHRcdFx0XHRmb3IgKHZhciBqPXN0YXJ0OyBqPGVuZDsgaisrKSB7IGZyYW1lcy5wdXNoKGopOyB9XG5cdFx0XHRcdGlmIChsYWJlbEZ1bmN0aW9uKSB7XG5cdFx0XHRcdFx0bGFiZWwgPSBsYWJlbEZ1bmN0aW9uKGxhYmVsLCBzb3VyY2UsIHN0YXJ0LCBlbmQpO1xuXHRcdFx0XHRcdGlmICghbGFiZWwpIHsgY29udGludWU7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmFkZEFuaW1hdGlvbihsYWJlbCwgZnJhbWVzLCB0cnVlKTsgLy8gZm9yIG5vdywgdGhpcyBsb29wcyBhbGwgYW5pbWF0aW9ucy5cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEJ1aWxkcyBhIFNwcml0ZVNoZWV0IGluc3RhbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGZyYW1lcy5cblx0ICogQG1ldGhvZCBidWlsZFxuXHQgKiBAcmV0dXJuIHtTcHJpdGVTaGVldH0gVGhlIGNyZWF0ZWQgU3ByaXRlU2hlZXQgaW5zdGFuY2UsIG9yIG51bGwgaWYgYSBidWlsZCBpcyBhbHJlYWR5IHJ1bm5pbmcgb3IgYW4gZXJyb3Igb2NjdXJyZWQuXG5cdCAqKi9cblx0cC5idWlsZCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9kYXRhKSB7IHRocm93IFNwcml0ZVNoZWV0QnVpbGRlci5FUlJfUlVOTklORzsgfVxuXHRcdHRoaXMuX3N0YXJ0QnVpbGQoKTtcblx0XHR3aGlsZSAodGhpcy5fZHJhd05leHQoKSkge31cblx0XHR0aGlzLl9lbmRCdWlsZCgpO1xuXHRcdHJldHVybiB0aGlzLnNwcml0ZVNoZWV0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBc3luY2hyb25vdXNseSBidWlsZHMgYSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBmcmFtZXMuIEl0IHdpbGxcblx0ICogcnVuIDIwIHRpbWVzIHBlciBzZWNvbmQsIHVzaW5nIGFuIGFtb3VudCBvZiB0aW1lIGRlZmluZWQgYnkgPGNvZGU+dGltZVNsaWNlPC9jb2RlPi4gV2hlbiBpdCBpcyBjb21wbGV0ZSBpdCB3aWxsXG5cdCAqIGNhbGwgdGhlIHNwZWNpZmllZCBjYWxsYmFjay5cblx0ICogQG1ldGhvZCBidWlsZEFzeW5jXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZVNsaWNlXSBTZXRzIHRoZSB0aW1lU2xpY2UgcHJvcGVydHkgb24gdGhpcyBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmJ1aWxkQXN5bmMgPSBmdW5jdGlvbih0aW1lU2xpY2UpIHtcblx0XHRpZiAodGhpcy5fZGF0YSkgeyB0aHJvdyBTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX1JVTk5JTkc7IH1cblx0XHR0aGlzLnRpbWVTbGljZSA9IHRpbWVTbGljZTtcblx0XHR0aGlzLl9zdGFydEJ1aWxkKCk7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0aGlzLl90aW1lcklEID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgX3RoaXMuX3J1bigpOyB9LCA1MC1NYXRoLm1heCgwLjAxLCBNYXRoLm1pbigwLjk5LCB0aGlzLnRpbWVTbGljZXx8MC4zKSkqNTApO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdG9wcyB0aGUgY3VycmVudCBhc3luY2hyb25vdXMgYnVpbGQuXG5cdCAqIEBtZXRob2Qgc3RvcEFzeW5jXG5cdCAqKi9cblx0cC5zdG9wQXN5bmMgPSBmdW5jdGlvbigpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fdGltZXJJRCk7XG5cdFx0dGhpcy5fZGF0YSA9IG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNwcml0ZVNoZWV0QnVpbGRlciBpbnN0YW5jZXMgY2Fubm90IGJlIGNsb25lZC5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyhcIlNwcml0ZVNoZWV0QnVpbGRlciBjYW5ub3QgYmUgY2xvbmVkLlwiKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW1Nwcml0ZVNoZWV0QnVpbGRlcl1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9zdGFydEJ1aWxkXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9zdGFydEJ1aWxkID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhZCA9IHRoaXMucGFkZGluZ3x8MDtcblx0XHR0aGlzLnByb2dyZXNzID0gMDtcblx0XHR0aGlzLnNwcml0ZVNoZWV0ID0gbnVsbDtcblx0XHR0aGlzLl9pbmRleCA9IDA7XG5cdFx0dGhpcy5fc2NhbGUgPSB0aGlzLnNjYWxlO1xuXHRcdHZhciBkYXRhRnJhbWVzID0gW107XG5cdFx0dGhpcy5fZGF0YSA9IHtcblx0XHRcdGltYWdlczogW10sXG5cdFx0XHRmcmFtZXM6IGRhdGFGcmFtZXMsXG5cdFx0XHRhbmltYXRpb25zOiB0aGlzLl9hbmltYXRpb25zIC8vIFRPRE86IHNob3VsZCB3ZSBcImNsb25lXCIgX2FuaW1hdGlvbnMgaW4gY2FzZSBzb21lb25lIGFkZHMgbW9yZSBhbmltYXRpb25zIGFmdGVyIGEgYnVpbGQ/XG5cdFx0fTtcblxuXHRcdHZhciBmcmFtZXMgPSB0aGlzLl9mcmFtZXMuc2xpY2UoKTtcblx0XHRmcmFtZXMuc29ydChmdW5jdGlvbihhLGIpIHsgcmV0dXJuIChhLmhlaWdodDw9Yi5oZWlnaHQpID8gLTEgOiAxOyB9KTtcblxuXHRcdGlmIChmcmFtZXNbZnJhbWVzLmxlbmd0aC0xXS5oZWlnaHQrcGFkKjIgPiB0aGlzLm1heEhlaWdodCkgeyB0aHJvdyBTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX0RJTUVOU0lPTlM7IH1cblx0XHR2YXIgeT0wLCB4PTA7XG5cdFx0dmFyIGltZyA9IDA7XG5cdFx0d2hpbGUgKGZyYW1lcy5sZW5ndGgpIHtcblx0XHRcdHZhciBvID0gdGhpcy5fZmlsbFJvdyhmcmFtZXMsIHksIGltZywgZGF0YUZyYW1lcywgcGFkKTtcblx0XHRcdGlmIChvLncgPiB4KSB7IHggPSBvLnc7IH1cblx0XHRcdHkgKz0gby5oO1xuXHRcdFx0aWYgKCFvLmggfHwgIWZyYW1lcy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGNhbnZhcyA9IGNyZWF0ZWpzLmNyZWF0ZUNhbnZhcz9jcmVhdGVqcy5jcmVhdGVDYW52YXMoKTpkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXHRcdFx0XHRjYW52YXMud2lkdGggPSB0aGlzLl9nZXRTaXplKHgsdGhpcy5tYXhXaWR0aCk7XG5cdFx0XHRcdGNhbnZhcy5oZWlnaHQgPSB0aGlzLl9nZXRTaXplKHksdGhpcy5tYXhIZWlnaHQpO1xuXHRcdFx0XHR0aGlzLl9kYXRhLmltYWdlc1tpbWddID0gY2FudmFzO1xuXHRcdFx0XHRpZiAoIW8uaCkge1xuXHRcdFx0XHRcdHg9eT0wO1xuXHRcdFx0XHRcdGltZysrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX3NldHVwTW92aWVDbGlwRnJhbWVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSB3aWR0aCAmIGhlaWdodCBvZiB0aGUgcm93LlxuXHQgKiovXG5cdHAuX3NldHVwTW92aWVDbGlwRnJhbWUgPSBmdW5jdGlvbihzb3VyY2UsIGRhdGEpIHtcblx0XHR2YXIgYWUgPSBzb3VyY2UuYWN0aW9uc0VuYWJsZWQ7XG5cdFx0c291cmNlLmFjdGlvbnNFbmFibGVkID0gZmFsc2U7XG5cdFx0c291cmNlLmdvdG9BbmRTdG9wKGRhdGEuaSk7XG5cdFx0c291cmNlLmFjdGlvbnNFbmFibGVkID0gYWU7XG5cdFx0ZGF0YS5mJiZkYXRhLmYoc291cmNlLCBkYXRhLmQsIGRhdGEuaSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldFNpemVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSB3aWR0aCAmIGhlaWdodCBvZiB0aGUgcm93LlxuXHQgKiovXG5cdHAuX2dldFNpemUgPSBmdW5jdGlvbihzaXplLG1heCkge1xuXHRcdHZhciBwb3cgPSA0O1xuXHRcdHdoaWxlIChNYXRoLnBvdygyLCsrcG93KSA8IHNpemUpe31cblx0XHRyZXR1cm4gTWF0aC5taW4obWF4LE1hdGgucG93KDIscG93KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2ZpbGxSb3dcblx0ICogQHBhcmFtIHtBcnJheX0gZnJhbWVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudH0gaW1nXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhRnJhbWVzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwYWRcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSB3aWR0aCAmIGhlaWdodCBvZiB0aGUgcm93LlxuXHQgKiovXG5cdHAuX2ZpbGxSb3cgPSBmdW5jdGlvbihmcmFtZXMsIHksIGltZywgZGF0YUZyYW1lcywgcGFkKSB7XG5cdFx0dmFyIHcgPSB0aGlzLm1heFdpZHRoO1xuXHRcdHZhciBtYXhIID0gdGhpcy5tYXhIZWlnaHQ7XG5cdFx0eSArPSBwYWQ7XG5cdFx0dmFyIGggPSBtYXhILXk7XG5cdFx0dmFyIHggPSBwYWQ7XG5cdFx0dmFyIGhlaWdodCA9IDA7XG5cdFx0Zm9yICh2YXIgaT1mcmFtZXMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuXHRcdFx0dmFyIGZyYW1lID0gZnJhbWVzW2ldO1xuXHRcdFx0dmFyIHNjID0gdGhpcy5fc2NhbGUqZnJhbWUuc2NhbGU7XG5cdFx0XHR2YXIgcmVjdCA9IGZyYW1lLnNvdXJjZVJlY3Q7XG5cdFx0XHR2YXIgc291cmNlID0gZnJhbWUuc291cmNlO1xuXHRcdFx0dmFyIHJ4ID0gTWF0aC5mbG9vcihzYypyZWN0LngtcGFkKTtcblx0XHRcdHZhciByeSA9IE1hdGguZmxvb3Ioc2MqcmVjdC55LXBhZCk7XG5cdFx0XHR2YXIgcmggPSBNYXRoLmNlaWwoc2MqcmVjdC5oZWlnaHQrcGFkKjIpO1xuXHRcdFx0dmFyIHJ3ID0gTWF0aC5jZWlsKHNjKnJlY3Qud2lkdGgrcGFkKjIpO1xuXHRcdFx0aWYgKHJ3ID4gdykgeyB0aHJvdyBTcHJpdGVTaGVldEJ1aWxkZXIuRVJSX0RJTUVOU0lPTlM7IH1cblx0XHRcdGlmIChyaCA+IGggfHwgeCtydyA+IHcpIHsgY29udGludWU7IH1cblx0XHRcdGZyYW1lLmltZyA9IGltZztcblx0XHRcdGZyYW1lLnJlY3QgPSBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKHgseSxydyxyaCk7XG5cdFx0XHRoZWlnaHQgPSBoZWlnaHQgfHwgcmg7XG5cdFx0XHRmcmFtZXMuc3BsaWNlKGksMSk7XG5cdFx0XHRkYXRhRnJhbWVzW2ZyYW1lLmluZGV4XSA9IFt4LHkscncscmgsaW1nLE1hdGgucm91bmQoLXJ4K3NjKnNvdXJjZS5yZWdYLXBhZCksTWF0aC5yb3VuZCgtcnkrc2Mqc291cmNlLnJlZ1ktcGFkKV07XG5cdFx0XHR4ICs9IHJ3O1xuXHRcdH1cblx0XHRyZXR1cm4ge3c6eCwgaDpoZWlnaHR9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9lbmRCdWlsZFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fZW5kQnVpbGQgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnNwcml0ZVNoZWV0ID0gbmV3IGNyZWF0ZWpzLlNwcml0ZVNoZWV0KHRoaXMuX2RhdGEpO1xuXHRcdHRoaXMuX2RhdGEgPSBudWxsO1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSAxO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImNvbXBsZXRlXCIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9ydW5cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3J1biA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0cyA9IE1hdGgubWF4KDAuMDEsIE1hdGgubWluKDAuOTksIHRoaXMudGltZVNsaWNlfHwwLjMpKSo1MDtcblx0XHR2YXIgdCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkrdHM7XG5cdFx0dmFyIGNvbXBsZXRlID0gZmFsc2U7XG5cdFx0d2hpbGUgKHQgPiAobmV3IERhdGUoKSkuZ2V0VGltZSgpKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2RyYXdOZXh0KCkpIHsgY29tcGxldGUgPSB0cnVlOyBicmVhazsgfVxuXHRcdH1cblx0XHRpZiAoY29tcGxldGUpIHtcblx0XHRcdHRoaXMuX2VuZEJ1aWxkKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0XHR0aGlzLl90aW1lcklEID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgX3RoaXMuX3J1bigpOyB9LCA1MC10cyk7XG5cdFx0fVxuXHRcdHZhciBwID0gdGhpcy5wcm9ncmVzcyA9IHRoaXMuX2luZGV4L3RoaXMuX2ZyYW1lcy5sZW5ndGg7XG5cdFx0aWYgKHRoaXMuaGFzRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIpKSB7XG5cdFx0XHR2YXIgZXZ0ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwicHJvZ3Jlc3NcIik7XG5cdFx0XHRldnQucHJvZ3Jlc3MgPSBwO1xuXHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9kcmF3TmV4dFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4gQm9vbGVhbiBSZXR1cm5zIGZhbHNlIGlmIHRoaXMgaXMgdGhlIGxhc3QgZHJhdy5cblx0ICoqL1xuXHRwLl9kcmF3TmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmcmFtZSA9IHRoaXMuX2ZyYW1lc1t0aGlzLl9pbmRleF07XG5cdFx0dmFyIHNjID0gZnJhbWUuc2NhbGUqdGhpcy5fc2NhbGU7XG5cdFx0dmFyIHJlY3QgPSBmcmFtZS5yZWN0O1xuXHRcdHZhciBzb3VyY2VSZWN0ID0gZnJhbWUuc291cmNlUmVjdDtcblx0XHR2YXIgY2FudmFzID0gdGhpcy5fZGF0YS5pbWFnZXNbZnJhbWUuaW1nXTtcblx0XHR2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblx0XHRmcmFtZS5mdW5jdCYmZnJhbWUuZnVuY3QoZnJhbWUuc291cmNlLCBmcmFtZS5kYXRhKTtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHgucmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuXHRcdGN0eC5jbGlwKCk7XG5cdFx0Y3R4LnRyYW5zbGF0ZShNYXRoLmNlaWwocmVjdC54LXNvdXJjZVJlY3QueCpzYyksIE1hdGguY2VpbChyZWN0Lnktc291cmNlUmVjdC55KnNjKSk7XG5cdFx0Y3R4LnNjYWxlKHNjLHNjKTtcblx0XHRmcmFtZS5zb3VyY2UuZHJhdyhjdHgpOyAvLyBkaXNwbGF5IG9iamVjdCB3aWxsIGRyYXcgaXRzZWxmLlxuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0cmV0dXJuICgrK3RoaXMuX2luZGV4KSA8IHRoaXMuX2ZyYW1lcy5sZW5ndGg7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5TcHJpdGVTaGVldEJ1aWxkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKFNwcml0ZVNoZWV0QnVpbGRlciwgXCJFdmVudERpc3BhdGNoZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRE9NRWxlbWVudC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogPGI+VGhpcyBjbGFzcyBpcyBzdGlsbCBleHBlcmltZW50YWwsIGFuZCBtb3JlIGFkdmFuY2VkIHVzZSBpcyBsaWtlbHkgdG8gYmUgYnVnZ3kuIFBsZWFzZSByZXBvcnQgYnVncy48L2I+XG5cdCAqXG5cdCAqIEEgRE9NRWxlbWVudCBhbGxvd3MgeW91IHRvIGFzc29jaWF0ZSBhIEhUTUxFbGVtZW50IHdpdGggdGhlIGRpc3BsYXkgbGlzdC4gSXQgd2lsbCBiZSB0cmFuc2Zvcm1lZFxuXHQgKiB3aXRoaW4gdGhlIERPTSBhcyB0aG91Z2ggaXQgaXMgY2hpbGQgb2YgdGhlIHt7I2Nyb3NzTGluayBcIkNvbnRhaW5lclwifX17ey9jcm9zc0xpbmt9fSBpdCBpcyBhZGRlZCB0by4gSG93ZXZlciwgaXQgaXNcblx0ICogbm90IHJlbmRlcmVkIHRvIGNhbnZhcywgYW5kIGFzIHN1Y2ggd2lsbCByZXRhaW4gd2hhdGV2ZXIgei1pbmRleCBpdCBoYXMgcmVsYXRpdmUgdG8gdGhlIGNhbnZhcyAoaWUuIGl0IHdpbGwgYmVcblx0ICogZHJhd24gaW4gZnJvbnQgb2Ygb3IgYmVoaW5kIHRoZSBjYW52YXMpLlxuXHQgKlxuXHQgKiBUaGUgcG9zaXRpb24gb2YgYSBET01FbGVtZW50IGlzIHJlbGF0aXZlIHRvIHRoZWlyIHBhcmVudCBub2RlIGluIHRoZSBET00uIEl0IGlzIHJlY29tbWVuZGVkIHRoYXRcblx0ICogdGhlIERPTSBPYmplY3QgYmUgYWRkZWQgdG8gYSBkaXYgdGhhdCBhbHNvIGNvbnRhaW5zIHRoZSBjYW52YXMgc28gdGhhdCB0aGV5IHNoYXJlIHRoZSBzYW1lIHBvc2l0aW9uXG5cdCAqIG9uIHRoZSBwYWdlLlxuXHQgKlxuXHQgKiBET01FbGVtZW50IGlzIHVzZWZ1bCBmb3IgcG9zaXRpb25pbmcgSFRNTCBlbGVtZW50cyBvdmVyIHRvcCBvZiBjYW52YXMgY29udGVudCwgYW5kIGZvciBlbGVtZW50c1xuXHQgKiB0aGF0IHlvdSB3YW50IHRvIGRpc3BsYXkgb3V0c2lkZSB0aGUgYm91bmRzIG9mIHRoZSBjYW52YXMuIEZvciBleGFtcGxlLCBhIHRvb2x0aXAgd2l0aCByaWNoIEhUTUxcblx0ICogY29udGVudC5cblx0ICpcblx0ICogPGg0Pk1vdXNlIEludGVyYWN0aW9uPC9oND5cblx0ICpcblx0ICogRE9NRWxlbWVudCBpbnN0YW5jZXMgYXJlIG5vdCBmdWxsIEVhc2VsSlMgZGlzcGxheSBvYmplY3RzLCBhbmQgZG8gbm90IHBhcnRpY2lwYXRlIGluIEVhc2VsSlMgbW91c2Vcblx0ICogZXZlbnRzIG9yIHN1cHBvcnQgbWV0aG9kcyBsaWtlIGhpdFRlc3QuIFRvIGdldCBtb3VzZSBldmVudHMgZnJvbSBhIERPTUVsZW1lbnQsIHlvdSBtdXN0IGluc3RlYWQgYWRkIGhhbmRsZXJzIHRvXG5cdCAqIHRoZSBodG1sRWxlbWVudCAobm90ZSwgdGhpcyBkb2VzIG5vdCBzdXBwb3J0IEV2ZW50RGlzcGF0Y2hlcilcblx0ICpcblx0ICogICAgICB2YXIgZG9tRWxlbWVudCA9IG5ldyBjcmVhdGVqcy5ET01FbGVtZW50KGh0bWxFbGVtZW50KTtcblx0ICogICAgICBkb21FbGVtZW50Lmh0bWxFbGVtZW50Lm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcblx0ICogICAgICAgICAgY29uc29sZS5sb2coXCJjbGlja2VkXCIpO1xuXHQgKiAgICAgIH1cblx0ICpcblx0ICogQGNsYXNzIERPTUVsZW1lbnRcblx0ICogQGV4dGVuZHMgRGlzcGxheU9iamVjdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaHRtbEVsZW1lbnQgQSByZWZlcmVuY2Ugb3IgaWQgZm9yIHRoZSBET00gZWxlbWVudCB0byBtYW5hZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBET01FbGVtZW50KGh0bWxFbGVtZW50KSB7XG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X2NvbnN0cnVjdG9yKCk7XG5cdFx0XG5cdFx0aWYgKHR5cGVvZihodG1sRWxlbWVudCk9PVwic3RyaW5nXCIpIHsgaHRtbEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChodG1sRWxlbWVudCk7IH1cblx0XHR0aGlzLm1vdXNlRW5hYmxlZCA9IGZhbHNlO1xuXHRcdFxuXHRcdHZhciBzdHlsZSA9IGh0bWxFbGVtZW50LnN0eWxlO1xuXHRcdHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdHN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IHN0eWxlLldlYmtpdFRyYW5zZm9ybU9yaWdpbiA9IHN0eWxlLm1zVHJhbnNmb3JtT3JpZ2luID0gc3R5bGUuTW96VHJhbnNmb3JtT3JpZ2luID0gc3R5bGUuT1RyYW5zZm9ybU9yaWdpbiA9IFwiMCUgMCVcIjtcblx0XHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIERPTSBvYmplY3QgdG8gbWFuYWdlLlxuXHRcdCAqIEBwcm9wZXJ0eSBodG1sRWxlbWVudFxuXHRcdCAqIEB0eXBlIEhUTUxFbGVtZW50XG5cdFx0ICovXG5cdFx0dGhpcy5odG1sRWxlbWVudCA9IGh0bWxFbGVtZW50O1xuXHRcblx0XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX29sZE10eFxuXHRcdCAqIEB0eXBlIE1hdHJpeDJEXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX29sZFByb3BzID0gbnVsbDtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChET01FbGVtZW50LCBjcmVhdGVqcy5EaXNwbGF5T2JqZWN0KTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXMuXG5cdCAqIFRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3Igd2hldGhlciBpdCB3b3VsZCBiZSB2aXNpYmxlIHdpdGhpbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgc3RhZ2UuXG5cdCAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG1haW5seSBmb3IgaW50ZXJuYWwgdXNlLCB0aG91Z2ggaXQgbWF5IGJlIHVzZWZ1bCBmb3IgYWR2YW5jZWQgdXNlcy5cblx0ICogQG1ldGhvZCBpc1Zpc2libGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRpc3BsYXkgb2JqZWN0IHdvdWxkIGJlIHZpc2libGUgaWYgZHJhd24gdG8gYSBjYW52YXNcblx0ICovXG5cdHAuaXNWaXNpYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuaHRtbEVsZW1lbnQgIT0gbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogRHJhd3MgdGhlIGRpc3BsYXkgb2JqZWN0IGludG8gdGhlIHNwZWNpZmllZCBjb250ZXh0IGlnbm9yaW5nIGl0cyB2aXNpYmxlLCBhbHBoYSwgc2hhZG93LCBhbmQgdHJhbnNmb3JtLlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRyYXcgd2FzIGhhbmRsZWQgKHVzZWZ1bCBmb3Igb3ZlcnJpZGluZyBmdW5jdGlvbmFsaXR5KS5cblx0ICogTk9URTogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UsIHRob3VnaCBpdCBtYXkgYmUgdXNlZnVsIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIGRyYXdcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgY2FudmFzIDJEIGNvbnRleHQgb2JqZWN0IHRvIGRyYXcgaW50by5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVDYWNoZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZHJhdyBvcGVyYXRpb24gc2hvdWxkIGlnbm9yZSBhbnkgY3VycmVudCBjYWNoZS5cblx0ICogRm9yIGV4YW1wbGUsIHVzZWQgZm9yIGRyYXdpbmcgdGhlIGNhY2hlICh0byBwcmV2ZW50IGl0IGZyb20gc2ltcGx5IGRyYXdpbmcgYW4gZXhpc3RpbmcgY2FjaGUgYmFja1xuXHQgKiBpbnRvIGl0c2VsZikuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRwLmRyYXcgPSBmdW5jdGlvbihjdHgsIGlnbm9yZUNhY2hlKSB7XG5cdFx0Ly8gdGhpcyByZWxpZXMgb24gdGhlIF90aWNrIG1ldGhvZCBiZWNhdXNlIGRyYXcgaXNuJ3QgY2FsbGVkIGlmIHRoZSBwYXJlbnQgaXMgbm90IHZpc2libGUuXG5cdFx0Ly8gdGhlIGFjdHVhbCB1cGRhdGUgaGFwcGVucyBpbiBfaGFuZGxlRHJhd0VuZFxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBOb3QgYXBwbGljYWJsZSB0byBET01FbGVtZW50LlxuXHQgKiBAbWV0aG9kIGNhY2hlXG5cdCAqL1xuXHRwLmNhY2hlID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKipcblx0ICogTm90IGFwcGxpY2FibGUgdG8gRE9NRWxlbWVudC5cblx0ICogQG1ldGhvZCB1bmNhY2hlXG5cdCAqL1xuXHRwLnVuY2FjaGUgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBOb3QgYXBwbGljYWJsZSB0byBET01FbGVtZW50LlxuXHQgKiBAbWV0aG9kIHVwZGF0ZUNhY2hlXG5cdCAqL1xuXHRwLnVwZGF0ZUNhY2hlID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKipcblx0ICogTm90IGFwcGxpY2FibGUgdG8gRE9NRWxlbWVudC5cblx0ICogQG1ldGhvZCBoaXRUZXN0XG5cdCAqL1xuXHRwLmhpdFRlc3QgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBOb3QgYXBwbGljYWJsZSB0byBET01FbGVtZW50LlxuXHQgKiBAbWV0aG9kIGxvY2FsVG9HbG9iYWxcblx0ICovXG5cdHAubG9jYWxUb0dsb2JhbCA9IGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIE5vdCBhcHBsaWNhYmxlIHRvIERPTUVsZW1lbnQuXG5cdCAqIEBtZXRob2QgZ2xvYmFsVG9Mb2NhbFxuXHQgKi9cblx0cC5nbG9iYWxUb0xvY2FsID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKipcblx0ICogTm90IGFwcGxpY2FibGUgdG8gRE9NRWxlbWVudC5cblx0ICogQG1ldGhvZCBsb2NhbFRvTG9jYWxcblx0ICovXG5cdHAubG9jYWxUb0xvY2FsID0gZnVuY3Rpb24oKSB7fTtcblxuXHQvKipcblx0ICogRE9NRWxlbWVudCBjYW5ub3QgYmUgY2xvbmVkLiBUaHJvd3MgYW4gZXJyb3IuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyhcIkRPTUVsZW1lbnQgY2Fubm90IGJlIGNsb25lZC5cIilcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbRE9NRWxlbWVudCAobmFtZT1cIisgIHRoaXMubmFtZSArXCIpXVwiO1xuXHR9O1xuXG5cdC8qKlxuICAgICAqIEludGVyYWN0aW9uIGV2ZW50cyBzaG91bGQgYmUgYWRkZWQgdG8gYGh0bWxFbGVtZW50YCwgYW5kIG5vdCB0aGUgRE9NRWxlbWVudCBpbnN0YW5jZSwgc2luY2UgRE9NRWxlbWVudCBpbnN0YW5jZXNcblx0ICogYXJlIG5vdCBmdWxsIEVhc2VsSlMgZGlzcGxheSBvYmplY3RzIGFuZCBkbyBub3QgcGFydGljaXBhdGUgaW4gRWFzZWxKUyBtb3VzZSBldmVudHMuXG5cdCAqIEBldmVudCBjbGlja1xuXHQgKi9cblxuICAgICAvKipcbiAgICAgKiBJbnRlcmFjdGlvbiBldmVudHMgc2hvdWxkIGJlIGFkZGVkIHRvIGBodG1sRWxlbWVudGAsIGFuZCBub3QgdGhlIERPTUVsZW1lbnQgaW5zdGFuY2UsIHNpbmNlIERPTUVsZW1lbnQgaW5zdGFuY2VzXG4gXHQgKiBhcmUgbm90IGZ1bGwgRWFzZWxKUyBkaXNwbGF5IG9iamVjdHMgYW5kIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBFYXNlbEpTIG1vdXNlIGV2ZW50cy5cblx0ICogQGV2ZW50IGRibENsaWNrXG5cdCAqL1xuXG4gICAgIC8qKlxuICAgICAgKiBJbnRlcmFjdGlvbiBldmVudHMgc2hvdWxkIGJlIGFkZGVkIHRvIGBodG1sRWxlbWVudGAsIGFuZCBub3QgdGhlIERPTUVsZW1lbnQgaW5zdGFuY2UsIHNpbmNlIERPTUVsZW1lbnQgaW5zdGFuY2VzXG4gXHQgICogYXJlIG5vdCBmdWxsIEVhc2VsSlMgZGlzcGxheSBvYmplY3RzIGFuZCBkbyBub3QgcGFydGljaXBhdGUgaW4gRWFzZWxKUyBtb3VzZSBldmVudHMuXG5cdCAgKiBAZXZlbnQgbW91c2Vkb3duXG5cdCAgKi9cblxuICAgICAvKipcbiAgICAgICogVGhlIEhUTUxFbGVtZW50IGNhbiBsaXN0ZW4gZm9yIHRoZSBtb3VzZW92ZXIgZXZlbnQsIG5vdCB0aGUgRE9NRWxlbWVudCBpbnN0YW5jZS5cbiAgICAgICogU2luY2UgRE9NRWxlbWVudCBpbnN0YW5jZXMgYXJlIG5vdCBmdWxsIEVhc2VsSlMgZGlzcGxheSBvYmplY3RzIGFuZCBkbyBub3QgcGFydGljaXBhdGUgaW4gRWFzZWxKUyBtb3VzZSBldmVudHMuXG4gICAgICAqIEBldmVudCBtb3VzZW92ZXJcblx0ICAqL1xuXG4gICAgIC8qKlxuICAgICAgKiBOb3QgYXBwbGljYWJsZSB0byBET01FbGVtZW50LlxuXHQgICogQGV2ZW50IHRpY2tcblx0ICAqL1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX3RpY2tcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2dE9iaiBBbiBldmVudCBvYmplY3QgdGhhdCB3aWxsIGJlIGRpc3BhdGNoZWQgdG8gYWxsIHRpY2sgbGlzdGVuZXJzLiBUaGlzIG9iamVjdCBpcyByZXVzZWQgYmV0d2VlbiBkaXNwYXRjaGVycyB0byByZWR1Y2UgY29uc3RydWN0aW9uICYgR0MgY29zdHMuXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl90aWNrID0gZnVuY3Rpb24oZXZ0T2JqKSB7XG5cdFx0dmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpO1xuXHRcdHN0YWdlJiZzdGFnZS5vbihcImRyYXdlbmRcIiwgdGhpcy5faGFuZGxlRHJhd0VuZCwgdGhpcywgdHJ1ZSk7XG5cdFx0dGhpcy5EaXNwbGF5T2JqZWN0X190aWNrKGV2dE9iaik7XG5cdH07XG5cdFxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlRHJhd0VuZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldnRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5faGFuZGxlRHJhd0VuZCA9IGZ1bmN0aW9uKGV2dCkge1xuXHRcdHZhciBvID0gdGhpcy5odG1sRWxlbWVudDtcblx0XHRpZiAoIW8pIHsgcmV0dXJuOyB9XG5cdFx0dmFyIHN0eWxlID0gby5zdHlsZTtcblx0XHRcblx0XHR2YXIgcHJvcHMgPSB0aGlzLmdldENvbmNhdGVuYXRlZERpc3BsYXlQcm9wcyh0aGlzLl9wcm9wcyksIG10eCA9IHByb3BzLm1hdHJpeDtcblx0XHRcblx0XHR2YXIgdmlzaWJpbGl0eSA9IHByb3BzLnZpc2libGUgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCI7XG5cdFx0aWYgKHZpc2liaWxpdHkgIT0gc3R5bGUudmlzaWJpbGl0eSkgeyBzdHlsZS52aXNpYmlsaXR5ID0gdmlzaWJpbGl0eTsgfVxuXHRcdGlmICghcHJvcHMudmlzaWJsZSkgeyByZXR1cm47IH1cblx0XHRcblx0XHR2YXIgb2xkUHJvcHMgPSB0aGlzLl9vbGRQcm9wcywgb2xkTXR4ID0gb2xkUHJvcHMmJm9sZFByb3BzLm1hdHJpeDtcblx0XHR2YXIgbiA9IDEwMDAwOyAvLyBwcmVjaXNpb25cblx0XHRcblx0XHRpZiAoIW9sZE10eCB8fCAhb2xkTXR4LmVxdWFscyhtdHgpKSB7XG5cdFx0XHR2YXIgc3RyID0gXCJtYXRyaXgoXCIgKyAobXR4LmEqbnwwKS9uICtcIixcIisgKG10eC5iKm58MCkvbiArXCIsXCIrIChtdHguYypufDApL24gK1wiLFwiKyAobXR4LmQqbnwwKS9uICtcIixcIisgKG10eC50eCswLjV8MCk7XG5cdFx0XHRzdHlsZS50cmFuc2Zvcm0gPSBzdHlsZS5XZWJraXRUcmFuc2Zvcm0gPSBzdHlsZS5PVHJhbnNmb3JtID0gc3R5bGUubXNUcmFuc2Zvcm0gPSBzdHIgK1wiLFwiKyAobXR4LnR5KzAuNXwwKSArXCIpXCI7XG5cdFx0XHRzdHlsZS5Nb3pUcmFuc2Zvcm0gPSBzdHIgK1wicHgsXCIrIChtdHgudHkrMC41fDApICtcInB4KVwiO1xuXHRcdFx0aWYgKCFvbGRQcm9wcykgeyBvbGRQcm9wcyA9IHRoaXMuX29sZFByb3BzID0gbmV3IGNyZWF0ZWpzLkRpc3BsYXlQcm9wcyh0cnVlLCBOYU4pOyB9XG5cdFx0XHRvbGRQcm9wcy5tYXRyaXguY29weShtdHgpO1xuXHRcdH1cblx0XHRcblx0XHRpZiAob2xkUHJvcHMuYWxwaGEgIT0gcHJvcHMuYWxwaGEpIHtcblx0XHRcdHN0eWxlLm9wYWNpdHkgPSBcIlwiKyhwcm9wcy5hbHBoYSpufDApL247XG5cdFx0XHRvbGRQcm9wcy5hbHBoYSA9IHByb3BzLmFscGhhO1xuXHRcdH1cblx0fTtcblxuXG5cdGNyZWF0ZWpzLkRPTUVsZW1lbnQgPSBjcmVhdGVqcy5wcm9tb3RlKERPTUVsZW1lbnQsIFwiRGlzcGxheU9iamVjdFwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBGaWx0ZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEJhc2UgY2xhc3MgdGhhdCBhbGwgZmlsdGVycyBzaG91bGQgaW5oZXJpdCBmcm9tLiBGaWx0ZXJzIG5lZWQgdG8gYmUgYXBwbGllZCB0byBvYmplY3RzIHRoYXQgaGF2ZSBiZWVuIGNhY2hlZCB1c2luZ1xuXHQgKiB0aGUge3sjY3Jvc3NMaW5rIFwiRGlzcGxheU9iamVjdC9jYWNoZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuIElmIGFuIG9iamVjdCBjaGFuZ2VzLCBwbGVhc2UgY2FjaGUgaXQgYWdhaW4sIG9yIHVzZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJEaXNwbGF5T2JqZWN0L3VwZGF0ZUNhY2hlXCJ9fXt7L2Nyb3NzTGlua319LiBOb3RlIHRoYXQgdGhlIGZpbHRlcnMgbXVzdCBiZSBhcHBsaWVkIGJlZm9yZSBjYWNoaW5nLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgbXlJbnN0YW5jZS5maWx0ZXJzID0gW1xuXHQgKiAgICAgICAgICBuZXcgY3JlYXRlanMuQ29sb3JGaWx0ZXIoMCwgMCwgMCwgMSwgMjU1LCAwLCAwKSxcblx0ICogICAgICAgICAgbmV3IGNyZWF0ZWpzLkJsdXJGaWx0ZXIoNSwgNSwgMTApXG5cdCAqICAgICAgXTtcblx0ICogICAgICBteUluc3RhbmNlLmNhY2hlKDAsMCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiBOb3RlIHRoYXQgZWFjaCBmaWx0ZXIgY2FuIGltcGxlbWVudCBhIHt7I2Nyb3NzTGluayBcIkZpbHRlci9nZXRCb3VuZHNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLCB3aGljaCByZXR1cm5zIHRoZVxuXHQgKiBtYXJnaW5zIHRoYXQgbmVlZCB0byBiZSBhcHBsaWVkIGluIG9yZGVyIHRvIGZ1bGx5IGRpc3BsYXkgdGhlIGZpbHRlci4gRm9yIGV4YW1wbGUsIHRoZSB7eyNjcm9zc0xpbmsgXCJCbHVyRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHdpbGwgY2F1c2UgYW4gb2JqZWN0IHRvIGZlYXRoZXIgb3V0d2FyZHMsIHJlc3VsdGluZyBpbiBhIG1hcmdpbiBhcm91bmQgdGhlIHNoYXBlLlxuXHQgKlxuXHQgKiA8aDQ+RWFzZWxKUyBGaWx0ZXJzPC9oND5cblx0ICogRWFzZWxKUyBjb21lcyB3aXRoIGEgbnVtYmVyIG9mIHByZS1idWlsdCBmaWx0ZXJzLiBOb3RlIHRoYXQgaW5kaXZpZHVhbCBmaWx0ZXJzIGFyZSBub3QgY29tcGlsZWQgaW50byB0aGUgbWluaWZpZWRcblx0ICogdmVyc2lvbiBvZiBFYXNlbEpTLiBUbyB1c2UgdGhlbSwgeW91IG11c3QgaW5jbHVkZSB0aGVtIG1hbnVhbGx5IGluIHRoZSBIVE1MLlxuXHQgKiA8dWw+PGxpPnt7I2Nyb3NzTGluayBcIkFscGhhTWFwRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319IDogTWFwIGEgZ3JleXNjYWxlIGltYWdlIHRvIHRoZSBhbHBoYSBjaGFubmVsIG9mIGEgZGlzcGxheSBvYmplY3Q8L2xpPlxuXHQgKiAgICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBbHBoYU1hc2tGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX06IE1hcCBhbiBpbWFnZSdzIGFscGhhIGNoYW5uZWwgdG8gdGhlIGFscGhhIGNoYW5uZWwgb2YgYSBkaXNwbGF5IG9iamVjdDwvbGk+XG5cdCAqICAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkJsdXJGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX06IEFwcGx5IHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIGJsdXIgdG8gYSBkaXNwbGF5IG9iamVjdDwvbGk+XG5cdCAqICAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkNvbG9yRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319OiBDb2xvciB0cmFuc2Zvcm0gYSBkaXNwbGF5IG9iamVjdDwvbGk+XG5cdCAqICAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkNvbG9yTWF0cml4RmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319OiBUcmFuc2Zvcm0gYW4gaW1hZ2UgdXNpbmcgYSB7eyNjcm9zc0xpbmsgXCJDb2xvck1hdHJpeFwifX17ey9jcm9zc0xpbmt9fTwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqIEBjbGFzcyBGaWx0ZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gRmlsdGVyKCkge31cblx0dmFyIHAgPSBGaWx0ZXIucHJvdG90eXBlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFByb3ZpZGVzIHBhZGRpbmcgdmFsdWVzIGZvciB0aGlzIGZpbHRlci4gVGhhdCBpcywgaG93IG11Y2ggdGhlIGZpbHRlciB3aWxsIGV4dGVuZCB0aGUgdmlzdWFsIGJvdW5kcyBvZiBhbiBvYmplY3QgaXQgaXMgYXBwbGllZCB0by5cblx0ICogQG1ldGhvZCBnZXRCb3VuZHNcblx0ICogQHBhcmFtIHtSZWN0YW5nbGV9IFtyZWN0XSBJZiBzcGVjaWZpZWQsIHRoZSBwcm92aWRlZCBSZWN0YW5nbGUgaW5zdGFuY2Ugd2lsbCBiZSBleHBhbmRlZCBieSB0aGUgcGFkZGluZyBhbW91bnRzIGFuZCByZXR1cm5lZC5cblx0ICogQHJldHVybiB7UmVjdGFuZ2xlfSBJZiBhIGByZWN0YCBwYXJhbSB3YXMgcHJvdmlkZWQsIGl0IGlzIHJldHVybmVkLiBJZiBub3QsIGVpdGhlciBhIG5ldyByZWN0YW5nbGUgd2l0aCB0aGUgcGFkZGluZyB2YWx1ZXMsIG9yIG51bGwgaWYgbm8gcGFkZGluZyBpcyByZXF1aXJlZCBmb3IgdGhpcyBmaWx0ZXIuXG5cdCAqKi9cblx0cC5nZXRCb3VuZHMgPSBmdW5jdGlvbihyZWN0KSB7XG5cdFx0cmV0dXJuIHJlY3Q7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhlIGZpbHRlciB0byB0aGUgc3BlY2lmaWVkIGNvbnRleHQuXG5cdCAqIEBtZXRob2QgYXBwbHlGaWx0ZXJcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgMkQgY29udGV4dCB0byB1c2UgYXMgdGhlIHNvdXJjZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHBvc2l0aW9uIHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggVGhlIHdpZHRoIHRvIHVzZSBmb3IgdGhlIHNvdXJjZSByZWN0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IFRoZSBoZWlnaHQgdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBbdGFyZ2V0Q3R4XSBUaGUgMkQgY29udGV4dCB0byBkcmF3IHRoZSByZXN1bHQgdG8uIERlZmF1bHRzIHRvIHRoZSBjb250ZXh0IHBhc3NlZCB0byBjdHguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGFyZ2V0WF0gVGhlIHggcG9zaXRpb24gdG8gZHJhdyB0aGUgcmVzdWx0IHRvLiBEZWZhdWx0cyB0byB0aGUgdmFsdWUgcGFzc2VkIHRvIHguXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGFyZ2V0WV0gVGhlIHkgcG9zaXRpb24gdG8gZHJhdyB0aGUgcmVzdWx0IHRvLiBEZWZhdWx0cyB0byB0aGUgdmFsdWUgcGFzc2VkIHRvIHkuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBmaWx0ZXIgd2FzIGFwcGxpZWQgc3VjY2Vzc2Z1bGx5LlxuXHQgKiovXG5cdHAuYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbihjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHRhcmdldEN0eCwgdGFyZ2V0WCwgdGFyZ2V0WSkge1xuXHRcdC8vIHRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIGJlY2F1c2UgbW9zdCBmaWx0ZXJzIGFjY2VzcyBwaXhlbCBkYXRhLiBJdCBpcyBvdmVycmlkZGVuIHdoZW4gbm90IG5lZWRlZC5cblx0XHR0YXJnZXRDdHggPSB0YXJnZXRDdHggfHwgY3R4O1xuXHRcdGlmICh0YXJnZXRYID09IG51bGwpIHsgdGFyZ2V0WCA9IHg7IH1cblx0XHRpZiAodGFyZ2V0WSA9PSBudWxsKSB7IHRhcmdldFkgPSB5OyB9XG5cdFx0dHJ5IHtcblx0XHRcdHZhciBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX2FwcGx5RmlsdGVyKGltYWdlRGF0YSkpIHtcblx0XHRcdHRhcmdldEN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCB0YXJnZXRYLCB0YXJnZXRZKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHJldHVybiB7U3RyaW5nfSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIltGaWx0ZXJdXCI7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGlzIEZpbHRlciBpbnN0YW5jZS5cblx0ICogQG1ldGhvZCBjbG9uZVxuXHQgKiBAcmV0dXJuIHtGaWx0ZXJ9IEEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgRmlsdGVyIGluc3RhbmNlLlxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEZpbHRlcigpO1xuXHR9O1xuXHRcbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX2FwcGx5RmlsdGVyXG5cdCAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBpbWFnZURhdGEgVGFyZ2V0IEltYWdlRGF0YSBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICoqL1xuXHRwLl9hcHBseUZpbHRlciA9IGZ1bmN0aW9uKGltYWdlRGF0YSkgeyByZXR1cm4gdHJ1ZTsgfTtcblxuXG5cdGNyZWF0ZWpzLkZpbHRlciA9IEZpbHRlcjtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBCbHVyRmlsdGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBBcHBsaWVzIGEgYm94IGJsdXIgdG8gRGlzcGxheU9iamVjdHMuIE5vdGUgdGhhdCB0aGlzIGZpbHRlciBpcyBmYWlybHkgQ1BVIGludGVuc2l2ZSwgcGFydGljdWxhcmx5IGlmIHRoZSBxdWFsaXR5IGlzXG5cdCAqIHNldCBoaWdoZXIgdGhhbiAxLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqIFRoaXMgZXhhbXBsZSBjcmVhdGVzIGEgcmVkIGNpcmNsZSwgYW5kIHRoZW4gYXBwbGllcyBhIDUgcGl4ZWwgYmx1ciB0byBpdC4gSXQgdXNlcyB0aGUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyL2dldEJvdW5kc1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QgdG8gYWNjb3VudCBmb3IgdGhlIHNwcmVhZCB0aGF0IHRoZSBibHVyIGNhdXNlcy5cblx0ICpcblx0ICogICAgICB2YXIgc2hhcGUgPSBuZXcgY3JlYXRlanMuU2hhcGUoKS5zZXQoe3g6MTAwLHk6MTAwfSk7XG5cdCAqICAgICAgc2hhcGUuZ3JhcGhpY3MuYmVnaW5GaWxsKFwiI2ZmMDAwMFwiKS5kcmF3Q2lyY2xlKDAsMCw1MCk7XG5cdCAqXG5cdCAqICAgICAgdmFyIGJsdXJGaWx0ZXIgPSBuZXcgY3JlYXRlanMuQmx1ckZpbHRlcig1LCA1LCAxKTtcblx0ICogICAgICBzaGFwZS5maWx0ZXJzID0gW2JsdXJGaWx0ZXJdO1xuXHQgKiAgICAgIHZhciBib3VuZHMgPSBibHVyRmlsdGVyLmdldEJvdW5kcygpO1xuXHQgKlxuXHQgKiAgICAgIHNoYXBlLmNhY2hlKC01MCtib3VuZHMueCwgLTUwK2JvdW5kcy55LCAxMDArYm91bmRzLndpZHRoLCAxMDArYm91bmRzLmhlaWdodCk7XG5cdCAqXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGFuIG1vcmUgaW5mb3JtYXRpb24gb24gYXBwbHlpbmcgZmlsdGVycy5cblx0ICogQGNsYXNzIEJsdXJGaWx0ZXJcblx0ICogQGV4dGVuZHMgRmlsdGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2JsdXJYPTBdIFRoZSBob3Jpem9udGFsIGJsdXIgcmFkaXVzIGluIHBpeGVscy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtibHVyWT0wXSBUaGUgdmVydGljYWwgYmx1ciByYWRpdXMgaW4gcGl4ZWxzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3F1YWxpdHk9MV0gVGhlIG51bWJlciBvZiBibHVyIGl0ZXJhdGlvbnMuXG5cdCAqKi9cblx0ZnVuY3Rpb24gQmx1ckZpbHRlciggYmx1clgsIGJsdXJZLCBxdWFsaXR5KSB7XG5cdFx0aWYgKCBpc05hTihibHVyWCkgfHwgYmx1clggPCAwICkgYmx1clggPSAwO1xuXHRcdGlmICggaXNOYU4oYmx1clkpIHx8IGJsdXJZIDwgMCApIGJsdXJZID0gMDtcblx0XHRpZiAoIGlzTmFOKHF1YWxpdHkpIHx8IHF1YWxpdHkgPCAxICApIHF1YWxpdHkgPSAxO1xuXG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBIb3Jpem9udGFsIGJsdXIgcmFkaXVzIGluIHBpeGVsc1xuXHRcdCAqIEBwcm9wZXJ0eSBibHVyWFxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5ibHVyWCA9IGJsdXJYIHwgMDtcblxuXHRcdC8qKlxuXHRcdCAqIFZlcnRpY2FsIGJsdXIgcmFkaXVzIGluIHBpeGVsc1xuXHRcdCAqIEBwcm9wZXJ0eSBibHVyWVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5ibHVyWSA9IGJsdXJZIHwgMDtcblxuXHRcdC8qKlxuXHRcdCAqIE51bWJlciBvZiBibHVyIGl0ZXJhdGlvbnMuIEZvciBleGFtcGxlLCBhIHZhbHVlIG9mIDEgd2lsbCBwcm9kdWNlIGEgcm91Z2ggYmx1ci4gQSB2YWx1ZSBvZiAyIHdpbGwgcHJvZHVjZSBhXG5cdFx0ICogc21vb3RoZXIgYmx1ciwgYnV0IHRha2UgdHdpY2UgYXMgbG9uZyB0byBydW4uXG5cdFx0ICogQHByb3BlcnR5IHF1YWxpdHlcblx0XHQgKiBAZGVmYXVsdCAxXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMucXVhbGl0eSA9IHF1YWxpdHkgfCAwO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEJsdXJGaWx0ZXIsIGNyZWF0ZWpzLkZpbHRlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblxuLy8gY29uc3RhbnRzOlxuXHQvKipcblx0ICogQXJyYXkgb2YgbXVsdGlwbHkgdmFsdWVzIGZvciBibHVyIGNhbGN1bGF0aW9ucy5cblx0ICogQHByb3BlcnR5IE1VTF9UQUJMRVxuXHQgKiBAdHlwZSBBcnJheVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRCbHVyRmlsdGVyLk1VTF9UQUJMRSA9IFsxLCAxNzEsIDIwNSwgMjkzLCA1NywgMzczLCA3OSwgMTM3LCAyNDEsIDI3LCAzOTEsIDM1NywgNDEsIDE5LCAyODMsIDI2NSwgNDk3LCA0NjksIDQ0MywgNDIxLCAyNSwgMTkxLCAzNjUsIDM0OSwgMzM1LCAxNjEsIDE1NSwgMTQ5LCA5LCAyNzgsIDI2OSwgMjYxLCA1MDUsIDI0NSwgNDc1LCAyMzEsIDQ0OSwgNDM3LCAyMTMsIDQxNSwgNDA1LCAzOTUsIDE5MywgMzc3LCAzNjksIDM2MSwgMzUzLCAzNDUsIDE2OSwgMzMxLCAzMjUsIDMxOSwgMzEzLCAzMDcsIDMwMSwgMzcsIDE0NSwgMjg1LCAyODEsIDY5LCAyNzEsIDI2NywgMjYzLCAyNTksIDUwOSwgNTAxLCA0OTMsIDI0MywgNDc5LCAxMTgsIDQ2NSwgNDU5LCAxMTMsIDQ0NiwgNTUsIDQzNSwgNDI5LCA0MjMsIDIwOSwgNDEzLCA1MSwgNDAzLCAxOTksIDM5MywgOTcsIDMsIDM3OSwgMzc1LCAzNzEsIDM2NywgMzYzLCAzNTksIDM1NSwgMzUxLCAzNDcsIDQzLCA4NSwgMzM3LCAzMzMsIDE2NSwgMzI3LCAzMjMsIDUsIDMxNywgMTU3LCAzMTEsIDc3LCAzMDUsIDMwMywgNzUsIDI5NywgMjk0LCA3MywgMjg5LCAyODcsIDcxLCAxNDEsIDI3OSwgMjc3LCAyNzUsIDY4LCAxMzUsIDY3LCAxMzMsIDMzLCAyNjIsIDI2MCwgMTI5LCA1MTEsIDUwNywgNTAzLCA0OTksIDQ5NSwgNDkxLCA2MSwgMTIxLCA0ODEsIDQ3NywgMjM3LCAyMzUsIDQ2NywgMjMyLCAxMTUsIDQ1NywgMjI3LCA0NTEsIDcsIDQ0NSwgMjIxLCA0MzksIDIxOCwgNDMzLCAyMTUsIDQyNywgNDI1LCAyMTEsIDQxOSwgNDE3LCAyMDcsIDQxMSwgNDA5LCAyMDMsIDIwMiwgNDAxLCAzOTksIDM5NiwgMTk3LCA0OSwgMzg5LCAzODcsIDM4NSwgMzgzLCA5NSwgMTg5LCA0NywgMTg3LCA5MywgMTg1LCAyMywgMTgzLCA5MSwgMTgxLCA0NSwgMTc5LCA4OSwgMTc3LCAxMSwgMTc1LCA4NywgMTczLCAzNDUsIDM0MywgMzQxLCAzMzksIDMzNywgMjEsIDE2NywgODMsIDMzMSwgMzI5LCAzMjcsIDE2MywgODEsIDMyMywgMzIxLCAzMTksIDE1OSwgNzksIDMxNSwgMzEzLCAzOSwgMTU1LCAzMDksIDMwNywgMTUzLCAzMDUsIDMwMywgMTUxLCA3NSwgMjk5LCAxNDksIDM3LCAyOTUsIDE0NywgNzMsIDI5MSwgMTQ1LCAyODksIDI4NywgMTQzLCAyODUsIDcxLCAxNDEsIDI4MSwgMzUsIDI3OSwgMTM5LCA2OSwgMjc1LCAxMzcsIDI3MywgMTcsIDI3MSwgMTM1LCAyNjksIDI2NywgMTMzLCAyNjUsIDMzLCAyNjMsIDEzMSwgMjYxLCAxMzAsIDI1OSwgMTI5LCAyNTcsIDFdO1xuXG5cdC8qKlxuXHQgKiBBcnJheSBvZiBzaGlmdCB2YWx1ZXMgZm9yIGJsdXIgY2FsY3VsYXRpb25zLlxuXHQgKiBAcHJvcGVydHkgU0hHX1RBQkxFXG5cdCAqIEB0eXBlIEFycmF5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdEJsdXJGaWx0ZXIuU0hHX1RBQkxFID0gWzAsIDksIDEwLCAxMSwgOSwgMTIsIDEwLCAxMSwgMTIsIDksIDEzLCAxMywgMTAsIDksIDEzLCAxMywgMTQsIDE0LCAxNCwgMTQsIDEwLCAxMywgMTQsIDE0LCAxNCwgMTMsIDEzLCAxMywgOSwgMTQsIDE0LCAxNCwgMTUsIDE0LCAxNSwgMTQsIDE1LCAxNSwgMTQsIDE1LCAxNSwgMTUsIDE0LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE0LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE1LCAxMiwgMTQsIDE1LCAxNSwgMTMsIDE1LCAxNSwgMTUsIDE1LCAxNiwgMTYsIDE2LCAxNSwgMTYsIDE0LCAxNiwgMTYsIDE0LCAxNiwgMTMsIDE2LCAxNiwgMTYsIDE1LCAxNiwgMTMsIDE2LCAxNSwgMTYsIDE0LCA5LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxMywgMTQsIDE2LCAxNiwgMTUsIDE2LCAxNiwgMTAsIDE2LCAxNSwgMTYsIDE0LCAxNiwgMTYsIDE0LCAxNiwgMTYsIDE0LCAxNiwgMTYsIDE0LCAxNSwgMTYsIDE2LCAxNiwgMTQsIDE1LCAxNCwgMTUsIDEzLCAxNiwgMTYsIDE1LCAxNywgMTcsIDE3LCAxNywgMTcsIDE3LCAxNCwgMTUsIDE3LCAxNywgMTYsIDE2LCAxNywgMTYsIDE1LCAxNywgMTYsIDE3LCAxMSwgMTcsIDE2LCAxNywgMTYsIDE3LCAxNiwgMTcsIDE3LCAxNiwgMTcsIDE3LCAxNiwgMTcsIDE3LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE2LCAxNCwgMTcsIDE3LCAxNywgMTcsIDE1LCAxNiwgMTQsIDE2LCAxNSwgMTYsIDEzLCAxNiwgMTUsIDE2LCAxNCwgMTYsIDE1LCAxNiwgMTIsIDE2LCAxNSwgMTYsIDE3LCAxNywgMTcsIDE3LCAxNywgMTMsIDE2LCAxNSwgMTcsIDE3LCAxNywgMTYsIDE1LCAxNywgMTcsIDE3LCAxNiwgMTUsIDE3LCAxNywgMTQsIDE2LCAxNywgMTcsIDE2LCAxNywgMTcsIDE2LCAxNSwgMTcsIDE2LCAxNCwgMTcsIDE2LCAxNSwgMTcsIDE2LCAxNywgMTcsIDE2LCAxNywgMTUsIDE2LCAxNywgMTQsIDE3LCAxNiwgMTUsIDE3LCAxNiwgMTcsIDEzLCAxNywgMTYsIDE3LCAxNywgMTYsIDE3LCAxNCwgMTcsIDE2LCAxNywgMTYsIDE3LCAxNiwgMTcsIDldO1xuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5nZXRCb3VuZHMgPSBmdW5jdGlvbiAocmVjdCkge1xuXHRcdHZhciB4ID0gdGhpcy5ibHVyWHwwLCB5ID0gdGhpcy5ibHVyWXwgMDtcblx0XHRpZiAoeCA8PSAwICYmIHkgPD0gMCkgeyByZXR1cm4gcmVjdDsgfVxuXHRcdHZhciBxID0gTWF0aC5wb3codGhpcy5xdWFsaXR5LCAwLjIpO1xuXHRcdHJldHVybiAocmVjdCB8fCBuZXcgY3JlYXRlanMuUmVjdGFuZ2xlKCkpLnBhZCh4KnErMSx5KnErMSx4KnErMSx5KnErMSk7XG5cdH07XG5cblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgQmx1ckZpbHRlcih0aGlzLmJsdXJYLCB0aGlzLmJsdXJZLCB0aGlzLnF1YWxpdHkpO1xuXHR9O1xuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbQmx1ckZpbHRlcl1cIjtcblx0fTtcblxuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5fYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG5cblx0XHR2YXIgcmFkaXVzWCA9IHRoaXMuYmx1clggPj4gMTtcblx0XHRpZiAoaXNOYU4ocmFkaXVzWCkgfHwgcmFkaXVzWCA8IDApIHJldHVybiBmYWxzZTtcblx0XHR2YXIgcmFkaXVzWSA9IHRoaXMuYmx1clkgPj4gMTtcblx0XHRpZiAoaXNOYU4ocmFkaXVzWSkgfHwgcmFkaXVzWSA8IDApIHJldHVybiBmYWxzZTtcblx0XHRpZiAocmFkaXVzWCA9PSAwICYmIHJhZGl1c1kgPT0gMCkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0dmFyIGl0ZXJhdGlvbnMgPSB0aGlzLnF1YWxpdHk7XG5cdFx0aWYgKGlzTmFOKGl0ZXJhdGlvbnMpIHx8IGl0ZXJhdGlvbnMgPCAxKSBpdGVyYXRpb25zID0gMTtcblx0XHRpdGVyYXRpb25zIHw9IDA7XG5cdFx0aWYgKGl0ZXJhdGlvbnMgPiAzKSBpdGVyYXRpb25zID0gMztcblx0XHRpZiAoaXRlcmF0aW9ucyA8IDEpIGl0ZXJhdGlvbnMgPSAxO1xuXG5cdFx0dmFyIHB4ID0gaW1hZ2VEYXRhLmRhdGE7XG5cdFx0dmFyIHg9MCwgeT0wLCBpPTAsIHA9MCwgeXA9MCwgeWk9MCwgeXc9MCwgcj0wLCBnPTAsIGI9MCwgYT0wLCBwcj0wLCBwZz0wLCBwYj0wLCBwYT0wO1xuXG5cdFx0dmFyIGRpdnggPSAocmFkaXVzWCArIHJhZGl1c1ggKyAxKSB8IDA7XG5cdFx0dmFyIGRpdnkgPSAocmFkaXVzWSArIHJhZGl1c1kgKyAxKSB8IDA7XG5cdFx0dmFyIHcgPSBpbWFnZURhdGEud2lkdGggfCAwO1xuXHRcdHZhciBoID0gaW1hZ2VEYXRhLmhlaWdodCB8IDA7XG5cblx0XHR2YXIgdzEgPSAodyAtIDEpIHwgMDtcblx0XHR2YXIgaDEgPSAoaCAtIDEpIHwgMDtcblx0XHR2YXIgcnhwMSA9IChyYWRpdXNYICsgMSkgfCAwO1xuXHRcdHZhciByeXAxID0gKHJhZGl1c1kgKyAxKSB8IDA7XG5cblx0XHR2YXIgc3N4ID0ge3I6MCxiOjAsZzowLGE6MH07XG5cdFx0dmFyIHN4ID0gc3N4O1xuXHRcdGZvciAoIGkgPSAxOyBpIDwgZGl2eDsgaSsrIClcblx0XHR7XG5cdFx0XHRzeCA9IHN4Lm4gPSB7cjowLGI6MCxnOjAsYTowfTtcblx0XHR9XG5cdFx0c3gubiA9IHNzeDtcblxuXHRcdHZhciBzc3kgPSB7cjowLGI6MCxnOjAsYTowfTtcblx0XHR2YXIgc3kgPSBzc3k7XG5cdFx0Zm9yICggaSA9IDE7IGkgPCBkaXZ5OyBpKysgKVxuXHRcdHtcblx0XHRcdHN5ID0gc3kubiA9IHtyOjAsYjowLGc6MCxhOjB9O1xuXHRcdH1cblx0XHRzeS5uID0gc3N5O1xuXG5cdFx0dmFyIHNpID0gbnVsbDtcblxuXG5cdFx0dmFyIG10eCA9IEJsdXJGaWx0ZXIuTVVMX1RBQkxFW3JhZGl1c1hdIHwgMDtcblx0XHR2YXIgc3R4ID0gQmx1ckZpbHRlci5TSEdfVEFCTEVbcmFkaXVzWF0gfCAwO1xuXHRcdHZhciBtdHkgPSBCbHVyRmlsdGVyLk1VTF9UQUJMRVtyYWRpdXNZXSB8IDA7XG5cdFx0dmFyIHN0eSA9IEJsdXJGaWx0ZXIuU0hHX1RBQkxFW3JhZGl1c1ldIHwgMDtcblxuXHRcdHdoaWxlIChpdGVyYXRpb25zLS0gPiAwKSB7XG5cblx0XHRcdHl3ID0geWkgPSAwO1xuXHRcdFx0dmFyIG1zID0gbXR4O1xuXHRcdFx0dmFyIHNzID0gc3R4O1xuXHRcdFx0Zm9yICh5ID0gaDsgLS15ID4gLTE7KSB7XG5cdFx0XHRcdHIgPSByeHAxICogKHByID0gcHhbKHlpKSB8IDBdKTtcblx0XHRcdFx0ZyA9IHJ4cDEgKiAocGcgPSBweFsoeWkgKyAxKSB8IDBdKTtcblx0XHRcdFx0YiA9IHJ4cDEgKiAocGIgPSBweFsoeWkgKyAyKSB8IDBdKTtcblx0XHRcdFx0YSA9IHJ4cDEgKiAocGEgPSBweFsoeWkgKyAzKSB8IDBdKTtcblxuXHRcdFx0XHRzeCA9IHNzeDtcblxuXHRcdFx0XHRmb3IoIGkgPSByeHAxOyAtLWkgPiAtMTsgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c3guciA9IHByO1xuXHRcdFx0XHRcdHN4LmcgPSBwZztcblx0XHRcdFx0XHRzeC5iID0gcGI7XG5cdFx0XHRcdFx0c3guYSA9IHBhO1xuXHRcdFx0XHRcdHN4ID0gc3gubjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciggaSA9IDE7IGkgPCByeHAxOyBpKysgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cCA9ICh5aSArICgodzEgPCBpID8gdzEgOiBpKSA8PCAyKSkgfCAwO1xuXHRcdFx0XHRcdHIgKz0gKCBzeC5yID0gcHhbcF0pO1xuXHRcdFx0XHRcdGcgKz0gKCBzeC5nID0gcHhbcCsxXSk7XG5cdFx0XHRcdFx0YiArPSAoIHN4LmIgPSBweFtwKzJdKTtcblx0XHRcdFx0XHRhICs9ICggc3guYSA9IHB4W3ArM10pO1xuXG5cdFx0XHRcdFx0c3ggPSBzeC5uO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2kgPSBzc3g7XG5cdFx0XHRcdGZvciAoIHggPSAwOyB4IDwgdzsgeCsrIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHB4W3lpKytdID0gKHIgKiBtcykgPj4+IHNzO1xuXHRcdFx0XHRcdHB4W3lpKytdID0gKGcgKiBtcykgPj4+IHNzO1xuXHRcdFx0XHRcdHB4W3lpKytdID0gKGIgKiBtcykgPj4+IHNzO1xuXHRcdFx0XHRcdHB4W3lpKytdID0gKGEgKiBtcykgPj4+IHNzO1xuXG5cdFx0XHRcdFx0cCA9ICgoeXcgKyAoKHAgPSB4ICsgcmFkaXVzWCArIDEpIDwgdzEgPyBwIDogdzEpKSA8PCAyKTtcblxuXHRcdFx0XHRcdHIgLT0gc2kuciAtICggc2kuciA9IHB4W3BdKTtcblx0XHRcdFx0XHRnIC09IHNpLmcgLSAoIHNpLmcgPSBweFtwKzFdKTtcblx0XHRcdFx0XHRiIC09IHNpLmIgLSAoIHNpLmIgPSBweFtwKzJdKTtcblx0XHRcdFx0XHRhIC09IHNpLmEgLSAoIHNpLmEgPSBweFtwKzNdKTtcblxuXHRcdFx0XHRcdHNpID0gc2kubjtcblxuXHRcdFx0XHR9XG5cdFx0XHRcdHl3ICs9IHc7XG5cdFx0XHR9XG5cblx0XHRcdG1zID0gbXR5O1xuXHRcdFx0c3MgPSBzdHk7XG5cdFx0XHRmb3IgKHggPSAwOyB4IDwgdzsgeCsrKSB7XG5cdFx0XHRcdHlpID0gKHggPDwgMikgfCAwO1xuXG5cdFx0XHRcdHIgPSAocnlwMSAqIChwciA9IHB4W3lpXSkpIHwgMDtcblx0XHRcdFx0ZyA9IChyeXAxICogKHBnID0gcHhbKHlpICsgMSkgfCAwXSkpIHwgMDtcblx0XHRcdFx0YiA9IChyeXAxICogKHBiID0gcHhbKHlpICsgMikgfCAwXSkpIHwgMDtcblx0XHRcdFx0YSA9IChyeXAxICogKHBhID0gcHhbKHlpICsgMykgfCAwXSkpIHwgMDtcblxuXHRcdFx0XHRzeSA9IHNzeTtcblx0XHRcdFx0Zm9yKCBpID0gMDsgaSA8IHJ5cDE7IGkrKyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzeS5yID0gcHI7XG5cdFx0XHRcdFx0c3kuZyA9IHBnO1xuXHRcdFx0XHRcdHN5LmIgPSBwYjtcblx0XHRcdFx0XHRzeS5hID0gcGE7XG5cdFx0XHRcdFx0c3kgPSBzeS5uO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0eXAgPSB3O1xuXG5cdFx0XHRcdGZvciggaSA9IDE7IGkgPD0gcmFkaXVzWTsgaSsrIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHlpID0gKCB5cCArIHggKSA8PCAyO1xuXG5cdFx0XHRcdFx0ciArPSAoIHN5LnIgPSBweFt5aV0pO1xuXHRcdFx0XHRcdGcgKz0gKCBzeS5nID0gcHhbeWkrMV0pO1xuXHRcdFx0XHRcdGIgKz0gKCBzeS5iID0gcHhbeWkrMl0pO1xuXHRcdFx0XHRcdGEgKz0gKCBzeS5hID0gcHhbeWkrM10pO1xuXG5cdFx0XHRcdFx0c3kgPSBzeS5uO1xuXG5cdFx0XHRcdFx0aWYoIGkgPCBoMSApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0eXAgKz0gdztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR5aSA9IHg7XG5cdFx0XHRcdHNpID0gc3N5O1xuXHRcdFx0XHRpZiAoIGl0ZXJhdGlvbnMgPiAwIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAoIHkgPSAwOyB5IDwgaDsgeSsrIClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRwID0geWkgPDwgMjtcblx0XHRcdFx0XHRcdHB4W3ArM10gPSBwYSA9KGEgKiBtcykgPj4+IHNzO1xuXHRcdFx0XHRcdFx0aWYgKCBwYSA+IDAgKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRweFtwXSAgID0gKChyICogbXMpID4+PiBzcyApO1xuXHRcdFx0XHRcdFx0XHRweFtwKzFdID0gKChnICogbXMpID4+PiBzcyApO1xuXHRcdFx0XHRcdFx0XHRweFtwKzJdID0gKChiICogbXMpID4+PiBzcyApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cHhbcF0gPSBweFtwKzFdID0gcHhbcCsyXSA9IDBcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cCA9ICggeCArICgoICggcCA9IHkgKyByeXAxKSA8IGgxID8gcCA6IGgxICkgKiB3ICkpIDw8IDI7XG5cblx0XHRcdFx0XHRcdHIgLT0gc2kuciAtICggc2kuciA9IHB4W3BdKTtcblx0XHRcdFx0XHRcdGcgLT0gc2kuZyAtICggc2kuZyA9IHB4W3ArMV0pO1xuXHRcdFx0XHRcdFx0YiAtPSBzaS5iIC0gKCBzaS5iID0gcHhbcCsyXSk7XG5cdFx0XHRcdFx0XHRhIC09IHNpLmEgLSAoIHNpLmEgPSBweFtwKzNdKTtcblxuXHRcdFx0XHRcdFx0c2kgPSBzaS5uO1xuXG5cdFx0XHRcdFx0XHR5aSArPSB3O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3IgKCB5ID0gMDsgeSA8IGg7IHkrKyApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cCA9IHlpIDw8IDI7XG5cdFx0XHRcdFx0XHRweFtwKzNdID0gcGEgPShhICogbXMpID4+PiBzcztcblx0XHRcdFx0XHRcdGlmICggcGEgPiAwIClcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cGEgPSAyNTUgLyBwYTtcblx0XHRcdFx0XHRcdFx0cHhbcF0gICA9ICgociAqIG1zKSA+Pj4gc3MgKSAqIHBhO1xuXHRcdFx0XHRcdFx0XHRweFtwKzFdID0gKChnICogbXMpID4+PiBzcyApICogcGE7XG5cdFx0XHRcdFx0XHRcdHB4W3ArMl0gPSAoKGIgKiBtcykgPj4+IHNzICkgKiBwYTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHB4W3BdID0gcHhbcCsxXSA9IHB4W3ArMl0gPSAwXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHAgPSAoIHggKyAoKCAoIHAgPSB5ICsgcnlwMSkgPCBoMSA/IHAgOiBoMSApICogdyApKSA8PCAyO1xuXG5cdFx0XHRcdFx0XHRyIC09IHNpLnIgLSAoIHNpLnIgPSBweFtwXSk7XG5cdFx0XHRcdFx0XHRnIC09IHNpLmcgLSAoIHNpLmcgPSBweFtwKzFdKTtcblx0XHRcdFx0XHRcdGIgLT0gc2kuYiAtICggc2kuYiA9IHB4W3ArMl0pO1xuXHRcdFx0XHRcdFx0YSAtPSBzaS5hIC0gKCBzaS5hID0gcHhbcCszXSk7XG5cblx0XHRcdFx0XHRcdHNpID0gc2kubjtcblxuXHRcdFx0XHRcdFx0eWkgKz0gdztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHRjcmVhdGVqcy5CbHVyRmlsdGVyID0gY3JlYXRlanMucHJvbW90ZShCbHVyRmlsdGVyLCBcIkZpbHRlclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBBbHBoYU1hcEZpbHRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRcblx0XG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEFwcGxpZXMgYSBncmV5c2NhbGUgYWxwaGEgbWFwIGltYWdlIChvciBjYW52YXMpIHRvIHRoZSB0YXJnZXQsIHN1Y2ggdGhhdCB0aGUgYWxwaGEgY2hhbm5lbCBvZiB0aGUgcmVzdWx0IHdpbGxcblx0ICogYmUgY29waWVkIGZyb20gdGhlIHJlZCBjaGFubmVsIG9mIHRoZSBtYXAsIGFuZCB0aGUgUkdCIGNoYW5uZWxzIHdpbGwgYmUgY29waWVkIGZyb20gdGhlIHRhcmdldC5cblx0ICpcblx0ICogR2VuZXJhbGx5LCBpdCBpcyByZWNvbW1lbmRlZCB0aGF0IHlvdSB1c2Uge3sjY3Jvc3NMaW5rIFwiQWxwaGFNYXNrRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319LCBiZWNhdXNlIGl0IGhhcyBtdWNoXG5cdCAqIGJldHRlciBwZXJmb3JtYW5jZS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBUaGlzIGV4YW1wbGUgZHJhd3MgYSByZWQtPmJsdWUgYm94LCBjYWNoZXMgaXQsIGFuZCB0aGVuIHVzZXMgdGhlIGNhY2hlIGNhbnZhcyBhcyBhbiBhbHBoYSBtYXAgb24gYSAxMDB4MTAwIGltYWdlLlxuXHQgKlxuXHQgKiAgICAgICB2YXIgYm94ID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG5cdCAqICAgICAgIGJveC5ncmFwaGljcy5iZWdpbkxpbmVhckdyYWRpZW50RmlsbChbXCIjZmYwMDAwXCIsIFwiIzAwMDBmZlwiXSwgWzAsIDFdLCAwLCAwLCAwLCAxMDApXG5cdCAqICAgICAgIGJveC5ncmFwaGljcy5kcmF3UmVjdCgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqICAgICAgIGJveC5jYWNoZSgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqXG5cdCAqICAgICAgIHZhciBibXAgPSBuZXcgY3JlYXRlanMuQml0bWFwKFwicGF0aC90by9pbWFnZS5qcGdcIik7XG5cdCAqICAgICAgIGJtcC5maWx0ZXJzID0gW1xuXHQgKiAgICAgICAgICAgbmV3IGNyZWF0ZWpzLkFscGhhTWFwRmlsdGVyKGJveC5jYWNoZUNhbnZhcylcblx0ICogICAgICAgXTtcblx0ICogICAgICAgYm1wLmNhY2hlKDAsIDAsIDEwMCwgMTAwKTtcblx0ICogICAgICAgc3RhZ2UuYWRkQ2hpbGQoYm1wKTtcblx0ICpcblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIkZpbHRlclwifX17ey9jcm9zc0xpbmt9fSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBhcHBseWluZyBmaWx0ZXJzLlxuXHQgKiBAY2xhc3MgQWxwaGFNYXBGaWx0ZXJcblx0ICogQGV4dGVuZHMgRmlsdGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IGFscGhhTWFwIFRoZSBncmV5c2NhbGUgaW1hZ2UgKG9yIGNhbnZhcykgdG8gdXNlIGFzIHRoZSBhbHBoYSB2YWx1ZSBmb3IgdGhlXG5cdCAqIHJlc3VsdC4gVGhpcyBzaG91bGQgYmUgZXhhY3RseSB0aGUgc2FtZSBkaW1lbnNpb25zIGFzIHRoZSB0YXJnZXQuXG5cdCAqKi9cblx0ZnVuY3Rpb24gQWxwaGFNYXBGaWx0ZXIoYWxwaGFNYXApIHtcblx0XG5cdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgZ3JleXNjYWxlIGltYWdlIChvciBjYW52YXMpIHRvIHVzZSBhcyB0aGUgYWxwaGEgdmFsdWUgZm9yIHRoZSByZXN1bHQuIFRoaXMgc2hvdWxkIGJlIGV4YWN0bHkgdGhlIHNhbWVcblx0XHQgKiBkaW1lbnNpb25zIGFzIHRoZSB0YXJnZXQuXG5cdFx0ICogQHByb3BlcnR5IGFscGhhTWFwXG5cdFx0ICogQHR5cGUgSFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudFxuXHRcdCAqKi9cblx0XHR0aGlzLmFscGhhTWFwID0gYWxwaGFNYXA7XG5cdFx0XG5cdFx0XG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2FscGhhTWFwXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnRcblx0XHQgKiovXG5cdFx0dGhpcy5fYWxwaGFNYXAgPSBudWxsO1xuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfbWFwRGF0YVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSBVaW50OENsYW1wZWRBcnJheVxuXHRcdCAqKi9cblx0XHR0aGlzLl9tYXBEYXRhID0gbnVsbDtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChBbHBoYU1hcEZpbHRlciwgY3JlYXRlanMuRmlsdGVyKTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbyA9IG5ldyBBbHBoYU1hcEZpbHRlcih0aGlzLmFscGhhTWFwKTtcblx0XHRvLl9hbHBoYU1hcCA9IHRoaXMuX2FscGhhTWFwO1xuXHRcdG8uX21hcERhdGEgPSB0aGlzLl9tYXBEYXRhO1xuXHRcdHJldHVybiBvO1xuXHR9O1xuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFwiW0FscGhhTWFwRmlsdGVyXVwiO1xuXHR9O1xuXG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5fYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG5cdFx0aWYgKCF0aGlzLmFscGhhTWFwKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0aWYgKCF0aGlzLl9wcmVwQWxwaGFNYXAoKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRcblx0XHQvLyBUT0RPOiB1cGRhdGUgdG8gc3VwcG9ydCBzY2VuYXJpb3Mgd2hlcmUgdGhlIHRhcmdldCBoYXMgZGlmZmVyZW50IGRpbWVuc2lvbnMuXG5cdFx0dmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwRGF0YTtcblx0XHRmb3IodmFyIGk9MCwgbD1kYXRhLmxlbmd0aDsgaTxsOyBpICs9IDQpIHsgZGF0YVtpICsgM10gPSBtYXBbaV0gfHwgMDsgfVxuXHRcdFxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9wcmVwQWxwaGFNYXBcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX3ByZXBBbHBoYU1hcCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuYWxwaGFNYXApIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKHRoaXMuYWxwaGFNYXAgPT0gdGhpcy5fYWxwaGFNYXAgJiYgdGhpcy5fbWFwRGF0YSkgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0dGhpcy5fbWFwRGF0YSA9IG51bGw7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX2FscGhhTWFwID0gdGhpcy5hbHBoYU1hcDtcblx0XHR2YXIgY2FudmFzID0gbWFwO1xuXHRcdHZhciBjdHg7XG5cdFx0aWYgKG1hcCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG5cdFx0XHRjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYW52YXMgPSBjcmVhdGVqcy5jcmVhdGVDYW52YXMgPyBjcmVhdGVqcy5jcmVhdGVDYW52YXMoKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cdFx0XHRjYW52YXMud2lkdGggPSBtYXAud2lkdGg7XG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gbWFwLmhlaWdodDtcblx0XHRcdGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cdFx0XHRjdHguZHJhd0ltYWdlKG1hcCwgMCwgMCk7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciBpbWdEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBtYXAud2lkdGgsIG1hcC5oZWlnaHQpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vaWYgKCF0aGlzLnN1cHByZXNzQ3Jvc3NEb21haW5FcnJvcnMpIHRocm93IG5ldyBFcnJvcihcInVuYWJsZSB0byBhY2Nlc3MgbG9jYWwgaW1hZ2UgZGF0YTogXCIgKyBlKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0XG5cdFx0dGhpcy5fbWFwRGF0YSA9IGltZ0RhdGEuZGF0YTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLkFscGhhTWFwRmlsdGVyID0gY3JlYXRlanMucHJvbW90ZShBbHBoYU1hcEZpbHRlciwgXCJGaWx0ZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQWxwaGFNYXNrRmlsdGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBBcHBsaWVzIHRoZSBhbHBoYSBmcm9tIHRoZSBtYXNrIGltYWdlIChvciBjYW52YXMpIHRvIHRoZSB0YXJnZXQsIHN1Y2ggdGhhdCB0aGUgYWxwaGEgY2hhbm5lbCBvZiB0aGUgcmVzdWx0IHdpbGxcblx0ICogYmUgZGVyaXZlZCBmcm9tIHRoZSBtYXNrLCBhbmQgdGhlIFJHQiBjaGFubmVscyB3aWxsIGJlIGNvcGllZCBmcm9tIHRoZSB0YXJnZXQuIFRoaXMgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCB0b1xuXHQgKiBhcHBseSBhbiBhbHBoYSBtYXNrIHRvIGEgZGlzcGxheSBvYmplY3QuIFRoaXMgY2FuIGFsc28gYmUgdXNlZCB0byBjb21iaW5lIGEgSlBHIGNvbXByZXNzZWQgUkdCIGltYWdlIHdpdGggYSBQTkczMlxuXHQgKiBhbHBoYSBtYXNrLCB3aGljaCBjYW4gcmVzdWx0IGluIGEgbXVjaCBzbWFsbGVyIGZpbGUgc2l6ZSB0aGFuIGEgc2luZ2xlIFBORzMyIGNvbnRhaW5pbmcgQVJHQi5cblx0ICpcblx0ICogPGI+SU1QT1JUQU5UIE5PVEU6IFRoaXMgZmlsdGVyIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IHRoZSB0YXJnZXRDdHgsIG9yIHRhcmdldFgvWSBwYXJhbWV0ZXJzIGNvcnJlY3RseS48L2I+XG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogVGhpcyBleGFtcGxlIGRyYXdzIGEgZ3JhZGllbnQgYm94LCB0aGVuIGNhY2hlcyBpdCBhbmQgdXNlcyB0aGUgXCJjYWNoZUNhbnZhc1wiIGFzIHRoZSBhbHBoYSBtYXNrIG9uIGEgMTAweDEwMCBpbWFnZS5cblx0ICpcblx0ICogICAgICB2YXIgYm94ID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XG5cdCAqICAgICAgYm94LmdyYXBoaWNzLmJlZ2luTGluZWFyR3JhZGllbnRGaWxsKFtcIiMwMDAwMDBcIiwgXCJyZ2JhKDAsIDAsIDAsIDApXCJdLCBbMCwgMV0sIDAsIDAsIDEwMCwgMTAwKVxuXHQgKiAgICAgIGJveC5ncmFwaGljcy5kcmF3UmVjdCgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqICAgICAgYm94LmNhY2hlKDAsIDAsIDEwMCwgMTAwKTtcblx0ICpcblx0ICogICAgICB2YXIgYm1wID0gbmV3IGNyZWF0ZWpzLkJpdG1hcChcInBhdGgvdG8vaW1hZ2UuanBnXCIpO1xuXHQgKiAgICAgIGJtcC5maWx0ZXJzID0gW1xuXHQgKiAgICAgICAgICBuZXcgY3JlYXRlanMuQWxwaGFNYXNrRmlsdGVyKGJveC5jYWNoZUNhbnZhcylcblx0ICogICAgICBdO1xuXHQgKiAgICAgIGJtcC5jYWNoZSgwLCAwLCAxMDAsIDEwMCk7XG5cdCAqXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gYXBwbHlpbmcgZmlsdGVycy5cblx0ICogQGNsYXNzIEFscGhhTWFza0ZpbHRlclxuXHQgKiBAZXh0ZW5kcyBGaWx0ZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gbWFza1xuXHQgKiovXG5cdGZ1bmN0aW9uIEFscGhhTWFza0ZpbHRlcihtYXNrKSB7XG5cdFxuXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogVGhlIGltYWdlIChvciBjYW52YXMpIHRvIHVzZSBhcyB0aGUgbWFzay5cblx0XHQgKiBAcHJvcGVydHkgbWFza1xuXHRcdCAqIEB0eXBlIEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnRcblx0XHQgKiovXG5cdFx0dGhpcy5tYXNrID0gbWFzaztcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChBbHBoYU1hc2tGaWx0ZXIsIGNyZWF0ZWpzLkZpbHRlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cdFxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhlIGZpbHRlciB0byB0aGUgc3BlY2lmaWVkIGNvbnRleHQuXG5cdCAqXG5cdCAqIDxzdHJvbmc+SU1QT1JUQU5UIE5PVEU6IFRoaXMgZmlsdGVyIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IHRoZSB0YXJnZXRDdHgsIG9yIHRhcmdldFgvWSBwYXJhbWV0ZXJzXG5cdCAqIGNvcnJlY3RseS48L3N0cm9uZz5cblx0ICogQG1ldGhvZCBhcHBseUZpbHRlclxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IFRoZSAyRCBjb250ZXh0IHRvIHVzZSBhcyB0aGUgc291cmNlLlxuXHQgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBwb3NpdGlvbiB0byB1c2UgZm9yIHRoZSBzb3VyY2UgcmVjdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBUaGUgd2lkdGggdG8gdXNlIGZvciB0aGUgc291cmNlIHJlY3QuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgVGhlIGhlaWdodCB0byB1c2UgZm9yIHRoZSBzb3VyY2UgcmVjdC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFt0YXJnZXRDdHhdIE5PVCBTVVBQT1JURUQgSU4gVEhJUyBGSUxURVIuIFRoZSAyRCBjb250ZXh0IHRvIGRyYXcgdGhlIHJlc3VsdCB0by4gRGVmYXVsdHMgdG8gdGhlIGNvbnRleHQgcGFzc2VkIHRvIGN0eC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0YXJnZXRYXSBOT1QgU1VQUE9SVEVEIElOIFRISVMgRklMVEVSLiBUaGUgeCBwb3NpdGlvbiB0byBkcmF3IHRoZSByZXN1bHQgdG8uIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBwYXNzZWQgdG8geC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0YXJnZXRZXSBOT1QgU1VQUE9SVEVEIElOIFRISVMgRklMVEVSLiBUaGUgeSBwb3NpdGlvbiB0byBkcmF3IHRoZSByZXN1bHQgdG8uIERlZmF1bHRzIHRvIHRoZSB2YWx1ZSBwYXNzZWQgdG8geS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIGZpbHRlciB3YXMgYXBwbGllZCBzdWNjZXNzZnVsbHkuXG5cdCAqKi9cblx0cC5hcHBseUZpbHRlciA9IGZ1bmN0aW9uIChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHRhcmdldEN0eCwgdGFyZ2V0WCwgdGFyZ2V0WSkge1xuXHRcdGlmICghdGhpcy5tYXNrKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0dGFyZ2V0Q3R4ID0gdGFyZ2V0Q3R4IHx8IGN0eDtcblx0XHRpZiAodGFyZ2V0WCA9PSBudWxsKSB7IHRhcmdldFggPSB4OyB9XG5cdFx0aWYgKHRhcmdldFkgPT0gbnVsbCkgeyB0YXJnZXRZID0geTsgfVxuXG5cdFx0dGFyZ2V0Q3R4LnNhdmUoKTtcblx0XHRpZiAoY3R4ICE9IHRhcmdldEN0eCkge1xuXHRcdFx0Ly8gVE9ETzogc3VwcG9ydCB0YXJnZXRDdHggYW5kIHRhcmdldFgvWVxuXHRcdFx0Ly8gY2xlYXJSZWN0LCB0aGVuIGRyYXcgdGhlIGN0eCBpbj9cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR0YXJnZXRDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1pblwiO1xuXHRcdHRhcmdldEN0eC5kcmF3SW1hZ2UodGhpcy5tYXNrLCB0YXJnZXRYLCB0YXJnZXRZKTtcblx0XHR0YXJnZXRDdHgucmVzdG9yZSgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG5ldyBBbHBoYU1hc2tGaWx0ZXIodGhpcy5tYXNrKTtcblx0fTtcblxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltBbHBoYU1hc2tGaWx0ZXJdXCI7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5BbHBoYU1hc2tGaWx0ZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEFscGhhTWFza0ZpbHRlciwgXCJGaWx0ZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQ29sb3JGaWx0ZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIEFwcGxpZXMgYSBjb2xvciB0cmFuc2Zvcm0gdG8gRGlzcGxheU9iamVjdHMuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICogVGhpcyBleGFtcGxlIGRyYXdzIGEgcmVkIGNpcmNsZSwgYW5kIHRoZW4gdHJhbnNmb3JtcyBpdCB0byBCbHVlLiBUaGlzIGlzIGFjY29tcGxpc2hlZCBieSBtdWx0aXBseWluZyBhbGwgdGhlIGNoYW5uZWxzXG5cdCAqIHRvIDAgKGV4Y2VwdCBhbHBoYSwgd2hpY2ggaXMgc2V0IHRvIDEpLCBhbmQgdGhlbiBhZGRpbmcgMjU1IHRvIHRoZSBibHVlIGNoYW5uZWwuXG5cdCAqXG5cdCAqICAgICAgdmFyIHNoYXBlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCkuc2V0KHt4OjEwMCx5OjEwMH0pO1xuXHQgKiAgICAgIHNoYXBlLmdyYXBoaWNzLmJlZ2luRmlsbChcIiNmZjAwMDBcIikuZHJhd0NpcmNsZSgwLDAsNTApO1xuXHQgKlxuXHQgKiAgICAgIHNoYXBlLmZpbHRlcnMgPSBbXG5cdCAqICAgICAgICAgIG5ldyBjcmVhdGVqcy5Db2xvckZpbHRlcigwLDAsMCwxLCAwLDAsMjU1LDApXG5cdCAqICAgICAgXTtcblx0ICogICAgICBzaGFwZS5jYWNoZSgtNTAsIC01MCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhbiBtb3JlIGluZm9ybWF0aW9uIG9uIGFwcGx5aW5nIGZpbHRlcnMuXG5cdCAqIEBjbGFzcyBDb2xvckZpbHRlclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3JlZE11bHRpcGxpZXI9MV0gVGhlIGFtb3VudCB0byBtdWx0aXBseSBhZ2FpbnN0IHRoZSByZWQgY2hhbm5lbC4gVGhpcyBpcyBhIHJhbmdlIGJldHdlZW4gMCBhbmQgMS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtncmVlbk11bHRpcGxpZXI9MV0gVGhlIGFtb3VudCB0byBtdWx0aXBseSBhZ2FpbnN0IHRoZSBncmVlbiBjaGFubmVsLiBUaGlzIGlzIGEgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2JsdWVNdWx0aXBsaWVyPTFdIFRoZSBhbW91bnQgdG8gbXVsdGlwbHkgYWdhaW5zdCB0aGUgYmx1ZSBjaGFubmVsLiBUaGlzIGlzIGEgcmFuZ2UgYmV0d2VlbiAwIGFuZCAxLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2FscGhhTXVsdGlwbGllcj0xXSBUaGUgYW1vdW50IHRvIG11bHRpcGx5IGFnYWluc3QgdGhlIGFscGhhIGNoYW5uZWwuIFRoaXMgaXMgYSByYW5nZSBiZXR3ZWVuIDAgYW5kIDEuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcmVkT2Zmc2V0PTBdIFRoZSBhbW91bnQgdG8gYWRkIHRvIHRoZSByZWQgY2hhbm5lbCBhZnRlciBpdCBoYXMgYmVlbiBtdWx0aXBsaWVkLiBUaGlzIGlzIGEgcmFuZ2Vcblx0ICogYmV0d2VlbiAtMjU1IGFuZCAyNTUuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbZ3JlZW5PZmZzZXQ9MF0gVGhlIGFtb3VudCB0byBhZGQgdG8gdGhlIGdyZWVuIGNoYW5uZWwgYWZ0ZXIgaXQgaGFzIGJlZW4gbXVsdGlwbGllZC4gVGhpcyBpcyBhIHJhbmdlXG5cdCAgKiBiZXR3ZWVuIC0yNTUgYW5kIDI1NS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtibHVlT2Zmc2V0PTBdIFRoZSBhbW91bnQgdG8gYWRkIHRvIHRoZSBibHVlIGNoYW5uZWwgYWZ0ZXIgaXQgaGFzIGJlZW4gbXVsdGlwbGllZC4gVGhpcyBpcyBhIHJhbmdlXG5cdCAgKiBiZXR3ZWVuIC0yNTUgYW5kIDI1NS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthbHBoYU9mZnNldD0wXSBUaGUgYW1vdW50IHRvIGFkZCB0byB0aGUgYWxwaGEgY2hhbm5lbCBhZnRlciBpdCBoYXMgYmVlbiBtdWx0aXBsaWVkLiBUaGlzIGlzIGEgcmFuZ2Vcblx0ICAqIGJldHdlZW4gLTI1NSBhbmQgMjU1LlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQGV4dGVuZHMgRmlsdGVyXG5cdCAqKi9cblx0ZnVuY3Rpb24gQ29sb3JGaWx0ZXIocmVkTXVsdGlwbGllciwgZ3JlZW5NdWx0aXBsaWVyLCBibHVlTXVsdGlwbGllciwgYWxwaGFNdWx0aXBsaWVyLCByZWRPZmZzZXQsIGdyZWVuT2Zmc2V0LCBibHVlT2Zmc2V0LCBhbHBoYU9mZnNldCkge1xuXHRcdFxuXHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogUmVkIGNoYW5uZWwgbXVsdGlwbGllci5cblx0XHQgKiBAcHJvcGVydHkgcmVkTXVsdGlwbGllclxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLnJlZE11bHRpcGxpZXIgPSByZWRNdWx0aXBsaWVyICE9IG51bGwgPyByZWRNdWx0aXBsaWVyIDogMTtcblx0XG5cdFx0LyoqXG5cdFx0ICogR3JlZW4gY2hhbm5lbCBtdWx0aXBsaWVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBncmVlbk11bHRpcGxpZXJcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5ncmVlbk11bHRpcGxpZXIgPSBncmVlbk11bHRpcGxpZXIgIT0gbnVsbCA/IGdyZWVuTXVsdGlwbGllciA6IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEJsdWUgY2hhbm5lbCBtdWx0aXBsaWVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBibHVlTXVsdGlwbGllclxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmJsdWVNdWx0aXBsaWVyID0gYmx1ZU11bHRpcGxpZXIgIT0gbnVsbCA/IGJsdWVNdWx0aXBsaWVyIDogMTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQWxwaGEgY2hhbm5lbCBtdWx0aXBsaWVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBhbHBoYU11bHRpcGxpZXJcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5hbHBoYU11bHRpcGxpZXIgPSBhbHBoYU11bHRpcGxpZXIgIT0gbnVsbCA/IGFscGhhTXVsdGlwbGllciA6IDE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFJlZCBjaGFubmVsIG9mZnNldCAoYWRkZWQgdG8gdmFsdWUpLlxuXHRcdCAqIEBwcm9wZXJ0eSByZWRPZmZzZXRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5yZWRPZmZzZXQgPSByZWRPZmZzZXQgfHwgMDtcblx0XG5cdFx0LyoqXG5cdFx0ICogR3JlZW4gY2hhbm5lbCBvZmZzZXQgKGFkZGVkIHRvIHZhbHVlKS5cblx0XHQgKiBAcHJvcGVydHkgZ3JlZW5PZmZzZXRcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiovXG5cdFx0dGhpcy5ncmVlbk9mZnNldCA9IGdyZWVuT2Zmc2V0IHx8IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEJsdWUgY2hhbm5lbCBvZmZzZXQgKGFkZGVkIHRvIHZhbHVlKS5cblx0XHQgKiBAcHJvcGVydHkgYmx1ZU9mZnNldFxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqKi9cblx0XHR0aGlzLmJsdWVPZmZzZXQgPSBibHVlT2Zmc2V0IHx8IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEFscGhhIGNoYW5uZWwgb2Zmc2V0IChhZGRlZCB0byB2YWx1ZSkuXG5cdFx0ICogQHByb3BlcnR5IGFscGhhT2Zmc2V0XG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICoqL1xuXHRcdHRoaXMuYWxwaGFPZmZzZXQgPSBhbHBoYU9mZnNldCB8fCAwO1xuXHR9XG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKENvbG9yRmlsdGVyLCBjcmVhdGVqcy5GaWx0ZXIpO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0NvbG9yRmlsdGVyXVwiO1xuXHR9O1xuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yRmlsdGVyKHRoaXMucmVkTXVsdGlwbGllciwgdGhpcy5ncmVlbk11bHRpcGxpZXIsIHRoaXMuYmx1ZU11bHRpcGxpZXIsIHRoaXMuYWxwaGFNdWx0aXBsaWVyLCB0aGlzLnJlZE9mZnNldCwgdGhpcy5ncmVlbk9mZnNldCwgdGhpcy5ibHVlT2Zmc2V0LCB0aGlzLmFscGhhT2Zmc2V0KTtcblx0fTtcblx0XG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqIGRvY2NlZCBpbiBzdXBlciBjbGFzcyAqKi9cblx0cC5fYXBwbHlGaWx0ZXIgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcblx0XHR2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuXHRcdHZhciBsID0gZGF0YS5sZW5ndGg7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPGw7IGkrPTQpIHtcblx0XHRcdGRhdGFbaV0gPSBkYXRhW2ldKnRoaXMucmVkTXVsdGlwbGllcit0aGlzLnJlZE9mZnNldDtcblx0XHRcdGRhdGFbaSsxXSA9IGRhdGFbaSsxXSp0aGlzLmdyZWVuTXVsdGlwbGllcit0aGlzLmdyZWVuT2Zmc2V0O1xuXHRcdFx0ZGF0YVtpKzJdID0gZGF0YVtpKzJdKnRoaXMuYmx1ZU11bHRpcGxpZXIrdGhpcy5ibHVlT2Zmc2V0O1xuXHRcdFx0ZGF0YVtpKzNdID0gZGF0YVtpKzNdKnRoaXMuYWxwaGFNdWx0aXBsaWVyK3RoaXMuYWxwaGFPZmZzZXQ7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0Y3JlYXRlanMuQ29sb3JGaWx0ZXIgPSBjcmVhdGVqcy5wcm9tb3RlKENvbG9yRmlsdGVyLCBcIkZpbHRlclwiKTtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBDb2xvck1hdHJpeC5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cbi8vIGNvbnN0cnVjdG9yOlxuXHQvKipcblx0ICogUHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyBmb3IgYXNzZW1ibGluZyBhIG1hdHJpeCBmb3IgdXNlIHdpdGggdGhlIHt7I2Nyb3NzTGluayBcIkNvbG9yTWF0cml4RmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBNb3N0IG1ldGhvZHMgcmV0dXJuIHRoZSBpbnN0YW5jZSB0byBmYWNpbGl0YXRlIGNoYWluZWQgY2FsbHMuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBteUNvbG9yTWF0cml4LmFkanVzdEh1ZSgyMCkuYWRqdXN0QnJpZ2h0bmVzcyg1MCk7XG5cdCAqXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJGaWx0ZXJcIn19e3svY3Jvc3NMaW5rfX0gZm9yIGFuIGV4YW1wbGUgb2YgaG93IHRvIGFwcGx5IGZpbHRlcnMsIG9yIHt7I2Nyb3NzTGluayBcIkNvbG9yTWF0cml4RmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBhbiBleGFtcGxlIG9mIGhvdyB0byB1c2UgQ29sb3JNYXRyaXggdG8gY2hhbmdlIGEgRGlzcGxheU9iamVjdCdzIGNvbG9yLlxuXHQgKiBAY2xhc3MgQ29sb3JNYXRyaXhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGJyaWdodG5lc3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvbnRyYXN0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzYXR1cmF0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBodWVcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqKi9cblx0ZnVuY3Rpb24gQ29sb3JNYXRyaXgoYnJpZ2h0bmVzcywgY29udHJhc3QsIHNhdHVyYXRpb24sIGh1ZSkge1xuXHRcdHRoaXMuc2V0Q29sb3IoYnJpZ2h0bmVzcywgY29udHJhc3QsIHNhdHVyYXRpb24sIGh1ZSk7XG5cdH1cblx0dmFyIHAgPSBDb2xvck1hdHJpeC5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXG5cbi8vIGNvbnN0YW50czpcblx0LyoqXG5cdCAqIEFycmF5IG9mIGRlbHRhIHZhbHVlcyBmb3IgY29udHJhc3QgY2FsY3VsYXRpb25zLlxuXHQgKiBAcHJvcGVydHkgREVMVEFfSU5ERVhcblx0ICogQHR5cGUgQXJyYXlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0Q29sb3JNYXRyaXguREVMVEFfSU5ERVggPSBbXG5cdFx0MCwgICAgMC4wMSwgMC4wMiwgMC4wNCwgMC4wNSwgMC4wNiwgMC4wNywgMC4wOCwgMC4xLCAgMC4xMSxcblx0XHQwLjEyLCAwLjE0LCAwLjE1LCAwLjE2LCAwLjE3LCAwLjE4LCAwLjIwLCAwLjIxLCAwLjIyLCAwLjI0LFxuXHRcdDAuMjUsIDAuMjcsIDAuMjgsIDAuMzAsIDAuMzIsIDAuMzQsIDAuMzYsIDAuMzgsIDAuNDAsIDAuNDIsXG5cdFx0MC40NCwgMC40NiwgMC40OCwgMC41LCAgMC41MywgMC41NiwgMC41OSwgMC42MiwgMC42NSwgMC42OCxcblx0XHQwLjcxLCAwLjc0LCAwLjc3LCAwLjgwLCAwLjgzLCAwLjg2LCAwLjg5LCAwLjkyLCAwLjk1LCAwLjk4LFxuXHRcdDEuMCwgIDEuMDYsIDEuMTIsIDEuMTgsIDEuMjQsIDEuMzAsIDEuMzYsIDEuNDIsIDEuNDgsIDEuNTQsXG5cdFx0MS42MCwgMS42NiwgMS43MiwgMS43OCwgMS44NCwgMS45MCwgMS45NiwgMi4wLCAgMi4xMiwgMi4yNSxcblx0XHQyLjM3LCAyLjUwLCAyLjYyLCAyLjc1LCAyLjg3LCAzLjAsICAzLjIsICAzLjQsICAzLjYsICAzLjgsXG5cdFx0NC4wLCAgNC4zLCAgNC43LCAgNC45LCAgNS4wLCAgNS41LCAgNi4wLCAgNi41LCAgNi44LCAgNy4wLFxuXHRcdDcuMywgIDcuNSwgIDcuOCwgIDguMCwgIDguNCwgIDguNywgIDkuMCwgIDkuNCwgIDkuNiwgIDkuOCxcblx0XHQxMC4wXG5cdF07XG5cblx0LyoqXG5cdCAqIElkZW50aXR5IG1hdHJpeCB2YWx1ZXMuXG5cdCAqIEBwcm9wZXJ0eSBJREVOVElUWV9NQVRSSVhcblx0ICogQHR5cGUgQXJyYXlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0Q29sb3JNYXRyaXguSURFTlRJVFlfTUFUUklYID0gW1xuXHRcdDEsMCwwLDAsMCxcblx0XHQwLDEsMCwwLDAsXG5cdFx0MCwwLDEsMCwwLFxuXHRcdDAsMCwwLDEsMCxcblx0XHQwLDAsMCwwLDFcblx0XTtcblxuXHQvKipcblx0ICogVGhlIGNvbnN0YW50IGxlbmd0aCBvZiBhIGNvbG9yIG1hdHJpeC5cblx0ICogQHByb3BlcnR5IExFTkdUSFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0Q29sb3JNYXRyaXguTEVOR1RIID0gQ29sb3JNYXRyaXguSURFTlRJVFlfTUFUUklYLmxlbmd0aDtcblxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFJlc2V0cyB0aGUgaW5zdGFuY2Ugd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlcy5cblx0ICogQG1ldGhvZCBzZXRDb2xvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gYnJpZ2h0bmVzc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gY29udHJhc3Rcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNhdHVyYXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IGh1ZVxuXHQgKiBAcmV0dXJuIHtDb2xvck1hdHJpeH0gVGhlIENvbG9yTWF0cml4IGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKi9cblx0cC5zZXRDb2xvciA9IGZ1bmN0aW9uKGJyaWdodG5lc3MsY29udHJhc3Qsc2F0dXJhdGlvbixodWUpIHtcblx0XHRyZXR1cm4gdGhpcy5yZXNldCgpLmFkanVzdENvbG9yKGJyaWdodG5lc3MsY29udHJhc3Qsc2F0dXJhdGlvbixodWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXNldHMgdGhlIG1hdHJpeCB0byBpZGVudGl0eSB2YWx1ZXMuXG5cdCAqIEBtZXRob2QgcmVzZXRcblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICovXG5cdHAucmVzZXQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jb3B5KENvbG9yTWF0cml4LklERU5USVRZX01BVFJJWCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IG1ldGhvZCB0byBhZGp1c3QgYnJpZ2h0bmVzcywgY29udHJhc3QsIHNhdHVyYXRpb24gYW5kIGh1ZS5cblx0ICogRXF1aXZhbGVudCB0byBjYWxsaW5nIGFkanVzdEh1ZShodWUpLCBhZGp1c3RDb250cmFzdChjb250cmFzdCksXG5cdCAqIGFkanVzdEJyaWdodG5lc3MoYnJpZ2h0bmVzcyksIGFkanVzdFNhdHVyYXRpb24oc2F0dXJhdGlvbiksIGluIHRoYXQgb3JkZXIuXG5cdCAqIEBtZXRob2QgYWRqdXN0Q29sb3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGJyaWdodG5lc3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvbnRyYXN0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzYXR1cmF0aW9uXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBodWVcblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmFkanVzdENvbG9yID0gZnVuY3Rpb24oYnJpZ2h0bmVzcyxjb250cmFzdCxzYXR1cmF0aW9uLGh1ZSkge1xuXHRcdHRoaXMuYWRqdXN0SHVlKGh1ZSk7XG5cdFx0dGhpcy5hZGp1c3RDb250cmFzdChjb250cmFzdCk7XG5cdFx0dGhpcy5hZGp1c3RCcmlnaHRuZXNzKGJyaWdodG5lc3MpO1xuXHRcdHJldHVybiB0aGlzLmFkanVzdFNhdHVyYXRpb24oc2F0dXJhdGlvbik7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkanVzdHMgdGhlIGJyaWdodG5lc3Mgb2YgcGl4ZWwgY29sb3IgYnkgYWRkaW5nIHRoZSBzcGVjaWZpZWQgdmFsdWUgdG8gdGhlIHJlZCwgZ3JlZW4gYW5kIGJsdWUgY2hhbm5lbHMuXG5cdCAqIFBvc2l0aXZlIHZhbHVlcyB3aWxsIG1ha2UgdGhlIGltYWdlIGJyaWdodGVyLCBuZWdhdGl2ZSB2YWx1ZXMgd2lsbCBtYWtlIGl0IGRhcmtlci5cblx0ICogQG1ldGhvZCBhZGp1c3RCcmlnaHRuZXNzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBBIHZhbHVlIGJldHdlZW4gLTI1NSAmIDI1NSB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIFJHQiBjaGFubmVscy5cblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmFkanVzdEJyaWdodG5lc3MgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PSAwIHx8IGlzTmFOKHZhbHVlKSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHZhbHVlID0gdGhpcy5fY2xlYW5WYWx1ZSh2YWx1ZSwyNTUpO1xuXHRcdHRoaXMuX211bHRpcGx5TWF0cml4KFtcblx0XHRcdDEsMCwwLDAsdmFsdWUsXG5cdFx0XHQwLDEsMCwwLHZhbHVlLFxuXHRcdFx0MCwwLDEsMCx2YWx1ZSxcblx0XHRcdDAsMCwwLDEsMCxcblx0XHRcdDAsMCwwLDAsMVxuXHRcdF0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGp1c3RzIHRoZSBjb250cmFzdCBvZiBwaXhlbCBjb2xvci5cblx0ICogUG9zaXRpdmUgdmFsdWVzIHdpbGwgaW5jcmVhc2UgY29udHJhc3QsIG5lZ2F0aXZlIHZhbHVlcyB3aWxsIGRlY3JlYXNlIGNvbnRyYXN0LlxuXHQgKiBAbWV0aG9kIGFkanVzdENvbnRyYXN0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBBIHZhbHVlIGJldHdlZW4gLTEwMCAmIDEwMC5cblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IFRoZSBDb2xvck1hdHJpeCBpbnN0YW5jZSB0aGUgbWV0aG9kIGlzIGNhbGxlZCBvbiAodXNlZnVsIGZvciBjaGFpbmluZyBjYWxscy4pXG5cdCAqIEBjaGFpbmFibGVcblx0ICoqL1xuXHRwLmFkanVzdENvbnRyYXN0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT0gMCB8fCBpc05hTih2YWx1ZSkpIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR2YWx1ZSA9IHRoaXMuX2NsZWFuVmFsdWUodmFsdWUsMTAwKTtcblx0XHR2YXIgeDtcblx0XHRpZiAodmFsdWU8MCkge1xuXHRcdFx0eCA9IDEyNyt2YWx1ZS8xMDAqMTI3O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0gdmFsdWUlMTtcblx0XHRcdGlmICh4ID09IDApIHtcblx0XHRcdFx0eCA9IENvbG9yTWF0cml4LkRFTFRBX0lOREVYW3ZhbHVlXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHggPSBDb2xvck1hdHJpeC5ERUxUQV9JTkRFWFsodmFsdWU8PDApXSooMS14KStDb2xvck1hdHJpeC5ERUxUQV9JTkRFWFsodmFsdWU8PDApKzFdKng7IC8vIHVzZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBmb3IgbW9yZSBncmFudWxhcml0eS5cblx0XHRcdH1cblx0XHRcdHggPSB4KjEyNysxMjc7XG5cdFx0fVxuXHRcdHRoaXMuX211bHRpcGx5TWF0cml4KFtcblx0XHRcdHgvMTI3LDAsMCwwLDAuNSooMTI3LXgpLFxuXHRcdFx0MCx4LzEyNywwLDAsMC41KigxMjcteCksXG5cdFx0XHQwLDAseC8xMjcsMCwwLjUqKDEyNy14KSxcblx0XHRcdDAsMCwwLDEsMCxcblx0XHRcdDAsMCwwLDAsMVxuXHRcdF0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGp1c3RzIHRoZSBjb2xvciBzYXR1cmF0aW9uIG9mIHRoZSBwaXhlbC5cblx0ICogUG9zaXRpdmUgdmFsdWVzIHdpbGwgaW5jcmVhc2Ugc2F0dXJhdGlvbiwgbmVnYXRpdmUgdmFsdWVzIHdpbGwgZGVjcmVhc2Ugc2F0dXJhdGlvbiAodHJlbmQgdG93YXJkcyBncmV5c2NhbGUpLlxuXHQgKiBAbWV0aG9kIGFkanVzdFNhdHVyYXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIEEgdmFsdWUgYmV0d2VlbiAtMTAwICYgMTAwLlxuXHQgKiBAcmV0dXJuIHtDb2xvck1hdHJpeH0gVGhlIENvbG9yTWF0cml4IGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuYWRqdXN0U2F0dXJhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHZhbHVlID09IDAgfHwgaXNOYU4odmFsdWUpKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dmFsdWUgPSB0aGlzLl9jbGVhblZhbHVlKHZhbHVlLDEwMCk7XG5cdFx0dmFyIHggPSAxKygodmFsdWUgPiAwKSA/IDMqdmFsdWUvMTAwIDogdmFsdWUvMTAwKTtcblx0XHR2YXIgbHVtUiA9IDAuMzA4Njtcblx0XHR2YXIgbHVtRyA9IDAuNjA5NDtcblx0XHR2YXIgbHVtQiA9IDAuMDgyMDtcblx0XHR0aGlzLl9tdWx0aXBseU1hdHJpeChbXG5cdFx0XHRsdW1SKigxLXgpK3gsbHVtRyooMS14KSxsdW1CKigxLXgpLDAsMCxcblx0XHRcdGx1bVIqKDEteCksbHVtRyooMS14KSt4LGx1bUIqKDEteCksMCwwLFxuXHRcdFx0bHVtUiooMS14KSxsdW1HKigxLXgpLGx1bUIqKDEteCkreCwwLDAsXG5cdFx0XHQwLDAsMCwxLDAsXG5cdFx0XHQwLDAsMCwwLDFcblx0XHRdKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBBZGp1c3RzIHRoZSBodWUgb2YgdGhlIHBpeGVsIGNvbG9yLlxuXHQgKiBAbWV0aG9kIGFkanVzdEh1ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgQSB2YWx1ZSBiZXR3ZWVuIC0xODAgJiAxODAuXG5cdCAqIEByZXR1cm4ge0NvbG9yTWF0cml4fSBUaGUgQ29sb3JNYXRyaXggaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQgKiBAY2hhaW5hYmxlXG5cdCAqKi9cblx0cC5hZGp1c3RIdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PSAwIHx8IGlzTmFOKHZhbHVlKSkgeyByZXR1cm4gdGhpczsgfVxuXHRcdHZhbHVlID0gdGhpcy5fY2xlYW5WYWx1ZSh2YWx1ZSwxODApLzE4MCpNYXRoLlBJO1xuXHRcdHZhciBjb3NWYWwgPSBNYXRoLmNvcyh2YWx1ZSk7XG5cdFx0dmFyIHNpblZhbCA9IE1hdGguc2luKHZhbHVlKTtcblx0XHR2YXIgbHVtUiA9IDAuMjEzO1xuXHRcdHZhciBsdW1HID0gMC43MTU7XG5cdFx0dmFyIGx1bUIgPSAwLjA3Mjtcblx0XHR0aGlzLl9tdWx0aXBseU1hdHJpeChbXG5cdFx0XHRsdW1SK2Nvc1ZhbCooMS1sdW1SKStzaW5WYWwqKC1sdW1SKSxsdW1HK2Nvc1ZhbCooLWx1bUcpK3NpblZhbCooLWx1bUcpLGx1bUIrY29zVmFsKigtbHVtQikrc2luVmFsKigxLWx1bUIpLDAsMCxcblx0XHRcdGx1bVIrY29zVmFsKigtbHVtUikrc2luVmFsKigwLjE0MyksbHVtRytjb3NWYWwqKDEtbHVtRykrc2luVmFsKigwLjE0MCksbHVtQitjb3NWYWwqKC1sdW1CKStzaW5WYWwqKC0wLjI4MyksMCwwLFxuXHRcdFx0bHVtUitjb3NWYWwqKC1sdW1SKStzaW5WYWwqKC0oMS1sdW1SKSksbHVtRytjb3NWYWwqKC1sdW1HKStzaW5WYWwqKGx1bUcpLGx1bUIrY29zVmFsKigxLWx1bUIpK3NpblZhbCoobHVtQiksMCwwLFxuXHRcdFx0MCwwLDAsMSwwLFxuXHRcdFx0MCwwLDAsMCwxXG5cdFx0XSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIENvbmNhdGVuYXRlcyAobXVsdGlwbGllcykgdGhlIHNwZWNpZmllZCBtYXRyaXggd2l0aCB0aGlzIG9uZS5cblx0ICogQG1ldGhvZCBjb25jYXRcblx0ICogQHBhcmFtIHtBcnJheX0gbWF0cml4IEFuIGFycmF5IG9yIENvbG9yTWF0cml4IGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtDb2xvck1hdHJpeH0gVGhlIENvbG9yTWF0cml4IGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuY29uY2F0ID0gZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0bWF0cml4ID0gdGhpcy5fZml4TWF0cml4KG1hdHJpeCk7XG5cdFx0aWYgKG1hdHJpeC5sZW5ndGggIT0gQ29sb3JNYXRyaXguTEVOR1RIKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fbXVsdGlwbHlNYXRyaXgobWF0cml4KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgQ29sb3JNYXRyaXguXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7Q29sb3JNYXRyaXh9IEEgY2xvbmUgb2YgdGhpcyBDb2xvck1hdHJpeC5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIChuZXcgQ29sb3JNYXRyaXgoKSkuY29weSh0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJuIGEgbGVuZ3RoIDI1ICg1eDUpIGFycmF5IGluc3RhbmNlIGNvbnRhaW5pbmcgdGhpcyBtYXRyaXgncyB2YWx1ZXMuXG5cdCAqIEBtZXRob2QgdG9BcnJheVxuXHQgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgaG9sZGluZyB0aGlzIG1hdHJpeCdzIHZhbHVlcy5cblx0ICoqL1xuXHRwLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJyID0gW107XG5cdFx0Zm9yICh2YXIgaT0gMCwgbD1Db2xvck1hdHJpeC5MRU5HVEg7IGk8bDsgaSsrKSB7XG5cdFx0XHRhcnJbaV0gPSB0aGlzW2ldO1xuXHRcdH1cblx0XHRyZXR1cm4gYXJyO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb3B5IHRoZSBzcGVjaWZpZWQgbWF0cml4J3MgdmFsdWVzIHRvIHRoaXMgbWF0cml4LlxuXHQgKiBAbWV0aG9kIGNvcHlcblx0ICogQHBhcmFtIHtBcnJheX0gbWF0cml4IEFuIGFycmF5IG9yIENvbG9yTWF0cml4IGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtDb2xvck1hdHJpeH0gVGhlIENvbG9yTWF0cml4IGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQgKiovXG5cdHAuY29weSA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHZhciBsID0gQ29sb3JNYXRyaXguTEVOR1RIO1xuXHRcdGZvciAodmFyIGk9MDtpPGw7aSsrKSB7XG5cdFx0XHR0aGlzW2ldID0gbWF0cml4W2ldO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQgKiBAbWV0aG9kIHRvU3RyaW5nXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxuXHQgKiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbQ29sb3JNYXRyaXhdXCI7XG5cdH07XG5cblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfbXVsdGlwbHlNYXRyaXhcblx0ICogQHBhcmFtIHtBcnJheX0gbWF0cml4XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRwLl9tdWx0aXBseU1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHZhciBpLCBqLCBrLCBjb2wgPSBbXTtcblxuXHRcdGZvciAoaT0wO2k8NTtpKyspIHtcblx0XHRcdGZvciAoaj0wO2o8NTtqKyspIHtcblx0XHRcdFx0Y29sW2pdID0gdGhpc1tqK2kqNV07XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGo9MDtqPDU7aisrKSB7XG5cdFx0XHRcdHZhciB2YWw9MDtcblx0XHRcdFx0Zm9yIChrPTA7azw1O2srKykge1xuXHRcdFx0XHRcdHZhbCArPSBtYXRyaXhbaitrKjVdKmNvbFtrXTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzW2oraSo1XSA9IHZhbDtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIE1ha2Ugc3VyZSB2YWx1ZXMgYXJlIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHJhbmdlLCBodWUgaGFzIGEgbGltaXQgb2YgMTgwLCBicmlnaHRuZXNzIGlzIDI1NSwgb3RoZXJzIGFyZSAxMDAuXG5cdCAqIEBtZXRob2QgX2NsZWFuVmFsdWVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSByYXcgbnVtYmVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdCBUaGUgbWF4aW11bSB0aGF0IHRoZSBudW1iZXIgY2FuIGJlLiBUaGUgbWluaW11bSBpcyB0aGUgbGltaXQgKiAtMS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2NsZWFuVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgbGltaXQpIHtcblx0XHRyZXR1cm4gTWF0aC5taW4obGltaXQsTWF0aC5tYXgoLWxpbWl0LHZhbHVlKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIE1ha2VzIHN1cmUgbWF0cml4ZXMgYXJlIDV4NSAoMjUgbG9uZykuXG5cdCAqIEBtZXRob2QgX2ZpeE1hdHJpeFxuXHQgKiBAcGFyYW0ge0FycmF5fSBtYXRyaXhcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2ZpeE1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdGlmIChtYXRyaXggaW5zdGFuY2VvZiBDb2xvck1hdHJpeCkgeyBtYXRyaXggPSBtYXRyaXgudG9BcnJheSgpOyB9XG5cdFx0aWYgKG1hdHJpeC5sZW5ndGggPCBDb2xvck1hdHJpeC5MRU5HVEgpIHtcblx0XHRcdG1hdHJpeCA9IG1hdHJpeC5zbGljZSgwLG1hdHJpeC5sZW5ndGgpLmNvbmNhdChDb2xvck1hdHJpeC5JREVOVElUWV9NQVRSSVguc2xpY2UobWF0cml4Lmxlbmd0aCxDb2xvck1hdHJpeC5MRU5HVEgpKTtcblx0XHR9IGVsc2UgaWYgKG1hdHJpeC5sZW5ndGggPiBDb2xvck1hdHJpeC5MRU5HVEgpIHtcblx0XHRcdG1hdHJpeCA9IG1hdHJpeC5zbGljZSgwLENvbG9yTWF0cml4LkxFTkdUSCk7XG5cdFx0fVxuXHRcdHJldHVybiBtYXRyaXg7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5Db2xvck1hdHJpeCA9IENvbG9yTWF0cml4O1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIENvbG9yTWF0cml4RmlsdGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBBbGxvd3MgeW91IHRvIGNhcnJ5IG91dCBjb21wbGV4IGNvbG9yIG9wZXJhdGlvbnMgc3VjaCBhcyBtb2RpZnlpbmcgc2F0dXJhdGlvbiwgYnJpZ2h0bmVzcywgb3IgaW52ZXJ0aW5nLiBTZWUgdGhlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkNvbG9yTWF0cml4XCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGNoYW5naW5nIGNvbG9ycy4gRm9yIGFuIGVhc2llciBjb2xvciB0cmFuc2Zvcm0sXG5cdCAqIGNvbnNpZGVyIHRoZSB7eyNjcm9zc0xpbmsgXCJDb2xvckZpbHRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKiBUaGlzIGV4YW1wbGUgY3JlYXRlcyBhIHJlZCBjaXJjbGUsIGludmVydHMgaXRzIGh1ZSwgYW5kIHRoZW4gc2F0dXJhdGVzIGl0IHRvIGJyaWdodGVuIGl0IHVwLlxuXHQgKlxuXHQgKiAgICAgIHZhciBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpLnNldCh7eDoxMDAseToxMDB9KTtcblx0ICogICAgICBzaGFwZS5ncmFwaGljcy5iZWdpbkZpbGwoXCIjZmYwMDAwXCIpLmRyYXdDaXJjbGUoMCwwLDUwKTtcblx0ICpcblx0ICogICAgICB2YXIgbWF0cml4ID0gbmV3IGNyZWF0ZWpzLkNvbG9yTWF0cml4KCkuYWRqdXN0SHVlKDE4MCkuYWRqdXN0U2F0dXJhdGlvbigxMDApO1xuXHQgKiAgICAgIHNoYXBlLmZpbHRlcnMgPSBbXG5cdCAqICAgICAgICAgIG5ldyBjcmVhdGVqcy5Db2xvck1hdHJpeEZpbHRlcihtYXRyaXgpXG5cdCAqICAgICAgXTtcblx0ICpcblx0ICogICAgICBzaGFwZS5jYWNoZSgtNTAsIC01MCwgMTAwLCAxMDApO1xuXHQgKlxuXHQgKiBTZWUge3sjY3Jvc3NMaW5rIFwiRmlsdGVyXCJ9fXt7L2Nyb3NzTGlua319IGZvciBhbiBtb3JlIGluZm9ybWF0aW9uIG9uIGFwcGx5aW5nIGZpbHRlcnMuXG5cdCAqIEBjbGFzcyBDb2xvck1hdHJpeEZpbHRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQGV4dGVuZHMgRmlsdGVyXG5cdCAqIEBwYXJhbSB7QXJyYXkgfCBDb2xvck1hdHJpeH0gbWF0cml4IEEgNHg1IG1hdHJpeCBkZXNjcmliaW5nIHRoZSBjb2xvciBvcGVyYXRpb24gdG8gcGVyZm9ybS4gU2VlIGFsc28gdGhlIHt7I2Nyb3NzTGluayBcIkNvbG9yTWF0cml4XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGNsYXNzLlxuXHQgKiovXG5cdGZ1bmN0aW9uIENvbG9yTWF0cml4RmlsdGVyKG1hdHJpeCkge1xuXHRcblx0XHRcblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQSA0eDUgbWF0cml4IGRlc2NyaWJpbmcgdGhlIGNvbG9yIG9wZXJhdGlvbiB0byBwZXJmb3JtLiBTZWUgYWxzbyB0aGUge3sjY3Jvc3NMaW5rIFwiQ29sb3JNYXRyaXhcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBAcHJvcGVydHkgbWF0cml4XG5cdFx0ICogQHR5cGUgQXJyYXkgfCBDb2xvck1hdHJpeFxuXHRcdCAqKi9cblx0XHR0aGlzLm1hdHJpeCA9IG1hdHJpeDtcblx0fVxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChDb2xvck1hdHJpeEZpbHRlciwgY3JlYXRlanMuRmlsdGVyKTtcblxuXHQvLyBUT0RPOiBkZXByZWNhdGVkXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLiBSRU1PVkVELiBTZWUgZG9jcyBmb3IgZGV0YWlscy5cblx0XG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0NvbG9yTWF0cml4RmlsdGVyXVwiO1xuXHR9O1xuXG5cdC8qKiBkb2NjZWQgaW4gc3VwZXIgY2xhc3MgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yTWF0cml4RmlsdGVyKHRoaXMubWF0cml4KTtcblx0fTtcblxuLy8gcHJpdmF0ZSBtZXRob2RzOlxuXHQvKiogZG9jY2VkIGluIHN1cGVyIGNsYXNzICoqL1xuXHRwLl9hcHBseUZpbHRlciA9IGZ1bmN0aW9uKGltYWdlRGF0YSkgeyBcblx0XHR2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuXHRcdHZhciBsID0gZGF0YS5sZW5ndGg7XG5cdFx0dmFyIHIsZyxiLGE7XG5cdFx0dmFyIG10eCA9IHRoaXMubWF0cml4O1xuXHRcdHZhciBtMCA9ICBtdHhbMF0sICBtMSA9ICBtdHhbMV0sICBtMiA9ICBtdHhbMl0sICBtMyA9ICBtdHhbM10sICBtNCA9ICBtdHhbNF07XG5cdFx0dmFyIG01ID0gIG10eFs1XSwgIG02ID0gIG10eFs2XSwgIG03ID0gIG10eFs3XSwgIG04ID0gIG10eFs4XSwgIG05ID0gIG10eFs5XTtcblx0XHR2YXIgbTEwID0gbXR4WzEwXSwgbTExID0gbXR4WzExXSwgbTEyID0gbXR4WzEyXSwgbTEzID0gbXR4WzEzXSwgbTE0ID0gbXR4WzE0XTtcblx0XHR2YXIgbTE1ID0gbXR4WzE1XSwgbTE2ID0gbXR4WzE2XSwgbTE3ID0gbXR4WzE3XSwgbTE4ID0gbXR4WzE4XSwgbTE5ID0gbXR4WzE5XTtcblxuXHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKz00KSB7XG5cdFx0XHRyID0gZGF0YVtpXTtcblx0XHRcdGcgPSBkYXRhW2krMV07XG5cdFx0XHRiID0gZGF0YVtpKzJdO1xuXHRcdFx0YSA9IGRhdGFbaSszXTtcblx0XHRcdGRhdGFbaV0gPSByKm0wK2cqbTErYiptMithKm0zK200OyAvLyByZWRcblx0XHRcdGRhdGFbaSsxXSA9IHIqbTUrZyptNitiKm03K2EqbTgrbTk7IC8vIGdyZWVuXG5cdFx0XHRkYXRhW2krMl0gPSByKm0xMCtnKm0xMStiKm0xMithKm0xMyttMTQ7IC8vIGJsdWVcblx0XHRcdGRhdGFbaSszXSA9IHIqbTE1K2cqbTE2K2IqbTE3K2EqbTE4K20xOTsgLy8gYWxwaGFcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5Db2xvck1hdHJpeEZpbHRlciA9IGNyZWF0ZWpzLnByb21vdGUoQ29sb3JNYXRyaXhGaWx0ZXIsIFwiRmlsdGVyXCIpO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFRvdWNoLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuICogR2xvYmFsIHV0aWxpdHkgZm9yIHdvcmtpbmcgd2l0aCBtdWx0aS10b3VjaCBlbmFibGVkIGRldmljZXMgaW4gRWFzZWxKUy4gQ3VycmVudGx5IHN1cHBvcnRzIFczQyBUb3VjaCBBUEkgKGlPUyBhbmRcbiAqIG1vZGVybiBBbmRyb2lkIGJyb3dzZXIpIGFuZCB0aGUgUG9pbnRlciBBUEkgKElFKSwgaW5jbHVkaW5nIG1zLXByZWZpeGVkIGV2ZW50cyBpbiBJRTEwLCBhbmQgdW5wcmVmaXhlZCBpbiBJRTExLlxuICpcbiAqIEVuc3VyZSB0aGF0IHlvdSB7eyNjcm9zc0xpbmsgXCJUb3VjaC9kaXNhYmxlXCJ9fXt7L2Nyb3NzTGlua319IHRvdWNoIHdoZW4gY2xlYW5pbmcgdXAgeW91ciBhcHBsaWNhdGlvbi4gWW91IGRvIG5vdCBoYXZlXG4gKiB0byBjaGVjayBpZiB0b3VjaCBpcyBzdXBwb3J0ZWQgdG8gZW5hYmxlIGl0LCBhcyBpdCB3aWxsIGZhaWwgZ3JhY2VmdWxseSBpZiBpdCBpcyBub3Qgc3VwcG9ydGVkLlxuICpcbiAqIDxoND5FeGFtcGxlPC9oND5cbiAqXG4gKiAgICAgIHZhciBzdGFnZSA9IG5ldyBjcmVhdGVqcy5TdGFnZShcImNhbnZhc0lkXCIpO1xuICogICAgICBjcmVhdGVqcy5Ub3VjaC5lbmFibGUoc3RhZ2UpO1xuICpcbiAqIDxzdHJvbmc+Tm90ZTo8L3N0cm9uZz4gSXQgaXMgaW1wb3J0YW50IHRvIGRpc2FibGUgVG91Y2ggb24gYSBzdGFnZSB0aGF0IHlvdSBhcmUgbm8gbG9uZ2VyIHVzaW5nOlxuICpcbiAqICAgICAgY3JlYXRlanMuVG91Y2guZGlzYWJsZShzdGFnZSk7XG4gKlxuICogQGNsYXNzIFRvdWNoXG4gKiBAc3RhdGljXG4gKiovXG5cdGZ1bmN0aW9uIFRvdWNoKCkge1xuXHRcdHRocm93IFwiVG91Y2ggY2Fubm90IGJlIGluc3RhbnRpYXRlZFwiO1xuXHR9XG5cblxuLy8gcHVibGljIHN0YXRpYyBtZXRob2RzOlxuXHQvKipcblx0ICogUmV0dXJucyBgdHJ1ZWAgaWYgdG91Y2ggaXMgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGJyb3dzZXIuXG5cdCAqIEBtZXRob2QgaXNTdXBwb3J0ZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSW5kaWNhdGVzIHdoZXRoZXIgdG91Y2ggaXMgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGJyb3dzZXIuXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVyblx0ISEoKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgLy8gaU9TICYgQW5kcm9pZFxuXHRcdFx0fHwgKHdpbmRvdy5uYXZpZ2F0b3JbJ21zUG9pbnRlckVuYWJsZWQnXSAmJiB3aW5kb3cubmF2aWdhdG9yWydtc01heFRvdWNoUG9pbnRzJ10gPiAwKSAvLyBJRTEwXG5cdFx0XHR8fCAod2luZG93Lm5hdmlnYXRvclsncG9pbnRlckVuYWJsZWQnXSAmJiB3aW5kb3cubmF2aWdhdG9yWydtYXhUb3VjaFBvaW50cyddID4gMCkpOyAvLyBJRTExK1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbmFibGVzIHRvdWNoIGludGVyYWN0aW9uIGZvciB0aGUgc3BlY2lmaWVkIEVhc2VsSlMge3sjY3Jvc3NMaW5rIFwiU3RhZ2VcIn19e3svY3Jvc3NMaW5rfX0uIEN1cnJlbnRseSBzdXBwb3J0cyBpT1Ncblx0ICogKGFuZCBjb21wYXRpYmxlIGJyb3dzZXJzLCBzdWNoIGFzIG1vZGVybiBBbmRyb2lkIGJyb3dzZXJzKSwgYW5kIElFMTAvMTEuIFN1cHBvcnRzIGJvdGggc2luZ2xlIHRvdWNoIGFuZFxuXHQgKiBtdWx0aS10b3VjaCBtb2Rlcy4gRXh0ZW5kcyB0aGUgRWFzZWxKUyB7eyNjcm9zc0xpbmsgXCJNb3VzZUV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IG1vZGVsLCBidXQgd2l0aG91dCBzdXBwb3J0IGZvclxuXHQgKiBkb3VibGUgY2xpY2sgb3Igb3Zlci9vdXQgZXZlbnRzLiBTZWUgdGhlIE1vdXNlRXZlbnQge3sjY3Jvc3NMaW5rIFwiTW91c2VFdmVudC9wb2ludGVySWQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cdCAqIEBtZXRob2QgZW5hYmxlXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlIFRoZSB7eyNjcm9zc0xpbmsgXCJTdGFnZVwifX17ey9jcm9zc0xpbmt9fSB0byBlbmFibGUgdG91Y2ggb24uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbmdsZVRvdWNoPWZhbHNlXSBJZiBgdHJ1ZWAsIG9ubHkgYSBzaW5nbGUgdG91Y2ggd2lsbCBiZSBhY3RpdmUgYXQgYSB0aW1lLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFthbGxvd0RlZmF1bHQ9ZmFsc2VdIElmIGB0cnVlYCwgdGhlbiBkZWZhdWx0IGdlc3R1cmUgYWN0aW9ucyAoZXguIHNjcm9sbGluZywgem9vbWluZykgd2lsbCBiZVxuXHQgKiBhbGxvd2VkIHdoZW4gdGhlIHVzZXIgaXMgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgdGFyZ2V0IGNhbnZhcy5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdG91Y2ggd2FzIHN1Y2Nlc3NmdWxseSBlbmFibGVkIG9uIHRoZSB0YXJnZXQgc3RhZ2UuXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5lbmFibGUgPSBmdW5jdGlvbihzdGFnZSwgc2luZ2xlVG91Y2gsIGFsbG93RGVmYXVsdCkge1xuXHRcdGlmICghc3RhZ2UgfHwgIXN0YWdlLmNhbnZhcyB8fCAhVG91Y2guaXNTdXBwb3J0ZWQoKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAoc3RhZ2UuX190b3VjaCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0Ly8gaW5qZWN0IHJlcXVpcmVkIHByb3BlcnRpZXMgb24gc3RhZ2U6XG5cdFx0c3RhZ2UuX190b3VjaCA9IHtwb2ludGVyczp7fSwgbXVsdGl0b3VjaDohc2luZ2xlVG91Y2gsIHByZXZlbnREZWZhdWx0OiFhbGxvd0RlZmF1bHQsIGNvdW50OjB9O1xuXG5cdFx0Ly8gbm90ZSB0aGF0IGluIHRoZSBmdXR1cmUgd2UgbWF5IG5lZWQgdG8gZGlzYWJsZSB0aGUgc3RhbmRhcmQgbW91c2UgZXZlbnQgbW9kZWwgYmVmb3JlIGFkZGluZ1xuXHRcdC8vIHRoZXNlIHRvIHByZXZlbnQgZHVwbGljYXRlIGNhbGxzLiBJdCBkb2Vzbid0IHNlZW0gdG8gYmUgYW4gaXNzdWUgd2l0aCBpT1MgZGV2aWNlcyB0aG91Z2guXG5cdFx0aWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgeyBUb3VjaC5fSU9TX2VuYWJsZShzdGFnZSk7IH1cblx0XHRlbHNlIGlmICh3aW5kb3cubmF2aWdhdG9yWydtc1BvaW50ZXJFbmFibGVkJ10gfHwgd2luZG93Lm5hdmlnYXRvcltcInBvaW50ZXJFbmFibGVkXCJdKSB7IFRvdWNoLl9JRV9lbmFibGUoc3RhZ2UpOyB9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyB0aGF0IHdlcmUgc2V0IHVwIHdoZW4gY2FsbGluZyBgVG91Y2guZW5hYmxlKClgIG9uIGEgc3RhZ2UuXG5cdCAqIEBtZXRob2QgZGlzYWJsZVxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZSBUaGUge3sjY3Jvc3NMaW5rIFwiU3RhZ2VcIn19e3svY3Jvc3NMaW5rfX0gdG8gZGlzYWJsZSB0b3VjaCBvbi5cblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRvdWNoLmRpc2FibGUgPSBmdW5jdGlvbihzdGFnZSkge1xuXHRcdGlmICghc3RhZ2UpIHsgcmV0dXJuOyB9XG5cdFx0aWYgKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgeyBUb3VjaC5fSU9TX2Rpc2FibGUoc3RhZ2UpOyB9XG5cdFx0ZWxzZSBpZiAod2luZG93Lm5hdmlnYXRvclsnbXNQb2ludGVyRW5hYmxlZCddIHx8IHdpbmRvdy5uYXZpZ2F0b3JbXCJwb2ludGVyRW5hYmxlZFwiXSkgeyBUb3VjaC5fSUVfZGlzYWJsZShzdGFnZSk7IH1cblx0XHRcblx0XHRkZWxldGUgc3RhZ2UuX190b3VjaDtcblx0fTtcblxuXG4vLyBQcml2YXRlIHN0YXRpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfSU9TX2VuYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5fSU9TX2VuYWJsZSA9IGZ1bmN0aW9uKHN0YWdlKSB7XG5cdFx0dmFyIGNhbnZhcyA9IHN0YWdlLmNhbnZhcztcblx0XHR2YXIgZiA9IHN0YWdlLl9fdG91Y2guZiA9IGZ1bmN0aW9uKGUpIHsgVG91Y2guX0lPU19oYW5kbGVFdmVudChzdGFnZSxlKTsgfTtcblx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgZiwgZmFsc2UpO1xuXHRcdGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGYsIGZhbHNlKTtcblx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGYsIGZhbHNlKTtcblx0XHRjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIGYsIGZhbHNlKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfSU9TX2Rpc2FibGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZVxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guX0lPU19kaXNhYmxlID0gZnVuY3Rpb24oc3RhZ2UpIHtcblx0XHR2YXIgY2FudmFzID0gc3RhZ2UuY2FudmFzO1xuXHRcdGlmICghY2FudmFzKSB7IHJldHVybjsgfVxuXHRcdHZhciBmID0gc3RhZ2UuX190b3VjaC5mO1xuXHRcdGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBmLCBmYWxzZSk7XG5cdFx0Y2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgZiwgZmFsc2UpO1xuXHRcdGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgZiwgZmFsc2UpO1xuXHRcdGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgZiwgZmFsc2UpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9JT1NfaGFuZGxlRXZlbnRcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2Vcblx0ICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5fSU9TX2hhbmRsZUV2ZW50ID0gZnVuY3Rpb24oc3RhZ2UsIGUpIHtcblx0XHRpZiAoIXN0YWdlKSB7IHJldHVybjsgfVxuXHRcdGlmIChzdGFnZS5fX3RvdWNoLnByZXZlbnREZWZhdWx0KSB7IGUucHJldmVudERlZmF1bHQmJmUucHJldmVudERlZmF1bHQoKTsgfVxuXHRcdHZhciB0b3VjaGVzID0gZS5jaGFuZ2VkVG91Y2hlcztcblx0XHR2YXIgdHlwZSA9IGUudHlwZTtcblx0XHRmb3IgKHZhciBpPSAwLGw9dG91Y2hlcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR2YXIgdG91Y2ggPSB0b3VjaGVzW2ldO1xuXHRcdFx0dmFyIGlkID0gdG91Y2guaWRlbnRpZmllcjtcblx0XHRcdGlmICh0b3VjaC50YXJnZXQgIT0gc3RhZ2UuY2FudmFzKSB7IGNvbnRpbnVlOyB9XG5cblx0XHRcdGlmICh0eXBlID09IFwidG91Y2hzdGFydFwiKSB7XG5cdFx0XHRcdHRoaXMuX2hhbmRsZVN0YXJ0KHN0YWdlLCBpZCwgZSwgdG91Y2gucGFnZVgsIHRvdWNoLnBhZ2VZKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PSBcInRvdWNobW92ZVwiKSB7XG5cdFx0XHRcdHRoaXMuX2hhbmRsZU1vdmUoc3RhZ2UsIGlkLCBlLCB0b3VjaC5wYWdlWCwgdG91Y2gucGFnZVkpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09IFwidG91Y2hlbmRcIiB8fCB0eXBlID09IFwidG91Y2hjYW5jZWxcIikge1xuXHRcdFx0XHR0aGlzLl9oYW5kbGVFbmQoc3RhZ2UsIGlkLCBlKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX0lFX2VuYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUb3VjaC5fSUVfZW5hYmxlID0gZnVuY3Rpb24oc3RhZ2UpIHtcblx0XHR2YXIgY2FudmFzID0gc3RhZ2UuY2FudmFzO1xuXHRcdHZhciBmID0gc3RhZ2UuX190b3VjaC5mID0gZnVuY3Rpb24oZSkgeyBUb3VjaC5fSUVfaGFuZGxlRXZlbnQoc3RhZ2UsZSk7IH07XG5cblx0XHRpZiAod2luZG93Lm5hdmlnYXRvcltcInBvaW50ZXJFbmFibGVkXCJdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyRG93blwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlck1vdmVcIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJVcFwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlckNhbmNlbFwiLCBmLCBmYWxzZSk7XG5cdFx0XHRpZiAoc3RhZ2UuX190b3VjaC5wcmV2ZW50RGVmYXVsdCkgeyBjYW52YXMuc3R5bGUubXNUb3VjaEFjdGlvbiA9IFwibm9uZVwiOyB9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBmLCBmYWxzZSk7XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIiwgZiwgZmFsc2UpO1xuXHRcdFx0aWYgKHN0YWdlLl9fdG91Y2gucHJldmVudERlZmF1bHQpIHsgY2FudmFzLnN0eWxlLnRvdWNoQWN0aW9uID0gXCJub25lXCI7IH1cblxuXHRcdH1cblx0XHRzdGFnZS5fX3RvdWNoLmFjdGl2ZUlEcyA9IHt9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9JRV9kaXNhYmxlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2Vcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRvdWNoLl9JRV9kaXNhYmxlID0gZnVuY3Rpb24oc3RhZ2UpIHtcblx0XHR2YXIgZiA9IHN0YWdlLl9fdG91Y2guZjtcblxuXHRcdGlmICh3aW5kb3cubmF2aWdhdG9yW1wicG9pbnRlckVuYWJsZWRcIl0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJNb3ZlXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiTVNQb2ludGVyVXBcIiwgZiwgZmFsc2UpO1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJNU1BvaW50ZXJDYW5jZWxcIiwgZiwgZmFsc2UpO1xuXHRcdFx0aWYgKHN0YWdlLmNhbnZhcykge1xuXHRcdFx0XHRzdGFnZS5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIk1TUG9pbnRlckRvd25cIiwgZiwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIGYsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBmLCBmYWxzZSk7XG5cdFx0XHRpZiAoc3RhZ2UuY2FudmFzKSB7XG5cdFx0XHRcdHN0YWdlLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZiwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfSUVfaGFuZGxlRXZlbnRcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2Vcblx0ICogQHBhcmFtIHtPYmplY3R9IGUgVGhlIGV2ZW50IHRvIGhhbmRsZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0VG91Y2guX0lFX2hhbmRsZUV2ZW50ID0gZnVuY3Rpb24oc3RhZ2UsIGUpIHtcblx0XHRpZiAoIXN0YWdlKSB7IHJldHVybjsgfVxuXHRcdGlmIChzdGFnZS5fX3RvdWNoLnByZXZlbnREZWZhdWx0KSB7IGUucHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG5cdFx0dmFyIHR5cGUgPSBlLnR5cGU7XG5cdFx0dmFyIGlkID0gZS5wb2ludGVySWQ7XG5cdFx0dmFyIGlkcyA9IHN0YWdlLl9fdG91Y2guYWN0aXZlSURzO1xuXG5cdFx0aWYgKHR5cGUgPT0gXCJNU1BvaW50ZXJEb3duXCIgfHwgdHlwZSA9PSBcInBvaW50ZXJkb3duXCIpIHtcblx0XHRcdGlmIChlLnNyY0VsZW1lbnQgIT0gc3RhZ2UuY2FudmFzKSB7IHJldHVybjsgfVxuXHRcdFx0aWRzW2lkXSA9IHRydWU7XG5cdFx0XHR0aGlzLl9oYW5kbGVTdGFydChzdGFnZSwgaWQsIGUsIGUucGFnZVgsIGUucGFnZVkpO1xuXHRcdH0gZWxzZSBpZiAoaWRzW2lkXSkgeyAvLyBpdCdzIGFuIGlkIHdlJ3JlIHdhdGNoaW5nXG5cdFx0XHRpZiAodHlwZSA9PSBcIk1TUG9pbnRlck1vdmVcIiB8fCB0eXBlID09IFwicG9pbnRlcm1vdmVcIikge1xuXHRcdFx0XHR0aGlzLl9oYW5kbGVNb3ZlKHN0YWdlLCBpZCwgZSwgZS5wYWdlWCwgZS5wYWdlWSk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT0gXCJNU1BvaW50ZXJVcFwiIHx8IHR5cGUgPT0gXCJNU1BvaW50ZXJDYW5jZWxcIlxuXHRcdFx0XHRcdHx8IHR5cGUgPT0gXCJwb2ludGVydXBcIiB8fCB0eXBlID09IFwicG9pbnRlcmNhbmNlbFwiKSB7XG5cdFx0XHRcdGRlbGV0ZShpZHNbaWRdKTtcblx0XHRcdFx0dGhpcy5faGFuZGxlRW5kKHN0YWdlLCBpZCwgZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVTdGFydFxuXHQgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGlkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB5XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUb3VjaC5faGFuZGxlU3RhcnQgPSBmdW5jdGlvbihzdGFnZSwgaWQsIGUsIHgsIHkpIHtcblx0XHR2YXIgcHJvcHMgPSBzdGFnZS5fX3RvdWNoO1xuXHRcdGlmICghcHJvcHMubXVsdGl0b3VjaCAmJiBwcm9wcy5jb3VudCkgeyByZXR1cm47IH1cblx0XHR2YXIgaWRzID0gcHJvcHMucG9pbnRlcnM7XG5cdFx0aWYgKGlkc1tpZF0pIHsgcmV0dXJuOyB9XG5cdFx0aWRzW2lkXSA9IHRydWU7XG5cdFx0cHJvcHMuY291bnQrKztcblx0XHRzdGFnZS5faGFuZGxlUG9pbnRlckRvd24oaWQsIGUsIHgsIHkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNb3ZlXG5cdCAqIEBwYXJhbSB7U3RhZ2V9IHN0YWdlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gaWRcblx0ICogQHBhcmFtIHtPYmplY3R9IGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHlcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRvdWNoLl9oYW5kbGVNb3ZlID0gZnVuY3Rpb24oc3RhZ2UsIGlkLCBlLCB4LCB5KSB7XG5cdFx0aWYgKCFzdGFnZS5fX3RvdWNoLnBvaW50ZXJzW2lkXSkgeyByZXR1cm47IH1cblx0XHRzdGFnZS5faGFuZGxlUG9pbnRlck1vdmUoaWQsIGUsIHgsIHkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVFbmRcblx0ICogQHBhcmFtIHtTdGFnZX0gc3RhZ2Vcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VG91Y2guX2hhbmRsZUVuZCA9IGZ1bmN0aW9uKHN0YWdlLCBpZCwgZSkge1xuXHRcdC8vIFRPRE86IGNhbmNlbCBzaG91bGQgYmUgaGFuZGxlZCBkaWZmZXJlbnRseSBmb3IgcHJvcGVyIFVJIChleC4gYW4gdXAgd291bGQgdHJpZ2dlciBhIGNsaWNrLCBhIGNhbmNlbCB3b3VsZCBtb3JlIGNsb3NlbHkgcmVzZW1ibGUgYW4gb3V0KS5cblx0XHR2YXIgcHJvcHMgPSBzdGFnZS5fX3RvdWNoO1xuXHRcdHZhciBpZHMgPSBwcm9wcy5wb2ludGVycztcblx0XHRpZiAoIWlkc1tpZF0pIHsgcmV0dXJuOyB9XG5cdFx0cHJvcHMuY291bnQtLTtcblx0XHRzdGFnZS5faGFuZGxlUG9pbnRlclVwKGlkLCBlLCB0cnVlKTtcblx0XHRkZWxldGUoaWRzW2lkXSk7XG5cdH07XG5cblxuXHRjcmVhdGVqcy5Ub3VjaCA9IFRvdWNoO1xufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIHZlcnNpb24uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBTdGF0aWMgY2xhc3MgaG9sZGluZyBsaWJyYXJ5IHNwZWNpZmljIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIHZlcnNpb24gYW5kIGJ1aWxkRGF0ZSBvZlxuXHQgKiB0aGUgbGlicmFyeS5cblx0ICogQGNsYXNzIEVhc2VsSlNcblx0ICoqL1xuXHR2YXIgcyA9IGNyZWF0ZWpzLkVhc2VsSlMgPSBjcmVhdGVqcy5FYXNlbEpTIHx8IHt9O1xuXG5cdC8qKlxuXHQgKiBUaGUgdmVyc2lvbiBzdHJpbmcgZm9yIHRoaXMgcmVsZWFzZS5cblx0ICogQHByb3BlcnR5IHZlcnNpb25cblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRzLnZlcnNpb24gPSAvKj12ZXJzaW9uKi9cIjAuOC4xXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxuXHQvKipcblx0ICogVGhlIGJ1aWxkIGRhdGUgZm9yIHRoaXMgcmVsZWFzZSBpbiBVVEMgZm9ybWF0LlxuXHQgKiBAcHJvcGVydHkgYnVpbGREYXRlXG5cdCAqIEB0eXBlIFN0cmluZ1xuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0cy5idWlsZERhdGUgPSAvKj1kYXRlKi9cIlRodSwgMjEgTWF5IDIwMTUgMTY6MTc6MzkgR01UXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxufSkoKTtcbi8qIVxuKiBQcmVsb2FkSlNcbiogVmlzaXQgaHR0cDovL2NyZWF0ZWpzLmNvbS8gZm9yIGRvY3VtZW50YXRpb24sIHVwZGF0ZXMgYW5kIGV4YW1wbGVzLlxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgZ3NraW5uZXIuY29tLCBpbmMuXG4qXG4qIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4qIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4qIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4qIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4qIGNvbmRpdGlvbnM6XG4qXG4qIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4qIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuKlxuKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbiogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG4qIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4qIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIHZlcnNpb24uanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogU3RhdGljIGNsYXNzIGhvbGRpbmcgbGlicmFyeSBzcGVjaWZpYyBpbmZvcm1hdGlvbiBzdWNoIGFzIHRoZSB2ZXJzaW9uIGFuZCBidWlsZERhdGUgb2YgdGhlIGxpYnJhcnkuXG5cdCAqIEBjbGFzcyBQcmVsb2FkSlNcblx0ICoqL1xuXHR2YXIgcyA9IGNyZWF0ZWpzLlByZWxvYWRKUyA9IGNyZWF0ZWpzLlByZWxvYWRKUyB8fCB7fTtcblxuXHQvKipcblx0ICogVGhlIHZlcnNpb24gc3RyaW5nIGZvciB0aGlzIHJlbGVhc2UuXG5cdCAqIEBwcm9wZXJ0eSB2ZXJzaW9uXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRzLnZlcnNpb24gPSAvKj12ZXJzaW9uKi9cIjAuNi4xXCI7IC8vIGluamVjdGVkIGJ5IGJ1aWxkIHByb2Nlc3NcblxuXHQvKipcblx0ICogVGhlIGJ1aWxkIGRhdGUgZm9yIHRoaXMgcmVsZWFzZSBpbiBVVEMgZm9ybWF0LlxuXHQgKiBAcHJvcGVydHkgYnVpbGREYXRlXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRzLmJ1aWxkRGF0ZSA9IC8qPWRhdGUqL1wiVGh1LCAyMSBNYXkgMjAxNSAxNjoxNzozNyBHTVRcIjsgLy8gaW5qZWN0ZWQgYnkgYnVpbGQgcHJvY2Vzc1xuXG59KSgpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gZXh0ZW5kLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG5cbi8qKlxuICogU2V0cyB1cCB0aGUgcHJvdG90eXBlIGNoYWluIGFuZCBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBmb3IgYSBuZXcgY2xhc3MuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIHJpZ2h0IGFmdGVyIGNyZWF0aW5nIHRoZSBjbGFzcyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBcdGZ1bmN0aW9uIE15U3ViQ2xhc3MoKSB7fVxuICogXHRjcmVhdGVqcy5leHRlbmQoTXlTdWJDbGFzcywgTXlTdXBlckNsYXNzKTtcbiAqIFx0Q2xhc3NCLnByb3RvdHlwZS5kb1NvbWV0aGluZyA9IGZ1bmN0aW9uKCkgeyB9XG4gKlxuICogXHR2YXIgZm9vID0gbmV3IE15U3ViQ2xhc3MoKTtcbiAqIFx0Y29uc29sZS5sb2coZm9vIGluc3RhbmNlb2YgTXlTdXBlckNsYXNzKTsgLy8gdHJ1ZVxuICogXHRjb25zb2xlLmxvZyhmb28ucHJvdG90eXBlLmNvbnN0cnVjdG9yID09PSBNeVN1YkNsYXNzKTsgLy8gdHJ1ZVxuICpcbiAqIEBtZXRob2QgZXh0ZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJjbGFzcyBUaGUgc3ViY2xhc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdXBlcmNsYXNzIFRoZSBzdXBlcmNsYXNzIHRvIGV4dGVuZC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBzdWJjbGFzcydzIG5ldyBwcm90b3R5cGUuXG4gKi9cbmNyZWF0ZWpzLmV4dGVuZCA9IGZ1bmN0aW9uKHN1YmNsYXNzLCBzdXBlcmNsYXNzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGZ1bmN0aW9uIG8oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBzdWJjbGFzczsgfVxuXHRvLnByb3RvdHlwZSA9IHN1cGVyY2xhc3MucHJvdG90eXBlO1xuXHRyZXR1cm4gKHN1YmNsYXNzLnByb3RvdHlwZSA9IG5ldyBvKCkpO1xufTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIHByb21vdGUuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuLyoqXG4gKiBAY2xhc3MgVXRpbGl0eSBNZXRob2RzXG4gKi9cblxuLyoqXG4gKiBQcm9tb3RlcyBhbnkgbWV0aG9kcyBvbiB0aGUgc3VwZXIgY2xhc3MgdGhhdCB3ZXJlIG92ZXJyaWRkZW4sIGJ5IGNyZWF0aW5nIGFuIGFsaWFzIGluIHRoZSBmb3JtYXQgYHByZWZpeF9tZXRob2ROYW1lYC5cbiAqIEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGUgc3VwZXIgY2xhc3MncyBuYW1lIGFzIHRoZSBwcmVmaXguXG4gKiBBbiBhbGlhcyB0byB0aGUgc3VwZXIgY2xhc3MncyBjb25zdHJ1Y3RvciBpcyBhbHdheXMgYWRkZWQgaW4gdGhlIGZvcm1hdCBgcHJlZml4X2NvbnN0cnVjdG9yYC5cbiAqIFRoaXMgYWxsb3dzIHRoZSBzdWJjbGFzcyB0byBjYWxsIHN1cGVyIGNsYXNzIG1ldGhvZHMgd2l0aG91dCB1c2luZyBgZnVuY3Rpb24uY2FsbGAsIHByb3ZpZGluZyBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIGBNeVN1YkNsYXNzYCBleHRlbmRzIGBNeVN1cGVyQ2xhc3NgLCBhbmQgYm90aCBkZWZpbmUgYSBgZHJhd2AgbWV0aG9kLCB0aGVuIGNhbGxpbmcgYHByb21vdGUoTXlTdWJDbGFzcywgXCJNeVN1cGVyQ2xhc3NcIilgXG4gKiB3b3VsZCBhZGQgYSBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYCBtZXRob2QgdG8gTXlTdWJDbGFzcyBhbmQgcHJvbW90ZSB0aGUgYGRyYXdgIG1ldGhvZCBvbiBgTXlTdXBlckNsYXNzYCB0byB0aGVcbiAqIHByb3RvdHlwZSBvZiBgTXlTdWJDbGFzc2AgYXMgYE15U3VwZXJDbGFzc19kcmF3YC5cbiAqXG4gKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGNsYXNzJ3MgcHJvdG90eXBlIGlzIGZ1bGx5IGRlZmluZWQuXG4gKlxuICogXHRmdW5jdGlvbiBDbGFzc0EobmFtZSkge1xuICogXHRcdHRoaXMubmFtZSA9IG5hbWU7XG4gKiBcdH1cbiAqIFx0Q2xhc3NBLnByb3RvdHlwZS5ncmVldCA9IGZ1bmN0aW9uKCkge1xuICogXHRcdHJldHVybiBcIkhlbGxvIFwiK3RoaXMubmFtZTtcbiAqIFx0fVxuICpcbiAqIFx0ZnVuY3Rpb24gQ2xhc3NCKG5hbWUsIHB1bmN0dWF0aW9uKSB7XG4gKiBcdFx0dGhpcy5DbGFzc0FfY29uc3RydWN0b3IobmFtZSk7XG4gKiBcdFx0dGhpcy5wdW5jdHVhdGlvbiA9IHB1bmN0dWF0aW9uO1xuICogXHR9XG4gKiBcdGNyZWF0ZWpzLmV4dGVuZChDbGFzc0IsIENsYXNzQSk7XG4gKiBcdENsYXNzQi5wcm90b3R5cGUuZ3JlZXQgPSBmdW5jdGlvbigpIHtcbiAqIFx0XHRyZXR1cm4gdGhpcy5DbGFzc0FfZ3JlZXQoKSt0aGlzLnB1bmN0dWF0aW9uO1xuICogXHR9XG4gKiBcdGNyZWF0ZWpzLnByb21vdGUoQ2xhc3NCLCBcIkNsYXNzQVwiKTtcbiAqXG4gKiBcdHZhciBmb28gPSBuZXcgQ2xhc3NCKFwiV29ybGRcIiwgXCIhPyFcIik7XG4gKiBcdGNvbnNvbGUubG9nKGZvby5ncmVldCgpKTsgLy8gSGVsbG8gV29ybGQhPyFcbiAqXG4gKiBAbWV0aG9kIHByb21vdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YmNsYXNzIFRoZSBjbGFzcyB0byBwcm9tb3RlIHN1cGVyIGNsYXNzIG1ldGhvZHMgb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IFRoZSBwcmVmaXggdG8gYWRkIHRvIHRoZSBwcm9tb3RlZCBtZXRob2QgbmFtZXMuIFVzdWFsbHkgdGhlIG5hbWUgb2YgdGhlIHN1cGVyY2xhc3MuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgc3ViY2xhc3MuXG4gKi9cbmNyZWF0ZWpzLnByb21vdGUgPSBmdW5jdGlvbihzdWJjbGFzcywgcHJlZml4KSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciBzdWJQID0gc3ViY2xhc3MucHJvdG90eXBlLCBzdXBQID0gKE9iamVjdC5nZXRQcm90b3R5cGVPZiYmT2JqZWN0LmdldFByb3RvdHlwZU9mKHN1YlApKXx8c3ViUC5fX3Byb3RvX187XG5cdGlmIChzdXBQKSB7XG5cdFx0c3ViUFsocHJlZml4Kz1cIl9cIikgKyBcImNvbnN0cnVjdG9yXCJdID0gc3VwUC5jb25zdHJ1Y3RvcjsgLy8gY29uc3RydWN0b3IgaXMgbm90IGFsd2F5cyBpbm51bWVyYWJsZVxuXHRcdGZvciAodmFyIG4gaW4gc3VwUCkge1xuXHRcdFx0aWYgKHN1YlAuaGFzT3duUHJvcGVydHkobikgJiYgKHR5cGVvZiBzdXBQW25dID09IFwiZnVuY3Rpb25cIikpIHsgc3ViUFtwcmVmaXggKyBuXSA9IHN1cFBbbl07IH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHN1YmNsYXNzO1xufTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIGluZGV4T2YuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuLyoqXG4gKiBAY2xhc3MgVXRpbGl0eSBNZXRob2RzXG4gKi9cblxuLyoqXG4gKiBGaW5kcyB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhIHNwZWNpZmllZCB2YWx1ZSBzZWFyY2hFbGVtZW50IGluIHRoZSBwYXNzZWQgaW4gYXJyYXksIGFuZCByZXR1cm5zIHRoZSBpbmRleCBvZlxuICogdGhhdCB2YWx1ZS4gIFJldHVybnMgLTEgaWYgdmFsdWUgaXMgbm90IGZvdW5kLlxuICpcbiAqICAgICAgdmFyIGkgPSBjcmVhdGVqcy5pbmRleE9mKG15QXJyYXksIG15RWxlbWVudFRvRmluZCk7XG4gKlxuICogQG1ldGhvZCBpbmRleE9mXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBBcnJheSB0byBzZWFyY2ggZm9yIHNlYXJjaEVsZW1lbnRcbiAqIEBwYXJhbSBzZWFyY2hFbGVtZW50IEVsZW1lbnQgdG8gZmluZCBpbiBhcnJheS5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIGZpcnN0IGluZGV4IG9mIHNlYXJjaEVsZW1lbnQgaW4gYXJyYXkuXG4gKi9cbmNyZWF0ZWpzLmluZGV4T2YgPSBmdW5jdGlvbiAoYXJyYXksIHNlYXJjaEVsZW1lbnQpe1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRmb3IgKHZhciBpID0gMCxsPWFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGlmIChzZWFyY2hFbGVtZW50ID09PSBhcnJheVtpXSkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBwcm94eS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4vKipcbiAqIFZhcmlvdXMgdXRpbGl0aWVzIHRoYXQgdGhlIENyZWF0ZUpTIFN1aXRlIHVzZXMuIFV0aWxpdGllcyBhcmUgY3JlYXRlZCBhcyBzZXBhcmF0ZSBmaWxlcywgYW5kIHdpbGwgYmUgYXZhaWxhYmxlIG9uIHRoZVxuICogY3JlYXRlanMgbmFtZXNwYWNlIGRpcmVjdGx5LlxuICpcbiAqIDxoND5FeGFtcGxlPC9oND5cbiAqXG4gKiAgICAgIG15T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgY3JlYXRlanMucHJveHkobXlNZXRob2QsIHNjb3BlKSk7XG4gKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICogQG1haW4gVXRpbGl0eSBNZXRob2RzXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogQSBmdW5jdGlvbiBwcm94eSBmb3IgbWV0aG9kcy4gQnkgZGVmYXVsdCwgSmF2YVNjcmlwdCBtZXRob2RzIGRvIG5vdCBtYWludGFpbiBzY29wZSwgc28gcGFzc2luZyBhIG1ldGhvZCBhcyBhXG5cdCAqIGNhbGxiYWNrIHdpbGwgcmVzdWx0IGluIHRoZSBtZXRob2QgZ2V0dGluZyBjYWxsZWQgaW4gdGhlIHNjb3BlIG9mIHRoZSBjYWxsZXIuIFVzaW5nIGEgcHJveHkgZW5zdXJlcyB0aGF0IHRoZVxuXHQgKiBtZXRob2QgZ2V0cyBjYWxsZWQgaW4gdGhlIGNvcnJlY3Qgc2NvcGUuXG5cdCAqXG5cdCAqIEFkZGl0aW9uYWwgYXJndW1lbnRzIGNhbiBiZSBwYXNzZWQgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGZ1bmN0aW9uIHdoZW4gaXQgaXMgY2FsbGVkLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgbXlPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcImV2ZW50XCIsIGNyZWF0ZWpzLnByb3h5KG15SGFuZGxlciwgdGhpcywgYXJnMSwgYXJnMikpO1xuXHQgKlxuXHQgKiAgICAgIGZ1bmN0aW9uIG15SGFuZGxlcihhcmcxLCBhcmcyKSB7XG5cdCAqICAgICAgICAgICAvLyBUaGlzIGdldHMgY2FsbGVkIHdoZW4gbXlPYmplY3QubXlDYWxsYmFjayBpcyBleGVjdXRlZC5cblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEBtZXRob2QgcHJveHlcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIFRoZSBmdW5jdGlvbiB0byBjYWxsXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSBUaGUgc2NvcGUgdG8gY2FsbCB0aGUgbWV0aG9kIG5hbWUgb25cblx0ICogQHBhcmFtIHttaXhlZH0gW2FyZ10gKiBBcmd1bWVudHMgdGhhdCBhcmUgYXBwZW5kZWQgdG8gdGhlIGNhbGxiYWNrIGZvciBhZGRpdGlvbmFsIHBhcmFtcy5cblx0ICogQHB1YmxpY1xuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRjcmVhdGVqcy5wcm94eSA9IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlKSB7XG5cdFx0dmFyIGFBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIG1ldGhvZC5hcHBseShzY29wZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKS5jb25jYXQoYUFyZ3MpKTtcblx0XHR9O1xuXHR9XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBCcm93c2VyRGV0ZWN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbi8qKlxuICogQGNsYXNzIFV0aWxpdHkgTWV0aG9kc1xuICovXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBBbiBvYmplY3QgdGhhdCBkZXRlcm1pbmVzIHRoZSBjdXJyZW50IGJyb3dzZXIsIHZlcnNpb24sIG9wZXJhdGluZyBzeXN0ZW0sIGFuZCBvdGhlciBlbnZpcm9ubWVudFxuXHQgKiB2YXJpYWJsZXMgdmlhIHVzZXIgYWdlbnQgc3RyaW5nLlxuXHQgKlxuXHQgKiBVc2VkIGZvciBhdWRpbyBiZWNhdXNlIGZlYXR1cmUgZGV0ZWN0aW9uIGlzIHVuYWJsZSB0byBkZXRlY3QgdGhlIG1hbnkgbGltaXRhdGlvbnMgb2YgbW9iaWxlIGRldmljZXMuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBpZiAoY3JlYXRlanMuQnJvd3NlckRldGVjdC5pc0lPUykgeyAvLyBkbyBzdHVmZiB9XG5cdCAqXG5cdCAqIEBwcm9wZXJ0eSBCcm93c2VyRGV0ZWN0XG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNGaXJlZm94IFRydWUgaWYgb3VyIGJyb3dzZXIgaXMgRmlyZWZveC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpc09wZXJhIFRydWUgaWYgb3VyIGJyb3dzZXIgaXMgb3BlcmEuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNDaHJvbWUgVHJ1ZSBpZiBvdXIgYnJvd3NlciBpcyBDaHJvbWUuICBOb3RlIHRoYXQgQ2hyb21lIGZvciBBbmRyb2lkIHJldHVybnMgdHJ1ZSwgYnV0IGlzIGFcblx0ICogY29tcGxldGVseSBkaWZmZXJlbnQgYnJvd3NlciB3aXRoIGRpZmZlcmVudCBhYmlsaXRpZXMuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJT1MgVHJ1ZSBpZiBvdXIgYnJvd3NlciBpcyBzYWZhcmkgZm9yIGlPUyBkZXZpY2VzIChpUGFkLCBpUGhvbmUsIGFuZCBpUG9kKS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0FuZHJvaWQgVHJ1ZSBpZiBvdXIgYnJvd3NlciBpcyBBbmRyb2lkLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmxhY2tiZXJyeSBUcnVlIGlmIG91ciBicm93c2VyIGlzIEJsYWNrYmVycnkuXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRmdW5jdGlvbiBCcm93c2VyRGV0ZWN0KCkge1xuXHRcdHRocm93IFwiQnJvd3NlckRldGVjdCBjYW5ub3QgYmUgaW5zdGFudGlhdGVkXCI7XG5cdH1cblxuXHR2YXIgYWdlbnQgPSBCcm93c2VyRGV0ZWN0LmFnZW50ID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cdEJyb3dzZXJEZXRlY3QuaXNXaW5kb3dQaG9uZSA9IChhZ2VudC5pbmRleE9mKFwiSUVNb2JpbGVcIikgPiAtMSkgfHwgKGFnZW50LmluZGV4T2YoXCJXaW5kb3dzIFBob25lXCIpID4gLTEpO1xuXHRCcm93c2VyRGV0ZWN0LmlzRmlyZWZveCA9IChhZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSA+IC0xKTtcblx0QnJvd3NlckRldGVjdC5pc09wZXJhID0gKHdpbmRvdy5vcGVyYSAhPSBudWxsKTtcblx0QnJvd3NlckRldGVjdC5pc0Nocm9tZSA9IChhZ2VudC5pbmRleE9mKFwiQ2hyb21lXCIpID4gLTEpOyAgLy8gTk9URSB0aGF0IENocm9tZSBvbiBBbmRyb2lkIHJldHVybnMgdHJ1ZSBidXQgaXMgYSBjb21wbGV0ZWx5IGRpZmZlcmVudCBicm93c2VyIHdpdGggZGlmZmVyZW50IGFiaWxpdGllc1xuXHRCcm93c2VyRGV0ZWN0LmlzSU9TID0gKGFnZW50LmluZGV4T2YoXCJpUG9kXCIpID4gLTEgfHwgYWdlbnQuaW5kZXhPZihcImlQaG9uZVwiKSA+IC0xIHx8IGFnZW50LmluZGV4T2YoXCJpUGFkXCIpID4gLTEpICYmICFCcm93c2VyRGV0ZWN0LmlzV2luZG93UGhvbmU7XG5cdEJyb3dzZXJEZXRlY3QuaXNBbmRyb2lkID0gKGFnZW50LmluZGV4T2YoXCJBbmRyb2lkXCIpID4gLTEpICYmICFCcm93c2VyRGV0ZWN0LmlzV2luZG93UGhvbmU7XG5cdEJyb3dzZXJEZXRlY3QuaXNCbGFja2JlcnJ5ID0gKGFnZW50LmluZGV4T2YoXCJCbGFja2JlcnJ5XCIpID4gLTEpO1xuXG5cdGNyZWF0ZWpzLkJyb3dzZXJEZXRlY3QgPSBCcm93c2VyRGV0ZWN0O1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRXZlbnQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBDb250YWlucyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHNoYXJlZCBieSBhbGwgZXZlbnRzIGZvciB1c2Ugd2l0aFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFxuXHQgKiBOb3RlIHRoYXQgRXZlbnQgb2JqZWN0cyBhcmUgb2Z0ZW4gcmV1c2VkLCBzbyB5b3Ugc2hvdWxkIG5ldmVyXG5cdCAqIHJlbHkgb24gYW4gZXZlbnQgb2JqZWN0J3Mgc3RhdGUgb3V0c2lkZSBvZiB0aGUgY2FsbCBzdGFjayBpdCB3YXMgcmVjZWl2ZWQgaW4uXG5cdCAqIEBjbGFzcyBFdmVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBidWJibGVzIEluZGljYXRlcyB3aGV0aGVyIHRoZSBldmVudCB3aWxsIGJ1YmJsZSB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FuY2VsYWJsZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdGhpcyBldmVudCBjYW4gYmUgY2FuY2VsbGVkLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBFdmVudCh0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlKSB7XG5cdFx0XG5cdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgdHlwZSBvZiBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgdHlwZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqKi9cblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgb2JqZWN0IHRoYXQgZ2VuZXJhdGVkIGFuIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSB0YXJnZXRcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLnRhcmdldCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IHRhcmdldCB0aGF0IGEgYnViYmxpbmcgZXZlbnQgaXMgYmVpbmcgZGlzcGF0Y2hlZCBmcm9tLiBGb3Igbm9uLWJ1YmJsaW5nIGV2ZW50cywgdGhpcyB3aWxsXG5cdFx0ICogYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHRhcmdldC4gRm9yIGV4YW1wbGUsIGlmIGNoaWxkT2JqLnBhcmVudCA9IHBhcmVudE9iaiwgYW5kIGEgYnViYmxpbmcgZXZlbnRcblx0XHQgKiBpcyBnZW5lcmF0ZWQgZnJvbSBjaGlsZE9iaiwgdGhlbiBhIGxpc3RlbmVyIG9uIHBhcmVudE9iaiB3b3VsZCByZWNlaXZlIHRoZSBldmVudCB3aXRoXG5cdFx0ICogdGFyZ2V0PWNoaWxkT2JqICh0aGUgb3JpZ2luYWwgdGFyZ2V0KSBhbmQgY3VycmVudFRhcmdldD1wYXJlbnRPYmogKHdoZXJlIHRoZSBsaXN0ZW5lciB3YXMgYWRkZWQpLlxuXHRcdCAqIEBwcm9wZXJ0eSBjdXJyZW50VGFyZ2V0XG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogRm9yIGJ1YmJsaW5nIGV2ZW50cywgdGhpcyBpbmRpY2F0ZXMgdGhlIGN1cnJlbnQgZXZlbnQgcGhhc2U6PE9MPlxuXHRcdCAqIFx0PExJPiBjYXB0dXJlIHBoYXNlOiBzdGFydGluZyBmcm9tIHRoZSB0b3AgcGFyZW50IHRvIHRoZSB0YXJnZXQ8L0xJPlxuXHRcdCAqIFx0PExJPiBhdCB0YXJnZXQgcGhhc2U6IGN1cnJlbnRseSBiZWluZyBkaXNwYXRjaGVkIGZyb20gdGhlIHRhcmdldDwvTEk+XG5cdFx0ICogXHQ8TEk+IGJ1YmJsaW5nIHBoYXNlOiBmcm9tIHRoZSB0YXJnZXQgdG8gdGhlIHRvcCBwYXJlbnQ8L0xJPlxuXHRcdCAqIDwvT0w+XG5cdFx0ICogQHByb3BlcnR5IGV2ZW50UGhhc2Vcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmV2ZW50UGhhc2UgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZXZlbnQgd2lsbCBidWJibGUgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBidWJibGVzXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmJ1YmJsZXMgPSAhIWJ1YmJsZXM7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiB0aGlzIGV2ZW50IGNhbiBiZSBjYW5jZWxsZWQgdmlhXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcHJldmVudERlZmF1bHRcIn19e3svY3Jvc3NMaW5rfX0uIFRoaXMgaXMgc2V0IHZpYSB0aGUgRXZlbnQgY29uc3RydWN0b3IuXG5cdFx0ICogQHByb3BlcnR5IGNhbmNlbGFibGVcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuY2FuY2VsYWJsZSA9ICEhY2FuY2VsYWJsZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGVwb2NoIHRpbWUgYXQgd2hpY2ggdGhpcyBldmVudCB3YXMgY3JlYXRlZC5cblx0XHQgKiBAcHJvcGVydHkgdGltZVN0YW1wXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy50aW1lU3RhbXAgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcHJldmVudERlZmF1bHRcIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkXG5cdFx0ICogb24gdGhpcyBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgZGVmYXVsdFByZXZlbnRlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9zdG9wUHJvcGFnYXRpb25cIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudC9zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkIG9uIHRoaXMgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IHByb3BhZ2F0aW9uU3RvcHBlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHt7I2Nyb3NzTGluayBcIkV2ZW50L3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwifX17ey9jcm9zc0xpbmt9fSBoYXMgYmVlbiBjYWxsZWRcblx0XHQgKiBvbiB0aGlzIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBpbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHt7I2Nyb3NzTGluayBcIkV2ZW50L3JlbW92ZVwifX17ey9jcm9zc0xpbmt9fSBoYXMgYmVlbiBjYWxsZWQgb24gdGhpcyBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgcmVtb3ZlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5yZW1vdmVkID0gZmFsc2U7XG5cdH1cblx0dmFyIHAgPSBFdmVudC5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXHRcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBTZXRzIHt7I2Nyb3NzTGluayBcIkV2ZW50L2RlZmF1bHRQcmV2ZW50ZWRcIn19e3svY3Jvc3NMaW5rfX0gdG8gdHJ1ZS5cblx0ICogTWlycm9ycyB0aGUgRE9NIGV2ZW50IHN0YW5kYXJkLlxuXHQgKiBAbWV0aG9kIHByZXZlbnREZWZhdWx0XG5cdCAqKi9cblx0cC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRoaXMuY2FuY2VsYWJsZSYmdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB7eyNjcm9zc0xpbmsgXCJFdmVudC9wcm9wYWdhdGlvblN0b3BwZWRcIn19e3svY3Jvc3NMaW5rfX0gdG8gdHJ1ZS5cblx0ICogTWlycm9ycyB0aGUgRE9NIGV2ZW50IHN0YW5kYXJkLlxuXHQgKiBAbWV0aG9kIHN0b3BQcm9wYWdhdGlvblxuXHQgKiovXG5cdHAuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHt7I2Nyb3NzTGluayBcIkV2ZW50L3Byb3BhZ2F0aW9uU3RvcHBlZFwifX17ey9jcm9zc0xpbmt9fSBhbmRcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkXCJ9fXt7L2Nyb3NzTGlua319IHRvIHRydWUuXG5cdCAqIE1pcnJvcnMgdGhlIERPTSBldmVudCBzdGFuZGFyZC5cblx0ICogQG1ldGhvZCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cblx0ICoqL1xuXHRwLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhdXNlcyB0aGUgYWN0aXZlIGxpc3RlbmVyIHRvIGJlIHJlbW92ZWQgdmlhIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcblx0ICogXG5cdCAqIFx0XHRteUJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZ0KSB7XG5cdCAqIFx0XHRcdC8vIGRvIHN0dWZmLi4uXG5cdCAqIFx0XHRcdGV2dC5yZW1vdmUoKTsgLy8gcmVtb3ZlcyB0aGlzIGxpc3RlbmVyLlxuXHQgKiBcdFx0fSk7XG5cdCAqIFxuXHQgKiBAbWV0aG9kIHJlbW92ZVxuXHQgKiovXG5cdHAucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZW1vdmVkID0gdHJ1ZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIEV2ZW50IGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge0V2ZW50fSBhIGNsb25lIG9mIHRoZSBFdmVudCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBFdmVudCh0aGlzLnR5cGUsIHRoaXMuYnViYmxlcywgdGhpcy5jYW5jZWxhYmxlKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBQcm92aWRlcyBhIGNoYWluYWJsZSBzaG9ydGN1dCBtZXRob2QgZm9yIHNldHRpbmcgYSBudW1iZXIgb2YgcHJvcGVydGllcyBvbiB0aGUgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBBIGdlbmVyaWMgb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBjb3B5IHRvIHRoZSBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7RXZlbnR9IFJldHVybnMgdGhlIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLnNldCA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykgeyB0aGlzW25dID0gcHJvcHNbbl07IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0V2ZW50ICh0eXBlPVwiK3RoaXMudHlwZStcIildXCI7XG5cdH07XG5cblx0Y3JlYXRlanMuRXZlbnQgPSBFdmVudDtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBFcnJvckV2ZW50LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJhbCBlcnJvciB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSwgdGhhdCBkZXNjcmliZXMgYW4gZXJyb3IgdGhhdCBvY2N1cnJlZCwgYXMgd2VsbCBhcyBhbnkgZGV0YWlscy5cblx0ICogQGNsYXNzIEVycm9yRXZlbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IFt0aXRsZV0gVGhlIGVycm9yIHRpdGxlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gVGhlIGVycm9yIGRlc2NyaXB0aW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV0gQWRkaXRpb25hbCBlcnJvciBkYXRhXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gRXJyb3JFdmVudCh0aXRsZSwgbWVzc2FnZSwgZGF0YSkge1xuXHRcdHRoaXMuRXZlbnRfY29uc3RydWN0b3IoXCJlcnJvclwiKTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBzaG9ydCBlcnJvciB0aXRsZSwgd2hpY2ggaW5kaWNhdGVzIHRoZSB0eXBlIG9mIGVycm9yIHRoYXQgb2NjdXJyZWQuXG5cdFx0ICogQHByb3BlcnR5IHRpdGxlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0dGhpcy50aXRsZSA9IHRpdGxlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHZlcmJvc2UgZXJyb3IgbWVzc2FnZSwgY29udGFpbmluZyBkZXRhaWxzIGFib3V0IHRoZSBlcnJvci5cblx0XHQgKiBAcHJvcGVydHkgbWVzc2FnZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cblx0XHQvKipcblx0XHQgKiBBZGRpdGlvbmFsIGRhdGEgYXR0YWNoZWQgdG8gYW4gZXJyb3IuXG5cdFx0ICogQHByb3BlcnR5IGRhdGFcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdH1cblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChFcnJvckV2ZW50LCBjcmVhdGVqcy5FdmVudCk7XG5cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgY3JlYXRlanMuRXJyb3JFdmVudCh0aGlzLnRpdGxlLCB0aGlzLm1lc3NhZ2UsIHRoaXMuZGF0YSk7XG5cdH07XG5cblx0Y3JlYXRlanMuRXJyb3JFdmVudCA9IGNyZWF0ZWpzLnByb21vdGUoRXJyb3JFdmVudCwgXCJFdmVudFwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEV2ZW50RGlzcGF0Y2hlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbi8vIGNvbnN0cnVjdG9yOlxyXG5cdC8qKlxyXG5cdCAqIEV2ZW50RGlzcGF0Y2hlciBwcm92aWRlcyBtZXRob2RzIGZvciBtYW5hZ2luZyBxdWV1ZXMgb2YgZXZlbnQgbGlzdGVuZXJzIGFuZCBkaXNwYXRjaGluZyBldmVudHMuXHJcblx0ICpcclxuXHQgKiBZb3UgY2FuIGVpdGhlciBleHRlbmQgRXZlbnREaXNwYXRjaGVyIG9yIG1peCBpdHMgbWV0aG9kcyBpbnRvIGFuIGV4aXN0aW5nIHByb3RvdHlwZSBvciBpbnN0YW5jZSBieSB1c2luZyB0aGVcclxuXHQgKiBFdmVudERpc3BhdGNoZXIge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL2luaXRpYWxpemVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxyXG5cdCAqIFxyXG5cdCAqIFRvZ2V0aGVyIHdpdGggdGhlIENyZWF0ZUpTIEV2ZW50IGNsYXNzLCBFdmVudERpc3BhdGNoZXIgcHJvdmlkZXMgYW4gZXh0ZW5kZWQgZXZlbnQgbW9kZWwgdGhhdCBpcyBiYXNlZCBvbiB0aGVcclxuXHQgKiBET00gTGV2ZWwgMiBldmVudCBtb2RlbCwgaW5jbHVkaW5nIGFkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXIsIGFuZCBkaXNwYXRjaEV2ZW50LiBJdCBzdXBwb3J0c1xyXG5cdCAqIGJ1YmJsaW5nIC8gY2FwdHVyZSwgcHJldmVudERlZmF1bHQsIHN0b3BQcm9wYWdhdGlvbiwgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uLCBhbmQgaGFuZGxlRXZlbnQuXHJcblx0ICogXHJcblx0ICogRXZlbnREaXNwYXRjaGVyIGFsc28gZXhwb3NlcyBhIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9vblwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QsIHdoaWNoIG1ha2VzIGl0IGVhc2llclxyXG5cdCAqIHRvIGNyZWF0ZSBzY29wZWQgbGlzdGVuZXJzLCBsaXN0ZW5lcnMgdGhhdCBvbmx5IHJ1biBvbmNlLCBhbmQgbGlzdGVuZXJzIHdpdGggYXNzb2NpYXRlZCBhcmJpdHJhcnkgZGF0YS4gVGhlIFxyXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9vZmZcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIGlzIG1lcmVseSBhbiBhbGlhcyB0b1xyXG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9yZW1vdmVFdmVudExpc3RlbmVyXCJ9fXt7L2Nyb3NzTGlua319LlxyXG5cdCAqIFxyXG5cdCAqIEFub3RoZXIgYWRkaXRpb24gdG8gdGhlIERPTSBMZXZlbCAyIG1vZGVsIGlzIHRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnNcIn19e3svY3Jvc3NMaW5rfX1cclxuXHQgKiBtZXRob2QsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGxpc3RlbmVycyBmb3IgYWxsIGV2ZW50cywgb3IgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmljIGV2ZW50LiBUaGUgRXZlbnQgb2JqZWN0IGFsc28gXHJcblx0ICogaW5jbHVkZXMgYSB7eyNjcm9zc0xpbmsgXCJFdmVudC9yZW1vdmVcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIHdoaWNoIHJlbW92ZXMgdGhlIGFjdGl2ZSBsaXN0ZW5lci5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKiBBZGQgRXZlbnREaXNwYXRjaGVyIGNhcGFiaWxpdGllcyB0byB0aGUgXCJNeUNsYXNzXCIgY2xhc3MuXHJcblx0ICpcclxuXHQgKiAgICAgIEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplKE15Q2xhc3MucHJvdG90eXBlKTtcclxuXHQgKlxyXG5cdCAqIEFkZCBhbiBldmVudCAoc2VlIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9hZGRFdmVudExpc3RlbmVyXCJ9fXt7L2Nyb3NzTGlua319KS5cclxuXHQgKlxyXG5cdCAqICAgICAgaW5zdGFuY2UuYWRkRXZlbnRMaXN0ZW5lcihcImV2ZW50TmFtZVwiLCBoYW5kbGVyTWV0aG9kKTtcclxuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZXJNZXRob2QoZXZlbnQpIHtcclxuXHQgKiAgICAgICAgICBjb25zb2xlLmxvZyhldmVudC50YXJnZXQgKyBcIiBXYXMgQ2xpY2tlZFwiKTtcclxuXHQgKiAgICAgIH1cclxuXHQgKlxyXG5cdCAqIDxiPk1haW50YWluaW5nIHByb3BlciBzY29wZTwvYj48YnIgLz5cclxuXHQgKiBTY29wZSAoaWUuIFwidGhpc1wiKSBjYW4gYmUgYmUgYSBjaGFsbGVuZ2Ugd2l0aCBldmVudHMuIFVzaW5nIHRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvb25cIn19e3svY3Jvc3NMaW5rfX1cclxuXHQgKiBtZXRob2QgdG8gc3Vic2NyaWJlIHRvIGV2ZW50cyBzaW1wbGlmaWVzIHRoaXMuXHJcblx0ICpcclxuXHQgKiAgICAgIGluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCkge1xyXG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKGluc3RhbmNlID09IHRoaXMpOyAvLyBmYWxzZSwgc2NvcGUgaXMgYW1iaWd1b3VzLlxyXG5cdCAqICAgICAgfSk7XHJcblx0ICogICAgICBcclxuXHQgKiAgICAgIGluc3RhbmNlLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuXHQgKiAgICAgICAgICBjb25zb2xlLmxvZyhpbnN0YW5jZSA9PSB0aGlzKTsgLy8gdHJ1ZSwgXCJvblwiIHVzZXMgZGlzcGF0Y2hlciBzY29wZSBieSBkZWZhdWx0LlxyXG5cdCAqICAgICAgfSk7XHJcblx0ICogXHJcblx0ICogSWYgeW91IHdhbnQgdG8gdXNlIGFkZEV2ZW50TGlzdGVuZXIgaW5zdGVhZCwgeW91IG1heSB3YW50IHRvIHVzZSBmdW5jdGlvbi5iaW5kKCkgb3IgYSBzaW1pbGFyIHByb3h5IHRvIG1hbmFnZSBzY29wZS5cclxuXHQgKiAgICAgIFxyXG5cdCAqXHJcblx0ICogQGNsYXNzIEV2ZW50RGlzcGF0Y2hlclxyXG5cdCAqIEBjb25zdHJ1Y3RvclxyXG5cdCAqKi9cclxuXHRmdW5jdGlvbiBFdmVudERpc3BhdGNoZXIoKSB7XHJcblx0XHJcblx0XHJcblx0Ly8gcHJpdmF0ZSBwcm9wZXJ0aWVzOlxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAcHJvcGVydHkgX2xpc3RlbmVyc1xyXG5cdFx0ICogQHR5cGUgT2JqZWN0XHJcblx0XHQgKiovXHJcblx0XHR0aGlzLl9saXN0ZW5lcnMgPSBudWxsO1xyXG5cdFx0XHJcblx0XHQvKipcclxuXHRcdCAqIEBwcm90ZWN0ZWRcclxuXHRcdCAqIEBwcm9wZXJ0eSBfY2FwdHVyZUxpc3RlbmVyc1xyXG5cdFx0ICogQHR5cGUgT2JqZWN0XHJcblx0XHQgKiovXHJcblx0XHR0aGlzLl9jYXB0dXJlTGlzdGVuZXJzID0gbnVsbDtcclxuXHR9XHJcblx0dmFyIHAgPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlO1xyXG5cclxuXHQvKipcclxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXHJcblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XHJcblx0ICogZm9yIGRldGFpbHMuXHJcblx0ICpcclxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiBAZGVwcmVjYXRlZFxyXG5cdCAqL1xyXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxyXG5cclxuXHJcbi8vIHN0YXRpYyBwdWJsaWMgbWV0aG9kczpcclxuXHQvKipcclxuXHQgKiBTdGF0aWMgaW5pdGlhbGl6ZXIgdG8gbWl4IEV2ZW50RGlzcGF0Y2hlciBtZXRob2RzIGludG8gYSB0YXJnZXQgb2JqZWN0IG9yIHByb3RvdHlwZS5cclxuXHQgKiBcclxuXHQgKiBcdFx0RXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUoTXlDbGFzcy5wcm90b3R5cGUpOyAvLyBhZGQgdG8gdGhlIHByb3RvdHlwZSBvZiB0aGUgY2xhc3NcclxuXHQgKiBcdFx0RXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUobXlPYmplY3QpOyAvLyBhZGQgdG8gYSBzcGVjaWZpYyBpbnN0YW5jZVxyXG5cdCAqIFxyXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxyXG5cdCAqIEBzdGF0aWNcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IHRvIGluamVjdCBFdmVudERpc3BhdGNoZXIgbWV0aG9kcyBpbnRvLiBUaGlzIGNhbiBiZSBhbiBpbnN0YW5jZSBvciBhXHJcblx0ICogcHJvdG90eXBlLlxyXG5cdCAqKi9cclxuXHRFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKHRhcmdldCkge1xyXG5cdFx0dGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgPSBwLmFkZEV2ZW50TGlzdGVuZXI7XHJcblx0XHR0YXJnZXQub24gPSBwLm9uO1xyXG5cdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIgPSB0YXJnZXQub2ZmID0gIHAucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcclxuXHRcdHRhcmdldC5yZW1vdmVBbGxFdmVudExpc3RlbmVycyA9IHAucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnM7XHJcblx0XHR0YXJnZXQuaGFzRXZlbnRMaXN0ZW5lciA9IHAuaGFzRXZlbnRMaXN0ZW5lcjtcclxuXHRcdHRhcmdldC5kaXNwYXRjaEV2ZW50ID0gcC5kaXNwYXRjaEV2ZW50O1xyXG5cdFx0dGFyZ2V0Ll9kaXNwYXRjaEV2ZW50ID0gcC5fZGlzcGF0Y2hFdmVudDtcclxuXHRcdHRhcmdldC53aWxsVHJpZ2dlciA9IHAud2lsbFRyaWdnZXI7XHJcblx0fTtcclxuXHRcclxuXHJcbi8vIHB1YmxpYyBtZXRob2RzOlxyXG5cdC8qKlxyXG5cdCAqIEFkZHMgdGhlIHNwZWNpZmllZCBldmVudCBsaXN0ZW5lci4gTm90ZSB0aGF0IGFkZGluZyBtdWx0aXBsZSBsaXN0ZW5lcnMgdG8gdGhlIHNhbWUgZnVuY3Rpb24gd2lsbCByZXN1bHQgaW5cclxuXHQgKiBtdWx0aXBsZSBjYWxsYmFja3MgZ2V0dGluZyBmaXJlZC5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spO1xyXG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcclxuXHQgKiAgICAgICAgIC8vIENsaWNrIGhhcHBlbmVkLlxyXG5cdCAqICAgICAgfVxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBBbiBvYmplY3Qgd2l0aCBhIGhhbmRsZUV2ZW50IG1ldGhvZCwgb3IgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5cclxuXHQgKiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXHJcblx0ICogQHJldHVybiB7RnVuY3Rpb24gfCBPYmplY3R9IFJldHVybnMgdGhlIGxpc3RlbmVyIGZvciBjaGFpbmluZyBvciBhc3NpZ25tZW50LlxyXG5cdCAqKi9cclxuXHRwLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xyXG5cdFx0dmFyIGxpc3RlbmVycztcclxuXHRcdGlmICh1c2VDYXB0dXJlKSB7XHJcblx0XHRcdGxpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgPSB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzfHx7fTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc3x8e307XHJcblx0XHR9XHJcblx0XHR2YXIgYXJyID0gbGlzdGVuZXJzW3R5cGVdO1xyXG5cdFx0aWYgKGFycikgeyB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpOyB9XHJcblx0XHRhcnIgPSBsaXN0ZW5lcnNbdHlwZV07IC8vIHJlbW92ZSBtYXkgaGF2ZSBkZWxldGVkIHRoZSBhcnJheVxyXG5cdFx0aWYgKCFhcnIpIHsgbGlzdGVuZXJzW3R5cGVdID0gW2xpc3RlbmVyXTsgIH1cclxuXHRcdGVsc2UgeyBhcnIucHVzaChsaXN0ZW5lcik7IH1cclxuXHRcdHJldHVybiBsaXN0ZW5lcjtcclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEEgc2hvcnRjdXQgbWV0aG9kIGZvciB1c2luZyBhZGRFdmVudExpc3RlbmVyIHRoYXQgbWFrZXMgaXQgZWFzaWVyIHRvIHNwZWNpZnkgYW4gZXhlY3V0aW9uIHNjb3BlLCBoYXZlIGEgbGlzdGVuZXJcclxuXHQgKiBvbmx5IHJ1biBvbmNlLCBhc3NvY2lhdGUgYXJiaXRyYXJ5IGRhdGEgd2l0aCB0aGUgbGlzdGVuZXIsIGFuZCByZW1vdmUgdGhlIGxpc3RlbmVyLlxyXG5cdCAqIFxyXG5cdCAqIFRoaXMgbWV0aG9kIHdvcmtzIGJ5IGNyZWF0aW5nIGFuIGFub255bW91cyB3cmFwcGVyIGZ1bmN0aW9uIGFuZCBzdWJzY3JpYmluZyBpdCB3aXRoIGFkZEV2ZW50TGlzdGVuZXIuXHJcblx0ICogVGhlIGNyZWF0ZWQgYW5vbnltb3VzIGZ1bmN0aW9uIGlzIHJldHVybmVkIGZvciB1c2Ugd2l0aCAucmVtb3ZlRXZlbnRMaXN0ZW5lciAob3IgLm9mZikuXHJcblx0ICogXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqIFxyXG5cdCAqIFx0XHR2YXIgbGlzdGVuZXIgPSBteUJ0bi5vbihcImNsaWNrXCIsIGhhbmRsZUNsaWNrLCBudWxsLCBmYWxzZSwge2NvdW50OjN9KTtcclxuXHQgKiBcdFx0ZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZ0LCBkYXRhKSB7XHJcblx0ICogXHRcdFx0ZGF0YS5jb3VudCAtPSAxO1xyXG5cdCAqIFx0XHRcdGNvbnNvbGUubG9nKHRoaXMgPT0gbXlCdG4pOyAvLyB0cnVlIC0gc2NvcGUgZGVmYXVsdHMgdG8gdGhlIGRpc3BhdGNoZXJcclxuXHQgKiBcdFx0XHRpZiAoZGF0YS5jb3VudCA9PSAwKSB7XHJcblx0ICogXHRcdFx0XHRhbGVydChcImNsaWNrZWQgMyB0aW1lcyFcIik7XHJcblx0ICogXHRcdFx0XHRteUJ0bi5vZmYoXCJjbGlja1wiLCBsaXN0ZW5lcik7XHJcblx0ICogXHRcdFx0XHQvLyBhbHRlcm5hdGVseTogZXZ0LnJlbW92ZSgpO1xyXG5cdCAqIFx0XHRcdH1cclxuXHQgKiBcdFx0fVxyXG5cdCAqIFxyXG5cdCAqIEBtZXRob2Qgb25cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb24gfCBPYmplY3R9IGxpc3RlbmVyIEFuIG9iamVjdCB3aXRoIGEgaGFuZGxlRXZlbnQgbWV0aG9kLCBvciBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlblxyXG5cdCAqIHRoZSBldmVudCBpcyBkaXNwYXRjaGVkLlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdIFRoZSBzY29wZSB0byBleGVjdXRlIHRoZSBsaXN0ZW5lciBpbi4gRGVmYXVsdHMgdG8gdGhlIGRpc3BhdGNoZXIvY3VycmVudFRhcmdldCBmb3IgZnVuY3Rpb24gbGlzdGVuZXJzLCBhbmQgdG8gdGhlIGxpc3RlbmVyIGl0c2VsZiBmb3Igb2JqZWN0IGxpc3RlbmVycyAoaWUuIHVzaW5nIGhhbmRsZUV2ZW50KS5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBJZiB0cnVlLCB0aGUgbGlzdGVuZXIgd2lsbCByZW1vdmUgaXRzZWxmIGFmdGVyIHRoZSBmaXJzdCB0aW1lIGl0IGlzIHRyaWdnZXJlZC5cclxuXHQgKiBAcGFyYW0geyp9IFtkYXRhXSBBcmJpdHJhcnkgZGF0YSB0aGF0IHdpbGwgYmUgaW5jbHVkZWQgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgd2hlbiB0aGUgbGlzdGVuZXIgaXMgY2FsbGVkLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmU9ZmFsc2VdIEZvciBldmVudHMgdGhhdCBidWJibGUsIGluZGljYXRlcyB3aGV0aGVyIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50IGluIHRoZSBjYXB0dXJlIG9yIGJ1YmJsaW5nL3RhcmdldCBwaGFzZS5cclxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYW5vbnltb3VzIGZ1bmN0aW9uIHRoYXQgd2FzIGNyZWF0ZWQgYW5kIGFzc2lnbmVkIGFzIHRoZSBsaXN0ZW5lci4gVGhpcyBpcyBuZWVkZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBsYXRlciB1c2luZyAucmVtb3ZlRXZlbnRMaXN0ZW5lci5cclxuXHQgKiovXHJcblx0cC5vbiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCBzY29wZSwgb25jZSwgZGF0YSwgdXNlQ2FwdHVyZSkge1xyXG5cdFx0aWYgKGxpc3RlbmVyLmhhbmRsZUV2ZW50KSB7XHJcblx0XHRcdHNjb3BlID0gc2NvcGV8fGxpc3RlbmVyO1xyXG5cdFx0XHRsaXN0ZW5lciA9IGxpc3RlbmVyLmhhbmRsZUV2ZW50O1xyXG5cdFx0fVxyXG5cdFx0c2NvcGUgPSBzY29wZXx8dGhpcztcclxuXHRcdHJldHVybiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZnVuY3Rpb24oZXZ0KSB7XHJcblx0XHRcdFx0bGlzdGVuZXIuY2FsbChzY29wZSwgZXZ0LCBkYXRhKTtcclxuXHRcdFx0XHRvbmNlJiZldnQucmVtb3ZlKCk7XHJcblx0XHRcdH0sIHVzZUNhcHR1cmUpO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBldmVudCBsaXN0ZW5lci5cclxuXHQgKlxyXG5cdCAqIDxiPkltcG9ydGFudCBOb3RlOjwvYj4gdGhhdCB5b3UgbXVzdCBwYXNzIHRoZSBleGFjdCBmdW5jdGlvbiByZWZlcmVuY2UgdXNlZCB3aGVuIHRoZSBldmVudCB3YXMgYWRkZWQuIElmIGEgcHJveHlcclxuXHQgKiBmdW5jdGlvbiwgb3IgZnVuY3Rpb24gY2xvc3VyZSBpcyB1c2VkIGFzIHRoZSBjYWxsYmFjaywgdGhlIHByb3h5L2Nsb3N1cmUgcmVmZXJlbmNlIG11c3QgYmUgdXNlZCAtIGEgbmV3IHByb3h5IG9yXHJcblx0ICogY2xvc3VyZSB3aWxsIG5vdCB3b3JrLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljayk7XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIHJlbW92ZUV2ZW50TGlzdGVuZXJcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb24gfCBPYmplY3R9IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiBvciBvYmplY3QuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZV0gRm9yIGV2ZW50cyB0aGF0IGJ1YmJsZSwgaW5kaWNhdGVzIHdoZXRoZXIgdG8gbGlzdGVuIGZvciB0aGUgZXZlbnQgaW4gdGhlIGNhcHR1cmUgb3IgYnViYmxpbmcvdGFyZ2V0IHBoYXNlLlxyXG5cdCAqKi9cclxuXHRwLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xyXG5cdFx0dmFyIGxpc3RlbmVycyA9IHVzZUNhcHR1cmUgPyB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzIDogdGhpcy5fbGlzdGVuZXJzO1xyXG5cdFx0aWYgKCFsaXN0ZW5lcnMpIHsgcmV0dXJuOyB9XHJcblx0XHR2YXIgYXJyID0gbGlzdGVuZXJzW3R5cGVdO1xyXG5cdFx0aWYgKCFhcnIpIHsgcmV0dXJuOyB9XHJcblx0XHRmb3IgKHZhciBpPTAsbD1hcnIubGVuZ3RoOyBpPGw7IGkrKykge1xyXG5cdFx0XHRpZiAoYXJyW2ldID09IGxpc3RlbmVyKSB7XHJcblx0XHRcdFx0aWYgKGw9PTEpIHsgZGVsZXRlKGxpc3RlbmVyc1t0eXBlXSk7IH0gLy8gYWxsb3dzIGZvciBmYXN0ZXIgY2hlY2tzLlxyXG5cdFx0XHRcdGVsc2UgeyBhcnIuc3BsaWNlKGksMSk7IH1cclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogQSBzaG9ydGN1dCB0byB0aGUgcmVtb3ZlRXZlbnRMaXN0ZW5lciBtZXRob2QsIHdpdGggdGhlIHNhbWUgcGFyYW1ldGVycyBhbmQgcmV0dXJuIHZhbHVlLiBUaGlzIGlzIGEgY29tcGFuaW9uIHRvIHRoZVxyXG5cdCAqIC5vbiBtZXRob2QuXHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIG9mZlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbiB8IE9iamVjdH0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIG9yIG9iamVjdC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXHJcblx0ICoqL1xyXG5cdHAub2ZmID0gcC5yZW1vdmVFdmVudExpc3RlbmVyO1xyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgdHlwZSwgb3IgYWxsIGxpc3RlbmVycyBvZiBhbGwgdHlwZXMuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzXHJcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7XHJcblx0ICpcclxuXHQgKiAgICAgIC8vIFJlbW92ZSBhbGwgY2xpY2sgbGlzdGVuZXJzXHJcblx0ICogICAgICBkaXNwbGF5T2JqZWN0LnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKFwiY2xpY2tcIik7XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LiBJZiBvbWl0dGVkLCBhbGwgbGlzdGVuZXJzIGZvciBhbGwgdHlwZXMgd2lsbCBiZSByZW1vdmVkLlxyXG5cdCAqKi9cclxuXHRwLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0aWYgKCF0eXBlKSB7IHRoaXMuX2xpc3RlbmVycyA9IHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMgPSBudWxsOyB9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0aWYgKHRoaXMuX2xpc3RlbmVycykgeyBkZWxldGUodGhpcy5fbGlzdGVuZXJzW3R5cGVdKTsgfVxyXG5cdFx0XHRpZiAodGhpcy5fY2FwdHVyZUxpc3RlbmVycykgeyBkZWxldGUodGhpcy5fY2FwdHVyZUxpc3RlbmVyc1t0eXBlXSk7IH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBEaXNwYXRjaGVzIHRoZSBzcGVjaWZpZWQgZXZlbnQgdG8gYWxsIGxpc3RlbmVycy5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgLy8gVXNlIGEgc3RyaW5nIGV2ZW50XHJcblx0ICogICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKTtcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gVXNlIGFuIEV2ZW50IGluc3RhbmNlXHJcblx0ICogICAgICB2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJwcm9ncmVzc1wiKTtcclxuXHQgKiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGRpc3BhdGNoRXZlbnRcclxuXHQgKiBAcGFyYW0ge09iamVjdCB8IFN0cmluZyB8IEV2ZW50fSBldmVudE9iaiBBbiBvYmplY3Qgd2l0aCBhIFwidHlwZVwiIHByb3BlcnR5LCBvciBhIHN0cmluZyB0eXBlLlxyXG5cdCAqIFdoaWxlIGEgZ2VuZXJpYyBvYmplY3Qgd2lsbCB3b3JrLCBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYSBDcmVhdGVKUyBFdmVudCBpbnN0YW5jZS4gSWYgYSBzdHJpbmcgaXMgdXNlZCxcclxuXHQgKiBkaXNwYXRjaEV2ZW50IHdpbGwgY29uc3RydWN0IGFuIEV2ZW50IGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCB0eXBlLlxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdGhlIHZhbHVlIG9mIGV2ZW50T2JqLmRlZmF1bHRQcmV2ZW50ZWQuXHJcblx0ICoqL1xyXG5cdHAuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50T2JqKSB7XHJcblx0XHRpZiAodHlwZW9mIGV2ZW50T2JqID09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0Ly8gd29uJ3QgYnViYmxlLCBzbyBza2lwIGV2ZXJ5dGhpbmcgaWYgdGhlcmUncyBubyBsaXN0ZW5lcnM6XHJcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcblx0XHRcdGlmICghbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnNbZXZlbnRPYmpdKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHRldmVudE9iaiA9IG5ldyBjcmVhdGVqcy5FdmVudChldmVudE9iaik7XHJcblx0XHR9IGVsc2UgaWYgKGV2ZW50T2JqLnRhcmdldCAmJiBldmVudE9iai5jbG9uZSkge1xyXG5cdFx0XHQvLyByZWRpc3BhdGNoaW5nIGFuIGFjdGl2ZSBldmVudCBvYmplY3QsIHNvIGNsb25lIGl0OlxyXG5cdFx0XHRldmVudE9iaiA9IGV2ZW50T2JqLmNsb25lKCk7XHJcblx0XHR9XHJcblx0XHR0cnkgeyBldmVudE9iai50YXJnZXQgPSB0aGlzOyB9IGNhdGNoIChlKSB7fSAvLyB0cnkvY2F0Y2ggYWxsb3dzIHJlZGlzcGF0Y2hpbmcgb2YgbmF0aXZlIGV2ZW50c1xyXG5cclxuXHRcdGlmICghZXZlbnRPYmouYnViYmxlcyB8fCAhdGhpcy5wYXJlbnQpIHtcclxuXHRcdFx0dGhpcy5fZGlzcGF0Y2hFdmVudChldmVudE9iaiwgMik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgdG9wPXRoaXMsIGxpc3Q9W3RvcF07XHJcblx0XHRcdHdoaWxlICh0b3AucGFyZW50KSB7IGxpc3QucHVzaCh0b3AgPSB0b3AucGFyZW50KTsgfVxyXG5cdFx0XHR2YXIgaSwgbD1saXN0Lmxlbmd0aDtcclxuXHJcblx0XHRcdC8vIGNhcHR1cmUgJiBhdFRhcmdldFxyXG5cdFx0XHRmb3IgKGk9bC0xOyBpPj0wICYmICFldmVudE9iai5wcm9wYWdhdGlvblN0b3BwZWQ7IGktLSkge1xyXG5cdFx0XHRcdGxpc3RbaV0uX2Rpc3BhdGNoRXZlbnQoZXZlbnRPYmosIDErKGk9PTApKTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBidWJibGluZ1xyXG5cdFx0XHRmb3IgKGk9MTsgaTxsICYmICFldmVudE9iai5wcm9wYWdhdGlvblN0b3BwZWQ7IGkrKykge1xyXG5cdFx0XHRcdGxpc3RbaV0uX2Rpc3BhdGNoRXZlbnQoZXZlbnRPYmosIDMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZXZlbnRPYmouZGVmYXVsdFByZXZlbnRlZDtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZS5cclxuXHQgKiBAbWV0aG9kIGhhc0V2ZW50TGlzdGVuZXJcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXHJcblx0ICoqL1xyXG5cdHAuaGFzRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMsIGNhcHR1cmVMaXN0ZW5lcnMgPSB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzO1xyXG5cdFx0cmV0dXJuICEhKChsaXN0ZW5lcnMgJiYgbGlzdGVuZXJzW3R5cGVdKSB8fCAoY2FwdHVyZUxpc3RlbmVycyAmJiBjYXB0dXJlTGlzdGVuZXJzW3R5cGVdKSk7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZSBvbiB0aGlzIG9iamVjdCBvciBhbnkgb2YgaXRzXHJcblx0ICogYW5jZXN0b3JzIChwYXJlbnQsIHBhcmVudCdzIHBhcmVudCwgZXRjKS4gQSByZXR1cm4gdmFsdWUgb2YgdHJ1ZSBpbmRpY2F0ZXMgdGhhdCBpZiBhIGJ1YmJsaW5nIGV2ZW50IG9mIHRoZVxyXG5cdCAqIHNwZWNpZmllZCB0eXBlIGlzIGRpc3BhdGNoZWQgZnJvbSB0aGlzIG9iamVjdCwgaXQgd2lsbCB0cmlnZ2VyIGF0IGxlYXN0IG9uZSBsaXN0ZW5lci5cclxuXHQgKiBcclxuXHQgKiBUaGlzIGlzIHNpbWlsYXIgdG8ge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL2hhc0V2ZW50TGlzdGVuZXJcIn19e3svY3Jvc3NMaW5rfX0sIGJ1dCBpdCBzZWFyY2hlcyB0aGUgZW50aXJlXHJcblx0ICogZXZlbnQgZmxvdyBmb3IgYSBsaXN0ZW5lciwgbm90IGp1c3QgdGhpcyBvYmplY3QuXHJcblx0ICogQG1ldGhvZCB3aWxsVHJpZ2dlclxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxyXG5cdCAqKi9cclxuXHRwLndpbGxUcmlnZ2VyID0gZnVuY3Rpb24odHlwZSkge1xyXG5cdFx0dmFyIG8gPSB0aGlzO1xyXG5cdFx0d2hpbGUgKG8pIHtcclxuXHRcdFx0aWYgKG8uaGFzRXZlbnRMaXN0ZW5lcih0eXBlKSkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cdFx0XHRvID0gby5wYXJlbnQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQG1ldGhvZCB0b1N0cmluZ1xyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGluc3RhbmNlLlxyXG5cdCAqKi9cclxuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gXCJbRXZlbnREaXNwYXRjaGVyXVwiO1xyXG5cdH07XHJcblxyXG5cclxuLy8gcHJpdmF0ZSBtZXRob2RzOlxyXG5cdC8qKlxyXG5cdCAqIEBtZXRob2QgX2Rpc3BhdGNoRXZlbnRcclxuXHQgKiBAcGFyYW0ge09iamVjdCB8IFN0cmluZyB8IEV2ZW50fSBldmVudE9ialxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFBoYXNlXHJcblx0ICogQHByb3RlY3RlZFxyXG5cdCAqKi9cclxuXHRwLl9kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnRPYmosIGV2ZW50UGhhc2UpIHtcclxuXHRcdHZhciBsLCBsaXN0ZW5lcnMgPSAoZXZlbnRQaGFzZT09MSkgPyB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzIDogdGhpcy5fbGlzdGVuZXJzO1xyXG5cdFx0aWYgKGV2ZW50T2JqICYmIGxpc3RlbmVycykge1xyXG5cdFx0XHR2YXIgYXJyID0gbGlzdGVuZXJzW2V2ZW50T2JqLnR5cGVdO1xyXG5cdFx0XHRpZiAoIWFycnx8IShsPWFyci5sZW5ndGgpKSB7IHJldHVybjsgfVxyXG5cdFx0XHR0cnkgeyBldmVudE9iai5jdXJyZW50VGFyZ2V0ID0gdGhpczsgfSBjYXRjaCAoZSkge31cclxuXHRcdFx0dHJ5IHsgZXZlbnRPYmouZXZlbnRQaGFzZSA9IGV2ZW50UGhhc2U7IH0gY2F0Y2ggKGUpIHt9XHJcblx0XHRcdGV2ZW50T2JqLnJlbW92ZWQgPSBmYWxzZTtcclxuXHRcdFx0XHJcblx0XHRcdGFyciA9IGFyci5zbGljZSgpOyAvLyB0byBhdm9pZCBpc3N1ZXMgd2l0aCBpdGVtcyBiZWluZyByZW1vdmVkIG9yIGFkZGVkIGR1cmluZyB0aGUgZGlzcGF0Y2hcclxuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGwgJiYgIWV2ZW50T2JqLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIG8gPSBhcnJbaV07XHJcblx0XHRcdFx0aWYgKG8uaGFuZGxlRXZlbnQpIHsgby5oYW5kbGVFdmVudChldmVudE9iaik7IH1cclxuXHRcdFx0XHRlbHNlIHsgbyhldmVudE9iaik7IH1cclxuXHRcdFx0XHRpZiAoZXZlbnRPYmoucmVtb3ZlZCkge1xyXG5cdFx0XHRcdFx0dGhpcy5vZmYoZXZlbnRPYmoudHlwZSwgbywgZXZlbnRQaGFzZT09MSk7XHJcblx0XHRcdFx0XHRldmVudE9iai5yZW1vdmVkID0gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblxyXG5cdGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlciA9IEV2ZW50RGlzcGF0Y2hlcjtcclxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFByb2dyZXNzRXZlbnQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKHNjb3BlKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIENyZWF0ZUpTIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZGlzcGF0Y2hlZCB3aGVuIHByb2dyZXNzIGNoYW5nZXMuXG5cdCAqIEBjbGFzcyBQcm9ncmVzc0V2ZW50XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsb2FkZWQgVGhlIGFtb3VudCB0aGF0IGhhcyBiZWVuIGxvYWRlZC4gVGhpcyBjYW4gYmUgYW55IG51bWJlciByZWxhdGl2ZSB0byB0aGUgdG90YWwuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdG90YWw9MV0gVGhlIHRvdGFsIGFtb3VudCB0aGF0IHdpbGwgbG9hZC4gVGhpcyB3aWxsIGRlZmF1bHQgdG8gMSwgc28gaWYgdGhlIGBsb2FkZWRgIHZhbHVlIGlzXG5cdCAqIGEgcGVyY2VudGFnZSAoYmV0d2VlbiAwIGFuZCAxKSwgaXQgY2FuIGJlIG9taXR0ZWQuXG5cdCAqIEB0b2RvIENvbnNpZGVyIGhhdmluZyB0aGlzIGV2ZW50IGJlIGEgXCJmaWxlcHJvZ3Jlc3NcIiBldmVudCBhcyB3ZWxsXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gUHJvZ3Jlc3NFdmVudChsb2FkZWQsIHRvdGFsKSB7XG5cdFx0dGhpcy5FdmVudF9jb25zdHJ1Y3RvcihcInByb2dyZXNzXCIpO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGFtb3VudCB0aGF0IGhhcyBiZWVuIGxvYWRlZCAob3V0IG9mIGEgdG90YWwgYW1vdW50KVxuXHRcdCAqIEBwcm9wZXJ0eSBsb2FkZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMubG9hZGVkID0gbG9hZGVkO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRvdGFsIFwic2l6ZVwiIG9mIHRoZSBsb2FkLlxuXHRcdCAqIEBwcm9wZXJ0eSB0b3RhbFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqL1xuXHRcdHRoaXMudG90YWwgPSAodG90YWwgPT0gbnVsbCkgPyAxIDogdG90YWw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgcGVyY2VudGFnZSAob3V0IG9mIDEpIHRoYXQgdGhlIGxvYWQgaGFzIGJlZW4gY29tcGxldGVkLiBUaGlzIGlzIGNhbGN1bGF0ZWQgdXNpbmcgYGxvYWRlZC90b3RhbGAuXG5cdFx0ICogQHByb3BlcnR5IHByb2dyZXNzXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICovXG5cdFx0dGhpcy5wcm9ncmVzcyA9ICh0b3RhbCA9PSAwKSA/IDAgOiB0aGlzLmxvYWRlZCAvIHRoaXMudG90YWw7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoUHJvZ3Jlc3NFdmVudCwgY3JlYXRlanMuRXZlbnQpO1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIFByb2dyZXNzRXZlbnQgaW5zdGFuY2UuXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHJldHVybiB7UHJvZ3Jlc3NFdmVudH0gYSBjbG9uZSBvZiB0aGUgRXZlbnQgaW5zdGFuY2UuXG5cdCAqKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgY3JlYXRlanMuUHJvZ3Jlc3NFdmVudCh0aGlzLmxvYWRlZCwgdGhpcy50b3RhbCk7XG5cdH07XG5cblx0Y3JlYXRlanMuUHJvZ3Jlc3NFdmVudCA9IGNyZWF0ZWpzLnByb21vdGUoUHJvZ3Jlc3NFdmVudCwgXCJFdmVudFwiKTtcblxufSh3aW5kb3cpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIGpzb24zLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG4vKiEgSlNPTiB2My4zLjIgfCBodHRwOi8vYmVzdGllanMuZ2l0aHViLmlvL2pzb24zIHwgQ29weXJpZ2h0IDIwMTItMjAxNCwgS2l0IENhbWJyaWRnZSB8IGh0dHA6Ly9raXQubWl0LWxpY2Vuc2Uub3JnICovXG47KGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXG4gIC8vIHN0cmljdCBgZGVmaW5lYCBjaGVjayBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBgci5qc2AuXG4gIHZhciBpc0xvYWRlciA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kO1xuXG4gIC8vIEEgc2V0IG9mIHR5cGVzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggb2JqZWN0cyBmcm9tIHByaW1pdGl2ZXMuXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgXCJvYmplY3RcIjogdHJ1ZVxuICB9O1xuXG4gIC8vIERldGVjdCB0aGUgYGV4cG9ydHNgIG9iamVjdCBleHBvc2VkIGJ5IENvbW1vbkpTIGltcGxlbWVudGF0aW9ucy5cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvLyBVc2UgdGhlIGBnbG9iYWxgIG9iamVjdCBleHBvc2VkIGJ5IE5vZGUgKGluY2x1ZGluZyBCcm93c2VyaWZ5IHZpYVxuICAvLyBgaW5zZXJ0LW1vZHVsZS1nbG9iYWxzYCksIE5hcndoYWwsIGFuZCBSaW5nbyBhcyB0aGUgZGVmYXVsdCBjb250ZXh0LFxuICAvLyBhbmQgdGhlIGB3aW5kb3dgIG9iamVjdCBpbiBicm93c2Vycy4gUmhpbm8gZXhwb3J0cyBhIGBnbG9iYWxgIGZ1bmN0aW9uXG4gIC8vIGluc3RlYWQuXG4gIHZhciByb290ID0gb2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93IHx8IHRoaXMsXG4gICAgICBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgdHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbDtcblxuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbFtcImdsb2JhbFwiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wid2luZG93XCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJzZWxmXCJdID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLy8gUHVibGljOiBJbml0aWFsaXplcyBKU09OIDMgdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QsIGF0dGFjaGluZyB0aGVcbiAgLy8gYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgZnVuY3Rpb25zIHRvIHRoZSBzcGVjaWZpZWQgYGV4cG9ydHNgIG9iamVjdC5cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQsIGV4cG9ydHMpIHtcbiAgICBjb250ZXh0IHx8IChjb250ZXh0ID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcbiAgICBleHBvcnRzIHx8IChleHBvcnRzID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcblxuICAgIC8vIE5hdGl2ZSBjb25zdHJ1Y3RvciBhbGlhc2VzLlxuICAgIHZhciBOdW1iZXIgPSBjb250ZXh0W1wiTnVtYmVyXCJdIHx8IHJvb3RbXCJOdW1iZXJcIl0sXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHRbXCJTdHJpbmdcIl0gfHwgcm9vdFtcIlN0cmluZ1wiXSxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dFtcIk9iamVjdFwiXSB8fCByb290W1wiT2JqZWN0XCJdLFxuICAgICAgICBEYXRlID0gY29udGV4dFtcIkRhdGVcIl0gfHwgcm9vdFtcIkRhdGVcIl0sXG4gICAgICAgIFN5bnRheEVycm9yID0gY29udGV4dFtcIlN5bnRheEVycm9yXCJdIHx8IHJvb3RbXCJTeW50YXhFcnJvclwiXSxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dFtcIlR5cGVFcnJvclwiXSB8fCByb290W1wiVHlwZUVycm9yXCJdLFxuICAgICAgICBNYXRoID0gY29udGV4dFtcIk1hdGhcIl0gfHwgcm9vdFtcIk1hdGhcIl0sXG4gICAgICAgIG5hdGl2ZUpTT04gPSBjb250ZXh0W1wiSlNPTlwiXSB8fCByb290W1wiSlNPTlwiXTtcblxuICAgIC8vIERlbGVnYXRlIHRvIHRoZSBuYXRpdmUgYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgaW1wbGVtZW50YXRpb25zLlxuICAgIGlmICh0eXBlb2YgbmF0aXZlSlNPTiA9PSBcIm9iamVjdFwiICYmIG5hdGl2ZUpTT04pIHtcbiAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gbmF0aXZlSlNPTi5zdHJpbmdpZnk7XG4gICAgICBleHBvcnRzLnBhcnNlID0gbmF0aXZlSlNPTi5wYXJzZTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBhbGlhc2VzLlxuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIGdldENsYXNzID0gb2JqZWN0UHJvdG8udG9TdHJpbmcsXG4gICAgICAgIGlzUHJvcGVydHksIGZvckVhY2gsIHVuZGVmO1xuXG4gICAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxuICAgIHZhciBpc0V4dGVuZGVkID0gbmV3IERhdGUoLTM1MDk4MjczMzQ1NzMyOTIpO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxuICAgICAgLy8gcmVzdWx0cyBmb3IgY2VydGFpbiBkYXRlcyBpbiBPcGVyYSA+PSAxMC41My5cbiAgICAgIGlzRXh0ZW5kZWQgPSBpc0V4dGVuZGVkLmdldFVUQ0Z1bGxZZWFyKCkgPT0gLTEwOTI1MiAmJiBpc0V4dGVuZGVkLmdldFVUQ01vbnRoKCkgPT09IDAgJiYgaXNFeHRlbmRlZC5nZXRVVENEYXRlKCkgPT09IDEgJiZcbiAgICAgICAgLy8gU2FmYXJpIDwgMi4wLjIgc3RvcmVzIHRoZSBpbnRlcm5hbCBtaWxsaXNlY29uZCB0aW1lIHZhbHVlIGNvcnJlY3RseSxcbiAgICAgICAgLy8gYnV0IGNsaXBzIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGRhdGUgbWV0aG9kcyB0byB0aGUgcmFuZ2Ugb2ZcbiAgICAgICAgLy8gc2lnbmVkIDMyLWJpdCBpbnRlZ2VycyAoWy0yICoqIDMxLCAyICoqIDMxIC0gMV0pLlxuICAgICAgICBpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCkgPT0gMTAgJiYgaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCkgPT0gMzcgJiYgaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCkgPT0gNiAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpID09IDcwODtcbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cbiAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBuYXRpdmUgYEpTT04uc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxuICAgIC8vIGltcGxlbWVudGF0aW9ucyBhcmUgc3BlYy1jb21wbGlhbnQuIEJhc2VkIG9uIHdvcmsgYnkgS2VuIFNueWRlci5cbiAgICBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgICAgaWYgKGhhc1tuYW1lXSAhPT0gdW5kZWYpIHtcbiAgICAgICAgLy8gUmV0dXJuIGNhY2hlZCBmZWF0dXJlIHRlc3QgcmVzdWx0LlxuICAgICAgICByZXR1cm4gaGFzW25hbWVdO1xuICAgICAgfVxuICAgICAgdmFyIGlzU3VwcG9ydGVkO1xuICAgICAgaWYgKG5hbWUgPT0gXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIikge1xuICAgICAgICAvLyBJRSA8PSA3IGRvZXNuJ3Qgc3VwcG9ydCBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgdXNpbmcgc3F1YXJlXG4gICAgICAgIC8vIGJyYWNrZXQgbm90YXRpb24uIElFIDggb25seSBzdXBwb3J0cyB0aGlzIGZvciBwcmltaXRpdmVzLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IFwiYVwiWzBdICE9IFwiYVwiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwianNvblwiKSB7XG4gICAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIGJvdGggYEpTT04uc3RyaW5naWZ5YCBhbmQgYEpTT04ucGFyc2VgIGFyZVxuICAgICAgICAvLyBzdXBwb3J0ZWQuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gaGFzKFwianNvbi1zdHJpbmdpZnlcIikgJiYgaGFzKFwianNvbi1wYXJzZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSwgc2VyaWFsaXplZCA9ICd7XCJhXCI6WzEsdHJ1ZSxmYWxzZSxudWxsLFwiXFxcXHUwMDAwXFxcXGJcXFxcblxcXFxmXFxcXHJcXFxcdFwiXX0nO1xuICAgICAgICAvLyBUZXN0IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1zdHJpbmdpZnlcIikge1xuICAgICAgICAgIHZhciBzdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSwgc3RyaW5naWZ5U3VwcG9ydGVkID0gdHlwZW9mIHN0cmluZ2lmeSA9PSBcImZ1bmN0aW9uXCIgJiYgaXNFeHRlbmRlZDtcbiAgICAgICAgICBpZiAoc3RyaW5naWZ5U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAvLyBBIHRlc3QgZnVuY3Rpb24gb2JqZWN0IHdpdGggYSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kLlxuICAgICAgICAgICAgKHZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0pLnRvSlNPTiA9IHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID1cbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDMuMWIxIGFuZCBiMiBzZXJpYWxpemUgc3RyaW5nLCBudW1iZXIsIGFuZCBib29sZWFuXG4gICAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlcyBhcyBvYmplY3QgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KDApID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiwgYW5kIEpTT04gMiBzZXJpYWxpemUgd3JhcHBlZCBwcmltaXRpdmVzIGFzIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgTnVtYmVyKCkpID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgU3RyaW5nKCkpID09ICdcIlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAsIGB1bmRlZmluZWRgLCBvclxuICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggYHRvSlNPTmAgcHJvcGVydGllcyBhcyB3ZWxsLCAqdW5sZXNzKiB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyB3aXRoaW4gYW4gb2JqZWN0IG9yIGFycmF5KS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIElFIDggc2VyaWFsaXplcyBgdW5kZWZpbmVkYCBhcyBgXCJ1bmRlZmluZWRcImAuIFNhZmFyaSA8PSA1LjEuNyBhbmRcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMyBwYXNzIHRoaXMgdGVzdC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNyBhbmQgRkYgMy4xYjMgdGhyb3cgYEVycm9yYHMgYW5kIGBUeXBlRXJyb3JgcyxcbiAgICAgICAgICAgICAgICAvLyByZXNwZWN0aXZlbHksIGlmIHRoZSB2YWx1ZSBpcyBvbWl0dGVkIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBudW1iZXIsXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nLCBhcnJheSwgb2JqZWN0LCBCb29sZWFuLCBvciBgbnVsbGAgbGl0ZXJhbC4gVGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyBpbnNpZGUgb2JqZWN0IG9yIGFycmF5IGxpdGVyYWxzLiBZVUkgMy4wLjBiMSBpZ25vcmVzIGN1c3RvbSBgdG9KU09OYFxuICAgICAgICAgICAgICAgIC8vIG1ldGhvZHMgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3ZhbHVlXSkgPT0gXCJbMV1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBzZXJpYWxpemVzIGBbdW5kZWZpbmVkXWAgYXMgYFwiW11cImAgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgIC8vIGBcIltudWxsXVwiYC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmXSkgPT0gXCJbbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFlVSSAzLjAuMGIxIGZhaWxzIHRvIHNlcmlhbGl6ZSBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwpID09IFwibnVsbFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgaGFsdHMgc2VyaWFsaXphdGlvbiBpZiBhbiBhcnJheSBjb250YWlucyBhIGZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgIC8vIGBbMSwgdHJ1ZSwgZ2V0Q2xhc3MsIDFdYCBzZXJpYWxpemVzIGFzIFwiWzEsdHJ1ZSxdLFwiLiBGRiAzLjFiM1xuICAgICAgICAgICAgICAgIC8vIGVsaWRlcyBub24tSlNPTiB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXMsIHVubGVzcyB0aGV5XG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWYsIGdldENsYXNzLCBudWxsXSkgPT0gXCJbbnVsbCxudWxsLG51bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAgIC8vIHdoZXJlIGNoYXJhY3RlciBlc2NhcGUgY29kZXMgYXJlIGV4cGVjdGVkIChlLmcuLCBgXFxiYCA9PiBgXFx1MDAwOGApLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh7IFwiYVwiOiBbdmFsdWUsIHRydWUsIGZhbHNlLCBudWxsLCBcIlxceDAwXFxiXFxuXFxmXFxyXFx0XCJdIH0pID09IHNlcmlhbGl6ZWQgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwsIHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoWzEsIDJdLCBudWxsLCAxKSA9PSBcIltcXG4gMSxcXG4gMlxcbl1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIEpTT04gMiwgUHJvdG90eXBlIDw9IDEuNywgYW5kIG9sZGVyIFdlYktpdCBidWlsZHMgaW5jb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyBzZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC04LjY0ZTE1KSkgPT0gJ1wiLTI3MTgyMS0wNC0yMFQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNSwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoOC42NGUxNSkpID09ICdcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggPD0gMTEuMCBpbmNvcnJlY3RseSBzZXJpYWxpemVzIHllYXJzIHByaW9yIHRvIDAgYXMgbmVnYXRpdmVcbiAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IHllYXJzIGluc3RlYWQgb2Ygc2l4LWRpZ2l0IHllYXJzLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtNjIxOTg3NTUyZTUpKSA9PSAnXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjUgYW5kIE9wZXJhID49IDEwLjUzIGluY29ycmVjdGx5IHNlcmlhbGl6ZSBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBsZXNzIHRoYW4gMTAwMC4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTEpKSA9PSAnXCIxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVpcIic7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gc3RyaW5naWZ5U3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlc3QgYEpTT04ucGFyc2VgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tcGFyc2VcIikge1xuICAgICAgICAgIHZhciBwYXJzZSA9IGV4cG9ydHMucGFyc2U7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhIGJhcmUgbGl0ZXJhbCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLy8gQ29uZm9ybWluZyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGFsc28gY29lcmNlIHRoZSBpbml0aWFsIGFyZ3VtZW50IHRvXG4gICAgICAgICAgICAgIC8vIGEgc3RyaW5nIHByaW9yIHRvIHBhcnNpbmcuXG4gICAgICAgICAgICAgIGlmIChwYXJzZShcIjBcIikgPT09IDAgJiYgIXBhcnNlKGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBwYXJzaW5nIHRlc3QuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZShzZXJpYWxpemVkKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VTdXBwb3J0ZWQgPSB2YWx1ZVtcImFcIl0ubGVuZ3RoID09IDUgJiYgdmFsdWVbXCJhXCJdWzBdID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS4yIGFuZCBGRiAzLjFiMSBhbGxvdyB1bmVzY2FwZWQgdGFicyBpbiBzdHJpbmdzLlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9ICFwYXJzZSgnXCJcXHRcIicpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wIGFuZCA0LjAuMSBhbGxvdyBsZWFkaW5nIGArYCBzaWducyBhbmQgbGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgcG9pbnRzLiBGRiA0LjAsIDQuMC4xLCBhbmQgSUUgOS0xMCBhbHNvIGFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMDFcIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCwgNC4wLjEsIGFuZCBSaGlubyAxLjdSMy1SNCBhbGxvdyB0cmFpbGluZyBkZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzLiBUaGVzZSBlbnZpcm9ubWVudHMsIGFsb25nIHdpdGggRkYgMy4xYjEgYW5kIDIsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyBhbGxvdyB0cmFpbGluZyBjb21tYXMgaW4gSlNPTiBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjEuXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBwYXJzZVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1tuYW1lXSA9ICEhaXNTdXBwb3J0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFoYXMoXCJqc29uXCIpKSB7XG4gICAgICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxuICAgICAgdmFyIGZ1bmN0aW9uQ2xhc3MgPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsXG4gICAgICAgICAgZGF0ZUNsYXNzID0gXCJbb2JqZWN0IERhdGVdXCIsXG4gICAgICAgICAgbnVtYmVyQ2xhc3MgPSBcIltvYmplY3QgTnVtYmVyXVwiLFxuICAgICAgICAgIHN0cmluZ0NsYXNzID0gXCJbb2JqZWN0IFN0cmluZ11cIixcbiAgICAgICAgICBhcnJheUNsYXNzID0gXCJbb2JqZWN0IEFycmF5XVwiLFxuICAgICAgICAgIGJvb2xlYW5DbGFzcyA9IFwiW29iamVjdCBCb29sZWFuXVwiO1xuXG4gICAgICAvLyBEZXRlY3QgaW5jb21wbGV0ZSBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXguXG4gICAgICB2YXIgY2hhckluZGV4QnVnZ3kgPSBoYXMoXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIik7XG5cbiAgICAgIC8vIERlZmluZSBhZGRpdGlvbmFsIHV0aWxpdHkgbWV0aG9kcyBpZiB0aGUgYERhdGVgIG1ldGhvZHMgYXJlIGJ1Z2d5LlxuICAgICAgaWYgKCFpc0V4dGVuZGVkKSB7XG4gICAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgICAgIC8vIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBtb250aHMgb2YgdGhlIHllYXIgYW5kIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuXG4gICAgICAgIC8vIEphbnVhcnkgMXN0IGFuZCB0aGUgZmlyc3Qgb2YgdGhlIHJlc3BlY3RpdmUgbW9udGguXG4gICAgICAgIHZhciBNb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdO1xuICAgICAgICAvLyBJbnRlcm5hbDogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aGUgVW5peCBlcG9jaCBhbmQgdGhlXG4gICAgICAgIC8vIGZpcnN0IGRheSBvZiB0aGUgZ2l2ZW4gbW9udGguXG4gICAgICAgIHZhciBnZXREYXkgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICByZXR1cm4gTW9udGhzW21vbnRoXSArIDM2NSAqICh5ZWFyIC0gMTk3MCkgKyBmbG9vcigoeWVhciAtIDE5NjkgKyAobW9udGggPSArKG1vbnRoID4gMSkpKSAvIDQpIC0gZmxvb3IoKHllYXIgLSAxOTAxICsgbW9udGgpIC8gMTAwKSArIGZsb29yKCh5ZWFyIC0gMTYwMSArIG1vbnRoKSAvIDQwMCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXG4gICAgICAvLyBvYmplY3QuIERlbGVnYXRlcyB0byB0aGUgbmF0aXZlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIG1ldGhvZC5cbiAgICAgIGlmICghKGlzUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eSkpIHtcbiAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGNvbnN0cnVjdG9yO1xuICAgICAgICAgIGlmICgobWVtYmVycy5fX3Byb3RvX18gPSBudWxsLCBtZW1iZXJzLl9fcHJvdG9fXyA9IHtcbiAgICAgICAgICAgIC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XG4gICAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBGaXJlZm94IGFuZCBTZWFNb25rZXkuXG4gICAgICAgICAgICBcInRvU3RyaW5nXCI6IDFcbiAgICAgICAgICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xuICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC4zIGRvZXNuJ3QgaW1wbGVtZW50IGBPYmplY3QjaGFzT3duUHJvcGVydHlgLCBidXRcbiAgICAgICAgICAgIC8vIHN1cHBvcnRzIHRoZSBtdXRhYmxlICpwcm90byogcHJvcGVydHkuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIC8vIENhcHR1cmUgYW5kIGJyZWFrIHRoZSBvYmplY3QncyBwcm90b3R5cGUgY2hhaW4gKHNlZSBzZWN0aW9uIDguNi4yXG4gICAgICAgICAgICAgIC8vIG9mIHRoZSBFUyA1LjEgc3BlYykuIFRoZSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb24gcHJldmVudHMgYW5cbiAgICAgICAgICAgICAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLl9fcHJvdG9fXywgcmVzdWx0ID0gcHJvcGVydHkgaW4gKHRoaXMuX19wcm90b19fID0gbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENhcHR1cmUgYSByZWZlcmVuY2UgdG8gdGhlIHRvcC1sZXZlbCBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gbWVtYmVycy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxuICAgICAgICAgICAgLy8gb3RoZXIgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgIShwcm9wZXJ0eSBpbiBwYXJlbnQgJiYgdGhpc1twcm9wZXJ0eV0gPT09IHBhcmVudFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVtYmVycyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGlzUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBOb3JtYWxpemVzIHRoZSBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBhbGdvcml0aG0gYWNyb3NzXG4gICAgICAvLyBlbnZpcm9ubWVudHMuIEVhY2ggZW51bWVyYXRlZCBrZXkgaXMgeWllbGRlZCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uXG4gICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNpemUgPSAwLCBQcm9wZXJ0aWVzLCBtZW1iZXJzLCBwcm9wZXJ0eTtcblxuICAgICAgICAvLyBUZXN0cyBmb3IgYnVncyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGBmb3IuLi5pbmAgYWxnb3JpdGhtLiBUaGVcbiAgICAgICAgLy8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cbiAgICAgICAgLy8gYE9iamVjdC5wcm90b3R5cGVgIGluIG9sZGVyIHZlcnNpb25zIG9mIElFLCBOZXRzY2FwZSwgYW5kIE1vemlsbGEuXG4gICAgICAgIChQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMudmFsdWVPZiA9IDA7XG4gICAgICAgIH0pLnByb3RvdHlwZS52YWx1ZU9mID0gMDtcblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cbiAgICAgICAgbWVtYmVycyA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gbWVtYmVycykge1xuICAgICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgaWYgKGlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUHJvcGVydGllcyA9IG1lbWJlcnMgPSBudWxsO1xuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgaXRlcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIG1lbWJlcnMgPSBbXCJ2YWx1ZU9mXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiLCBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsIFwiaXNQcm90b3R5cGVPZlwiLCBcImhhc093blByb3BlcnR5XCIsIFwiY29uc3RydWN0b3JcIl07XG4gICAgICAgICAgLy8gSUUgPD0gOCwgTW96aWxsYSAxLjAsIGFuZCBOZXRzY2FwZSA2LjIgaWdub3JlIHNoYWRvd2VkIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgICAgLy8gcHJvcGVydGllcy5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBsZW5ndGg7XG4gICAgICAgICAgICB2YXIgaGFzUHJvcGVydHkgPSAhaXNGdW5jdGlvbiAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yICE9IFwiZnVuY3Rpb25cIiAmJiBvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5XSAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkgfHwgaXNQcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIEdlY2tvIDw9IDEuMCBlbnVtZXJhdGVzIHRoZSBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgdW5kZXJcbiAgICAgICAgICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zOyBJRSBkb2VzIG5vdC5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciBlYWNoIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PSAyKSB7XG4gICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIFN0b3JlIGVhY2ggcHJvcGVydHkgbmFtZSB0byBwcmV2ZW50IGRvdWJsZSBlbnVtZXJhdGlvbi4gVGhlXG4gICAgICAgICAgICAgIC8vIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyBub3QgZW51bWVyYXRlZCBkdWUgdG8gY3Jvc3MtXG4gICAgICAgICAgICAgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiAhaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSAmJiAobWVtYmVyc1twcm9wZXJ0eV0gPSAxKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGJ1Z3MgZGV0ZWN0ZWQ7IHVzZSB0aGUgc3RhbmRhcmQgYGZvci4uLmluYCBhbGdvcml0aG0uXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgaXNDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBkdWUgdG9cbiAgICAgICAgICAgIC8vIGNyb3NzLWVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xuICAgICAgfTtcblxuICAgICAgLy8gUHVibGljOiBTZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBgdmFsdWVgIGFzIGEgSlNPTiBzdHJpbmcuIFRoZSBvcHRpb25hbFxuICAgICAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcbiAgICAgIC8vIGFycmF5IG1lbWJlcnMgYXJlIHNlcmlhbGl6ZWQsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIG51bWJlcnMgdGhhdFxuICAgICAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXG4gICAgICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAgIC8vIGxldmVsIG9mIHRoZSBvdXRwdXQuXG4gICAgICBpZiAoIWhhcyhcImpzb24tc3RyaW5naWZ5XCIpKSB7XG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBFc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcXFxcXCInLFxuICAgICAgICAgIDg6IFwiXFxcXGJcIixcbiAgICAgICAgICAxMjogXCJcXFxcZlwiLFxuICAgICAgICAgIDEwOiBcIlxcXFxuXCIsXG4gICAgICAgICAgMTM6IFwiXFxcXHJcIixcbiAgICAgICAgICA5OiBcIlxcXFx0XCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQ29udmVydHMgYHZhbHVlYCBpbnRvIGEgemVyby1wYWRkZWQgc3RyaW5nIHN1Y2ggdGhhdCBpdHNcbiAgICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cbiAgICAgICAgdmFyIGxlYWRpbmdaZXJvZXMgPSBcIjAwMDAwMFwiO1xuICAgICAgICB2YXIgdG9QYWRkZWRTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgsIHZhbHVlKSB7XG4gICAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiB3aGVyZSBgMCA9PSAtMGAsIGJ1dCBgU3RyaW5nKC0wKSAhPT0gXCIwXCJgLlxuICAgICAgICAgIHJldHVybiAobGVhZGluZ1plcm9lcyArICh2YWx1ZSB8fCAwKSkuc2xpY2UoLXdpZHRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogRG91YmxlLXF1b3RlcyBhIHN0cmluZyBgdmFsdWVgLCByZXBsYWNpbmcgYWxsIEFTQ0lJIGNvbnRyb2xcbiAgICAgICAgLy8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxuICAgICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgUXVvdGUodmFsdWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICB2YXIgdW5pY29kZVByZWZpeCA9IFwiXFxcXHUwMFwiO1xuICAgICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJ1wiJywgaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIHVzZUNoYXJJbmRleCA9ICFjaGFySW5kZXhCdWdneSB8fCBsZW5ndGggPiAxMDtcbiAgICAgICAgICB2YXIgc3ltYm9scyA9IHVzZUNoYXJJbmRleCAmJiAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5zcGxpdChcIlwiKSA6IHZhbHVlKTtcbiAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3JcbiAgICAgICAgICAgIC8vIHNob3J0aGFuZCBlc2NhcGUgc2VxdWVuY2U7IG90aGVyd2lzZSwgYXBwZW5kIHRoZSBjaGFyYWN0ZXIgYXMtaXMuXG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgODogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDM0OiBjYXNlIDkyOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBFc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVuaWNvZGVQcmVmaXggKyB0b1BhZGRlZFN0cmluZygyLCBjaGFyQ29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1c2VDaGFySW5kZXggPyBzeW1ib2xzW2luZGV4XSA6IHZhbHVlLmNoYXJBdChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXCInO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIGFuIG9iamVjdC4gSW1wbGVtZW50cyB0aGVcbiAgICAgICAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXG4gICAgICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSwgY2xhc3NOYW1lLCB5ZWFyLCBtb250aCwgZGF0ZSwgdGltZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgcmVzdWx0cywgZWxlbWVudCwgaW5kZXgsIGxlbmd0aCwgcHJlZml4LCByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgaG9zdCBvYmplY3Qgc3VwcG9ydC5cbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRGF0ZXMgYXJlIHNlcmlhbGl6ZWQgYWNjb3JkaW5nIHRvIHRoZSBgRGF0ZSN0b0pTT05gIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS45LjUuNDQuIFNlZSBzZWN0aW9uIDE1LjkuMS4xNVxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAgICAgICAgaWYgKGdldERheSkge1xuICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29tcHV0ZSB0aGUgeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLFxuICAgICAgICAgICAgICAgICAgLy8gc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBpZiB0aGUgYGdldFVUQypgIG1ldGhvZHMgYXJlXG4gICAgICAgICAgICAgICAgICAvLyBidWdneS4gQWRhcHRlZCBmcm9tIEBZYWZmbGUncyBgZGF0ZS1zaGltYCBwcm9qZWN0LlxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IGZsb29yKHZhbHVlIC8gODY0ZTUpO1xuICAgICAgICAgICAgICAgICAgZm9yICh5ZWFyID0gZmxvb3IoZGF0ZSAvIDM2NS4yNDI1KSArIDE5NzAgLSAxOyBnZXREYXkoeWVhciArIDEsIDApIDw9IGRhdGU7IHllYXIrKyk7XG4gICAgICAgICAgICAgICAgICBmb3IgKG1vbnRoID0gZmxvb3IoKGRhdGUgLSBnZXREYXkoeWVhciwgMCkpIC8gMzAuNDIpOyBnZXREYXkoeWVhciwgbW9udGggKyAxKSA8PSBkYXRlOyBtb250aCsrKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSAxICsgZGF0ZSAtIGdldERheSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgYHRpbWVgIHZhbHVlIHNwZWNpZmllcyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheSAoc2VlIEVTXG4gICAgICAgICAgICAgICAgICAvLyA1LjEgc2VjdGlvbiAxNS45LjEuMikuIFRoZSBmb3JtdWxhIGAoQSAlIEIgKyBCKSAlIEJgIGlzIHVzZWRcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGNvbXB1dGUgYEEgbW9kdWxvIEJgLCBhcyB0aGUgYCVgIG9wZXJhdG9yIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kIHRvIHRoZSBgbW9kdWxvYCBvcGVyYXRpb24gZm9yIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICB0aW1lID0gKHZhbHVlICUgODY0ZTUgKyA4NjRlNSkgJSA4NjRlNTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBhcmUgb2J0YWluZWQgYnlcbiAgICAgICAgICAgICAgICAgIC8vIGRlY29tcG9zaW5nIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5LiBTZWUgc2VjdGlvbiAxNS45LjEuMTAuXG4gICAgICAgICAgICAgICAgICBob3VycyA9IGZsb29yKHRpbWUgLyAzNmU1KSAlIDI0O1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IGZsb29yKHRpbWUgLyA2ZTQpICUgNjA7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gZmxvb3IodGltZSAvIDFlMykgJSA2MDtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRpbWUgJSAxZTM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgICAgbW9udGggPSB2YWx1ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IHZhbHVlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gdmFsdWUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSB2YWx1ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gdmFsdWUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoeWVhciA8PSAwIHx8IHllYXIgPj0gMWU0ID8gKHllYXIgPCAwID8gXCItXCIgOiBcIitcIikgKyB0b1BhZGRlZFN0cmluZyg2LCB5ZWFyIDwgMCA/IC15ZWFyIDogeWVhcikgOiB0b1BhZGRlZFN0cmluZyg0LCB5ZWFyKSkgK1xuICAgICAgICAgICAgICAgICAgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBtb250aCArIDEpICsgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBkYXRlKSArXG4gICAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXG4gICAgICAgICAgICAgICAgICAvLyBkaWdpdHM7IG1pbGxpc2Vjb25kcyBzaG91bGQgaGF2ZSB0aHJlZS5cbiAgICAgICAgICAgICAgICAgIFwiVFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgaG91cnMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBtaW51dGVzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgc2Vjb25kcykgK1xuICAgICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgICBcIi5cIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcIlpcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PSBcImZ1bmN0aW9uXCIgJiYgKChjbGFzc05hbWUgIT0gbnVtYmVyQ2xhc3MgJiYgY2xhc3NOYW1lICE9IHN0cmluZ0NsYXNzICYmIGNsYXNzTmFtZSAhPSBhcnJheUNsYXNzKSB8fCBpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSkge1xuICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcbiAgICAgICAgICAgICAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xuICAgICAgICAgICAgICAvLyBpZ25vcmVzIGFsbCBgdG9KU09OYCBtZXRob2RzIG9uIHRoZXNlIG9iamVjdHMgdW5sZXNzIHRoZXkgYXJlXG4gICAgICAgICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBvYnRhaW4gdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGJvb2xlYW5DbGFzcykge1xuICAgICAgICAgICAgLy8gQm9vbGVhbnMgYXJlIHJlcHJlc2VudGVkIGxpdGVyYWxseS5cbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gYEluZmluaXR5YCBhbmQgYE5hTmAgYXJlIHNlcmlhbGl6ZWQgYXNcbiAgICAgICAgICAgIC8vIGBcIm51bGxcImAuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCA/IFwiXCIgKyB2YWx1ZSA6IFwibnVsbFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoaXMgaXMgYSBsaW5lYXIgc2VhcmNoOyBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gc3RhY2subGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgaWYgKHN0YWNrW2xlbmd0aF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsIGFuZCBpbmRlbnQgb25lIGFkZGl0aW9uYWwgbGV2ZWwuXG4gICAgICAgICAgICBwcmVmaXggPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIGFycmF5IGVsZW1lbnRzLlxuICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzZXJpYWxpemUoaW5kZXgsIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudCA9PT0gdW5kZWYgPyBcIm51bGxcIiA6IGVsZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogKFwiW1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwiXVwiKSkgOiBcIltdXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cbiAgICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAvLyBpdHNlbGYuXG4gICAgICAgICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZXJpYWxpemUocHJvcGVydHksIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxuICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCBgbWVtYmVyYCB7cXVvdGUocHJvcGVydHkpICsgXCI6XCJ9XG4gICAgICAgICAgICAgICAgICAvLyBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBgbWVtYmVyYCBhbmQgdGhlIGBzcGFjZWAgY2hhcmFjdGVyLlwiXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxuICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBub3QgdGhlIGBzcGFjZWAge3dpZHRofSBhcmd1bWVudCBwcm92aWRlZCB0b1xuICAgICAgICAgICAgICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIiArICh3aGl0ZXNwYWNlID8gXCIgXCIgOiBcIlwiKSArIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIntcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwifVwiIDogKFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiKSkgOiBcInt9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9iamVjdCBmcm9tIHRoZSB0cmF2ZXJzZWQgb2JqZWN0IHN0YWNrLlxuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcbiAgICAgICAgICB2YXIgd2hpdGVzcGFjZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIGNsYXNzTmFtZTtcbiAgICAgICAgICBpZiAob2JqZWN0VHlwZXNbdHlwZW9mIGZpbHRlcl0gJiYgZmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xuICAgICAgICAgICAgICBjYWxsYmFjayA9IGZpbHRlcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXG4gICAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBmaWx0ZXIubGVuZ3RoLCB2YWx1ZTsgaW5kZXggPCBsZW5ndGg7IHZhbHVlID0gZmlsdGVyW2luZGV4KytdLCAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpKSwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykgJiYgKHByb3BlcnRpZXNbdmFsdWVdID0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh3aWR0aCkpID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGB3aWR0aGAgdG8gYW4gaW50ZWdlciBhbmQgY3JlYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmdcbiAgICAgICAgICAgICAgLy8gYHdpZHRoYCBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgaWYgKCh3aWR0aCAtPSB3aWR0aCAlIDEpID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAod2hpdGVzcGFjZSA9IFwiXCIsIHdpZHRoID4gMTAgJiYgKHdpZHRoID0gMTApOyB3aGl0ZXNwYWNlLmxlbmd0aCA8IHdpZHRoOyB3aGl0ZXNwYWNlICs9IFwiIFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgICAgd2hpdGVzcGFjZSA9IHdpZHRoLmxlbmd0aCA8PSAxMCA/IHdpZHRoIDogd2lkdGguc2xpY2UoMCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgZGlzY2FyZHMgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggZW1wdHkgc3RyaW5nIGtleXNcbiAgICAgICAgICAvLyAoYFwiXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxuICAgICAgICAgIC8vIChlLmcuLCBgIShcIlwiIGluIHsgXCJcIjogMX0pYCkuXG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShcIlwiLCAodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSBzb3VyY2UsIHZhbHVlKSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIFwiXCIsIFtdKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gUHVibGljOiBQYXJzZXMgYSBKU09OIHNvdXJjZSBzdHJpbmcuXG4gICAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcbiAgICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciB1bmVzY2FwZWRcbiAgICAgICAgLy8gZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBVbmVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXCInLFxuICAgICAgICAgIDQ3OiBcIi9cIixcbiAgICAgICAgICA5ODogXCJcXGJcIixcbiAgICAgICAgICAxMTY6IFwiXFx0XCIsXG4gICAgICAgICAgMTEwOiBcIlxcblwiLFxuICAgICAgICAgIDEwMjogXCJcXGZcIixcbiAgICAgICAgICAxMTQ6IFwiXFxyXCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogU3RvcmVzIHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgIHZhciBJbmRleCwgU291cmNlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXNldHMgdGhlIHBhcnNlciBzdGF0ZSBhbmQgdGhyb3dzIGEgYFN5bnRheEVycm9yYC5cbiAgICAgICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICB0aHJvdyBTeW50YXhFcnJvcigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXR1cm5zIHRoZSBuZXh0IHRva2VuLCBvciBgXCIkXCJgIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWRcbiAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgc291cmNlIHN0cmluZy4gQSB0b2tlbiBtYXkgYmUgYSBzdHJpbmcsIG51bWJlciwgYG51bGxgXG4gICAgICAgIC8vIGxpdGVyYWwsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cbiAgICAgICAgdmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gU291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLCB2YWx1ZSwgYmVnaW4sIHBvc2l0aW9uLCBpc1NpZ25lZCwgY2hhckNvZGU7XG4gICAgICAgICAgd2hpbGUgKEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxuICAgICAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSB0b2tlbnMsIGluY2x1ZGluZyB0YWJzLCBjYXJyaWFnZSByZXR1cm5zLCBsaW5lXG4gICAgICAgICAgICAgICAgLy8gZmVlZHMsIGFuZCBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTIzOiBjYXNlIDEyNTogY2FzZSA5MTogY2FzZSA5MzogY2FzZSA1ODogY2FzZSA0NDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhIHB1bmN0dWF0b3IgdG9rZW4gKGB7YCwgYH1gLCBgW2AsIGBdYCwgYDpgLCBvciBgLGApIGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjaGFySW5kZXhCdWdneSA/IHNvdXJjZS5jaGFyQXQoSW5kZXgpIDogc291cmNlW0luZGV4XTtcbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgICAvLyBgXCJgIGRlbGltaXRzIGEgSlNPTiBzdHJpbmc7IGFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZFxuICAgICAgICAgICAgICAgIC8vIGJlZ2luIHBhcnNpbmcgdGhlIHN0cmluZy4gU3RyaW5nIHRva2VucyBhcmUgcHJlZml4ZWQgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZW50aW5lbCBgQGAgY2hhcmFjdGVyIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSBwdW5jdHVhdG9ycyBhbmRcbiAgICAgICAgICAgICAgICAvLyBlbmQtb2Ytc3RyaW5nIHRva2Vucy5cbiAgICAgICAgICAgICAgICBmb3IgKHZhbHVlID0gXCJAXCIsIEluZGV4Kys7IEluZGV4IDwgbGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmVzY2FwZWQgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzICh0aG9zZSB3aXRoIGEgY29kZSB1bml0XG4gICAgICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVyKSBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT0gOTIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSByZXZlcnNlIHNvbGlkdXMgKGBcXGApIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYW4gZXNjYXBlZFxuICAgICAgICAgICAgICAgICAgICAvLyBjb250cm9sIGNoYXJhY3RlciAoaW5jbHVkaW5nIGBcImAsIGBcXGAsIGFuZCBgL2ApIG9yIFVuaWNvZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MjogY2FzZSAzNDogY2FzZSA0NzogY2FzZSA5ODogY2FzZSAxMTY6IGNhc2UgMTEwOiBjYXNlIDEwMjogY2FzZSAxMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBVbmVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYFxcdWAgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCB2YWxpZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleCArIDQ7IEluZGV4IDwgcG9zaXRpb247IEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgdmFsaWQgc2VxdWVuY2UgY29tcHJpc2VzIGZvdXIgaGV4ZGlnaXRzIChjYXNlLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlbnNpdGl2ZSkgdGhhdCBmb3JtIGEgc2luZ2xlIGhleGFkZWNpbWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKFwiMHhcIiArIHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEFuIHVuZXNjYXBlZCBkb3VibGUtcXVvdGUgY2hhcmFjdGVyIG1hcmtzIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgc3RyaW5nIGlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckNvZGUgPj0gMzIgJiYgY2hhckNvZGUgIT0gOTIgJiYgY2hhckNvZGUgIT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc3RyaW5nIGFzLWlzLlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnRlcm1pbmF0ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgbnVtYmVycyBhbmQgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIG5lZ2F0aXZlIHNpZ24sIGlmIG9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhbiBpbnRlZ2VyIG9yIGZsb2F0aW5nLXBvaW50IHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvZXMgYXJlIGludGVycHJldGVkIGFzIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ4ICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCArIDEpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgb2N0YWwgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW50ZWdlciBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICBmb3IgKDsgSW5kZXggPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgSW5kZXgrKyk7XG4gICAgICAgICAgICAgICAgICAvLyBGbG9hdHMgY2Fubm90IGNvbnRhaW4gYSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQ7IGhvd2V2ZXIsIHRoaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UgaXMgYWxyZWFkeSBhY2NvdW50ZWQgZm9yIGJ5IHRoZSBwYXJzZXIuXG4gICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDQ2KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGRlY2ltYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgdHJhaWxpbmcgZGVjaW1hbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSBleHBvbmVudHMuIFRoZSBgZWAgZGVub3RpbmcgdGhlIGV4cG9uZW50IGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMTAxIHx8IGNoYXJDb2RlID09IDY5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcGFzdCB0aGUgc2lnbiBmb2xsb3dpbmcgdGhlIGV4cG9uZW50LCBpZiBvbmUgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDMgfHwgY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBleHBvbmVudGlhbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgZW1wdHkgZXhwb25lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gQ29lcmNlIHRoZSBwYXJzZWQgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICAgICAgICAgICAgICAgIHJldHVybiArc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEEgbmVnYXRpdmUgc2lnbiBtYXkgb25seSBwcmVjZWRlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgaWYgKGlzU2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBgdHJ1ZWAsIGBmYWxzZWAsIGFuZCBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDUpID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcIm51bGxcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnJlY29nbml6ZWQgdG9rZW4uXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmV0dXJuIHRoZSBzZW50aW5lbCBgJGAgY2hhcmFjdGVyIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICAgIC8vIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLlxuICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUGFyc2VzIGEgSlNPTiBgdmFsdWVgIHRva2VuLlxuICAgICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdHMsIGhhc01lbWJlcnM7XG4gICAgICAgICAgaWYgKHZhbHVlID09IFwiJFwiKSB7XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSA9PSBcIkBcIikge1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIG9iamVjdCBhbmQgYXJyYXkgbGl0ZXJhbHMuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBhcnJheSwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgYXJyYXkuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBtYXJrcyB0aGUgZW5kIG9mIHRoZSBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRpbmcgdGhlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXh0LlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggYXJyYXkgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGdldCh2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIntcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIG9iamVjdCwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAgICAgICByZXN1bHRzID0ge307XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5zIG1lbWJlcnMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdG9yLlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIG9iamVjdCBtZW1iZXIuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxuICAgICAgICAgICAgICAgIC8vIGRvdWJsZS1xdW90ZWQgc3RyaW5ncywgYW5kIGEgYDpgIG11c3Qgc2VwYXJhdGUgZWFjaCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vIG5hbWUgYW5kIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiB8fCAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgIT0gXCJAXCIgfHwgbGV4KCkgIT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdG9rZW4gZW5jb3VudGVyZWQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFVwZGF0ZXMgYSB0cmF2ZXJzZWQgb2JqZWN0IG1lbWJlci5cbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmKSB7XG4gICAgICAgICAgICBkZWxldGUgc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlW3Byb3BlcnR5XSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSB0cmF2ZXJzZXMgYSBwYXJzZWQgSlNPTiBvYmplY3QsIGludm9raW5nIHRoZVxuICAgICAgICAvLyBgY2FsbGJhY2tgIGZ1bmN0aW9uIGZvciBlYWNoIHZhbHVlLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgV2Fsayhob2xkZXIsIG5hbWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICB2YXIgd2FsayA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sIGxlbmd0aDtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGBmb3JFYWNoYCBjYW4ndCBiZSB1c2VkIHRvIHRyYXZlcnNlIGFuIGFycmF5IGluIE9wZXJhIDw9IDguNTRcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxuICAgICAgICAgICAgLy8gZm9yIGFycmF5IGluZGljZXMgKGUuZy4sIGAhWzEsIDIsIDNdLmhhc093blByb3BlcnR5KFwiMFwiKWApLlxuICAgICAgICAgICAgaWYgKGdldENsYXNzLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgbGVuZ3RoLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnBhcnNlYC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuICAgICAgICAgIEluZGV4ID0gMDtcbiAgICAgICAgICBTb3VyY2UgPSBcIlwiICsgc291cmNlO1xuICAgICAgICAgIHJlc3VsdCA9IGdldChsZXgoKSk7XG4gICAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXG4gICAgICAgICAgaWYgKGxleCgpICE9IFwiJFwiKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXNldCB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzW1wicnVuSW5Db250ZXh0XCJdID0gcnVuSW5Db250ZXh0O1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9XG5cbiAgaWYgKGZyZWVFeHBvcnRzICYmICFpc0xvYWRlcikge1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgZW52aXJvbm1lbnRzLlxuICAgIHJ1bkluQ29udGV4dChyb290LCBmcmVlRXhwb3J0cyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRXhwb3J0IGZvciB3ZWIgYnJvd3NlcnMgYW5kIEphdmFTY3JpcHQgZW5naW5lcy5cbiAgICB2YXIgbmF0aXZlSlNPTiA9IHJvb3QuSlNPTixcbiAgICAgICAgcHJldmlvdXNKU09OID0gcm9vdFtcIkpTT04zXCJdLFxuICAgICAgICBpc1Jlc3RvcmVkID0gZmFsc2U7XG5cbiAgICB2YXIgSlNPTjMgPSBydW5JbkNvbnRleHQocm9vdCwgKHJvb3RbXCJKU09OM1wiXSA9IHtcbiAgICAgIC8vIFB1YmxpYzogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBnbG9iYWwgYEpTT05gIG9iamVjdCBhbmRcbiAgICAgIC8vIHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBKU09OM2Agb2JqZWN0LlxuICAgICAgXCJub0NvbmZsaWN0XCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jlc3RvcmVkKSB7XG4gICAgICAgICAgaXNSZXN0b3JlZCA9IHRydWU7XG4gICAgICAgICAgcm9vdC5KU09OID0gbmF0aXZlSlNPTjtcbiAgICAgICAgICByb290W1wiSlNPTjNcIl0gPSBwcmV2aW91c0pTT047XG4gICAgICAgICAgbmF0aXZlSlNPTiA9IHByZXZpb3VzSlNPTiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04zO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJvb3QuSlNPTiA9IHtcbiAgICAgIFwicGFyc2VcIjogSlNPTjMucGFyc2UsXG4gICAgICBcInN0cmluZ2lmeVwiOiBKU09OMy5zdHJpbmdpZnlcbiAgICB9O1xuICB9XG5cbiAgLy8gRXhwb3J0IGZvciBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuXG4gIGlmIChpc0xvYWRlcikge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gSlNPTjM7XG4gICAgfSk7XG4gIH1cbn0pLmNhbGwodGhpcyk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBEb21VdGlscy5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuKGZ1bmN0aW9uICgpIHtcblxuXHQvKipcblx0ICogQSBmZXcgdXRpbGl0aWVzIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBkb20uXG5cdCAqIEBjbGFzcyBEb21VdGlsc1xuXHQgKi9cblx0dmFyIHMgPSB7fTtcblxuXHRzLmFwcGVuZFRvSGVhZCA9IGZ1bmN0aW9uIChlbCkge1xuXHRcdHMuZ2V0SGVhZCgpLmFwcGVuZENoaWxkKGVsKVxuXHR9XG5cblx0cy5nZXRIZWFkID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcblx0fVxuXG5cdHMuZ2V0Qm9keSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJvZHlcIilbMF07XG5cdH1cblxuXHRjcmVhdGVqcy5Eb21VdGlscyA9IHM7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBEYXRhVXRpbHMuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cblx0LyoqXG5cdCAqIEEgZmV3IGRhdGEgdXRpbGl0aWVzIGZvciBmb3JtYXR0aW5nIGRpZmZlcmVudCBkYXRhIHR5cGVzLlxuXHQgKiBAY2xhc3MgRGF0YVV0aWxzXG5cdCAqL1xuXHR2YXIgcyA9IHt9O1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBQYXJzZSBYTUwgdXNpbmcgdGhlIERPTS4gVGhpcyBpcyByZXF1aXJlZCB3aGVuIHByZWxvYWRpbmcgWE1MIG9yIFNWRy5cblx0ICogQG1ldGhvZCBwYXJzZVhNTFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgcmF3IHRleHQgb3IgWE1MIHRoYXQgaXMgbG9hZGVkIGJ5IFhIUi5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG1pbWUgdHlwZSBvZiB0aGUgWE1MLiBVc2UgXCJ0ZXh0L3htbFwiIGZvciBYTUwsIGFuZCAgXCJpbWFnZS9zdmcreG1sXCIgZm9yIFNWRyBwYXJzaW5nLlxuXHQgKiBAcmV0dXJuIHtYTUx9IEFuIFhNTCBkb2N1bWVudFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLnBhcnNlWE1MID0gZnVuY3Rpb24gKHRleHQsIHR5cGUpIHtcblx0XHR2YXIgeG1sID0gbnVsbDtcblx0XHQvLyBDb2Nvb25KUyBkb2VzIG5vdCBzdXBwb3J0IFhNTCBwYXJzaW5nIHdpdGggZWl0aGVyIG1ldGhvZC5cblxuXHRcdC8vIE1vc3QgYnJvd3NlcnMgd2lsbCB1c2UgRE9NUGFyc2VyXG5cdFx0Ly8gSUUgZmFpbHMgb24gY2VydGFpbiBTVkcgZmlsZXMsIHNvIHdlIGhhdmUgYSBmYWxsYmFjayBiZWxvdy5cblx0XHR0cnkge1xuXHRcdFx0aWYgKHdpbmRvdy5ET01QYXJzZXIpIHtcblx0XHRcdFx0dmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcblx0XHRcdFx0eG1sID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh0ZXh0LCB0eXBlKTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgZm9yIElFIHN1cHBvcnQuXG5cdFx0aWYgKCF4bWwpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHhtbCA9IG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTERPTVwiKTtcblx0XHRcdFx0eG1sLmFzeW5jID0gZmFsc2U7XG5cdFx0XHRcdHhtbC5sb2FkWE1MKHRleHQpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHR4bWwgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB4bWw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBhcnNlIGEgc3RyaW5nIGludG8gYW4gT2JqZWN0LlxuXHQgKiBAbWV0aG9kIHBhcnNlSlNPTlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIGxvYWRlZCBKU09OIHN0cmluZ1xuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBBIEphdmFTY3JpcHQgb2JqZWN0LlxuXHQgKi9cblx0cy5wYXJzZUpTT04gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHQvLyBUT0RPOyBIYW5kbGUgdGhpcyB3aXRoIGEgY3VzdG9tIGVycm9yP1xuXHRcdFx0dGhyb3cgZTtcblx0XHR9XG5cdH07XG5cblx0Y3JlYXRlanMuRGF0YVV0aWxzID0gcztcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIExvYWRJdGVtLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIEFsbCBsb2FkZXJzIGFjY2VwdCBhbiBpdGVtIGNvbnRhaW5pbmcgdGhlIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGlzIGNsYXNzLiBJZiBhIHJhdyBvYmplY3QgaXMgcGFzc2VkIGluc3RlYWQsXG5cdCAqIGl0IHdpbGwgbm90IGJlIGFmZmVjdGVkLCBidXQgaXQgbXVzdCBjb250YWluIGF0IGxlYXN0IGEge3sjY3Jvc3NMaW5rIFwic3JjOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5LiBBXG5cdCAqIHN0cmluZyBwYXRoIG9yIEhUTUwgdGFnIGlzIGFsc28gYWNjZXB0YWJsZSwgYnV0IGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYSBMb2FkSXRlbSB1c2luZyB0aGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiY3JlYXRlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCBieSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBAY2xhc3MgTG9hZEl0ZW1cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0ZnVuY3Rpb24gTG9hZEl0ZW0oKSB7XG5cdFx0LyoqXG5cdFx0ICogVGhlIHNvdXJjZSBvZiB0aGUgZmlsZSB0aGF0IGlzIGJlaW5nIGxvYWRlZC4gVGhpcyBwcm9wZXJ0eSBpcyA8Yj5yZXF1aXJlZDwvYj4uIFRoZSBzb3VyY2UgY2FuIGVpdGhlciBiZSBhXG5cdFx0ICogc3RyaW5nIChyZWNvbW1lbmRlZCksIG9yIGFuIEhUTUwgdGFnLlxuXHRcdCAqIFRoaXMgY2FuIGFsc28gYmUgYW4gb2JqZWN0LCBidXQgaW4gdGhhdCBjYXNlIGl0IGhhcyB0byBpbmNsdWRlIGEgdHlwZSBhbmQgYmUgaGFuZGxlZCBieSBhIHBsdWdpbi5cblx0XHQgKiBAcHJvcGVydHkgc3JjXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5zcmMgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHR5cGUgZmlsZSB0aGF0IGlzIGJlaW5nIGxvYWRlZC4gVGhlIHR5cGUgb2YgdGhlIGZpbGUgaXMgdXN1YWxseSBpbmZlcnJlZCBieSB0aGUgZXh0ZW5zaW9uLCBidXQgY2FuIGFsc29cblx0XHQgKiBiZSBzZXQgbWFudWFsbHkuIFRoaXMgaXMgaGVscGZ1bCBpbiBjYXNlcyB3aGVyZSBhIGZpbGUgZG9lcyBub3QgaGF2ZSBhbiBleHRlbnNpb24uXG5cdFx0ICogQHByb3BlcnR5IHR5cGVcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnR5cGUgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgaWRlbnRpZmllciB3aGljaCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhlIGxvYWRlZCBvYmplY3QuIElmIG5vbmUgaXMgcHJvdmlkZWQsIHRoaXMgd2lsbCBiZVxuXHRcdCAqIGF1dG9tYXRpY2FsbHkgc2V0IHRvIHRoZSB7eyNjcm9zc0xpbmsgXCJzcmM6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IGlkXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5pZCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBEZXRlcm1pbmVzIGlmIGEgbWFuaWZlc3Qgd2lsbCBtYWludGFpbiB0aGUgb3JkZXIgb2YgdGhpcyBpdGVtLCBpbiByZWxhdGlvbiB0byBvdGhlciBpdGVtcyBpbiB0aGUgbWFuaWZlc3Rcblx0XHQgKiB0aGF0IGhhdmUgYWxzbyBzZXQgdGhlIGBtYWludGFpbk9yZGVyYCBwcm9wZXJ0eSB0byBgdHJ1ZWAuIFRoaXMgb25seSBhcHBsaWVzIHdoZW4gdGhlIG1heCBjb25uZWN0aW9ucyBoYXNcblx0XHQgKiBiZWVuIHNldCBhYm92ZSAxICh1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc2V0TWF4Q29ubmVjdGlvbnNcIn19e3svY3Jvc3NMaW5rfX0pLiBFdmVyeXRoaW5nIHdpdGggdGhpc1xuXHRcdCAqIHByb3BlcnR5IHNldCB0byBgZmFsc2VgIHdpbGwgZmluaXNoIGFzIGl0IGlzIGxvYWRlZC4gT3JkZXJlZCBpdGVtcyBhcmUgY29tYmluZWQgd2l0aCBzY3JpcHQgdGFncyBsb2FkaW5nIGluXG5cdFx0ICogb3JkZXIgd2hlbiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbWFpbnRhaW5TY3JpcHRPcmRlcjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpcyBzZXQgdG8gYHRydWVgLlxuXHRcdCAqIEBwcm9wZXJ0eSBtYWludGFpbk9yZGVyXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLm1haW50YWluT3JkZXIgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEEgY2FsbGJhY2sgdXNlZCBieSBKU09OUCByZXF1ZXN0cyB0aGF0IGRlZmluZXMgd2hhdCBnbG9iYWwgbWV0aG9kIHRvIGNhbGwgd2hlbiB0aGUgSlNPTlAgY29udGVudCBpcyBsb2FkZWQuXG5cdFx0ICogQHByb3BlcnR5IGNhbGxiYWNrXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5jYWxsYmFjayA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBbiBhcmJpdHJhcnkgZGF0YSBvYmplY3QsIHdoaWNoIGlzIGluY2x1ZGVkIHdpdGggdGhlIGxvYWRlZCBvYmplY3QuXG5cdFx0ICogQHByb3BlcnR5IGRhdGFcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLmRhdGEgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHJlcXVlc3QgbWV0aG9kIHVzZWQgZm9yIEhUVFAgY2FsbHMuIEJvdGgge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvR0VUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvUE9TVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSByZXF1ZXN0IHR5cGVzIGFyZSBzdXBwb3J0ZWQsIGFuZCBhcmUgZGVmaW5lZCBhc1xuXHRcdCAqIGNvbnN0YW50cyBvbiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgbWV0aG9kXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBnZXRcblx0XHQgKi9cblx0XHR0aGlzLm1ldGhvZCA9IGNyZWF0ZWpzLkxvYWRJdGVtLkdFVDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBoYXNoIG9mIG5hbWUvdmFsdWUgcGFpcnMgdG8gc2VuZCB0byB0aGUgc2VydmVyLlxuXHRcdCAqIEBwcm9wZXJ0eSB2YWx1ZXNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLnZhbHVlcyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiBoZWFkZXJzIHRvIGF0dGFjaCB0byBhbiBYSFIgcmVxdWVzdC4gUHJlbG9hZEpTIHdpbGwgYXV0b21hdGljYWxseSBhdHRhY2ggc29tZSBkZWZhdWx0XG5cdFx0ICogaGVhZGVycyB3aGVuIHJlcXVpcmVkLCBpbmNsdWRpbmcgXCJPcmlnaW5cIiwgXCJDb250ZW50LVR5cGVcIiwgYW5kIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiLiBZb3UgbWF5IG92ZXJyaWRlIHRoZVxuXHRcdCAqIGRlZmF1bHQgaGVhZGVycyBieSBpbmNsdWRpbmcgdGhlbSBpbiB5b3VyIGhlYWRlcnMgb2JqZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBoZWFkZXJzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICovXG5cdFx0dGhpcy5oZWFkZXJzID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBjcmVkZW50aWFscyBmb3IgWEhSIHJlcXVlc3RzLlxuXHRcdCAqIEBwcm9wZXJ0eSB3aXRoQ3JlZGVudGlhbHNcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIG1pbWUgdHlwZSBvZiBYSFItYmFzZWQgcmVxdWVzdHMuIFRoaXMgaXMgYXV0b21hdGljYWxseSBzZXQgdG8gXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIgZm9yIHRleHRcblx0XHQgKiBiYXNlZCBmaWxlcyAoanNvbiwgeG1sLCB0ZXh0LCBjc3MsIGpzKS5cblx0XHQgKiBAcHJvcGVydHkgbWltZVR5cGVcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLm1pbWVUeXBlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFNldHMgdGhlIGNyb3NzT3JpZ2luIGF0dHJpYnV0ZSBmb3IgQ09SUy1lbmFibGVkIGltYWdlcyBsb2FkaW5nIGNyb3NzLWRvbWFpbi5cblx0XHQgKiBAcHJvcGVydHkgY3Jvc3NPcmlnaW5cblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBBbm9ueW1vdXNcblx0XHQgKi9cblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgYSByZXF1ZXN0IHRpbWVzIG91dC4gVGhpcyBvbmx5IGFwcGxpZXMgdG8gdGFnLWJhc2VkIGFuZCBhbmQgWEhSXG5cdFx0ICogKGxldmVsIG9uZSkgbG9hZGluZywgYXMgWEhSIChsZXZlbCAyKSBwcm92aWRlcyBpdHMgb3duIHRpbWVvdXQgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IGxvYWRUaW1lb3V0XG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCA4MDAwICg4IHNlY29uZHMpXG5cdFx0ICovXG5cdFx0dGhpcy5sb2FkVGltZW91dCA9IHMuTE9BRF9USU1FT1VUX0RFRkFVTFQ7XG5cdH07XG5cblx0dmFyIHAgPSBMb2FkSXRlbS5wcm90b3R5cGUgPSB7fTtcblx0dmFyIHMgPSBMb2FkSXRlbTtcblxuXHQvKipcblx0ICogRGVmYXVsdCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgYSByZXF1ZXN0IHRpbWVzIG91dC4gVGhpcyBvbmx5IGFwcGxpZXMgdG8gdGFnLWJhc2VkIGFuZCBhbmQgWEhSXG5cdCAqIChsZXZlbCBvbmUpIGxvYWRpbmcsIGFzIFhIUiAobGV2ZWwgMikgcHJvdmlkZXMgaXRzIG93biB0aW1lb3V0IGV2ZW50LlxuXHQgKiBAcHJvcGVydHkgTE9BRF9USU1FT1VUX0RFRkFVTFRcblx0ICogQHR5cGUge251bWJlcn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5MT0FEX1RJTUVPVVRfREVGQVVMVCA9IDgwMDA7XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIExvYWRJdGVtLlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+U3RyaW5nLWJhc2VkIGl0ZW1zIGFyZSBjb252ZXJ0ZWQgdG8gYSBMb2FkSXRlbSB3aXRoIGEgcG9wdWxhdGVkIHt7I2Nyb3NzTGluayBcInNyYzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS48L2xpPlxuXHQgKiAgICAgPGxpPkxvYWRJdGVtIGluc3RhbmNlcyBhcmUgcmV0dXJuZWQgYXMtaXM8L2xpPlxuXHQgKiAgICAgPGxpPk9iamVjdHMgYXJlIHJldHVybmVkIHdpdGggYW55IG5lZWRlZCBwcm9wZXJ0aWVzIGFkZGVkPC9saT5cblx0ICogPC91bD5cblx0ICogQG1ldGhvZCBjcmVhdGVcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxTdHJpbmd8T2JqZWN0fSB2YWx1ZSBUaGUgbG9hZCBpdGVtIHZhbHVlXG5cdCAqIEByZXR1cm5zIHtMb2FkSXRlbXxPYmplY3R9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY3JlYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG5ldyBMb2FkSXRlbSgpO1xuXHRcdFx0aXRlbS5zcmMgPSB2YWx1ZTtcblx0XHRcdHJldHVybiBpdGVtO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBzKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCAmJiB2YWx1ZS5zcmMpIHtcblx0XHRcdGlmICh2YWx1ZS5sb2FkVGltZW91dCA9PSBudWxsKSB7XG5cdFx0XHRcdHZhbHVlLmxvYWRUaW1lb3V0ID0gcy5MT0FEX1RJTUVPVVRfREVGQVVMVDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVHlwZSBub3QgcmVjb2duaXplZC5cIik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcm92aWRlcyBhIGNoYWluYWJsZSBzaG9ydGN1dCBtZXRob2QgZm9yIHNldHRpbmcgYSBudW1iZXIgb2YgcHJvcGVydGllcyBvbiB0aGUgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgbG9hZEl0ZW0gPSBuZXcgY3JlYXRlanMuTG9hZEl0ZW0oKS5zZXQoe3NyYzpcImltYWdlLnBuZ1wiLCBtYWludGFpbk9yZGVyOnRydWV9KTtcblx0ICpcblx0ICogQG1ldGhvZCBzZXRcblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEEgZ2VuZXJpYyBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRvIGNvcHkgdG8gdGhlIExvYWRJdGVtIGluc3RhbmNlLlxuXHQgKiBAcmV0dXJuIHtMb2FkSXRlbX0gUmV0dXJucyB0aGUgaW5zdGFuY2UgdGhlIG1ldGhvZCBpcyBjYWxsZWQgb24gKHVzZWZ1bCBmb3IgY2hhaW5pbmcgY2FsbHMuKVxuXHQqL1xuXHRwLnNldCA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykgeyB0aGlzW25dID0gcHJvcHNbbl07IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHRjcmVhdGVqcy5Mb2FkSXRlbSA9IHM7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBSZXF1ZXN0VXRpbHMuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbihmdW5jdGlvbiAoKSB7XG5cblx0LyoqXG5cdCAqIFV0aWxpdGllcyB0aGF0IGFzc2lzdCB3aXRoIHBhcnNpbmcgbG9hZCBpdGVtcywgYW5kIGRldGVybWluaW5nIGZpbGUgdHlwZXMsIGV0Yy5cblx0ICogQGNsYXNzIFJlcXVlc3RVdGlsc1xuXHQgKi9cblx0dmFyIHMgPSB7fTtcblxuXHQvKipcblx0ICogVGhlIFJlZ3VsYXIgRXhwcmVzc2lvbiB1c2VkIHRvIHRlc3QgZmlsZSBVUkxTIGZvciBhbiBhYnNvbHV0ZSBwYXRoLlxuXHQgKiBAcHJvcGVydHkgQUJTT0xVVEVfUEFUSFxuXHQgKiBAdHlwZSB7UmVnRXhwfVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLkFCU09MVVRFX1BBVFQgPSAvXig/Olxcdys6KT9cXC97Mn0vaTtcblxuXHQvKipcblx0ICogVGhlIFJlZ3VsYXIgRXhwcmVzc2lvbiB1c2VkIHRvIHRlc3QgZmlsZSBVUkxTIGZvciBhIHJlbGF0aXZlIHBhdGguXG5cdCAqIEBwcm9wZXJ0eSBSRUxBVElWRV9QQVRIXG5cdCAqIEB0eXBlIHtSZWdFeHB9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuUkVMQVRJVkVfUEFUVCA9ICgvXlsuL10qP1xcLy9pKTtcblxuXHQvKipcblx0ICogVGhlIFJlZ3VsYXIgRXhwcmVzc2lvbiB1c2VkIHRvIHRlc3QgZmlsZSBVUkxTIGZvciBhbiBleHRlbnNpb24uIE5vdGUgdGhhdCBVUklzIG11c3QgYWxyZWFkeSBoYXZlIHRoZSBxdWVyeSBzdHJpbmdcblx0ICogcmVtb3ZlZC5cblx0ICogQHByb3BlcnR5IEVYVEVOU0lPTl9QQVRUXG5cdCAqIEB0eXBlIHtSZWdFeHB9XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuRVhURU5TSU9OX1BBVFQgPSAvXFwvP1teL10rXFwuKFxcd3sxLDV9KSQvaTtcblxuXHQvKipcblx0ICogUGFyc2UgYSBmaWxlIHBhdGggdG8gZGV0ZXJtaW5lIHRoZSBpbmZvcm1hdGlvbiB3ZSBuZWVkIHRvIHdvcmsgd2l0aCBpdC4gQ3VycmVudGx5LCBQcmVsb2FkSlMgbmVlZHMgdG8ga25vdzpcblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPklmIHRoZSBwYXRoIGlzIGFic29sdXRlLiBBYnNvbHV0ZSBwYXRocyBzdGFydCB3aXRoIGEgcHJvdG9jb2wgKHN1Y2ggYXMgYGh0dHA6Ly9gLCBgZmlsZTovL2AsIG9yXG5cdCAqICAgICBgLy9uZXR3b3JrUGF0aGApPC9saT5cblx0ICogICAgIDxsaT5JZiB0aGUgcGF0aCBpcyByZWxhdGl2ZS4gUmVsYXRpdmUgcGF0aHMgc3RhcnQgd2l0aCBgLi4vYCBvciBgL3BhdGhgIChvciBzaW1pbGFyKTwvbGk+XG5cdCAqICAgICA8bGk+VGhlIGZpbGUgZXh0ZW5zaW9uLiBUaGlzIGlzIGRldGVybWluZWQgYnkgdGhlIGZpbGVuYW1lIHdpdGggYW4gZXh0ZW5zaW9uLiBRdWVyeSBzdHJpbmdzIGFyZSBkcm9wcGVkLCBhbmRcblx0ICogICAgIHRoZSBmaWxlIHBhdGggaXMgZXhwZWN0ZWQgdG8gZm9sbG93IHRoZSBmb3JtYXQgYG5hbWUuZXh0YC48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBAbWV0aG9kIHBhcnNlVVJJXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IEFuIE9iamVjdCB3aXRoIGFuIGBhYnNvbHV0ZWAgYW5kIGByZWxhdGl2ZWAgQm9vbGVhbiB2YWx1ZXMsIGFzIHdlbGwgYXMgYW4gb3B0aW9uYWwgJ2V4dGVuc2lvbmBcblx0ICogcHJvcGVydHksIHdoaWNoIGlzIHRoZSBsb3dlcmNhc2UgZXh0ZW5zaW9uLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLnBhcnNlVVJJID0gZnVuY3Rpb24gKHBhdGgpIHtcblx0XHR2YXIgaW5mbyA9IHthYnNvbHV0ZTogZmFsc2UsIHJlbGF0aXZlOiBmYWxzZX07XG5cdFx0aWYgKHBhdGggPT0gbnVsbCkgeyByZXR1cm4gaW5mbzsgfVxuXG5cdFx0Ly8gRHJvcCB0aGUgcXVlcnkgc3RyaW5nXG5cdFx0dmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoXCI/XCIpO1xuXHRcdGlmIChxdWVyeUluZGV4ID4gLTEpIHtcblx0XHRcdHBhdGggPSBwYXRoLnN1YnN0cigwLCBxdWVyeUluZGV4KTtcblx0XHR9XG5cblx0XHQvLyBBYnNvbHV0ZVxuXHRcdHZhciBtYXRjaDtcblx0XHRpZiAocy5BQlNPTFVURV9QQVRULnRlc3QocGF0aCkpIHtcblx0XHRcdGluZm8uYWJzb2x1dGUgPSB0cnVlO1xuXG5cdFx0XHQvLyBSZWxhdGl2ZVxuXHRcdH0gZWxzZSBpZiAocy5SRUxBVElWRV9QQVRULnRlc3QocGF0aCkpIHtcblx0XHRcdGluZm8ucmVsYXRpdmUgPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIEV4dGVuc2lvblxuXHRcdGlmIChtYXRjaCA9IHBhdGgubWF0Y2gocy5FWFRFTlNJT05fUEFUVCkpIHtcblx0XHRcdGluZm8uZXh0ZW5zaW9uID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGluZm87XG5cdH07XG5cblx0LyoqXG5cdCAqIEZvcm1hdHMgYW4gb2JqZWN0IGludG8gYSBxdWVyeSBzdHJpbmcgZm9yIGVpdGhlciBhIFBPU1Qgb3IgR0VUIHJlcXVlc3QuXG5cdCAqIEBtZXRob2QgZm9ybWF0UXVlcnlTdHJpbmdcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgdG8gY29udmVydCB0byBhIHF1ZXJ5IHN0cmluZy5cblx0ICogQHBhcmFtIHtBcnJheX0gW3F1ZXJ5XSBFeGlzdGluZyBuYW1lL3ZhbHVlIHBhaXJzIHRvIGFwcGVuZCBvbiB0byB0aGlzIHF1ZXJ5LlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmZvcm1hdFF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24gKGRhdGEsIHF1ZXJ5KSB7XG5cdFx0aWYgKGRhdGEgPT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGRhdGEuJyk7XG5cdFx0fVxuXHRcdHZhciBwYXJhbXMgPSBbXTtcblx0XHRmb3IgKHZhciBuIGluIGRhdGEpIHtcblx0XHRcdHBhcmFtcy5wdXNoKG4gKyAnPScgKyBlc2NhcGUoZGF0YVtuXSkpO1xuXHRcdH1cblx0XHRpZiAocXVlcnkpIHtcblx0XHRcdHBhcmFtcyA9IHBhcmFtcy5jb25jYXQocXVlcnkpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFyYW1zLmpvaW4oJyYnKTtcblx0fTtcblxuXHQvKipcblx0ICogQSB1dGlsaXR5IG1ldGhvZCB0aGF0IGJ1aWxkcyBhIGZpbGUgcGF0aCB1c2luZyBhIHNvdXJjZSBhbmQgYSBkYXRhIG9iamVjdCwgYW5kIGZvcm1hdHMgaXQgaW50byBhIG5ldyBwYXRoLlxuXHQgKiBAbWV0aG9kIGJ1aWxkUGF0aFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjIFRoZSBzb3VyY2UgcGF0aCB0byBhZGQgdmFsdWVzIHRvLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdIE9iamVjdCB1c2VkIHRvIGFwcGVuZCB2YWx1ZXMgdG8gdGhpcyByZXF1ZXN0IGFzIGEgcXVlcnkgc3RyaW5nLiBFeGlzdGluZyBwYXJhbWV0ZXJzIG9uIHRoZVxuXHQgKiBwYXRoIHdpbGwgYmUgcHJlc2VydmVkLlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBBIGZvcm1hdHRlZCBzdHJpbmcgdGhhdCBjb250YWlucyB0aGUgcGF0aCBhbmQgdGhlIHN1cHBsaWVkIHBhcmFtZXRlcnMuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuYnVpbGRQYXRoID0gZnVuY3Rpb24gKHNyYywgZGF0YSkge1xuXHRcdGlmIChkYXRhID09IG51bGwpIHtcblx0XHRcdHJldHVybiBzcmM7XG5cdFx0fVxuXG5cdFx0dmFyIHF1ZXJ5ID0gW107XG5cdFx0dmFyIGlkeCA9IHNyYy5pbmRleE9mKCc/Jyk7XG5cblx0XHRpZiAoaWR4ICE9IC0xKSB7XG5cdFx0XHR2YXIgcSA9IHNyYy5zbGljZShpZHggKyAxKTtcblx0XHRcdHF1ZXJ5ID0gcXVlcnkuY29uY2F0KHEuc3BsaXQoJyYnKSk7XG5cdFx0fVxuXG5cdFx0aWYgKGlkeCAhPSAtMSkge1xuXHRcdFx0cmV0dXJuIHNyYy5zbGljZSgwLCBpZHgpICsgJz8nICsgdGhpcy5fZm9ybWF0UXVlcnlTdHJpbmcoZGF0YSwgcXVlcnkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gc3JjICsgJz8nICsgdGhpcy5fZm9ybWF0UXVlcnlTdHJpbmcoZGF0YSwgcXVlcnkpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBpc0Nyb3NzRG9tYWluXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIEEgbG9hZCBpdGVtIHdpdGggYSBgc3JjYCBwcm9wZXJ0eS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gSWYgdGhlIGxvYWQgaXRlbSBpcyBsb2FkaW5nIGZyb20gYSBkaWZmZXJlbnQgZG9tYWluIHRoYW4gdGhlIGN1cnJlbnQgbG9jYXRpb24uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNDcm9zc0RvbWFpbiA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0dmFyIHRhcmdldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXHRcdHRhcmdldC5ocmVmID0gaXRlbS5zcmM7XG5cblx0XHR2YXIgaG9zdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXHRcdGhvc3QuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cblx0XHR2YXIgY3Jvc3Nkb21haW4gPSAodGFyZ2V0Lmhvc3RuYW1lICE9IFwiXCIpICYmXG5cdFx0XHRcdFx0XHQgICh0YXJnZXQucG9ydCAhPSBob3N0LnBvcnQgfHxcblx0XHRcdFx0XHRcdCAgIHRhcmdldC5wcm90b2NvbCAhPSBob3N0LnByb3RvY29sIHx8XG5cdFx0XHRcdFx0XHQgICB0YXJnZXQuaG9zdG5hbWUgIT0gaG9zdC5ob3N0bmFtZSk7XG5cdFx0cmV0dXJuIGNyb3NzZG9tYWluO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGlzTG9jYWxcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gQSBsb2FkIGl0ZW0gd2l0aCBhIGBzcmNgIHByb3BlcnR5XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBsb2FkIGl0ZW0gaXMgbG9hZGluZyBmcm9tIHRoZSBcImZpbGU6XCIgcHJvdG9jb2wuIEFzc3VtZSB0aGF0IHRoZSBob3N0IG11c3QgYmUgbG9jYWwgYXNcblx0ICogd2VsbC5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pc0xvY2FsID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHR2YXIgdGFyZ2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG5cdFx0dGFyZ2V0LmhyZWYgPSBpdGVtLnNyYztcblx0XHRyZXR1cm4gdGFyZ2V0Lmhvc3RuYW1lID09IFwiXCIgJiYgdGFyZ2V0LnByb3RvY29sID09IFwiZmlsZTpcIjtcblx0fTtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgdHlwZSBzaG91bGQgYmUgbG9hZGVkIGFzIGEgYmluYXJ5IGZpbGUuIEN1cnJlbnRseSwgb25seSBpbWFnZXMgYW5kIGl0ZW1zIG1hcmtlZFxuXHQgKiBzcGVjaWZpY2FsbHkgYXMgXCJiaW5hcnlcIiBhcmUgbG9hZGVkIGFzIGJpbmFyeS4gTm90ZSB0aGF0IGF1ZGlvIGlzIDxiPm5vdDwvYj4gYSBiaW5hcnkgdHlwZSwgYXMgd2UgY2FuIG5vdCBwbGF5XG5cdCAqIGJhY2sgdXNpbmcgYW4gYXVkaW8gdGFnIGlmIGl0IGlzIGxvYWRlZCBhcyBiaW5hcnkuIFBsdWdpbnMgY2FuIGNoYW5nZSB0aGUgaXRlbSB0eXBlIHRvIGJpbmFyeSB0byBlbnN1cmUgdGhleSBnZXRcblx0ICogYSBiaW5hcnkgcmVzdWx0IHRvIHdvcmsgd2l0aC4gQmluYXJ5IGZpbGVzIGFyZSBsb2FkZWQgdXNpbmcgWEhSMi4gVHlwZXMgYXJlIGRlZmluZWQgYXMgc3RhdGljIGNvbnN0YW50cyBvblxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBpc0JpbmFyeVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgaXRlbSB0eXBlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgc3BlY2lmaWVkIHR5cGUgaXMgYmluYXJ5LlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmlzQmluYXJ5ID0gZnVuY3Rpb24gKHR5cGUpIHtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSU1BR0U6XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkJJTkFSWTpcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBpdGVtIGlzIGEgdmFsaWQgSFRNTEltYWdlRWxlbWVudFxuXHQgKiBAbWV0aG9kIGlzSW1hZ2VUYWdcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cblx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNJbWFnZVRhZyA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIGl0ZW0gaXMgYSB2YWxpZCBIVE1MQXVkaW9FbGVtZW50XG5cdCAqIEBtZXRob2QgaXNBdWRpb1RhZ1xuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pc0F1ZGlvVGFnID0gZnVuY3Rpb24oaXRlbSkge1xuXHRcdGlmICh3aW5kb3cuSFRNTEF1ZGlvRWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIGl0ZW0gaW5zdGFuY2VvZiBIVE1MQXVkaW9FbGVtZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBpdGVtIGlzIGEgdmFsaWQgSFRNTFZpZGVvRWxlbWVudFxuXHQgKiBAbWV0aG9kIGlzVmlkZW9UYWdcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW1cblx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuaXNWaWRlb1RhZyA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRpZiAod2luZG93LkhUTUxWaWRlb0VsZW1lbnQpIHtcblx0XHRcdHJldHVybiBpdGVtIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgdHlwZSBpcyBhIHRleHQtYmFzZWQgYXNzZXQsIGFuZCBzaG91bGQgYmUgbG9hZGVkIGFzIFVURi04LlxuXHQgKiBAbWV0aG9kIGlzVGV4dFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgaXRlbSB0eXBlLlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgc3BlY2lmaWVkIHR5cGUgaXMgdGV4dC5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5pc1RleHQgPSBmdW5jdGlvbiAodHlwZSkge1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5URVhUOlxuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KU09OOlxuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5NQU5JRkVTVDpcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuWE1MOlxuXHRcdFx0Y2FzZSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5DU1M6XG5cdFx0XHRjYXNlIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNWRzpcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSkFWQVNDUklQVDpcblx0XHRcdGNhc2UgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU1BSSVRFU0hFRVQ6XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIHRoZSBvYmplY3QgdXNpbmcgY29tbW9uIGV4dGVuc2lvbnMuIE5vdGUgdGhhdCB0aGUgdHlwZSBjYW4gYmUgcGFzc2VkIGluIHdpdGggdGhlIGxvYWQgaXRlbVxuXHQgKiBpZiBpdCBpcyBhbiB1bnVzdWFsIGV4dGVuc2lvbi5cblx0ICogQG1ldGhvZCBnZXRUeXBlQnlFeHRlbnNpb25cblx0ICogQHBhcmFtIHtTdHJpbmd9IGV4dGVuc2lvbiBUaGUgZmlsZSBleHRlbnNpb24gdG8gdXNlIHRvIGRldGVybWluZSB0aGUgbG9hZCB0eXBlLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBkZXRlcm1pbmVkIGxvYWQgdHlwZSAoZm9yIGV4YW1wbGUsIDxjb2RlPkFic3RyYWN0TG9hZGVyLklNQUdFPC9jb2RlPikuIFdpbGwgcmV0dXJuIGBudWxsYCBpZlxuXHQgKiB0aGUgdHlwZSBjYW4gbm90IGJlIGRldGVybWluZWQgYnkgdGhlIGV4dGVuc2lvbi5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5nZXRUeXBlQnlFeHRlbnNpb24gPSBmdW5jdGlvbiAoZXh0ZW5zaW9uKSB7XG5cdFx0aWYgKGV4dGVuc2lvbiA9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVEVYVDtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKGV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0XHRjYXNlIFwianBlZ1wiOlxuXHRcdFx0Y2FzZSBcImpwZ1wiOlxuXHRcdFx0Y2FzZSBcImdpZlwiOlxuXHRcdFx0Y2FzZSBcInBuZ1wiOlxuXHRcdFx0Y2FzZSBcIndlYnBcIjpcblx0XHRcdGNhc2UgXCJibXBcIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLklNQUdFO1xuXHRcdFx0Y2FzZSBcIm9nZ1wiOlxuXHRcdFx0Y2FzZSBcIm1wM1wiOlxuXHRcdFx0Y2FzZSBcIndlYm1cIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNPVU5EO1xuXHRcdFx0Y2FzZSBcIm1wNFwiOlxuXHRcdFx0Y2FzZSBcIndlYm1cIjpcblx0XHRcdGNhc2UgXCJ0c1wiOlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVklERU87XG5cdFx0XHRjYXNlIFwianNvblwiOlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTjtcblx0XHRcdGNhc2UgXCJ4bWxcIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlhNTDtcblx0XHRcdGNhc2UgXCJjc3NcIjpcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkNTUztcblx0XHRcdGNhc2UgXCJqc1wiOlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSkFWQVNDUklQVDtcblx0XHRcdGNhc2UgJ3N2Zyc6XG5cdFx0XHRcdHJldHVybiBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TVkc7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVEVYVDtcblx0XHR9XG5cdH07XG5cblx0Y3JlYXRlanMuUmVxdWVzdFV0aWxzID0gcztcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEFic3RyYWN0TG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBsb2FkZXIsIHdoaWNoIGRlZmluZXMgYWxsIHRoZSBnZW5lcmljIG1ldGhvZHMsIHByb3BlcnRpZXMsIGFuZCBldmVudHMuIEFsbCBsb2FkZXJzIGV4dGVuZCB0aGlzIGNsYXNzLFxuXHQgKiBpbmNsdWRpbmcgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQGNsYXNzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18b2JqZWN0fHN0cmluZ30gbG9hZEl0ZW0gVGhlIGl0ZW0gdG8gYmUgbG9hZGVkLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtwcmVmZXJYSFJdIERldGVybWluZXMgaWYgdGhlIExvYWRJdGVtIHNob3VsZCA8ZW0+dHJ5PC9lbT4gYW5kIGxvYWQgdXNpbmcgWEhSLCBvciB0YWtlIGFcblx0ICogdGFnLWJhc2VkIGFwcHJvYWNoLCB3aGljaCBjYW4gYmUgYmV0dGVyIGluIGNyb3NzLWRvbWFpbiBzaXR1YXRpb25zLiBOb3QgYWxsIGxvYWRlcnMgY2FuIGxvYWQgdXNpbmcgb25lIG9yIHRoZVxuXHQgKiBvdGhlciwgc28gdGhpcyBpcyBhIHN1Z2dlc3RlZCBkaXJlY3RpdmUuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gVGhlIHR5cGUgb2YgbG9hZGVyLiBMb2FkZXIgdHlwZXMgYXJlIGRlZmluZWQgYXMgY29uc3RhbnRzIG9uIHRoZSBBYnN0cmFjdExvYWRlciBjbGFzcyxcblx0ICogc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJJTUFHRTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSwge3sjY3Jvc3NMaW5rIFwiQ1NTOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LCBldGMuXG5cdCAqIEBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlclxuXHQgKi9cblx0ZnVuY3Rpb24gQWJzdHJhY3RMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUiwgdHlwZSkge1xuXHRcdHRoaXMuRXZlbnREaXNwYXRjaGVyX2NvbnN0cnVjdG9yKCk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIElmIHRoZSBsb2FkZXIgaGFzIGNvbXBsZXRlZCBsb2FkaW5nLiBUaGlzIHByb3ZpZGVzIGEgcXVpY2sgY2hlY2ssIGJ1dCBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgZGlmZmVyZW50IGFwcHJvYWNoZXNcblx0XHQgKiB1c2VkIGZvciBsb2FkaW5nIGRvIG5vdCBwaWxlIHVwIHJlc3VsdGluZyBpbiBtb3JlIHRoYW4gb25lIGBjb21wbGV0ZWAge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IGxvYWRlZFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICovXG5cdFx0dGhpcy5sb2FkZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZSBpZiB0aGUgbG9hZGVyIHdhcyBjYW5jZWxlZC4gQ2FuY2VsZWQgbG9hZHMgd2lsbCBub3QgZmlyZSBjb21wbGV0ZSBldmVudHMuIE5vdGUgdGhhdCB0aGlzIHByb3BlcnR5XG5cdFx0ICogaXMgcmVhZG9ubHksIHNvIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSBxdWV1ZXMgc2hvdWxkIGJlIGNsb3NlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvY2xvc2VcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBpbnN0ZWFkLlxuXHRcdCAqIEBwcm9wZXJ0eSBjYW5jZWxlZFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy5jYW5jZWxlZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgbG9hZCBwcm9ncmVzcyAocGVyY2VudGFnZSkgZm9yIHRoaXMgaXRlbS4gVGhpcyB3aWxsIGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMS5cblx0XHQgKlxuXHRcdCAqIDxoND5FeGFtcGxlPC9oND5cblx0XHQgKlxuXHRcdCAqICAgICB2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG5cdFx0ICogICAgIHF1ZXVlLmxvYWRGaWxlKFwibGFyZ2VJbWFnZS5wbmdcIik7XG5cdFx0ICogICAgIHF1ZXVlLm9uKFwicHJvZ3Jlc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0ICogICAgICAgICBjb25zb2xlLmxvZyhcIlByb2dyZXNzOlwiLCBxdWV1ZS5wcm9ncmVzcywgZXZlbnQucHJvZ3Jlc3MpO1xuXHRcdCAqICAgICB9KTtcblx0XHQgKlxuXHRcdCAqIEBwcm9wZXJ0eSBwcm9ncmVzc1xuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqL1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSAwO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgaXRlbSB0aGlzIGxvYWRlciB3aWxsIGxvYWQuIFNlZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fSBmb3IgYSBmdWxsIGxpc3Qgb2Zcblx0XHQgKiBzdXBwb3J0ZWQgdHlwZXMuXG5cdFx0ICogQHByb3BlcnR5IHR5cGVcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cblx0XHQvKipcblx0XHQgKiBBIGZvcm1hdHRlciBmdW5jdGlvbiB0aGF0IGNvbnZlcnRzIHRoZSBsb2FkZWQgcmF3IHJlc3VsdCBpbnRvIHRoZSBmaW5hbCByZXN1bHQuIEZvciBleGFtcGxlLCB0aGUgSlNPTkxvYWRlclxuXHRcdCAqIGNvbnZlcnRzIGEgc3RyaW5nIG9mIHRleHQgaW50byBhIEphdmFTY3JpcHQgb2JqZWN0LiBOb3QgYWxsIGxvYWRlcnMgaGF2ZSBhIHJlc3VsdEZvcm1hdHRlciwgYW5kIHRoaXMgcHJvcGVydHlcblx0XHQgKiBjYW4gYmUgb3ZlcnJpZGRlbiB0byBwcm92aWRlIGN1c3RvbSBmb3JtYXR0aW5nLlxuXHRcdCAqXG5cdFx0ICogT3B0aW9uYWxseSwgYSByZXN1bHRGb3JtYXR0ZXIgY2FuIHJldHVybiBhIGNhbGxiYWNrIGZ1bmN0aW9uIGluIGNhc2VzIHdoZXJlIHRoZSBmb3JtYXR0aW5nIG5lZWRzIHRvIGJlXG5cdFx0ICogYXN5bmNocm9ub3VzLCBzdWNoIGFzIGNyZWF0aW5nIGEgbmV3IGltYWdlLlxuXHRcdCAqIEBwcm9wZXJ0eSByZXN1bHRGb3JtYXR0ZXJcblx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gbnVsbDtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogVGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IHRoaXMgbG9hZGVyIHJlcHJlc2VudHMuIE5vdGUgdGhhdCB0aGlzIGlzIG51bGwgaW4gYSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX0sXG5cdFx0ICogYnV0IHdpbGwgYmUgYXZhaWxhYmxlIG9uIGxvYWRlcnMgc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJYTUxMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIkltYWdlTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBfaXRlbVxuXHRcdCAqIEB0eXBlIHtMb2FkSXRlbXxPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHRpZiAobG9hZEl0ZW0pIHtcblx0XHRcdHRoaXMuX2l0ZW0gPSBjcmVhdGVqcy5Mb2FkSXRlbS5jcmVhdGUobG9hZEl0ZW0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9pdGVtID0gbnVsbDtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRoZSBsb2FkZXIgd2lsbCB0cnkgYW5kIGxvYWQgY29udGVudCB1c2luZyBYSFIgKHRydWUpIG9yIEhUTUwgdGFncyAoZmFsc2UpLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcHJlZmVyWEhSXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9wcmVmZXJYSFIgPSBwcmVmZXJYSFI7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbG9hZGVkIHJlc3VsdCBhZnRlciBpdCBpcyBmb3JtYXR0ZWQgYnkgYW4gb3B0aW9uYWwge3sjY3Jvc3NMaW5rIFwicmVzdWx0Rm9ybWF0dGVyXCJ9fXt7L2Nyb3NzTGlua319LiBGb3Jcblx0XHQgKiBpdGVtcyB0aGF0IGFyZSBub3QgZm9ybWF0dGVkLCB0aGlzIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIHt7I2Nyb3NzTGluayBcIl9yYXdSZXN1bHQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogVGhlIHJlc3VsdCBpcyBhY2Nlc3NlZCB1c2luZyB0aGUge3sjY3Jvc3NMaW5rIFwiZ2V0UmVzdWx0XCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblx0XHQgKiBAcHJvcGVydHkgX3Jlc3VsdFxuXHRcdCAqIEB0eXBlIHtPYmplY3R8U3RyaW5nfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcmVzdWx0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsb2FkZWQgcmVzdWx0IGJlZm9yZSBpdCBpcyBmb3JtYXR0ZWQuIFRoZSByYXdSZXN1bHQgaXMgYWNjZXNzZWQgdXNpbmcgdGhlIHt7I2Nyb3NzTGluayBcImdldFJlc3VsdFwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIG1ldGhvZCwgYW5kIHBhc3NpbmcgYHRydWVgLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmF3UmVzdWx0XG5cdFx0ICogQHR5cGUge09iamVjdHxTdHJpbmd9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9yYXdSZXN1bHQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQSBsaXN0IG9mIGl0ZW1zIHRoYXQgbG9hZGVycyBsb2FkIGJlaGluZCB0aGUgc2NlbmVzLiBUaGlzIGRvZXMgbm90IGluY2x1ZGUgdGhlIG1haW4gaXRlbSB0aGUgbG9hZGVyIGlzXG5cdFx0ICogcmVzcG9uc2libGUgZm9yIGxvYWRpbmcuIEV4YW1wbGVzIG9mIGxvYWRlcnMgdGhhdCBoYXZlIHN1Yi1pdGVtcyBpbmNsdWRlIHRoZSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldExvYWRlclwifX17ey9jcm9zc0xpbmt9fSBhbmRcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRJdGVtc1xuXHRcdCAqIEB0eXBlIHtudWxsfVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkZWRJdGVtcyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYXR0cmlidXRlIHRoZSBpdGVtcyBsb2FkZWQgdXNpbmcgdGFncyB1c2UgZm9yIHRoZSBzb3VyY2UuXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gSFRNTCB0YWcgKG9yIHNpbWlsYXIpIHRoYXQgYSBsb2FkZXIgbWF5IHVzZSB0byBsb2FkIEhUTUwgY29udGVudCwgc3VjaCBhcyBpbWFnZXMsIHNjcmlwdHMsIGV0Yy5cblx0XHQgKiBAcHJvcGVydHkgX3RhZ1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl90YWcgPSBudWxsO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEFic3RyYWN0TG9hZGVyLCBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIpO1xuXHR2YXIgcyA9IEFic3RyYWN0TG9hZGVyO1xuXG5cdC8vIFRPRE86IGRlcHJlY2F0ZWRcblx0Ly8gcC5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7fTsgLy8gc2VhcmNoYWJsZSBmb3IgZGV2cyB3b25kZXJpbmcgd2hlcmUgaXQgaXMuIFJFTU9WRUQuIFNlZSBkb2NzIGZvciBkZXRhaWxzLlxuXG5cblx0LyoqXG5cdCAqIERlZmluZXMgYSBQT1NUIHJlcXVlc3QsIHVzZSBmb3IgYSBtZXRob2QgdmFsdWUgd2hlbiBsb2FkaW5nIGRhdGEuXG5cdCAqIEBwcm9wZXJ0eSBQT1NUXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHBvc3Rcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5QT1NUID0gXCJQT1NUXCI7XG5cblx0LyoqXG5cdCAqIERlZmluZXMgYSBHRVQgcmVxdWVzdCwgdXNlIGZvciBhIG1ldGhvZCB2YWx1ZSB3aGVuIGxvYWRpbmcgZGF0YS5cblx0ICogQHByb3BlcnR5IEdFVFxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBnZXRcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5HRVQgPSBcIkdFVFwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBnZW5lcmljIGJpbmFyeSB0eXBlcy4gTm90ZSB0aGF0IGltYWdlcyBhcmUgbG9hZGVkIGFzIGJpbmFyeSBmaWxlcyB3aGVuIHVzaW5nIFhIUi5cblx0ICogQHByb3BlcnR5IEJJTkFSWVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBiaW5hcnlcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuQklOQVJZID0gXCJiaW5hcnlcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgY3NzIGZpbGVzLiBDU1MgZmlsZXMgYXJlIGxvYWRlZCB1c2luZyBhICZsdDtsaW5rJmd0OyB3aGVuIGxvYWRlZCB3aXRoIFhIUiwgb3IgYVxuXHQgKiAmbHQ7c3R5bGUmZ3Q7IHRhZyB3aGVuIGxvYWRlZCB3aXRoIHRhZ3MuXG5cdCAqIEBwcm9wZXJ0eSBDU1Ncblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgY3NzXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLkNTUyA9IFwiY3NzXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIGltYWdlIGZpbGVzLCB1c3VhbGx5IHBuZywgZ2lmLCBvciBqcGcvanBlZy4gSW1hZ2VzIGFyZSBsb2FkZWQgaW50byBhbiAmbHQ7aW1hZ2UmZ3Q7IHRhZy5cblx0ICogQHByb3BlcnR5IElNQUdFXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGltYWdlXG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLklNQUdFID0gXCJpbWFnZVwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBqYXZhc2NyaXB0IGZpbGVzLCB1c3VhbGx5IHdpdGggdGhlIFwianNcIiBmaWxlIGV4dGVuc2lvbi4gSmF2YVNjcmlwdCBmaWxlcyBhcmUgbG9hZGVkIGludG8gYVxuXHQgKiAmbHQ7c2NyaXB0Jmd0OyB0YWcuXG5cdCAqXG5cdCAqIFNpbmNlIHZlcnNpb24gMC40LjErLCBkdWUgdG8gaG93IHRhZy1sb2FkZWQgc2NyaXB0cyB3b3JrLCBhbGwgSmF2YVNjcmlwdCBmaWxlcyBhcmUgYXV0b21hdGljYWxseSBpbmplY3RlZCBpbnRvXG5cdCAqIHRoZSBib2R5IG9mIHRoZSBkb2N1bWVudCB0byBtYWludGFpbiBwYXJpdHkgYmV0d2VlbiBYSFIgYW5kIHRhZy1sb2FkZWQgc2NyaXB0cy4gSW4gdmVyc2lvbiAwLjQuMCBhbmQgZWFybGllcixcblx0ICogb25seSB0YWctbG9hZGVkIHNjcmlwdHMgYXJlIGluamVjdGVkLlxuXHQgKiBAcHJvcGVydHkgSkFWQVNDUklQVFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBqYXZhc2NyaXB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRzLkpBVkFTQ1JJUFQgPSBcImphdmFzY3JpcHRcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IganNvbiBmaWxlcywgdXN1YWxseSB3aXRoIHRoZSBcImpzb25cIiBmaWxlIGV4dGVuc2lvbi4gSlNPTiBkYXRhIGlzIGxvYWRlZCBhbmQgcGFyc2VkIGludG8gYVxuXHQgKiBKYXZhU2NyaXB0IG9iamVjdC4gTm90ZSB0aGF0IGlmIGEgYGNhbGxiYWNrYCBpcyBwcmVzZW50IG9uIHRoZSBsb2FkIGl0ZW0sIHRoZSBmaWxlIHdpbGwgYmUgbG9hZGVkIHdpdGggSlNPTlAsXG5cdCAqIG5vIG1hdHRlciB3aGF0IHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvcHJlZmVyWEhSOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGlzIHNldCB0bywgYW5kIHRoZSBKU09OXG5cdCAqIG11c3QgY29udGFpbiBhIG1hdGNoaW5nIHdyYXBwZXIgZnVuY3Rpb24uXG5cdCAqIEBwcm9wZXJ0eSBKU09OXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGpzb25cblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuSlNPTiA9IFwianNvblwiO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJlbG9hZCB0eXBlIGZvciBqc29ucCBmaWxlcywgdXN1YWxseSB3aXRoIHRoZSBcImpzb25cIiBmaWxlIGV4dGVuc2lvbi4gSlNPTiBkYXRhIGlzIGxvYWRlZCBhbmQgcGFyc2VkIGludG8gYVxuXHQgKiBKYXZhU2NyaXB0IG9iamVjdC4gWW91IGFyZSByZXF1aXJlZCB0byBwYXNzIGEgY2FsbGJhY2sgcGFyYW1ldGVyIHRoYXQgbWF0Y2hlcyB0aGUgZnVuY3Rpb24gd3JhcHBlciBpbiB0aGUgSlNPTi5cblx0ICogTm90ZSB0aGF0IEpTT05QIHdpbGwgYWx3YXlzIGJlIHVzZWQgaWYgdGhlcmUgaXMgYSBjYWxsYmFjayBwcmVzZW50LCBubyBtYXR0ZXIgd2hhdCB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3ByZWZlclhIUjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBwcm9wZXJ0eSBpcyBzZXQgdG8uXG5cdCAqIEBwcm9wZXJ0eSBKU09OUFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBqc29ucFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5KU09OUCA9IFwianNvbnBcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IganNvbi1iYXNlZCBtYW5pZmVzdCBmaWxlcywgdXN1YWxseSB3aXRoIHRoZSBcImpzb25cIiBmaWxlIGV4dGVuc2lvbi4gVGhlIEpTT04gZGF0YSBpcyBsb2FkZWRcblx0ICogYW5kIHBhcnNlZCBpbnRvIGEgSmF2YVNjcmlwdCBvYmplY3QuIFByZWxvYWRKUyB3aWxsIHRoZW4gbG9vayBmb3IgYSBcIm1hbmlmZXN0XCIgcHJvcGVydHkgaW4gdGhlIEpTT04sIHdoaWNoIGlzIGFuXG5cdCAqIEFycmF5IG9mIGZpbGVzIHRvIGxvYWQsIGZvbGxvd2luZyB0aGUgc2FtZSBmb3JtYXQgYXMgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kLiBJZiBhIFwiY2FsbGJhY2tcIiBpcyBzcGVjaWZpZWQgb24gdGhlIG1hbmlmZXN0IG9iamVjdCwgdGhlbiBpdCB3aWxsIGJlIGxvYWRlZCB1c2luZyBKU09OUCBpbnN0ZWFkLFxuXHQgKiByZWdhcmRsZXNzIG9mIHdoYXQgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9wcmVmZXJYSFI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaXMgc2V0IHRvLlxuXHQgKiBAcHJvcGVydHkgTUFOSUZFU1Rcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgbWFuaWZlc3Rcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuTUFOSUZFU1QgPSBcIm1hbmlmZXN0XCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIHNvdW5kIGZpbGVzLCB1c3VhbGx5IG1wMywgb2dnLCBvciB3YXYuIFdoZW4gbG9hZGluZyB2aWEgdGFncywgYXVkaW8gaXMgbG9hZGVkIGludG8gYW5cblx0ICogJmx0O2F1ZGlvJmd0OyB0YWcuXG5cdCAqIEBwcm9wZXJ0eSBTT1VORFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBzb3VuZFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5TT1VORCA9IFwic291bmRcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgdmlkZW8gZmlsZXMsIHVzdWFsbHkgbXA0LCB0cywgb3Igb2dnLiBXaGVuIGxvYWRpbmcgdmlhIHRhZ3MsIHZpZGVvIGlzIGxvYWRlZCBpbnRvIGFuXG5cdCAqICZsdDt2aWRlbyZndDsgdGFnLlxuXHQgKiBAcHJvcGVydHkgVklERU9cblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgdmlkZW9cblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuVklERU8gPSBcInZpZGVvXCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIFNwcml0ZVNoZWV0IGZpbGVzLiBTcHJpdGVTaGVldCBmaWxlcyBhcmUgSlNPTiBmaWxlcyB0aGF0IGNvbnRhaW4gc3RyaW5nIGltYWdlIHBhdGhzLlxuXHQgKiBAcHJvcGVydHkgU1BSSVRFU0hFRVRcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgc3ByaXRlc2hlZXRcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuU1BSSVRFU0hFRVQgPSBcInNwcml0ZXNoZWV0XCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIFNWRyBmaWxlcy5cblx0ICogQHByb3BlcnR5IFNWR1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBzdmdcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuU1ZHID0gXCJzdmdcIjtcblxuXHQvKipcblx0ICogVGhlIHByZWxvYWQgdHlwZSBmb3IgdGV4dCBmaWxlcywgd2hpY2ggaXMgYWxzbyB0aGUgZGVmYXVsdCBmaWxlIHR5cGUgaWYgdGhlIHR5cGUgY2FuIG5vdCBiZSBkZXRlcm1pbmVkLiBUZXh0IGlzXG5cdCAqIGxvYWRlZCBhcyByYXcgdGV4dC5cblx0ICogQHByb3BlcnR5IFRFWFRcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgdGV4dFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cy5URVhUID0gXCJ0ZXh0XCI7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmVsb2FkIHR5cGUgZm9yIHhtbCBmaWxlcy4gWE1MIGlzIGxvYWRlZCBpbnRvIGFuIFhNTCBkb2N1bWVudC5cblx0ICogQHByb3BlcnR5IFhNTFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCB4bWxcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHMuWE1MID0gXCJ4bWxcIjtcblxuLy8gRXZlbnRzXG5cdC8qKlxuXHQgKiBUaGUge3sjY3Jvc3NMaW5rIFwiUHJvZ3Jlc3NFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIHdoZW4gdGhlIG92ZXJhbGwgcHJvZ3Jlc3MgY2hhbmdlcy4gUHJpb3IgdG9cblx0ICogdmVyc2lvbiAwLjYuMCwgdGhpcyB3YXMganVzdCBhIHJlZ3VsYXIge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBldmVudCBwcm9ncmVzc1xuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoZSB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIHdoZW4gYSBsb2FkIHN0YXJ0cy5cblx0ICogQGV2ZW50IGxvYWRzdGFydFxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBzaW5jZSAwLjMuMVxuXHQgKi9cblxuXHQvKipcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgd2hlbiB0aGUgZW50aXJlIHF1ZXVlIGhhcyBiZWVuIGxvYWRlZC5cblx0ICogQGV2ZW50IGNvbXBsZXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGUge3sjY3Jvc3NMaW5rIFwiRXJyb3JFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIHdoZW4gdGhlIGxvYWRlciBlbmNvdW50ZXJzIGFuIGVycm9yLiBJZiB0aGUgZXJyb3Igd2FzXG5cdCAqIGVuY291bnRlcmVkIGJ5IGEgZmlsZSwgdGhlIGV2ZW50IHdpbGwgY29udGFpbiB0aGUgaXRlbSB0aGF0IGNhdXNlZCB0aGUgZXJyb3IuIFByaW9yIHRvIHZlcnNpb24gMC42LjAsIHRoaXMgd2FzXG5cdCAqIGp1c3QgYSByZWd1bGFyIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAZXZlbnQgZXJyb3Jcblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGUge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCB3aGVuIHRoZSBsb2FkZXIgZW5jb3VudGVycyBhbiBpbnRlcm5hbCBmaWxlIGxvYWQgZXJyb3IuXG5cdCAqIFRoaXMgZW5hYmxlcyBsb2FkZXJzIHRvIG1haW50YWluIGludGVybmFsIHF1ZXVlcywgYW5kIHN1cmZhY2UgZmlsZSBsb2FkIGVycm9ycy5cblx0ICogQGV2ZW50IGZpbGVlcnJvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW4gdHlwZSAoXCJmaWxlZXJyb3JcIilcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxvYmplY3R9IFRoZSBpdGVtIHRoYXQgZW5jb3VudGVyZWQgdGhlIGVycm9yXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblxuXHQvKipcblx0ICogVGhlIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgaXMgZmlyZWQgd2hlbiBhIGxvYWRlciBpbnRlcm5hbGx5IGxvYWRzIGEgZmlsZS4gVGhpcyBlbmFibGVzXG5cdCAqIGxvYWRlcnMgc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fSB0byBtYWludGFpbiBpbnRlcm5hbCB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWVcIn19e3svY3Jvc3NMaW5rfX1zXG5cdCAqIGFuZCBub3RpZnkgd2hlbiB0aGV5IGhhdmUgbG9hZGVkIGEgZmlsZS4gVGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSBjbGFzcyBkaXNwYXRjaGVzIGFcblx0ICogc2xpZ2h0bHkgZGlmZmVyZW50IHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudC5cblx0ICogQGV2ZW50IGZpbGVsb2FkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIG9iamVjdCB0aGF0IGRpc3BhdGNoZWQgdGhlIGV2ZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZSAoXCJmaWxlbG9hZFwiKVxuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBUaGUgZmlsZSBpdGVtIHdoaWNoIHdhcyBzcGVjaWZpZWQgaW4gdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvciB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319IGNhbGwuIElmIG9ubHkgYSBzdHJpbmcgcGF0aCBvciB0YWcgd2FzIHNwZWNpZmllZCwgdGhlXG5cdCAqIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhhdCB2YWx1ZSBhcyBhIGBzcmNgIHByb3BlcnR5LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0IFRoZSBIVE1MIHRhZyBvciBwYXJzZWQgcmVzdWx0IG9mIHRoZSBsb2FkZWQgaXRlbS5cblx0ICogQHBhcmFtIHtPYmplY3R9IHJhd1Jlc3VsdCBUaGUgdW5wcm9jZXNzZWQgcmVzdWx0LCB1c3VhbGx5IHRoZSByYXcgdGV4dCBvciBiaW5hcnkgZGF0YSBiZWZvcmUgaXQgaXMgY29udmVydGVkXG5cdCAqIHRvIGEgdXNhYmxlIG9iamVjdC5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGUge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBpcyBmaXJlZCBhZnRlciB0aGUgaW50ZXJuYWwgcmVxdWVzdCBpcyBjcmVhdGVkLCBidXQgYmVmb3JlIGEgbG9hZC5cblx0ICogVGhpcyBhbGxvd3MgdXBkYXRlcyB0byB0aGUgbG9hZGVyIGZvciBzcGVjaWZpYyBsb2FkaW5nIG5lZWRzLCBzdWNoIGFzIGJpbmFyeSBvciBYSFIgaW1hZ2UgbG9hZGluZy5cblx0ICogQGV2ZW50IGluaXRpYWxpemVcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlIChcImluaXRpYWxpemVcIilcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyIFRoZSBsb2FkZXIgdGhhdCBoYXMgYmVlbiBpbml0aWFsaXplZC5cblx0ICovXG5cblxuXHQvKipcblx0ICogR2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBtYW5pZmVzdCBpdGVtIHRoYXQgaXMgbG9hZGVkIGJ5IHRoaXMgbG9hZGVyLiBJbiBzb21lIGNhc2VzIHRoaXMgd2lsbCBiZSB0aGUgdmFsdWUgdGhhdCB3YXNcblx0ICogcGFzc2VkIGludG8ge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319IHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fSBvclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319LiBIb3dldmVyIGlmIG9ubHkgYSBTdHJpbmcgcGF0aCB3YXMgcGFzc2VkIGluLCB0aGVuIGl0IHdpbGxcblx0ICogYmUgYSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBnZXRJdGVtXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1hbmlmZXN0IGl0ZW0gdGhhdCB0aGlzIGxvYWRlciBpcyByZXNwb25zaWJsZSBmb3IgbG9hZGluZy5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmdldEl0ZW0gPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2l0ZW07XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCBhIHJlZmVyZW5jZSB0byB0aGUgY29udGVudCB0aGF0IHdhcyBsb2FkZWQgYnkgdGhlIGxvYWRlciAob25seSBhdmFpbGFibGUgYWZ0ZXIgdGhlIHt7I2Nyb3NzTGluayBcImNvbXBsZXRlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IGlzIGRpc3BhdGNoZWQuXG5cdCAqIEBtZXRob2QgZ2V0UmVzdWx0XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Jhdz1mYWxzZV0gRGV0ZXJtaW5lcyBpZiB0aGUgcmV0dXJuZWQgcmVzdWx0IHdpbGwgYmUgdGhlIGZvcm1hdHRlZCBjb250ZW50LCBvciB0aGUgcmF3IGxvYWRlZFxuXHQgKiBkYXRhIChpZiBpdCBleGlzdHMpLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5nZXRSZXN1bHQgPSBmdW5jdGlvbiAocmF3KSB7XG5cdFx0cmV0dXJuIHJhdyA/IHRoaXMuX3Jhd1Jlc3VsdCA6IHRoaXMuX3Jlc3VsdDtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBgdGFnYCB0aGlzIG9iamVjdCBjcmVhdGVzIG9yIHVzZXMgZm9yIGxvYWRpbmcuXG5cdCAqIEBtZXRob2QgZ2V0VGFnXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIHRhZyBpbnN0YW5jZVxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuZ2V0VGFnID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl90YWc7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgYHRhZ2AgdGhpcyBpdGVtIHVzZXMgZm9yIGxvYWRpbmcuXG5cdCAqIEBtZXRob2Qgc2V0VGFnXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YWcgVGhlIHRhZyBpbnN0YW5jZVxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuc2V0VGFnID0gZnVuY3Rpb24odGFnKSB7XG5cdCAgdGhpcy5fdGFnID0gdGFnO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBCZWdpbiBsb2FkaW5nIHRoZSBpdGVtLiBUaGlzIG1ldGhvZCBpcyByZXF1aXJlZCB3aGVuIHVzaW5nIGEgbG9hZGVyIGJ5IGl0c2VsZi5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHZhciBxdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUoKTtcblx0ICogICAgICBxdWV1ZS5vbihcImNvbXBsZXRlXCIsIGhhbmRsZUNvbXBsZXRlKTtcblx0ICogICAgICBxdWV1ZS5sb2FkTWFuaWZlc3QoZmlsZUFycmF5LCBmYWxzZSk7IC8vIE5vdGUgdGhlIDJuZCBhcmd1bWVudCB0aGF0IHRlbGxzIHRoZSBxdWV1ZSBub3QgdG8gc3RhcnQgbG9hZGluZyB5ZXRcblx0ICogICAgICBxdWV1ZS5sb2FkKCk7XG5cdCAqXG5cdCAqIEBtZXRob2QgbG9hZFxuXHQgKi9cblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2NyZWF0ZVJlcXVlc3QoKTtcblxuXHRcdHRoaXMuX3JlcXVlc3Qub24oXCJjb21wbGV0ZVwiLCB0aGlzLCB0aGlzKTtcblx0XHR0aGlzLl9yZXF1ZXN0Lm9uKFwicHJvZ3Jlc3NcIiwgdGhpcywgdGhpcyk7XG5cdFx0dGhpcy5fcmVxdWVzdC5vbihcImxvYWRTdGFydFwiLCB0aGlzLCB0aGlzKTtcblx0XHR0aGlzLl9yZXF1ZXN0Lm9uKFwiYWJvcnRcIiwgdGhpcywgdGhpcyk7XG5cdFx0dGhpcy5fcmVxdWVzdC5vbihcInRpbWVvdXRcIiwgdGhpcywgdGhpcyk7XG5cdFx0dGhpcy5fcmVxdWVzdC5vbihcImVycm9yXCIsIHRoaXMsIHRoaXMpO1xuXG5cdFx0dmFyIGV2dCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImluaXRpYWxpemVcIik7XG5cdFx0ZXZ0LmxvYWRlciA9IHRoaXMuX3JlcXVlc3Q7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cblx0XHR0aGlzLl9yZXF1ZXN0LmxvYWQoKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2xvc2UgdGhlIHRoZSBpdGVtLiBUaGlzIHdpbGwgc3RvcCBhbnkgb3BlbiByZXF1ZXN0cyAoYWx0aG91Z2ggZG93bmxvYWRzIHVzaW5nIEhUTUwgdGFncyBtYXkgc3RpbGwgY29udGludWUgaW5cblx0ICogdGhlIGJhY2tncm91bmQpLCBidXQgZXZlbnRzIHdpbGwgbm90IGxvbmdlciBiZSBkaXNwYXRjaGVkLlxuXHQgKiBAbWV0aG9kIGNhbmNlbFxuXHQgKi9cblx0cC5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5jYW5jZWxlZCA9IHRydWU7XG5cdFx0dGhpcy5kZXN0cm95KCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENsZWFuIHVwIHRoZSBsb2FkZXIuXG5cdCAqIEBtZXRob2QgZGVzdHJveVxuXHQgKi9cblx0cC5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QpIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoKTtcblx0XHRcdHRoaXMuX3JlcXVlc3QuZGVzdHJveSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuXG5cdFx0dGhpcy5faXRlbSA9IG51bGw7XG5cdFx0dGhpcy5fcmF3UmVzdWx0ID0gbnVsbDtcblx0XHR0aGlzLl9yZXN1bHQgPSBudWxsO1xuXG5cdFx0dGhpcy5fbG9hZEl0ZW1zID0gbnVsbDtcblxuXHRcdHRoaXMucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMoKTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IGFueSBpdGVtcyBsb2FkZWQgaW50ZXJuYWxseSBieSB0aGUgbG9hZGVyLiBUaGUgZW5hYmxlcyBsb2FkZXJzIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogdG8gZXhwb3NlIGl0ZW1zIGl0IGxvYWRzIGludGVybmFsbHkuXG5cdCAqIEBtZXRob2QgZ2V0TG9hZGVkSXRlbXNcblx0ICogQHJldHVybiB7QXJyYXl9IEEgbGlzdCBvZiB0aGUgaXRlbXMgbG9hZGVkIGJ5IHRoZSBsb2FkZXIuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5nZXRMb2FkZWRJdGVtcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9hZGVkSXRlbXM7XG5cdH07XG5cblxuXHQvLyBQcml2YXRlIG1ldGhvZHNcblx0LyoqXG5cdCAqIENyZWF0ZSBhbiBpbnRlcm5hbCByZXF1ZXN0IHVzZWQgZm9yIGxvYWRpbmcuIEJ5IGRlZmF1bHQsIGFuIHt7I2Nyb3NzTGluayBcIlhIUlJlcXVlc3RcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGFnUmVxdWVzdFwifX17ey9jcm9zc0xpbmt9fSBpcyBjcmVhdGVkLCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIHt7I2Nyb3NzTGluayBcInByZWZlclhIUjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogT3RoZXIgbG9hZGVycyBtYXkgb3ZlcnJpZGUgdGhpcyB0byB1c2UgZGlmZmVyZW50IHJlcXVlc3QgdHlwZXMsIHN1Y2ggYXMge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIHdoaWNoIHVzZXMge3sjY3Jvc3NMaW5rIFwiSlNPTkxvYWRlclwifX17ey9jcm9zc0xpbmt9fSBvciB7eyNjcm9zc0xpbmsgXCJKU09OUExvYWRlclwifX17ey9jcm9zc0xpbmt9fSB1bmRlciB0aGUgaG9vZC5cblx0ICogQG1ldGhvZCBfY3JlYXRlUmVxdWVzdFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9wcmVmZXJYSFIpIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuVGFnUmVxdWVzdCh0aGlzLl9pdGVtLCB0aGlzLl90YWcgfHwgdGhpcy5fY3JlYXRlVGFnKCksIHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuWEhSUmVxdWVzdCh0aGlzLl9pdGVtKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSB0aGUgSFRNTCB0YWcgdXNlZCBmb3IgbG9hZGluZy4gVGhpcyBtZXRob2QgZG9lcyBub3RoaW5nIGJ5IGRlZmF1bHQsIGFuZCBuZWVkcyB0byBiZSBpbXBsZW1lbnRlZFxuXHQgKiBieSBsb2FkZXJzIHRoYXQgcmVxdWlyZSB0YWcgbG9hZGluZy5cblx0ICogQG1ldGhvZCBfY3JlYXRlVGFnXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgVGhlIHRhZyBzb3VyY2Vcblx0ICogQHJldHVybiB7SFRNTEVsZW1lbnR9IFRoZSB0YWcgdGhhdCB3YXMgY3JlYXRlZFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9jcmVhdGVUYWcgPSBmdW5jdGlvbihzcmMpIHsgcmV0dXJuIG51bGw7IH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoIGEgbG9hZHN0YXJ0IHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9sb2Fkc3RhcnQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZXZlbnQgZm9yIGRldGFpbHMgb24gdGhlIGV2ZW50IHBheWxvYWQuXG5cdCAqIEBtZXRob2QgX3NlbmRMb2FkU3RhcnRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2VuZExvYWRTdGFydCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5faXNDYW5jZWxlZCgpKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChcImxvYWRzdGFydFwiKTtcblx0fTtcblxuXHQvKipcblx0ICogRGlzcGF0Y2ggYSB7eyNjcm9zc0xpbmsgXCJQcm9ncmVzc0V2ZW50XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIF9zZW5kUHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtOdW1iZXIgfCBPYmplY3R9IHZhbHVlIFRoZSBwcm9ncmVzcyBvZiB0aGUgbG9hZGVkIGl0ZW0sIG9yIGFuIG9iamVjdCBjb250YWluaW5nIDxjb2RlPmxvYWRlZDwvY29kZT5cblx0ICogYW5kIDxjb2RlPnRvdGFsPC9jb2RlPiBwcm9wZXJ0aWVzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZW5kUHJvZ3Jlc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRpZiAodGhpcy5faXNDYW5jZWxlZCgpKSB7IHJldHVybjsgfVxuXHRcdHZhciBldmVudCA9IG51bGw7XG5cdFx0aWYgKHR5cGVvZih2YWx1ZSkgPT0gXCJudW1iZXJcIikge1xuXHRcdFx0dGhpcy5wcm9ncmVzcyA9IHZhbHVlO1xuXHRcdFx0ZXZlbnQgPSBuZXcgY3JlYXRlanMuUHJvZ3Jlc3NFdmVudCh0aGlzLnByb2dyZXNzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXZlbnQgPSB2YWx1ZTtcblx0XHRcdHRoaXMucHJvZ3Jlc3MgPSB2YWx1ZS5sb2FkZWQgLyB2YWx1ZS50b3RhbDtcblx0XHRcdGV2ZW50LnByb2dyZXNzID0gdGhpcy5wcm9ncmVzcztcblx0XHRcdGlmIChpc05hTih0aGlzLnByb2dyZXNzKSB8fCB0aGlzLnByb2dyZXNzID09IEluZmluaXR5KSB7IHRoaXMucHJvZ3Jlc3MgPSAwOyB9XG5cdFx0fVxuXHRcdHRoaXMuaGFzRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIpICYmIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoIGEgY29tcGxldGUge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2NvbXBsZXRlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50XG5cdCAqIEBtZXRob2QgX3NlbmRDb21wbGV0ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZW5kQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2lzQ2FuY2VsZWQoKSkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMubG9hZGVkID0gdHJ1ZTtcblxuXHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FdmVudChcImNvbXBsZXRlXCIpO1xuXHRcdGV2ZW50LnJhd1Jlc3VsdCA9IHRoaXMuX3Jhd1Jlc3VsdDtcblxuXHRcdGlmICh0aGlzLl9yZXN1bHQgIT0gbnVsbCkge1xuXHRcdFx0ZXZlbnQucmVzdWx0ID0gdGhpcy5fcmVzdWx0O1xuXHRcdH1cblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERpc3BhdGNoIGFuIGVycm9yIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9lcnJvcjpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBmb3IgZGV0YWlscyBvbiB0aGUgZXZlbnQgcGF5bG9hZC5cblx0ICogQG1ldGhvZCBfc2VuZEVycm9yXG5cdCAqIEBwYXJhbSB7RXJyb3JFdmVudH0gZXZlbnQgVGhlIGV2ZW50IG9iamVjdCBjb250YWluaW5nIHNwZWNpZmljIGVycm9yIHByb3BlcnRpZXMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3NlbmRFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGlmICh0aGlzLl9pc0NhbmNlbGVkKCkgfHwgIXRoaXMuaGFzRXZlbnRMaXN0ZW5lcihcImVycm9yXCIpKSB7IHJldHVybjsgfVxuXHRcdGlmIChldmVudCA9PSBudWxsKSB7XG5cdFx0XHRldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9FUlJPUl9FTVBUWVwiKTsgLy8gVE9ETzogUG9wdWxhdGUgZXJyb3Jcblx0XHR9XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIGlmIHRoZSBsb2FkIGhhcyBiZWVuIGNhbmNlbGVkLiBUaGlzIGlzIGltcG9ydGFudCB0byBlbnN1cmUgdGhhdCBtZXRob2QgY2FsbHMgb3IgYXN5bmNocm9ub3VzIGV2ZW50c1xuXHQgKiBkbyBub3QgY2F1c2UgaXNzdWVzIGFmdGVyIHRoZSBxdWV1ZSBoYXMgYmVlbiBjbGVhbmVkIHVwLlxuXHQgKiBAbWV0aG9kIF9pc0NhbmNlbGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZSBsb2FkZXIgaGFzIGJlZW4gY2FuY2VsZWQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2lzQ2FuY2VsZWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHdpbmRvdy5jcmVhdGVqcyA9PSBudWxsIHx8IHRoaXMuY2FuY2VsZWQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIEEgY3VzdG9tIHJlc3VsdCBmb3JtYXR0ZXIgZnVuY3Rpb24sIHdoaWNoIGlzIGNhbGxlZCBqdXN0IGJlZm9yZSBhIHJlcXVlc3QgZGlzcGF0Y2hlcyBpdHMgY29tcGxldGUgZXZlbnQuIE1vc3Rcblx0ICogbG9hZGVyIHR5cGVzIGFscmVhZHkgaGF2ZSBhbiBpbnRlcm5hbCBmb3JtYXR0ZXIsIGJ1dCB0aGlzIGNhbiBiZSB1c2VyLW92ZXJyaWRkZW4gZm9yIGN1c3RvbSBmb3JtYXR0aW5nLiBUaGVcblx0ICogZm9ybWF0dGVkIHJlc3VsdCB3aWxsIGJlIGF2YWlsYWJsZSBvbiBMb2FkZXJzIHVzaW5nIHt7I2Nyb3NzTGluayBcImdldFJlc3VsdFwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHBhc3NpbmcgYHRydWVgLlxuXHQgKiBAcHJvcGVydHkgcmVzdWx0Rm9ybWF0dGVyXG5cdCAqIEB0eXBlIEZ1bmN0aW9uXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGZvcm1hdHRlZCByZXN1bHRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLnJlc3VsdEZvcm1hdHRlciA9IG51bGw7XG5cblx0LyoqXG5cdCAqIEhhbmRsZSBldmVudHMgZnJvbSBpbnRlcm5hbCByZXF1ZXN0cy4gQnkgZGVmYXVsdCwgbG9hZGVycyB3aWxsIGhhbmRsZSwgYW5kIHJlZGlzcGF0Y2ggdGhlIG5lY2Vzc2FyeSBldmVudHMsIGJ1dFxuXHQgKiB0aGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiBmb3IgY3VzdG9tIGJlaGF2aW91cnMuXG5cdCAqIEBtZXRob2QgaGFuZGxlRXZlbnRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRoYXQgdGhlIGludGVybmFsIHJlcXVlc3QgZGlzcGF0Y2hlcy5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cdHAuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcblx0XHRcdGNhc2UgXCJjb21wbGV0ZVwiOlxuXHRcdFx0XHR0aGlzLl9yYXdSZXN1bHQgPSBldmVudC50YXJnZXQuX3Jlc3BvbnNlO1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRGb3JtYXR0ZXIgJiYgdGhpcy5yZXN1bHRGb3JtYXR0ZXIodGhpcyk7XG5cdFx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0XHRcdGlmIChyZXN1bHQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0XHRcdHJlc3VsdChmdW5jdGlvbihyZXN1bHQpIHtcblx0XHRcdFx0XHRcdF90aGlzLl9yZXN1bHQgPSByZXN1bHQ7XG5cdFx0XHRcdFx0XHRfdGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fcmVzdWx0ID0gIHJlc3VsdCB8fCB0aGlzLl9yYXdSZXN1bHQ7XG5cdFx0XHRcdFx0dGhpcy5fc2VuZENvbXBsZXRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwicHJvZ3Jlc3NcIjpcblx0XHRcdFx0dGhpcy5fc2VuZFByb2dyZXNzKGV2ZW50KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwiZXJyb3JcIjpcblx0XHRcdFx0dGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwibG9hZHN0YXJ0XCI6XG5cdFx0XHRcdHRoaXMuX3NlbmRMb2FkU3RhcnQoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwiYWJvcnRcIjpcblx0XHRcdGNhc2UgXCJ0aW1lb3V0XCI6XG5cdFx0XHRcdGlmICghdGhpcy5faXNDYW5jZWxlZCgpKSB7XG5cdFx0XHRcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50LnR5cGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBidWlsZFBhdGhcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlJlcXVlc3RVdGlsc1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2Qge3sjY3Jvc3NMaW5rIFwiUmVxdWVzdFV0aWxzL2J1aWxkUGF0aFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpbnN0ZWFkLlxuXHQgKi9cblx0cC5idWlsZFBhdGggPSBmdW5jdGlvbiAoc3JjLCBkYXRhKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5idWlsZFBhdGgoc3JjLCBkYXRhKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFwiW1ByZWxvYWRKUyBBYnN0cmFjdExvYWRlcl1cIjtcblx0fTtcblxuXHRjcmVhdGVqcy5BYnN0cmFjdExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoQWJzdHJhY3RMb2FkZXIsIFwiRXZlbnREaXNwYXRjaGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQWJzdHJhY3RNZWRpYUxvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBUaGUgQWJzdHJhY3RNZWRpYUxvYWRlciBpcyBhIGJhc2UgY2xhc3MgdGhhdCBoYW5kbGVzIHNvbWUgb2YgdGhlIHNoYXJlZCBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIG9mIGxvYWRlcnMgdGhhdFxuXHQgKiBoYW5kbGUgSFRNTCBtZWRpYSBlbGVtZW50cywgc3VjaCBhcyBWaWRlbyBhbmQgQXVkaW8uXG5cdCAqIEBjbGFzcyBBYnN0cmFjdE1lZGlhTG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZlclhIUlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBtZWRpYSB0byBsb2FkLiBVc3VhbGx5IFwidmlkZW9cIiBvciBcImF1ZGlvXCIuXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gQWJzdHJhY3RNZWRpYUxvYWRlcihsb2FkSXRlbSwgcHJlZmVyWEhSLCB0eXBlKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgcHJlZmVyWEhSLCB0eXBlKTtcblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5yZXN1bHRGb3JtYXR0ZXIgPSB0aGlzLl9mb3JtYXRSZXN1bHQ7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSA9IFwic3JjXCI7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQWJzdHJhY3RNZWRpYUxvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXG5cdC8vIHN0YXRpYyBwcm9wZXJ0aWVzXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdHAubG9hZCA9IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBUYWdSZXF1ZXN0IHdpbGwgaGFuZGxlIG1vc3Qgb2YgdGhpcywgYnV0IFNvdW5kIC8gVmlkZW8gbmVlZCBhIGZldyBjdXN0b20gcHJvcGVydGllcywgc28ganVzdCBoYW5kbGUgdGhlbSBoZXJlLlxuXHRcdGlmICghdGhpcy5fdGFnKSB7XG5cdFx0XHR0aGlzLl90YWcgPSB0aGlzLl9jcmVhdGVUYWcodGhpcy5faXRlbS5zcmMpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3RhZy5wcmVsb2FkID0gXCJhdXRvXCI7XG5cdFx0dGhpcy5fdGFnLmxvYWQoKTtcblxuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfbG9hZCgpO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHRhZyBmb3IgbG9hZGluZyBpZiBpdCBkb2Vzbid0IGV4aXN0IHlldC5cblx0ICogQG1ldGhvZCBfY3JlYXRlVGFnXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jcmVhdGVUYWcgPSBmdW5jdGlvbiAoKSB7fTtcblxuXG5cdHAuX2NyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX3ByZWZlclhIUikge1xuXHRcdFx0dGhpcy5fcmVxdWVzdCA9IG5ldyBjcmVhdGVqcy5NZWRpYVRhZ1JlcXVlc3QodGhpcy5faXRlbSwgdGhpcy5fdGFnIHx8IHRoaXMuX2NyZWF0ZVRhZygpLCB0aGlzLl90YWdTcmNBdHRyaWJ1dGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLlhIUlJlcXVlc3QodGhpcy5faXRlbSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgcmVzdWx0IGZvcm1hdHRlciBmb3IgbWVkaWEgZmlsZXMuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHJldHVybnMge0hUTUxWaWRlb0VsZW1lbnR8SFRNTEF1ZGlvRWxlbWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHR0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lciAmJiB0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsIHRoaXMuX2xvYWRlZEhhbmRsZXIpO1xuXHRcdHRoaXMuX3RhZy5vbnN0YWxsZWQgPSBudWxsO1xuXHRcdGlmICh0aGlzLl9wcmVmZXJYSFIpIHtcblx0XHRcdGxvYWRlci5nZXRUYWcoKS5zcmMgPSBsb2FkZXIuZ2V0UmVzdWx0KHRydWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gbG9hZGVyLmdldFRhZygpO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkFic3RyYWN0TWVkaWFMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEFic3RyYWN0TWVkaWFMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBBYnN0cmFjdFJlcXVlc3QuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogQSBiYXNlIGNsYXNzIGZvciBhY3R1YWwgZGF0YSByZXF1ZXN0cywgc3VjaCBhcyB7eyNjcm9zc0xpbmsgXCJYSFJSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJUYWdSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBhbmQge3sjY3Jvc3NMaW5rIFwiTWVkaWFSZXF1ZXN0XCJ9fXt7L2Nyb3NzTGlua319LiBQcmVsb2FkSlMgbG9hZGVycyB3aWxsIHR5cGljYWxseSB1c2UgYSBkYXRhIGxvYWRlciB1bmRlciB0aGVcblx0ICogaG9vZCB0byBnZXQgZGF0YS5cblx0ICogQGNsYXNzIEFic3RyYWN0UmVxdWVzdFxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfSBpdGVtXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0dmFyIEFic3RyYWN0UmVxdWVzdCA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0dGhpcy5faXRlbSA9IGl0ZW07XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoQWJzdHJhY3RSZXF1ZXN0LCBjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIpO1xuXG5cdC8vIHB1YmxpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBCZWdpbiBhIGxvYWQuXG5cdCAqIEBtZXRob2QgbG9hZFxuXHQgKi9cblx0cC5sb2FkID0gIGZ1bmN0aW9uKCkge307XG5cblx0LyoqXG5cdCAqIENsZWFuIHVwIGEgcmVxdWVzdC5cblx0ICogQG1ldGhvZCBkZXN0cm95XG5cdCAqL1xuXHRwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qKlxuXHQgKiBDYW5jZWwgYW4gaW4tcHJvZ3Jlc3MgcmVxdWVzdC5cblx0ICogQG1ldGhvZCBjYW5jZWxcblx0ICovXG5cdHAuY2FuY2VsID0gZnVuY3Rpb24oKSB7fTtcblxuXHRjcmVhdGVqcy5BYnN0cmFjdFJlcXVlc3QgPSBjcmVhdGVqcy5wcm9tb3RlKEFic3RyYWN0UmVxdWVzdCwgXCJFdmVudERpc3BhdGNoZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUYWdSZXF1ZXN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEFuIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0UmVxdWVzdFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGxvYWRzIEhUTUwgdGFncywgc3VjaCBhcyBpbWFnZXMgYW5kIHNjcmlwdHMuXG5cdCAqIEBjbGFzcyBUYWdSZXF1ZXN0XG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW19IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhZ1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjQXR0cmlidXRlIFRoZSB0YWcgYXR0cmlidXRlIHRoYXQgc3BlY2lmaWVzIHRoZSBzb3VyY2UsIHN1Y2ggYXMgXCJzcmNcIiwgXCJocmVmXCIsIGV0Yy5cblx0ICovXG5cdGZ1bmN0aW9uIFRhZ1JlcXVlc3QobG9hZEl0ZW0sIHRhZywgc3JjQXR0cmlidXRlKSB7XG5cdFx0dGhpcy5BYnN0cmFjdFJlcXVlc3RfY29uc3RydWN0b3IobG9hZEl0ZW0pO1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBUaGUgSFRNTCB0YWcgaW5zdGFuY2UgdGhhdCBpcyB1c2VkIHRvIGxvYWQuXG5cdFx0ICogQHByb3BlcnR5IF90YWdcblx0XHQgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3RhZyA9IHRhZztcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0YWcgYXR0cmlidXRlIHRoYXQgc3BlY2lmaWVzIHRoZSBzb3VyY2UsIHN1Y2ggYXMgXCJzcmNcIiwgXCJocmVmXCIsIGV0Yy5cblx0XHQgKiBAcHJvcGVydHkgX3RhZ1NyY0F0dHJpYnV0ZVxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSA9IHNyY0F0dHJpYnV0ZTtcblxuXHRcdC8qKlxuXHRcdCAqIEEgbWV0aG9kIGNsb3N1cmUgdXNlZCBmb3IgaGFuZGxpbmcgdGhlIHRhZyBsb2FkIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZGVkSGFuZGxlclxuXHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRlZEhhbmRsZXIgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVUYWdDb21wbGV0ZSwgdGhpcyk7XG5cblx0XHQvKipcblx0XHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBlbGVtZW50IHdhcyBhZGRlZCB0byB0aGUgRE9NIGF1dG9tYXRpY2FsbHkgYnkgUHJlbG9hZEpTLCBzbyBpdCBjYW4gYmUgY2xlYW5lZCB1cCBhZnRlci5cblx0XHQgKiBAcHJvcGVydHkgX2FkZGVkVG9ET01cblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2FkZGVkVG9ET00gPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZXMgd2hhdCB0aGUgdGFncyBpbml0aWFsIHN0eWxlLnZpc2liaWxpdHkgd2FzLCBzbyB3ZSBjYW4gc2V0IGl0IGNvcnJlY3RseSBhZnRlciBhIGxvYWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7bnVsbH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3N0YXJ0VGFnVmlzaWJpbGl0eSA9IG51bGw7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoVGFnUmVxdWVzdCwgY3JlYXRlanMuQWJzdHJhY3RSZXF1ZXN0KTtcblxuXHQvLyBwdWJsaWMgbWV0aG9kc1xuXHRwLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdGFnLm9ubG9hZCA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRhZ0NvbXBsZXRlLCB0aGlzKTtcblx0XHR0aGlzLl90YWcub25yZWFkeXN0YXRlY2hhbmdlID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZSwgdGhpcyk7XG5cdFx0dGhpcy5fdGFnLm9uZXJyb3IgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVFcnJvciwgdGhpcyk7XG5cblx0XHR2YXIgZXZ0ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiaW5pdGlhbGl6ZVwiKTtcblx0XHRldnQubG9hZGVyID0gdGhpcy5fdGFnO1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cblx0XHR0aGlzLl9oaWRlVGFnKCk7XG5cblx0XHR0aGlzLl9sb2FkVGltZW91dCA9IHNldFRpbWVvdXQoY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlVGltZW91dCwgdGhpcyksIHRoaXMuX2l0ZW0ubG9hZFRpbWVvdXQpO1xuXG5cdFx0dGhpcy5fdGFnW3RoaXMuX3RhZ1NyY0F0dHJpYnV0ZV0gPSB0aGlzLl9pdGVtLnNyYztcblxuXHRcdC8vIHdkZzo6IEFwcGVuZCB0aGUgdGFnIEFGVEVSIHNldHRpbmcgdGhlIHNyYywgb3IgU1ZHIGxvYWRpbmcgb24gaU9TIHdpbGwgZmFpbC5cblx0XHRpZiAodGhpcy5fdGFnLnBhcmVudE5vZGUgPT0gbnVsbCkge1xuXHRcdFx0d2luZG93LmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fdGFnKTtcblx0XHRcdHRoaXMuX2FkZGVkVG9ET00gPSB0cnVlO1xuXHRcdH1cblx0fTtcblxuXHRwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuX3RhZyA9IG51bGw7XG5cblx0XHR0aGlzLkFic3RyYWN0UmVxdWVzdF9kZXN0cm95KCk7XG5cdH07XG5cblx0Ly8gcHJpdmF0ZSBtZXRob2RzXG5cdC8qKlxuXHQgKiBIYW5kbGUgdGhlIHJlYWR5U3RhdGVDaGFuZ2UgZXZlbnQgZnJvbSBhIHRhZy4gV2UgbmVlZCB0aGlzIGluIHBsYWNlIG9mIHRoZSBgb25sb2FkYCBjYWxsYmFjayAobWFpbmx5IFNDUklQVFxuXHQgKiBhbmQgTElOSyB0YWdzKSwgYnV0IG90aGVyIGNhc2VzIG1heSBleGlzdC5cblx0ICogQG1ldGhvZCBfaGFuZGxlUmVhZHlTdGF0ZUNoYW5nZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlUmVhZHlTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fbG9hZFRpbWVvdXQpO1xuXHRcdC8vIFRoaXMgaXMgc3RyaWN0bHkgZm9yIHRhZ3MgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBvbmxvYWQuXG5cdFx0dmFyIHRhZyA9IHRoaXMuX3RhZztcblxuXHRcdC8vIENvbXBsZXRlIGlzIGZvciBvbGQgSUUgc3VwcG9ydC5cblx0XHRpZiAodGFnLnJlYWR5U3RhdGUgPT0gXCJsb2FkZWRcIiB8fCB0YWcucmVhZHlTdGF0ZSA9PSBcImNvbXBsZXRlXCIpIHtcblx0XHRcdHRoaXMuX2hhbmRsZVRhZ0NvbXBsZXRlKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGUgYW55IGVycm9yIGV2ZW50cyBmcm9tIHRoZSB0YWcuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUVycm9yXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2hhbmRsZUVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fY2xlYW4oKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJlcnJvclwiKTtcblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlIHRoZSB0YWcncyBvbmxvYWQgY2FsbGJhY2suXG5cdCAqIEBtZXRob2QgX2hhbmRsZVRhZ0NvbXBsZXRlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVUYWdDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9yYXdSZXN1bHQgPSB0aGlzLl90YWc7XG5cdFx0dGhpcy5fcmVzdWx0ID0gdGhpcy5yZXN1bHRGb3JtYXR0ZXIgJiYgdGhpcy5yZXN1bHRGb3JtYXR0ZXIodGhpcykgfHwgdGhpcy5fcmF3UmVzdWx0O1xuXG5cdFx0dGhpcy5fY2xlYW4oKTtcblx0XHR0aGlzLl9zaG93VGFnKCk7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIHRhZyByZXF1ZXN0IGhhcyBub3QgbG9hZGVkIHdpdGhpbiB0aGUgdGltZSBzcGVjaWZpZWQgaW4gbG9hZFRpbWVvdXQuXG5cdCAqIEBtZXRob2QgX2hhbmRsZUVycm9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGVycm9yIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9jbGVhbigpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXZlbnQoXCJ0aW1lb3V0XCIpKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycywgYnV0IGRvbid0IGRlc3Ryb3kgdGhlIHJlcXVlc3Qgb2JqZWN0XG5cdCAqIEBtZXRob2QgX2NsZWFuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jbGVhbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3RhZy5vbmxvYWQgPSBudWxsO1xuXHRcdHRoaXMuX3RhZy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXHRcdHRoaXMuX3RhZy5vbmVycm9yID0gbnVsbDtcblx0XHRpZiAodGhpcy5fYWRkZWRUb0RPTSAmJiB0aGlzLl90YWcucGFyZW50Tm9kZSAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl90YWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl90YWcpO1xuXHRcdH1cblx0XHRjbGVhclRpbWVvdXQodGhpcy5fbG9hZFRpbWVvdXQpO1xuXHR9O1xuXG5cdHAuX2hpZGVUYWcgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9zdGFydFRhZ1Zpc2liaWxpdHkgPSB0aGlzLl90YWcuc3R5bGUudmlzaWJpbGl0eTtcblx0XHR0aGlzLl90YWcuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG5cdH07XG5cblx0cC5fc2hvd1RhZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3RhZy5zdHlsZS52aXNpYmlsaXR5ID0gdGhpcy5fc3RhcnRUYWdWaXNpYmlsaXR5O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBIYW5kbGUgYSBzdGFsbGVkIGF1ZGlvIGV2ZW50LiBUaGUgbWFpbiBwbGFjZSB0aGlzIGhhcHBlbnMgaXMgd2l0aCBIVE1MQXVkaW8gaW4gQ2hyb21lIHdoZW4gcGxheWluZyBiYWNrIGF1ZGlvXG5cdCAqIHRoYXQgaXMgYWxyZWFkeSBpbiBhIGxvYWQsIGJ1dCBub3QgY29tcGxldGUuXG5cdCAqIEBtZXRob2QgX2hhbmRsZVN0YWxsZWRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZVN0YWxsZWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly9JZ25vcmUsIGxldCB0aGUgdGltZW91dCB0YWtlIGNhcmUgb2YgaXQuIFNvbWV0aW1lcyBpdHMgbm90IHJlYWxseSBzdG9wcGVkLlxuXHR9O1xuXG5cdGNyZWF0ZWpzLlRhZ1JlcXVlc3QgPSBjcmVhdGVqcy5wcm9tb3RlKFRhZ1JlcXVlc3QsIFwiQWJzdHJhY3RSZXF1ZXN0XCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gTWVkaWFUYWdSZXF1ZXN0LmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEFuIHt7I2Nyb3NzTGluayBcIlRhZ1JlcXVlc3RcIn19e3svY3Jvc3NMaW5rfX0gdGhhdCBsb2FkcyBIVE1MIHRhZ3MgZm9yIHZpZGVvIGFuZCBhdWRpby5cblx0ICogQGNsYXNzIE1lZGlhVGFnUmVxdWVzdFxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0hUTUxBdWRpb0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gdGFnXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmNBdHRyaWJ1dGUgVGhlIHRhZyBhdHRyaWJ1dGUgdGhhdCBzcGVjaWZpZXMgdGhlIHNvdXJjZSwgc3VjaCBhcyBcInNyY1wiLCBcImhyZWZcIiwgZXRjLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIE1lZGlhVGFnUmVxdWVzdChsb2FkSXRlbSwgdGFnLCBzcmNBdHRyaWJ1dGUpIHtcblx0XHR0aGlzLkFic3RyYWN0UmVxdWVzdF9jb25zdHJ1Y3Rvcihsb2FkSXRlbSk7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdHRoaXMuX3RhZyA9IHRhZztcblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBzcmNBdHRyaWJ1dGU7XG5cdFx0dGhpcy5fbG9hZGVkSGFuZGxlciA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRhZ0NvbXBsZXRlLCB0aGlzKTtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChNZWRpYVRhZ1JlcXVlc3QsIGNyZWF0ZWpzLlRhZ1JlcXVlc3QpO1xuXHR2YXIgcyA9IE1lZGlhVGFnUmVxdWVzdDtcblxuXHQvLyBwdWJsaWMgbWV0aG9kc1xuXHRwLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNjID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlU3RhbGxlZCwgdGhpcyk7XG5cdFx0dGhpcy5fc3RhbGxlZENhbGxiYWNrID0gc2M7XG5cblx0XHR2YXIgcGMgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVQcm9ncmVzcywgdGhpcyk7XG5cdFx0dGhpcy5faGFuZGxlUHJvZ3Jlc3MgPSBwYztcblxuXHRcdHRoaXMuX3RhZy5hZGRFdmVudExpc3RlbmVyKFwic3RhbGxlZFwiLCBzYyk7XG5cdFx0dGhpcy5fdGFnLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCBwYyk7XG5cblx0XHQvLyBUaGlzIHdpbGwgdGVsbCB1cyB3aGVuIGF1ZGlvIGlzIGJ1ZmZlcmVkIGVub3VnaCB0byBwbGF5IHRocm91Z2gsIGJ1dCBub3Qgd2hlbiBpdHMgbG9hZGVkLlxuXHRcdC8vIFRoZSB0YWcgZG9lc24ndCBrZWVwIGxvYWRpbmcgaW4gQ2hyb21lIG9uY2UgZW5vdWdoIGhhcyBidWZmZXJlZCwgYW5kIHdlIGhhdmUgZGVjaWRlZCB0aGF0IGJlaGF2aW91ciBpcyBzdWZmaWNpZW50LlxuXHRcdHRoaXMuX3RhZy5hZGRFdmVudExpc3RlbmVyICYmIHRoaXMuX3RhZy5hZGRFdmVudExpc3RlbmVyKFwiY2FucGxheXRocm91Z2hcIiwgdGhpcy5fbG9hZGVkSGFuZGxlciwgZmFsc2UpOyAvLyBjYW5wbGF5dGhyb3VnaCBjYWxsYmFjayBkb2Vzbid0IHdvcmsgaW4gQ2hyb21lLCBzbyB3ZSB1c2UgYW4gZXZlbnQuXG5cblx0XHR0aGlzLlRhZ1JlcXVlc3RfbG9hZCgpO1xuXHR9O1xuXG5cdC8vIHByaXZhdGUgbWV0aG9kc1xuXHRwLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9sb2FkVGltZW91dCk7XG5cdFx0Ly8gVGhpcyBpcyBzdHJpY3RseSBmb3IgdGFncyBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IG9ubG9hZC5cblx0XHR2YXIgdGFnID0gdGhpcy5fdGFnO1xuXG5cdFx0Ly8gQ29tcGxldGUgaXMgZm9yIG9sZCBJRSBzdXBwb3J0LlxuXHRcdGlmICh0YWcucmVhZHlTdGF0ZSA9PSBcImxvYWRlZFwiIHx8IHRhZy5yZWFkeVN0YXRlID09IFwiY29tcGxldGVcIikge1xuXHRcdFx0dGhpcy5faGFuZGxlVGFnQ29tcGxldGUoKTtcblx0XHR9XG5cdH07XG5cblx0cC5faGFuZGxlU3RhbGxlZCA9IGZ1bmN0aW9uICgpIHtcblx0XHQvL0lnbm9yZSwgbGV0IHRoZSB0aW1lb3V0IHRha2UgY2FyZSBvZiBpdC4gU29tZXRpbWVzIGl0cyBub3QgcmVhbGx5IHN0b3BwZWQuXG5cdH07XG5cblx0LyoqXG5cdCAqIEFuIFhIUiByZXF1ZXN0IGhhcyByZXBvcnRlZCBwcm9ncmVzcy5cblx0ICogQG1ldGhvZCBfaGFuZGxlUHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgcHJvZ3Jlc3MgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVQcm9ncmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGlmICghZXZlbnQgfHwgZXZlbnQubG9hZGVkID4gMCAmJiBldmVudC50b3RhbCA9PSAwKSB7XG5cdFx0XHRyZXR1cm47IC8vIFNvbWV0aW1lcyB3ZSBnZXQgbm8gXCJ0b3RhbFwiLCBzbyBqdXN0IGlnbm9yZSB0aGUgcHJvZ3Jlc3MgZXZlbnQuXG5cdFx0fVxuXG5cdFx0dmFyIG5ld0V2ZW50ID0gbmV3IGNyZWF0ZWpzLlByb2dyZXNzRXZlbnQoZXZlbnQubG9hZGVkLCBldmVudC50b3RhbCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHRwLl9jbGVhbiA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lciAmJiB0aGlzLl90YWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsIHRoaXMuX2xvYWRlZEhhbmRsZXIpO1xuXHRcdHRoaXMuX3RhZy5yZW1vdmVFdmVudExpc3RlbmVyKFwic3RhbGxlZFwiLCB0aGlzLl9zdGFsbGVkQ2FsbGJhY2spO1xuXHRcdHRoaXMuX3RhZy5yZW1vdmVFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgdGhpcy5fcHJvZ3Jlc3NDYWxsYmFjayk7XG5cblx0XHR0aGlzLlRhZ1JlcXVlc3RfX2NsZWFuKCk7XG5cdH07XG5cblx0Y3JlYXRlanMuTWVkaWFUYWdSZXF1ZXN0ID0gY3JlYXRlanMucHJvbW90ZShNZWRpYVRhZ1JlcXVlc3QsIFwiVGFnUmVxdWVzdFwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFhIUlJlcXVlc3QuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuLy8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgcHJlbG9hZGVyIHRoYXQgbG9hZHMgaXRlbXMgdXNpbmcgWEhSIHJlcXVlc3RzLCB1c3VhbGx5IFhNTEh0dHBSZXF1ZXN0LiBIb3dldmVyIFhEb21haW5SZXF1ZXN0cyB3aWxsIGJlIHVzZWRcblx0ICogZm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cyBpZiBwb3NzaWJsZSwgYW5kIG9sZGVyIHZlcnNpb25zIG9mIElFIGZhbGwgYmFjayBvbiB0byBBY3RpdmVYIG9iamVjdHMgd2hlbiBuZWNlc3NhcnkuXG5cdCAqIFhIUiByZXF1ZXN0cyBsb2FkIHRoZSBjb250ZW50IGFzIHRleHQgb3IgYmluYXJ5IGRhdGEsIHByb3ZpZGUgcHJvZ3Jlc3MgYW5kIGNvbnNpc3RlbnQgY29tcGxldGlvbiBldmVudHMsIGFuZFxuXHQgKiBjYW4gYmUgY2FuY2VsZWQgZHVyaW5nIGxvYWQuIE5vdGUgdGhhdCBYSFIgaXMgbm90IHN1cHBvcnRlZCBpbiBJRSA2IG9yIGVhcmxpZXIsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yXG5cdCAqIGNyb3NzLWRvbWFpbiBsb2FkaW5nLlxuXHQgKiBAY2xhc3MgWEhSUmVxdWVzdFxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIG9iamVjdCB0aGF0IGRlZmluZXMgdGhlIGZpbGUgdG8gbG9hZC4gUGxlYXNlIHNlZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBhbiBvdmVydmlldyBvZiBzdXBwb3J0ZWQgZmlsZSBwcm9wZXJ0aWVzLlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKi9cblx0ZnVuY3Rpb24gWEhSUmVxdWVzdCAoaXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RSZXF1ZXN0X2NvbnN0cnVjdG9yKGl0ZW0pO1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHQvKipcblx0XHQgKiBBIHJlZmVyZW5jZSB0byB0aGUgWEhSIHJlcXVlc3QgdXNlZCB0byBsb2FkIHRoZSBjb250ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBfcmVxdWVzdFxuXHRcdCAqIEB0eXBlIHtYTUxIdHRwUmVxdWVzdCB8IFhEb21haW5SZXF1ZXN0IHwgQWN0aXZlWC5YTUxIVFRQfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcmVxdWVzdCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBIG1hbnVhbCBsb2FkIHRpbWVvdXQgdGhhdCBpcyB1c2VkIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IHRoZSBvblRpbWVvdXQgZXZlbnQgb24gWEhSIChYSFIgbGV2ZWwgMSxcblx0XHQgKiB0eXBpY2FsbHkgSUU5KS5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRUaW1lb3V0XG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRUaW1lb3V0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBicm93c2VyJ3MgWEhSIChYTUxIVFRQUmVxdWVzdCkgdmVyc2lvbi4gU3VwcG9ydGVkIHZlcnNpb25zIGFyZSAxIGFuZCAyLiBUaGVyZSBpcyBubyBvZmZpY2lhbCB3YXkgdG8gZGV0ZWN0XG5cdFx0ICogdGhlIHZlcnNpb24sIHNvIHdlIHVzZSBjYXBhYmlsaXRpZXMgdG8gbWFrZSBhIGJlc3QgZ3Vlc3MuXG5cdFx0ICogQHByb3BlcnR5IF94aHJMZXZlbFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5feGhyTGV2ZWwgPSAxO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHJlc3BvbnNlIG9mIGEgbG9hZGVkIGZpbGUuIFRoaXMgaXMgc2V0IGJlY2F1c2UgaXQgaXMgZXhwZW5zaXZlIHRvIGxvb2sgdXAgY29uc3RhbnRseS4gVGhpcyBwcm9wZXJ0eSB3aWxsIGJlXG5cdFx0ICogbnVsbCB1bnRpbCB0aGUgZmlsZSBpcyBsb2FkZWQuXG5cdFx0ICogQHByb3BlcnR5IF9yZXNwb25zZVxuXHRcdCAqIEB0eXBlIHttaXhlZH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3Jlc3BvbnNlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSByZXNwb25zZSBvZiB0aGUgbG9hZGVkIGZpbGUgYmVmb3JlIGl0IGlzIG1vZGlmaWVkLiBJbiBtb3N0IGNhc2VzLCBjb250ZW50IGlzIGNvbnZlcnRlZCBmcm9tIHJhdyB0ZXh0IHRvXG5cdFx0ICogYW4gSFRNTCB0YWcgb3IgYSBmb3JtYXR0ZWQgb2JqZWN0IHdoaWNoIGlzIHNldCB0byB0aGUgPGNvZGU+cmVzdWx0PC9jb2RlPiBwcm9wZXJ0eSwgYnV0IHRoZSBkZXZlbG9wZXIgbWF5IHN0aWxsXG5cdFx0ICogd2FudCB0byBhY2Nlc3MgdGhlIHJhdyBjb250ZW50IGFzIGl0IHdhcyBsb2FkZWQuXG5cdFx0ICogQHByb3BlcnR5IF9yYXdSZXNwb25zZVxuXHRcdCAqIEB0eXBlIHtTdHJpbmd8T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fcmF3UmVzcG9uc2UgPSBudWxsO1xuXG5cdFx0dGhpcy5fY2FuY2VsZWQgPSBmYWxzZTtcblxuXHRcdC8vIFNldHVwIG91ciBldmVudCBoYW5kbGVycyBub3cuXG5cdFx0dGhpcy5faGFuZGxlTG9hZFN0YXJ0UHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVMb2FkU3RhcnQsIHRoaXMpO1xuXHRcdHRoaXMuX2hhbmRsZVByb2dyZXNzUHJveHkgPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVQcm9ncmVzcywgdGhpcyk7XG5cdFx0dGhpcy5faGFuZGxlQWJvcnRQcm94eSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUFib3J0LCB0aGlzKTtcblx0XHR0aGlzLl9oYW5kbGVFcnJvclByb3h5ID0gY3JlYXRlanMucHJveHkodGhpcy5faGFuZGxlRXJyb3IsIHRoaXMpO1xuXHRcdHRoaXMuX2hhbmRsZVRpbWVvdXRQcm94eSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRpbWVvdXQsIHRoaXMpO1xuXHRcdHRoaXMuX2hhbmRsZUxvYWRQcm94eSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZUxvYWQsIHRoaXMpO1xuXHRcdHRoaXMuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2VQcm94eSA9IGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2UsIHRoaXMpO1xuXG5cdFx0aWYgKCF0aGlzLl9jcmVhdGVYSFIoaXRlbSkpIHtcblx0XHRcdC8vVE9ETzogVGhyb3cgZXJyb3I/XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFhIUlJlcXVlc3QsIGNyZWF0ZWpzLkFic3RyYWN0UmVxdWVzdCk7XG5cbi8vIHN0YXRpYyBwcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBBIGxpc3Qgb2YgWE1MSFRUUCBvYmplY3QgSURzIHRvIHRyeSB3aGVuIGJ1aWxkaW5nIGFuIEFjdGl2ZVggb2JqZWN0IGZvciBYSFIgcmVxdWVzdHMgaW4gZWFybGllciB2ZXJzaW9ucyBvZiBJRS5cblx0ICogQHByb3BlcnR5IEFDVElWRVhfVkVSU0lPTlNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKiBAc2luY2UgMC40LjJcblx0ICogQHByaXZhdGVcblx0ICovXG5cdFhIUlJlcXVlc3QuQUNUSVZFWF9WRVJTSU9OUyA9IFtcblx0XHRcIk1zeG1sMi5YTUxIVFRQLjYuMFwiLFxuXHRcdFwiTXN4bWwyLlhNTEhUVFAuNS4wXCIsXG5cdFx0XCJNc3htbDIuWE1MSFRUUC40LjBcIixcblx0XHRcIk1TWE1MMi5YTUxIVFRQLjMuMFwiLFxuXHRcdFwiTVNYTUwyLlhNTEhUVFBcIixcblx0XHRcIk1pY3Jvc29mdC5YTUxIVFRQXCJcblx0XTtcblxuLy8gUHVibGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIExvb2sgdXAgdGhlIGxvYWRlZCByZXN1bHQuXG5cdCAqIEBtZXRob2QgZ2V0UmVzdWx0XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Jhdz1mYWxzZV0gUmV0dXJuIGEgcmF3IHJlc3VsdCBpbnN0ZWFkIG9mIGEgZm9ybWF0dGVkIHJlc3VsdC4gVGhpcyBhcHBsaWVzIHRvIGNvbnRlbnRcblx0ICogbG9hZGVkIHZpYSBYSFIgc3VjaCBhcyBzY3JpcHRzLCBYTUwsIENTUywgYW5kIEltYWdlcy4gSWYgdGhlcmUgaXMgbm8gcmF3IHJlc3VsdCwgdGhlIGZvcm1hdHRlZCByZXN1bHQgd2lsbCBiZVxuXHQgKiByZXR1cm5lZCBpbnN0ZWFkLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEEgcmVzdWx0IG9iamVjdCBjb250YWluaW5nIHRoZSBjb250ZW50IHRoYXQgd2FzIGxvYWRlZCwgc3VjaCBhczpcblx0ICogPHVsPlxuXHQgKiAgICAgIDxsaT5BbiBpbWFnZSB0YWcgKCZsdDtpbWFnZSAvJmd0OykgZm9yIGltYWdlczwvbGk+XG5cdCAqICAgICAgPGxpPkEgc2NyaXB0IHRhZyBmb3IgSmF2YVNjcmlwdCAoJmx0O3NjcmlwdCAvJmd0OykuIE5vdGUgdGhhdCBzY3JpcHRzIGxvYWRlZCB3aXRoIHRhZ3MgbWF5IGJlIGFkZGVkIHRvIHRoZVxuXHQgKiAgICAgIEhUTUwgaGVhZC48L2xpPlxuXHQgKiAgICAgIDxsaT5BIHN0eWxlIHRhZyBmb3IgQ1NTICgmbHQ7c3R5bGUgLyZndDspPC9saT5cblx0ICogICAgICA8bGk+UmF3IHRleHQgZm9yIFRFWFQ8L2xpPlxuXHQgKiAgICAgIDxsaT5BIGZvcm1hdHRlZCBKYXZhU2NyaXB0IG9iamVjdCBkZWZpbmVkIGJ5IEpTT048L2xpPlxuXHQgKiAgICAgIDxsaT5BbiBYTUwgZG9jdW1lbnQ8L2xpPlxuXHQgKiAgICAgIDxsaT5BbiBiaW5hcnkgYXJyYXlidWZmZXIgbG9hZGVkIGJ5IFhIUjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIE5vdGUgdGhhdCBpZiBhIHJhdyByZXN1bHQgaXMgcmVxdWVzdGVkLCBidXQgbm90IGZvdW5kLCB0aGUgcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZC5cblx0ICovXG5cdHAuZ2V0UmVzdWx0ID0gZnVuY3Rpb24gKHJhdykge1xuXHRcdGlmIChyYXcgJiYgdGhpcy5fcmF3UmVzcG9uc2UpIHtcblx0XHRcdHJldHVybiB0aGlzLl9yYXdSZXNwb25zZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3Jlc3BvbnNlO1xuXHR9O1xuXG5cdC8vIE92ZXJyaWRlcyBhYnN0cmFjdCBtZXRob2QgaW4gQWJzdHJhY3RSZXF1ZXN0XG5cdHAuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuY2FuY2VsZWQgPSB0cnVlO1xuXHRcdHRoaXMuX2NsZWFuKCk7XG5cdFx0dGhpcy5fcmVxdWVzdC5hYm9ydCgpO1xuXHR9O1xuXG5cdC8vIE92ZXJyaWRlcyBhYnN0cmFjdCBtZXRob2QgaW4gQWJzdHJhY3RMb2FkZXJcblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9yZXF1ZXN0ID09IG51bGwpIHtcblx0XHRcdHRoaXMuX2hhbmRsZUVycm9yKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly9FdmVudHNcblx0XHRpZiAodGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRzdGFydFwiLCB0aGlzLl9oYW5kbGVMb2FkU3RhcnRQcm94eSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgdGhpcy5faGFuZGxlUHJvZ3Jlc3NQcm94eSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgdGhpcy5faGFuZGxlQWJvcnRQcm94eSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5faGFuZGxlRXJyb3JQcm94eSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwidGltZW91dFwiLCB0aGlzLl9oYW5kbGVUaW1lb3V0UHJveHksIGZhbHNlKTtcblxuXHRcdFx0Ly8gTm90ZTogV2UgZG9uJ3QgZ2V0IG9ubG9hZCBpbiBhbGwgYnJvd3NlcnMgKGVhcmxpZXIgRkYgYW5kIElFKS4gb25SZWFkeVN0YXRlQ2hhbmdlIGhhbmRsZXMgdGhlc2UuXG5cdFx0XHR0aGlzLl9yZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHRoaXMuX2hhbmRsZUxvYWRQcm94eSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLCB0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlUHJveHksIGZhbHNlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gSUU5IHN1cHBvcnRcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25sb2Fkc3RhcnQgPSB0aGlzLl9oYW5kbGVMb2FkU3RhcnRQcm94eTtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25wcm9ncmVzcyA9IHRoaXMuX2hhbmRsZVByb2dyZXNzUHJveHk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9uYWJvcnQgPSB0aGlzLl9oYW5kbGVBYm9ydFByb3h5O1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbmVycm9yID0gdGhpcy5faGFuZGxlRXJyb3JQcm94eTtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub250aW1lb3V0ID0gdGhpcy5faGFuZGxlVGltZW91dFByb3h5O1xuXG5cdFx0XHQvLyBOb3RlOiBXZSBkb24ndCBnZXQgb25sb2FkIGluIGFsbCBicm93c2VycyAoZWFybGllciBGRiBhbmQgSUUpLiBvblJlYWR5U3RhdGVDaGFuZ2UgaGFuZGxlcyB0aGVzZS5cblx0XHRcdHRoaXMuX3JlcXVlc3Qub25sb2FkID0gdGhpcy5faGFuZGxlTG9hZFByb3h5O1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB0aGlzLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlUHJveHk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHVwIGEgdGltZW91dCBpZiB3ZSBkb24ndCBoYXZlIFhIUjJcblx0XHRpZiAodGhpcy5feGhyTGV2ZWwgPT0gMSkge1xuXHRcdFx0dGhpcy5fbG9hZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRpbWVvdXQsIHRoaXMpLCB0aGlzLl9pdGVtLmxvYWRUaW1lb3V0KTtcblx0XHR9XG5cblx0XHQvLyBTb21ldGltZXMgd2UgZ2V0IGJhY2sgNDA0cyBpbW1lZGlhdGVseSwgcGFydGljdWxhcmx5IHdoZW4gdGhlcmUgaXMgYSBjcm9zcyBvcmlnaW4gcmVxdWVzdC4gIC8vIG5vdGUgdGhpcyBkb2VzIG5vdCBjYXRjaCBpbiBDaHJvbWVcblx0XHR0cnkge1xuXHRcdFx0aWYgKCF0aGlzLl9pdGVtLnZhbHVlcyB8fCB0aGlzLl9pdGVtLm1ldGhvZCA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5HRVQpIHtcblx0XHRcdFx0dGhpcy5fcmVxdWVzdC5zZW5kKCk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2l0ZW0ubWV0aG9kID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlBPU1QpIHtcblx0XHRcdFx0dGhpcy5fcmVxdWVzdC5zZW5kKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5mb3JtYXRRdWVyeVN0cmluZyh0aGlzLl9pdGVtLnZhbHVlcykpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJYSFJfU0VORFwiLCBudWxsLCBlcnJvcikpO1xuXHRcdH1cblx0fTtcblxuXHRwLnNldFJlc3BvbnNlVHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG5cdFx0Ly8gU29tZSBvbGQgYnJvd3NlcnMgZG9lc24ndCBzdXBwb3J0IGJsb2IsIHNvIHdlIGNvbnZlcnQgYXJyYXlidWZmZXIgdG8gYmxvYiBhZnRlciByZXNwb25zZSBpcyBkb3dubG9hZGVkXG5cdFx0aWYgKHR5cGUgPT09ICdibG9iJykge1xuXHRcdFx0dHlwZSA9IHdpbmRvdy5VUkwgPyAnYmxvYicgOiAnYXJyYXlidWZmZXInO1xuXHRcdFx0dGhpcy5fcmVzcG9uc2VUeXBlID0gdHlwZTtcblx0XHR9XG5cdFx0dGhpcy5fcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0eXBlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgYWxsIHRoZSByZXNwb25zZSBoZWFkZXJzIGZyb20gdGhlIFhtbEh0dHBSZXF1ZXN0LlxuXHQgKlxuXHQgKiA8c3Ryb25nPkZyb20gdGhlIGRvY3M6PC9zdHJvbmc+IFJldHVybiBhbGwgdGhlIEhUVFAgaGVhZGVycywgZXhjbHVkaW5nIGhlYWRlcnMgdGhhdCBhcmUgYSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoXG5cdCAqIGZvciBTZXQtQ29va2llIG9yIFNldC1Db29raWUyLCBhcyBhIHNpbmdsZSBzdHJpbmcsIHdpdGggZWFjaCBoZWFkZXIgbGluZSBzZXBhcmF0ZWQgYnkgYSBVKzAwMEQgQ1IgVSswMDBBIExGIHBhaXIsXG5cdCAqIGV4Y2x1ZGluZyB0aGUgc3RhdHVzIGxpbmUsIGFuZCB3aXRoIGVhY2ggaGVhZGVyIG5hbWUgYW5kIGhlYWRlciB2YWx1ZSBzZXBhcmF0ZWQgYnkgYSBVKzAwM0EgQ09MT04gVSswMDIwIFNQQUNFXG5cdCAqIHBhaXIuXG5cdCAqIEBtZXRob2QgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICogQHNpbmNlIDAuNC4xXG5cdCAqL1xuXHRwLmdldEFsbFJlc3BvbnNlSGVhZGVycyA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3JlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogR2V0IGEgc3BlY2lmaWMgcmVzcG9uc2UgaGVhZGVyIGZyb20gdGhlIFhtbEh0dHBSZXF1ZXN0LlxuXHQgKlxuXHQgKiA8c3Ryb25nPkZyb20gdGhlIGRvY3M6PC9zdHJvbmc+IFJldHVybnMgdGhlIGhlYWRlciBmaWVsZCB2YWx1ZSBmcm9tIHRoZSByZXNwb25zZSBvZiB3aGljaCB0aGUgZmllbGQgbmFtZSBtYXRjaGVzXG5cdCAqIGhlYWRlciwgdW5sZXNzIHRoZSBmaWVsZCBuYW1lIGlzIFNldC1Db29raWUgb3IgU2V0LUNvb2tpZTIuXG5cdCAqIEBtZXRob2QgZ2V0UmVzcG9uc2VIZWFkZXJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgaGVhZGVyIG5hbWUgdG8gcmV0cmlldmUuXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICogQHNpbmNlIDAuNC4xXG5cdCAqL1xuXHRwLmdldFJlc3BvbnNlSGVhZGVyID0gZnVuY3Rpb24gKGhlYWRlcikge1xuXHRcdGlmICh0aGlzLl9yZXF1ZXN0LmdldFJlc3BvbnNlSGVhZGVyIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXF1ZXN0LmdldFJlc3BvbnNlSGVhZGVyKGhlYWRlcik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fTtcblxuLy8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgcHJvZ3Jlc3MuXG5cdCAqIEBtZXRob2QgX2hhbmRsZVByb2dyZXNzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIHByb2dyZXNzIGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRpZiAoIWV2ZW50IHx8IGV2ZW50LmxvYWRlZCA+IDAgJiYgZXZlbnQudG90YWwgPT0gMCkge1xuXHRcdFx0cmV0dXJuOyAvLyBTb21ldGltZXMgd2UgZ2V0IG5vIFwidG90YWxcIiwgc28ganVzdCBpZ25vcmUgdGhlIHByb2dyZXNzIGV2ZW50LlxuXHRcdH1cblxuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5Qcm9ncmVzc0V2ZW50KGV2ZW50LmxvYWRlZCwgZXZlbnQudG90YWwpO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgYSBsb2FkIHN0YXJ0LlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVMb2FkU3RhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgbG9hZFN0YXJ0IGV2ZW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTG9hZFN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2xvYWRUaW1lb3V0KTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJsb2Fkc3RhcnRcIik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgcmVwb3J0ZWQgYW4gYWJvcnQgZXZlbnQuXG5cdCAqIEBtZXRob2QgaGFuZGxlQWJvcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgYWJvcnQgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVBYm9ydCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuX2NsZWFuKCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiWEhSX0FCT1JURURcIiwgbnVsbCwgZXZlbnQpKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIFhIUiByZXF1ZXN0IGhhcyByZXBvcnRlZCBhbiBlcnJvciBldmVudC5cblx0ICogQG1ldGhvZCBfaGFuZGxlRXJyb3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgZXJyb3IgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuX2NsZWFuKCk7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KGV2ZW50Lm1lc3NhZ2UpKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIFhIUiByZXF1ZXN0IGhhcyByZXBvcnRlZCBhIHJlYWR5U3RhdGUgY2hhbmdlLiBOb3RlIHRoYXQgb2xkZXIgYnJvd3NlcnMgKElFIDcgJiA4KSBkbyBub3QgcHJvdmlkZSBhbiBvbmxvYWRcblx0ICogZXZlbnQsIHNvIHdlIG11c3QgbW9uaXRvciB0aGUgcmVhZHlTdGF0ZUNoYW5nZSB0byBkZXRlcm1pbmUgaWYgdGhlIGZpbGUgaXMgbG9hZGVkLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIHJlYWR5U3RhdGVDaGFuZ2UgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVSZWFkeVN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuX3JlcXVlc3QucmVhZHlTdGF0ZSA9PSA0KSB7XG5cdFx0XHR0aGlzLl9oYW5kbGVMb2FkKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgWEhSIHJlcXVlc3QgaGFzIGNvbXBsZXRlZC4gVGhpcyBpcyBjYWxsZWQgYnkgdGhlIFhIUiByZXF1ZXN0IGRpcmVjdGx5LCBvciBieSBhIHJlYWR5U3RhdGVDaGFuZ2UgdGhhdCBoYXNcblx0ICogPGNvZGU+cmVxdWVzdC5yZWFkeVN0YXRlID09IDQ8L2NvZGU+LiBPbmx5IHRoZSBmaXJzdCBjYWxsIHRvIHRoaXMgbWV0aG9kIHdpbGwgYmUgcHJvY2Vzc2VkLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVMb2FkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgWEhSIGxvYWQgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVMb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMubG9hZGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMubG9hZGVkID0gdHJ1ZTtcblxuXHRcdHZhciBlcnJvciA9IHRoaXMuX2NoZWNrRXJyb3IoKTtcblx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdHRoaXMuX2hhbmRsZUVycm9yKGVycm9yKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9yZXNwb25zZSA9IHRoaXMuX2dldFJlc3BvbnNlKCk7XG5cdFx0Ly8gQ29udmVydCBhcnJheWJ1ZmZlciBiYWNrIHRvIGJsb2Jcblx0XHRpZiAodGhpcy5fcmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0aGlzLl9yZXNwb25zZSA9IG5ldyBCbG9iKFt0aGlzLl9yZXNwb25zZV0pO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHQvLyBGYWxsYmFjayB0byB1c2UgQmxvYkJ1aWxkZXIgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBub3Qgc3VwcG9ydGVkXG5cdFx0XHRcdC8vIFRlc3RlZCBvbiBBbmRyb2lkIDIuMyB+IDQuMiBhbmQgaU9TNSBzYWZhcmlcblx0XHRcdFx0d2luZG93LkJsb2JCdWlsZGVyID0gd2luZG93LkJsb2JCdWlsZGVyIHx8IHdpbmRvdy5XZWJLaXRCbG9iQnVpbGRlciB8fCB3aW5kb3cuTW96QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1TQmxvYkJ1aWxkZXI7XG5cdFx0XHRcdGlmIChlLm5hbWUgPT09ICdUeXBlRXJyb3InICYmIHdpbmRvdy5CbG9iQnVpbGRlcikge1xuXHRcdFx0XHRcdHZhciBidWlsZGVyID0gbmV3IEJsb2JCdWlsZGVyKCk7XG5cdFx0XHRcdFx0YnVpbGRlci5hcHBlbmQodGhpcy5fcmVzcG9uc2UpO1xuXHRcdFx0XHRcdHRoaXMuX3Jlc3BvbnNlID0gYnVpbGRlci5nZXRCbG9iKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fY2xlYW4oKTtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXZlbnQoXCJjb21wbGV0ZVwiKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBYSFIgcmVxdWVzdCBoYXMgdGltZWQgb3V0LiBUaGlzIGlzIGNhbGxlZCBieSB0aGUgWEhSIHJlcXVlc3QgZGlyZWN0bHksIG9yIHZpYSBhIDxjb2RlPnNldFRpbWVvdXQ8L2NvZGU+XG5cdCAqIGNhbGxiYWNrLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVUaW1lb3V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnRdIFRoZSBYSFIgdGltZW91dCBldmVudC4gVGhpcyBpcyBvY2Nhc2lvbmFsbHkgbnVsbCB3aGVuIGNhbGxlZCBieSB0aGUgYmFja3VwIHNldFRpbWVvdXQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVUaW1lb3V0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dGhpcy5fY2xlYW4oKTtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlBSRUxPQURfVElNRU9VVFwiLCBudWxsLCBldmVudCkpO1xuXHR9O1xuXG4vLyBQcm90ZWN0ZWRcblx0LyoqXG5cdCAqIERldGVybWluZSBpZiB0aGVyZSBpcyBhbiBlcnJvciBpbiB0aGUgY3VycmVudCBsb2FkLiBUaGlzIGNoZWNrcyB0aGUgc3RhdHVzIG9mIHRoZSByZXF1ZXN0IGZvciBwcm9ibGVtIGNvZGVzLiBOb3RlXG5cdCAqIHRoYXQgdGhpcyBkb2VzIG5vdCBjaGVjayBmb3IgYW4gYWN0dWFsIHJlc3BvbnNlLiBDdXJyZW50bHksIGl0IG9ubHkgY2hlY2tzIGZvciA0MDQgb3IgMCBlcnJvciBjb2RlLlxuXHQgKiBAbWV0aG9kIF9jaGVja0Vycm9yXG5cdCAqIEByZXR1cm4ge2ludH0gSWYgdGhlIHJlcXVlc3Qgc3RhdHVzIHJldHVybnMgYW4gZXJyb3IgY29kZS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NoZWNrRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdFx0Ly9MTTogUHJvYmFibHkgbmVlZCBhZGRpdGlvbmFsIGhhbmRsZXJzIGhlcmUsIG1heWJlIDUwMVxuXHRcdHZhciBzdGF0dXMgPSBwYXJzZUludCh0aGlzLl9yZXF1ZXN0LnN0YXR1cyk7XG5cblx0XHRzd2l0Y2ggKHN0YXR1cykge1xuXHRcdFx0Y2FzZSA0MDQ6ICAgLy8gTm90IEZvdW5kXG5cdFx0XHRjYXNlIDA6ICAgICAvLyBOb3QgTG9hZGVkXG5cdFx0XHRcdHJldHVybiBuZXcgRXJyb3Ioc3RhdHVzKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIFZhbGlkYXRlIHRoZSByZXNwb25zZS4gRGlmZmVyZW50IGJyb3dzZXJzIGhhdmUgZGlmZmVyZW50IGFwcHJvYWNoZXMsIHNvbWUgb2Ygd2hpY2ggdGhyb3cgZXJyb3JzIHdoZW4gYWNjZXNzZWRcblx0ICogaW4gb3RoZXIgYnJvd3NlcnMuIElmIHRoZXJlIGlzIG5vIHJlc3BvbnNlLCB0aGUgPGNvZGU+X3Jlc3BvbnNlPC9jb2RlPiBwcm9wZXJ0eSB3aWxsIHJlbWFpbiBudWxsLlxuXHQgKiBAbWV0aG9kIF9nZXRSZXNwb25zZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZ2V0UmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Jlc3BvbnNlICE9IG51bGwpIHtcblx0XHRcdHJldHVybiB0aGlzLl9yZXNwb25zZTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fcmVxdWVzdC5yZXNwb25zZSAhPSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fcmVxdWVzdC5yZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBbmRyb2lkIDIuMiB1c2VzIC5yZXNwb25zZVRleHRcblx0XHR0cnkge1xuXHRcdFx0aWYgKHRoaXMuX3JlcXVlc3QucmVzcG9uc2VUZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JlcXVlc3QucmVzcG9uc2VUZXh0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHR9XG5cblx0XHQvLyBXaGVuIGxvYWRpbmcgWE1MLCBJRTkgZG9lcyBub3QgcmV0dXJuIC5yZXNwb25zZSwgaW5zdGVhZCBpdCByZXR1cm5zIHJlc3BvbnNlWE1MLnhtbFxuXHRcdHRyeSB7XG5cdFx0XHRpZiAodGhpcy5fcmVxdWVzdC5yZXNwb25zZVhNTCAhPSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9yZXF1ZXN0LnJlc3BvbnNlWE1MO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGFuIFhIUiByZXF1ZXN0LiBEZXBlbmRpbmcgb24gYSBudW1iZXIgb2YgZmFjdG9ycywgd2UgZ2V0IHRvdGFsbHkgZGlmZmVyZW50IHJlc3VsdHMuXG5cdCAqIDxvbD48bGk+U29tZSBicm93c2VycyBnZXQgYW4gPGNvZGU+WERvbWFpblJlcXVlc3Q8L2NvZGU+IHdoZW4gbG9hZGluZyBjcm9zcy1kb21haW4uPC9saT5cblx0ICogICAgICA8bGk+WE1MSHR0cFJlcXVlc3QgYXJlIGNyZWF0ZWQgd2hlbiBhdmFpbGFibGUuPC9saT5cblx0ICogICAgICA8bGk+QWN0aXZlWC5YTUxIVFRQIG9iamVjdHMgYXJlIHVzZWQgaW4gb2xkZXIgSUUgYnJvd3NlcnMuPC9saT5cblx0ICogICAgICA8bGk+VGV4dCByZXF1ZXN0cyBvdmVycmlkZSB0aGUgbWltZSB0eXBlIGlmIHBvc3NpYmxlPC9saT5cblx0ICogICAgICA8bGk+T3JpZ2luIGhlYWRlcnMgYXJlIHNlbnQgZm9yIGNyb3NzZG9tYWluIHJlcXVlc3RzIGluIHNvbWUgYnJvd3NlcnMuPC9saT5cblx0ICogICAgICA8bGk+QmluYXJ5IGxvYWRzIHNldCB0aGUgcmVzcG9uc2UgdHlwZSB0byBcImFycmF5YnVmZmVyXCI8L2xpPjwvb2w+XG5cdCAqIEBtZXRob2QgX2NyZWF0ZVhIUlxuXHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBUaGUgcmVxdWVzdGVkIGl0ZW0gdGhhdCBpcyBiZWluZyBsb2FkZWQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIGFuIFhIUiByZXF1ZXN0IG9yIGVxdWl2YWxlbnQgd2FzIHN1Y2Nlc3NmdWxseSBjcmVhdGVkLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY3JlYXRlWEhSID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHQvLyBDaGVjayBmb3IgY3Jvc3MtZG9tYWluIGxvYWRzLiBXZSBjYW4ndCBmdWxseSBzdXBwb3J0IHRoZW0sIGJ1dCB3ZSBjYW4gdHJ5LlxuXHRcdHZhciBjcm9zc2RvbWFpbiA9IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0Nyb3NzRG9tYWluKGl0ZW0pO1xuXHRcdHZhciBoZWFkZXJzID0ge307XG5cblx0XHQvLyBDcmVhdGUgdGhlIHJlcXVlc3QuIEZhbGxiYWNrIHRvIHdoYXRldmVyIHN1cHBvcnQgd2UgaGF2ZS5cblx0XHR2YXIgcmVxID0gbnVsbDtcblx0XHRpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG5cdFx0XHRyZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0XHRcdC8vIFRoaXMgaXMgOCBvciA5LCBzbyB1c2UgWERvbWFpblJlcXVlc3QgaW5zdGVhZC5cblx0XHRcdGlmIChjcm9zc2RvbWFpbiAmJiByZXEud2l0aENyZWRlbnRpYWxzID09PSB1bmRlZmluZWQgJiYgd2luZG93LlhEb21haW5SZXF1ZXN0KSB7XG5cdFx0XHRcdHJlcSA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7IC8vIE9sZCBJRSB2ZXJzaW9ucyB1c2UgYSBkaWZmZXJlbnQgYXBwcm9hY2hcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcy5BQ1RJVkVYX1ZFUlNJT05TLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgYXhWZXJzaW9uID0gcy5BQ1RJVkVYX1ZFUlNJT05TW2ldO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJlcSA9IG5ldyBBY3RpdmVYT2JqZWN0KGF4VmVyc2lvbik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHJlcSA9PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBEZWZhdWx0IHRvIHV0Zi04IGZvciBUZXh0IHJlcXVlc3RzLlxuXHRcdGlmIChpdGVtLm1pbWVUeXBlID09IG51bGwgJiYgY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzVGV4dChpdGVtLnR5cGUpKSB7XG5cdFx0XHRpdGVtLm1pbWVUeXBlID0gXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCI7XG5cdFx0fVxuXG5cdFx0Ly8gSUU5IGRvZXNuJ3Qgc3VwcG9ydCBvdmVycmlkZU1pbWVUeXBlKCksIHNvIHdlIG5lZWQgdG8gY2hlY2sgZm9yIGl0LlxuXHRcdGlmIChpdGVtLm1pbWVUeXBlICYmIHJlcS5vdmVycmlkZU1pbWVUeXBlKSB7XG5cdFx0XHRyZXEub3ZlcnJpZGVNaW1lVHlwZShpdGVtLm1pbWVUeXBlKTtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgdGhlIFhIUiBsZXZlbFxuXHRcdHRoaXMuX3hockxldmVsID0gKHR5cGVvZiByZXEucmVzcG9uc2VUeXBlID09PSBcInN0cmluZ1wiKSA/IDIgOiAxO1xuXG5cdFx0dmFyIHNyYyA9IG51bGw7XG5cdFx0aWYgKGl0ZW0ubWV0aG9kID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkdFVCkge1xuXHRcdFx0c3JjID0gY3JlYXRlanMuUmVxdWVzdFV0aWxzLmJ1aWxkUGF0aChpdGVtLnNyYywgaXRlbS52YWx1ZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcmMgPSBpdGVtLnNyYztcblx0XHR9XG5cblx0XHQvLyBPcGVuIHRoZSByZXF1ZXN0LiAgU2V0IGNyb3NzLWRvbWFpbiBmbGFncyBpZiBpdCBpcyBzdXBwb3J0ZWQgKFhIUiBsZXZlbCAxIG9ubHkpXG5cdFx0cmVxLm9wZW4oaXRlbS5tZXRob2QgfHwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuR0VULCBzcmMsIHRydWUpO1xuXG5cdFx0aWYgKGNyb3NzZG9tYWluICYmIHJlcSBpbnN0YW5jZW9mIFhNTEh0dHBSZXF1ZXN0ICYmIHRoaXMuX3hockxldmVsID09IDEpIHtcblx0XHRcdGhlYWRlcnNbXCJPcmlnaW5cIl0gPSBsb2NhdGlvbi5vcmlnaW47XG5cdFx0fVxuXG5cdFx0Ly8gVG8gc2VuZCBkYXRhIHdlIG5lZWQgdG8gc2V0IHRoZSBDb250ZW50LXR5cGUgaGVhZGVyKVxuXHRcdGlmIChpdGVtLnZhbHVlcyAmJiBpdGVtLm1ldGhvZCA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5QT1NUKSB7XG5cdFx0XHRoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcblx0XHR9XG5cblx0XHRpZiAoIWNyb3NzZG9tYWluICYmICFoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSkge1xuXHRcdFx0aGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0fVxuXG5cdFx0aWYgKGl0ZW0uaGVhZGVycykge1xuXHRcdFx0Zm9yICh2YXIgbiBpbiBpdGVtLmhlYWRlcnMpIHtcblx0XHRcdFx0aGVhZGVyc1tuXSA9IGl0ZW0uaGVhZGVyc1tuXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKG4gaW4gaGVhZGVycykge1xuXHRcdFx0cmVxLnNldFJlcXVlc3RIZWFkZXIobiwgaGVhZGVyc1tuXSlcblx0XHR9XG5cblx0XHRpZiAocmVxIGluc3RhbmNlb2YgWE1MSHR0cFJlcXVlc3QgJiYgaXRlbS53aXRoQ3JlZGVudGlhbHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmVxLndpdGhDcmVkZW50aWFscyA9IGl0ZW0ud2l0aENyZWRlbnRpYWxzO1xuXHRcdH1cblxuXHRcdHRoaXMuX3JlcXVlc3QgPSByZXE7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQSByZXF1ZXN0IGhhcyBjb21wbGV0ZWQgKG9yIGZhaWxlZCBvciBjYW5jZWxlZCksIGFuZCBuZWVkcyB0byBiZSBkaXNwb3NlZC5cblx0ICogQG1ldGhvZCBfY2xlYW5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NsZWFuID0gZnVuY3Rpb24gKCkge1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9sb2FkVGltZW91dCk7XG5cblx0XHRpZiAodGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyICE9IG51bGwpIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRzdGFydFwiLCB0aGlzLl9oYW5kbGVMb2FkU3RhcnRQcm94eSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCB0aGlzLl9oYW5kbGVQcm9ncmVzc1Byb3h5KTtcblx0XHRcdHRoaXMuX3JlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHRoaXMuX2hhbmRsZUFib3J0UHJveHkpO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5faGFuZGxlRXJyb3JQcm94eSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0aW1lb3V0XCIsIHRoaXMuX2hhbmRsZVRpbWVvdXRQcm94eSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHRoaXMuX2hhbmRsZUxvYWRQcm94eSk7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsIHRoaXMuX2hhbmRsZVJlYWR5U3RhdGVDaGFuZ2VQcm94eSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25sb2Fkc3RhcnQgPSBudWxsO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbnByb2dyZXNzID0gbnVsbDtcblx0XHRcdHRoaXMuX3JlcXVlc3Qub25hYm9ydCA9IG51bGw7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0Lm9uZXJyb3IgPSBudWxsO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbnRpbWVvdXQgPSBudWxsO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbmxvYWQgPSBudWxsO1xuXHRcdFx0dGhpcy5fcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXHRcdH1cblx0fTtcblxuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBcIltQcmVsb2FkSlMgWEhSUmVxdWVzdF1cIjtcblx0fTtcblxuXHRjcmVhdGVqcy5YSFJSZXF1ZXN0ID0gY3JlYXRlanMucHJvbW90ZShYSFJSZXF1ZXN0LCBcIkFic3RyYWN0UmVxdWVzdFwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIExvYWRRdWV1ZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbi8qXG4gVE9ETzogV0lORE9XUyBJU1NVRVNcbiAqIE5vIGVycm9yIGZvciBIVE1MIGF1ZGlvIGluIElFIDY3OFxuICogU1ZHIG5vIGZhaWx1cmUgZXJyb3IgaW4gSUUgNjcgKG1heWJlIDgpIFRBR1MgQU5EIFhIUlxuICogTm8gc2NyaXB0IGNvbXBsZXRlIGhhbmRsZXIgaW4gSUUgNjcgVEFHUyAoWEhSIGlzIGZpbmUpXG4gKiBObyBYTUwvSlNPTiBpbiBJRTYgVEFHU1xuICogTmVlZCB0byBoaWRlIGxvYWRpbmcgU1ZHIGluIE9wZXJhIFRBR1NcbiAqIE5vIENTUyBvbmxvYWQvcmVhZHlzdGF0ZWNoYW5nZSBpbiBTYWZhcmkgb3IgQW5kcm9pZCBUQUdTIChyZXF1aXJlcyBydWxlIGNoZWNraW5nKVxuICogU1ZHIG5vIGxvYWQgb3IgZmFpbHVyZSBpbiBPcGVyYSBYSFJcbiAqIFJlcG9ydGVkIGlzc3VlcyB3aXRoIElFNy84XG4gKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBUaGUgTG9hZFF1ZXVlIGNsYXNzIGlzIHRoZSBtYWluIEFQSSBmb3IgcHJlbG9hZGluZyBjb250ZW50LiBMb2FkUXVldWUgaXMgYSBsb2FkIG1hbmFnZXIsIHdoaWNoIGNhbiBwcmVsb2FkIGVpdGhlclxuXHQgKiBhIHNpbmdsZSBmaWxlLCBvciBxdWV1ZSBvZiBmaWxlcy5cblx0ICpcblx0ICogPGI+Q3JlYXRpbmcgYSBRdWV1ZTwvYj48YnIgLz5cblx0ICogVG8gdXNlIExvYWRRdWV1ZSwgY3JlYXRlIGEgTG9hZFF1ZXVlIGluc3RhbmNlLiBJZiB5b3Ugd2FudCB0byBmb3JjZSB0YWcgbG9hZGluZyB3aGVyZSBwb3NzaWJsZSwgc2V0IHRoZSBwcmVmZXJYSFJcblx0ICogYXJndW1lbnQgdG8gZmFsc2UuXG5cdCAqXG5cdCAqICAgICAgdmFyIHF1ZXVlID0gbmV3IGNyZWF0ZWpzLkxvYWRRdWV1ZSh0cnVlKTtcblx0ICpcblx0ICogPGI+TGlzdGVuaW5nIGZvciBFdmVudHM8L2I+PGJyIC8+XG5cdCAqIEFkZCBhbnkgbGlzdGVuZXJzIHlvdSB3YW50IHRvIHRoZSBxdWV1ZS4gU2luY2UgUHJlbG9hZEpTIDAuMy4wLCB0aGUge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGxldHMgeW91IGFkZCBhcyBtYW55IGxpc3RlbmVycyBhcyB5b3Ugd2FudCBmb3IgZXZlbnRzLiBZb3UgY2FuIHN1YnNjcmliZSB0byB0aGUgZm9sbG93aW5nIGV2ZW50czo8dWw+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvY29tcGxldGU6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX06IGZpcmVkIHdoZW4gYSBxdWV1ZSBjb21wbGV0ZXMgbG9hZGluZyBhbGxcblx0ICogICAgIGZpbGVzPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9lcnJvcjpldmVudFwifX17ey9jcm9zc0xpbmt9fTogZmlyZWQgd2hlbiB0aGUgcXVldWUgZW5jb3VudGVycyBhbiBlcnJvciB3aXRoXG5cdCAqICAgICBhbnkgZmlsZS48L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL3Byb2dyZXNzOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319OiBQcm9ncmVzcyBmb3IgdGhlIGVudGlyZSBxdWV1ZSBoYXNcblx0ICogICAgIGNoYW5nZWQuPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZWxvYWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX06IEEgc2luZ2xlIGZpbGUgaGFzIGNvbXBsZXRlZCBsb2FkaW5nLjwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVwcm9ncmVzczpldmVudFwifX17ey9jcm9zc0xpbmt9fTogUHJvZ3Jlc3MgZm9yIGEgc2luZ2xlIGZpbGUgaGFzIGNoYW5nZXMuIE5vdGVcblx0ICogICAgIHRoYXQgb25seSBmaWxlcyBsb2FkZWQgd2l0aCBYSFIgKG9yIHBvc3NpYmx5IGJ5IHBsdWdpbnMpIHdpbGwgZmlyZSBwcm9ncmVzcyBldmVudHMgb3RoZXIgdGhhbiAwIG9yIDEwMCUuPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogICAgICBxdWV1ZS5vbihcImZpbGVsb2FkXCIsIGhhbmRsZUZpbGVMb2FkLCB0aGlzKTtcblx0ICogICAgICBxdWV1ZS5vbihcImNvbXBsZXRlXCIsIGhhbmRsZUNvbXBsZXRlLCB0aGlzKTtcblx0ICpcblx0ICogPGI+QWRkaW5nIGZpbGVzIGFuZCBtYW5pZmVzdHM8L2I+PGJyIC8+XG5cdCAqIEFkZCBmaWxlcyB5b3Ugd2FudCB0byBsb2FkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fSBvciBhZGQgbXVsdGlwbGUgZmlsZXMgYXQgYVxuXHQgKiB0aW1lIHVzaW5nIGEgbGlzdCBvciBhIG1hbmlmZXN0IGRlZmluaXRpb24gdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fS4gRmlsZXMgYXJlXG5cdCAqIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGFjdGl2ZSBxdWV1ZSwgc28geW91IGNhbiB1c2UgdGhlc2UgbWV0aG9kcyBhcyBtYW55IHRpbWVzIGFzIHlvdSBsaWtlLCB3aGVuZXZlciB5b3Vcblx0ICogbGlrZS5cblx0ICpcblx0ICogICAgICBxdWV1ZS5sb2FkRmlsZShcImZpbGVQYXRoL2ZpbGUuanBnXCIpO1xuXHQgKiAgICAgIHF1ZXVlLmxvYWRGaWxlKHtpZDpcImltYWdlXCIsIHNyYzpcImZpbGVQYXRoL2ZpbGUuanBnXCJ9KTtcblx0ICogICAgICBxdWV1ZS5sb2FkTWFuaWZlc3QoW1wiZmlsZVBhdGgvZmlsZS5qcGdcIiwge2lkOlwiaW1hZ2VcIiwgc3JjOlwiZmlsZVBhdGgvZmlsZS5qcGdcIn1dKTtcblx0ICpcblx0ICogICAgICAvLyBVc2UgYW4gZXh0ZXJuYWwgbWFuaWZlc3Rcblx0ICogICAgICBxdWV1ZS5sb2FkTWFuaWZlc3QoXCJwYXRoL3RvL21hbmlmZXN0Lmpzb25cIik7XG5cdCAqICAgICAgcXVldWUubG9hZE1hbmlmZXN0KHtzcmM6XCJtYW5pZmVzdC5qc29uXCIsIHR5cGU6XCJtYW5pZmVzdFwifSk7XG5cdCAqXG5cdCAqIElmIHlvdSBwYXNzIGBmYWxzZWAgYXMgdGhlIGBsb2FkTm93YCBwYXJhbWV0ZXIsIHRoZSBxdWV1ZSB3aWxsIG5vdCBraWNrIG9mIHRoZSBsb2FkIG9mIHRoZSBmaWxlcywgYnV0IGl0IHdpbGwgbm90XG5cdCAqIHN0b3AgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiBzdGFydGVkLiBDYWxsIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9sb2FkXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCB0byBiZWdpblxuXHQgKiBhIHBhdXNlZCBxdWV1ZS4gTm90ZSB0aGF0IGEgcGF1c2VkIHF1ZXVlIHdpbGwgYXV0b21hdGljYWxseSByZXN1bWUgd2hlbiBuZXcgZmlsZXMgYXJlIGFkZGVkIHRvIGl0IHdpdGggYVxuXHQgKiBgbG9hZE5vd2AgYXJndW1lbnQgb2YgYHRydWVgLlxuXHQgKlxuXHQgKiAgICAgIHF1ZXVlLmxvYWQoKTtcblx0ICpcblx0ICogPGI+RmlsZSBUeXBlczwvYj48YnIgLz5cblx0ICogVGhlIGZpbGUgdHlwZSBvZiBhIG1hbmlmZXN0IGl0ZW0gaXMgYXV0by1kZXRlcm1pbmVkIGJ5IHRoZSBmaWxlIGV4dGVuc2lvbi4gVGhlIHBhdHRlcm4gbWF0Y2hpbmcgaW4gUHJlbG9hZEpTXG5cdCAqIHNob3VsZCBoYW5kbGUgdGhlIG1ham9yaXR5IG9mIHN0YW5kYXJkIGZpbGUgYW5kIHVybCBmb3JtYXRzLCBhbmQgd29ya3Mgd2l0aCBjb21tb24gZmlsZSBleHRlbnNpb25zLiBJZiB5b3UgaGF2ZVxuXHQgKiBlaXRoZXIgYSBub24tc3RhbmRhcmQgZmlsZSBleHRlbnNpb24sIG9yIGFyZSBzZXJ2aW5nIHRoZSBmaWxlIHVzaW5nIGEgcHJveHkgc2NyaXB0LCB0aGVuIHlvdSBjYW4gcGFzcyBpbiBhXG5cdCAqIDxjb2RlPnR5cGU8L2NvZGU+IHByb3BlcnR5IHdpdGggYW55IG1hbmlmZXN0IGl0ZW0uXG5cdCAqXG5cdCAqICAgICAgcXVldWUubG9hZEZpbGUoe3NyYzpcInBhdGgvdG8vbXlGaWxlLm1wM3hcIiwgdHlwZTpjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TT1VORH0pO1xuXHQgKlxuXHQgKiAgICAgIC8vIE5vdGUgdGhhdCBQcmVsb2FkSlMgd2lsbCBub3QgcmVhZCBhIGZpbGUgZXh0ZW5zaW9uIGZyb20gdGhlIHF1ZXJ5IHN0cmluZ1xuXHQgKiAgICAgIHF1ZXVlLmxvYWRGaWxlKHtzcmM6XCJodHRwOi8vc2VydmVyLmNvbS9wcm94eT9maWxlPWltYWdlLmpwZ1wiLCB0eXBlOmNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLklNQUdFfSk7XG5cdCAqXG5cdCAqIFN1cHBvcnRlZCB0eXBlcyBhcmUgZGVmaW5lZCBvbiB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gY2xhc3MsIGFuZCBpbmNsdWRlOlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvQklOQVJZOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBSYXcgYmluYXJ5IGRhdGEgdmlhIFhIUjwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvQ1NTOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBDU1MgZmlsZXM8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0lNQUdFOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBDb21tb24gaW1hZ2UgZm9ybWF0czwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSkFWQVNDUklQVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogSmF2YVNjcmlwdCBmaWxlczwvbGk+XG5cdCAqICAgICA8bGk+e3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSlNPTjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogSlNPTiBkYXRhPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KU09OUDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogSlNPTiBmaWxlcyBjcm9zcy1kb21haW48L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL01BTklGRVNUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBBIGxpc3Qgb2YgZmlsZXMgdG8gbG9hZCBpbiBKU09OIGZvcm1hdCwgc2VlXG5cdCAqICAgICB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX08L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1NPVU5EOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBBdWRpbyBmaWxlIGZvcm1hdHM8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1NQUklURVNIRUVUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBKU09OIFNwcml0ZVNoZWV0IGRlZmluaXRlaW9ucy4gVGhpc1xuXHQgKiAgICAgd2lsbCBhbHNvIGxvYWQgc3ViLWltYWdlcywgYW5kIHByb3ZpZGUgYSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZS48L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1NWRzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogU1ZHIGZpbGVzPC9saT5cblx0ICogICAgIDxsaT57eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9URVhUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319OiBUZXh0IGZpbGVzIC0gWEhSIG9ubHk8L2xpPlxuXHQgKiAgICAgPGxpPnt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1hNTDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fTogWE1MIGRhdGE8L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiA8ZW0+Tm90ZTogTG9hZGVyIHR5cGVzIHVzZWQgdG8gYmUgZGVmaW5lZCBvbiBMb2FkUXVldWUsIGJ1dCBoYXZlIGJlZW4gbW92ZWQgdG8gQWJzdHJhY3RMb2FkZXIgZm9yIGJldHRlclxuXHQgKiBwb3J0YWJpbGl0eSBvZiBsb2FkZXIgY2xhc3Nlcywgd2hpY2ggY2FuIGJlIHVzZWQgaW5kaXZpZHVhbGx5IG5vdy4gVGhlIHByb3BlcnRpZXMgb24gTG9hZFF1ZXVlIHN0aWxsIGV4aXN0LCBidXRcblx0ICogYXJlIGRlcHJlY2F0ZWQuPC9lbT5cblx0ICpcblx0ICogPGI+SGFuZGxpbmcgUmVzdWx0czwvYj48YnIgLz5cblx0ICogV2hlbiBhIGZpbGUgaXMgZmluaXNoZWQgZG93bmxvYWRpbmcsIGEge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGlzXG5cdCAqIGRpc3BhdGNoZWQuIEluIGFuIGV4YW1wbGUgYWJvdmUsIHRoZXJlIGlzIGFuIGV2ZW50IGxpc3RlbmVyIHNuaXBwZXQgZm9yIGZpbGVsb2FkLiBMb2FkZWQgZmlsZXMgYXJlIHVzdWFsbHkgYVxuXHQgKiBmb3JtYXR0ZWQgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgaW1tZWRpYXRlbHksIGluY2x1ZGluZzpcblx0ICogPHVsPlxuXHQgKiAgICAgPGxpPkJpbmFyeTogVGhlIGJpbmFyeSBsb2FkZWQgcmVzdWx0PC9saT5cblx0ICogICAgIDxsaT5DU1M6IEEgJmx0O2xpbmsgLyZndDsgdGFnPC9saT5cblx0ICogICAgIDxsaT5JbWFnZTogQW4gJmx0O2ltZyAvJmd0OyB0YWc8L2xpPlxuXHQgKiAgICAgPGxpPkphdmFTY3JpcHQ6IEEgJmx0O3NjcmlwdCAvJmd0OyB0YWc8L2xpPlxuXHQgKiAgICAgPGxpPkpTT04vSlNPTlA6IEEgZm9ybWF0dGVkIEphdmFTY3JpcHQgT2JqZWN0PC9saT5cblx0ICogICAgIDxsaT5NYW5pZmVzdDogQSBKYXZhU2NyaXB0IG9iamVjdC5cblx0ICogICAgIDxsaT5Tb3VuZDogQW4gJmx0O2F1ZGlvIC8mZ3Q7IHRhZzwvYT5cblx0ICogICAgIDxsaT5TcHJpdGVTaGVldDogQSB7eyNjcm9zc0xpbmsgXCJTcHJpdGVTaGVldFwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZSwgY29udGFpbmluZyBsb2FkZWQgaW1hZ2VzLlxuXHQgKiAgICAgPGxpPlNWRzogQW4gJmx0O29iamVjdCAvJmd0OyB0YWc8L2xpPlxuXHQgKiAgICAgPGxpPlRleHQ6IFJhdyB0ZXh0PC9saT5cblx0ICogICAgIDxsaT5YTUw6IEFuIFhNTCBET00gbm9kZTwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqXG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlRmlsZUxvYWQoZXZlbnQpIHtcblx0ICogICAgICAgICAgdmFyIGl0ZW0gPSBldmVudC5pdGVtOyAvLyBBIHJlZmVyZW5jZSB0byB0aGUgaXRlbSB0aGF0IHdhcyBwYXNzZWQgaW4gdG8gdGhlIExvYWRRdWV1ZVxuXHQgKiAgICAgICAgICB2YXIgdHlwZSA9IGl0ZW0udHlwZTtcblx0ICpcblx0ICogICAgICAgICAgLy8gQWRkIGFueSBpbWFnZXMgdG8gdGhlIHBhZ2UgYm9keS5cblx0ICogICAgICAgICAgaWYgKHR5cGUgPT0gY3JlYXRlanMuTG9hZFF1ZXVlLklNQUdFKSB7XG5cdCAqICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGV2ZW50LnJlc3VsdCk7XG5cdCAqICAgICAgICAgIH1cblx0ICogICAgICB9XG5cdCAqXG5cdCAqIEF0IGFueSB0aW1lIGFmdGVyIHRoZSBmaWxlIGhhcyBiZWVuIGxvYWRlZCAodXN1YWxseSBhZnRlciB0aGUgcXVldWUgaGFzIGNvbXBsZXRlZCksIGFueSByZXN1bHQgY2FuIGJlIGxvb2tlZCB1cFxuXHQgKiB2aWEgaXRzIFwiaWRcIiB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZ2V0UmVzdWx0XCJ9fXt7L2Nyb3NzTGlua319LiBJZiBubyBpZCB3YXMgcHJvdmlkZWQsIHRoZW4gdGhlXG5cdCAqIFwic3JjXCIgb3IgZmlsZSBwYXRoIGNhbiBiZSB1c2VkIGluc3RlYWQsIGluY2x1ZGluZyB0aGUgYHBhdGhgIGRlZmluZWQgYnkgYSBtYW5pZmVzdCwgYnV0IDxzdHJvbmc+bm90IGluY2x1ZGluZzwvc3Ryb25nPlxuXHQgKiBhIGJhc2UgcGF0aCBkZWZpbmVkIG9uIHRoZSBMb2FkUXVldWUuIEl0IGlzIHJlY29tbWVuZGVkIHRvIGFsd2F5cyBwYXNzIGFuIGlkIGlmIHlvdSB3YW50IHRvIGxvb2sgdXAgY29udGVudC5cblx0ICpcblx0ICogICAgICB2YXIgaW1hZ2UgPSBxdWV1ZS5nZXRSZXN1bHQoXCJpbWFnZVwiKTtcblx0ICogICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGltYWdlKTtcblx0ICpcblx0ICogUmF3IGxvYWRlZCBjb250ZW50IGNhbiBiZSBhY2Nlc3NlZCB1c2luZyB0aGUgPGNvZGU+cmF3UmVzdWx0PC9jb2RlPiBwcm9wZXJ0eSBvZiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50LCBvciBjYW4gYmUgbG9va2VkIHVwIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9nZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX0sIHBhc3NpbmcgYHRydWVgIGFzIHRoZSAybmRcblx0ICogYXJndW1lbnQuIFRoaXMgaXMgb25seSBhcHBsaWNhYmxlIGZvciBjb250ZW50IHRoYXQgaGFzIGJlZW4gcGFyc2VkIGZvciB0aGUgYnJvd3Nlciwgc3BlY2lmaWNhbGx5OiBKYXZhU2NyaXB0LFxuXHQgKiBDU1MsIFhNTCwgU1ZHLCBhbmQgSlNPTiBvYmplY3RzLCBvciBhbnl0aGluZyBsb2FkZWQgd2l0aCBYSFIuXG5cdCAqXG5cdCAqICAgICAgdmFyIGltYWdlID0gcXVldWUuZ2V0UmVzdWx0KFwiaW1hZ2VcIiwgdHJ1ZSk7IC8vIGxvYWQgdGhlIGJpbmFyeSBpbWFnZSBkYXRhIGxvYWRlZCB3aXRoIFhIUi5cblx0ICpcblx0ICogPGI+UGx1Z2luczwvYj48YnIgLz5cblx0ICogTG9hZFF1ZXVlIGhhcyBhIHNpbXBsZSBwbHVnaW4gYXJjaGl0ZWN0dXJlIHRvIGhlbHAgcHJvY2VzcyBhbmQgcHJlbG9hZCBjb250ZW50LiBGb3IgZXhhbXBsZSwgdG8gcHJlbG9hZCBhdWRpbyxcblx0ICogbWFrZSBzdXJlIHRvIGluc3RhbGwgdGhlIDxhIGhyZWY9XCJodHRwOi8vc291bmRqcy5jb21cIj5Tb3VuZEpTPC9hPiBTb3VuZCBjbGFzcywgd2hpY2ggd2lsbCBoZWxwIGxvYWQgSFRNTCBhdWRpbyxcblx0ICogRmxhc2ggYXVkaW8sIGFuZCBXZWJBdWRpbyBmaWxlcy4gVGhpcyBzaG91bGQgYmUgaW5zdGFsbGVkIDxzdHJvbmc+YmVmb3JlPC9zdHJvbmc+IGxvYWRpbmcgYW55IGF1ZGlvIGZpbGVzLlxuXHQgKlxuXHQgKiAgICAgIHF1ZXVlLmluc3RhbGxQbHVnaW4oY3JlYXRlanMuU291bmQpO1xuXHQgKlxuXHQgKiA8aDQ+S25vd24gQnJvd3NlciBJc3N1ZXM8L2g0PlxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+QnJvd3NlcnMgd2l0aG91dCBhdWRpbyBzdXBwb3J0IGNhbiBub3QgbG9hZCBhdWRpbyBmaWxlcy48L2xpPlxuXHQgKiAgICAgPGxpPlNhZmFyaSBvbiBNYWMgT1MgWCBjYW4gb25seSBwbGF5IEhUTUwgYXVkaW8gaWYgUXVpY2tUaW1lIGlzIGluc3RhbGxlZDwvbGk+XG5cdCAqICAgICA8bGk+SFRNTCBBdWRpbyB0YWdzIHdpbGwgb25seSBkb3dubG9hZCB1bnRpbCB0aGVpciA8Y29kZT5jYW5QbGF5VGhyb3VnaDwvY29kZT4gZXZlbnQgaXMgZmlyZWQuIEJyb3dzZXJzIG90aGVyXG5cdCAqICAgICB0aGFuIENocm9tZSB3aWxsIGNvbnRpbnVlIHRvIGRvd25sb2FkIGluIHRoZSBiYWNrZ3JvdW5kLjwvbGk+XG5cdCAqICAgICA8bGk+V2hlbiBsb2FkaW5nIHNjcmlwdHMgdXNpbmcgdGFncywgdGhleSBhcmUgYXV0b21hdGljYWxseSBhZGRlZCB0byB0aGUgZG9jdW1lbnQuPC9saT5cblx0ICogICAgIDxsaT5TY3JpcHRzIGxvYWRlZCB2aWEgWEhSIG1heSBub3QgYmUgcHJvcGVybHkgaW5zcGVjdGFibGUgd2l0aCBicm93c2VyIHRvb2xzLjwvbGk+XG5cdCAqICAgICA8bGk+SUU2IGFuZCBJRTcgKGFuZCBzb21lIG90aGVyIGJyb3dzZXJzKSBtYXkgbm90IGJlIGFibGUgdG8gbG9hZCBYTUwsIFRleHQsIG9yIEpTT04sIHNpbmNlIHRoZXkgcmVxdWlyZVxuXHQgKiAgICAgWEhSIHRvIHdvcmsuPC9saT5cblx0ICogICAgIDxsaT5Db250ZW50IGxvYWRlZCB2aWEgdGFncyB3aWxsIG5vdCBzaG93IHByb2dyZXNzLCBhbmQgd2lsbCBjb250aW51ZSB0byBkb3dubG9hZCBpbiB0aGUgYmFja2dyb3VuZCB3aGVuXG5cdCAqICAgICBjYW5jZWxlZCwgYWx0aG91Z2ggbm8gZXZlbnRzIHdpbGwgYmUgZGlzcGF0Y2hlZC48L2xpPlxuXHQgKiA8L3VsPlxuXHQgKlxuXHQgKiBAY2xhc3MgTG9hZFF1ZXVlXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ByZWZlclhIUj10cnVlXSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHByZWxvYWQgaW5zdGFuY2Ugd2lsbCBmYXZvciBsb2FkaW5nIHdpdGggWEhSIChYTUwgSFRUUFxuXHQgKiBSZXF1ZXN0cyksIG9yIEhUTUwgdGFncy4gV2hlbiB0aGlzIGlzIGBmYWxzZWAsIHRoZSBxdWV1ZSB3aWxsIHVzZSB0YWcgbG9hZGluZyB3aGVuIHBvc3NpYmxlLCBhbmQgZmFsbCBiYWNrIG9uIFhIUlxuXHQgKiB3aGVuIG5lY2Vzc2FyeS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtiYXNlUGF0aD1cIlwiXSBBIHBhdGggdGhhdCB3aWxsIGJlIHByZXBlbmRlZCBvbiB0byB0aGUgc291cmNlIHBhcmFtZXRlciBvZiBhbGwgaXRlbXMgaW4gdGhlIHF1ZXVlXG5cdCAqIGJlZm9yZSB0aGV5IGFyZSBsb2FkZWQuICBTb3VyY2VzIGJlZ2lubmluZyB3aXRoIGEgcHJvdG9jb2wgc3VjaCBhcyBgaHR0cDovL2Agb3IgYSByZWxhdGl2ZSBwYXRoIHN1Y2ggYXMgYC4uL2Bcblx0ICogd2lsbCBub3QgcmVjZWl2ZSBhIGJhc2UgcGF0aC5cblx0ICogQHBhcmFtIHtTdHJpbmd8Qm9vbGVhbn0gW2Nyb3NzT3JpZ2luPVwiXCJdIEFuIG9wdGlvbmFsIGZsYWcgdG8gc3VwcG9ydCBpbWFnZXMgbG9hZGVkIGZyb20gYSBDT1JTLWVuYWJsZWQgc2VydmVyLiBUb1xuXHQgKiB1c2UgaXQsIHNldCB0aGlzIHZhbHVlIHRvIGB0cnVlYCwgd2hpY2ggd2lsbCBkZWZhdWx0IHRoZSBjcm9zc09yaWdpbiBwcm9wZXJ0eSBvbiBpbWFnZXMgdG8gXCJBbm9ueW1vdXNcIi4gQW55XG5cdCAqIHN0cmluZyB2YWx1ZSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoLCBidXQgb25seSBcIlwiIGFuZCBcIkFub255bW91c1wiIGFyZSByZWNvbW1lbmRlZC4gPHN0cm9uZz5Ob3RlOiBUaGUgY3Jvc3NPcmlnaW5cblx0ICogcGFyYW1ldGVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBMb2FkSXRlbS5jcm9zc09yaWdpbiBpbnN0ZWFkPC9zdHJvbmc+XG5cdCAqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKi9cblx0ZnVuY3Rpb24gTG9hZFF1ZXVlIChwcmVmZXJYSFIsIGJhc2VQYXRoLCBjcm9zc09yaWdpbikge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IoKTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGFycmF5IG9mIHRoZSBwbHVnaW5zIHJlZ2lzdGVyZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2luc3RhbGxQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IF9wbHVnaW5zXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHNpbmNlIDAuNi4xXG5cdFx0ICovXG5cdFx0dGhpcy5fcGx1Z2lucyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IGhhc2ggb2YgY2FsbGJhY2tzIHRoYXQgYXJlIGZpcmVkIGZvciBlYWNoIGZpbGUgdHlwZSBiZWZvcmUgdGhlIGZpbGUgaXMgbG9hZGVkLCBnaXZpbmcgcGx1Z2lucyB0aGVcblx0XHQgKiBhYmlsaXR5IHRvIG92ZXJyaWRlIHByb3BlcnRpZXMgb2YgdGhlIGxvYWQuIFBsZWFzZSBzZWUgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9pbnN0YWxsUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogbWV0aG9kIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBfdHlwZUNhbGxiYWNrc1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl90eXBlQ2FsbGJhY2tzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiBjYWxsYmFja3MgdGhhdCBhcmUgZmlyZWQgZm9yIGVhY2ggZmlsZSBleHRlbnNpb24gYmVmb3JlIHRoZSBmaWxlIGlzIGxvYWRlZCwgZ2l2aW5nIHBsdWdpbnMgdGhlXG5cdFx0ICogYWJpbGl0eSB0byBvdmVycmlkZSBwcm9wZXJ0aWVzIG9mIHRoZSBsb2FkLiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvaW5zdGFsbFBsdWdpblwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIG1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBAcHJvcGVydHkgX2V4dGVuc2lvbkNhbGxiYWNrc1xuXHRcdCAqIEB0eXBlIHtudWxsfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fZXh0ZW5zaW9uQ2FsbGJhY2tzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbmV4dCBwcmVsb2FkIHF1ZXVlIHRvIHByb2Nlc3Mgd2hlbiB0aGlzIG9uZSBpcyBjb21wbGV0ZS4gSWYgYW4gZXJyb3IgaXMgdGhyb3duIGluIHRoZSBjdXJyZW50IHF1ZXVlLCBhbmRcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc3RvcE9uRXJyb3I6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaXMgYHRydWVgLCB0aGUgbmV4dCBxdWV1ZSB3aWxsIG5vdCBiZSBwcm9jZXNzZWQuXG5cdFx0ICogQHByb3BlcnR5IG5leHRcblx0XHQgKiBAdHlwZSB7TG9hZFF1ZXVlfVxuXHRcdCAqIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHR0aGlzLm5leHQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogRW5zdXJlIGxvYWRlZCBzY3JpcHRzIFwiY29tcGxldGVcIiBpbiB0aGUgb3JkZXIgdGhleSBhcmUgc3BlY2lmaWVkLiBMb2FkZWQgc2NyaXB0cyBhcmUgYWRkZWQgdG8gdGhlIGRvY3VtZW50IGhlYWRcblx0XHQgKiBvbmNlIHRoZXkgYXJlIGxvYWRlZC4gU2NyaXB0cyBsb2FkZWQgdmlhIHRhZ3Mgd2lsbCBsb2FkIG9uZS1hdC1hLXRpbWUgd2hlbiB0aGlzIHByb3BlcnR5IGlzIGB0cnVlYCwgd2hlcmVhc1xuXHRcdCAqIHNjcmlwdHMgbG9hZGVkIHVzaW5nIFhIUiBjYW4gbG9hZCBpbiBhbnkgb3JkZXIsIGJ1dCB3aWxsIFwiZmluaXNoXCIgYW5kIGJlIGFkZGVkIHRvIHRoZSBkb2N1bWVudCBpbiB0aGUgb3JkZXJcblx0XHQgKiBzcGVjaWZpZWQuXG5cdFx0ICpcblx0XHQgKiBBbnkgaXRlbXMgY2FuIGJlIHNldCB0byBsb2FkIGluIG9yZGVyIGJ5IHNldHRpbmcgdGhlIHt7I2Nyb3NzTGluayBcIm1haW50YWluT3JkZXI6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBwcm9wZXJ0eSBvbiB0aGUgbG9hZCBpdGVtLCBvciBieSBlbnN1cmluZyB0aGF0IG9ubHkgb25lIGNvbm5lY3Rpb24gY2FuIGJlIG9wZW4gYXQgYSB0aW1lIHVzaW5nXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldE1heENvbm5lY3Rpb25zXCJ9fXt7L2Nyb3NzTGlua319LiBOb3RlIHRoYXQgd2hlbiB0aGUgYG1haW50YWluU2NyaXB0T3JkZXJgIHByb3BlcnR5XG5cdFx0ICogaXMgc2V0IHRvIGB0cnVlYCwgc2NyaXB0cyBpdGVtcyBhcmUgYXV0b21hdGljYWxseSBzZXQgdG8gYG1haW50YWluT3JkZXI9dHJ1ZWAsIGFuZCBjaGFuZ2luZyB0aGVcblx0XHQgKiBgbWFpbnRhaW5TY3JpcHRPcmRlcmAgdG8gYGZhbHNlYCBkdXJpbmcgYSBsb2FkIHdpbGwgbm90IGNoYW5nZSBpdGVtcyBhbHJlYWR5IGluIGEgcXVldWUuXG5cdFx0ICpcblx0XHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdFx0ICpcblx0XHQgKiAgICAgIHZhciBxdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUoKTtcblx0XHQgKiAgICAgIHF1ZXVlLnNldE1heENvbm5lY3Rpb25zKDMpOyAvLyBTZXQgYSBoaWdoZXIgbnVtYmVyIHRvIGxvYWQgbXVsdGlwbGUgaXRlbXMgYXQgb25jZVxuXHRcdCAqICAgICAgcXVldWUubWFpbnRhaW5TY3JpcHRPcmRlciA9IHRydWU7IC8vIEVuc3VyZSBzY3JpcHRzIGFyZSBsb2FkZWQgaW4gb3JkZXJcblx0XHQgKiAgICAgIHF1ZXVlLmxvYWRNYW5pZmVzdChbXG5cdFx0ICogICAgICAgICAgXCJzY3JpcHQxLmpzXCIsXG5cdFx0ICogICAgICAgICAgXCJzY3JpcHQyLmpzXCIsXG5cdFx0ICogICAgICAgICAgXCJpbWFnZS5wbmdcIiwgLy8gTG9hZCBhbnkgdGltZVxuXHRcdCAqICAgICAgICAgIHtzcmM6IFwiaW1hZ2UyLnBuZ1wiLCBtYWludGFpbk9yZGVyOiB0cnVlfSAvLyBXaWxsIHdhaXQgZm9yIHNjcmlwdDIuanNcblx0XHQgKiAgICAgICAgICBcImltYWdlMy5wbmdcIixcblx0XHQgKiAgICAgICAgICBcInNjcmlwdDMuanNcIiAvLyBXaWxsIHdhaXQgZm9yIGltYWdlMi5wbmcgYmVmb3JlIGxvYWRpbmcgKG9yIGNvbXBsZXRpbmcgd2hlbiBsb2FkaW5nIHdpdGggWEhSKVxuXHRcdCAqICAgICAgXSk7XG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkgbWFpbnRhaW5TY3JpcHRPcmRlclxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHQgKi9cblx0XHR0aGlzLm1haW50YWluU2NyaXB0T3JkZXIgPSB0cnVlO1xuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgTG9hZFF1ZXVlIHdpbGwgc3RvcCBwcm9jZXNzaW5nIHRoZSBjdXJyZW50IHF1ZXVlIHdoZW4gYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQuXG5cdFx0ICogQHByb3BlcnR5IHN0b3BPbkVycm9yXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLnN0b3BPbkVycm9yID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIG1heGltdW0gb3BlbiBjb25uZWN0aW9ucyB0aGF0IGEgbG9hZFF1ZXVlIHRyaWVzIHRvIG1haW50YWluLiBQbGVhc2Ugc2VlXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldE1heENvbm5lY3Rpb25zXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBfbWF4Q29ubmVjdGlvbnNcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDFcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX21heENvbm5lY3Rpb25zID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIGludGVybmFsIGxpc3Qgb2YgYWxsIHRoZSBkZWZhdWx0IExvYWRlcnMgdGhhdCBhcmUgaW5jbHVkZWQgd2l0aCBQcmVsb2FkSlMuIEJlZm9yZSBhbiBpdGVtIGlzIGxvYWRlZCwgdGhlXG5cdFx0ICogYXZhaWxhYmxlIGxvYWRlciBsaXN0IGlzIGl0ZXJhdGVkLCBpbiB0aGUgb3JkZXIgdGhleSBhcmUgaW5jbHVkZWQsIGFuZCBhcyBzb29uIGFzIGEgbG9hZGVyIGluZGljYXRlcyBpdCBjYW5cblx0XHQgKiBoYW5kbGUgdGhlIGNvbnRlbnQsIGl0IHdpbGwgYmUgc2VsZWN0ZWQuIFRoZSBkZWZhdWx0IGxvYWRlciwgKHt7I2Nyb3NzTGluayBcIlRleHRMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gaXNcblx0XHQgKiBsYXN0IGluIHRoZSBsaXN0LCBzbyBpdCB3aWxsIGJlIHVzZWQgaWYgbm8gb3RoZXIgbWF0Y2ggaXMgZm91bmQuIFR5cGljYWxseSwgbG9hZGVycyB3aWxsIG1hdGNoIGJhc2VkIG9uIHRoZVxuXHRcdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL3R5cGVcIn19e3svY3Jvc3NMaW5rfX0sIHdoaWNoIGlzIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lZCB1c2luZyB0aGUgZmlsZSBleHRlbnNpb24gb2Zcblx0XHQgKiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vc3JjOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqXG5cdFx0ICogTG9hZGVycyBjYW4gYmUgcmVtb3ZlZCBmcm9tIFByZWxvYWRKUyBieSBzaW1wbHkgbm90IGluY2x1ZGluZyB0aGVtLlxuXHRcdCAqXG5cdFx0ICogQ3VzdG9tIGxvYWRlcnMgaW5zdGFsbGVkIHVzaW5nIHt7I2Nyb3NzTGluayBcInJlZ2lzdGVyTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IHdpbGwgYmUgcHJlcGVuZGVkIHRvIHRoaXMgbGlzdFxuXHRcdCAqIHNvIHRoYXQgdGhleSBhcmUgY2hlY2tlZCBmaXJzdC5cblx0XHQgKiBAcHJvcGVydHkgX2F2YWlsYWJsZUxvYWRlcnNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAc2luY2UgMC42LjBcblx0XHQgKi9cblx0XHR0aGlzLl9hdmFpbGFibGVMb2FkZXJzID0gW1xuXHRcdFx0Y3JlYXRlanMuSW1hZ2VMb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5KYXZhU2NyaXB0TG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuQ1NTTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuSlNPTkxvYWRlcixcblx0XHRcdGNyZWF0ZWpzLkpTT05QTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuU291bmRMb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5NYW5pZmVzdExvYWRlcixcblx0XHRcdGNyZWF0ZWpzLlNwcml0ZVNoZWV0TG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuWE1MTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuU1ZHTG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuQmluYXJ5TG9hZGVyLFxuXHRcdFx0Y3JlYXRlanMuVmlkZW9Mb2FkZXIsXG5cdFx0XHRjcmVhdGVqcy5UZXh0TG9hZGVyLFxuXHRcdF07XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIGJ1aWx0IGluIGxvYWRlcnMsIHNvIHRoZXkgY2FuJ3QgYmUgcmVtb3ZlZCBieSB7eyNjcm9zc0xpbmsgXCJ1bnJlZ2lzdGVyTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua30uXG5cdFx0XHRcdCAqIEBwcm9wZXJ0eSBfZGVmYXVsdExvYWRlckxlbmd0aFxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAc2luY2UgMC42LjBcblx0XHQgKi9cblx0XHR0aGlzLl9kZWZhdWx0TG9hZGVyTGVuZ3RoID0gdGhpcy5fYXZhaWxhYmxlTG9hZGVycy5sZW5ndGg7XG5cblx0XHR0aGlzLmluaXQocHJlZmVyWEhSLCBiYXNlUGF0aCwgY3Jvc3NPcmlnaW4pO1xuXHR9XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoTG9hZFF1ZXVlLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gTG9hZFF1ZXVlO1xuXG5cdC8qKlxuXHQgKiA8c3Ryb25nPlJFTU9WRUQ8L3N0cm9uZz4uIFJlbW92ZWQgaW4gZmF2b3Igb2YgdXNpbmcgYE15U3VwZXJDbGFzc19jb25zdHJ1Y3RvcmAuXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICpcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2QgaW5pdGlhbGl6ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cblxuXHQvKipcblx0ICogQW4gaW50ZXJuYWwgaW5pdGlhbGl6YXRpb24gbWV0aG9kLCB3aGljaCBpcyB1c2VkIGZvciBpbml0aWFsIHNldCB1cCwgYnV0IGFsc28gdG8gcmVzZXQgdGhlIExvYWRRdWV1ZS5cblx0ICogQG1ldGhvZCBpbml0XG5cdCAqIEBwYXJhbSBwcmVmZXJYSFJcblx0ICogQHBhcmFtIGJhc2VQYXRoXG5cdCAqIEBwYXJhbSBjcm9zc09yaWdpblxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5pbml0ID0gZnVuY3Rpb24gKHByZWZlclhIUiwgYmFzZVBhdGgsIGNyb3NzT3JpZ2luKSB7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSB1c2VYSFJcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICogQGRlcHJlY2F0ZWQgVXNlIHByZWZlclhIUiBpbnN0ZWFkLlxuXHRcdCAqL1xuXHRcdHRoaXMudXNlWEhSID0gdHJ1ZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRyeSBhbmQgdXNlIFhNTEh0dHBSZXF1ZXN0IChYSFIpIHdoZW4gcG9zc2libGUuIE5vdGUgdGhhdCBMb2FkUXVldWUgd2lsbCBkZWZhdWx0IHRvIHRhZyBsb2FkaW5nIG9yIFhIUlxuXHRcdCAqIGxvYWRpbmcgZGVwZW5kaW5nIG9uIHRoZSByZXF1aXJlbWVudHMgZm9yIGEgbWVkaWEgdHlwZS4gRm9yIGV4YW1wbGUsIEhUTUwgYXVkaW8gY2FuIG5vdCBiZSBsb2FkZWQgd2l0aCBYSFIsXG5cdFx0ICogYW5kIHBsYWluIHRleHQgY2FuIG5vdCBiZSBsb2FkZWQgd2l0aCB0YWdzLCBzbyBpdCB3aWxsIGRlZmF1bHQgdGhlIHRoZSBjb3JyZWN0IHR5cGUgaW5zdGVhZCBvZiB1c2luZyB0aGVcblx0XHQgKiB1c2VyLWRlZmluZWQgdHlwZS5cblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCB0cnVlXG5cdFx0ICogQHNpbmNlIDAuNi4wXG5cdFx0ICovXG5cdFx0dGhpcy5wcmVmZXJYSFIgPSB0cnVlOyAvL1RPRE86IEdldC9TZXRcblx0XHR0aGlzLl9wcmVmZXJYSFIgPSB0cnVlO1xuXHRcdHRoaXMuc2V0UHJlZmVyWEhSKHByZWZlclhIUik7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdGhlIHF1ZXVlIGlzIGN1cnJlbnRseSBwYXVzZWQgb3Igbm90LlxuXHRcdCAqIEBwcm9wZXJ0eSBfcGF1c2VkXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIEEgcGF0aCB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIG9uIHRvIHRoZSBpdGVtJ3Mge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vc3JjOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LiBUaGVcblx0XHQgKiBgX2Jhc2VQYXRoYCBwcm9wZXJ0eSB3aWxsIG9ubHkgYmUgdXNlZCBpZiBhbiBpdGVtJ3Mgc291cmNlIGlzIHJlbGF0aXZlLCBhbmQgZG9lcyBub3QgaW5jbHVkZSBhIHByb3RvY29sIHN1Y2hcblx0XHQgKiBhcyBgaHR0cDovL2AsIG9yIGEgcmVsYXRpdmUgcGF0aCBzdWNoIGFzIGAuLi9gLlxuXHRcdCAqIEBwcm9wZXJ0eSBfYmFzZVBhdGhcblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHNpbmNlIDAuMy4xXG5cdFx0ICovXG5cdFx0dGhpcy5fYmFzZVBhdGggPSBiYXNlUGF0aDtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9wdGlvbmFsIGZsYWcgdG8gc2V0IG9uIGltYWdlcyB0aGF0IGFyZSBsb2FkZWQgdXNpbmcgUHJlbG9hZEpTLCB3aGljaCBlbmFibGVzIENPUlMgc3VwcG9ydC4gSW1hZ2VzIGxvYWRlZFxuXHRcdCAqIGNyb3NzLWRvbWFpbiBieSBzZXJ2ZXJzIHRoYXQgc3VwcG9ydCBDT1JTIHJlcXVpcmUgdGhlIGNyb3NzT3JpZ2luIGZsYWcgdG8gYmUgbG9hZGVkIGFuZCBpbnRlcmFjdGVkIHdpdGggYnlcblx0XHQgKiBhIGNhbnZhcy4gV2hlbiBsb2FkaW5nIGxvY2FsbHksIG9yIHdpdGggYSBzZXJ2ZXIgd2l0aCBubyBDT1JTIHN1cHBvcnQsIHRoaXMgZmxhZyBjYW4gY2F1c2Ugb3RoZXIgc2VjdXJpdHkgaXNzdWVzLFxuXHRcdCAqIHNvIGl0IGlzIHJlY29tbWVuZGVkIHRvIG9ubHkgc2V0IGl0IGlmIHlvdSBhcmUgc3VyZSB0aGUgc2VydmVyIHN1cHBvcnRzIGl0LiBDdXJyZW50bHksIHN1cHBvcnRlZCB2YWx1ZXMgYXJlIFwiXCJcblx0XHQgKiBhbmQgXCJBbm9ueW1vdXNcIi5cblx0XHQgKiBAcHJvcGVydHkgX2Nyb3NzT3JpZ2luXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCBcIlwiXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBAc2luY2UgMC40LjFcblx0XHQgKi9cblx0XHR0aGlzLl9jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZFN0YXJ0IGV2ZW50IHdhcyBkaXNwYXRjaGVkIGFscmVhZHkuIFRoaXMgZXZlbnQgaXMgb25seSBmaXJlZCBvbmUgdGltZSwgd2hlbiB0aGUgZmlyc3Rcblx0XHQgKiBmaWxlIGlzIHJlcXVlc3RlZC5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRTdGFydFdhc0Rpc3BhdGNoZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZFN0YXJ0V2FzRGlzcGF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBjdXJyZW50bHkgYSBzY3JpcHQgbG9hZGluZy4gVGhpcyBoZWxwcyBlbnN1cmUgdGhhdCBvbmx5IGEgc2luZ2xlIHNjcmlwdCBsb2FkcyBhdCBvbmNlIHdoZW5cblx0XHQgKiB1c2luZyBhIHNjcmlwdCB0YWcgdG8gZG8gcHJlbG9hZGluZy5cblx0XHQgKiBAcHJvcGVydHkgX2N1cnJlbnRseUxvYWRpbmdTY3JpcHRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2N1cnJlbnRseUxvYWRpbmdTY3JpcHQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgY29udGFpbmluZyB0aGUgY3VycmVudGx5IGRvd25sb2FkaW5nIGZpbGVzLlxuXHRcdCAqIEBwcm9wZXJ0eSBfY3VycmVudExvYWRzXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fY3VycmVudExvYWRzID0gW107XG5cblx0XHQvKipcblx0XHQgKiBBbiBhcnJheSBjb250YWluaW5nIHRoZSBxdWV1ZWQgaXRlbXMgdGhhdCBoYXZlIG5vdCB5ZXQgc3RhcnRlZCBkb3dubG9hZGluZy5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRRdWV1ZVxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRRdWV1ZSA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgY29udGFpbmluZyBkb3dubG9hZHMgdGhhdCBoYXZlIG5vdCBjb21wbGV0ZWQsIHNvIHRoYXQgdGhlIExvYWRRdWV1ZSBjYW4gYmUgcHJvcGVybHkgcmVzZXQuXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkUXVldWVCYWNrdXBcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkUXVldWVCYWNrdXAgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBoYXNoIG9mIGl0ZW1zIHRoYXQgaGF2ZSBmaW5pc2hlZCBkb3dubG9hZGluZywgaW5kZXhlZCBieSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBpZC5cblx0XHQgKiBAcHJvcGVydHkgX2xvYWRJdGVtc0J5SWRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZEl0ZW1zQnlJZCA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IGhhc2ggb2YgaXRlbXMgdGhhdCBoYXZlIGZpbmlzaGVkIGRvd25sb2FkaW5nLCBpbmRleGVkIGJ5IHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogc291cmNlLlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZEl0ZW1zQnlTcmNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0dGhpcy5fbG9hZEl0ZW1zQnlTcmMgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBoYXNoIG9mIGxvYWRlZCBpdGVtcywgaW5kZXhlZCBieSB0aGUgSUQgb2YgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319LlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZGVkUmVzdWx0c1xuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkZWRSZXN1bHRzID0ge307XG5cblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3QgaGFzaCBvZiB1bi1wYXJzZWQgbG9hZGVkIGl0ZW1zLCBpbmRleGVkIGJ5IHRoZSBJRCBvZiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQHByb3BlcnR5IF9sb2FkZWRSYXdSZXN1bHRzXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRlZFJhd1Jlc3VsdHMgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBudW1iZXIgb2YgaXRlbXMgdGhhdCBoYXZlIGJlZW4gcmVxdWVzdGVkLiBUaGlzIGhlbHBzIG1hbmFnZSBhbiBvdmVyYWxsIHByb2dyZXNzIHdpdGhvdXQga25vd2luZyBob3cgbGFyZ2Vcblx0XHQgKiB0aGUgZmlsZXMgYXJlIGJlZm9yZSB0aGV5IGFyZSBkb3dubG9hZGVkLiBUaGlzIGRvZXMgbm90IGluY2x1ZGUgaXRlbXMgaW5zaWRlIG9mIGxvYWRlcnMgc3VjaCBhcyB0aGVcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJNYW5pZmVzdExvYWRlclwifX17ey9jcm9zc0xpbmt9fS5cblx0XHQgKiBAcHJvcGVydHkgX251bUl0ZW1zXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKi9cblx0XHR0aGlzLl9udW1JdGVtcyA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRoYXQgaGF2ZSBjb21wbGV0ZWQgbG9hZGVkLiBUaGlzIGhlbHBzIG1hbmFnZSBhbiBvdmVyYWxsIHByb2dyZXNzIHdpdGhvdXQga25vd2luZyBob3cgbGFyZ2Vcblx0XHQgKiB0aGUgZmlsZXMgYXJlIGJlZm9yZSB0aGV5IGFyZSBkb3dubG9hZGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfbnVtSXRlbXNMb2FkZWRcblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX251bUl0ZW1zTG9hZGVkID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEEgbGlzdCBvZiBzY3JpcHRzIGluIHRoZSBvcmRlciB0aGV5IHdlcmUgcmVxdWVzdGVkLiBUaGlzIGhlbHBzIGVuc3VyZSB0aGF0IHNjcmlwdHMgYXJlIFwiY29tcGxldGVkXCIgaW4gdGhlIHJpZ2h0XG5cdFx0ICogb3JkZXIuXG5cdFx0ICogQHByb3BlcnR5IF9zY3JpcHRPcmRlclxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX3NjcmlwdE9yZGVyID0gW107XG5cblx0XHQvKipcblx0XHQgKiBBIGxpc3Qgb2Ygc2NyaXB0cyB0aGF0IGhhdmUgYmVlbiBsb2FkZWQuIEl0ZW1zIGFyZSBhZGRlZCB0byB0aGlzIGxpc3QgYXMgPGNvZGU+bnVsbDwvY29kZT4gd2hlbiB0aGV5IGFyZVxuXHRcdCAqIHJlcXVlc3RlZCwgY29udGFpbiB0aGUgbG9hZGVkIGl0ZW0gaWYgaXQgaGFzIGNvbXBsZXRlZCwgYnV0IG5vdCBiZWVuIGRpc3BhdGNoZWQgdG8gdGhlIHVzZXIsIGFuZCA8Y29kZT50cnVlPC90cnVlPlxuXHRcdCAqIG9uY2UgdGhleSBhcmUgY29tcGxldGUgYW5kIGhhdmUgYmVlbiBkaXNwYXRjaGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfbG9hZGVkU2NyaXB0c1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX2xvYWRlZFNjcmlwdHMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBsYXN0IHByb2dyZXNzIGFtb3VudC4gVGhpcyBpcyB1c2VkIHRvIHN1cHByZXNzIGR1cGxpY2F0ZSBwcm9ncmVzcyBldmVudHMuXG5cdFx0ICogQHByb3BlcnR5IF9sYXN0UHJvZ3Jlc3Ncblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogQHNpbmNlIDAuNi4wXG5cdFx0ICovXG5cdFx0dGhpcy5fbGFzdFByb2dyZXNzID0gTmFOO1xuXG5cdH07XG5cbi8vIHN0YXRpYyBwcm9wZXJ0aWVzXG5cdC8qKlxuXHQgKiBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gYXNzdW1lIGEgbG9hZCBoYXMgZmFpbGVkLiBBbiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9lcnJvcjpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCBpcyBkaXNwYXRjaGVkIGlmIHRoZSB0aW1lb3V0IGlzIHJlYWNoZWQgYmVmb3JlIGFueSBkYXRhIGlzIHJlY2VpdmVkLlxuXHQgKiBAcHJvcGVydHkgbG9hZFRpbWVvdXRcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQGRlZmF1bHQgODAwMFxuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKiBAZGVwcmVjYXRlZCBJbiBmYXZvdXIgb2Yge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vTE9BRF9USU1FT1VUX0RFRkFVTFQ6cHJvcGVydHl9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5LlxuXHQgKi9cblx0cy5sb2FkVGltZW91dCA9IDgwMDA7XG5cblx0LyoqXG5cdCAqIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byBhc3N1bWUgYSBsb2FkIGhhcyBmYWlsZWQuXG5cdCAqIEBwcm9wZXJ0eSBMT0FEX1RJTUVPVVRcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQGRlZmF1bHQgMFxuXHQgKiBAZGVwcmVjYXRlZCBpbiBmYXZvciBvZiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRUaW1lb3V0OnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5LlxuXHQgKi9cblx0cy5MT0FEX1RJTUVPVVQgPSAwO1xuXG4vLyBQcmVsb2FkIFR5cGVzXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgQklOQVJZXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGJpbmFyeVxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvQklOQVJZOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLkJJTkFSWSA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkJJTkFSWTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IENTU1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBjc3Ncblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0NTUzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5DU1MgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5DU1M7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBJTUFHRVxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBpbWFnZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvQ1NTOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLklNQUdFID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSU1BR0U7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBKQVZBU0NSSVBUXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGphdmFzY3JpcHRcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pBVkFTQ1JJUFQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuSkFWQVNDUklQVCA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpBVkFTQ1JJUFQ7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBKU09OXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGpzb25cblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0pTT046cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuSlNPTiA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkpTT047XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBKU09OUFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBqc29ucFxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSlNPTlA6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuSlNPTlAgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KU09OUDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IE1BTklGRVNUXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IG1hbmlmZXN0XG5cdCAqIEBzdGF0aWNcblx0ICogQHNpbmNlIDAuNC4xXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvTUFOSUZFU1Q6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaW5zdGVhZC5cblx0ICovXG5cdHMuTUFOSUZFU1QgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5NQU5JRkVTVDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IFNPVU5EXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHNvdW5kXG5cdCAqIEBzdGF0aWNcblx0ICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBBYnN0cmFjdExvYWRlciB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KQVZBU0NSSVBUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLlNPVU5EID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU09VTkQ7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBWSURFT1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCB2aWRlb1xuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSkFWQVNDUklQVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5WSURFTyA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlZJREVPO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgU1ZHXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IHN2Z1xuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvU1ZHOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuXG5cdCAqL1xuXHRzLlNWRyA9IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNWRztcblxuXHQvKipcblx0ICogQHByb3BlcnR5IFRFWFRcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgdGV4dFxuXHQgKiBAc3RhdGljXG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvVEVYVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5URVhUID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVEVYVDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IFhNTFxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCB4bWxcblx0ICogQHN0YXRpY1xuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1hNTDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5YTUwgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5YTUw7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBQT1NUXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqIEBkZXByZWNhdGVkIFVzZSB0aGUgQWJzdHJhY3RMb2FkZXIge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvUE9TVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5QT1NUID0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuUE9TVDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IEdFVFxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIEFic3RyYWN0TG9hZGVyIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL0dFVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBpbnN0ZWFkLlxuXHQgKi9cblx0cy5HRVQgPSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5HRVQ7XG5cbi8vIGV2ZW50c1xuXHQvKipcblx0ICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGFuIGluZGl2aWR1YWwgZmlsZSBoYXMgbG9hZGVkLCBhbmQgYmVlbiBwcm9jZXNzZWQuXG5cdCAqIEBldmVudCBmaWxlbG9hZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSBmaWxlIGl0ZW0gd2hpY2ggd2FzIHNwZWNpZmllZCBpbiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG9yIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX0gY2FsbC4gSWYgb25seSBhIHN0cmluZyBwYXRoIG9yIHRhZyB3YXMgc3BlY2lmaWVkLCB0aGVcblx0ICogb2JqZWN0IHdpbGwgY29udGFpbiB0aGF0IHZhbHVlIGFzIGEgYHNyY2AgcHJvcGVydHkuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHQgVGhlIEhUTUwgdGFnIG9yIHBhcnNlZCByZXN1bHQgb2YgdGhlIGxvYWRlZCBpdGVtLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcmF3UmVzdWx0IFRoZSB1bnByb2Nlc3NlZCByZXN1bHQsIHVzdWFsbHkgdGhlIHJhdyB0ZXh0IG9yIGJpbmFyeSBkYXRhIGJlZm9yZSBpdCBpcyBjb252ZXJ0ZWRcblx0ICogdG8gYSB1c2FibGUgb2JqZWN0LlxuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoaXMge3sjY3Jvc3NMaW5rIFwiUHJvZ3Jlc3NFdmVudFwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGlzIGZpcmVkIHdoZW4gYW4gYW4gaW5kaXZpZHVhbCBmaWxlJ3MgcHJvZ3Jlc3MgY2hhbmdlcy5cblx0ICogQGV2ZW50IGZpbGVwcm9ncmVzc1xuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cblx0LyoqXG5cdCAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhbiBpbmRpdmlkdWFsIGZpbGUgc3RhcnRzIHRvIGxvYWQuXG5cdCAqIEBldmVudCBmaWxlc3RhcnRcblx0ICogQHBhcmFtIHtPYmplY3R9IFRoZSBvYmplY3QgdGhhdCBkaXNwYXRjaGVkIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIFRoZSBmaWxlIGl0ZW0gd2hpY2ggd2FzIHNwZWNpZmllZCBpbiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRGaWxlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG9yIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkTWFuaWZlc3RcIn19e3svY3Jvc3NMaW5rfX0gY2FsbC4gSWYgb25seSBhIHN0cmluZyBwYXRoIG9yIHRhZyB3YXMgc3BlY2lmaWVkLCB0aGVcblx0ICogb2JqZWN0IHdpbGwgY29udGFpbiB0aGF0IHZhbHVlIGFzIGEgcHJvcGVydHkuXG5cdCAqL1xuXG4vLyBwdWJsaWMgbWV0aG9kc1xuXHQvKipcblx0ICogUmVnaXN0ZXIgYSBjdXN0b20gbG9hZGVycyBjbGFzcy4gTmV3IGxvYWRlcnMgYXJlIGdpdmVuIHByZWNlZGVuY2Ugb3ZlciBsb2FkZXJzIGFkZGVkIGVhcmxpZXIgYW5kIGRlZmF1bHQgbG9hZGVycy5cblx0ICogSXQgaXMgcmVjb21tZW5kZWQgdGhhdCBsb2FkZXJzIGV4dGVuZCB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlclwifX17ey9jcm9zc0xpbmt9fS4gTG9hZGVycyBjYW4gb25seSBiZSBhZGRlZFxuXHQgKiBvbmNlLCBhbmQgd2lsbCBiZSBwcmVwZW5kZWQgdG8gdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGxvYWRlcnMuXG5cdCAqIEBtZXRob2QgcmVnaXN0ZXJMb2FkZXJcblx0ICogQHBhcmFtIHtGdW5jdGlvbnxBYnN0cmFjdExvYWRlcn0gbG9hZGVyIFRoZSBBYnN0cmFjdExvYWRlciBjbGFzcyB0byBhZGQuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5yZWdpc3RlckxvYWRlciA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHRpZiAoIWxvYWRlciB8fCAhbG9hZGVyLmNhbkxvYWRJdGVtKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJsb2FkZXIgaXMgb2YgYW4gaW5jb3JyZWN0IHR5cGUuXCIpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5fYXZhaWxhYmxlTG9hZGVycy5pbmRleE9mKGxvYWRlcikgIT0gLTEpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcImxvYWRlciBhbHJlYWR5IGV4aXN0cy5cIik7IC8vTE06IE1heWJlIGp1c3Qgc2lsZW50bHkgZmFpbCBoZXJlXG5cdFx0fVxuXG5cdFx0dGhpcy5fYXZhaWxhYmxlTG9hZGVycy51bnNoaWZ0KGxvYWRlcik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhIGN1c3RvbSBsb2FkZXIgYWRkZWQgdXNpZyB7eyNjcm9zc0xpbmsgXCJyZWdpc3RlckxvYWRlclwifX17ey9jcm9zc0xpbmt9fS4gT25seSBjdXN0b20gbG9hZGVycyBjYW4gYmVcblx0ICogdW5yZWdpc3RlcmVkLCB0aGUgZGVmYXVsdCBsb2FkZXJzIHdpbGwgYWx3YXlzIGJlIGF2YWlsYWJsZS5cblx0ICogQG1ldGhvZCB1bnJlZ2lzdGVyTG9hZGVyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb258QWJzdHJhY3RMb2FkZXJ9IGxvYWRlciBUaGUgQWJzdHJhY3RMb2FkZXIgY2xhc3MgdG8gcmVtb3ZlXG5cdCAqL1xuXHRwLnVucmVnaXN0ZXJMb2FkZXIgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0dmFyIGlkeCA9IHRoaXMuX2F2YWlsYWJsZUxvYWRlcnMuaW5kZXhPZihsb2FkZXIpO1xuXHRcdGlmIChpZHggIT0gLTEgJiYgaWR4IDwgdGhpcy5fZGVmYXVsdExvYWRlckxlbmd0aCAtIDEpIHtcblx0XHRcdHRoaXMuX2F2YWlsYWJsZUxvYWRlcnMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHNldFVzZVhIUlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIFRoZSBuZXcgdXNlWEhSIHZhbHVlIHRvIHNldC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVGhlIG5ldyB1c2VYSFIgdmFsdWUuIElmIFhIUiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyLCB0aGlzIHdpbGwgcmV0dXJuIGZhbHNlLCBldmVuIGlmXG5cdCAqIHRoZSBwcm92aWRlZCB2YWx1ZSBhcmd1bWVudCB3YXMgdHJ1ZS5cblx0ICogQHNpbmNlIDAuMy4wXG5cdCAqIEBkZXByZWNhdGVkIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwicHJlZmVyWEhSOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5LCBvciB0aGUge3sjY3Jvc3NMaW5rIFwic2V0VXNlWEhSXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZCBpbnN0ZWFkLlxuXHQgKi9cblx0cC5zZXRVc2VYSFIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRQcmVmZXJYSFIodmFsdWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGFuZ2UgdGhlIHt7I2Nyb3NzTGluayBcInByZWZlclhIUjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSB2YWx1ZS4gTm90ZSB0aGF0IGlmIHRoaXMgaXMgc2V0IHRvIGB0cnVlYCwgaXQgbWF5XG5cdCAqIGZhaWwsIG9yIGJlIGlnbm9yZWQgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyJ3MgY2FwYWJpbGl0aWVzIGFuZCB0aGUgbG9hZCB0eXBlLlxuXHQgKiBAbWV0aG9kIHNldFByZWZlclhIUlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBUaGUgdmFsdWUgb2Yge3sjY3Jvc3NMaW5rIFwicHJlZmVyWEhSXCJ9fXt7L2Nyb3NzTGlua319IHRoYXQgd2FzIHN1Y2Nlc3NmdWxseSBzZXQuXG5cdCAqIEBzaW5jZSAwLjYuMFxuXHQgKi9cblx0cC5zZXRQcmVmZXJYSFIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHQvLyBEZXRlcm1pbmUgaWYgd2UgY2FuIHVzZSBYSFIuIFhIUiBkZWZhdWx0cyB0byBUUlVFLCBidXQgdGhlIGJyb3dzZXIgbWF5IG5vdCBzdXBwb3J0IGl0LlxuXHRcdC8vVE9ETzogU2hvdWxkIHdlIGJlIGNoZWNraW5nIGZvciB0aGUgb3RoZXIgWEhSIHR5cGVzPyBNaWdodCBoYXZlIHRvIGRvIGEgdHJ5L2NhdGNoIG9uIHRoZSBkaWZmZXJlbnQgdHlwZXMgc2ltaWxhciB0byBjcmVhdGVYSFIuXG5cdFx0dGhpcy5wcmVmZXJYSFIgPSAodmFsdWUgIT0gZmFsc2UgJiYgd2luZG93LlhNTEh0dHBSZXF1ZXN0ICE9IG51bGwpO1xuXHRcdHJldHVybiB0aGlzLnByZWZlclhIUjtcblx0fTtcblxuXHQvKipcblx0ICogU3RvcHMgYWxsIHF1ZXVlZCBhbmQgbG9hZGluZyBpdGVtcywgYW5kIGNsZWFycyB0aGUgcXVldWUuIFRoaXMgYWxzbyByZW1vdmVzIGFsbCBpbnRlcm5hbCByZWZlcmVuY2VzIHRvIGxvYWRlZFxuXHQgKiBjb250ZW50LCBhbmQgYWxsb3dzIHRoZSBxdWV1ZSB0byBiZSB1c2VkIGFnYWluLlxuXHQgKiBAbWV0aG9kIHJlbW92ZUFsbFxuXHQgKiBAc2luY2UgMC4zLjBcblx0ICovXG5cdHAucmVtb3ZlQWxsID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMucmVtb3ZlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3BzIGFuIGl0ZW0gZnJvbSBiZWluZyBsb2FkZWQsIGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIHF1ZXVlLiBJZiBub3RoaW5nIGlzIHBhc3NlZCwgYWxsIGl0ZW1zIGFyZSByZW1vdmVkLlxuXHQgKiBUaGlzIGFsc28gcmVtb3ZlcyBpbnRlcm5hbCByZWZlcmVuY2VzIHRvIGxvYWRlZCBpdGVtKHMpLlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgcXVldWUubG9hZE1hbmlmZXN0KFtcblx0ICogICAgICAgICAge3NyYzpcInRlc3QucG5nXCIsIGlkOlwicG5nXCJ9LFxuXHQgKiAgICAgICAgICB7c3JjOlwidGVzdC5qcGdcIiwgaWQ6XCJqcGdcIn0sXG5cdCAqICAgICAgICAgIHtzcmM6XCJ0ZXN0Lm1wM1wiLCBpZDpcIm1wM1wifVxuXHQgKiAgICAgIF0pO1xuXHQgKiAgICAgIHF1ZXVlLnJlbW92ZShcInBuZ1wiKTsgLy8gU2luZ2xlIGl0ZW0gYnkgSURcblx0ICogICAgICBxdWV1ZS5yZW1vdmUoXCJwbmdcIiwgXCJ0ZXN0LmpwZ1wiKTsgLy8gSXRlbXMgYXMgYXJndW1lbnRzLiBNaXhlZCBpZCBhbmQgc3JjLlxuXHQgKiAgICAgIHF1ZXVlLnJlbW92ZShbXCJ0ZXN0LnBuZ1wiLCBcImpwZ1wiXSk7IC8vIEl0ZW1zIGluIGFuIEFycmF5LiBNaXhlZCBpZCBhbmQgc3JjLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlbW92ZVxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IEFycmF5fSBpZHNPclVybHMqIFRoZSBpZCBvciBpZHMgdG8gcmVtb3ZlIGZyb20gdGhpcyBxdWV1ZS4gWW91IGNhbiBwYXNzIGFuIGl0ZW0sIGFuIGFycmF5IG9mXG5cdCAqIGl0ZW1zLCBvciBtdWx0aXBsZSBpdGVtcyBhcyBhcmd1bWVudHMuXG5cdCAqIEBzaW5jZSAwLjMuMFxuXHQgKi9cblx0cC5yZW1vdmUgPSBmdW5jdGlvbiAoaWRzT3JVcmxzKSB7XG5cdFx0dmFyIGFyZ3MgPSBudWxsO1xuXG5cdFx0aWYgKGlkc09yVXJscyAmJiAhKGlkc09yVXJscyBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdFx0YXJncyA9IFtpZHNPclVybHNdO1xuXHRcdH0gZWxzZSBpZiAoaWRzT3JVcmxzKSB7XG5cdFx0XHRhcmdzID0gaWRzT3JVcmxzO1xuXHRcdH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaXRlbXNXZXJlUmVtb3ZlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gRGVzdHJveSBldmVyeXRoaW5nXG5cdFx0aWYgKCFhcmdzKSB7XG5cdFx0XHR0aGlzLmNsb3NlKCk7XG5cdFx0XHRmb3IgKHZhciBuIGluIHRoaXMuX2xvYWRJdGVtc0J5SWQpIHtcblx0XHRcdFx0dGhpcy5fZGlzcG9zZUl0ZW0odGhpcy5fbG9hZEl0ZW1zQnlJZFtuXSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmluaXQodGhpcy5wcmVmZXJYSFIsIHRoaXMuX2Jhc2VQYXRoKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIHNwZWNpZmljIGl0ZW1zXG5cdFx0fSBlbHNlIHtcblx0XHRcdHdoaWxlIChhcmdzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgaXRlbSA9IGFyZ3MucG9wKCk7XG5cdFx0XHRcdHZhciByID0gdGhpcy5nZXRSZXN1bHQoaXRlbSk7XG5cblx0XHRcdFx0Ly9SZW1vdmUgZnJvbSB0aGUgbWFpbiBsb2FkIFF1ZXVlXG5cdFx0XHRcdGZvciAoaSA9IHRoaXMuX2xvYWRRdWV1ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdGxvYWRJdGVtID0gdGhpcy5fbG9hZFF1ZXVlW2ldLmdldEl0ZW0oKTtcblx0XHRcdFx0XHRpZiAobG9hZEl0ZW0uaWQgPT0gaXRlbSB8fCBsb2FkSXRlbS5zcmMgPT0gaXRlbSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fbG9hZFF1ZXVlLnNwbGljZShpLCAxKVswXS5jYW5jZWwoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vUmVtb3ZlIGZyb20gdGhlIGJhY2t1cCBxdWV1ZVxuXHRcdFx0XHRmb3IgKGkgPSB0aGlzLl9sb2FkUXVldWVCYWNrdXAubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRsb2FkSXRlbSA9IHRoaXMuX2xvYWRRdWV1ZUJhY2t1cFtpXS5nZXRJdGVtKCk7XG5cdFx0XHRcdFx0aWYgKGxvYWRJdGVtLmlkID09IGl0ZW0gfHwgbG9hZEl0ZW0uc3JjID09IGl0ZW0pIHtcblx0XHRcdFx0XHRcdHRoaXMuX2xvYWRRdWV1ZUJhY2t1cC5zcGxpY2UoaSwgMSlbMF0uY2FuY2VsKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAocikge1xuXHRcdFx0XHRcdHRoaXMuX2Rpc3Bvc2VJdGVtKHRoaXMuZ2V0SXRlbShpdGVtKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IHRoaXMuX2N1cnJlbnRMb2Fkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdFx0dmFyIGxvYWRJdGVtID0gdGhpcy5fY3VycmVudExvYWRzW2ldLmdldEl0ZW0oKTtcblx0XHRcdFx0XHRcdGlmIChsb2FkSXRlbS5pZCA9PSBpdGVtIHx8IGxvYWRJdGVtLnNyYyA9PSBpdGVtKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2N1cnJlbnRMb2Fkcy5zcGxpY2UoaSwgMSlbMF0uY2FuY2VsKCk7XG5cdFx0XHRcdFx0XHRcdGl0ZW1zV2VyZVJlbW92ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyB3YXMgY2FsbGVkIGR1cmluZyBhIGxvYWQsIHRyeSB0byBsb2FkIHRoZSBuZXh0IGl0ZW0uXG5cdFx0XHRpZiAoaXRlbXNXZXJlUmVtb3ZlZCkge1xuXHRcdFx0XHR0aGlzLl9sb2FkTmV4dCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogU3RvcHMgYWxsIG9wZW4gbG9hZHMsIGRlc3Ryb3lzIGFueSBsb2FkZWQgaXRlbXMsIGFuZCByZXNldHMgdGhlIHF1ZXVlLCBzbyBhbGwgaXRlbXMgY2FuXG5cdCAqIGJlIHJlbG9hZGVkIGFnYWluIGJ5IGNhbGxpbmcge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvbG9hZFwifX17ey9jcm9zc0xpbmt9fS4gSXRlbXMgYXJlIG5vdCByZW1vdmVkIGZyb20gdGhlXG5cdCAqIHF1ZXVlLiBUbyByZW1vdmUgaXRlbXMgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvcmVtb3ZlXCJ9fXt7L2Nyb3NzTGlua319IG9yXG5cdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9yZW1vdmVBbGxcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXHQgKiBAbWV0aG9kIHJlc2V0XG5cdCAqIEBzaW5jZSAwLjMuMFxuXHQgKi9cblx0cC5yZXNldCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmNsb3NlKCk7XG5cdFx0Zm9yICh2YXIgbiBpbiB0aGlzLl9sb2FkSXRlbXNCeUlkKSB7XG5cdFx0XHR0aGlzLl9kaXNwb3NlSXRlbSh0aGlzLl9sb2FkSXRlbXNCeUlkW25dKTtcblx0XHR9XG5cblx0XHQvL1Jlc2V0IHRoZSBxdWV1ZSB0byBpdHMgc3RhcnQgc3RhdGVcblx0XHR2YXIgYSA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fbG9hZFF1ZXVlQmFja3VwLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0YS5wdXNoKHRoaXMuX2xvYWRRdWV1ZUJhY2t1cFtpXS5nZXRJdGVtKCkpO1xuXHRcdH1cblxuXHRcdHRoaXMubG9hZE1hbmlmZXN0KGEsIGZhbHNlKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVnaXN0ZXIgYSBwbHVnaW4uIFBsdWdpbnMgY2FuIG1hcCB0byBsb2FkIHR5cGVzIChzb3VuZCwgaW1hZ2UsIGV0YyksIG9yIHNwZWNpZmljIGV4dGVuc2lvbnMgKHBuZywgbXAzLCBldGMpLlxuXHQgKiBDdXJyZW50bHksIG9ubHkgb25lIHBsdWdpbiBjYW4gZXhpc3QgcGVyIHR5cGUvZXh0ZW5zaW9uLlxuXHQgKlxuXHQgKiBXaGVuIGEgcGx1Z2luIGlzIGluc3RhbGxlZCwgYSA8Y29kZT5nZXRQcmVsb2FkSGFuZGxlcnMoKTwvY29kZT4gbWV0aG9kIHdpbGwgYmUgY2FsbGVkIG9uIGl0LiBGb3IgbW9yZSBpbmZvcm1hdGlvblxuXHQgKiBvbiB0aGlzIG1ldGhvZCwgY2hlY2sgb3V0IHRoZSB7eyNjcm9zc0xpbmsgXCJTYW1wbGVQbHVnaW4vZ2V0UHJlbG9hZEhhbmRsZXJzXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCBpbiB0aGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiU2FtcGxlUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzLlxuXHQgKlxuXHQgKiBCZWZvcmUgYSBmaWxlIGlzIGxvYWRlZCwgYSBtYXRjaGluZyBwbHVnaW4gaGFzIGFuIG9wcG9ydHVuaXR5IHRvIG1vZGlmeSB0aGUgbG9hZC4gSWYgYSBgY2FsbGJhY2tgIGlzIHJldHVybmVkXG5cdCAqIGZyb20gdGhlIHt7I2Nyb3NzTGluayBcIlNhbXBsZVBsdWdpbi9nZXRQcmVsb2FkSGFuZGxlcnNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLCBpdCB3aWxsIGJlIGludm9rZWQgZmlyc3QsIGFuZCBpdHNcblx0ICogcmVzdWx0IG1heSBjYW5jZWwgb3IgbW9kaWZ5IHRoZSBpdGVtLiBUaGUgY2FsbGJhY2sgbWV0aG9kIGNhbiBhbHNvIHJldHVybiBhIGBjb21wbGV0ZUhhbmRsZXJgIHRvIGJlIGZpcmVkIHdoZW5cblx0ICogdGhlIGZpbGUgaXMgbG9hZGVkLCBvciBhIGB0YWdgIG9iamVjdCwgd2hpY2ggd2lsbCBtYW5hZ2UgdGhlIGFjdHVhbCBkb3dubG9hZC4gRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2Vcblx0ICogbWV0aG9kcywgY2hlY2sgb3V0IHRoZSB7eyNjcm9zc0xpbmsgXCJTYW1wbGVQbHVnaW4vcHJlbG9hZEhhbmRsZXJcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlNhbXBsZVBsdWdpbi9maWxlTG9hZEhhbmRsZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogbWV0aG9kcyBvbiB0aGUge3sjY3Jvc3NMaW5rIFwiU2FtcGxlUGx1Z2luXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBAbWV0aG9kIGluc3RhbGxQbHVnaW5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gcGx1Z2luIFRoZSBwbHVnaW4gY2xhc3MgdG8gaW5zdGFsbC5cblx0ICovXG5cdHAuaW5zdGFsbFBsdWdpbiA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcblx0XHRpZiAocGx1Z2luID09IG51bGwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAocGx1Z2luLmdldFByZWxvYWRIYW5kbGVycyAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl9wbHVnaW5zLnB1c2gocGx1Z2luKTtcblx0XHRcdHZhciBtYXAgPSBwbHVnaW4uZ2V0UHJlbG9hZEhhbmRsZXJzKCk7XG5cdFx0XHRtYXAuc2NvcGUgPSBwbHVnaW47XG5cblx0XHRcdGlmIChtYXAudHlwZXMgIT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG1hcC50eXBlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR0aGlzLl90eXBlQ2FsbGJhY2tzW21hcC50eXBlc1tpXV0gPSBtYXA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG1hcC5leHRlbnNpb25zICE9IG51bGwpIHtcblx0XHRcdFx0Zm9yIChpID0gMCwgbCA9IG1hcC5leHRlbnNpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHRoaXMuX2V4dGVuc2lvbkNhbGxiYWNrc1ttYXAuZXh0ZW5zaW9uc1tpXV0gPSBtYXA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgbWF4aW11bSBudW1iZXIgb2YgY29uY3VycmVudCBjb25uZWN0aW9ucy4gTm90ZSB0aGF0IGJyb3dzZXJzIGFuZCBzZXJ2ZXJzIG1heSBoYXZlIGEgYnVpbHQtaW4gbWF4aW11bVxuXHQgKiBudW1iZXIgb2Ygb3BlbiBjb25uZWN0aW9ucywgc28gYW55IGFkZGl0aW9uYWwgY29ubmVjdGlvbnMgbWF5IHJlbWFpbiBpbiBhIHBlbmRpbmcgc3RhdGUgdW50aWwgdGhlIGJyb3dzZXJcblx0ICogb3BlbnMgdGhlIGNvbm5lY3Rpb24uIFdoZW4gbG9hZGluZyBzY3JpcHRzIHVzaW5nIHRhZ3MsIGFuZCB3aGVuIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9tYWludGFpblNjcmlwdE9yZGVyOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGlzIGB0cnVlYCwgb25seSBvbmUgc2NyaXB0IGlzIGxvYWRlZCBhdCBhIHRpbWUgZHVlIHRvIGJyb3dzZXIgbGltaXRhdGlvbnMuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICB2YXIgcXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG5cdCAqICAgICAgcXVldWUuc2V0TWF4Q29ubmVjdGlvbnMoMTApOyAvLyBBbGxvdyAxMCBjb25jdXJyZW50IGxvYWRzXG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0TWF4Q29ubmVjdGlvbnNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgb2YgY29uY3VycmVudCBsb2FkcyB0byBhbGxvdy4gQnkgZGVmYXVsdCwgb25seSBhIHNpbmdsZSBjb25uZWN0aW9uIHBlciBMb2FkUXVldWVcblx0ICogaXMgb3BlbiBhdCBhbnkgdGltZS5cblx0ICovXG5cdHAuc2V0TWF4Q29ubmVjdGlvbnMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR0aGlzLl9tYXhDb25uZWN0aW9ucyA9IHZhbHVlO1xuXHRcdGlmICghdGhpcy5fcGF1c2VkICYmIHRoaXMuX2xvYWRRdWV1ZS5sZW5ndGggPiAwKSB7XG5cdFx0XHR0aGlzLl9sb2FkTmV4dCgpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogTG9hZCBhIHNpbmdsZSBmaWxlLiBUbyBhZGQgbXVsdGlwbGUgZmlsZXMgYXQgb25jZSwgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG1ldGhvZC5cblx0ICpcblx0ICogRmlsZXMgYXJlIGFsd2F5cyBhcHBlbmRlZCB0byB0aGUgY3VycmVudCBxdWV1ZSwgc28gdGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgbXVsdGlwbGUgdGltZXMgdG8gYWRkIGZpbGVzLlxuXHQgKiBUbyBjbGVhciB0aGUgcXVldWUgZmlyc3QsIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvY2xvc2VcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLlxuXHQgKiBAbWV0aG9kIGxvYWRGaWxlXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fFN0cmluZ30gZmlsZSBUaGUgZmlsZSBvYmplY3Qgb3IgcGF0aCB0byBsb2FkLiBBIGZpbGUgY2FuIGJlIGVpdGhlclxuXHQgKiA8dWw+XG5cdCAqICAgICA8bGk+QSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZTwvbGk+XG5cdCAqICAgICA8bGk+QW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBkZWZpbmVkIGJ5IHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319PC9saT5cblx0ICogICAgIDxsaT5PUiBBIHN0cmluZyBwYXRoIHRvIGEgcmVzb3VyY2UuIE5vdGUgdGhhdCB0aGlzIGtpbmQgb2YgbG9hZCBpdGVtIHdpbGwgYmUgY29udmVydGVkIHRvIGEge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX1cblx0ICogICAgIGluIHRoZSBiYWNrZ3JvdW5kLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2xvYWROb3c9dHJ1ZV0gS2ljayBvZmYgYW4gaW1tZWRpYXRlIGxvYWQgKHRydWUpIG9yIHdhaXQgZm9yIGEgbG9hZCBjYWxsIChmYWxzZSkuIFRoZSBkZWZhdWx0XG5cdCAqIHZhbHVlIGlzIHRydWUuIElmIHRoZSBxdWV1ZSBpcyBwYXVzZWQgdXNpbmcge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldFBhdXNlZFwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHRoZSB2YWx1ZSBpc1xuXHQgKiBgdHJ1ZWAsIHRoZSBxdWV1ZSB3aWxsIHJlc3VtZSBhdXRvbWF0aWNhbGx5LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2Jhc2VQYXRoXSBBIGJhc2UgcGF0aCB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIHRvIGVhY2ggZmlsZS4gVGhlIGJhc2VQYXRoIGFyZ3VtZW50IG92ZXJyaWRlcyB0aGVcblx0ICogcGF0aCBzcGVjaWZpZWQgaW4gdGhlIGNvbnN0cnVjdG9yLiBOb3RlIHRoYXQgaWYgeW91IGxvYWQgYSBtYW5pZmVzdCB1c2luZyBhIGZpbGUgb2YgdHlwZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9NQU5JRkVTVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogaXRzIGZpbGVzIHdpbGwgPHN0cm9uZz5OT1Q8L3N0cm9uZz4gdXNlIHRoZSBiYXNlUGF0aCBwYXJhbWV0ZXIuIDxzdHJvbmc+VGhlIGJhc2VQYXRoIHBhcmFtZXRlciBpcyBkZXByZWNhdGVkLjwvc3Ryb25nPlxuXHQgKiBUaGlzIHBhcmFtZXRlciB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gUGxlYXNlIGVpdGhlciB1c2UgdGhlIGBiYXNlUGF0aGAgcGFyYW1ldGVyIGluIHRoZSBMb2FkUXVldWVcblx0ICogY29uc3RydWN0b3IsIG9yIGEgYHBhdGhgIHByb3BlcnR5IGluIGEgbWFuaWZlc3QgZGVmaW5pdGlvbi5cblx0ICovXG5cdHAubG9hZEZpbGUgPSBmdW5jdGlvbiAoZmlsZSwgbG9hZE5vdywgYmFzZVBhdGgpIHtcblx0XHRpZiAoZmlsZSA9PSBudWxsKSB7XG5cdFx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXJyb3JFdmVudChcIlBSRUxPQURfTk9fRklMRVwiKTtcblx0XHRcdHRoaXMuX3NlbmRFcnJvcihldmVudCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuX2FkZEl0ZW0oZmlsZSwgbnVsbCwgYmFzZVBhdGgpO1xuXG5cdFx0aWYgKGxvYWROb3cgIT09IGZhbHNlKSB7XG5cdFx0XHR0aGlzLnNldFBhdXNlZChmYWxzZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2V0UGF1c2VkKHRydWUpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogTG9hZCBhbiBhcnJheSBvZiBmaWxlcy4gVG8gbG9hZCBhIHNpbmdsZSBmaWxlLCB1c2UgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cdCAqIFRoZSBmaWxlcyBpbiB0aGUgbWFuaWZlc3QgYXJlIHJlcXVlc3RlZCBpbiB0aGUgc2FtZSBvcmRlciwgYnV0IG1heSBjb21wbGV0ZSBpbiBhIGRpZmZlcmVudCBvcmRlciBpZiB0aGUgbWF4XG5cdCAqIGNvbm5lY3Rpb25zIGFyZSBzZXQgYWJvdmUgMSB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc2V0TWF4Q29ubmVjdGlvbnNcIn19e3svY3Jvc3NMaW5rfX0uIFNjcmlwdHMgd2lsbCBsb2FkXG5cdCAqIGluIHRoZSByaWdodCBvcmRlciBhcyBsb25nIGFzIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9tYWludGFpblNjcmlwdE9yZGVyXCJ9fXt7L2Nyb3NzTGlua319IGlzIHRydWUgKHdoaWNoIGlzXG5cdCAqIGRlZmF1bHQpLlxuXHQgKlxuXHQgKiBGaWxlcyBhcmUgYWx3YXlzIGFwcGVuZGVkIHRvIHRoZSBjdXJyZW50IHF1ZXVlLCBzbyB0aGlzIG1ldGhvZCBjYW4gYmUgdXNlZCBtdWx0aXBsZSB0aW1lcyB0byBhZGQgZmlsZXMuXG5cdCAqIFRvIGNsZWFyIHRoZSBxdWV1ZSBmaXJzdCwgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9jbG9zZVwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuXG5cdCAqIEBtZXRob2QgbG9hZE1hbmlmZXN0XG5cdCAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfE9iamVjdH0gbWFuaWZlc3QgQW4gbGlzdCBvZiBmaWxlcyB0byBsb2FkLiBUaGUgbG9hZE1hbmlmZXN0IGNhbGwgc3VwcG9ydHMgZm91ciB0eXBlcyBvZlxuXHQgKiBtYW5pZmVzdHM6XG5cdCAqIDxvbD5cblx0ICogICAgIDxsaT5BIHN0cmluZyBwYXRoLCB3aGljaCBwb2ludHMgdG8gYSBtYW5pZmVzdCBmaWxlLCB3aGljaCBpcyBhIEpTT04gZmlsZSB0aGF0IGNvbnRhaW5zIGEgXCJtYW5pZmVzdFwiIHByb3BlcnR5LFxuXHQgKiAgICAgd2hpY2ggZGVmaW5lcyB0aGUgbGlzdCBvZiBmaWxlcyB0byBsb2FkLCBhbmQgY2FuIG9wdGlvbmFsbHkgY29udGFpbiBhIFwicGF0aFwiIHByb3BlcnR5LCB3aGljaCB3aWxsIGJlXG5cdCAqICAgICBwcmVwZW5kZWQgdG8gZWFjaCBmaWxlIGluIHRoZSBsaXN0LjwvbGk+XG5cdCAqICAgICA8bGk+QW4gb2JqZWN0IHdoaWNoIGRlZmluZXMgYSBcInNyY1wiLCB3aGljaCBpcyBhIEpTT04gb3IgSlNPTlAgZmlsZS4gQSBcImNhbGxiYWNrXCIgY2FuIGJlIGRlZmluZWQgZm9yIEpTT05QXG5cdCAqICAgICBmaWxlLiBUaGUgSlNPTi9KU09OUCBmaWxlIHNob3VsZCBjb250YWluIGEgXCJtYW5pZmVzdFwiIHByb3BlcnR5LCB3aGljaCBkZWZpbmVzIHRoZSBsaXN0IG9mIGZpbGVzIHRvIGxvYWQsXG5cdCAqICAgICBhbmQgY2FuIG9wdGlvbmFsbHkgY29udGFpbiBhIFwicGF0aFwiIHByb3BlcnR5LCB3aGljaCB3aWxsIGJlIHByZXBlbmRlZCB0byBlYWNoIGZpbGUgaW4gdGhlIGxpc3QuPC9saT5cblx0ICogICAgIDxsaT5BbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgYSBcIm1hbmlmZXN0XCIgcHJvcGVydHksIHdoaWNoIGRlZmluZXMgdGhlIGxpc3Qgb2YgZmlsZXMgdG8gbG9hZCwgYW5kIGNhblxuXHQgKiAgICAgb3B0aW9uYWxseSBjb250YWluIGEgXCJwYXRoXCIgcHJvcGVydHksIHdoaWNoIHdpbGwgYmUgcHJlcGVuZGVkIHRvIGVhY2ggZmlsZSBpbiB0aGUgbGlzdC48L2xpPlxuXHQgKiAgICAgPGxpPkFuIEFycmF5IG9mIGZpbGVzIHRvIGxvYWQuPC9saT5cblx0ICogPC9vbD5cblx0ICpcblx0ICogRWFjaCBcImZpbGVcIiBpbiBhIG1hbmlmZXN0IGNhbiBiZSBlaXRoZXI6XG5cdCAqIDx1bD5cblx0ICogICAgIDxsaT5BIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IGluc3RhbmNlPC9saT5cblx0ICogICAgIDxsaT5BbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGRlZmluZWQgYnkge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX08L2xpPlxuXHQgKiAgICAgPGxpPk9SIEEgc3RyaW5nIHBhdGggdG8gYSByZXNvdXJjZS4gTm90ZSB0aGF0IHRoaXMga2luZCBvZiBsb2FkIGl0ZW0gd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiAgICAgaW4gdGhlIGJhY2tncm91bmQuPC9saT5cblx0ICogPC91bD5cblx0ICpcblx0ICogQHBhcmFtIHtCb29sZWFufSBbbG9hZE5vdz10cnVlXSBLaWNrIG9mZiBhbiBpbW1lZGlhdGUgbG9hZCAodHJ1ZSkgb3Igd2FpdCBmb3IgYSBsb2FkIGNhbGwgKGZhbHNlKS4gVGhlIGRlZmF1bHRcblx0ICogdmFsdWUgaXMgdHJ1ZS4gSWYgdGhlIHF1ZXVlIGlzIHBhdXNlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc2V0UGF1c2VkXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB0aGlzIHZhbHVlIGlzXG5cdCAqIGB0cnVlYCwgdGhlIHF1ZXVlIHdpbGwgcmVzdW1lIGF1dG9tYXRpY2FsbHkuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbYmFzZVBhdGhdIEEgYmFzZSBwYXRoIHRoYXQgd2lsbCBiZSBwcmVwZW5kZWQgdG8gZWFjaCBmaWxlLiBUaGUgYmFzZVBhdGggYXJndW1lbnQgb3ZlcnJpZGVzIHRoZVxuXHQgKiBwYXRoIHNwZWNpZmllZCBpbiB0aGUgY29uc3RydWN0b3IuIE5vdGUgdGhhdCBpZiB5b3UgbG9hZCBhIG1hbmlmZXN0IHVzaW5nIGEgZmlsZSBvZiB0eXBlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9NQU5JRkVTVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSxcblx0ICogaXRzIGZpbGVzIHdpbGwgPHN0cm9uZz5OT1Q8L3N0cm9uZz4gdXNlIHRoZSBiYXNlUGF0aCBwYXJhbWV0ZXIuIDxzdHJvbmc+VGhlIGJhc2VQYXRoIHBhcmFtZXRlciBpcyBkZXByZWNhdGVkLjwvc3Ryb25nPlxuXHQgKiBUaGlzIHBhcmFtZXRlciB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gUGxlYXNlIGVpdGhlciB1c2UgdGhlIGBiYXNlUGF0aGAgcGFyYW1ldGVyIGluIHRoZSBMb2FkUXVldWVcblx0ICogY29uc3RydWN0b3IsIG9yIGEgYHBhdGhgIHByb3BlcnR5IGluIGEgbWFuaWZlc3QgZGVmaW5pdGlvbi5cblx0ICovXG5cdHAubG9hZE1hbmlmZXN0ID0gZnVuY3Rpb24gKG1hbmlmZXN0LCBsb2FkTm93LCBiYXNlUGF0aCkge1xuXHRcdHZhciBmaWxlTGlzdCA9IG51bGw7XG5cdFx0dmFyIHBhdGggPSBudWxsO1xuXG5cdFx0Ly8gQXJyYXktYmFzZWQgbGlzdCBvZiBpdGVtc1xuXHRcdGlmIChtYW5pZmVzdCBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRpZiAobWFuaWZlc3QubGVuZ3RoID09IDApIHtcblx0XHRcdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJQUkVMT0FEX01BTklGRVNUX0VNUFRZXCIpO1xuXHRcdFx0XHR0aGlzLl9zZW5kRXJyb3IoZXZlbnQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRmaWxlTGlzdCA9IG1hbmlmZXN0O1xuXG5cdFx0XHQvLyBTdHJpbmctYmFzZWQuIE9ubHkgZmlsZSBtYW5pZmVzdHMgY2FuIGJlIHNwZWNpZmllZCB0aGlzIHdheS4gQW55IG90aGVyIHR5cGVzIHdpbGwgY2F1c2UgYW4gZXJyb3Igd2hlbiBsb2FkZWQuXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YobWFuaWZlc3QpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRmaWxlTGlzdCA9IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHNyYzogbWFuaWZlc3QsXG5cdFx0XHRcdFx0dHlwZTogcy5NQU5JRkVTVFxuXHRcdFx0XHR9XG5cdFx0XHRdO1xuXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YobWFuaWZlc3QpID09IFwib2JqZWN0XCIpIHtcblxuXHRcdFx0Ly8gQW4gb2JqZWN0IHRoYXQgZGVmaW5lcyBhIG1hbmlmZXN0IHBhdGhcblx0XHRcdGlmIChtYW5pZmVzdC5zcmMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAobWFuaWZlc3QudHlwZSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0bWFuaWZlc3QudHlwZSA9IHMuTUFOSUZFU1Q7XG5cdFx0XHRcdH0gZWxzZSBpZiAobWFuaWZlc3QudHlwZSAhPSBzLk1BTklGRVNUKSB7XG5cdFx0XHRcdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJQUkVMT0FEX01BTklGRVNUX1RZUEVcIik7XG5cdFx0XHRcdFx0dGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmaWxlTGlzdCA9IFttYW5pZmVzdF07XG5cblx0XHRcdFx0Ly8gQW4gb2JqZWN0IHRoYXQgZGVmaW5lcyBhIG1hbmlmZXN0XG5cdFx0XHR9IGVsc2UgaWYgKG1hbmlmZXN0Lm1hbmlmZXN0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZmlsZUxpc3QgPSBtYW5pZmVzdC5tYW5pZmVzdDtcblx0XHRcdFx0cGF0aCA9IG1hbmlmZXN0LnBhdGg7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVuc3VwcG9ydGVkLiBUaGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBldmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiUFJFTE9BRF9NQU5JRkVTVF9OVUxMXCIpO1xuXHRcdFx0dGhpcy5fc2VuZEVycm9yKGV2ZW50KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGZpbGVMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dGhpcy5fYWRkSXRlbShmaWxlTGlzdFtpXSwgcGF0aCwgYmFzZVBhdGgpO1xuXHRcdH1cblxuXHRcdGlmIChsb2FkTm93ICE9PSBmYWxzZSkge1xuXHRcdFx0dGhpcy5zZXRQYXVzZWQoZmFsc2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNldFBhdXNlZCh0cnVlKTtcblx0XHR9XG5cblx0fTtcblxuXHQvKipcblx0ICogU3RhcnQgYSBMb2FkUXVldWUgdGhhdCB3YXMgY3JlYXRlZCwgYnV0IG5vdCBhdXRvbWF0aWNhbGx5IHN0YXJ0ZWQuXG5cdCAqIEBtZXRob2QgbG9hZFxuXHQgKi9cblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuc2V0UGF1c2VkKGZhbHNlKTtcblx0fTtcblxuXHQvKipcblx0ICogTG9vayB1cCBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319IHVzaW5nIGVpdGhlciB0aGUgXCJpZFwiIG9yIFwic3JjXCIgdGhhdCB3YXMgc3BlY2lmaWVkIHdoZW4gbG9hZGluZyBpdC4gTm90ZSB0aGF0IGlmIG5vIFwiaWRcIiB3YXNcblx0ICogc3VwcGxpZWQgd2l0aCB0aGUgbG9hZCBpdGVtLCB0aGUgSUQgd2lsbCBiZSB0aGUgXCJzcmNcIiwgaW5jbHVkaW5nIGEgYHBhdGhgIHByb3BlcnR5IGRlZmluZWQgYnkgYSBtYW5pZmVzdC4gVGhlXG5cdCAqIGBiYXNlUGF0aGAgd2lsbCBub3QgYmUgcGFydCBvZiB0aGUgSUQuXG5cdCAqIEBtZXRob2QgZ2V0SXRlbVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIDxjb2RlPmlkPC9jb2RlPiBvciA8Y29kZT5zcmM8L2NvZGU+IG9mIHRoZSBsb2FkIGl0ZW0uXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGxvYWQgaXRlbSB0aGF0IHdhcyBpbml0aWFsbHkgcmVxdWVzdGVkIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBvciB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319LiBUaGlzIG9iamVjdCBpcyBhbHNvIHJldHVybmVkIHZpYSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IGFzIHRoZSBgaXRlbWAgcGFyYW1ldGVyLlxuXHQgKi9cblx0cC5nZXRJdGVtID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRJdGVtc0J5SWRbdmFsdWVdIHx8IHRoaXMuX2xvYWRJdGVtc0J5U3JjW3ZhbHVlXTtcblx0fTtcblxuXHQvKipcblx0ICogTG9vayB1cCBhIGxvYWRlZCByZXN1bHQgdXNpbmcgZWl0aGVyIHRoZSBcImlkXCIgb3IgXCJzcmNcIiB0aGF0IHdhcyBzcGVjaWZpZWQgd2hlbiBsb2FkaW5nIGl0LiBOb3RlIHRoYXQgaWYgbm8gXCJpZFwiXG5cdCAqIHdhcyBzdXBwbGllZCB3aXRoIHRoZSBsb2FkIGl0ZW0sIHRoZSBJRCB3aWxsIGJlIHRoZSBcInNyY1wiLCBpbmNsdWRpbmcgYSBgcGF0aGAgcHJvcGVydHkgZGVmaW5lZCBieSBhIG1hbmlmZXN0LiBUaGVcblx0ICogYGJhc2VQYXRoYCB3aWxsIG5vdCBiZSBwYXJ0IG9mIHRoZSBJRC5cblx0ICogQG1ldGhvZCBnZXRSZXN1bHRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSA8Y29kZT5pZDwvY29kZT4gb3IgPGNvZGU+c3JjPC9jb2RlPiBvZiB0aGUgbG9hZCBpdGVtLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyYXdSZXN1bHQ9ZmFsc2VdIFJldHVybiBhIHJhdyByZXN1bHQgaW5zdGVhZCBvZiBhIGZvcm1hdHRlZCByZXN1bHQuIFRoaXMgYXBwbGllcyB0byBjb250ZW50XG5cdCAqIGxvYWRlZCB2aWEgWEhSIHN1Y2ggYXMgc2NyaXB0cywgWE1MLCBDU1MsIGFuZCBJbWFnZXMuIElmIHRoZXJlIGlzIG5vIHJhdyByZXN1bHQsIHRoZSBmb3JtYXR0ZWQgcmVzdWx0IHdpbGwgYmVcblx0ICogcmV0dXJuZWQgaW5zdGVhZC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBBIHJlc3VsdCBvYmplY3QgY29udGFpbmluZyB0aGUgY29udGVudCB0aGF0IHdhcyBsb2FkZWQsIHN1Y2ggYXM6XG5cdCAqIDx1bD5cblx0ICogICAgICA8bGk+QW4gaW1hZ2UgdGFnICgmbHQ7aW1hZ2UgLyZndDspIGZvciBpbWFnZXM8L2xpPlxuXHQgKiAgICAgIDxsaT5BIHNjcmlwdCB0YWcgZm9yIEphdmFTY3JpcHQgKCZsdDtzY3JpcHQgLyZndDspLiBOb3RlIHRoYXQgc2NyaXB0cyBhcmUgYXV0b21hdGljYWxseSBhZGRlZCB0byB0aGUgSFRNTFxuXHQgKiAgICAgIERPTS48L2xpPlxuXHQgKiAgICAgIDxsaT5BIHN0eWxlIHRhZyBmb3IgQ1NTICgmbHQ7c3R5bGUgLyZndDsgb3IgJmx0O2xpbmsgJmd0Oyk8L2xpPlxuXHQgKiAgICAgIDxsaT5SYXcgdGV4dCBmb3IgVEVYVDwvbGk+XG5cdCAqICAgICAgPGxpPkEgZm9ybWF0dGVkIEphdmFTY3JpcHQgb2JqZWN0IGRlZmluZWQgYnkgSlNPTjwvbGk+XG5cdCAqICAgICAgPGxpPkFuIFhNTCBkb2N1bWVudDwvbGk+XG5cdCAqICAgICAgPGxpPkEgYmluYXJ5IGFycmF5YnVmZmVyIGxvYWRlZCBieSBYSFI8L2xpPlxuXHQgKiAgICAgIDxsaT5BbiBhdWRpbyB0YWcgKCZsdDthdWRpbyAmZ3Q7KSBmb3IgSFRNTCBhdWRpby4gTm90ZSB0aGF0IGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBTb3VuZEpTIEFQSXMgdG8gcGxheVxuXHQgKiAgICAgIGxvYWRlZCBhdWRpby4gU3BlY2lmaWNhbGx5LCBhdWRpbyBsb2FkZWQgYnkgRmxhc2ggYW5kIFdlYkF1ZGlvIHdpbGwgcmV0dXJuIGEgbG9hZGVyIG9iamVjdCB1c2luZyB0aGlzIG1ldGhvZFxuXHQgKiAgICAgIHdoaWNoIGNhbiBub3QgYmUgdXNlZCB0byBwbGF5IGF1ZGlvIGJhY2suPC9saT5cblx0ICogPC91bD5cblx0ICogVGhpcyBvYmplY3QgaXMgYWxzbyByZXR1cm5lZCB2aWEgdGhlIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9maWxlbG9hZDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBhcyB0aGUgJ2l0ZW1gXG5cdCAqIHBhcmFtZXRlci4gTm90ZSB0aGF0IGlmIGEgcmF3IHJlc3VsdCBpcyByZXF1ZXN0ZWQsIGJ1dCBub3QgZm91bmQsIHRoZSByZXN1bHQgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkLlxuXHQgKi9cblx0cC5nZXRSZXN1bHQgPSBmdW5jdGlvbiAodmFsdWUsIHJhd1Jlc3VsdCkge1xuXHRcdHZhciBpdGVtID0gdGhpcy5fbG9hZEl0ZW1zQnlJZFt2YWx1ZV0gfHwgdGhpcy5fbG9hZEl0ZW1zQnlTcmNbdmFsdWVdO1xuXHRcdGlmIChpdGVtID09IG51bGwpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHR2YXIgaWQgPSBpdGVtLmlkO1xuXHRcdGlmIChyYXdSZXN1bHQgJiYgdGhpcy5fbG9hZGVkUmF3UmVzdWx0c1tpZF0pIHtcblx0XHRcdHJldHVybiB0aGlzLl9sb2FkZWRSYXdSZXN1bHRzW2lkXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2xvYWRlZFJlc3VsdHNbaWRdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBhbiBsaXN0IG9mIGl0ZW1zIGxvYWRlZCBieSB0aGlzIHF1ZXVlLlxuXHQgKiBAbWV0aG9kIGdldEl0ZW1zXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gbG9hZGVkIERldGVybWluZXMgaWYgb25seSBpdGVtcyB0aGF0IGhhdmUgYmVlbiBsb2FkZWQgc2hvdWxkIGJlIHJldHVybmVkLiBJZiBmYWxzZSwgaW4tcHJvZ3Jlc3Ncblx0ICogYW5kIGZhaWxlZCBsb2FkIGl0ZW1zIHdpbGwgYWxzbyBiZSBpbmNsdWRlZC5cblx0ICogQHJldHVybnMge0FycmF5fSBBIGxpc3Qgb2Ygb2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBsb2FkZWQuIEVhY2ggaXRlbSBpbmNsdWRlcyB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIHJlc3VsdCwgYW5kIHJhd1Jlc3VsdC5cblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLmdldEl0ZW1zID0gZnVuY3Rpb24gKGxvYWRlZCkge1xuXHRcdHZhciBhcnIgPSBbXTtcblx0XHRmb3IgKHZhciBuIGluIHRoaXMuX2xvYWRJdGVtc0J5SWQpIHtcblx0XHRcdHZhciBpdGVtID0gdGhpcy5fbG9hZEl0ZW1zQnlJZFtuXTtcblx0XHRcdHZhciByZXN1bHQgPSB0aGlzLmdldFJlc3VsdChuKTtcblx0XHRcdGlmIChsb2FkZWQgPT09IHRydWUgJiYgcmVzdWx0ID09IG51bGwpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRhcnIucHVzaCh7XG5cdFx0XHRcdGl0ZW06IGl0ZW0sXG5cdFx0XHRcdHJlc3VsdDogcmVzdWx0LFxuXHRcdFx0XHRyYXdSZXN1bHQ6IHRoaXMuZ2V0UmVzdWx0KG4sIHRydWUpXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIGFycjtcblx0fTtcblxuXHQvKipcblx0ICogUGF1c2Ugb3IgcmVzdW1lIHRoZSBjdXJyZW50IGxvYWQuIEFjdGl2ZSBsb2FkcyB3aWxsIG5vdCBiZSBjYW5jZWxsZWQsIGJ1dCB0aGUgbmV4dCBpdGVtcyBpbiB0aGUgcXVldWUgd2lsbCBub3Rcblx0ICogYmUgcHJvY2Vzc2VkIHdoZW4gYWN0aXZlIGxvYWRzIGNvbXBsZXRlLiBMb2FkUXVldWVzIGFyZSBub3QgcGF1c2VkIGJ5IGRlZmF1bHQuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBpZiBuZXcgaXRlbXMgYXJlIGFkZGVkIHRvIHRoZSBxdWV1ZSB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZEZpbGVcIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2xvYWRNYW5pZmVzdFwifX17ey9jcm9zc0xpbmt9fSwgYSBwYXVzZWQgcXVldWUgd2lsbCBiZSByZXN1bWVkLCB1bmxlc3MgdGhlIGBsb2FkTm93YFxuXHQgKiBhcmd1bWVudCBpcyBgZmFsc2VgLlxuXHQgKiBAbWV0aG9kIHNldFBhdXNlZFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIFdoZXRoZXIgdGhlIHF1ZXVlIHNob3VsZCBiZSBwYXVzZWQgb3Igbm90LlxuXHQgKi9cblx0cC5zZXRQYXVzZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR0aGlzLl9wYXVzZWQgPSB2YWx1ZTtcblx0XHRpZiAoIXRoaXMuX3BhdXNlZCkge1xuXHRcdFx0dGhpcy5fbG9hZE5leHQoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENsb3NlIHRoZSBhY3RpdmUgcXVldWUuIENsb3NpbmcgYSBxdWV1ZSBjb21wbGV0ZWx5IGVtcHRpZXMgdGhlIHF1ZXVlLCBhbmQgcHJldmVudHMgYW55IHJlbWFpbmluZyBpdGVtcyBmcm9tXG5cdCAqIHN0YXJ0aW5nIHRvIGRvd25sb2FkLiBOb3RlIHRoYXQgY3VycmVudGx5IGFueSBhY3RpdmUgbG9hZHMgd2lsbCByZW1haW4gb3BlbiwgYW5kIGV2ZW50cyBtYXkgYmUgcHJvY2Vzc2VkLlxuXHQgKlxuXHQgKiBUbyBzdG9wIGFuZCByZXN0YXJ0IGEgcXVldWUsIHVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL3NldFBhdXNlZFwifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBjbG9zZVxuXHQgKi9cblx0cC5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR3aGlsZSAodGhpcy5fY3VycmVudExvYWRzLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5fY3VycmVudExvYWRzLnBvcCgpLmNhbmNlbCgpO1xuXHRcdH1cblx0XHR0aGlzLl9zY3JpcHRPcmRlci5sZW5ndGggPSAwO1xuXHRcdHRoaXMuX2xvYWRlZFNjcmlwdHMubGVuZ3RoID0gMDtcblx0XHR0aGlzLmxvYWRTdGFydFdhc0Rpc3BhdGNoZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9pdGVtQ291bnQgPSAwO1xuXHRcdHRoaXMuX2xhc3RQcm9ncmVzcyA9IE5hTjtcblx0fTtcblxuLy8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIEFkZCBhbiBpdGVtIHRvIHRoZSBxdWV1ZS4gSXRlbXMgYXJlIGZvcm1hdHRlZCBpbnRvIGEgdXNhYmxlIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgcHJvcGVydGllcyBuZWNlc3NhcnkgdG9cblx0ICogbG9hZCB0aGUgY29udGVudC4gVGhlIGxvYWQgcXVldWUgaXMgcG9wdWxhdGVkIHdpdGggdGhlIGxvYWRlciBpbnN0YW5jZSB0aGF0IGhhbmRsZXMgcHJlbG9hZGluZywgYW5kIG5vdCB0aGUgbG9hZFxuXHQgKiBpdGVtIHRoYXQgd2FzIHBhc3NlZCBpbiBieSB0aGUgdXNlci4gVG8gbG9vayB1cCB0aGUgbG9hZCBpdGVtIGJ5IGlkIG9yIHNyYywgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUuZ2V0SXRlbVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QuXG5cdCAqIEBtZXRob2QgX2FkZEl0ZW1cblx0ICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB2YWx1ZSBUaGUgaXRlbSB0byBhZGQgdG8gdGhlIHF1ZXVlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdIEFuIG9wdGlvbmFsIHBhdGggcHJlcGVuZGVkIHRvIHRoZSBgc3JjYC4gVGhlIHBhdGggd2lsbCBvbmx5IGJlIHByZXBlbmRlZCBpZiB0aGUgc3JjIGlzXG5cdCAqIHJlbGF0aXZlLCBhbmQgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIHByb3RvY29sIHN1Y2ggYXMgYGh0dHA6Ly9gLCBvciBhIHBhdGggbGlrZSBgLi4vYC4gSWYgdGhlIExvYWRRdWV1ZSB3YXNcblx0ICogcHJvdmlkZWQgYSB7eyNjcm9zc0xpbmsgXCJfYmFzZVBhdGhcIn19e3svY3Jvc3NMaW5rfX0sIHRoZW4gaXQgd2lsbCBvcHRpb25hbGx5IGJlIHByZXBlbmRlZCBhZnRlci5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtiYXNlUGF0aF0gPHN0cm9uZz5EZXByZWNhdGVkPC9zdHJvbmc+QW4gb3B0aW9uYWwgYmFzZVBhdGggcGFzc2VkIGludG8gYSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvbG9hZE1hbmlmZXN0XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIG9yIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9sb2FkRmlsZVwifX17ey9jcm9zc0xpbmt9fSBjYWxsLiBUaGlzIHBhcmFtZXRlciB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdGFnZ2VkXG5cdCAqIHZlcnNpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9hZGRJdGVtID0gZnVuY3Rpb24gKHZhbHVlLCBwYXRoLCBiYXNlUGF0aCkge1xuXHRcdHZhciBpdGVtID0gdGhpcy5fY3JlYXRlTG9hZEl0ZW0odmFsdWUsIHBhdGgsIGJhc2VQYXRoKTsgLy8gYmFzZVBhdGggYW5kIG1hbmlmZXN0IHBhdGggYXJlIGFkZGVkIHRvIHRoZSBzcmMuXG5cdFx0aWYgKGl0ZW0gPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH0gLy8gU29tZXRpbWVzIHBsdWdpbnMgb3IgdHlwZXMgc2hvdWxkIGJlIHNraXBwZWQuXG5cdFx0dmFyIGxvYWRlciA9IHRoaXMuX2NyZWF0ZUxvYWRlcihpdGVtKTtcblx0XHRpZiAobG9hZGVyICE9IG51bGwpIHtcblx0XHRcdGlmIChcInBsdWdpbnNcIiBpbiBsb2FkZXIpIHtcblx0XHRcdFx0bG9hZGVyLnBsdWdpbnMgPSB0aGlzLl9wbHVnaW5zO1xuXHRcdFx0fVxuXHRcdFx0aXRlbS5fbG9hZGVyID0gbG9hZGVyO1xuXHRcdFx0dGhpcy5fbG9hZFF1ZXVlLnB1c2gobG9hZGVyKTtcblx0XHRcdHRoaXMuX2xvYWRRdWV1ZUJhY2t1cC5wdXNoKGxvYWRlcik7XG5cblx0XHRcdHRoaXMuX251bUl0ZW1zKys7XG5cdFx0XHR0aGlzLl91cGRhdGVQcm9ncmVzcygpO1xuXG5cdFx0XHQvLyBPbmx5IHdvcnJ5IGFib3V0IHNjcmlwdCBvcmRlciB3aGVuIHVzaW5nIFhIUiB0byBsb2FkIHNjcmlwdHMuIFRhZ3MgYXJlIG9ubHkgbG9hZGluZyBvbmUgYXQgYSB0aW1lLlxuXHRcdFx0aWYgKCh0aGlzLm1haW50YWluU2NyaXB0T3JkZXJcblx0XHRcdFx0XHQmJiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuTG9hZFF1ZXVlLkpBVkFTQ1JJUFRcblx0XHRcdFx0XHRcdC8vJiYgbG9hZGVyIGluc3RhbmNlb2YgY3JlYXRlanMuWEhSTG9hZGVyIC8vTk9URTogSGF2ZSB0byB0cmFjayBhbGwgSlMgZmlsZXMgdGhpcyB3YXlcblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0fHwgaXRlbS5tYWludGFpbk9yZGVyID09PSB0cnVlKSB7XG5cdFx0XHRcdHRoaXMuX3NjcmlwdE9yZGVyLnB1c2goaXRlbSk7XG5cdFx0XHRcdHRoaXMuX2xvYWRlZFNjcmlwdHMucHVzaChudWxsKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIHJlZmluZWQge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0sIHdoaWNoIGNvbnRhaW5zIGFsbCB0aGUgcmVxdWlyZWQgcHJvcGVydGllcy4gVGhlIHR5cGUgb2Zcblx0ICogaXRlbSBpcyBkZXRlcm1pbmVkIGJ5IGJyb3dzZXIgc3VwcG9ydCwgcmVxdWlyZW1lbnRzIGJhc2VkIG9uIHRoZSBmaWxlIHR5cGUsIGFuZCBkZXZlbG9wZXIgc2V0dGluZ3MuIEZvciBleGFtcGxlLFxuXHQgKiBYSFIgaXMgb25seSB1c2VkIGZvciBmaWxlIHR5cGVzIHRoYXQgc3VwcG9ydCBpdCBpbiBuZXcgYnJvd3NlcnMuXG5cdCAqXG5cdCAqIEJlZm9yZSB0aGUgaXRlbSBpcyByZXR1cm5lZCwgYW55IHBsdWdpbnMgcmVnaXN0ZXJlZCB0byBoYW5kbGUgdGhlIHR5cGUgb3IgZXh0ZW5zaW9uIHdpbGwgYmUgZmlyZWQsIHdoaWNoIG1heVxuXHQgKiBhbHRlciB0aGUgbG9hZCBpdGVtLlxuXHQgKiBAbWV0aG9kIF9jcmVhdGVMb2FkSXRlbVxuXHQgKiBAcGFyYW0ge1N0cmluZyB8IE9iamVjdCB8IEhUTUxBdWRpb0VsZW1lbnQgfCBIVE1MSW1hZ2VFbGVtZW50fSB2YWx1ZSBUaGUgaXRlbSB0aGF0IG5lZWRzIHRvIGJlIHByZWxvYWRlZC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXSBBIHBhdGggdG8gcHJlcGVuZCB0byB0aGUgaXRlbSdzIHNvdXJjZS4gU291cmNlcyBiZWdpbm5pbmcgd2l0aCBodHRwOi8vIG9yIHNpbWlsYXIgd2lsbFxuXHQgKiBub3QgcmVjZWl2ZSBhIHBhdGguIFNpbmNlIFByZWxvYWRKUyAwLjQuMSwgdGhlIHNyYyB3aWxsIGJlIG1vZGlmaWVkIHRvIGluY2x1ZGUgdGhlIGBwYXRoYCBhbmQge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL19iYXNlUGF0aDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB3aGVuIGl0IGlzIGFkZGVkLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW2Jhc2VQYXRoXSA8c3Ryb25nPkRlcHJlY3RhdGVkPC9zdHJvbmc+IEEgYmFzZSBwYXRoIHRvIHByZXBlbmQgdG8gdGhlIGl0ZW1zIHNvdXJjZSBpbiBhZGRpdGlvbiB0b1xuXHQgKiB0aGUgcGF0aCBhcmd1bWVudC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgbG9hZGVyIGluc3RhbmNlIHRoYXQgd2lsbCBiZSB1c2VkLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY3JlYXRlTG9hZEl0ZW0gPSBmdW5jdGlvbiAodmFsdWUsIHBhdGgsIGJhc2VQYXRoKSB7XG5cdFx0dmFyIGl0ZW0gPSBjcmVhdGVqcy5Mb2FkSXRlbS5jcmVhdGUodmFsdWUpO1xuXHRcdGlmIChpdGVtID09IG51bGwpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciBicCA9IFwiXCI7IC8vIFN0b3JlIHRoZSBnZW5lcmF0ZWQgYmFzZVBhdGhcblx0XHR2YXIgdXNlQmFzZVBhdGggPSBiYXNlUGF0aCB8fCB0aGlzLl9iYXNlUGF0aDtcblxuXHRcdGlmIChpdGVtLnNyYyBpbnN0YW5jZW9mIE9iamVjdCkge1xuXHRcdFx0aWYgKCFpdGVtLnR5cGUpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9IC8vIHRoZSB0aGUgc3JjIGlzIGFuIG9iamVjdCwgdHlwZSBpcyByZXF1aXJlZCB0byBwYXNzIG9mZiB0byBwbHVnaW5cblx0XHRcdGlmIChwYXRoKSB7XG5cdFx0XHRcdGJwID0gcGF0aDtcblx0XHRcdFx0dmFyIHBhdGhNYXRjaCA9IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5wYXJzZVVSSShwYXRoKTtcblx0XHRcdFx0Ly8gQWxzbyBhcHBlbmQgYmFzZVBhdGhcblx0XHRcdFx0aWYgKHVzZUJhc2VQYXRoICE9IG51bGwgJiYgIXBhdGhNYXRjaC5hYnNvbHV0ZSAmJiAhcGF0aE1hdGNoLnJlbGF0aXZlKSB7XG5cdFx0XHRcdFx0YnAgPSB1c2VCYXNlUGF0aCArIGJwO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHVzZUJhc2VQYXRoICE9IG51bGwpIHtcblx0XHRcdFx0YnAgPSB1c2VCYXNlUGF0aDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRGV0ZXJtaW5lIEV4dGVuc2lvbiwgZXRjLlxuXHRcdFx0dmFyIG1hdGNoID0gY3JlYXRlanMuUmVxdWVzdFV0aWxzLnBhcnNlVVJJKGl0ZW0uc3JjKTtcblx0XHRcdGlmIChtYXRjaC5leHRlbnNpb24pIHtcblx0XHRcdFx0aXRlbS5leHQgPSBtYXRjaC5leHRlbnNpb247XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXRlbS50eXBlID09IG51bGwpIHtcblx0XHRcdFx0aXRlbS50eXBlID0gY3JlYXRlanMuUmVxdWVzdFV0aWxzLmdldFR5cGVCeUV4dGVuc2lvbihpdGVtLmV4dCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluamVjdCBwYXRoICYgYmFzZVBhdGhcblx0XHRcdHZhciBhdXRvSWQgPSBpdGVtLnNyYztcblx0XHRcdGlmICghbWF0Y2guYWJzb2x1dGUgJiYgIW1hdGNoLnJlbGF0aXZlKSB7XG5cdFx0XHRcdGlmIChwYXRoKSB7XG5cdFx0XHRcdFx0YnAgPSBwYXRoO1xuXHRcdFx0XHRcdHZhciBwYXRoTWF0Y2ggPSBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMucGFyc2VVUkkocGF0aCk7XG5cdFx0XHRcdFx0YXV0b0lkID0gcGF0aCArIGF1dG9JZDtcblx0XHRcdFx0XHQvLyBBbHNvIGFwcGVuZCBiYXNlUGF0aFxuXHRcdFx0XHRcdGlmICh1c2VCYXNlUGF0aCAhPSBudWxsICYmICFwYXRoTWF0Y2guYWJzb2x1dGUgJiYgIXBhdGhNYXRjaC5yZWxhdGl2ZSkge1xuXHRcdFx0XHRcdFx0YnAgPSB1c2VCYXNlUGF0aCArIGJwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh1c2VCYXNlUGF0aCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0YnAgPSB1c2VCYXNlUGF0aDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aXRlbS5zcmMgPSBicCArIGl0ZW0uc3JjO1xuXHRcdH1cblx0XHRpdGVtLnBhdGggPSBicDtcblxuXHRcdC8vIElmIHRoZXJlJ3Mgbm8gaWQsIHNldCBvbmUgbm93LlxuXHRcdGlmIChpdGVtLmlkID09PSB1bmRlZmluZWQgfHwgaXRlbS5pZCA9PT0gbnVsbCB8fCBpdGVtLmlkID09PSBcIlwiKSB7XG5cdFx0XHRpdGVtLmlkID0gYXV0b0lkO1xuXHRcdH1cblxuXHRcdC8vIEdpdmUgcGx1Z2lucyBhIGNoYW5jZSB0byBtb2RpZnkgdGhlIGxvYWRJdGVtOlxuXHRcdHZhciBjdXN0b21IYW5kbGVyID0gdGhpcy5fdHlwZUNhbGxiYWNrc1tpdGVtLnR5cGVdIHx8IHRoaXMuX2V4dGVuc2lvbkNhbGxiYWNrc1tpdGVtLmV4dF07XG5cdFx0aWYgKGN1c3RvbUhhbmRsZXIpIHtcblx0XHRcdC8vIFBsdWdpbnMgYXJlIG5vdyBwYXNzZWQgYm90aCB0aGUgZnVsbCBzb3VyY2UsIGFzIHdlbGwgYXMgYSBjb21iaW5lZCBwYXRoK2Jhc2VQYXRoIChhcHByb3ByaWF0ZWx5KVxuXHRcdFx0dmFyIHJlc3VsdCA9IGN1c3RvbUhhbmRsZXIuY2FsbGJhY2suY2FsbChjdXN0b21IYW5kbGVyLnNjb3BlLCBpdGVtLCB0aGlzKTtcblxuXHRcdFx0Ly8gVGhlIHBsdWdpbiB3aWxsIGhhbmRsZSB0aGUgbG9hZCwgb3IgaGFzIGNhbmNlbGVkIGl0LiBJZ25vcmUgaXQuXG5cdFx0XHRpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0XHQvLyBMb2FkIGFzIG5vcm1hbDpcblx0XHRcdH0gZWxzZSBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG5cdFx0XHRcdC8vIERvIE5vdGhpbmdcblxuXHRcdFx0XHQvLyBSZXN1bHQgaXMgYSBsb2FkZXIgY2xhc3M6XG5cdFx0XHR9IGVsc2UgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG5cdFx0XHRcdGl0ZW0uX2xvYWRlciA9IHJlc3VsdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXBkYXRlIHRoZSBleHRlbnNpb24gaW4gY2FzZSB0aGUgdHlwZSBjaGFuZ2VkOlxuXHRcdFx0bWF0Y2ggPSBjcmVhdGVqcy5SZXF1ZXN0VXRpbHMucGFyc2VVUkkoaXRlbS5zcmMpO1xuXHRcdFx0aWYgKG1hdGNoLmV4dGVuc2lvbiAhPSBudWxsKSB7XG5cdFx0XHRcdGl0ZW0uZXh0ID0gbWF0Y2guZXh0ZW5zaW9uO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFN0b3JlIHRoZSBpdGVtIGZvciBsb29rdXAuIFRoaXMgYWxzbyBoZWxwcyBjbGVhbi11cCBsYXRlci5cblx0XHR0aGlzLl9sb2FkSXRlbXNCeUlkW2l0ZW0uaWRdID0gaXRlbTtcblx0XHR0aGlzLl9sb2FkSXRlbXNCeVNyY1tpdGVtLnNyY10gPSBpdGVtO1xuXG5cdFx0aWYgKGl0ZW0uY3Jvc3NPcmlnaW4gPT0gbnVsbCkge1xuXHRcdFx0aXRlbS5jcm9zc09yaWdpbiA9IHRoaXMuX2Nyb3NzT3JpZ2luO1xuXHRcdH1cblxuXHRcdHJldHVybiBpdGVtO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBsb2FkZXIgZm9yIGEgbG9hZCBpdGVtLlxuXHQgKiBAbWV0aG9kIF9jcmVhdGVMb2FkZXJcblx0ICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gQSBmb3JtYXR0ZWQgbG9hZCBpdGVtIHRoYXQgY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgYSBsb2FkZXIuXG5cdCAqIEByZXR1cm4ge0Fic3RyYWN0TG9hZGVyfSBBIGxvYWRlciB0aGF0IGNhbiBiZSB1c2VkIHRvIGxvYWQgY29udGVudC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2NyZWF0ZUxvYWRlciA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0aWYgKGl0ZW0uX2xvYWRlciAhPSBudWxsKSB7IC8vIEEgcGx1Z2luIGFscmVhZHkgc3BlY2lmaWVkIGEgbG9hZGVyXG5cdFx0XHRyZXR1cm4gaXRlbS5fbG9hZGVyO1xuXHRcdH1cblxuXHRcdC8vIEluaXRpYWxseSwgdHJ5IGFuZCB1c2UgdGhlIHByb3ZpZGVkL3N1cHBvcnRlZCBYSFIgbW9kZTpcblx0XHR2YXIgcHJlZmVyWEhSID0gdGhpcy5wcmVmZXJYSFI7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2F2YWlsYWJsZUxvYWRlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBsb2FkZXIgPSB0aGlzLl9hdmFpbGFibGVMb2FkZXJzW2ldO1xuXHRcdFx0aWYgKGxvYWRlciAmJiBsb2FkZXIuY2FuTG9hZEl0ZW0oaXRlbSkpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBsb2FkZXIoaXRlbSwgcHJlZmVyWEhSKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBUT0RPOiBMb2cgZXJyb3IgKHJlcXVpcmVzIGNyZWF0ZWpzLmxvZylcblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogTG9hZCB0aGUgbmV4dCBpdGVtIGluIHRoZSBxdWV1ZS4gSWYgdGhlIHF1ZXVlIGlzIGVtcHR5IChhbGwgaXRlbXMgaGF2ZSBiZWVuIGxvYWRlZCksIHRoZW4gdGhlIGNvbXBsZXRlIGV2ZW50XG5cdCAqIGlzIHByb2Nlc3NlZC4gVGhlIHF1ZXVlIHdpbGwgXCJmaWxsIHVwXCIgYW55IGVtcHR5IHNsb3RzLCB1cCB0byB0aGUgbWF4IGNvbm5lY3Rpb24gc3BlY2lmaWVkIHVzaW5nXG5cdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS5zZXRNYXhDb25uZWN0aW9uc1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2QuIFRoZSBvbmx5IGV4Y2VwdGlvbiBpcyBzY3JpcHRzIHRoYXQgYXJlIGxvYWRlZFxuXHQgKiB1c2luZyB0YWdzLCB3aGljaCBoYXZlIHRvIGJlIGxvYWRlZCBvbmUgYXQgYSB0aW1lIHRvIG1haW50YWluIGxvYWQgb3JkZXIuXG5cdCAqIEBtZXRob2QgX2xvYWROZXh0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9sb2FkTmV4dCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcGF1c2VkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25seSBkaXNwYXRjaCBsb2Fkc3RhcnQgZXZlbnQgd2hlbiB0aGUgZmlyc3QgZmlsZSBpcyBsb2FkZWQuXG5cdFx0aWYgKCF0aGlzLl9sb2FkU3RhcnRXYXNEaXNwYXRjaGVkKSB7XG5cdFx0XHR0aGlzLl9zZW5kTG9hZFN0YXJ0KCk7XG5cdFx0XHR0aGlzLl9sb2FkU3RhcnRXYXNEaXNwYXRjaGVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBUaGUgcXVldWUgaGFzIGNvbXBsZXRlZC5cblx0XHRpZiAodGhpcy5fbnVtSXRlbXMgPT0gdGhpcy5fbnVtSXRlbXNMb2FkZWQpIHtcblx0XHRcdHRoaXMubG9hZGVkID0gdHJ1ZTtcblx0XHRcdHRoaXMuX3NlbmRDb21wbGV0ZSgpO1xuXG5cdFx0XHQvLyBMb2FkIHRoZSBuZXh0IHF1ZXVlLCBpZiBpdCBoYXMgYmVlbiBkZWZpbmVkLlxuXHRcdFx0aWYgKHRoaXMubmV4dCAmJiB0aGlzLm5leHQubG9hZCkge1xuXHRcdFx0XHR0aGlzLm5leHQubG9hZCgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmxvYWRlZCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIE11c3QgaXRlcmF0ZSBmb3J3YXJkcyB0byBsb2FkIGluIHRoZSByaWdodCBvcmRlci5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xvYWRRdWV1ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuX2N1cnJlbnRMb2Fkcy5sZW5ndGggPj0gdGhpcy5fbWF4Q29ubmVjdGlvbnMpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbG9hZGVyID0gdGhpcy5fbG9hZFF1ZXVlW2ldO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIGJlIG9ubHkgbG9hZGluZyBvbmUgdGFnLXNjcmlwdCBhdCBhIHRpbWU6XG5cdFx0XHQvLyBOb3RlOiBtYWludGFpbk9yZGVyIGl0ZW1zIGRvbid0IGRvIGFueXRoaW5nIGhlcmUgYmVjYXVzZSB3ZSBjYW4gaG9sZCBvbnRvIHRoZWlyIGxvYWRlZCB2YWx1ZVxuXHRcdFx0aWYgKCF0aGlzLl9jYW5TdGFydExvYWQobG9hZGVyKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2xvYWRRdWV1ZS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRpLS07XG5cdFx0XHR0aGlzLl9sb2FkSXRlbShsb2FkZXIpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQmVnaW4gbG9hZGluZyBhbiBpdGVtLiBFdmVudCBsaXN0ZW5lcnMgYXJlIG5vdCBhZGRlZCB0byB0aGUgbG9hZGVycyB1bnRpbCB0aGUgbG9hZCBzdGFydHMuXG5cdCAqIEBtZXRob2QgX2xvYWRJdGVtXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlciBUaGUgbG9hZGVyIGluc3RhbmNlIHRvIHN0YXJ0LiBDdXJyZW50bHksIHRoaXMgd2lsbCBiZSBhbiBYSFJMb2FkZXIgb3IgVGFnTG9hZGVyLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fbG9hZEl0ZW0gPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0bG9hZGVyLm9uKFwiZmlsZWxvYWRcIiwgdGhpcy5faGFuZGxlRmlsZUxvYWQsIHRoaXMpO1xuXHRcdGxvYWRlci5vbihcInByb2dyZXNzXCIsIHRoaXMuX2hhbmRsZVByb2dyZXNzLCB0aGlzKTtcblx0XHRsb2FkZXIub24oXCJjb21wbGV0ZVwiLCB0aGlzLl9oYW5kbGVGaWxlQ29tcGxldGUsIHRoaXMpO1xuXHRcdGxvYWRlci5vbihcImVycm9yXCIsIHRoaXMuX2hhbmRsZUVycm9yLCB0aGlzKTtcblx0XHRsb2FkZXIub24oXCJmaWxlZXJyb3JcIiwgdGhpcy5faGFuZGxlRmlsZUVycm9yLCB0aGlzKTtcblx0XHR0aGlzLl9jdXJyZW50TG9hZHMucHVzaChsb2FkZXIpO1xuXHRcdHRoaXMuX3NlbmRGaWxlU3RhcnQobG9hZGVyLmdldEl0ZW0oKSk7XG5cdFx0bG9hZGVyLmxvYWQoKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIGNhbGxiYWNrIHRoYXQgaXMgZmlyZWQgd2hlbiBhIGxvYWRlciBsb2FkcyBhIGZpbGUuIFRoaXMgZW5hYmxlcyBsb2FkZXJzIGxpa2Uge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogdG8gbWFpbnRhaW4gaW50ZXJuYWwgcXVldWVzLCBidXQgZm9yIHRoaXMgcXVldWUgdG8gZGlzcGF0Y2ggdGhlIHt7I2Nyb3NzTGluayBcImZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50cy5cblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2ZpbGVsb2FkOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IGZyb20gdGhlIGxvYWRlci5cblx0ICogQHByaXZhdGVcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl9oYW5kbGVGaWxlTG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LnRhcmdldCA9IG51bGw7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIGNhbGxiYWNrIHRoYXQgaXMgZmlyZWQgd2hlbiBhIGxvYWRlciBlbmNvdW50ZXJzIGFuIGVycm9yIGZyb20gYW4gaW50ZXJuYWwgZmlsZSBsb2FkIG9wZXJhdGlvbi4gVGhpcyBlbmFibGVzXG5cdCAqIGxvYWRlcnMgbGlrZSBNXG5cdCAqIEBwYXJhbSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlRmlsZUVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIG5ld0V2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJGSUxFX0xPQURfRVJST1JcIiwgbnVsbCwgZXZlbnQuaXRlbSk7XG5cdFx0dGhpcy5fc2VuZEVycm9yKG5ld0V2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIGNhbGxiYWNrIHRoYXQgaXMgZmlyZWQgd2hlbiBhIGxvYWRlciBlbmNvdW50ZXJzIGFuIGVycm9yLiBUaGUgcXVldWUgd2lsbCBjb250aW51ZSBsb2FkaW5nIHVubGVzcyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc3RvcE9uRXJyb3I6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaXMgc2V0IHRvIGB0cnVlYC5cblx0ICogQG1ldGhvZCBfaGFuZGxlRXJyb3Jcblx0ICogQHBhcmFtIHtFcnJvckV2ZW50fSBldmVudCBUaGUgZXJyb3IgZXZlbnQsIGNvbnRhaW5pbmcgcmVsZXZhbnQgZXJyb3IgaW5mb3JtYXRpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBsb2FkZXIgPSBldmVudC50YXJnZXQ7XG5cdFx0dGhpcy5fbnVtSXRlbXNMb2FkZWQrKztcblxuXHRcdHRoaXMuX2ZpbmlzaE9yZGVyZWRJdGVtKGxvYWRlciwgdHJ1ZSk7XG5cdFx0dGhpcy5fdXBkYXRlUHJvZ3Jlc3MoKTtcblxuXHRcdHZhciBuZXdFdmVudCA9IG5ldyBjcmVhdGVqcy5FcnJvckV2ZW50KFwiRklMRV9MT0FEX0VSUk9SXCIsIG51bGwsIGxvYWRlci5nZXRJdGVtKCkpO1xuXHRcdC8vIFRPRE86IFByb3BhZ2F0ZSBhY3R1YWwgZXJyb3IgbWVzc2FnZS5cblxuXHRcdHRoaXMuX3NlbmRFcnJvcihuZXdFdmVudCk7XG5cblx0XHRpZiAoIXRoaXMuc3RvcE9uRXJyb3IpIHtcblx0XHRcdHRoaXMuX3JlbW92ZUxvYWRJdGVtKGxvYWRlcik7XG5cdFx0XHR0aGlzLl9jbGVhbkxvYWRJdGVtKGxvYWRlcik7XG5cdFx0XHR0aGlzLl9sb2FkTmV4dCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNldFBhdXNlZCh0cnVlKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEFuIGl0ZW0gaGFzIGZpbmlzaGVkIGxvYWRpbmcuIFdlIGNhbiBhc3N1bWUgdGhhdCBpdCBpcyB0b3RhbGx5IGxvYWRlZCwgaGFzIGJlZW4gcGFyc2VkIGZvciBpbW1lZGlhdGUgdXNlLCBhbmRcblx0ICogaXMgYXZhaWxhYmxlIGFzIHRoZSBcInJlc3VsdFwiIHByb3BlcnR5IG9uIHRoZSBsb2FkIGl0ZW0uIFRoZSByYXcgdGV4dCByZXN1bHQgZm9yIGEgcGFyc2VkIGl0ZW0gKHN1Y2ggYXMgSlNPTiwgWE1MLFxuXHQgKiBDU1MsIEphdmFTY3JpcHQsIGV0YykgaXMgYXZhaWxhYmxlIGFzIHRoZSBcInJhd1Jlc3VsdFwiIHByb3BlcnR5LCBhbmQgY2FuIGFsc28gYmUgbG9va2VkIHVwIHVzaW5nIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZS9nZXRSZXN1bHRcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgX2hhbmRsZUZpbGVDb21wbGV0ZVxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgb2JqZWN0IGZyb20gdGhlIGxvYWRlci5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZUZpbGVDb21wbGV0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBsb2FkZXIgPSBldmVudC50YXJnZXQ7XG5cdFx0dmFyIGl0ZW0gPSBsb2FkZXIuZ2V0SXRlbSgpO1xuXG5cdFx0dmFyIHJlc3VsdCA9IGxvYWRlci5nZXRSZXN1bHQoKTtcblx0XHR0aGlzLl9sb2FkZWRSZXN1bHRzW2l0ZW0uaWRdID0gcmVzdWx0O1xuXHRcdHZhciByYXdSZXN1bHQgPSBsb2FkZXIuZ2V0UmVzdWx0KHRydWUpO1xuXHRcdGlmIChyYXdSZXN1bHQgIT0gbnVsbCAmJiByYXdSZXN1bHQgIT09IHJlc3VsdCkge1xuXHRcdFx0dGhpcy5fbG9hZGVkUmF3UmVzdWx0c1tpdGVtLmlkXSA9IHJhd1Jlc3VsdDtcblx0XHR9XG5cblx0XHR0aGlzLl9zYXZlTG9hZGVkSXRlbXMobG9hZGVyKTtcblxuXHRcdC8vIFJlbW92ZSB0aGUgbG9hZCBpdGVtXG5cdFx0dGhpcy5fcmVtb3ZlTG9hZEl0ZW0obG9hZGVyKTtcblxuXHRcdGlmICghdGhpcy5fZmluaXNoT3JkZXJlZEl0ZW0obG9hZGVyKSkge1xuXHRcdFx0Ly8gVGhlIGl0ZW0gd2FzIE5PVCBtYW5hZ2VkLCBzbyBwcm9jZXNzIGl0IG5vd1xuXHRcdFx0dGhpcy5fcHJvY2Vzc0ZpbmlzaGVkTG9hZChpdGVtLCBsb2FkZXIpO1xuXHRcdH1cblxuXHRcdC8vIENsZWFuIHVwIHRoZSBsb2FkIGl0ZW1cblx0XHR0aGlzLl9jbGVhbkxvYWRJdGVtKGxvYWRlcik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNvbWUgbG9hZGVycyBtaWdodCBsb2FkIGFkZGl0aW9uYWwgY29udGVudCwgb3RoZXIgdGhhbiB0aGUgaXRlbSB0aGV5IHdlcmUgcGFzc2VkIChzdWNoIGFzIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319KS5cblx0ICogQW55IGl0ZW1zIGV4cG9zZWQgYnkgdGhlIGxvYWRlciB1c2luZyB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9nZXRMb2FkSXRlbXNcIn19e3svY3Jvc3NMaW5rfX0gYXJlIGFkZGVkIHRvIHRoZVxuXHQgKiBMb2FkUXVldWUncyBsb29rLXVwcywgaW5jbHVkaW5nIHt7I2Nyb3NzTGluayBcImdldEl0ZW1cIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcImdldFJlc3VsdFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2RzLlxuXHQgKiBAbWV0aG9kIF9zYXZlTG9hZGVkSXRlbXNcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDAuNi4wXG5cdCAqL1xuXHRwLl9zYXZlTG9hZGVkSXRlbXMgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0Ly8gVE9ETzogTm90IHN1cmUgaG93IHRvIGhhbmRsZSB0aGlzLiBXb3VsZCBiZSBuaWNlIHRvIGV4cG9zZSB0aGUgaXRlbXMuXG5cdFx0Ly8gTG9hZGVycyBtYXkgbG9hZCBzdWItaXRlbXMuIFRoaXMgYWRkcyB0aGVtIHRvIHRoaXMgcXVldWVcblx0XHR2YXIgbGlzdCA9IGxvYWRlci5nZXRMb2FkZWRJdGVtcygpO1xuXHRcdGlmIChsaXN0ID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IGxpc3RbaV0uaXRlbTtcblxuXHRcdFx0Ly8gU3RvcmUgaXRlbSBsb29rdXBzXG5cdFx0XHR0aGlzLl9sb2FkSXRlbXNCeVNyY1tpdGVtLnNyY10gPSBpdGVtO1xuXHRcdFx0dGhpcy5fbG9hZEl0ZW1zQnlJZFtpdGVtLmlkXSA9IGl0ZW07XG5cblx0XHRcdC8vIFN0b3JlIGxvYWRlZCBjb250ZW50XG5cdFx0XHR0aGlzLl9sb2FkZWRSZXN1bHRzW2l0ZW0uaWRdID0gbGlzdFtpXS5yZXN1bHQ7XG5cdFx0XHR0aGlzLl9sb2FkZWRSYXdSZXN1bHRzW2l0ZW0uaWRdID0gbGlzdFtpXS5yYXdSZXN1bHQ7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBGbGFnIGFuIGl0ZW0gYXMgZmluaXNoZWQuIElmIHRoZSBpdGVtJ3Mgb3JkZXIgaXMgYmVpbmcgbWFuYWdlZCwgdGhlbiBlbnN1cmUgdGhhdCBpdCBpcyBhbGxvd2VkIHRvIGZpbmlzaCwgYW5kIGlmXG5cdCAqIHNvLCB0cmlnZ2VyIHByaW9yIGl0ZW1zIHRvIHRyaWdnZXIgYXMgd2VsbC5cblx0ICogQG1ldGhvZCBfZmluaXNoT3JkZXJlZEl0ZW1cblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gbG9hZEZhaWxlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBJZiB0aGUgaXRlbSdzIG9yZGVyIGlzIGJlaW5nIG1hbmFnZWQuIFRoaXMgYWxsb3dzIHRoZSBjYWxsZXIgdG8gdGFrZSBhbiBhbHRlcm5hdGVcblx0ICogYmVoYXZpb3VyIGlmIGl0IGlzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZmluaXNoT3JkZXJlZEl0ZW0gPSBmdW5jdGlvbiAobG9hZGVyLCBsb2FkRmFpbGVkKSB7XG5cdFx0dmFyIGl0ZW0gPSBsb2FkZXIuZ2V0SXRlbSgpO1xuXG5cdFx0aWYgKCh0aGlzLm1haW50YWluU2NyaXB0T3JkZXIgJiYgaXRlbS50eXBlID09IGNyZWF0ZWpzLkxvYWRRdWV1ZS5KQVZBU0NSSVBUKVxuXHRcdFx0XHR8fCBpdGVtLm1haW50YWluT3JkZXIpIHtcblxuXHRcdFx0Ly9UT0RPOiBFdmFsdWF0ZSByZW1vdmFsIG9mIHRoZSBfY3VycmVudGx5TG9hZGluZ1NjcmlwdFxuXHRcdFx0aWYgKGxvYWRlciBpbnN0YW5jZW9mIGNyZWF0ZWpzLkphdmFTY3JpcHRMb2FkZXIpIHtcblx0XHRcdFx0dGhpcy5fY3VycmVudGx5TG9hZGluZ1NjcmlwdCA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaW5kZXggPSBjcmVhdGVqcy5pbmRleE9mKHRoaXMuX3NjcmlwdE9yZGVyLCBpdGVtKTtcblx0XHRcdGlmIChpbmRleCA9PSAtMSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IC8vIFRoaXMgbG9hZGVyIG5vIGxvbmdlciBleGlzdHNcblx0XHRcdHRoaXMuX2xvYWRlZFNjcmlwdHNbaW5kZXhdID0gKGxvYWRGYWlsZWQgPT09IHRydWUpID8gdHJ1ZSA6IGl0ZW07XG5cblx0XHRcdHRoaXMuX2NoZWNrU2NyaXB0TG9hZE9yZGVyKCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuc3VyZSB0aGUgc2NyaXB0cyBsb2FkIGFuZCBkaXNwYXRjaCBpbiB0aGUgY29ycmVjdCBvcmRlci4gV2hlbiB1c2luZyBYSFIsIHNjcmlwdHMgYXJlIHN0b3JlZCBpbiBhbiBhcnJheSBpbiB0aGVcblx0ICogb3JkZXIgdGhleSB3ZXJlIGFkZGVkLCBidXQgd2l0aCBhIFwibnVsbFwiIHZhbHVlLiBXaGVuIHRoZXkgYXJlIGNvbXBsZXRlZCwgdGhlIHZhbHVlIGlzIHNldCB0byB0aGUgbG9hZCBpdGVtLFxuXHQgKiBhbmQgdGhlbiB3aGVuIHRoZXkgYXJlIHByb2Nlc3NlZCBhbmQgZGlzcGF0Y2hlZCwgdGhlIHZhbHVlIGlzIHNldCB0byBgdHJ1ZWAuIFRoaXMgbWV0aG9kIHNpbXBseVxuXHQgKiBpdGVyYXRlcyB0aGUgYXJyYXksIGFuZCBlbnN1cmVzIHRoYXQgYW55IGxvYWRlZCBpdGVtcyB0aGF0IGFyZSBub3QgcHJlY2VkZWQgYnkgYSBgbnVsbGAgdmFsdWUgYXJlXG5cdCAqIGRpc3BhdGNoZWQuXG5cdCAqIEBtZXRob2QgX2NoZWNrU2NyaXB0TG9hZE9yZGVyXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jaGVja1NjcmlwdExvYWRPcmRlciA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbCA9IHRoaXMuX2xvYWRlZFNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gdGhpcy5fbG9hZGVkU2NyaXB0c1tpXTtcblx0XHRcdGlmIChpdGVtID09PSBudWxsKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fSAvLyBUaGlzIGlzIHN0aWxsIGxvYWRpbmcuIERvIG5vdCBwcm9jZXNzIGZ1cnRoZXIuXG5cdFx0XHRpZiAoaXRlbSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gLy8gVGhpcyBoYXMgY29tcGxldGVkLCBhbmQgYmVlbiBwcm9jZXNzZWQuIE1vdmUgb24uXG5cblx0XHRcdHZhciBsb2FkSXRlbSA9IHRoaXMuX2xvYWRlZFJlc3VsdHNbaXRlbS5pZF07XG5cdFx0XHRpZiAoaXRlbS50eXBlID09IGNyZWF0ZWpzLkxvYWRRdWV1ZS5KQVZBU0NSSVBUKSB7XG5cdFx0XHRcdC8vIEFwcGVuZCBzY3JpcHQgdGFncyB0byB0aGUgaGVhZCBhdXRvbWF0aWNhbGx5LlxuXHRcdFx0XHRjcmVhdGVqcy5Eb21VdGlscy5hcHBlbmRUb0hlYWQobG9hZEl0ZW0pO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbG9hZGVyID0gaXRlbS5fbG9hZGVyO1xuXHRcdFx0dGhpcy5fcHJvY2Vzc0ZpbmlzaGVkTG9hZChpdGVtLCBsb2FkZXIpO1xuXHRcdFx0dGhpcy5fbG9hZGVkU2NyaXB0c1tpXSA9IHRydWU7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBBIGZpbGUgaGFzIGNvbXBsZXRlZCBsb2FkaW5nLCBhbmQgdGhlIExvYWRRdWV1ZSBjYW4gbW92ZSBvbi4gVGhpcyB0cmlnZ2VycyB0aGUgY29tcGxldGUgZXZlbnQsIGFuZCBraWNrLXN0YXJ0c1xuXHQgKiB0aGUgbmV4dCBpdGVtLlxuXHQgKiBAbWV0aG9kIF9wcm9jZXNzRmluaXNoZWRMb2FkXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9wcm9jZXNzRmluaXNoZWRMb2FkID0gZnVuY3Rpb24gKGl0ZW0sIGxvYWRlcikge1xuXHRcdHRoaXMuX251bUl0ZW1zTG9hZGVkKys7XG5cblx0XHQvLyBTaW5jZSBMb2FkUXVldWUgbmVlZHMgbWFpbnRhaW4gb3JkZXIsIHdlIGNhbid0IGFwcGVuZCBzY3JpcHRzIGluIHRoZSBsb2FkZXIuXG5cdFx0Ly8gU28gd2UgZG8gaXQgaGVyZSBpbnN0ZWFkLiBPciBpbiBfY2hlY2tTY3JpcHRMb2FkT3JkZXIoKTtcblx0XHRpZiAoIXRoaXMubWFpbnRhaW5TY3JpcHRPcmRlciAmJiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuTG9hZFF1ZXVlLkpBVkFTQ1JJUFQpIHtcblx0XHRcdGNyZWF0ZWpzLkRvbVV0aWxzLmFwcGVuZFRvSGVhZChpdGVtLnJlc3VsdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdXBkYXRlUHJvZ3Jlc3MoKTtcblx0XHR0aGlzLl9zZW5kRmlsZUNvbXBsZXRlKGl0ZW0sIGxvYWRlcik7XG5cdFx0dGhpcy5fbG9hZE5leHQoKTtcblx0fTtcblxuXHQvKipcblx0ICogRW5zdXJlIGl0ZW1zIHdpdGggYG1haW50YWluT3JkZXI9dHJ1ZWAgdGhhdCBhcmUgYmVmb3JlIHRoZSBzcGVjaWZpZWQgaXRlbSBoYXZlIGxvYWRlZC4gVGhpcyBvbmx5IGFwcGxpZXMgdG9cblx0ICogSmF2YVNjcmlwdCBpdGVtcyB0aGF0IGFyZSBiZWluZyBsb2FkZWQgd2l0aCBhIFRhZ0xvYWRlciwgc2luY2UgdGhleSBoYXZlIHRvIGJlIGxvYWRlZCBhbmQgY29tcGxldGVkIDxzdHJvbmc+YmVmb3JlPC9zdHJvbmc+XG5cdCAqIHRoZSBzY3JpcHQgY2FuIGV2ZW4gYmUgc3RhcnRlZCwgc2luY2UgaXQgZXhpc3QgaW4gdGhlIERPTSB3aGlsZSBsb2FkaW5nLlxuXHQgKiBAbWV0aG9kIF9jYW5TdGFydExvYWRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyIFRoZSBsb2FkZXIgZm9yIHRoZSBpdGVtXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGl0ZW0gY2FuIHN0YXJ0IGEgbG9hZCBvciBub3QuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9jYW5TdGFydExvYWQgPSBmdW5jdGlvbiAobG9hZGVyKSB7XG5cdFx0aWYgKCF0aGlzLm1haW50YWluU2NyaXB0T3JkZXIgfHwgbG9hZGVyLnByZWZlclhIUikge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHZhciBpdGVtID0gbG9hZGVyLmdldEl0ZW0oKTtcblx0XHRpZiAoaXRlbS50eXBlICE9IGNyZWF0ZWpzLkxvYWRRdWV1ZS5KQVZBU0NSSVBUKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX2N1cnJlbnRseUxvYWRpbmdTY3JpcHQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgaW5kZXggPSB0aGlzLl9zY3JpcHRPcmRlci5pbmRleE9mKGl0ZW0pO1xuXHRcdHZhciBpID0gMDtcblx0XHR3aGlsZSAoaSA8IGluZGV4KSB7XG5cdFx0XHR2YXIgY2hlY2tJdGVtID0gdGhpcy5fbG9hZGVkU2NyaXB0c1tpXTtcblx0XHRcdGlmIChjaGVja0l0ZW0gPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpKys7XG5cdFx0fVxuXHRcdHRoaXMuX2N1cnJlbnRseUxvYWRpbmdTY3JpcHQgPSB0cnVlO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBIGxvYWQgaXRlbSBpcyBjb21wbGV0ZWQgb3Igd2FzIGNhbmNlbGVkLCBhbmQgbmVlZHMgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBMb2FkUXVldWUuXG5cdCAqIEBtZXRob2QgX3JlbW92ZUxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlciBBIGxvYWRlciBpbnN0YW5jZSB0byByZW1vdmUuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9yZW1vdmVMb2FkSXRlbSA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHR2YXIgbCA9IHRoaXMuX2N1cnJlbnRMb2Fkcy5sZW5ndGg7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLl9jdXJyZW50TG9hZHNbaV0gPT0gbG9hZGVyKSB7XG5cdFx0XHRcdHRoaXMuX2N1cnJlbnRMb2Fkcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIHVubmVlZGVkIHJlZmVyZW5jZXMgZnJvbSBhIGxvYWRlci5cblx0ICpcblx0ICogQHBhcmFtIGxvYWRlclxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY2xlYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uKGxvYWRlcikge1xuXHRcdHZhciBpdGVtID0gbG9hZGVyLmdldEl0ZW0oKTtcblx0XHRpZiAoaXRlbSkge1xuXHRcdFx0ZGVsZXRlIGl0ZW0uX2xvYWRlcjtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQW4gaXRlbSBoYXMgZGlzcGF0Y2hlZCBwcm9ncmVzcy4gUHJvcGFnYXRlIHRoYXQgcHJvZ3Jlc3MsIGFuZCB1cGRhdGUgdGhlIExvYWRRdWV1ZSdzIG92ZXJhbGwgcHJvZ3Jlc3MuXG5cdCAqIEBtZXRob2QgX2hhbmRsZVByb2dyZXNzXG5cdCAqIEBwYXJhbSB7UHJvZ3Jlc3NFdmVudH0gZXZlbnQgVGhlIHByb2dyZXNzIGV2ZW50IGZyb20gdGhlIGl0ZW0uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVQcm9ncmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBsb2FkZXIgPSBldmVudC50YXJnZXQ7XG5cdFx0dGhpcy5fc2VuZEZpbGVQcm9ncmVzcyhsb2FkZXIuZ2V0SXRlbSgpLCBsb2FkZXIucHJvZ3Jlc3MpO1xuXHRcdHRoaXMuX3VwZGF0ZVByb2dyZXNzKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIE92ZXJhbGwgcHJvZ3Jlc3MgaGFzIGNoYW5nZWQsIHNvIGRldGVybWluZSB0aGUgbmV3IHByb2dyZXNzIGFtb3VudCBhbmQgZGlzcGF0Y2ggaXQuIFRoaXMgY2hhbmdlcyBhbnkgdGltZSBhblxuXHQgKiBpdGVtIGRpc3BhdGNoZXMgcHJvZ3Jlc3Mgb3IgY29tcGxldGVzLiBOb3RlIHRoYXQgc2luY2Ugd2UgZG9uJ3QgYWx3YXlzIGtub3cgdGhlIGFjdHVhbCBmaWxlc2l6ZSBvZiBpdGVtcyBiZWZvcmVcblx0ICogdGhleSBhcmUgbG9hZGVkLiBJbiB0aGlzIGNhc2UsIHdlIGRlZmluZSBhIFwic2xvdFwiIGZvciBlYWNoIGl0ZW0gKDEgaXRlbSBpbiAxMCB3b3VsZCBnZXQgMTAlKSwgYW5kIHRoZW4gYXBwZW5kXG5cdCAqIGxvYWRlZCBwcm9ncmVzcyBvbiB0b3Agb2YgdGhlIGFscmVhZHktbG9hZGVkIGl0ZW1zLlxuXHQgKlxuXHQgKiBGb3IgZXhhbXBsZSwgaWYgNS8xMCBpdGVtcyBoYXZlIGxvYWRlZCwgYW5kIGl0ZW0gNiBpcyAyMCUgbG9hZGVkLCB0aGUgdG90YWwgcHJvZ3Jlc3Mgd291bGQgYmU6XG5cdCAqIDx1bD5cblx0ICogICAgICA8bGk+NS8xMCBvZiB0aGUgaXRlbXMgaW4gdGhlIHF1ZXVlICg1MCUpPC9saT5cblx0ICogICAgICA8bGk+cGx1cyAyMCUgb2YgaXRlbSA2J3Mgc2xvdCAoMiUpPC9saT5cblx0ICogICAgICA8bGk+ZXF1YWxzIDUyJTwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIEBtZXRob2QgX3VwZGF0ZVByb2dyZXNzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl91cGRhdGVQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbG9hZGVkID0gdGhpcy5fbnVtSXRlbXNMb2FkZWQgLyB0aGlzLl9udW1JdGVtczsgLy8gRnVsbHkgTG9hZGVkIFByb2dyZXNzXG5cdFx0dmFyIHJlbWFpbmluZyA9IHRoaXMuX251bUl0ZW1zIC0gdGhpcy5fbnVtSXRlbXNMb2FkZWQ7XG5cdFx0aWYgKHJlbWFpbmluZyA+IDApIHtcblx0XHRcdHZhciBjaHVuayA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2N1cnJlbnRMb2Fkcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0Y2h1bmsgKz0gdGhpcy5fY3VycmVudExvYWRzW2ldLnByb2dyZXNzO1xuXHRcdFx0fVxuXHRcdFx0bG9hZGVkICs9IChjaHVuayAvIHJlbWFpbmluZykgKiAocmVtYWluaW5nIC8gdGhpcy5fbnVtSXRlbXMpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9sYXN0UHJvZ3Jlc3MgIT0gbG9hZGVkKSB7XG5cdFx0XHR0aGlzLl9zZW5kUHJvZ3Jlc3MobG9hZGVkKTtcblx0XHRcdHRoaXMuX2xhc3RQcm9ncmVzcyA9IGxvYWRlZDtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENsZWFuIG91dCBpdGVtIHJlc3VsdHMsIHRvIGZyZWUgdGhlbSBmcm9tIG1lbW9yeS4gTWFpbmx5LCB0aGUgbG9hZGVkIGl0ZW0gYW5kIHJlc3VsdHMgYXJlIGNsZWFyZWQgZnJvbSBpbnRlcm5hbFxuXHQgKiBoYXNoZXMuXG5cdCAqIEBtZXRob2QgX2Rpc3Bvc2VJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBpdGVtIHRoYXQgd2FzIHBhc3NlZCBpbiBmb3IgcHJlbG9hZGluZy5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Rpc3Bvc2VJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRkZWxldGUgdGhpcy5fbG9hZGVkUmVzdWx0c1tpdGVtLmlkXTtcblx0XHRkZWxldGUgdGhpcy5fbG9hZGVkUmF3UmVzdWx0c1tpdGVtLmlkXTtcblx0XHRkZWxldGUgdGhpcy5fbG9hZEl0ZW1zQnlJZFtpdGVtLmlkXTtcblx0XHRkZWxldGUgdGhpcy5fbG9hZEl0ZW1zQnlTcmNbaXRlbS5zcmNdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhIFwiZmlsZXByb2dyZXNzXCIge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0uIFBsZWFzZSBzZWUgdGhlIExvYWRRdWV1ZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZXByb2dyZXNzOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IGZvciBkZXRhaWxzIG9uIHRoZSBldmVudCBwYXlsb2FkLlxuXHQgKiBAbWV0aG9kIF9zZW5kRmlsZVByb2dyZXNzXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBpdGVtIHRoYXQgaXMgYmVpbmcgbG9hZGVkLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcHJvZ3Jlc3MgVGhlIGFtb3VudCB0aGUgaXRlbSBoYXMgYmVlbiBsb2FkZWQgKGJldHdlZW4gMCBhbmQgMSkuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3NlbmRGaWxlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoaXRlbSwgcHJvZ3Jlc3MpIHtcblx0XHRpZiAodGhpcy5faXNDYW5jZWxlZCgpIHx8IHRoaXMuX3BhdXNlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIXRoaXMuaGFzRXZlbnRMaXN0ZW5lcihcImZpbGVwcm9ncmVzc1wiKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vTE06IFJld29yayBQcm9ncmVzc0V2ZW50IHRvIHN1cHBvcnQgdGhpcz9cblx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJmaWxlcHJvZ3Jlc3NcIik7XG5cdFx0ZXZlbnQucHJvZ3Jlc3MgPSBwcm9ncmVzcztcblx0XHRldmVudC5sb2FkZWQgPSBwcm9ncmVzcztcblx0XHRldmVudC50b3RhbCA9IDE7XG5cdFx0ZXZlbnQuaXRlbSA9IGl0ZW07XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEaXNwYXRjaCBhIGZpbGVsb2FkIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LiBQbGVhc2Ugc2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvZmlsZWxvYWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQgZm9yXG5cdCAqIGRldGFpbHMgb24gdGhlIGV2ZW50IHBheWxvYWQuXG5cdCAqIEBtZXRob2QgX3NlbmRGaWxlQ29tcGxldGVcblx0ICogQHBhcmFtIHtMb2FkSXRlbU9iamVjdH0gaXRlbSBUaGUgaXRlbSB0aGF0IGlzIGJlaW5nIGxvYWRlZC5cblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX3NlbmRGaWxlQ29tcGxldGUgPSBmdW5jdGlvbiAoaXRlbSwgbG9hZGVyKSB7XG5cdFx0aWYgKHRoaXMuX2lzQ2FuY2VsZWQoKSB8fCB0aGlzLl9wYXVzZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJmaWxlbG9hZFwiKTtcblx0XHRldmVudC5sb2FkZXIgPSBsb2FkZXI7XG5cdFx0ZXZlbnQuaXRlbSA9IGl0ZW07XG5cdFx0ZXZlbnQucmVzdWx0ID0gdGhpcy5fbG9hZGVkUmVzdWx0c1tpdGVtLmlkXTtcblx0XHRldmVudC5yYXdSZXN1bHQgPSB0aGlzLl9sb2FkZWRSYXdSZXN1bHRzW2l0ZW0uaWRdO1xuXG5cdFx0Ly8gVGhpcyBjYWxscyBhIGhhbmRsZXIgc3BlY2lmaWVkIG9uIHRoZSBhY3R1YWwgbG9hZCBpdGVtLiBDdXJyZW50bHksIHRoZSBTb3VuZEpTIHBsdWdpbiB1c2VzIHRoaXMuXG5cdFx0aWYgKGl0ZW0uY29tcGxldGVIYW5kbGVyKSB7XG5cdFx0XHRpdGVtLmNvbXBsZXRlSGFuZGxlcihldmVudCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5oYXNFdmVudExpc3RlbmVyKFwiZmlsZWxvYWRcIikgJiYgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fTtcblxuXHQvKipcblx0ICogRGlzcGF0Y2ggYSBmaWxlc3RhcnQge3sjY3Jvc3NMaW5rIFwiRXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gaW1tZWRpYXRlbHkgYmVmb3JlIGEgZmlsZSBzdGFydHMgdG8gbG9hZC4gUGxlYXNlIHNlZVxuXHQgKiB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlL2ZpbGVzdGFydDpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCBmb3IgZGV0YWlscyBvbiB0aGUgZXZlbnQgcGF5bG9hZC5cblx0ICogQG1ldGhvZCBfc2VuZEZpbGVTdGFydFxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgaXRlbSB0aGF0IGlzIGJlaW5nIGxvYWRlZC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5fc2VuZEZpbGVTdGFydCA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiZmlsZXN0YXJ0XCIpO1xuXHRcdGV2ZW50Lml0ZW0gPSBpdGVtO1xuXHRcdHRoaXMuaGFzRXZlbnRMaXN0ZW5lcihcImZpbGVzdGFydFwiKSAmJiB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFwiW1ByZWxvYWRKUyBMb2FkUXVldWVdXCI7XG5cdH07XG5cblx0Y3JlYXRlanMuTG9hZFF1ZXVlID0gY3JlYXRlanMucHJvbW90ZShMb2FkUXVldWUsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVGV4dExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgVGV4dCBmaWxlcy5cblx0ICogQGNsYXNzIFRleHRMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gVGV4dExvYWRlcihsb2FkSXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHRydWUsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlRFWFQpO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFRleHRMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBUZXh0TG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBsb2FkcyBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1RFWFQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0sXG5cdCAqIGJ1dCBpcyBhbHNvIHRoZSBkZWZhdWx0IGxvYWRlciBpZiBhIGZpbGUgdHlwZSBjYW4gbm90IGJlIGRldGVybWluZWQuXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuVEVYVDtcblx0fTtcblxuXHRjcmVhdGVqcy5UZXh0TG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShUZXh0TG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gQmluYXJ5TG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBiaW5hcnkgZmlsZXMuIFRoaXMgaXMgdXNlZnVsIGZvciBsb2FkaW5nIHdlYiBhdWRpbywgb3IgY29udGVudCB0aGF0IHJlcXVpcmVzIGFuIEFycmF5QnVmZmVyLlxuXHQgKiBAY2xhc3MgQmluYXJ5TG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEJpbmFyeUxvYWRlcihsb2FkSXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHRydWUsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLkJJTkFSWSk7XG5cdFx0dGhpcy5vbihcImluaXRpYWxpemVcIiwgdGhpcy5fdXBkYXRlWEhSLCB0aGlzKTtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChCaW5hcnlMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBCaW5hcnlMb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9CSU5BUlk6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5CSU5BUlk7XG5cdH07XG5cblx0Ly8gcHJpdmF0ZSBtZXRob2RzXG5cdC8qKlxuXHQgKiBCZWZvcmUgdGhlIGl0ZW0gbG9hZHMsIHNldCB0aGUgcmVzcG9uc2UgdHlwZSB0byBcImFycmF5YnVmZmVyXCJcblx0ICogQHByb3BlcnR5IF91cGRhdGVYSFJcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX3VwZGF0ZVhIUiA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LmxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJhcnJheWJ1ZmZlclwiKTtcblx0fTtcblxuXHRjcmVhdGVqcy5CaW5hcnlMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEJpbmFyeUxvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIENTU0xvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgQ1NTIGZpbGVzLlxuXHQgKiBAY2xhc3MgQ1NTTG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZlclhIUlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIENTU0xvYWRlcihsb2FkSXRlbSwgcHJlZmVyWEhSKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgcHJlZmVyWEhSLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5DU1MpO1xuXG5cdFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblx0XHR0aGlzLnJlc3VsdEZvcm1hdHRlciA9IHRoaXMuX2Zvcm1hdFJlc3VsdDtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5fdGFnU3JjQXR0cmlidXRlID0gXCJocmVmXCI7XG5cblx0XHRpZiAocHJlZmVyWEhSKSB7XG5cdFx0XHR0aGlzLl90YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3RhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3RhZy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblx0XHR0aGlzLl90YWcudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChDU1NMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBDU1NMb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9DU1M6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuQ1NTO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBUaGUgcmVzdWx0IGZvcm1hdHRlciBmb3IgQ1NTIGZpbGVzLlxuXHQgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEByZXR1cm5zIHtIVE1MTGlua0VsZW1lbnR8SFRNTFN0eWxlRWxlbWVudH1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2Zvcm1hdFJlc3VsdCA9IGZ1bmN0aW9uIChsb2FkZXIpIHtcblx0XHRpZiAodGhpcy5fcHJlZmVyWEhSKSB7XG5cdFx0XHR2YXIgdGFnID0gbG9hZGVyLmdldFRhZygpO1xuXG5cdFx0XHRpZiAodGFnLnN0eWxlU2hlZXQpIHsgLy8gSUVcblx0XHRcdFx0dGFnLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGxvYWRlci5nZXRSZXN1bHQodHJ1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsb2FkZXIuZ2V0UmVzdWx0KHRydWUpKTtcblx0XHRcdFx0dGFnLmFwcGVuZENoaWxkKHRleHROb2RlKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFnID0gdGhpcy5fdGFnO1xuXHRcdH1cblxuXHRcdGNyZWF0ZWpzLkRvbVV0aWxzLmFwcGVuZFRvSGVhZCh0YWcpO1xuXG5cdFx0cmV0dXJuIHRhZztcblx0fTtcblxuXHRjcmVhdGVqcy5DU1NMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKENTU0xvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEltYWdlTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBpbWFnZSBmaWxlcy5cblx0ICogQGNsYXNzIEltYWdlTG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZlclhIUlxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIEltYWdlTG9hZGVyIChsb2FkSXRlbSwgcHJlZmVyWEhSKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgcHJlZmVyWEhSLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5JTUFHRSk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXG5cdFx0Ly8gcHJvdGVjdGVkIHByb3BlcnRpZXNcblx0XHR0aGlzLl90YWdTcmNBdHRyaWJ1dGUgPSBcInNyY1wiO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIHByZWxvYWQgaXRlbSBpcyBhbHJlYWR5IGEgdGFnLlxuXHRcdGlmIChjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNJbWFnZVRhZyhsb2FkSXRlbSkpIHtcblx0XHRcdHRoaXMuX3RhZyA9IGxvYWRJdGVtO1xuXHRcdH0gZWxzZSBpZiAoY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzSW1hZ2VUYWcobG9hZEl0ZW0uc3JjKSkge1xuXHRcdFx0dGhpcy5fdGFnID0gbG9hZEl0ZW0uc3JjO1xuXHRcdH0gZWxzZSBpZiAoY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzSW1hZ2VUYWcobG9hZEl0ZW0udGFnKSkge1xuXHRcdFx0dGhpcy5fdGFnID0gbG9hZEl0ZW0udGFnO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl90YWcgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fcHJlZmVyWEhSID0gZmFsc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3RhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG5cdFx0fVxuXG5cdFx0dGhpcy5vbihcImluaXRpYWxpemVcIiwgdGhpcy5fdXBkYXRlWEhSLCB0aGlzKTtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChJbWFnZUxvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IEltYWdlTG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSU1BR0U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSU1BR0U7XG5cdH07XG5cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl90YWcuc3JjICE9IFwiXCIgJiYgdGhpcy5fdGFnLmNvbXBsZXRlKSB7XG5cdFx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgY3Jvc3NPcmlnaW4gPSB0aGlzLl9pdGVtLmNyb3NzT3JpZ2luO1xuXHRcdGlmIChjcm9zc09yaWdpbiA9PSB0cnVlKSB7IGNyb3NzT3JpZ2luID0gXCJBbm9ueW1vdXNcIjsgfVxuXHRcdGlmIChjcm9zc09yaWdpbiAhPSBudWxsICYmICFjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNMb2NhbCh0aGlzLl9pdGVtLnNyYykpIHtcblx0XHRcdHRoaXMuX3RhZy5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuXHRcdH1cblxuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfbG9hZCgpO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdC8qKlxuXHQgKiBCZWZvcmUgdGhlIGl0ZW0gbG9hZHMsIHNldCBpdHMgbWltZVR5cGUgYW5kIHJlc3BvbnNlVHlwZS5cblx0ICogQHByb3BlcnR5IF91cGRhdGVYSFJcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX3VwZGF0ZVhIUiA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGV2ZW50LmxvYWRlci5taW1lVHlwZSA9ICd0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkLWJpbmFyeSc7XG5cblx0XHQvLyBPbmx5IGV4aXN0cyBmb3IgWEhSXG5cdFx0aWYgKGV2ZW50LmxvYWRlci5zZXRSZXNwb25zZVR5cGUpIHtcblx0XHRcdGV2ZW50LmxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJibG9iXCIpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIEltYWdlIGZpbGVzLlxuXHQgKiBAbWV0aG9kIF9mb3JtYXRSZXN1bHRcblx0ICogQHBhcmFtIHtBYnN0cmFjdExvYWRlcn0gbG9hZGVyXG5cdCAqIEByZXR1cm5zIHtIVE1MSW1hZ2VFbGVtZW50fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZm9ybWF0UmVzdWx0ID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChkb25lKSB7XG5cdFx0XHR2YXIgdGFnID0gX3RoaXMuX3RhZztcblx0XHRcdHZhciBVUkwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XG5cblx0XHRcdGlmICghX3RoaXMuX3ByZWZlclhIUikge1xuXHRcdFx0XHQvL2RvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGFnKTtcblx0XHRcdH0gZWxzZSBpZiAoVVJMKSB7XG5cdFx0XHRcdHZhciBvYmpVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGxvYWRlci5nZXRSZXN1bHQodHJ1ZSkpO1xuXHRcdFx0XHR0YWcuc3JjID0gb2JqVVJMO1xuXHRcdFx0XHR0YWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoX3RoaXMuc3JjKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFnLnNyYyA9IGxvYWRlci5nZXRJdGVtKCkuc3JjO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGFnLmNvbXBsZXRlKSB7XG5cdFx0XHRcdGRvbmUodGFnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0ZG9uZSh0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH07XG5cblx0Y3JlYXRlanMuSW1hZ2VMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEltYWdlTG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gSmF2YVNjcmlwdExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgSmF2YVNjcmlwdCBmaWxlcy5cblx0ICogQGNsYXNzIEphdmFTY3JpcHRMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gSmF2YVNjcmlwdExvYWRlcihsb2FkSXRlbSwgcHJlZmVyWEhSKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgcHJlZmVyWEhSLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KQVZBU0NSSVBUKTtcblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5yZXN1bHRGb3JtYXR0ZXIgPSB0aGlzLl9mb3JtYXRSZXN1bHQ7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSA9IFwic3JjXCI7XG5cdFx0dGhpcy5zZXRUYWcoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSk7XG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoSmF2YVNjcmlwdExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IEphdmFTY3JpcHRMb2FkZXI7XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KQVZBU0NSSVBUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSkFWQVNDUklQVDtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIEphdmFTY3JpcHQgZmlsZXMuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHJldHVybnMge0hUTUxMaW5rRWxlbWVudHxIVE1MU3R5bGVFbGVtZW50fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZm9ybWF0UmVzdWx0ID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdHZhciB0YWcgPSBsb2FkZXIuZ2V0VGFnKCk7XG5cdFx0aWYgKHRoaXMuX3ByZWZlclhIUikge1xuXHRcdFx0dGFnLnRleHQgPSBsb2FkZXIuZ2V0UmVzdWx0KHRydWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGFnO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLkphdmFTY3JpcHRMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEphdmFTY3JpcHRMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBKU09OTG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBKU09OIGZpbGVzLiBUbyBsb2FkIEpTT04gY3Jvc3MtZG9tYWluLCB1c2UgSlNPTlAgYW5kIHRoZSB7eyNjcm9zc0xpbmsgXCJKU09OUExvYWRlclwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBpbnN0ZWFkLiBUbyBsb2FkIEpTT04tZm9ybWF0dGVkIG1hbmlmZXN0cywgdXNlIHt7I2Nyb3NzTGluayBcIk1hbmlmZXN0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgdG9cblx0ICogbG9hZCBFYXNlbEpTIFNwcml0ZVNoZWV0cywgdXNlIHt7I2Nyb3NzTGluayBcIlNwcml0ZVNoZWV0TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAY2xhc3MgSlNPTkxvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBKU09OTG9hZGVyKGxvYWRJdGVtKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgdHJ1ZSwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuSlNPTik7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKEpTT05Mb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBKU09OTG9hZGVyO1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvSlNPTjpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KU09OICYmICFpdGVtLl9sb2FkQXNKU09OUDtcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIEpTT04gZmlsZXMuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHJldHVybnMge0hUTUxMaW5rRWxlbWVudHxIVE1MU3R5bGVFbGVtZW50fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZm9ybWF0UmVzdWx0ID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdHZhciBqc29uID0gbnVsbDtcblx0XHR0cnkge1xuXHRcdFx0anNvbiA9IGNyZWF0ZWpzLkRhdGFVdGlscy5wYXJzZUpTT04obG9hZGVyLmdldFJlc3VsdCh0cnVlKSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0dmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJKU09OX0ZPUk1BVFwiLCBudWxsLCBlKTtcblx0XHRcdHRoaXMuX3NlbmRFcnJvcihldmVudCk7XG5cdFx0XHRyZXR1cm4gZTtcblx0XHR9XG5cblx0XHRyZXR1cm4ganNvbjtcblx0fTtcblxuXHRjcmVhdGVqcy5KU09OTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShKU09OTG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gSlNPTlBMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIEpTT05QIGZpbGVzLCB3aGljaCBhcmUgSlNPTi1mb3JtYXR0ZWQgdGV4dCBmaWxlcywgd3JhcHBlZCBpbiBhIGNhbGxiYWNrLiBUbyBsb2FkIHJlZ3VsYXIgSlNPTlxuXHQgKiB3aXRob3V0IGEgY2FsbGJhY2sgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJKU09OTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319IGluc3RlYWQuIFRvIGxvYWQgSlNPTi1mb3JtYXR0ZWQgbWFuaWZlc3RzLFxuXHQgKiB1c2Uge3sjY3Jvc3NMaW5rIFwiTWFuaWZlc3RMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCB0byBsb2FkIEVhc2VsSlMgU3ByaXRlU2hlZXRzLCB1c2Vcblx0ICoge3sjY3Jvc3NMaW5rIFwiU3ByaXRlU2hlZXRMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBKU09OUCBmaWxlcyBsb2FkZWQgY29uY3VycmVudGx5IHJlcXVpcmUgYSA8ZW0+dW5pcXVlPC9lbT4gY2FsbGJhY2suIFRvIGVuc3VyZSBKU09OUCBmaWxlcyBhcmUgbG9hZGVkXG5cdCAqIGluIG9yZGVyLCBlaXRoZXIgdXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvc2V0TWF4Q29ubmVjdGlvbnNcIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kIChzZXQgdG8gMSksXG5cdCAqIG9yIHNldCB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS9tYWludGFpbk9yZGVyOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IG9uIGl0ZW1zIHdpdGggdGhlIHNhbWUgY2FsbGJhY2suXG5cdCAqIEBjbGFzcyBKU09OUExvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBKU09OUExvYWRlcihsb2FkSXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIGZhbHNlLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KU09OUCk7XG5cdFx0dGhpcy5zZXRUYWcoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSk7XG5cdFx0dGhpcy5nZXRUYWcoKS50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChKU09OUExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IEpTT05QTG9hZGVyO1xuXG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9KU09OUDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5KU09OUCB8fCBpdGVtLl9sb2FkQXNKU09OUDtcblx0fTtcblxuXHQvLyBwdWJsaWMgbWV0aG9kc1xuXHRwLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NhbmNlbCgpO1xuXHRcdHRoaXMuX2Rpc3Bvc2UoKTtcblx0fTtcblxuXHQvKipcblx0ICogTG9hZHMgdGhlIEpTT05wIGZpbGUuICBCZWNhdXNlIG9mIHRoZSB1bmlxdWUgbG9hZGluZyBuZWVkcyBvZiBqc29uUFxuXHQgKiB3ZSBkb24ndCB1c2UgdGhlIEFic3RyYWN0TG9hZGVyLmxvYWQoKSBtZXRob2QuXG5cdCAqXG5cdCAqIEBtZXRob2QgbG9hZFxuXHQgKlxuXHQgKi9cblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9pdGVtLmNhbGxiYWNrID09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignY2FsbGJhY2sgaXMgcmVxdWlyZWQgZm9yIGxvYWRpbmcgSlNPTlAgcmVxdWVzdHMuJyk7XG5cdFx0fVxuXG5cdFx0Ly8gVE9ETzogTG9vayBpbnRvIGNyZWF0aW5nIG91ciBvd24gaUZyYW1lIHRvIGhhbmRsZSB0aGUgbG9hZFxuXHRcdC8vIEluIHRoZSBmaXJzdCBhdHRlbXB0LCBGRiBkaWQgbm90IGdldCB0aGUgcmVzdWx0XG5cdFx0Ly8gICByZXN1bHQgaW5zdGFuY2VvZiBPYmplY3QgZGlkIG5vdCB3b3JrIGVpdGhlclxuXHRcdC8vICAgc28gd2Ugd291bGQgbmVlZCB0byBjbG9uZSB0aGUgcmVzdWx0LlxuXHRcdGlmICh3aW5kb3dbdGhpcy5faXRlbS5jYWxsYmFja10gIT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcIkpTT05QIGNhbGxiYWNrICdcIiArXG5cdFx0XHRcdHRoaXMuX2l0ZW0uY2FsbGJhY2sgK1xuXHRcdFx0XHRcIicgYWxyZWFkeSBleGlzdHMgb24gd2luZG93LiBZb3UgbmVlZCB0byBzcGVjaWZ5IGEgZGlmZmVyZW50IGNhbGxiYWNrIG9yIHJlLW5hbWUgdGhlIGN1cnJlbnQgb25lLlwiKTtcblx0XHR9XG5cblx0XHR3aW5kb3dbdGhpcy5faXRlbS5jYWxsYmFja10gPSBjcmVhdGVqcy5wcm94eSh0aGlzLl9oYW5kbGVMb2FkLCB0aGlzKTtcblx0XHR3aW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl90YWcpO1xuXG5cdFx0dGhpcy5fbG9hZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGNyZWF0ZWpzLnByb3h5KHRoaXMuX2hhbmRsZVRpbWVvdXQsIHRoaXMpLCB0aGlzLl9pdGVtLmxvYWRUaW1lb3V0KTtcblxuXHRcdC8vIExvYWQgdGhlIHRhZ1xuXHRcdHRoaXMuX3RhZy5zcmMgPSB0aGlzLl9pdGVtLnNyYztcblx0fTtcblxuXHQvLyBwcml2YXRlIG1ldGhvZHNcblx0LyoqXG5cdCAqIEhhbmRsZSB0aGUgSlNPTlAgY2FsbGJhY2ssIHdoaWNoIGlzIGEgcHVibGljIG1ldGhvZCBkZWZpbmVkIG9uIGB3aW5kb3dgLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVMb2FkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBmb3JtYXR0ZWQgSlNPTiBkYXRhLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTG9hZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0dGhpcy5fcmVzdWx0ID0gdGhpcy5fcmF3UmVzdWx0ID0gZGF0YTtcblx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblxuXHRcdHRoaXMuX2Rpc3Bvc2UoKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIHRhZyByZXF1ZXN0IGhhcyBub3QgbG9hZGVkIHdpdGhpbiB0aGUgdGltZSBzcGVjZmllZCBpbiBsb2FkVGltZW91dC5cblx0ICogQG1ldGhvZCBfaGFuZGxlRXJyb3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBYSFIgZXJyb3IgZXZlbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2Rpc3Bvc2UoKTtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQobmV3IGNyZWF0ZWpzLkVycm9yRXZlbnQoXCJ0aW1lb3V0XCIpKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2xlYW4gdXAgdGhlIEpTT05QIGxvYWQuIFRoaXMgY2xlYXJzIG91dCB0aGUgY2FsbGJhY2sgYW5kIHNjcmlwdCB0YWcgdGhhdCB0aGlzIGxvYWRlciBjcmVhdGVzLlxuXHQgKiBAbWV0aG9kIF9kaXNwb3NlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXHRcdHdpbmRvdy5kb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuX3RhZyk7XG5cdFx0ZGVsZXRlIHdpbmRvd1t0aGlzLl9pdGVtLmNhbGxiYWNrXTtcblxuXHRcdGNsZWFyVGltZW91dCh0aGlzLl9sb2FkVGltZW91dCk7XG5cdH07XG5cblx0Y3JlYXRlanMuSlNPTlBMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKEpTT05QTG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gTWFuaWZlc3RMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIEpTT04gbWFuaWZlc3RzLiBJdGVtcyBpbnNpZGUgdGhlIG1hbmlmZXN0IGFyZSBsb2FkZWQgYmVmb3JlIHRoZSBsb2FkZXIgY29tcGxldGVzLiBUbyBsb2FkIG1hbmlmZXN0c1xuXHQgKiB1c2luZyBKU09OUCwgc3BlY2lmeSBhIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtL2NhbGxiYWNrOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IGFzIHBhcnQgb2YgdGhlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkxvYWRJdGVtXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiBUaGUgbGlzdCBvZiBmaWxlcyBpbiB0aGUgbWFuaWZlc3QgbXVzdCBiZSBkZWZpbmVkIG9uIHRoZSB0b3AtbGV2ZWwgSlNPTiBvYmplY3QgaW4gYSBgbWFuaWZlc3RgIHByb3BlcnR5LiBUaGlzXG5cdCAqIGV4YW1wbGUgc2hvd3MgYSBzYW1wbGUgbWFuaWZlc3QgZGVmaW5pdGlvbiwgYXMgd2VsbCBhcyBob3cgdG8gdG8gaW5jbHVkZSBhIHN1Yi1tYW5pZmVzdC5cblx0ICpcblx0ICogXHRcdHtcblx0ICogXHRcdFx0XCJwYXRoXCI6IFwiYXNzZXRzL1wiLFxuXHQgKlx0IFx0ICAgIFwibWFuaWZlc3RcIjogW1xuXHQgKlx0XHRcdFx0XCJpbWFnZS5wbmdcIixcblx0ICpcdFx0XHRcdHtcInNyY1wiOiBcImltYWdlMi5wbmdcIiwgXCJpZFwiOlwiaW1hZ2UyXCJ9LFxuXHQgKlx0XHRcdFx0e1wic3JjXCI6IFwic3ViLW1hbmlmZXN0Lmpzb25cIiwgXCJ0eXBlXCI6XCJtYW5pZmVzdFwiLCBcImNhbGxiYWNrXCI6XCJqc29uQ2FsbGJhY2tcIn1cblx0ICpcdCBcdCAgICBdXG5cdCAqXHQgXHR9XG5cdCAqXG5cdCAqIFdoZW4gYSBNYW5pZmVzdExvYWRlciBoYXMgY29tcGxldGVkIGxvYWRpbmcsIHRoZSBwYXJlbnQgbG9hZGVyICh1c3VhbGx5IGEge3sjY3Jvc3NMaW5rIFwiTG9hZFF1ZXVlXCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBidXQgY291bGQgYWxzbyBiZSBhbm90aGVyIE1hbmlmZXN0TG9hZGVyKSB3aWxsIGluaGVyaXQgYWxsIHRoZSBsb2FkZWQgaXRlbXMsIHNvIHlvdSBjYW4gYWNjZXNzIHRoZW0gZGlyZWN0bHkuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGUge3sjY3Jvc3NMaW5rIFwiSlNPTkxvYWRlclwifX17ey9jcm9zc0xpbmt9fSBhbmQge3sjY3Jvc3NMaW5rIFwiSlNPTlBMb2FkZXJcIn19e3svY3Jvc3NMaW5rfX0gYXJlXG5cdCAqIGhpZ2hlciBwcmlvcml0eSBsb2FkZXJzLCBzbyBtYW5pZmVzdHMgPHN0cm9uZz5tdXN0PC9zdHJvbmc+IHNldCB0aGUge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW1cIn19e3svY3Jvc3NMaW5rfX1cblx0ICoge3sjY3Jvc3NMaW5rIFwiTG9hZEl0ZW0vdHlwZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSB0byB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9NQU5JRkVTVDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQGNsYXNzIE1hbmlmZXN0TG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIE1hbmlmZXN0TG9hZGVyKGxvYWRJdGVtKSB7XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9jb25zdHJ1Y3Rvcihsb2FkSXRlbSwgbnVsbCwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuTUFOSUZFU1QpO1xuXG5cdC8vIFB1YmxpYyBQcm9wZXJ0aWVzXG5cdFx0LyoqXG5cdFx0ICogQW4gYXJyYXkgb2YgdGhlIHBsdWdpbnMgcmVnaXN0ZXJlZCB1c2luZyB7eyNjcm9zc0xpbmsgXCJMb2FkUXVldWUvaW5zdGFsbFBsdWdpblwifX17ey9jcm9zc0xpbmt9fSxcblx0XHQgKiB1c2VkIHRvIHBhc3MgcGx1Z2lucyB0byBuZXcgTG9hZFF1ZXVlcyB0aGF0IG1heSBiZSBjcmVhdGVkLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcGx1Z2luc1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIEBzaW5jZSAwLjYuMVxuXHRcdCAqL1xuXHRcdHRoaXMucGx1Z2lucyA9IG51bGw7XG5cblxuXHQvLyBQcm90ZWN0ZWQgUHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEFuIGludGVybmFsIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSB0aGF0IGxvYWRzIHRoZSBjb250ZW50cyBvZiB0aGUgbWFuaWZlc3QuXG5cdFx0ICogQHByb3BlcnR5IF9tYW5pZmVzdFF1ZXVlXG5cdFx0ICogQHR5cGUge0xvYWRRdWV1ZX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX21hbmlmZXN0UXVldWUgPSBudWxsO1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKE1hbmlmZXN0TG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlcik7XG5cdHZhciBzID0gTWFuaWZlc3RMb2FkZXI7XG5cblx0Ly8gc3RhdGljIHByb3BlcnRpZXNcblx0LyoqXG5cdCAqIFRoZSBhbW91bnQgb2YgcHJvZ3Jlc3MgdGhhdCB0aGUgbWFuaWZlc3QgaXRzZWxmIHRha2VzIHVwLlxuXHQgKiBAcHJvcGVydHkgTUFOSUZFU1RfUFJPR1JFU1Ncblx0ICogQHR5cGUge251bWJlcn1cblx0ICogQGRlZmF1bHQgMC4yNSAoMjUlKVxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLk1BTklGRVNUX1BST0dSRVNTID0gMC4yNTtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL01BTklGRVNUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIEBtZXRob2QgY2FuTG9hZEl0ZW1cblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGl0ZW0gVGhlIExvYWRJdGVtIHRoYXQgYSBMb2FkUXVldWUgaXMgdHJ5aW5nIHRvIGxvYWQuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBXaGV0aGVyIHRoZSBsb2FkZXIgY2FuIGxvYWQgdGhlIGl0ZW0uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuY2FuTG9hZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLnR5cGUgPT0gY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuTUFOSUZFU1Q7XG5cdH07XG5cblx0Ly8gcHVibGljIG1ldGhvZHNcblx0cC5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfbG9hZCgpO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdHAuX2NyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSB0aGlzLl9pdGVtLmNhbGxiYWNrO1xuXHRcdGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLkpTT05QTG9hZGVyKHRoaXMuX2l0ZW0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9yZXF1ZXN0ID0gbmV3IGNyZWF0ZWpzLkpTT05Mb2FkZXIodGhpcy5faXRlbSk7XG5cdFx0fVxuXHR9O1xuXG5cdHAuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcblx0XHRcdGNhc2UgXCJjb21wbGV0ZVwiOlxuXHRcdFx0XHR0aGlzLl9yYXdSZXN1bHQgPSBldmVudC50YXJnZXQuZ2V0UmVzdWx0KHRydWUpO1xuXHRcdFx0XHR0aGlzLl9yZXN1bHQgPSBldmVudC50YXJnZXQuZ2V0UmVzdWx0KCk7XG5cdFx0XHRcdHRoaXMuX3NlbmRQcm9ncmVzcyhzLk1BTklGRVNUX1BST0dSRVNTKTtcblx0XHRcdFx0dGhpcy5fbG9hZE1hbmlmZXN0KHRoaXMuX3Jlc3VsdCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdGNhc2UgXCJwcm9ncmVzc1wiOlxuXHRcdFx0XHRldmVudC5sb2FkZWQgKj0gcy5NQU5JRkVTVF9QUk9HUkVTUztcblx0XHRcdFx0dGhpcy5wcm9ncmVzcyA9IGV2ZW50LmxvYWRlZCAvIGV2ZW50LnRvdGFsO1xuXHRcdFx0XHRpZiAoaXNOYU4odGhpcy5wcm9ncmVzcykgfHwgdGhpcy5wcm9ncmVzcyA9PSBJbmZpbml0eSkgeyB0aGlzLnByb2dyZXNzID0gMDsgfVxuXHRcdFx0XHR0aGlzLl9zZW5kUHJvZ3Jlc3MoZXZlbnQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfaGFuZGxlRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdHAuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfZGVzdHJveSgpO1xuXHRcdHRoaXMuX21hbmlmZXN0UXVldWUuY2xvc2UoKTtcblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGFuZCBsb2FkIHRoZSBtYW5pZmVzdCBpdGVtcyBvbmNlIHRoZSBhY3R1YWwgbWFuaWZlc3QgaGFzIGJlZW4gbG9hZGVkLlxuXHQgKiBAbWV0aG9kIF9sb2FkTWFuaWZlc3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IGpzb25cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2xvYWRNYW5pZmVzdCA9IGZ1bmN0aW9uIChqc29uKSB7XG5cdFx0aWYgKGpzb24gJiYganNvbi5tYW5pZmVzdCkge1xuXHRcdFx0dmFyIHF1ZXVlID0gdGhpcy5fbWFuaWZlc3RRdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUoKTtcblx0XHRcdHF1ZXVlLm9uKFwiZmlsZWxvYWRcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RGaWxlTG9hZCwgdGhpcyk7XG5cdFx0XHRxdWV1ZS5vbihcInByb2dyZXNzXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0UHJvZ3Jlc3MsIHRoaXMpO1xuXHRcdFx0cXVldWUub24oXCJjb21wbGV0ZVwiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdENvbXBsZXRlLCB0aGlzLCB0cnVlKTtcblx0XHRcdHF1ZXVlLm9uKFwiZXJyb3JcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RFcnJvciwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRmb3IodmFyIGkgPSAwLCBsID0gdGhpcy5wbHVnaW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1x0Ly8gY29uc2VydmUgb3JkZXIgb2YgcGx1Z2luc1xuXHRcdFx0XHRxdWV1ZS5pbnN0YWxsUGx1Z2luKHRoaXMucGx1Z2luc1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRxdWV1ZS5sb2FkTWFuaWZlc3QoanNvbik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3NlbmRDb21wbGV0ZSgpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQW4gaXRlbSBmcm9tIHRoZSB7eyNjcm9zc0xpbmsgXCJfbWFuaWZlc3RRdWV1ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBoYXMgY29tcGxldGVkLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNYW5pZmVzdEZpbGVMb2FkXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVNYW5pZmVzdEZpbGVMb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ZXZlbnQudGFyZ2V0ID0gbnVsbDtcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbWFuaWZlc3QgaGFzIGNvbXBsZXRlZCBsb2FkaW5nLiBUaGlzIHRyaWdnZXJzIHRoZSB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9jb21wbGV0ZTpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudFwifX17ey9jcm9zc0xpbmt9fSBmcm9tIHRoZSBNYW5pZmVzdExvYWRlci5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RDb21wbGV0ZVxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RDb21wbGV0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMuX2xvYWRlZEl0ZW1zID0gdGhpcy5fbWFuaWZlc3RRdWV1ZS5nZXRJdGVtcyh0cnVlKTtcblx0XHR0aGlzLl9zZW5kQ29tcGxldGUoKTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG1hbmlmZXN0IGhhcyByZXBvcnRlZCBwcm9ncmVzcy5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RQcm9ncmVzc1xuXHQgKiBAcGFyYW0ge1Byb2dyZXNzRXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVNYW5pZmVzdFByb2dyZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dGhpcy5wcm9ncmVzcyA9IGV2ZW50LnByb2dyZXNzICogKDEgLSBzLk1BTklGRVNUX1BST0dSRVNTKSArIHMuTUFOSUZFU1RfUFJPR1JFU1M7XG5cdFx0dGhpcy5fc2VuZFByb2dyZXNzKHRoaXMucHJvZ3Jlc3MpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbWFuaWZlc3QgaGFzIHJlcG9ydGVkIGFuIGVycm9yIHdpdGggb25lIG9mIHRoZSBmaWxlcy5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RFcnJvclxuXHQgKiBAcGFyYW0ge0Vycm9yRXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVNYW5pZmVzdEVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dmFyIG5ld0V2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwiZmlsZWVycm9yXCIpO1xuXHRcdG5ld0V2ZW50Lml0ZW0gPSBldmVudC5kYXRhO1xuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudChuZXdFdmVudCk7XG5cdH07XG5cblx0Y3JlYXRlanMuTWFuaWZlc3RMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKE1hbmlmZXN0TG9hZGVyLCBcIkFic3RyYWN0TG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gU291bmRMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIEhUTUwgYXVkaW8gZmlsZXMuIFByZWxvYWRKUyBjYW4gbm90IGxvYWQgV2ViQXVkaW8gZmlsZXMsIGFzIGEgV2ViQXVkaW8gY29udGV4dCBpcyByZXF1aXJlZCwgd2hpY2hcblx0ICogc2hvdWxkIGJlIGNyZWF0ZWQgYnkgZWl0aGVyIGEgbGlicmFyeSBwbGF5aW5nIHRoZSBzb3VuZCAoc3VjaCBhcyA8YSBocmVmPVwiaHR0cDovL3NvdW5kanMuY29tXCI+U291bmRKUzwvYT4sIG9yIGFuXG5cdCAqIGV4dGVybmFsIGZyYW1ld29yayB0aGF0IGhhbmRsZXMgYXVkaW8gcGxheWJhY2suIFRvIGxvYWQgY29udGVudCB0aGF0IGNhbiBiZSBwbGF5ZWQgYnkgV2ViQXVkaW8sIHVzZSB0aGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQmluYXJ5TG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319LCBhbmQgaGFuZGxlIHRoZSBhdWRpbyBjb250ZXh0IGRlY29kaW5nIG1hbnVhbGx5LlxuXHQgKiBAY2xhc3MgU291bmRMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TWVkaWFMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBTb3VuZExvYWRlcihsb2FkSXRlbSwgcHJlZmVyWEhSKSB7XG5cdFx0dGhpcy5BYnN0cmFjdE1lZGlhTG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNPVU5EKTtcblxuXHRcdC8vIHByb3RlY3RlZCBwcm9wZXJ0aWVzXG5cdFx0aWYgKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0F1ZGlvVGFnKGxvYWRJdGVtKSkge1xuXHRcdFx0dGhpcy5fdGFnID0gbG9hZEl0ZW07XG5cdFx0fSBlbHNlIGlmIChjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNBdWRpb1RhZyhsb2FkSXRlbS5zcmMpKSB7XG5cdFx0XHR0aGlzLl90YWcgPSBsb2FkSXRlbTtcblx0XHR9IGVsc2UgaWYgKGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0F1ZGlvVGFnKGxvYWRJdGVtLnRhZykpIHtcblx0XHRcdHRoaXMuX3RhZyA9IGNyZWF0ZWpzLlJlcXVlc3RVdGlscy5pc0F1ZGlvVGFnKGxvYWRJdGVtKSA/IGxvYWRJdGVtIDogbG9hZEl0ZW0uc3JjO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl90YWcgIT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fcHJlZmVyWEhSID0gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFNvdW5kTG9hZGVyLCBjcmVhdGVqcy5BYnN0cmFjdE1lZGlhTG9hZGVyKTtcblx0dmFyIHMgPSBTb3VuZExvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1NPVU5EOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNPVU5EO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdHAuX2NyZWF0ZVRhZyA9IGZ1bmN0aW9uIChzcmMpIHtcblx0XHR2YXIgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImF1ZGlvXCIpO1xuXHRcdHRhZy5hdXRvcGxheSA9IGZhbHNlO1xuXHRcdHRhZy5wcmVsb2FkID0gXCJub25lXCI7XG5cblx0XHQvL0xNOiBGaXJlZm94IGZhaWxzIHdoZW4gdGhpcyB0aGUgcHJlbG9hZD1cIm5vbmVcIiBmb3Igb3RoZXIgdGFncywgYnV0IGl0IG5lZWRzIHRvIGJlIFwibm9uZVwiIHRvIGVuc3VyZSBQcmVsb2FkSlMgd29ya3MuXG5cdFx0dGFnLnNyYyA9IHNyYztcblx0XHRyZXR1cm4gdGFnO1xuXHR9O1xuXG5cdGNyZWF0ZWpzLlNvdW5kTG9hZGVyID0gY3JlYXRlanMucHJvbW90ZShTb3VuZExvYWRlciwgXCJBYnN0cmFjdE1lZGlhTG9hZGVyXCIpO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gVmlkZW9Mb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIHZpZGVvIGZpbGVzLlxuXHQgKiBAY2xhc3MgVmlkZW9Mb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJlZmVyWEhSXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TWVkaWFMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBWaWRlb0xvYWRlcihsb2FkSXRlbSwgcHJlZmVyWEhSKSB7XG5cdFx0dGhpcy5BYnN0cmFjdE1lZGlhTG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBwcmVmZXJYSFIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlZJREVPKTtcblxuXHRcdGlmIChjcmVhdGVqcy5SZXF1ZXN0VXRpbHMuaXNWaWRlb1RhZyhsb2FkSXRlbSkgfHwgY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzVmlkZW9UYWcobG9hZEl0ZW0uc3JjKSkge1xuXHRcdFx0dGhpcy5zZXRUYWcoY3JlYXRlanMuUmVxdWVzdFV0aWxzLmlzVmlkZW9UYWcobG9hZEl0ZW0pP2xvYWRJdGVtOmxvYWRJdGVtLnNyYyk7XG5cblx0XHRcdC8vIFdlIGNhbid0IHVzZSBYSFIgZm9yIGEgdGFnIHRoYXQncyBwYXNzZWQgaW4uXG5cdFx0XHR0aGlzLl9wcmVmZXJYSFIgPSBmYWxzZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRUYWcodGhpcy5fY3JlYXRlVGFnKCkpO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgcCA9IGNyZWF0ZWpzLmV4dGVuZChWaWRlb0xvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RNZWRpYUxvYWRlcik7XG5cdHZhciBzID0gVmlkZW9Mb2FkZXI7XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIG5ldyB2aWRlbyB0YWdcblx0ICpcblx0ICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fY3JlYXRlVGFnID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XG5cdH07XG5cblx0Ly8gc3RhdGljIG1ldGhvZHNcblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGxvYWRlciBjYW4gbG9hZCBhIHNwZWNpZmljIGl0ZW0uIFRoaXMgbG9hZGVyIGNhbiBvbmx5IGxvYWQgaXRlbXMgdGhhdCBhcmUgb2YgdHlwZVxuXHQgKiB7eyNjcm9zc0xpbmsgXCJBYnN0cmFjdExvYWRlci9WSURFTzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5WSURFTztcblx0fTtcblxuXHRjcmVhdGVqcy5WaWRlb0xvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoVmlkZW9Mb2FkZXIsIFwiQWJzdHJhY3RNZWRpYUxvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFNwcml0ZVNoZWV0TG9hZGVyLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqcyB8fCB7fTtcblxuKGZ1bmN0aW9uICgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0Ly8gY29uc3RydWN0b3Jcblx0LyoqXG5cdCAqIEEgbG9hZGVyIGZvciBFYXNlbEpTIFNwcml0ZVNoZWV0cy4gSW1hZ2VzIGluc2lkZSB0aGUgc3ByaXRlc2hlZXQgZGVmaW5pdGlvbiBhcmUgbG9hZGVkIGJlZm9yZSB0aGUgbG9hZGVyXG5cdCAqIGNvbXBsZXRlcy4gVG8gbG9hZCBTcHJpdGVTaGVldHMgdXNpbmcgSlNPTlAsIHNwZWNpZnkgYSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS9jYWxsYmFjazpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBhcyBwYXJ0IG9mIHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fS4gTm90ZSB0aGF0IHRoZSB7eyNjcm9zc0xpbmsgXCJKU09OTG9hZGVyXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGFuZCB7eyNjcm9zc0xpbmsgXCJKU09OUExvYWRlclwifX17ey9jcm9zc0xpbmt9fSBhcmUgaGlnaGVyIHByaW9yaXR5IGxvYWRlcnMsIHNvIFNwcml0ZVNoZWV0cyA8c3Ryb25nPm11c3Q8L3N0cm9uZz5cblx0ICogc2V0IHRoZSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbVwifX17ey9jcm9zc0xpbmt9fSB7eyNjcm9zc0xpbmsgXCJMb2FkSXRlbS90eXBlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5XG5cdCAqIHRvIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1NQUklURVNIRUVUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKiBAY2xhc3MgU3ByaXRlU2hlZXRMb2FkZXJcblx0ICogQHBhcmFtIHtMb2FkSXRlbXxPYmplY3R9IGxvYWRJdGVtXG5cdCAqIEBleHRlbmRzIEFic3RyYWN0TG9hZGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gU3ByaXRlU2hlZXRMb2FkZXIobG9hZEl0ZW0pIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2NvbnN0cnVjdG9yKGxvYWRJdGVtLCBudWxsLCBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TUFJJVEVTSEVFVCk7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdC8qKlxuXHRcdCAqIEFuIGludGVybmFsIHF1ZXVlIHdoaWNoIGxvYWRzIHRoZSBTcHJpdGVTaGVldCdzIGltYWdlcy5cblx0XHQgKiBAbWV0aG9kIF9tYW5pZmVzdFF1ZXVlXG5cdFx0ICogQHR5cGUge0xvYWRRdWV1ZX1cblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdHRoaXMuX21hbmlmZXN0UXVldWUgPSBudWxsO1xuXHR9XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoU3ByaXRlU2hlZXRMb2FkZXIsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyKTtcblx0dmFyIHMgPSBTcHJpdGVTaGVldExvYWRlcjtcblxuXHQvLyBzdGF0aWMgcHJvcGVydGllc1xuXHQvKipcblx0ICogVGhlIGFtb3VudCBvZiBwcm9ncmVzcyB0aGF0IHRoZSBtYW5pZmVzdCBpdHNlbGYgdGFrZXMgdXAuXG5cdCAqIEBwcm9wZXJ0eSBTUFJJVEVTSEVFVF9QUk9HUkVTU1xuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKiBAZGVmYXVsdCAwLjI1ICgyNSUpXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHMuU1BSSVRFU0hFRVRfUFJPR1JFU1MgPSAwLjI1O1xuXG5cdC8vIHN0YXRpYyBtZXRob2RzXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBsb2FkZXIgY2FuIGxvYWQgYSBzcGVjaWZpYyBpdGVtLiBUaGlzIGxvYWRlciBjYW4gb25seSBsb2FkIGl0ZW1zIHRoYXQgYXJlIG9mIHR5cGVcblx0ICoge3sjY3Jvc3NMaW5rIFwiQWJzdHJhY3RMb2FkZXIvU1BSSVRFU0hFRVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5TUFJJVEVTSEVFVDtcblx0fTtcblxuXHQvLyBwdWJsaWMgbWV0aG9kc1xuXHRwLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLkFic3RyYWN0TG9hZGVyX2Rlc3Ryb3k7XG5cdFx0dGhpcy5fbWFuaWZlc3RRdWV1ZS5jbG9zZSgpO1xuXHR9O1xuXG5cdC8vIHByb3RlY3RlZCBtZXRob2RzXG5cdHAuX2NyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSB0aGlzLl9pdGVtLmNhbGxiYWNrO1xuXHRcdGlmIChjYWxsYmFjayAhPSBudWxsICYmIGNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuSlNPTlBMb2FkZXIodGhpcy5faXRlbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3JlcXVlc3QgPSBuZXcgY3JlYXRlanMuSlNPTkxvYWRlcih0aGlzLl9pdGVtKTtcblx0XHR9XG5cdH07XG5cblx0cC5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHN3aXRjaCAoZXZlbnQudHlwZSkge1xuXHRcdFx0Y2FzZSBcImNvbXBsZXRlXCI6XG5cdFx0XHRcdHRoaXMuX3Jhd1Jlc3VsdCA9IGV2ZW50LnRhcmdldC5nZXRSZXN1bHQodHJ1ZSk7XG5cdFx0XHRcdHRoaXMuX3Jlc3VsdCA9IGV2ZW50LnRhcmdldC5nZXRSZXN1bHQoKTtcblx0XHRcdFx0dGhpcy5fc2VuZFByb2dyZXNzKHMuU1BSSVRFU0hFRVRfUFJPR1JFU1MpO1xuXHRcdFx0XHR0aGlzLl9sb2FkTWFuaWZlc3QodGhpcy5fcmVzdWx0KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0Y2FzZSBcInByb2dyZXNzXCI6XG5cdFx0XHRcdGV2ZW50LmxvYWRlZCAqPSBzLlNQUklURVNIRUVUX1BST0dSRVNTO1xuXHRcdFx0XHR0aGlzLnByb2dyZXNzID0gZXZlbnQubG9hZGVkIC8gZXZlbnQudG90YWw7XG5cdFx0XHRcdGlmIChpc05hTih0aGlzLnByb2dyZXNzKSB8fCB0aGlzLnByb2dyZXNzID09IEluZmluaXR5KSB7IHRoaXMucHJvZ3Jlc3MgPSAwOyB9XG5cdFx0XHRcdHRoaXMuX3NlbmRQcm9ncmVzcyhldmVudCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5BYnN0cmFjdExvYWRlcl9oYW5kbGVFdmVudChldmVudCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhbmQgbG9hZCB0aGUgaW1hZ2VzIG9uY2UgdGhlIFNwcml0ZVNoZWV0IEpTT04gaGFzIGJlZW4gbG9hZGVkLlxuXHQgKiBAbWV0aG9kIF9sb2FkTWFuaWZlc3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IGpzb25cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2xvYWRNYW5pZmVzdCA9IGZ1bmN0aW9uIChqc29uKSB7XG5cdFx0aWYgKGpzb24gJiYganNvbi5pbWFnZXMpIHtcblx0XHRcdHZhciBxdWV1ZSA9IHRoaXMuX21hbmlmZXN0UXVldWUgPSBuZXcgY3JlYXRlanMuTG9hZFF1ZXVlKCk7XG5cdFx0XHRxdWV1ZS5vbihcImNvbXBsZXRlXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0Q29tcGxldGUsIHRoaXMsIHRydWUpO1xuXHRcdFx0cXVldWUub24oXCJmaWxlbG9hZFwiLCB0aGlzLl9oYW5kbGVNYW5pZmVzdEZpbGVMb2FkLCB0aGlzKTtcblx0XHRcdHF1ZXVlLm9uKFwicHJvZ3Jlc3NcIiwgdGhpcy5faGFuZGxlTWFuaWZlc3RQcm9ncmVzcywgdGhpcyk7XG5cdFx0XHRxdWV1ZS5vbihcImVycm9yXCIsIHRoaXMuX2hhbmRsZU1hbmlmZXN0RXJyb3IsIHRoaXMsIHRydWUpO1xuXHRcdFx0cXVldWUubG9hZE1hbmlmZXN0KGpzb24uaW1hZ2VzKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEFuIGl0ZW0gZnJvbSB0aGUge3sjY3Jvc3NMaW5rIFwiX21hbmlmZXN0UXVldWU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaGFzIGNvbXBsZXRlZC5cblx0ICogQG1ldGhvZCBfaGFuZGxlTWFuaWZlc3RGaWxlTG9hZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RGaWxlTG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHZhciBpbWFnZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRpZiAoaW1hZ2UgIT0gbnVsbCkge1xuXHRcdFx0dmFyIGltYWdlcyA9IHRoaXMuZ2V0UmVzdWx0KCkuaW1hZ2VzO1xuXHRcdFx0dmFyIHBvcyA9IGltYWdlcy5pbmRleE9mKGV2ZW50Lml0ZW0uc3JjKTtcblx0XHRcdGltYWdlc1twb3NdID0gaW1hZ2U7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgaW1hZ2VzIGhhdmUgY29tcGxldGVkIGxvYWRpbmcuIFRoaXMgdHJpZ2dlcnMgdGhlIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL2NvbXBsZXRlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIHt7I2Nyb3NzTGluayBcIkV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGZyb20gdGhlIFNwcml0ZVNoZWV0TG9hZGVyLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNYW5pZmVzdENvbXBsZXRlXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRwLl9oYW5kbGVNYW5pZmVzdENvbXBsZXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0dGhpcy5fcmVzdWx0ID0gbmV3IGNyZWF0ZWpzLlNwcml0ZVNoZWV0KHRoaXMuX3Jlc3VsdCk7XG5cdFx0dGhpcy5fbG9hZGVkSXRlbXMgPSB0aGlzLl9tYW5pZmVzdFF1ZXVlLmdldEl0ZW1zKHRydWUpO1xuXHRcdHRoaXMuX3NlbmRDb21wbGV0ZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgaW1hZ2VzIHt7I2Nyb3NzTGluayBcIkxvYWRRdWV1ZVwifX17ey9jcm9zc0xpbmt9fSBoYXMgcmVwb3J0ZWQgcHJvZ3Jlc3MuXG5cdCAqIEBtZXRob2QgX2hhbmRsZU1hbmlmZXN0UHJvZ3Jlc3Ncblx0ICogQHBhcmFtIHtQcm9ncmVzc0V2ZW50fSBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5faGFuZGxlTWFuaWZlc3RQcm9ncmVzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdHRoaXMucHJvZ3Jlc3MgPSBldmVudC5wcm9ncmVzcyAqICgxIC0gcy5TUFJJVEVTSEVFVF9QUk9HUkVTUykgKyBzLlNQUklURVNIRUVUX1BST0dSRVNTO1xuXHRcdHRoaXMuX3NlbmRQcm9ncmVzcyh0aGlzLnByb2dyZXNzKTtcblx0fTtcblxuXHQvKipcblx0ICogQW4gaW1hZ2UgaGFzIHJlcG9ydGVkIGFuIGVycm9yLlxuXHQgKiBAbWV0aG9kIF9oYW5kbGVNYW5pZmVzdEVycm9yXG5cdCAqIEBwYXJhbSB7RXJyb3JFdmVudH0gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHAuX2hhbmRsZU1hbmlmZXN0RXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHR2YXIgbmV3RXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJmaWxlZXJyb3JcIik7XG5cdFx0bmV3RXZlbnQuaXRlbSA9IGV2ZW50LmRhdGE7XG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcblx0fTtcblxuXHRjcmVhdGVqcy5TcHJpdGVTaGVldExvYWRlciA9IGNyZWF0ZWpzLnByb21vdGUoU3ByaXRlU2hlZXRMb2FkZXIsIFwiQWJzdHJhY3RMb2FkZXJcIik7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBTVkdMb2FkZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzIHx8IHt9O1xuXG4oZnVuY3Rpb24gKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBsb2FkZXIgZm9yIFNWRyBmaWxlcy5cblx0ICogQGNsYXNzIFNWR0xvYWRlclxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gbG9hZEl0ZW1cblx0ICogQHBhcmFtIHtCb29sZWFufSBwcmVmZXJYSFJcblx0ICogQGV4dGVuZHMgQWJzdHJhY3RMb2FkZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBTVkdMb2FkZXIobG9hZEl0ZW0sIHByZWZlclhIUikge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHByZWZlclhIUiwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIuU1ZHKTtcblxuXHRcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5yZXN1bHRGb3JtYXR0ZXIgPSB0aGlzLl9mb3JtYXRSZXN1bHQ7XG5cblx0XHQvLyBwcm90ZWN0ZWQgcHJvcGVydGllc1xuXHRcdHRoaXMuX3RhZ1NyY0F0dHJpYnV0ZSA9IFwiZGF0YVwiO1xuXG5cdFx0aWYgKHByZWZlclhIUikge1xuXHRcdFx0dGhpcy5zZXRUYWcoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN2Z1wiKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2V0VGFnKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvYmplY3RcIikpO1xuXHRcdFx0dGhpcy5nZXRUYWcoKS50eXBlID0gXCJpbWFnZS9zdmcreG1sXCI7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFNWR0xvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IFNWR0xvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1NWRzpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBAbWV0aG9kIGNhbkxvYWRJdGVtXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBpdGVtIFRoZSBMb2FkSXRlbSB0aGF0IGEgTG9hZFF1ZXVlIGlzIHRyeWluZyB0byBsb2FkLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgbG9hZGVyIGNhbiBsb2FkIHRoZSBpdGVtLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzLmNhbkxvYWRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS50eXBlID09IGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlNWRztcblx0fTtcblxuXHQvLyBwcm90ZWN0ZWQgbWV0aG9kc1xuXHQvKipcblx0ICogVGhlIHJlc3VsdCBmb3JtYXR0ZXIgZm9yIFNWRyBmaWxlcy5cblx0ICogQG1ldGhvZCBfZm9ybWF0UmVzdWx0XG5cdCAqIEBwYXJhbSB7QWJzdHJhY3RMb2FkZXJ9IGxvYWRlclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZm9ybWF0UmVzdWx0ID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdC8vIG1pbWUgc2hvdWxkIGJlIGltYWdlL3N2Zyt4bWwsIGJ1dCBPcGVyYSByZXF1aXJlcyB0ZXh0L3htbFxuXHRcdHZhciB4bWwgPSBjcmVhdGVqcy5EYXRhVXRpbHMucGFyc2VYTUwobG9hZGVyLmdldFJlc3VsdCh0cnVlKSwgXCJ0ZXh0L3htbFwiKTtcblx0XHR2YXIgdGFnID0gbG9hZGVyLmdldFRhZygpO1xuXG5cdFx0aWYgKCF0aGlzLl9wcmVmZXJYSFIgJiYgZG9jdW1lbnQuYm9keS5jb250YWlucyh0YWcpKSB7XG5cdFx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRhZyk7XG5cdFx0fVxuXG5cdFx0aWYgKHhtbC5kb2N1bWVudEVsZW1lbnQgIT0gbnVsbCkge1xuXHRcdFx0dGFnLmFwcGVuZENoaWxkKHhtbC5kb2N1bWVudEVsZW1lbnQpO1xuXHRcdFx0dGFnLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcblx0XHRcdHJldHVybiB0YWc7XG5cdFx0fSBlbHNlIHsgLy8gRm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBTVkcsIGp1c3QgZ2l2ZSB0aGVtIHRoZSBYTUwuIChJRSA5LTgpXG5cdFx0XHRyZXR1cm4geG1sO1xuXHRcdH1cblx0fTtcblxuXHRjcmVhdGVqcy5TVkdMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKFNWR0xvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFhNTExvYWRlci5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbiAoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8vIGNvbnN0cnVjdG9yXG5cdC8qKlxuXHQgKiBBIGxvYWRlciBmb3IgQ1NTIGZpbGVzLlxuXHQgKiBAY2xhc3MgWE1MTG9hZGVyXG5cdCAqIEBwYXJhbSB7TG9hZEl0ZW18T2JqZWN0fSBsb2FkSXRlbVxuXHQgKiBAZXh0ZW5kcyBBYnN0cmFjdExvYWRlclxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGZ1bmN0aW9uIFhNTExvYWRlcihsb2FkSXRlbSkge1xuXHRcdHRoaXMuQWJzdHJhY3RMb2FkZXJfY29uc3RydWN0b3IobG9hZEl0ZW0sIHRydWUsIGNyZWF0ZWpzLkFic3RyYWN0TG9hZGVyLlhNTCk7XG5cblx0XHQvLyBwdWJsaWMgcHJvcGVydGllc1xuXHRcdHRoaXMucmVzdWx0Rm9ybWF0dGVyID0gdGhpcy5fZm9ybWF0UmVzdWx0O1xuXHR9O1xuXG5cdHZhciBwID0gY3JlYXRlanMuZXh0ZW5kKFhNTExvYWRlciwgY3JlYXRlanMuQWJzdHJhY3RMb2FkZXIpO1xuXHR2YXIgcyA9IFhNTExvYWRlcjtcblxuXHQvLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgbG9hZGVyIGNhbiBsb2FkIGEgc3BlY2lmaWMgaXRlbS4gVGhpcyBsb2FkZXIgY2FuIG9ubHkgbG9hZCBpdGVtcyB0aGF0IGFyZSBvZiB0eXBlXG5cdCAqIHt7I2Nyb3NzTGluayBcIkFic3RyYWN0TG9hZGVyL1hNTDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogQG1ldGhvZCBjYW5Mb2FkSXRlbVxuXHQgKiBAcGFyYW0ge0xvYWRJdGVtfE9iamVjdH0gaXRlbSBUaGUgTG9hZEl0ZW0gdGhhdCBhIExvYWRRdWV1ZSBpcyB0cnlpbmcgdG8gbG9hZC5cblx0ICogQHJldHVybnMge0Jvb2xlYW59IFdoZXRoZXIgdGhlIGxvYWRlciBjYW4gbG9hZCB0aGUgaXRlbS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0cy5jYW5Mb2FkSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0udHlwZSA9PSBjcmVhdGVqcy5BYnN0cmFjdExvYWRlci5YTUw7XG5cdH07XG5cblx0Ly8gcHJvdGVjdGVkIG1ldGhvZHNcblx0LyoqXG5cdCAqIFRoZSByZXN1bHQgZm9ybWF0dGVyIGZvciBYTUwgZmlsZXMuXG5cdCAqIEBtZXRob2QgX2Zvcm1hdFJlc3VsdFxuXHQgKiBAcGFyYW0ge0Fic3RyYWN0TG9hZGVyfSBsb2FkZXJcblx0ICogQHJldHVybnMge1hNTERvY3VtZW50fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cC5fZm9ybWF0UmVzdWx0ID0gZnVuY3Rpb24gKGxvYWRlcikge1xuXHRcdHJldHVybiBjcmVhdGVqcy5EYXRhVXRpbHMucGFyc2VYTUwobG9hZGVyLmdldFJlc3VsdCh0cnVlKSwgXCJ0ZXh0L3htbFwiKTtcblx0fTtcblxuXHRjcmVhdGVqcy5YTUxMb2FkZXIgPSBjcmVhdGVqcy5wcm9tb3RlKFhNTExvYWRlciwgXCJBYnN0cmFjdExvYWRlclwiKTtcblxufSgpKTtcbi8qIVxuKiBUd2VlbkpTXG4qIFZpc2l0IGh0dHA6Ly9jcmVhdGVqcy5jb20vIGZvciBkb2N1bWVudGF0aW9uLCB1cGRhdGVzIGFuZCBleGFtcGxlcy5cbipcbiogQ29weXJpZ2h0IChjKSAyMDEwIGdza2lubmVyLmNvbSwgaW5jLlxuKlxuKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4qIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4qIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuKiBjb25kaXRpb25zOlxuKlxuKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbipcbiogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4qIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4qIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4qIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBleHRlbmQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuLyoqXG4gKiBAY2xhc3MgVXRpbGl0eSBNZXRob2RzXG4gKi9cblxuLyoqXG4gKiBTZXRzIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4gYW5kIGNvbnN0cnVjdG9yIHByb3BlcnR5IGZvciBhIG5ldyBjbGFzcy5cbiAqXG4gKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgcmlnaHQgYWZ0ZXIgY3JlYXRpbmcgdGhlIGNsYXNzIGNvbnN0cnVjdG9yLlxuICpcbiAqIFx0ZnVuY3Rpb24gTXlTdWJDbGFzcygpIHt9XG4gKiBcdGNyZWF0ZWpzLmV4dGVuZChNeVN1YkNsYXNzLCBNeVN1cGVyQ2xhc3MpO1xuICogXHRDbGFzc0IucHJvdG90eXBlLmRvU29tZXRoaW5nID0gZnVuY3Rpb24oKSB7IH1cbiAqXG4gKiBcdHZhciBmb28gPSBuZXcgTXlTdWJDbGFzcygpO1xuICogXHRjb25zb2xlLmxvZyhmb28gaW5zdGFuY2VvZiBNeVN1cGVyQ2xhc3MpOyAvLyB0cnVlXG4gKiBcdGNvbnNvbGUubG9nKGZvby5wcm90b3R5cGUuY29uc3RydWN0b3IgPT09IE15U3ViQ2xhc3MpOyAvLyB0cnVlXG4gKlxuICogQG1ldGhvZCBleHRlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YmNsYXNzIFRoZSBzdWJjbGFzcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cGVyY2xhc3MgVGhlIHN1cGVyY2xhc3MgdG8gZXh0ZW5kLlxuICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgdGhlIHN1YmNsYXNzJ3MgbmV3IHByb3RvdHlwZS5cbiAqL1xuY3JlYXRlanMuZXh0ZW5kID0gZnVuY3Rpb24oc3ViY2xhc3MsIHN1cGVyY2xhc3MpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0ZnVuY3Rpb24gbygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IHN1YmNsYXNzOyB9XG5cdG8ucHJvdG90eXBlID0gc3VwZXJjbGFzcy5wcm90b3R5cGU7XG5cdHJldHVybiAoc3ViY2xhc3MucHJvdG90eXBlID0gbmV3IG8oKSk7XG59O1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gcHJvbW90ZS5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4vKipcbiAqIEBjbGFzcyBVdGlsaXR5IE1ldGhvZHNcbiAqL1xuXG4vKipcbiAqIFByb21vdGVzIGFueSBtZXRob2RzIG9uIHRoZSBzdXBlciBjbGFzcyB0aGF0IHdlcmUgb3ZlcnJpZGRlbiwgYnkgY3JlYXRpbmcgYW4gYWxpYXMgaW4gdGhlIGZvcm1hdCBgcHJlZml4X21ldGhvZE5hbWVgLlxuICogSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSBzdXBlciBjbGFzcydzIG5hbWUgYXMgdGhlIHByZWZpeC5cbiAqIEFuIGFsaWFzIHRvIHRoZSBzdXBlciBjbGFzcydzIGNvbnN0cnVjdG9yIGlzIGFsd2F5cyBhZGRlZCBpbiB0aGUgZm9ybWF0IGBwcmVmaXhfY29uc3RydWN0b3JgLlxuICogVGhpcyBhbGxvd3MgdGhlIHN1YmNsYXNzIHRvIGNhbGwgc3VwZXIgY2xhc3MgbWV0aG9kcyB3aXRob3V0IHVzaW5nIGBmdW5jdGlvbi5jYWxsYCwgcHJvdmlkaW5nIGJldHRlciBwZXJmb3JtYW5jZS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaWYgYE15U3ViQ2xhc3NgIGV4dGVuZHMgYE15U3VwZXJDbGFzc2AsIGFuZCBib3RoIGRlZmluZSBhIGBkcmF3YCBtZXRob2QsIHRoZW4gY2FsbGluZyBgcHJvbW90ZShNeVN1YkNsYXNzLCBcIk15U3VwZXJDbGFzc1wiKWBcbiAqIHdvdWxkIGFkZCBhIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgIG1ldGhvZCB0byBNeVN1YkNsYXNzIGFuZCBwcm9tb3RlIHRoZSBgZHJhd2AgbWV0aG9kIG9uIGBNeVN1cGVyQ2xhc3NgIHRvIHRoZVxuICogcHJvdG90eXBlIG9mIGBNeVN1YkNsYXNzYCBhcyBgTXlTdXBlckNsYXNzX2RyYXdgLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciB0aGUgY2xhc3MncyBwcm90b3R5cGUgaXMgZnVsbHkgZGVmaW5lZC5cbiAqXG4gKiBcdGZ1bmN0aW9uIENsYXNzQShuYW1lKSB7XG4gKiBcdFx0dGhpcy5uYW1lID0gbmFtZTtcbiAqIFx0fVxuICogXHRDbGFzc0EucHJvdG90eXBlLmdyZWV0ID0gZnVuY3Rpb24oKSB7XG4gKiBcdFx0cmV0dXJuIFwiSGVsbG8gXCIrdGhpcy5uYW1lO1xuICogXHR9XG4gKlxuICogXHRmdW5jdGlvbiBDbGFzc0IobmFtZSwgcHVuY3R1YXRpb24pIHtcbiAqIFx0XHR0aGlzLkNsYXNzQV9jb25zdHJ1Y3RvcihuYW1lKTtcbiAqIFx0XHR0aGlzLnB1bmN0dWF0aW9uID0gcHVuY3R1YXRpb247XG4gKiBcdH1cbiAqIFx0Y3JlYXRlanMuZXh0ZW5kKENsYXNzQiwgQ2xhc3NBKTtcbiAqIFx0Q2xhc3NCLnByb3RvdHlwZS5ncmVldCA9IGZ1bmN0aW9uKCkge1xuICogXHRcdHJldHVybiB0aGlzLkNsYXNzQV9ncmVldCgpK3RoaXMucHVuY3R1YXRpb247XG4gKiBcdH1cbiAqIFx0Y3JlYXRlanMucHJvbW90ZShDbGFzc0IsIFwiQ2xhc3NBXCIpO1xuICpcbiAqIFx0dmFyIGZvbyA9IG5ldyBDbGFzc0IoXCJXb3JsZFwiLCBcIiE/IVwiKTtcbiAqIFx0Y29uc29sZS5sb2coZm9vLmdyZWV0KCkpOyAvLyBIZWxsbyBXb3JsZCE/IVxuICpcbiAqIEBtZXRob2QgcHJvbW90ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ViY2xhc3MgVGhlIGNsYXNzIHRvIHByb21vdGUgc3VwZXIgY2xhc3MgbWV0aG9kcyBvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggVGhlIHByZWZpeCB0byBhZGQgdG8gdGhlIHByb21vdGVkIG1ldGhvZCBuYW1lcy4gVXN1YWxseSB0aGUgbmFtZSBvZiB0aGUgc3VwZXJjbGFzcy5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBzdWJjbGFzcy5cbiAqL1xuY3JlYXRlanMucHJvbW90ZSA9IGZ1bmN0aW9uKHN1YmNsYXNzLCBwcmVmaXgpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIHN1YlAgPSBzdWJjbGFzcy5wcm90b3R5cGUsIHN1cFAgPSAoT2JqZWN0LmdldFByb3RvdHlwZU9mJiZPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc3ViUCkpfHxzdWJQLl9fcHJvdG9fXztcblx0aWYgKHN1cFApIHtcblx0XHRzdWJQWyhwcmVmaXgrPVwiX1wiKSArIFwiY29uc3RydWN0b3JcIl0gPSBzdXBQLmNvbnN0cnVjdG9yOyAvLyBjb25zdHJ1Y3RvciBpcyBub3QgYWx3YXlzIGlubnVtZXJhYmxlXG5cdFx0Zm9yICh2YXIgbiBpbiBzdXBQKSB7XG5cdFx0XHRpZiAoc3ViUC5oYXNPd25Qcm9wZXJ0eShuKSAmJiAodHlwZW9mIHN1cFBbbl0gPT0gXCJmdW5jdGlvblwiKSkgeyBzdWJQW3ByZWZpeCArIG5dID0gc3VwUFtuXTsgfVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gc3ViY2xhc3M7XG59O1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gRXZlbnQuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuLy8gY29uc3RydWN0b3I6XG5cdC8qKlxuXHQgKiBDb250YWlucyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHNoYXJlZCBieSBhbGwgZXZlbnRzIGZvciB1c2Ugd2l0aFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIFxuXHQgKiBOb3RlIHRoYXQgRXZlbnQgb2JqZWN0cyBhcmUgb2Z0ZW4gcmV1c2VkLCBzbyB5b3Ugc2hvdWxkIG5ldmVyXG5cdCAqIHJlbHkgb24gYW4gZXZlbnQgb2JqZWN0J3Mgc3RhdGUgb3V0c2lkZSBvZiB0aGUgY2FsbCBzdGFjayBpdCB3YXMgcmVjZWl2ZWQgaW4uXG5cdCAqIEBjbGFzcyBFdmVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBidWJibGVzIEluZGljYXRlcyB3aGV0aGVyIHRoZSBldmVudCB3aWxsIGJ1YmJsZSB0aHJvdWdoIHRoZSBkaXNwbGF5IGxpc3QuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FuY2VsYWJsZSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdGhpcyBldmVudCBjYW4gYmUgY2FuY2VsbGVkLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBFdmVudCh0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlKSB7XG5cdFx0XG5cdFxuXHQvLyBwdWJsaWMgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBUaGUgdHlwZSBvZiBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgdHlwZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqKi9cblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcblx0XHQvKipcblx0XHQgKiBUaGUgb2JqZWN0IHRoYXQgZ2VuZXJhdGVkIGFuIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSB0YXJnZXRcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiBAZGVmYXVsdCBudWxsXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLnRhcmdldCA9IG51bGw7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IHRhcmdldCB0aGF0IGEgYnViYmxpbmcgZXZlbnQgaXMgYmVpbmcgZGlzcGF0Y2hlZCBmcm9tLiBGb3Igbm9uLWJ1YmJsaW5nIGV2ZW50cywgdGhpcyB3aWxsXG5cdFx0ICogYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHRhcmdldC4gRm9yIGV4YW1wbGUsIGlmIGNoaWxkT2JqLnBhcmVudCA9IHBhcmVudE9iaiwgYW5kIGEgYnViYmxpbmcgZXZlbnRcblx0XHQgKiBpcyBnZW5lcmF0ZWQgZnJvbSBjaGlsZE9iaiwgdGhlbiBhIGxpc3RlbmVyIG9uIHBhcmVudE9iaiB3b3VsZCByZWNlaXZlIHRoZSBldmVudCB3aXRoXG5cdFx0ICogdGFyZ2V0PWNoaWxkT2JqICh0aGUgb3JpZ2luYWwgdGFyZ2V0KSBhbmQgY3VycmVudFRhcmdldD1wYXJlbnRPYmogKHdoZXJlIHRoZSBsaXN0ZW5lciB3YXMgYWRkZWQpLlxuXHRcdCAqIEBwcm9wZXJ0eSBjdXJyZW50VGFyZ2V0XG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICogQGRlZmF1bHQgbnVsbFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogRm9yIGJ1YmJsaW5nIGV2ZW50cywgdGhpcyBpbmRpY2F0ZXMgdGhlIGN1cnJlbnQgZXZlbnQgcGhhc2U6PE9MPlxuXHRcdCAqIFx0PExJPiBjYXB0dXJlIHBoYXNlOiBzdGFydGluZyBmcm9tIHRoZSB0b3AgcGFyZW50IHRvIHRoZSB0YXJnZXQ8L0xJPlxuXHRcdCAqIFx0PExJPiBhdCB0YXJnZXQgcGhhc2U6IGN1cnJlbnRseSBiZWluZyBkaXNwYXRjaGVkIGZyb20gdGhlIHRhcmdldDwvTEk+XG5cdFx0ICogXHQ8TEk+IGJ1YmJsaW5nIHBoYXNlOiBmcm9tIHRoZSB0YXJnZXQgdG8gdGhlIHRvcCBwYXJlbnQ8L0xJPlxuXHRcdCAqIDwvT0w+XG5cdFx0ICogQHByb3BlcnR5IGV2ZW50UGhhc2Vcblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmV2ZW50UGhhc2UgPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZXZlbnQgd2lsbCBidWJibGUgdGhyb3VnaCB0aGUgZGlzcGxheSBsaXN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBidWJibGVzXG5cdFx0ICogQHR5cGUgQm9vbGVhblxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0Ki9cblx0XHR0aGlzLmJ1YmJsZXMgPSAhIWJ1YmJsZXM7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiB0aGlzIGV2ZW50IGNhbiBiZSBjYW5jZWxsZWQgdmlhXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcHJldmVudERlZmF1bHRcIn19e3svY3Jvc3NMaW5rfX0uIFRoaXMgaXMgc2V0IHZpYSB0aGUgRXZlbnQgY29uc3RydWN0b3IuXG5cdFx0ICogQHByb3BlcnR5IGNhbmNlbGFibGVcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuY2FuY2VsYWJsZSA9ICEhY2FuY2VsYWJsZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIGVwb2NoIHRpbWUgYXQgd2hpY2ggdGhpcyBldmVudCB3YXMgY3JlYXRlZC5cblx0XHQgKiBAcHJvcGVydHkgdGltZVN0YW1wXG5cdFx0ICogQHR5cGUgTnVtYmVyXG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy50aW1lU3RhbXAgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcHJldmVudERlZmF1bHRcIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkXG5cdFx0ICogb24gdGhpcyBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgZGVmYXVsdFByZXZlbnRlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyBpZiB7eyNjcm9zc0xpbmsgXCJFdmVudC9zdG9wUHJvcGFnYXRpb25cIn19e3svY3Jvc3NMaW5rfX0gb3Jcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudC9zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIn19e3svY3Jvc3NMaW5rfX0gaGFzIGJlZW4gY2FsbGVkIG9uIHRoaXMgZXZlbnQuXG5cdFx0ICogQHByb3BlcnR5IHByb3BhZ2F0aW9uU3RvcHBlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHt7I2Nyb3NzTGluayBcIkV2ZW50L3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwifX17ey9jcm9zc0xpbmt9fSBoYXMgYmVlbiBjYWxsZWRcblx0XHQgKiBvbiB0aGlzIGV2ZW50LlxuXHRcdCAqIEBwcm9wZXJ0eSBpbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWRcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQqL1xuXHRcdHRoaXMuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG5cdFx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIHt7I2Nyb3NzTGluayBcIkV2ZW50L3JlbW92ZVwifX17ey9jcm9zc0xpbmt9fSBoYXMgYmVlbiBjYWxsZWQgb24gdGhpcyBldmVudC5cblx0XHQgKiBAcHJvcGVydHkgcmVtb3ZlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEByZWFkb25seVxuXHRcdCovXG5cdFx0dGhpcy5yZW1vdmVkID0gZmFsc2U7XG5cdH1cblx0dmFyIHAgPSBFdmVudC5wcm90b3R5cGU7XG5cblx0LyoqXG5cdCAqIDxzdHJvbmc+UkVNT1ZFRDwvc3Ryb25nPi4gUmVtb3ZlZCBpbiBmYXZvciBvZiB1c2luZyBgTXlTdXBlckNsYXNzX2NvbnN0cnVjdG9yYC5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9leHRlbmRcIn19e3svY3Jvc3NMaW5rfX0gYW5kIHt7I2Nyb3NzTGluayBcIlV0aWxpdHkgTWV0aG9kcy9wcm9tb3RlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKiBUaGVyZSBpcyBhbiBpbmhlcml0YW5jZSB0dXRvcmlhbCBkaXN0cmlidXRlZCB3aXRoIEVhc2VsSlMgaW4gL3R1dG9yaWFscy9Jbmhlcml0YW5jZS5cblx0ICpcblx0ICogQG1ldGhvZCBpbml0aWFsaXplXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdC8vIHAuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge307IC8vIHNlYXJjaGFibGUgZm9yIGRldnMgd29uZGVyaW5nIHdoZXJlIGl0IGlzLlxuXHRcblxuLy8gcHVibGljIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBTZXRzIHt7I2Nyb3NzTGluayBcIkV2ZW50L2RlZmF1bHRQcmV2ZW50ZWRcIn19e3svY3Jvc3NMaW5rfX0gdG8gdHJ1ZS5cblx0ICogTWlycm9ycyB0aGUgRE9NIGV2ZW50IHN0YW5kYXJkLlxuXHQgKiBAbWV0aG9kIHByZXZlbnREZWZhdWx0XG5cdCAqKi9cblx0cC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRoaXMuY2FuY2VsYWJsZSYmdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB7eyNjcm9zc0xpbmsgXCJFdmVudC9wcm9wYWdhdGlvblN0b3BwZWRcIn19e3svY3Jvc3NMaW5rfX0gdG8gdHJ1ZS5cblx0ICogTWlycm9ycyB0aGUgRE9NIGV2ZW50IHN0YW5kYXJkLlxuXHQgKiBAbWV0aG9kIHN0b3BQcm9wYWdhdGlvblxuXHQgKiovXG5cdHAuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHt7I2Nyb3NzTGluayBcIkV2ZW50L3Byb3BhZ2F0aW9uU3RvcHBlZFwifX17ey9jcm9zc0xpbmt9fSBhbmRcblx0ICoge3sjY3Jvc3NMaW5rIFwiRXZlbnQvaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkXCJ9fXt7L2Nyb3NzTGlua319IHRvIHRydWUuXG5cdCAqIE1pcnJvcnMgdGhlIERPTSBldmVudCBzdGFuZGFyZC5cblx0ICogQG1ldGhvZCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cblx0ICoqL1xuXHRwLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHR9O1xuXHRcblx0LyoqXG5cdCAqIENhdXNlcyB0aGUgYWN0aXZlIGxpc3RlbmVyIHRvIGJlIHJlbW92ZWQgdmlhIHJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcblx0ICogXG5cdCAqIFx0XHRteUJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZ0KSB7XG5cdCAqIFx0XHRcdC8vIGRvIHN0dWZmLi4uXG5cdCAqIFx0XHRcdGV2dC5yZW1vdmUoKTsgLy8gcmVtb3ZlcyB0aGlzIGxpc3RlbmVyLlxuXHQgKiBcdFx0fSk7XG5cdCAqIFxuXHQgKiBAbWV0aG9kIHJlbW92ZVxuXHQgKiovXG5cdHAucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZW1vdmVkID0gdHJ1ZTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIEV2ZW50IGluc3RhbmNlLlxuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge0V2ZW50fSBhIGNsb25lIG9mIHRoZSBFdmVudCBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBFdmVudCh0aGlzLnR5cGUsIHRoaXMuYnViYmxlcywgdGhpcy5jYW5jZWxhYmxlKTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBQcm92aWRlcyBhIGNoYWluYWJsZSBzaG9ydGN1dCBtZXRob2QgZm9yIHNldHRpbmcgYSBudW1iZXIgb2YgcHJvcGVydGllcyBvbiB0aGUgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBBIGdlbmVyaWMgb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBjb3B5IHRvIHRoZSBpbnN0YW5jZS5cblx0ICogQHJldHVybiB7RXZlbnR9IFJldHVybnMgdGhlIGluc3RhbmNlIHRoZSBtZXRob2QgaXMgY2FsbGVkIG9uICh1c2VmdWwgZm9yIGNoYWluaW5nIGNhbGxzLilcblx0ICogQGNoYWluYWJsZVxuXHQqL1xuXHRwLnNldCA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykgeyB0aGlzW25dID0gcHJvcHNbbl07IH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICoqL1xuXHRwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwiW0V2ZW50ICh0eXBlPVwiK3RoaXMudHlwZStcIildXCI7XG5cdH07XG5cblx0Y3JlYXRlanMuRXZlbnQgPSBFdmVudDtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBFdmVudERpc3BhdGNoZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHJcblxyXG4vLyBjb25zdHJ1Y3RvcjpcclxuXHQvKipcclxuXHQgKiBFdmVudERpc3BhdGNoZXIgcHJvdmlkZXMgbWV0aG9kcyBmb3IgbWFuYWdpbmcgcXVldWVzIG9mIGV2ZW50IGxpc3RlbmVycyBhbmQgZGlzcGF0Y2hpbmcgZXZlbnRzLlxyXG5cdCAqXHJcblx0ICogWW91IGNhbiBlaXRoZXIgZXh0ZW5kIEV2ZW50RGlzcGF0Y2hlciBvciBtaXggaXRzIG1ldGhvZHMgaW50byBhbiBleGlzdGluZyBwcm90b3R5cGUgb3IgaW5zdGFuY2UgYnkgdXNpbmcgdGhlXHJcblx0ICogRXZlbnREaXNwYXRjaGVyIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9pbml0aWFsaXplXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cclxuXHQgKiBcclxuXHQgKiBUb2dldGhlciB3aXRoIHRoZSBDcmVhdGVKUyBFdmVudCBjbGFzcywgRXZlbnREaXNwYXRjaGVyIHByb3ZpZGVzIGFuIGV4dGVuZGVkIGV2ZW50IG1vZGVsIHRoYXQgaXMgYmFzZWQgb24gdGhlXHJcblx0ICogRE9NIExldmVsIDIgZXZlbnQgbW9kZWwsIGluY2x1ZGluZyBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyLCBhbmQgZGlzcGF0Y2hFdmVudC4gSXQgc3VwcG9ydHNcclxuXHQgKiBidWJibGluZyAvIGNhcHR1cmUsIHByZXZlbnREZWZhdWx0LCBzdG9wUHJvcGFnYXRpb24sIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiwgYW5kIGhhbmRsZUV2ZW50LlxyXG5cdCAqIFxyXG5cdCAqIEV2ZW50RGlzcGF0Y2hlciBhbHNvIGV4cG9zZXMgYSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvb25cIn19e3svY3Jvc3NMaW5rfX0gbWV0aG9kLCB3aGljaCBtYWtlcyBpdCBlYXNpZXJcclxuXHQgKiB0byBjcmVhdGUgc2NvcGVkIGxpc3RlbmVycywgbGlzdGVuZXJzIHRoYXQgb25seSBydW4gb25jZSwgYW5kIGxpc3RlbmVycyB3aXRoIGFzc29jaWF0ZWQgYXJiaXRyYXJ5IGRhdGEuIFRoZSBcclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvb2ZmXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCBpcyBtZXJlbHkgYW4gYWxpYXMgdG9cclxuXHQgKiB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvcmVtb3ZlRXZlbnRMaXN0ZW5lclwifX17ey9jcm9zc0xpbmt9fS5cclxuXHQgKiBcclxuXHQgKiBBbm90aGVyIGFkZGl0aW9uIHRvIHRoZSBET00gTGV2ZWwgMiBtb2RlbCBpcyB0aGUge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL3JlbW92ZUFsbEV2ZW50TGlzdGVuZXJzXCJ9fXt7L2Nyb3NzTGlua319XHJcblx0ICogbWV0aG9kLCB3aGljaCBjYW4gYmUgdXNlZCB0byBsaXN0ZW5lcnMgZm9yIGFsbCBldmVudHMsIG9yIGxpc3RlbmVycyBmb3IgYSBzcGVjaWZpYyBldmVudC4gVGhlIEV2ZW50IG9iamVjdCBhbHNvIFxyXG5cdCAqIGluY2x1ZGVzIGEge3sjY3Jvc3NMaW5rIFwiRXZlbnQvcmVtb3ZlXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCB3aGljaCByZW1vdmVzIHRoZSBhY3RpdmUgbGlzdGVuZXIuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICogQWRkIEV2ZW50RGlzcGF0Y2hlciBjYXBhYmlsaXRpZXMgdG8gdGhlIFwiTXlDbGFzc1wiIGNsYXNzLlxyXG5cdCAqXHJcblx0ICogICAgICBFdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShNeUNsYXNzLnByb3RvdHlwZSk7XHJcblx0ICpcclxuXHQgKiBBZGQgYW4gZXZlbnQgKHNlZSB7eyNjcm9zc0xpbmsgXCJFdmVudERpc3BhdGNoZXIvYWRkRXZlbnRMaXN0ZW5lclwifX17ey9jcm9zc0xpbmt9fSkuXHJcblx0ICpcclxuXHQgKiAgICAgIGluc3RhbmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJldmVudE5hbWVcIiwgaGFuZGxlck1ldGhvZCk7XHJcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVyTWV0aG9kKGV2ZW50KSB7XHJcblx0ICogICAgICAgICAgY29uc29sZS5sb2coZXZlbnQudGFyZ2V0ICsgXCIgV2FzIENsaWNrZWRcIik7XHJcblx0ICogICAgICB9XHJcblx0ICpcclxuXHQgKiA8Yj5NYWludGFpbmluZyBwcm9wZXIgc2NvcGU8L2I+PGJyIC8+XHJcblx0ICogU2NvcGUgKGllLiBcInRoaXNcIikgY2FuIGJlIGJlIGEgY2hhbGxlbmdlIHdpdGggZXZlbnRzLiBVc2luZyB0aGUge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyL29uXCJ9fXt7L2Nyb3NzTGlua319XHJcblx0ICogbWV0aG9kIHRvIHN1YnNjcmliZSB0byBldmVudHMgc2ltcGxpZmllcyB0aGlzLlxyXG5cdCAqXHJcblx0ICogICAgICBpbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXZlbnQpIHtcclxuXHQgKiAgICAgICAgICBjb25zb2xlLmxvZyhpbnN0YW5jZSA9PSB0aGlzKTsgLy8gZmFsc2UsIHNjb3BlIGlzIGFtYmlndW91cy5cclxuXHQgKiAgICAgIH0pO1xyXG5cdCAqICAgICAgXHJcblx0ICogICAgICBpbnN0YW5jZS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0ICogICAgICAgICAgY29uc29sZS5sb2coaW5zdGFuY2UgPT0gdGhpcyk7IC8vIHRydWUsIFwib25cIiB1c2VzIGRpc3BhdGNoZXIgc2NvcGUgYnkgZGVmYXVsdC5cclxuXHQgKiAgICAgIH0pO1xyXG5cdCAqIFxyXG5cdCAqIElmIHlvdSB3YW50IHRvIHVzZSBhZGRFdmVudExpc3RlbmVyIGluc3RlYWQsIHlvdSBtYXkgd2FudCB0byB1c2UgZnVuY3Rpb24uYmluZCgpIG9yIGEgc2ltaWxhciBwcm94eSB0byBtYW5hZ2Ugc2NvcGUuXHJcblx0ICogICAgICBcclxuXHQgKlxyXG5cdCAqIEBjbGFzcyBFdmVudERpc3BhdGNoZXJcclxuXHQgKiBAY29uc3RydWN0b3JcclxuXHQgKiovXHJcblx0ZnVuY3Rpb24gRXZlbnREaXNwYXRjaGVyKCkge1xyXG5cdFxyXG5cdFxyXG5cdC8vIHByaXZhdGUgcHJvcGVydGllczpcclxuXHRcdC8qKlxyXG5cdFx0ICogQHByb3RlY3RlZFxyXG5cdFx0ICogQHByb3BlcnR5IF9saXN0ZW5lcnNcclxuXHRcdCAqIEB0eXBlIE9iamVjdFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5fbGlzdGVuZXJzID0gbnVsbDtcclxuXHRcdFxyXG5cdFx0LyoqXHJcblx0XHQgKiBAcHJvdGVjdGVkXHJcblx0XHQgKiBAcHJvcGVydHkgX2NhcHR1cmVMaXN0ZW5lcnNcclxuXHRcdCAqIEB0eXBlIE9iamVjdFxyXG5cdFx0ICoqL1xyXG5cdFx0dGhpcy5fY2FwdHVyZUxpc3RlbmVycyA9IG51bGw7XHJcblx0fVxyXG5cdHZhciBwID0gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZTtcclxuXHJcblx0LyoqXHJcblx0ICogPHN0cm9uZz5SRU1PVkVEPC9zdHJvbmc+LiBSZW1vdmVkIGluIGZhdm9yIG9mIHVzaW5nIGBNeVN1cGVyQ2xhc3NfY29uc3RydWN0b3JgLlxyXG5cdCAqIFNlZSB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvZXh0ZW5kXCJ9fXt7L2Nyb3NzTGlua319IGFuZCB7eyNjcm9zc0xpbmsgXCJVdGlsaXR5IE1ldGhvZHMvcHJvbW90ZVwifX17ey9jcm9zc0xpbmt9fVxyXG5cdCAqIGZvciBkZXRhaWxzLlxyXG5cdCAqXHJcblx0ICogVGhlcmUgaXMgYW4gaW5oZXJpdGFuY2UgdHV0b3JpYWwgZGlzdHJpYnV0ZWQgd2l0aCBFYXNlbEpTIGluIC90dXRvcmlhbHMvSW5oZXJpdGFuY2UuXHJcblx0ICpcclxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcclxuXHQgKiBAcHJvdGVjdGVkXHJcblx0ICogQGRlcHJlY2F0ZWRcclxuXHQgKi9cclxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy5cclxuXHJcblxyXG4vLyBzdGF0aWMgcHVibGljIG1ldGhvZHM6XHJcblx0LyoqXHJcblx0ICogU3RhdGljIGluaXRpYWxpemVyIHRvIG1peCBFdmVudERpc3BhdGNoZXIgbWV0aG9kcyBpbnRvIGEgdGFyZ2V0IG9iamVjdCBvciBwcm90b3R5cGUuXHJcblx0ICogXHJcblx0ICogXHRcdEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplKE15Q2xhc3MucHJvdG90eXBlKTsgLy8gYWRkIHRvIHRoZSBwcm90b3R5cGUgb2YgdGhlIGNsYXNzXHJcblx0ICogXHRcdEV2ZW50RGlzcGF0Y2hlci5pbml0aWFsaXplKG15T2JqZWN0KTsgLy8gYWRkIHRvIGEgc3BlY2lmaWMgaW5zdGFuY2VcclxuXHQgKiBcclxuXHQgKiBAbWV0aG9kIGluaXRpYWxpemVcclxuXHQgKiBAc3RhdGljXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCB0byBpbmplY3QgRXZlbnREaXNwYXRjaGVyIG1ldGhvZHMgaW50by4gVGhpcyBjYW4gYmUgYW4gaW5zdGFuY2Ugb3IgYVxyXG5cdCAqIHByb3RvdHlwZS5cclxuXHQgKiovXHJcblx0RXZlbnREaXNwYXRjaGVyLmluaXRpYWxpemUgPSBmdW5jdGlvbih0YXJnZXQpIHtcclxuXHRcdHRhcmdldC5hZGRFdmVudExpc3RlbmVyID0gcC5hZGRFdmVudExpc3RlbmVyO1xyXG5cdFx0dGFyZ2V0Lm9uID0gcC5vbjtcclxuXHRcdHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyID0gdGFyZ2V0Lm9mZiA9ICBwLnJlbW92ZUV2ZW50TGlzdGVuZXI7XHJcblx0XHR0YXJnZXQucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMgPSBwLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzO1xyXG5cdFx0dGFyZ2V0Lmhhc0V2ZW50TGlzdGVuZXIgPSBwLmhhc0V2ZW50TGlzdGVuZXI7XHJcblx0XHR0YXJnZXQuZGlzcGF0Y2hFdmVudCA9IHAuZGlzcGF0Y2hFdmVudDtcclxuXHRcdHRhcmdldC5fZGlzcGF0Y2hFdmVudCA9IHAuX2Rpc3BhdGNoRXZlbnQ7XHJcblx0XHR0YXJnZXQud2lsbFRyaWdnZXIgPSBwLndpbGxUcmlnZ2VyO1xyXG5cdH07XHJcblx0XHJcblxyXG4vLyBwdWJsaWMgbWV0aG9kczpcclxuXHQvKipcclxuXHQgKiBBZGRzIHRoZSBzcGVjaWZpZWQgZXZlbnQgbGlzdGVuZXIuIE5vdGUgdGhhdCBhZGRpbmcgbXVsdGlwbGUgbGlzdGVuZXJzIHRvIHRoZSBzYW1lIGZ1bmN0aW9uIHdpbGwgcmVzdWx0IGluXHJcblx0ICogbXVsdGlwbGUgY2FsbGJhY2tzIGdldHRpbmcgZmlyZWQuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIGRpc3BsYXlPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGhhbmRsZUNsaWNrKTtcclxuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XHJcblx0ICogICAgICAgICAvLyBDbGljayBoYXBwZW5lZC5cclxuXHQgKiAgICAgIH1cclxuXHQgKlxyXG5cdCAqIEBtZXRob2QgYWRkRXZlbnRMaXN0ZW5lclxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBzdHJpbmcgdHlwZSBvZiB0aGUgZXZlbnQuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbiB8IE9iamVjdH0gbGlzdGVuZXIgQW4gb2JqZWN0IHdpdGggYSBoYW5kbGVFdmVudCBtZXRob2QsIG9yIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuXHJcblx0ICogdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZV0gRm9yIGV2ZW50cyB0aGF0IGJ1YmJsZSwgaW5kaWNhdGVzIHdoZXRoZXIgdG8gbGlzdGVuIGZvciB0aGUgZXZlbnQgaW4gdGhlIGNhcHR1cmUgb3IgYnViYmxpbmcvdGFyZ2V0IHBoYXNlLlxyXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9uIHwgT2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0ZW5lciBmb3IgY2hhaW5pbmcgb3IgYXNzaWdubWVudC5cclxuXHQgKiovXHJcblx0cC5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnM7XHJcblx0XHRpZiAodXNlQ2FwdHVyZSkge1xyXG5cdFx0XHRsaXN0ZW5lcnMgPSB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVyc3x8e307XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnN8fHt9O1xyXG5cdFx0fVxyXG5cdFx0dmFyIGFyciA9IGxpc3RlbmVyc1t0eXBlXTtcclxuXHRcdGlmIChhcnIpIHsgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTsgfVxyXG5cdFx0YXJyID0gbGlzdGVuZXJzW3R5cGVdOyAvLyByZW1vdmUgbWF5IGhhdmUgZGVsZXRlZCB0aGUgYXJyYXlcclxuXHRcdGlmICghYXJyKSB7IGxpc3RlbmVyc1t0eXBlXSA9IFtsaXN0ZW5lcl07ICB9XHJcblx0XHRlbHNlIHsgYXJyLnB1c2gobGlzdGVuZXIpOyB9XHJcblx0XHRyZXR1cm4gbGlzdGVuZXI7XHJcblx0fTtcclxuXHRcclxuXHQvKipcclxuXHQgKiBBIHNob3J0Y3V0IG1ldGhvZCBmb3IgdXNpbmcgYWRkRXZlbnRMaXN0ZW5lciB0aGF0IG1ha2VzIGl0IGVhc2llciB0byBzcGVjaWZ5IGFuIGV4ZWN1dGlvbiBzY29wZSwgaGF2ZSBhIGxpc3RlbmVyXHJcblx0ICogb25seSBydW4gb25jZSwgYXNzb2NpYXRlIGFyYml0cmFyeSBkYXRhIHdpdGggdGhlIGxpc3RlbmVyLCBhbmQgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cclxuXHQgKiBcclxuXHQgKiBUaGlzIG1ldGhvZCB3b3JrcyBieSBjcmVhdGluZyBhbiBhbm9ueW1vdXMgd3JhcHBlciBmdW5jdGlvbiBhbmQgc3Vic2NyaWJpbmcgaXQgd2l0aCBhZGRFdmVudExpc3RlbmVyLlxyXG5cdCAqIFRoZSBjcmVhdGVkIGFub255bW91cyBmdW5jdGlvbiBpcyByZXR1cm5lZCBmb3IgdXNlIHdpdGggLnJlbW92ZUV2ZW50TGlzdGVuZXIgKG9yIC5vZmYpLlxyXG5cdCAqIFxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKiBcclxuXHQgKiBcdFx0dmFyIGxpc3RlbmVyID0gbXlCdG4ub24oXCJjbGlja1wiLCBoYW5kbGVDbGljaywgbnVsbCwgZmFsc2UsIHtjb3VudDozfSk7XHJcblx0ICogXHRcdGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2dCwgZGF0YSkge1xyXG5cdCAqIFx0XHRcdGRhdGEuY291bnQgLT0gMTtcclxuXHQgKiBcdFx0XHRjb25zb2xlLmxvZyh0aGlzID09IG15QnRuKTsgLy8gdHJ1ZSAtIHNjb3BlIGRlZmF1bHRzIHRvIHRoZSBkaXNwYXRjaGVyXHJcblx0ICogXHRcdFx0aWYgKGRhdGEuY291bnQgPT0gMCkge1xyXG5cdCAqIFx0XHRcdFx0YWxlcnQoXCJjbGlja2VkIDMgdGltZXMhXCIpO1xyXG5cdCAqIFx0XHRcdFx0bXlCdG4ub2ZmKFwiY2xpY2tcIiwgbGlzdGVuZXIpO1xyXG5cdCAqIFx0XHRcdFx0Ly8gYWx0ZXJuYXRlbHk6IGV2dC5yZW1vdmUoKTtcclxuXHQgKiBcdFx0XHR9XHJcblx0ICogXHRcdH1cclxuXHQgKiBcclxuXHQgKiBAbWV0aG9kIG9uXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBBbiBvYmplY3Qgd2l0aCBhIGhhbmRsZUV2ZW50IG1ldGhvZCwgb3IgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5cclxuXHQgKiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSBUaGUgc2NvcGUgdG8gZXhlY3V0ZSB0aGUgbGlzdGVuZXIgaW4uIERlZmF1bHRzIHRvIHRoZSBkaXNwYXRjaGVyL2N1cnJlbnRUYXJnZXQgZm9yIGZ1bmN0aW9uIGxpc3RlbmVycywgYW5kIHRvIHRoZSBsaXN0ZW5lciBpdHNlbGYgZm9yIG9iamVjdCBsaXN0ZW5lcnMgKGllLiB1c2luZyBoYW5kbGVFdmVudCkuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gSWYgdHJ1ZSwgdGhlIGxpc3RlbmVyIHdpbGwgcmVtb3ZlIGl0c2VsZiBhZnRlciB0aGUgZmlyc3QgdGltZSBpdCBpcyB0cmlnZ2VyZWQuXHJcblx0ICogQHBhcmFtIHsqfSBbZGF0YV0gQXJiaXRyYXJ5IGRhdGEgdGhhdCB3aWxsIGJlIGluY2x1ZGVkIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHdoZW4gdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFt1c2VDYXB0dXJlPWZhbHNlXSBGb3IgZXZlbnRzIHRoYXQgYnViYmxlLCBpbmRpY2F0ZXMgd2hldGhlciB0byBsaXN0ZW4gZm9yIHRoZSBldmVudCBpbiB0aGUgY2FwdHVyZSBvciBidWJibGluZy90YXJnZXQgcGhhc2UuXHJcblx0ICogQHJldHVybiB7RnVuY3Rpb259IFJldHVybnMgdGhlIGFub255bW91cyBmdW5jdGlvbiB0aGF0IHdhcyBjcmVhdGVkIGFuZCBhc3NpZ25lZCBhcyB0aGUgbGlzdGVuZXIuIFRoaXMgaXMgbmVlZGVkIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIgbGF0ZXIgdXNpbmcgLnJlbW92ZUV2ZW50TGlzdGVuZXIuXHJcblx0ICoqL1xyXG5cdHAub24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgc2NvcGUsIG9uY2UsIGRhdGEsIHVzZUNhcHR1cmUpIHtcclxuXHRcdGlmIChsaXN0ZW5lci5oYW5kbGVFdmVudCkge1xyXG5cdFx0XHRzY29wZSA9IHNjb3BlfHxsaXN0ZW5lcjtcclxuXHRcdFx0bGlzdGVuZXIgPSBsaXN0ZW5lci5oYW5kbGVFdmVudDtcclxuXHRcdH1cclxuXHRcdHNjb3BlID0gc2NvcGV8fHRoaXM7XHJcblx0XHRyZXR1cm4gdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmN0aW9uKGV2dCkge1xyXG5cdFx0XHRcdGxpc3RlbmVyLmNhbGwoc2NvcGUsIGV2dCwgZGF0YSk7XHJcblx0XHRcdFx0b25jZSYmZXZ0LnJlbW92ZSgpO1xyXG5cdFx0XHR9LCB1c2VDYXB0dXJlKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgZXZlbnQgbGlzdGVuZXIuXHJcblx0ICpcclxuXHQgKiA8Yj5JbXBvcnRhbnQgTm90ZTo8L2I+IHRoYXQgeW91IG11c3QgcGFzcyB0aGUgZXhhY3QgZnVuY3Rpb24gcmVmZXJlbmNlIHVzZWQgd2hlbiB0aGUgZXZlbnQgd2FzIGFkZGVkLiBJZiBhIHByb3h5XHJcblx0ICogZnVuY3Rpb24sIG9yIGZ1bmN0aW9uIGNsb3N1cmUgaXMgdXNlZCBhcyB0aGUgY2FsbGJhY2ssIHRoZSBwcm94eS9jbG9zdXJlIHJlZmVyZW5jZSBtdXN0IGJlIHVzZWQgLSBhIG5ldyBwcm94eSBvclxyXG5cdCAqIGNsb3N1cmUgd2lsbCBub3Qgd29yay5cclxuXHQgKlxyXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cclxuXHQgKlxyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uIHwgT2JqZWN0fSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gb3Igb2JqZWN0LlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VzZUNhcHR1cmVdIEZvciBldmVudHMgdGhhdCBidWJibGUsIGluZGljYXRlcyB3aGV0aGVyIHRvIGxpc3RlbiBmb3IgdGhlIGV2ZW50IGluIHRoZSBjYXB0dXJlIG9yIGJ1YmJsaW5nL3RhcmdldCBwaGFzZS5cclxuXHQgKiovXHJcblx0cC5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcclxuXHRcdHZhciBsaXN0ZW5lcnMgPSB1c2VDYXB0dXJlID8gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA6IHRoaXMuX2xpc3RlbmVycztcclxuXHRcdGlmICghbGlzdGVuZXJzKSB7IHJldHVybjsgfVxyXG5cdFx0dmFyIGFyciA9IGxpc3RlbmVyc1t0eXBlXTtcclxuXHRcdGlmICghYXJyKSB7IHJldHVybjsgfVxyXG5cdFx0Zm9yICh2YXIgaT0wLGw9YXJyLmxlbmd0aDsgaTxsOyBpKyspIHtcclxuXHRcdFx0aWYgKGFycltpXSA9PSBsaXN0ZW5lcikge1xyXG5cdFx0XHRcdGlmIChsPT0xKSB7IGRlbGV0ZShsaXN0ZW5lcnNbdHlwZV0pOyB9IC8vIGFsbG93cyBmb3IgZmFzdGVyIGNoZWNrcy5cclxuXHRcdFx0XHRlbHNlIHsgYXJyLnNwbGljZShpLDEpOyB9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdC8qKlxyXG5cdCAqIEEgc2hvcnRjdXQgdG8gdGhlIHJlbW92ZUV2ZW50TGlzdGVuZXIgbWV0aG9kLCB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMgYW5kIHJldHVybiB2YWx1ZS4gVGhpcyBpcyBhIGNvbXBhbmlvbiB0byB0aGVcclxuXHQgKiAub24gbWV0aG9kLlxyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBvZmZcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb24gfCBPYmplY3R9IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiBvciBvYmplY3QuXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbdXNlQ2FwdHVyZV0gRm9yIGV2ZW50cyB0aGF0IGJ1YmJsZSwgaW5kaWNhdGVzIHdoZXRoZXIgdG8gbGlzdGVuIGZvciB0aGUgZXZlbnQgaW4gdGhlIGNhcHR1cmUgb3IgYnViYmxpbmcvdGFyZ2V0IHBoYXNlLlxyXG5cdCAqKi9cclxuXHRwLm9mZiA9IHAucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgc3BlY2lmaWVkIHR5cGUsIG9yIGFsbCBsaXN0ZW5lcnMgb2YgYWxsIHR5cGVzLlxyXG5cdCAqXHJcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxyXG5cdCAqXHJcblx0ICogICAgICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVyc1xyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5yZW1vdmVBbGxFdmVudExpc3RlbmVycygpO1xyXG5cdCAqXHJcblx0ICogICAgICAvLyBSZW1vdmUgYWxsIGNsaWNrIGxpc3RlbmVyc1xyXG5cdCAqICAgICAgZGlzcGxheU9iamVjdC5yZW1vdmVBbGxFdmVudExpc3RlbmVycyhcImNsaWNrXCIpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCByZW1vdmVBbGxFdmVudExpc3RlbmVyc1xyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZV0gVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC4gSWYgb21pdHRlZCwgYWxsIGxpc3RlbmVycyBmb3IgYWxsIHR5cGVzIHdpbGwgYmUgcmVtb3ZlZC5cclxuXHQgKiovXHJcblx0cC5yZW1vdmVBbGxFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdGlmICghdHlwZSkgeyB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9jYXB0dXJlTGlzdGVuZXJzID0gbnVsbDsgfVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGlmICh0aGlzLl9saXN0ZW5lcnMpIHsgZGVsZXRlKHRoaXMuX2xpc3RlbmVyc1t0eXBlXSk7IH1cclxuXHRcdFx0aWYgKHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnMpIHsgZGVsZXRlKHRoaXMuX2NhcHR1cmVMaXN0ZW5lcnNbdHlwZV0pOyB9XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogRGlzcGF0Y2hlcyB0aGUgc3BlY2lmaWVkIGV2ZW50IHRvIGFsbCBsaXN0ZW5lcnMuXHJcblx0ICpcclxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XHJcblx0ICpcclxuXHQgKiAgICAgIC8vIFVzZSBhIHN0cmluZyBldmVudFxyXG5cdCAqICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFwiY29tcGxldGVcIik7XHJcblx0ICpcclxuXHQgKiAgICAgIC8vIFVzZSBhbiBFdmVudCBpbnN0YW5jZVxyXG5cdCAqICAgICAgdmFyIGV2ZW50ID0gbmV3IGNyZWF0ZWpzLkV2ZW50KFwicHJvZ3Jlc3NcIik7XHJcblx0ICogICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG5cdCAqXHJcblx0ICogQG1ldGhvZCBkaXNwYXRjaEV2ZW50XHJcblx0ICogQHBhcmFtIHtPYmplY3QgfCBTdHJpbmcgfCBFdmVudH0gZXZlbnRPYmogQW4gb2JqZWN0IHdpdGggYSBcInR5cGVcIiBwcm9wZXJ0eSwgb3IgYSBzdHJpbmcgdHlwZS5cclxuXHQgKiBXaGlsZSBhIGdlbmVyaWMgb2JqZWN0IHdpbGwgd29yaywgaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIGEgQ3JlYXRlSlMgRXZlbnQgaW5zdGFuY2UuIElmIGEgc3RyaW5nIGlzIHVzZWQsXHJcblx0ICogZGlzcGF0Y2hFdmVudCB3aWxsIGNvbnN0cnVjdCBhbiBFdmVudCBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgdHlwZS5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBldmVudE9iai5kZWZhdWx0UHJldmVudGVkLlxyXG5cdCAqKi9cclxuXHRwLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudE9iaikge1xyXG5cdFx0aWYgKHR5cGVvZiBldmVudE9iaiA9PSBcInN0cmluZ1wiKSB7XHJcblx0XHRcdC8vIHdvbid0IGJ1YmJsZSwgc28gc2tpcCBldmVyeXRoaW5nIGlmIHRoZXJlJ3Mgbm8gbGlzdGVuZXJzOlxyXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG5cdFx0XHRpZiAoIWxpc3RlbmVycyB8fCAhbGlzdGVuZXJzW2V2ZW50T2JqXSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0ZXZlbnRPYmogPSBuZXcgY3JlYXRlanMuRXZlbnQoZXZlbnRPYmopO1xyXG5cdFx0fSBlbHNlIGlmIChldmVudE9iai50YXJnZXQgJiYgZXZlbnRPYmouY2xvbmUpIHtcclxuXHRcdFx0Ly8gcmVkaXNwYXRjaGluZyBhbiBhY3RpdmUgZXZlbnQgb2JqZWN0LCBzbyBjbG9uZSBpdDpcclxuXHRcdFx0ZXZlbnRPYmogPSBldmVudE9iai5jbG9uZSgpO1xyXG5cdFx0fVxyXG5cdFx0dHJ5IHsgZXZlbnRPYmoudGFyZ2V0ID0gdGhpczsgfSBjYXRjaCAoZSkge30gLy8gdHJ5L2NhdGNoIGFsbG93cyByZWRpc3BhdGNoaW5nIG9mIG5hdGl2ZSBldmVudHNcclxuXHJcblx0XHRpZiAoIWV2ZW50T2JqLmJ1YmJsZXMgfHwgIXRoaXMucGFyZW50KSB7XHJcblx0XHRcdHRoaXMuX2Rpc3BhdGNoRXZlbnQoZXZlbnRPYmosIDIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHRvcD10aGlzLCBsaXN0PVt0b3BdO1xyXG5cdFx0XHR3aGlsZSAodG9wLnBhcmVudCkgeyBsaXN0LnB1c2godG9wID0gdG9wLnBhcmVudCk7IH1cclxuXHRcdFx0dmFyIGksIGw9bGlzdC5sZW5ndGg7XHJcblxyXG5cdFx0XHQvLyBjYXB0dXJlICYgYXRUYXJnZXRcclxuXHRcdFx0Zm9yIChpPWwtMTsgaT49MCAmJiAhZXZlbnRPYmoucHJvcGFnYXRpb25TdG9wcGVkOyBpLS0pIHtcclxuXHRcdFx0XHRsaXN0W2ldLl9kaXNwYXRjaEV2ZW50KGV2ZW50T2JqLCAxKyhpPT0wKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gYnViYmxpbmdcclxuXHRcdFx0Zm9yIChpPTE7IGk8bCAmJiAhZXZlbnRPYmoucHJvcGFnYXRpb25TdG9wcGVkOyBpKyspIHtcclxuXHRcdFx0XHRsaXN0W2ldLl9kaXNwYXRjaEV2ZW50KGV2ZW50T2JqLCAzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGV2ZW50T2JqLmRlZmF1bHRQcmV2ZW50ZWQ7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXHJcblx0ICogQG1ldGhvZCBoYXNFdmVudExpc3RlbmVyXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIHN0cmluZyB0eXBlIG9mIHRoZSBldmVudC5cclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxyXG5cdCAqKi9cclxuXHRwLmhhc0V2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLCBjYXB0dXJlTGlzdGVuZXJzID0gdGhpcy5fY2FwdHVyZUxpc3RlbmVycztcclxuXHRcdHJldHVybiAhISgobGlzdGVuZXJzICYmIGxpc3RlbmVyc1t0eXBlXSkgfHwgKGNhcHR1cmVMaXN0ZW5lcnMgJiYgY2FwdHVyZUxpc3RlbmVyc1t0eXBlXSkpO1xyXG5cdH07XHJcblx0XHJcblx0LyoqXHJcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUgb24gdGhpcyBvYmplY3Qgb3IgYW55IG9mIGl0c1xyXG5cdCAqIGFuY2VzdG9ycyAocGFyZW50LCBwYXJlbnQncyBwYXJlbnQsIGV0YykuIEEgcmV0dXJuIHZhbHVlIG9mIHRydWUgaW5kaWNhdGVzIHRoYXQgaWYgYSBidWJibGluZyBldmVudCBvZiB0aGVcclxuXHQgKiBzcGVjaWZpZWQgdHlwZSBpcyBkaXNwYXRjaGVkIGZyb20gdGhpcyBvYmplY3QsIGl0IHdpbGwgdHJpZ2dlciBhdCBsZWFzdCBvbmUgbGlzdGVuZXIuXHJcblx0ICogXHJcblx0ICogVGhpcyBpcyBzaW1pbGFyIHRvIHt7I2Nyb3NzTGluayBcIkV2ZW50RGlzcGF0Y2hlci9oYXNFdmVudExpc3RlbmVyXCJ9fXt7L2Nyb3NzTGlua319LCBidXQgaXQgc2VhcmNoZXMgdGhlIGVudGlyZVxyXG5cdCAqIGV2ZW50IGZsb3cgZm9yIGEgbGlzdGVuZXIsIG5vdCBqdXN0IHRoaXMgb2JqZWN0LlxyXG5cdCAqIEBtZXRob2Qgd2lsbFRyaWdnZXJcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgc3RyaW5nIHR5cGUgb2YgdGhlIGV2ZW50LlxyXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudC5cclxuXHQgKiovXHJcblx0cC53aWxsVHJpZ2dlciA9IGZ1bmN0aW9uKHR5cGUpIHtcclxuXHRcdHZhciBvID0gdGhpcztcclxuXHRcdHdoaWxlIChvKSB7XHJcblx0XHRcdGlmIChvLmhhc0V2ZW50TGlzdGVuZXIodHlwZSkpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0byA9IG8ucGFyZW50O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cclxuXHQgKiovXHJcblx0cC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIFwiW0V2ZW50RGlzcGF0Y2hlcl1cIjtcclxuXHR9O1xyXG5cclxuXHJcbi8vIHByaXZhdGUgbWV0aG9kczpcclxuXHQvKipcclxuXHQgKiBAbWV0aG9kIF9kaXNwYXRjaEV2ZW50XHJcblx0ICogQHBhcmFtIHtPYmplY3QgfCBTdHJpbmcgfCBFdmVudH0gZXZlbnRPYmpcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRQaGFzZVxyXG5cdCAqIEBwcm90ZWN0ZWRcclxuXHQgKiovXHJcblx0cC5fZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50T2JqLCBldmVudFBoYXNlKSB7XHJcblx0XHR2YXIgbCwgbGlzdGVuZXJzID0gKGV2ZW50UGhhc2U9PTEpID8gdGhpcy5fY2FwdHVyZUxpc3RlbmVycyA6IHRoaXMuX2xpc3RlbmVycztcclxuXHRcdGlmIChldmVudE9iaiAmJiBsaXN0ZW5lcnMpIHtcclxuXHRcdFx0dmFyIGFyciA9IGxpc3RlbmVyc1tldmVudE9iai50eXBlXTtcclxuXHRcdFx0aWYgKCFhcnJ8fCEobD1hcnIubGVuZ3RoKSkgeyByZXR1cm47IH1cclxuXHRcdFx0dHJ5IHsgZXZlbnRPYmouY3VycmVudFRhcmdldCA9IHRoaXM7IH0gY2F0Y2ggKGUpIHt9XHJcblx0XHRcdHRyeSB7IGV2ZW50T2JqLmV2ZW50UGhhc2UgPSBldmVudFBoYXNlOyB9IGNhdGNoIChlKSB7fVxyXG5cdFx0XHRldmVudE9iai5yZW1vdmVkID0gZmFsc2U7XHJcblx0XHRcdFxyXG5cdFx0XHRhcnIgPSBhcnIuc2xpY2UoKTsgLy8gdG8gYXZvaWQgaXNzdWVzIHdpdGggaXRlbXMgYmVpbmcgcmVtb3ZlZCBvciBhZGRlZCBkdXJpbmcgdGhlIGRpc3BhdGNoXHJcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsICYmICFldmVudE9iai5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ7IGkrKykge1xyXG5cdFx0XHRcdHZhciBvID0gYXJyW2ldO1xyXG5cdFx0XHRcdGlmIChvLmhhbmRsZUV2ZW50KSB7IG8uaGFuZGxlRXZlbnQoZXZlbnRPYmopOyB9XHJcblx0XHRcdFx0ZWxzZSB7IG8oZXZlbnRPYmopOyB9XHJcblx0XHRcdFx0aWYgKGV2ZW50T2JqLnJlbW92ZWQpIHtcclxuXHRcdFx0XHRcdHRoaXMub2ZmKGV2ZW50T2JqLnR5cGUsIG8sIGV2ZW50UGhhc2U9PTEpO1xyXG5cdFx0XHRcdFx0ZXZlbnRPYmoucmVtb3ZlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cclxuXHRjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIgPSBFdmVudERpc3BhdGNoZXI7XHJcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUaWNrZXIuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3Rvcjpcblx0LyoqXG5cdCAqIFRoZSBUaWNrZXIgcHJvdmlkZXMgYSBjZW50cmFsaXplZCB0aWNrIG9yIGhlYXJ0YmVhdCBicm9hZGNhc3QgYXQgYSBzZXQgaW50ZXJ2YWwuIExpc3RlbmVycyBjYW4gc3Vic2NyaWJlIHRvIHRoZSB0aWNrXG5cdCAqIGV2ZW50IHRvIGJlIG5vdGlmaWVkIHdoZW4gYSBzZXQgdGltZSBpbnRlcnZhbCBoYXMgZWxhcHNlZC5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoZSBpbnRlcnZhbCB0aGF0IHRoZSB0aWNrIGV2ZW50IGlzIGNhbGxlZCBpcyBhIHRhcmdldCBpbnRlcnZhbCwgYW5kIG1heSBiZSBicm9hZGNhc3QgYXQgYSBzbG93ZXIgaW50ZXJ2YWxcblx0ICogd2hlbiB1bmRlciBoaWdoIENQVSBsb2FkLiBUaGUgVGlja2VyIGNsYXNzIHVzZXMgYSBzdGF0aWMgaW50ZXJmYWNlIChleC4gYFRpY2tlci5mcmFtZXJhdGUgPSAzMDtgKSBhbmRcblx0ICogY2FuIG5vdCBiZSBpbnN0YW50aWF0ZWQuXG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICBjcmVhdGVqcy5UaWNrZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRpY2tcIiwgaGFuZGxlVGljayk7XG5cdCAqICAgICAgZnVuY3Rpb24gaGFuZGxlVGljayhldmVudCkge1xuXHQgKiAgICAgICAgICAvLyBBY3Rpb25zIGNhcnJpZWQgb3V0IGVhY2ggdGljayAoYWthIGZyYW1lKVxuXHQgKiAgICAgICAgICBpZiAoIWV2ZW50LnBhdXNlZCkge1xuXHQgKiAgICAgICAgICAgICAgLy8gQWN0aW9ucyBjYXJyaWVkIG91dCB3aGVuIHRoZSBUaWNrZXIgaXMgbm90IHBhdXNlZC5cblx0ICogICAgICAgICAgfVxuXHQgKiAgICAgIH1cblx0ICpcblx0ICogQGNsYXNzIFRpY2tlclxuXHQgKiBAdXNlcyBFdmVudERpc3BhdGNoZXJcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdGZ1bmN0aW9uIFRpY2tlcigpIHtcblx0XHR0aHJvdyBcIlRpY2tlciBjYW5ub3QgYmUgaW5zdGFudGlhdGVkLlwiO1xuXHR9XG5cblxuLy8gY29uc3RhbnRzOlxuXHQvKipcblx0ICogSW4gdGhpcyBtb2RlLCBUaWNrZXIgdXNlcyB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIEFQSSwgYnV0IGF0dGVtcHRzIHRvIHN5bmNoIHRoZSB0aWNrcyB0byB0YXJnZXQgZnJhbWVyYXRlLiBJdFxuXHQgKiB1c2VzIGEgc2ltcGxlIGhldXJpc3RpYyB0aGF0IGNvbXBhcmVzIHRoZSB0aW1lIG9mIHRoZSBSQUYgcmV0dXJuIHRvIHRoZSB0YXJnZXQgdGltZSBmb3IgdGhlIGN1cnJlbnQgZnJhbWUgYW5kXG5cdCAqIGRpc3BhdGNoZXMgdGhlIHRpY2sgd2hlbiB0aGUgdGltZSBpcyB3aXRoaW4gYSBjZXJ0YWluIHRocmVzaG9sZC5cblx0ICpcblx0ICogVGhpcyBtb2RlIGhhcyBhIGhpZ2hlciB2YXJpYW5jZSBmb3IgdGltZSBiZXR3ZWVuIGZyYW1lcyB0aGFuIHt7I2Nyb3NzTGluayBcIlRpY2tlci9USU1FT1VUOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiBidXQgZG9lcyBub3QgcmVxdWlyZSB0aGF0IGNvbnRlbnQgYmUgdGltZSBiYXNlZCBhcyB3aXRoIHt7I2Nyb3NzTGluayBcIlRpY2tlci9SQUY6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gd2hpbGVcblx0ICogZ2FpbmluZyB0aGUgYmVuZWZpdHMgb2YgdGhhdCBBUEkgKHNjcmVlbiBzeW5jaCwgYmFja2dyb3VuZCB0aHJvdHRsaW5nKS5cblx0ICpcblx0ICogVmFyaWFuY2UgaXMgdXN1YWxseSBsb3dlc3QgZm9yIGZyYW1lcmF0ZXMgdGhhdCBhcmUgYSBkaXZpc29yIG9mIHRoZSBSQUYgZnJlcXVlbmN5LiBUaGlzIGlzIHVzdWFsbHkgNjAsIHNvXG5cdCAqIGZyYW1lcmF0ZXMgb2YgMTAsIDEyLCAxNSwgMjAsIGFuZCAzMCB3b3JrIHdlbGwuXG5cdCAqXG5cdCAqIEZhbGxzIGJhY2sgdG8ge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1RJTUVPVVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaWYgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBBUEkgaXMgbm90XG5cdCAqIHN1cHBvcnRlZC5cblx0ICogQHByb3BlcnR5IFJBRl9TWU5DSEVEXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgXCJzeW5jaGVkXCJcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0VGlja2VyLlJBRl9TWU5DSEVEID0gXCJzeW5jaGVkXCI7XG5cblx0LyoqXG5cdCAqIEluIHRoaXMgbW9kZSwgVGlja2VyIHBhc3NlcyB0aHJvdWdoIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgaGVhcnRiZWF0LCBpZ25vcmluZyB0aGUgdGFyZ2V0IGZyYW1lcmF0ZSBjb21wbGV0ZWx5LlxuXHQgKiBCZWNhdXNlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmcmVxdWVuY3kgaXMgbm90IGRldGVybWluaXN0aWMsIGFueSBjb250ZW50IHVzaW5nIHRoaXMgbW9kZSBzaG91bGQgYmUgdGltZSBiYXNlZC5cblx0ICogWW91IGNhbiBsZXZlcmFnZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvZ2V0VGltZVwifX17ey9jcm9zc0xpbmt9fSBhbmQgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aWNrOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGV2ZW50IG9iamVjdCdzIFwiZGVsdGFcIiBwcm9wZXJ0aWVzIHRvIG1ha2UgdGhpcyBlYXNpZXIuXG5cdCAqXG5cdCAqIEZhbGxzIGJhY2sgb24ge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1RJTUVPVVQ6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gaWYgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBBUEkgaXMgbm90XG5cdCAqIHN1cHBvcnRlZC5cblx0ICogQHByb3BlcnR5IFJBRlxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IFwicmFmXCJcblx0ICogQHJlYWRvbmx5XG5cdCAqKi9cblx0VGlja2VyLlJBRiA9IFwicmFmXCI7XG5cblx0LyoqXG5cdCAqIEluIHRoaXMgbW9kZSwgVGlja2VyIHVzZXMgdGhlIHNldFRpbWVvdXQgQVBJLiBUaGlzIHByb3ZpZGVzIHByZWRpY3RhYmxlLCBhZGFwdGl2ZSBmcmFtZSB0aW1pbmcsIGJ1dCBkb2VzIG5vdFxuXHQgKiBwcm92aWRlIHRoZSBiZW5lZml0cyBvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKHNjcmVlbiBzeW5jaCwgYmFja2dyb3VuZCB0aHJvdHRsaW5nKS5cblx0ICogQHByb3BlcnR5IFRJTUVPVVRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBcInRpbWVvdXRcIlxuXHQgKiBAcmVhZG9ubHlcblx0ICoqL1xuXHRUaWNrZXIuVElNRU9VVCA9IFwidGltZW91dFwiO1xuXG5cbi8vIHN0YXRpYyBldmVudHM6XG5cdC8qKlxuXHQgKiBEaXNwYXRjaGVkIGVhY2ggdGljay4gVGhlIGV2ZW50IHdpbGwgYmUgZGlzcGF0Y2hlZCB0byBlYWNoIGxpc3RlbmVyIGV2ZW4gd2hlbiB0aGUgVGlja2VyIGhhcyBiZWVuIHBhdXNlZCB1c2luZ1xuXHQgKiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvc2V0UGF1c2VkXCJ9fXt7L2Nyb3NzTGlua319LlxuXHQgKlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgICAgY3JlYXRlanMuVGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0aWNrXCIsIGhhbmRsZVRpY2spO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZVRpY2soZXZlbnQpIHtcblx0ICogICAgICAgICAgY29uc29sZS5sb2coXCJQYXVzZWQ6XCIsIGV2ZW50LnBhdXNlZCwgZXZlbnQuZGVsdGEpO1xuXHQgKiAgICAgIH1cblx0ICpcblx0ICogQGV2ZW50IHRpY2tcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgb2JqZWN0IHRoYXQgZGlzcGF0Y2hlZCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBldmVudCB0eXBlLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHBhdXNlZCBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGlja2VyIGlzIGN1cnJlbnRseSBwYXVzZWQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YSBUaGUgdGltZSBlbGFwc2VkIGluIG1zIHNpbmNlIHRoZSBsYXN0IHRpY2suXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRoZSB0b3RhbCB0aW1lIGluIG1zIHNpbmNlIFRpY2tlciB3YXMgaW5pdGlhbGl6ZWQuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBydW5UaW1lIFRoZSB0b3RhbCB0aW1lIGluIG1zIHRoYXQgVGlja2VyIHdhcyBub3QgcGF1c2VkIHNpbmNlIGl0IHdhcyBpbml0aWFsaXplZC4gRm9yIGV4YW1wbGUsXG5cdCAqIFx0eW91IGNvdWxkIGRldGVybWluZSB0aGUgYW1vdW50IG9mIHRpbWUgdGhhdCB0aGUgVGlja2VyIGhhcyBiZWVuIHBhdXNlZCBzaW5jZSBpbml0aWFsaXphdGlvbiB3aXRoIGB0aW1lLXJ1blRpbWVgLlxuXHQgKiBAc2luY2UgMC42LjBcblx0ICovXG5cblxuLy8gcHVibGljIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogRGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Yge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3RpbWluZ01vZGVcIn19e3svY3Jvc3NMaW5rfX0sIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gSWYgdHJ1ZSwgdGltaW5nTW9kZSB3aWxsXG5cdCAqIHVzZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvUkFGX1NZTkNIRURcIn19e3svY3Jvc3NMaW5rfX0gYnkgZGVmYXVsdC5cblx0ICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Yge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3RpbWluZ01vZGVcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBwcm9wZXJ0eSB1c2VSQUZcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICoqL1xuXHRUaWNrZXIudXNlUkFGID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIFNwZWNpZmllcyB0aGUgdGltaW5nIGFwaSAoc2V0VGltZW91dCBvciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIGFuZCBtb2RlIHRvIHVzZS4gU2VlXG5cdCAqIHt7I2Nyb3NzTGluayBcIlRpY2tlci9USU1FT1VUXCJ9fXt7L2Nyb3NzTGlua319LCB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvUkFGXCJ9fXt7L2Nyb3NzTGlua319LCBhbmRcblx0ICoge3sjY3Jvc3NMaW5rIFwiVGlja2VyL1JBRl9TWU5DSEVEXCJ9fXt7L2Nyb3NzTGlua319IGZvciBtb2RlIGRldGFpbHMuXG5cdCAqIEBwcm9wZXJ0eSB0aW1pbmdNb2RlXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge1N0cmluZ31cblx0ICogQGRlZmF1bHQgVGlja2VyLlRJTUVPVVRcblx0ICoqL1xuXHRUaWNrZXIudGltaW5nTW9kZSA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFNwZWNpZmllcyBhIG1heGltdW0gdmFsdWUgZm9yIHRoZSBkZWx0YSBwcm9wZXJ0eSBpbiB0aGUgdGljayBldmVudCBvYmplY3QuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYnVpbGRpbmcgdGltZVxuXHQgKiBiYXNlZCBhbmltYXRpb25zIGFuZCBzeXN0ZW1zIHRvIHByZXZlbnQgaXNzdWVzIGNhdXNlZCBieSBsYXJnZSB0aW1lIGdhcHMgY2F1c2VkIGJ5IGJhY2tncm91bmQgdGFicywgc3lzdGVtIHNsZWVwLFxuXHQgKiBhbGVydCBkaWFsb2dzLCBvciBvdGhlciBibG9ja2luZyByb3V0aW5lcy4gRG91YmxlIHRoZSBleHBlY3RlZCBmcmFtZSBkdXJhdGlvbiBpcyBvZnRlbiBhbiBlZmZlY3RpdmUgdmFsdWVcblx0ICogKGV4LiBtYXhEZWx0YT01MCB3aGVuIHJ1bm5pbmcgYXQgNDBmcHMpLlxuXHQgKiBcblx0ICogVGhpcyBkb2VzIG5vdCBpbXBhY3QgYW55IG90aGVyIHZhbHVlcyAoZXguIHRpbWUsIHJ1blRpbWUsIGV0YyksIHNvIHlvdSBtYXkgZXhwZXJpZW5jZSBpc3N1ZXMgaWYgeW91IGVuYWJsZSBtYXhEZWx0YVxuXHQgKiB3aGVuIHVzaW5nIGJvdGggZGVsdGEgYW5kIG90aGVyIHZhbHVlcy5cblx0ICogXG5cdCAqIElmIDAsIHRoZXJlIGlzIG5vIG1heGltdW0uXG5cdCAqIEBwcm9wZXJ0eSBtYXhEZWx0YVxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqIEBkZWZhdWx0IDBcblx0ICovXG5cdFRpY2tlci5tYXhEZWx0YSA9IDA7XG5cdFxuXHQvKipcblx0ICogV2hlbiB0aGUgdGlja2VyIGlzIHBhdXNlZCwgYWxsIGxpc3RlbmVycyB3aWxsIHN0aWxsIHJlY2VpdmUgYSB0aWNrIGV2ZW50LCBidXQgdGhlIDxjb2RlPnBhdXNlZDwvY29kZT4gcHJvcGVydHlcblx0ICogb2YgdGhlIGV2ZW50IHdpbGwgYmUgYHRydWVgLiBBbHNvLCB3aGlsZSBwYXVzZWQgdGhlIGBydW5UaW1lYCB3aWxsIG5vdCBpbmNyZWFzZS4gU2VlIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aWNrOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319LFxuXHQgKiB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvZ2V0VGltZVwifX17ey9jcm9zc0xpbmt9fSwgYW5kIHt7I2Nyb3NzTGluayBcIlRpY2tlci9nZXRFdmVudFRpbWVcIn19e3svY3Jvc3NMaW5rfX0gZm9yIG1vcmVcblx0ICogaW5mby5cblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLlRpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBoYW5kbGVUaWNrKTtcblx0ICogICAgICBjcmVhdGVqcy5UaWNrZXIucGF1c2VkID0gdHJ1ZTtcblx0ICogICAgICBmdW5jdGlvbiBoYW5kbGVUaWNrKGV2ZW50KSB7XG5cdCAqICAgICAgICAgIGNvbnNvbGUubG9nKGV2ZW50LnBhdXNlZCxcblx0ICogICAgICAgICAgXHRjcmVhdGVqcy5UaWNrZXIuZ2V0VGltZShmYWxzZSksXG5cdCAqICAgICAgICAgIFx0Y3JlYXRlanMuVGlja2VyLmdldFRpbWUodHJ1ZSkpO1xuXHQgKiAgICAgIH1cblx0ICpcblx0ICogQHByb3BlcnR5IHBhdXNlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAZGVmYXVsdCBmYWxzZVxuXHQgKiovXG5cdFRpY2tlci5wYXVzZWQgPSBmYWxzZTtcblxuXG4vLyBtaXgtaW5zOlxuXHQvLyBFdmVudERpc3BhdGNoZXIgbWV0aG9kczpcblx0VGlja2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBudWxsO1xuXHRUaWNrZXIucmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMgPSBudWxsO1xuXHRUaWNrZXIuZGlzcGF0Y2hFdmVudCA9IG51bGw7XG5cdFRpY2tlci5oYXNFdmVudExpc3RlbmVyID0gbnVsbDtcblx0VGlja2VyLl9saXN0ZW5lcnMgPSBudWxsO1xuXHRjcmVhdGVqcy5FdmVudERpc3BhdGNoZXIuaW5pdGlhbGl6ZShUaWNrZXIpOyAvLyBpbmplY3QgRXZlbnREaXNwYXRjaGVyIG1ldGhvZHMuXG5cdFRpY2tlci5fYWRkRXZlbnRMaXN0ZW5lciA9IFRpY2tlci5hZGRFdmVudExpc3RlbmVyO1xuXHRUaWNrZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuXHRcdCFUaWNrZXIuX2luaXRlZCYmVGlja2VyLmluaXQoKTtcblx0XHRyZXR1cm4gVGlja2VyLl9hZGRFdmVudExpc3RlbmVyLmFwcGx5KFRpY2tlciwgYXJndW1lbnRzKTtcblx0fTtcblxuXG4vLyBwcml2YXRlIHN0YXRpYyBwcm9wZXJ0aWVzOlxuXHQvKipcblx0ICogQHByb3BlcnR5IF9pbml0ZWRcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5faW5pdGVkID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfc3RhcnRUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fc3RhcnRUaW1lID0gMDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IF9wYXVzZWRUaW1lXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdFRpY2tlci5fcGF1c2VkVGltZT0wO1xuXG5cdC8qKlxuXHQgKiBUaGUgbnVtYmVyIG9mIHRpY2tzIHRoYXQgaGF2ZSBwYXNzZWRcblx0ICogQHByb3BlcnR5IF90aWNrc1xuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3RpY2tzID0gMDtcblxuXHQvKipcblx0ICogVGhlIG51bWJlciBvZiB0aWNrcyB0aGF0IGhhdmUgcGFzc2VkIHdoaWxlIFRpY2tlciBoYXMgYmVlbiBwYXVzZWRcblx0ICogQHByb3BlcnR5IF9wYXVzZWRUaWNrc1xuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3BhdXNlZFRpY2tzID0gMDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IF9pbnRlcnZhbFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX2ludGVydmFsID0gNTA7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfbGFzdFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9sYXN0VGltZSA9IDA7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfdGltZXNcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3RpbWVzID0gbnVsbDtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IF90aWNrVGltZXNcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3RpY2tUaW1lcyA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFN0b3JlcyB0aGUgdGltZW91dCBvciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgaWQuXG5cdCAqIEBwcm9wZXJ0eSBfdGltZXJJZFxuXHQgKiBAc3RhdGljXG5cdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3RpbWVySWQgPSBudWxsO1xuXHRcblx0LyoqXG5cdCAqIFRydWUgaWYgY3VycmVudGx5IHVzaW5nIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgZmFsc2UgaWYgdXNpbmcgc2V0VGltZW91dC4gVGhpcyBtYXkgYmUgZGlmZmVyZW50IHRoYW4gdGltaW5nTW9kZVxuXHQgKiBpZiB0aGF0IHByb3BlcnR5IGNoYW5nZWQgYW5kIGEgdGljayBoYXNuJ3QgZmlyZWQuXG5cdCAqIEBwcm9wZXJ0eSBfcmFmXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3JhZiA9IHRydWU7XG5cdFxuXG4vLyBzdGF0aWMgZ2V0dGVyIC8gc2V0dGVyczpcblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2ludGVydmFsOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2Qgc2V0SW50ZXJ2YWxcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaW50ZXJ2YWxcblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbihpbnRlcnZhbCkge1xuXHRcdFRpY2tlci5faW50ZXJ2YWwgPSBpbnRlcnZhbDtcblx0XHRpZiAoIVRpY2tlci5faW5pdGVkKSB7IHJldHVybjsgfVxuXHRcdFRpY2tlci5fc2V0dXBUaWNrKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2ZyYW1lcmF0ZTpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIGdldEludGVydmFsXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdFRpY2tlci5nZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBUaWNrZXIuX2ludGVydmFsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVc2UgdGhlIHt7I2Nyb3NzTGluayBcIlRpY2tlci9mcmFtZXJhdGU6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgaW5zdGVhZC5cblx0ICogQG1ldGhvZCBzZXRGUFNcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuc2V0RlBTID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRUaWNrZXIuc2V0SW50ZXJ2YWwoMTAwMC92YWx1ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL2ludGVydmFsOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgZ2V0RlBTXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiovXG5cdFRpY2tlci5nZXRGUFMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gMTAwMC9UaWNrZXIuX2ludGVydmFsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZXMgdGhlIHRhcmdldCB0aW1lIChpbiBtaWxsaXNlY29uZHMpIGJldHdlZW4gdGlja3MuIERlZmF1bHQgaXMgNTAgKDIwIEZQUykuXG5cdCAqIE5vdGUgdGhhdCBhY3R1YWwgdGltZSBiZXR3ZWVuIHRpY2tzIG1heSBiZSBtb3JlIHRoYW4gc3BlY2lmaWVkIGRlcGVuZGluZyBvbiBDUFUgbG9hZC5cblx0ICogVGhpcyBwcm9wZXJ0eSBpcyBpZ25vcmVkIGlmIHRoZSB0aWNrZXIgaXMgdXNpbmcgdGhlIGBSQUZgIHRpbWluZyBtb2RlLlxuXHQgKiBAcHJvcGVydHkgaW50ZXJ2YWxcblx0ICogQHN0YXRpY1xuXHQgKiBAdHlwZSB7TnVtYmVyfVxuXHQgKiovXG5cdCBcblx0LyoqXG5cdCAqIEluZGljYXRlcyB0aGUgdGFyZ2V0IGZyYW1lIHJhdGUgaW4gZnJhbWVzIHBlciBzZWNvbmQgKEZQUykuIEVmZmVjdGl2ZWx5IGp1c3QgYSBzaG9ydGN1dCB0byBgaW50ZXJ2YWxgLCB3aGVyZVxuXHQgKiBgZnJhbWVyYXRlID09IDEwMDAvaW50ZXJ2YWxgLlxuXHQgKiBAcHJvcGVydHkgZnJhbWVyYXRlXG5cdCAqIEBzdGF0aWNcblx0ICogQHR5cGUge051bWJlcn1cblx0ICoqL1xuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRpY2tlciwge1xuXHRcdFx0aW50ZXJ2YWw6IHsgZ2V0OiBUaWNrZXIuZ2V0SW50ZXJ2YWwsIHNldDogVGlja2VyLnNldEludGVydmFsIH0sXG5cdFx0XHRmcmFtZXJhdGU6IHsgZ2V0OiBUaWNrZXIuZ2V0RlBTLCBzZXQ6IFRpY2tlci5zZXRGUFMgfVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlKSB7IGNvbnNvbGUubG9nKGUpOyB9XG5cblxuLy8gcHVibGljIHN0YXRpYyBtZXRob2RzOlxuXHQvKipcblx0ICogU3RhcnRzIHRoZSB0aWNrLiBUaGlzIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIGZpcnN0IGxpc3RlbmVyIGlzIGFkZGVkLlxuXHQgKiBAbWV0aG9kIGluaXRcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdFRpY2tlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKFRpY2tlci5faW5pdGVkKSB7IHJldHVybjsgfVxuXHRcdFRpY2tlci5faW5pdGVkID0gdHJ1ZTtcblx0XHRUaWNrZXIuX3RpbWVzID0gW107XG5cdFx0VGlja2VyLl90aWNrVGltZXMgPSBbXTtcblx0XHRUaWNrZXIuX3N0YXJ0VGltZSA9IFRpY2tlci5fZ2V0VGltZSgpO1xuXHRcdFRpY2tlci5fdGltZXMucHVzaChUaWNrZXIuX2xhc3RUaW1lID0gMCk7XG5cdFx0VGlja2VyLmludGVydmFsID0gVGlja2VyLl9pbnRlcnZhbDtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBTdG9wcyB0aGUgVGlja2VyIGFuZCByZW1vdmVzIGFsbCBsaXN0ZW5lcnMuIFVzZSBpbml0KCkgdG8gcmVzdGFydCB0aGUgVGlja2VyLlxuXHQgKiBAbWV0aG9kIHJlc2V0XG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRUaWNrZXIucmVzZXQgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoVGlja2VyLl9yYWYpIHtcblx0XHRcdHZhciBmID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm9DYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNDYW5jZWxBbmltYXRpb25GcmFtZTtcblx0XHRcdGYmJmYoVGlja2VyLl90aW1lcklkKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KFRpY2tlci5fdGltZXJJZCk7XG5cdFx0fVxuXHRcdFRpY2tlci5yZW1vdmVBbGxFdmVudExpc3RlbmVycyhcInRpY2tcIik7XG5cdFx0VGlja2VyLl90aW1lcklkID0gVGlja2VyLl90aW1lcyA9IFRpY2tlci5fdGlja1RpbWVzID0gbnVsbDtcblx0XHRUaWNrZXIuX3N0YXJ0VGltZSA9IFRpY2tlci5fbGFzdFRpbWUgPSBUaWNrZXIuX3RpY2tzID0gMDtcblx0XHRUaWNrZXIuX2luaXRlZCA9IGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhdmVyYWdlIHRpbWUgc3BlbnQgd2l0aGluIGEgdGljay4gVGhpcyBjYW4gdmFyeSBzaWduaWZpY2FudGx5IGZyb20gdGhlIHZhbHVlIHByb3ZpZGVkIGJ5IGdldE1lYXN1cmVkRlBTXG5cdCAqIGJlY2F1c2UgaXQgb25seSBtZWFzdXJlcyB0aGUgdGltZSBzcGVudCB3aXRoaW4gdGhlIHRpY2sgZXhlY3V0aW9uIHN0YWNrLiBcblx0ICogXG5cdCAqIEV4YW1wbGUgMTogV2l0aCBhIHRhcmdldCBGUFMgb2YgMjAsIGdldE1lYXN1cmVkRlBTKCkgcmV0dXJucyAyMGZwcywgd2hpY2ggaW5kaWNhdGVzIGFuIGF2ZXJhZ2Ugb2YgNTBtcyBiZXR3ZWVuIFxuXHQgKiB0aGUgZW5kIG9mIG9uZSB0aWNrIGFuZCB0aGUgZW5kIG9mIHRoZSBuZXh0LiBIb3dldmVyLCBnZXRNZWFzdXJlZFRpY2tUaW1lKCkgcmV0dXJucyAxNW1zLiBUaGlzIGluZGljYXRlcyB0aGF0IFxuXHQgKiB0aGVyZSBtYXkgYmUgdXAgdG8gMzVtcyBvZiBcImlkbGVcIiB0aW1lIGJldHdlZW4gdGhlIGVuZCBvZiBvbmUgdGljayBhbmQgdGhlIHN0YXJ0IG9mIHRoZSBuZXh0LlxuXHQgKlxuXHQgKiBFeGFtcGxlIDI6IFdpdGggYSB0YXJnZXQgRlBTIG9mIDMwLCBnZXRGUFMoKSByZXR1cm5zIDEwZnBzLCB3aGljaCBpbmRpY2F0ZXMgYW4gYXZlcmFnZSBvZiAxMDBtcyBiZXR3ZWVuIHRoZSBlbmQgb2Zcblx0ICogb25lIHRpY2sgYW5kIHRoZSBlbmQgb2YgdGhlIG5leHQuIEhvd2V2ZXIsIGdldE1lYXN1cmVkVGlja1RpbWUoKSByZXR1cm5zIDIwbXMuIFRoaXMgd291bGQgaW5kaWNhdGUgdGhhdCBzb21ldGhpbmdcblx0ICogb3RoZXIgdGhhbiB0aGUgdGljayBpcyB1c2luZyB+ODBtcyAoYW5vdGhlciBzY3JpcHQsIERPTSByZW5kZXJpbmcsIGV0YykuXG5cdCAqIEBtZXRob2QgZ2V0TWVhc3VyZWRUaWNrVGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGlja3NdIFRoZSBudW1iZXIgb2YgcHJldmlvdXMgdGlja3Mgb3ZlciB3aGljaCB0byBtZWFzdXJlIHRoZSBhdmVyYWdlIHRpbWUgc3BlbnQgaW4gYSB0aWNrLlxuXHQgKiBEZWZhdWx0cyB0byB0aGUgbnVtYmVyIG9mIHRpY2tzIHBlciBzZWNvbmQuIFRvIGdldCBvbmx5IHRoZSBsYXN0IHRpY2sncyB0aW1lLCBwYXNzIGluIDEuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGF2ZXJhZ2UgdGltZSBzcGVudCBpbiBhIHRpY2sgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiovXG5cdFRpY2tlci5nZXRNZWFzdXJlZFRpY2tUaW1lID0gZnVuY3Rpb24odGlja3MpIHtcblx0XHR2YXIgdHRsPTAsIHRpbWVzPVRpY2tlci5fdGlja1RpbWVzO1xuXHRcdGlmICghdGltZXMgfHwgdGltZXMubGVuZ3RoIDwgMSkgeyByZXR1cm4gLTE7IH1cblxuXHRcdC8vIGJ5IGRlZmF1bHQsIGNhbGN1bGF0ZSBhdmVyYWdlIGZvciB0aGUgcGFzdCB+MSBzZWNvbmQ6XG5cdFx0dGlja3MgPSBNYXRoLm1pbih0aW1lcy5sZW5ndGgsIHRpY2tzfHwoVGlja2VyLmdldEZQUygpfDApKTtcblx0XHRmb3IgKHZhciBpPTA7IGk8dGlja3M7IGkrKykgeyB0dGwgKz0gdGltZXNbaV07IH1cblx0XHRyZXR1cm4gdHRsL3RpY2tzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhY3R1YWwgZnJhbWVzIC8gdGlja3MgcGVyIHNlY29uZC5cblx0ICogQG1ldGhvZCBnZXRNZWFzdXJlZEZQU1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbdGlja3NdIFRoZSBudW1iZXIgb2YgcHJldmlvdXMgdGlja3Mgb3ZlciB3aGljaCB0byBtZWFzdXJlIHRoZSBhY3R1YWwgZnJhbWVzIC8gdGlja3MgcGVyIHNlY29uZC5cblx0ICogRGVmYXVsdHMgdG8gdGhlIG51bWJlciBvZiB0aWNrcyBwZXIgc2Vjb25kLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBhY3R1YWwgZnJhbWVzIC8gdGlja3MgcGVyIHNlY29uZC4gRGVwZW5kaW5nIG9uIHBlcmZvcm1hbmNlLCB0aGlzIG1heSBkaWZmZXJcblx0ICogZnJvbSB0aGUgdGFyZ2V0IGZyYW1lcyBwZXIgc2Vjb25kLlxuXHQgKiovXG5cdFRpY2tlci5nZXRNZWFzdXJlZEZQUyA9IGZ1bmN0aW9uKHRpY2tzKSB7XG5cdFx0dmFyIHRpbWVzID0gVGlja2VyLl90aW1lcztcblx0XHRpZiAoIXRpbWVzIHx8IHRpbWVzLmxlbmd0aCA8IDIpIHsgcmV0dXJuIC0xOyB9XG5cblx0XHQvLyBieSBkZWZhdWx0LCBjYWxjdWxhdGUgZnBzIGZvciB0aGUgcGFzdCB+MSBzZWNvbmQ6XG5cdFx0dGlja3MgPSBNYXRoLm1pbih0aW1lcy5sZW5ndGgtMSwgdGlja3N8fChUaWNrZXIuZ2V0RlBTKCl8MCkpO1xuXHRcdHJldHVybiAxMDAwLygodGltZXNbMF0tdGltZXNbdGlja3NdKS90aWNrcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFVzZSB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyL3BhdXNlZDpwcm9wZXJ0eVwifX17ey9jcm9zc0xpbmt9fSBwcm9wZXJ0eSBpbnN0ZWFkLlxuXHQgKiBAbWV0aG9kIHNldFBhdXNlZFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuc2V0UGF1c2VkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHQvLyBUT0RPOiBkZXByZWNhdGVkLlxuXHRcdFRpY2tlci5wYXVzZWQgPSB2YWx1ZTtcblx0fTtcblxuXHQvKipcblx0ICogVXNlIHRoZSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvcGF1c2VkOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IGluc3RlYWQuXG5cdCAqIEBtZXRob2QgZ2V0UGF1c2VkXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICogQGRlcHJlY2F0ZWRcblx0ICoqL1xuXHRUaWNrZXIuZ2V0UGF1c2VkID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gVE9ETzogZGVwcmVjYXRlZC5cblx0XHRyZXR1cm4gVGlja2VyLnBhdXNlZDtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZSBUaWNrZXIgd2FzIGluaXRpYWxpemVkIHZpYSB7eyNjcm9zc0xpbmsgXCJUaWNrZXIvaW5pdFwifX0uXG5cdCAqIFJldHVybnMgLTEgaWYgVGlja2VyIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZC4gRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCB1c2Vcblx0ICogdGhpcyBpbiBhIHRpbWUgc3luY2hyb25pemVkIGFuaW1hdGlvbiB0byBkZXRlcm1pbmUgdGhlIGV4YWN0IGFtb3VudCBvZiB0aW1lIHRoYXQgaGFzIGVsYXBzZWQuXG5cdCAqIEBtZXRob2QgZ2V0VGltZVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3J1blRpbWU9ZmFsc2VdIElmIHRydWUgb25seSB0aW1lIGVsYXBzZWQgd2hpbGUgVGlja2VyIHdhcyBub3QgcGF1c2VkIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIElmIGZhbHNlLCB0aGUgdmFsdWUgcmV0dXJuZWQgd2lsbCBiZSB0b3RhbCB0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGZpcnN0IHRpY2sgZXZlbnQgbGlzdGVuZXIgd2FzIGFkZGVkLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IE51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2UgVGlja2VyIHdhcyBpbml0aWFsaXplZCBvciAtMS5cblx0ICoqL1xuXHRUaWNrZXIuZ2V0VGltZSA9IGZ1bmN0aW9uKHJ1blRpbWUpIHtcblx0XHRyZXR1cm4gVGlja2VyLl9zdGFydFRpbWUgPyBUaWNrZXIuX2dldFRpbWUoKSAtIChydW5UaW1lID8gVGlja2VyLl9wYXVzZWRUaW1lIDogMCkgOiAtMTtcblx0fTtcblxuXHQvKipcblx0ICogU2ltaWxhciB0byBnZXRUaW1lKCksIGJ1dCByZXR1cm5zIHRoZSB0aW1lIG9uIHRoZSBtb3N0IHJlY2VudCB0aWNrIGV2ZW50IG9iamVjdC5cblx0ICogQG1ldGhvZCBnZXRFdmVudFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAcGFyYW0gcnVuVGltZSB7Qm9vbGVhbn0gW3J1blRpbWU9ZmFsc2VdIElmIHRydWUsIHRoZSBydW5UaW1lIHByb3BlcnR5IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiB0aW1lLlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgdGltZSBvciBydW5UaW1lIHByb3BlcnR5IGZyb20gdGhlIG1vc3QgcmVjZW50IHRpY2sgZXZlbnQgb3IgLTEuXG5cdCAqL1xuXHRUaWNrZXIuZ2V0RXZlbnRUaW1lID0gZnVuY3Rpb24ocnVuVGltZSkge1xuXHRcdHJldHVybiBUaWNrZXIuX3N0YXJ0VGltZSA/IChUaWNrZXIuX2xhc3RUaW1lIHx8IFRpY2tlci5fc3RhcnRUaW1lKSAtIChydW5UaW1lID8gVGlja2VyLl9wYXVzZWRUaW1lIDogMCkgOiAtMTtcblx0fTtcblx0XG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdGlja3MgdGhhdCBoYXZlIGJlZW4gYnJvYWRjYXN0IGJ5IFRpY2tlci5cblx0ICogQG1ldGhvZCBnZXRUaWNrc1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcGF1c2VhYmxlIEluZGljYXRlcyB3aGV0aGVyIHRvIGluY2x1ZGUgdGlja3MgdGhhdCB3b3VsZCBoYXZlIGJlZW4gYnJvYWRjYXN0XG5cdCAqIHdoaWxlIFRpY2tlciB3YXMgcGF1c2VkLiBJZiB0cnVlIG9ubHkgdGljayBldmVudHMgYnJvYWRjYXN0IHdoaWxlIFRpY2tlciBpcyBub3QgcGF1c2VkIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIElmIGZhbHNlLCB0aWNrIGV2ZW50cyB0aGF0IHdvdWxkIGhhdmUgYmVlbiBicm9hZGNhc3Qgd2hpbGUgVGlja2VyIHdhcyBwYXVzZWQgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcmV0dXJuXG5cdCAqIHZhbHVlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBmYWxzZS5cblx0ICogQHJldHVybiB7TnVtYmVyfSBvZiB0aWNrcyB0aGF0IGhhdmUgYmVlbiBicm9hZGNhc3QuXG5cdCAqKi9cblx0VGlja2VyLmdldFRpY2tzID0gZnVuY3Rpb24ocGF1c2VhYmxlKSB7XG5cdFx0cmV0dXJuICBUaWNrZXIuX3RpY2tzIC0gKHBhdXNlYWJsZSA/IFRpY2tlci5fcGF1c2VkVGlja3MgOiAwKTtcblx0fTtcblxuXG4vLyBwcml2YXRlIHN0YXRpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlU3luY2hcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0VGlja2VyLl9oYW5kbGVTeW5jaCA9IGZ1bmN0aW9uKCkge1xuXHRcdFRpY2tlci5fdGltZXJJZCA9IG51bGw7XG5cdFx0VGlja2VyLl9zZXR1cFRpY2soKTtcblxuXHRcdC8vIHJ1biBpZiBlbm91Z2ggdGltZSBoYXMgZWxhcHNlZCwgd2l0aCBhIGxpdHRsZSBiaXQgb2YgZmxleGliaWxpdHkgdG8gYmUgZWFybHk6XG5cdFx0aWYgKFRpY2tlci5fZ2V0VGltZSgpIC0gVGlja2VyLl9sYXN0VGltZSA+PSAoVGlja2VyLl9pbnRlcnZhbC0xKSowLjk3KSB7XG5cdFx0XHRUaWNrZXIuX3RpY2soKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2hhbmRsZVJBRlxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX2hhbmRsZVJBRiA9IGZ1bmN0aW9uKCkge1xuXHRcdFRpY2tlci5fdGltZXJJZCA9IG51bGw7XG5cdFx0VGlja2VyLl9zZXR1cFRpY2soKTtcblx0XHRUaWNrZXIuX3RpY2soKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfaGFuZGxlVGltZW91dFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX2hhbmRsZVRpbWVvdXQgPSBmdW5jdGlvbigpIHtcblx0XHRUaWNrZXIuX3RpbWVySWQgPSBudWxsO1xuXHRcdFRpY2tlci5fc2V0dXBUaWNrKCk7XG5cdFx0VGlja2VyLl90aWNrKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX3NldHVwVGlja1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3NldHVwVGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmIChUaWNrZXIuX3RpbWVySWQgIT0gbnVsbCkgeyByZXR1cm47IH0gLy8gYXZvaWQgZHVwbGljYXRlc1xuXG5cdFx0dmFyIG1vZGUgPSBUaWNrZXIudGltaW5nTW9kZXx8KFRpY2tlci51c2VSQUYmJlRpY2tlci5SQUZfU1lOQ0hFRCk7XG5cdFx0aWYgKG1vZGUgPT0gVGlja2VyLlJBRl9TWU5DSEVEIHx8IG1vZGUgPT0gVGlja2VyLlJBRikge1xuXHRcdFx0dmFyIGYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0XHRpZiAoZikge1xuXHRcdFx0XHRUaWNrZXIuX3RpbWVySWQgPSBmKG1vZGUgPT0gVGlja2VyLlJBRiA/IFRpY2tlci5faGFuZGxlUkFGIDogVGlja2VyLl9oYW5kbGVTeW5jaCk7XG5cdFx0XHRcdFRpY2tlci5fcmFmID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRUaWNrZXIuX3JhZiA9IGZhbHNlO1xuXHRcdFRpY2tlci5fdGltZXJJZCA9IHNldFRpbWVvdXQoVGlja2VyLl9oYW5kbGVUaW1lb3V0LCBUaWNrZXIuX2ludGVydmFsKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfdGlja1xuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICoqL1xuXHRUaWNrZXIuX3RpY2sgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGF1c2VkID0gVGlja2VyLnBhdXNlZDtcblx0XHR2YXIgdGltZSA9IFRpY2tlci5fZ2V0VGltZSgpO1xuXHRcdHZhciBlbGFwc2VkVGltZSA9IHRpbWUtVGlja2VyLl9sYXN0VGltZTtcblx0XHRUaWNrZXIuX2xhc3RUaW1lID0gdGltZTtcblx0XHRUaWNrZXIuX3RpY2tzKys7XG5cdFx0XG5cdFx0aWYgKHBhdXNlZCkge1xuXHRcdFx0VGlja2VyLl9wYXVzZWRUaWNrcysrO1xuXHRcdFx0VGlja2VyLl9wYXVzZWRUaW1lICs9IGVsYXBzZWRUaW1lO1xuXHRcdH1cblx0XHRcblx0XHRpZiAoVGlja2VyLmhhc0V2ZW50TGlzdGVuZXIoXCJ0aWNrXCIpKSB7XG5cdFx0XHR2YXIgZXZlbnQgPSBuZXcgY3JlYXRlanMuRXZlbnQoXCJ0aWNrXCIpO1xuXHRcdFx0dmFyIG1heERlbHRhID0gVGlja2VyLm1heERlbHRhO1xuXHRcdFx0ZXZlbnQuZGVsdGEgPSAobWF4RGVsdGEgJiYgZWxhcHNlZFRpbWUgPiBtYXhEZWx0YSkgPyBtYXhEZWx0YSA6IGVsYXBzZWRUaW1lO1xuXHRcdFx0ZXZlbnQucGF1c2VkID0gcGF1c2VkO1xuXHRcdFx0ZXZlbnQudGltZSA9IHRpbWU7XG5cdFx0XHRldmVudC5ydW5UaW1lID0gdGltZS1UaWNrZXIuX3BhdXNlZFRpbWU7XG5cdFx0XHRUaWNrZXIuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdFx0fVxuXHRcdFxuXHRcdFRpY2tlci5fdGlja1RpbWVzLnVuc2hpZnQoVGlja2VyLl9nZXRUaW1lKCktdGltZSk7XG5cdFx0d2hpbGUgKFRpY2tlci5fdGlja1RpbWVzLmxlbmd0aCA+IDEwMCkgeyBUaWNrZXIuX3RpY2tUaW1lcy5wb3AoKTsgfVxuXG5cdFx0VGlja2VyLl90aW1lcy51bnNoaWZ0KHRpbWUpO1xuXHRcdHdoaWxlIChUaWNrZXIuX3RpbWVzLmxlbmd0aCA+IDEwMCkgeyBUaWNrZXIuX3RpbWVzLnBvcCgpOyB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2dldFRpbWVcblx0ICogQHN0YXRpY1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0dmFyIG5vdyA9IHdpbmRvdy5wZXJmb3JtYW5jZSAmJiAocGVyZm9ybWFuY2Uubm93IHx8IHBlcmZvcm1hbmNlLm1vek5vdyB8fCBwZXJmb3JtYW5jZS5tc05vdyB8fCBwZXJmb3JtYW5jZS5vTm93IHx8IHBlcmZvcm1hbmNlLndlYmtpdE5vdyk7XG5cdFRpY2tlci5fZ2V0VGltZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAoKG5vdyYmbm93LmNhbGwocGVyZm9ybWFuY2UpKXx8KG5ldyBEYXRlKCkuZ2V0VGltZSgpKSkgLSBUaWNrZXIuX3N0YXJ0VGltZTtcblx0fTtcblxuXG5cdGNyZWF0ZWpzLlRpY2tlciA9IFRpY2tlcjtcbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBUd2Vlbi5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxuLy8gVE9ETzogcG9zc2libHkgYWRkIGEgRU5EIGFjdGlvbnNNb2RlIChvbmx5IHJ1bnMgYWN0aW9ucyB0aGF0ID09IHBvc2l0aW9uKT9cbi8vIFRPRE86IGV2YWx1YXRlIGEgd2F5IHRvIGRlY291cGxlIHBhdXNlZCBmcm9tIHRpY2sgcmVnaXN0cmF0aW9uLlxuXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXG4vLyBjb25zdHJ1Y3RvclxuXHQvKipcblx0ICogQSBUd2VlbiBpbnN0YW5jZSB0d2VlbnMgcHJvcGVydGllcyBmb3IgYSBzaW5nbGUgdGFyZ2V0LiBJbnN0YW5jZSBtZXRob2RzIGNhbiBiZSBjaGFpbmVkIGZvciBlYXN5IGNvbnN0cnVjdGlvbiBhbmQgc2VxdWVuY2luZzpcblx0ICpcblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKiAgICAgIHRhcmdldC5hbHBoYSA9IDE7XG5cdCAqXHQgICAgY3JlYXRlanMuVHdlZW4uZ2V0KHRhcmdldClcblx0ICpcdCAgICAgICAgIC53YWl0KDUwMClcblx0ICpcdCAgICAgICAgIC50byh7YWxwaGE6MCwgdmlzaWJsZTpmYWxzZX0sIDEwMDApXG5cdCAqXHQgICAgICAgICAuY2FsbChoYW5kbGVDb21wbGV0ZSk7XG5cdCAqXHQgICAgZnVuY3Rpb24gaGFuZGxlQ29tcGxldGUoKSB7XG5cdCAqXHQgICAgXHQvL1R3ZWVuIGNvbXBsZXRlXG5cdCAqXHQgICAgfVxuXHQgKlxuXHQgKiBNdWx0aXBsZSB0d2VlbnMgY2FuIHBvaW50IHRvIHRoZSBzYW1lIGluc3RhbmNlLCBob3dldmVyIGlmIHRoZXkgYWZmZWN0IHRoZSBzYW1lIHByb3BlcnRpZXMgdGhlcmUgY291bGQgYmUgdW5leHBlY3RlZFxuXHQgKiBiZWhhdmlvdXIuIFRvIHN0b3AgYWxsIHR3ZWVucyBvbiBhbiBvYmplY3QsIHVzZSB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9yZW1vdmVUd2VlbnNcIn19e3svY3Jvc3NMaW5rfX0gb3IgcGFzcyBgb3ZlcnJpZGU6dHJ1ZWBcblx0ICogaW4gdGhlIHByb3BzIGFyZ3VtZW50LlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLlR3ZWVuLmdldCh0YXJnZXQsIHtvdmVycmlkZTp0cnVlfSkudG8oe3g6MTAwfSk7XG5cdCAqXG5cdCAqIFN1YnNjcmliZSB0byB0aGUge3sjY3Jvc3NMaW5rIFwiVHdlZW4vY2hhbmdlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50IHRvIGdldCBub3RpZmllZCB3aGVuIGEgcHJvcGVydHkgb2YgdGhlXG5cdCAqIHRhcmdldCBpcyBjaGFuZ2VkLlxuXHQgKlxuXHQgKiAgICAgIGNyZWF0ZWpzLlR3ZWVuLmdldCh0YXJnZXQsIHtvdmVycmlkZTp0cnVlfSkudG8oe3g6MTAwfSkuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVDaGFuZ2UpO1xuXHQgKiAgICAgIGZ1bmN0aW9uIGhhbmRsZUNoYW5nZShldmVudCkge1xuXHQgKiAgICAgICAgICAvLyBUaGUgdHdlZW4gY2hhbmdlZC5cblx0ICogICAgICB9XG5cdCAqXG5cdCAqIFNlZSB0aGUgVHdlZW4ge3sjY3Jvc3NMaW5rIFwiVHdlZW4vZ2V0XCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZCBmb3IgYWRkaXRpb25hbCBwYXJhbSBkb2N1bWVudGF0aW9uLlxuXHQgKiBAY2xhc3MgVHdlZW5cblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCB0aGF0IHdpbGwgaGF2ZSBpdHMgcHJvcGVydGllcyB0d2VlbmVkLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXSBUaGUgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIHRvIGFwcGx5IHRvIHRoaXMgdHdlZW4gaW5zdGFuY2UgKGV4LiBge2xvb3A6dHJ1ZSwgcGF1c2VkOnRydWV9YC5cblx0ICogQWxsIHByb3BlcnRpZXMgZGVmYXVsdCB0byBmYWxzZS4gU3VwcG9ydGVkIHByb3BzIGFyZTo8VUw+XG5cdCAqICAgIDxMST4gbG9vcDogc2V0cyB0aGUgbG9vcCBwcm9wZXJ0eSBvbiB0aGlzIHR3ZWVuLjwvTEk+XG5cdCAqICAgIDxMST4gdXNlVGlja3M6IHVzZXMgdGlja3MgZm9yIGFsbCBkdXJhdGlvbnMgaW5zdGVhZCBvZiBtaWxsaXNlY29uZHMuPC9MST5cblx0ICogICAgPExJPiBpZ25vcmVHbG9iYWxQYXVzZTogc2V0cyB0aGUge3sjY3Jvc3NMaW5rIFwiVHdlZW4vaWdub3JlR2xvYmFsUGF1c2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gcHJvcGVydHkgb24gdGhpcyB0d2Vlbi48L0xJPlxuXHQgKiAgICA8TEk+IG92ZXJyaWRlOiBpZiB0cnVlLCBgVHdlZW4ucmVtb3ZlVHdlZW5zKHRhcmdldClgIHdpbGwgYmUgY2FsbGVkIHRvIHJlbW92ZSBhbnkgb3RoZXIgdHdlZW5zIHdpdGggdGhlIHNhbWUgdGFyZ2V0LlxuXHQgKiAgICA8TEk+IHBhdXNlZDogaW5kaWNhdGVzIHdoZXRoZXIgdG8gc3RhcnQgdGhlIHR3ZWVuIHBhdXNlZC48L0xJPlxuXHQgKiAgICA8TEk+IHBvc2l0aW9uOiBpbmRpY2F0ZXMgdGhlIGluaXRpYWwgcG9zaXRpb24gZm9yIHRoaXMgdHdlZW4uPC9MST5cblx0ICogICAgPExJPiBvbkNoYW5nZTogc3BlY2lmaWVzIGEgbGlzdGVuZXIgZm9yIHRoZSBcImNoYW5nZVwiIGV2ZW50LjwvTEk+XG5cdCAqIDwvVUw+XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcGx1Z2luRGF0YV0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgZGF0YSBmb3IgdXNlIGJ5IGluc3RhbGxlZCBwbHVnaW5zLiBTZWUgaW5kaXZpZHVhbFxuXHQgKiBwbHVnaW5zJyBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLlxuXHQgKiBAZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRmdW5jdGlvbiBUd2Vlbih0YXJnZXQsIHByb3BzLCBwbHVnaW5EYXRhKSB7XG5cblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQ2F1c2VzIHRoaXMgdHdlZW4gdG8gY29udGludWUgcGxheWluZyB3aGVuIGEgZ2xvYmFsIHBhdXNlIGlzIGFjdGl2ZS4gRm9yIGV4YW1wbGUsIGlmIFR3ZWVuSlMgaXMgdXNpbmcge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319LFxuXHRcdCAqIHRoZW4gc2V0dGluZyB0aGlzIHRvIHRydWUgKHRoZSBkZWZhdWx0KSB3aWxsIGNhdXNlIHRoaXMgdHdlZW4gdG8gYmUgcGF1c2VkIHdoZW4gPGNvZGU+VGlja2VyLnNldFBhdXNlZCh0cnVlKTwvY29kZT5cblx0XHQgKiBpcyBjYWxsZWQuIFNlZSB0aGUgVHdlZW4ge3sjY3Jvc3NMaW5rIFwiVHdlZW4vdGlja1wifX17ey9jcm9zc0xpbmt9fSBtZXRob2QgZm9yIG1vcmUgaW5mby4gQ2FuIGJlIHNldCB2aWEgdGhlIHByb3BzXG5cdFx0ICogcGFyYW1ldGVyLlxuXHRcdCAqIEBwcm9wZXJ0eSBpZ25vcmVHbG9iYWxQYXVzZVxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqL1xuXHRcdHRoaXMuaWdub3JlR2xvYmFsUGF1c2UgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogSWYgdHJ1ZSwgdGhlIHR3ZWVuIHdpbGwgbG9vcCB3aGVuIGl0IHJlYWNoZXMgdGhlIGVuZC4gQ2FuIGJlIHNldCB2aWEgdGhlIHByb3BzIHBhcmFtLlxuXHRcdCAqIEBwcm9wZXJ0eSBsb29wXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKi9cblx0XHR0aGlzLmxvb3AgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogU3BlY2lmaWVzIHRoZSB0b3RhbCBkdXJhdGlvbiBvZiB0aGlzIHR3ZWVuIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgdXNlVGlja3MgaXMgdHJ1ZSkuXG5cdFx0ICogVGhpcyB2YWx1ZSBpcyBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgYXMgeW91IG1vZGlmeSB0aGUgdHdlZW4uIENoYW5naW5nIGl0IGRpcmVjdGx5IGNvdWxkIHJlc3VsdCBpbiB1bmV4cGVjdGVkXG5cdFx0ICogYmVoYXZpb3VyLlxuXHRcdCAqIEBwcm9wZXJ0eSBkdXJhdGlvblxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqL1xuXHRcdHRoaXMuZHVyYXRpb24gPSAwO1xuXHRcblx0XHQvKipcblx0XHQgKiBBbGxvd3MgeW91IHRvIHNwZWNpZnkgZGF0YSB0aGF0IHdpbGwgYmUgdXNlZCBieSBpbnN0YWxsZWQgcGx1Z2lucy4gRWFjaCBwbHVnaW4gdXNlcyB0aGlzIGRpZmZlcmVudGx5LCBidXQgaW4gZ2VuZXJhbFxuXHRcdCAqIHlvdSBzcGVjaWZ5IGRhdGEgYnkgc2V0dGluZyBpdCB0byBhIHByb3BlcnR5IG9mIHBsdWdpbkRhdGEgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBwbHVnaW4gY2xhc3MuXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKlx0bXlUd2Vlbi5wbHVnaW5EYXRhLlBsdWdpbkNsYXNzTmFtZSA9IGRhdGE7XG5cdFx0ICogPGJyLz5cblx0XHQgKiBBbHNvLCBtb3N0IHBsdWdpbnMgc3VwcG9ydCBhIHByb3BlcnR5IHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZW0uIFRoaXMgaXMgdHlwaWNhbGx5IHRoZSBwbHVnaW4gY2xhc3MgbmFtZSBmb2xsb3dlZCBieSBcIl9lbmFibGVkXCIuPGJyLz5cblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqXHRteVR3ZWVuLnBsdWdpbkRhdGEuUGx1Z2luQ2xhc3NOYW1lX2VuYWJsZWQgPSBmYWxzZTs8YnIvPlxuXHRcdCAqIDxici8+XG5cdFx0ICogU29tZSBwbHVnaW5zIGFsc28gc3RvcmUgaW5zdGFuY2UgZGF0YSBpbiB0aGlzIG9iamVjdCwgdXN1YWxseSBpbiBhIHByb3BlcnR5IG5hbWVkIF9QbHVnaW5DbGFzc05hbWUuXG5cdFx0ICogU2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciBpbmRpdmlkdWFsIHBsdWdpbnMgZm9yIG1vcmUgZGV0YWlscy5cblx0XHQgKiBAcHJvcGVydHkgcGx1Z2luRGF0YVxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5wbHVnaW5EYXRhID0gcGx1Z2luRGF0YSB8fCB7fTtcblx0XG5cdFx0LyoqXG5cdFx0ICogVGhlIHRhcmdldCBvZiB0aGlzIHR3ZWVuLiBUaGlzIGlzIHRoZSBvYmplY3Qgb24gd2hpY2ggdGhlIHR3ZWVuZWQgcHJvcGVydGllcyB3aWxsIGJlIGNoYW5nZWQuIENoYW5naW5nXG5cdFx0ICogdGhpcyBwcm9wZXJ0eSBhZnRlciB0aGUgdHdlZW4gaXMgY3JlYXRlZCB3aWxsIG5vdCBoYXZlIGFueSBlZmZlY3QuXG5cdFx0ICogQHByb3BlcnR5IHRhcmdldFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICogQHJlYWRvbmx5XG5cdFx0ICovXG5cdFx0dGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBjdXJyZW50IG5vcm1hbGl6ZWQgcG9zaXRpb24gb2YgdGhlIHR3ZWVuLiBUaGlzIHdpbGwgYWx3YXlzIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCBkdXJhdGlvbi5cblx0XHQgKiBDaGFuZ2luZyB0aGlzIHByb3BlcnR5IGRpcmVjdGx5IHdpbGwgaGF2ZSBubyBlZmZlY3QuXG5cdFx0ICogQHByb3BlcnR5IHBvc2l0aW9uXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKi9cblx0XHR0aGlzLnBvc2l0aW9uID0gbnVsbDtcblx0XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHRoZSB0d2VlbidzIGN1cnJlbnQgcG9zaXRpb24gaXMgd2l0aGluIGEgcGFzc2l2ZSB3YWl0LlxuXHRcdCAqIEBwcm9wZXJ0eSBwYXNzaXZlXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5wYXNzaXZlID0gZmFsc2U7XG5cdFxuXHQvLyBwcml2YXRlIHByb3BlcnRpZXM6XHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3BhdXNlZFxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqIEBkZWZhdWx0IGZhbHNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2N1clF1ZXVlUHJvcHNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9jdXJRdWV1ZVByb3BzID0ge307XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfaW5pdFF1ZXVlUHJvcHNcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9pbml0UXVldWVQcm9wcyA9IHt9O1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3N0ZXBzXG5cdFx0ICogQHR5cGUge0FycmF5fVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9zdGVwcyA9IFtdO1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2FjdGlvbnNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2FjdGlvbnMgPSBbXTtcblx0XG5cdFx0LyoqXG5cdFx0ICogUmF3IHBvc2l0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBfcHJldlBvc2l0aW9uXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAwXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3ByZXZQb3NpdGlvbiA9IDA7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIFRoZSBwb3NpdGlvbiB3aXRoaW4gdGhlIGN1cnJlbnQgc3RlcC5cblx0XHQgKiBAcHJvcGVydHkgX3N0ZXBQb3NpdGlvblxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICogQGRlZmF1bHQgMFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9zdGVwUG9zaXRpb24gPSAwOyAvLyB0aGlzIGlzIG5lZWRlZCBieSBNb3ZpZUNsaXAuXG5cdFxuXHRcdC8qKlxuXHRcdCAqIE5vcm1hbGl6ZWQgcG9zaXRpb24uXG5cdFx0ICogQHByb3BlcnR5IF9wcmV2UG9zXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKiBAZGVmYXVsdCAtMVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9wcmV2UG9zID0gLTE7XG5cdFxuXHRcdC8qKlxuXHRcdCAqIEBwcm9wZXJ0eSBfdGFyZ2V0XG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuXHRcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3VzZVRpY2tzXG5cdFx0ICogQHR5cGUge0Jvb2xlYW59XG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fdXNlVGlja3MgPSBmYWxzZTtcblx0XG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9pbml0ZWRcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9pbml0ZWQgPSBmYWxzZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdHdlZW4gaXMgY3VycmVudGx5IHJlZ2lzdGVyZWQgd2l0aCBUd2Vlbi5cblx0XHQgKiBAcHJvcGVydHkgX3JlZ2lzdGVyZWRcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9yZWdpc3RlcmVkID0gZmFsc2U7XG5cblxuXHRcdGlmIChwcm9wcykge1xuXHRcdFx0dGhpcy5fdXNlVGlja3MgPSBwcm9wcy51c2VUaWNrcztcblx0XHRcdHRoaXMuaWdub3JlR2xvYmFsUGF1c2UgPSBwcm9wcy5pZ25vcmVHbG9iYWxQYXVzZTtcblx0XHRcdHRoaXMubG9vcCA9IHByb3BzLmxvb3A7XG5cdFx0XHRwcm9wcy5vbkNoYW5nZSAmJiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgcHJvcHMub25DaGFuZ2UpO1xuXHRcdFx0aWYgKHByb3BzLm92ZXJyaWRlKSB7IFR3ZWVuLnJlbW92ZVR3ZWVucyh0YXJnZXQpOyB9XG5cdFx0fVxuXHRcdGlmIChwcm9wcyYmcHJvcHMucGF1c2VkKSB7IHRoaXMuX3BhdXNlZD10cnVlOyB9XG5cdFx0ZWxzZSB7IGNyZWF0ZWpzLlR3ZWVuLl9yZWdpc3Rlcih0aGlzLHRydWUpOyB9XG5cdFx0aWYgKHByb3BzJiZwcm9wcy5wb3NpdGlvbiE9bnVsbCkgeyB0aGlzLnNldFBvc2l0aW9uKHByb3BzLnBvc2l0aW9uLCBUd2Vlbi5OT05FKTsgfVxuXG5cdH07XG5cblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoVHdlZW4sIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cdFxuXG4vLyBzdGF0aWMgcHJvcGVydGllc1xuXHQvKipcblx0ICogQ29uc3RhbnQgZGVmaW5pbmcgdGhlIG5vbmUgYWN0aW9uc01vZGUgZm9yIHVzZSB3aXRoIHNldFBvc2l0aW9uLlxuXHQgKiBAcHJvcGVydHkgTk9ORVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICogQGRlZmF1bHQgMFxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUd2Vlbi5OT05FID0gMDtcblxuXHQvKipcblx0ICogQ29uc3RhbnQgZGVmaW5pbmcgdGhlIGxvb3AgYWN0aW9uc01vZGUgZm9yIHVzZSB3aXRoIHNldFBvc2l0aW9uLlxuXHQgKiBAcHJvcGVydHkgTE9PUFxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICogQGRlZmF1bHQgMVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUd2Vlbi5MT09QID0gMTtcblxuXHQvKipcblx0ICogQ29uc3RhbnQgZGVmaW5pbmcgdGhlIHJldmVyc2UgYWN0aW9uc01vZGUgZm9yIHVzZSB3aXRoIHNldFBvc2l0aW9uLlxuXHQgKiBAcHJvcGVydHkgUkVWRVJTRVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICogQGRlZmF1bHQgMlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUd2Vlbi5SRVZFUlNFID0gMjtcblxuXHQvKipcblx0ICogQ29uc3RhbnQgcmV0dXJuZWQgYnkgcGx1Z2lucyB0byB0ZWxsIHRoZSB0d2VlbiBub3QgdG8gdXNlIGRlZmF1bHQgYXNzaWdubWVudC5cblx0ICogQHByb3BlcnR5IElHTk9SRVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VHdlZW4uSUdOT1JFID0ge307XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSBfbGlzdGVuZXJzXG5cdCAqIEB0eXBlIEFycmF5W1R3ZWVuXVxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdFR3ZWVuLl90d2VlbnMgPSBbXTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IF9wbHVnaW5zXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdFR3ZWVuLl9wbHVnaW5zID0ge307XG5cblxuLy8gc3RhdGljIG1ldGhvZHNcdFxuXHQvKipcblx0ICogUmV0dXJucyBhIG5ldyB0d2VlbiBpbnN0YW5jZS4gVGhpcyBpcyBmdW5jdGlvbmFsbHkgaWRlbnRpY2FsIHRvIHVzaW5nIFwibmV3IFR3ZWVuKC4uLilcIiwgYnV0IGxvb2tzIGNsZWFuZXJcblx0ICogd2l0aCB0aGUgY2hhaW5lZCBzeW50YXggb2YgVHdlZW5KUy5cblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKlx0XHR2YXIgdHdlZW4gPSBjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0KTtcblx0ICpcblx0ICogQG1ldGhvZCBnZXRcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCB0aGF0IHdpbGwgaGF2ZSBpdHMgcHJvcGVydGllcyB0d2VlbmVkLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXSBUaGUgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIHRvIGFwcGx5IHRvIHRoaXMgdHdlZW4gaW5zdGFuY2UgKGV4LiBge2xvb3A6dHJ1ZSwgcGF1c2VkOnRydWV9YCkuXG5cdCAqIEFsbCBwcm9wZXJ0aWVzIGRlZmF1bHQgdG8gYGZhbHNlYC4gU3VwcG9ydGVkIHByb3BzIGFyZTpcblx0ICogPFVMPlxuXHQgKiAgICA8TEk+IGxvb3A6IHNldHMgdGhlIGxvb3AgcHJvcGVydHkgb24gdGhpcyB0d2Vlbi48L0xJPlxuXHQgKiAgICA8TEk+IHVzZVRpY2tzOiB1c2VzIHRpY2tzIGZvciBhbGwgZHVyYXRpb25zIGluc3RlYWQgb2YgbWlsbGlzZWNvbmRzLjwvTEk+XG5cdCAqICAgIDxMST4gaWdub3JlR2xvYmFsUGF1c2U6IHNldHMgdGhlIHt7I2Nyb3NzTGluayBcIlR3ZWVuL2lnbm9yZUdsb2JhbFBhdXNlOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319IHByb3BlcnR5IG9uXG5cdCAqICAgIHRoaXMgdHdlZW4uPC9MST5cblx0ICogICAgPExJPiBvdmVycmlkZTogaWYgdHJ1ZSwgYGNyZWF0ZWpzLlR3ZWVuLnJlbW92ZVR3ZWVucyh0YXJnZXQpYCB3aWxsIGJlIGNhbGxlZCB0byByZW1vdmUgYW55IG90aGVyIHR3ZWVucyB3aXRoXG5cdCAqICAgIHRoZSBzYW1lIHRhcmdldC5cblx0ICogICAgPExJPiBwYXVzZWQ6IGluZGljYXRlcyB3aGV0aGVyIHRvIHN0YXJ0IHRoZSB0d2VlbiBwYXVzZWQuPC9MST5cblx0ICogICAgPExJPiBwb3NpdGlvbjogaW5kaWNhdGVzIHRoZSBpbml0aWFsIHBvc2l0aW9uIGZvciB0aGlzIHR3ZWVuLjwvTEk+XG5cdCAqICAgIDxMST4gb25DaGFuZ2U6IHNwZWNpZmllcyBhIGxpc3RlbmVyIGZvciB0aGUge3sjY3Jvc3NMaW5rIFwiVHdlZW4vY2hhbmdlOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50LjwvTEk+XG5cdCAqIDwvVUw+XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcGx1Z2luRGF0YV0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgZGF0YSBmb3IgdXNlIGJ5IGluc3RhbGxlZCBwbHVnaW5zLiBTZWUgaW5kaXZpZHVhbCBwbHVnaW5zJ1xuXHQgKiBkb2N1bWVudGF0aW9uIGZvciBkZXRhaWxzLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvdmVycmlkZT1mYWxzZV0gSWYgdHJ1ZSwgYW55IHByZXZpb3VzIHR3ZWVucyBvbiB0aGUgc2FtZSB0YXJnZXQgd2lsbCBiZSByZW1vdmVkLiBUaGlzIGlzIHRoZVxuXHQgKiBzYW1lIGFzIGNhbGxpbmcgYFR3ZWVuLnJlbW92ZVR3ZWVucyh0YXJnZXQpYC5cblx0ICogQHJldHVybiB7VHdlZW59IEEgcmVmZXJlbmNlIHRvIHRoZSBjcmVhdGVkIHR3ZWVuLiBBZGRpdGlvbmFsIGNoYWluZWQgdHdlZW5zLCBtZXRob2QgY2FsbHMsIG9yIGNhbGxiYWNrcyBjYW4gYmVcblx0ICogYXBwbGllZCB0byB0aGUgcmV0dXJuZWQgdHdlZW4gaW5zdGFuY2UuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFR3ZWVuLmdldCA9IGZ1bmN0aW9uKHRhcmdldCwgcHJvcHMsIHBsdWdpbkRhdGEsIG92ZXJyaWRlKSB7XG5cdFx0aWYgKG92ZXJyaWRlKSB7IFR3ZWVuLnJlbW92ZVR3ZWVucyh0YXJnZXQpOyB9XG5cdFx0cmV0dXJuIG5ldyBUd2Vlbih0YXJnZXQsIHByb3BzLCBwbHVnaW5EYXRhKTtcblx0fTtcblxuXHQvKipcblx0ICogQWR2YW5jZXMgYWxsIHR3ZWVucy4gVGhpcyB0eXBpY2FsbHkgdXNlcyB0aGUge3sjY3Jvc3NMaW5rIFwiVGlja2VyXCJ9fXt7L2Nyb3NzTGlua319IGNsYXNzLCBidXQgeW91IGNhbiBjYWxsIGl0XG5cdCAqIG1hbnVhbGx5IGlmIHlvdSBwcmVmZXIgdG8gdXNlIHlvdXIgb3duIFwiaGVhcnRiZWF0XCIgaW1wbGVtZW50YXRpb24uXG5cdCAqIEBtZXRob2QgdGlja1xuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgVGhlIGNoYW5nZSBpbiB0aW1lIGluIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCB0aWNrLiBSZXF1aXJlZCB1bmxlc3MgYWxsIHR3ZWVucyBoYXZlXG5cdCAqIGB1c2VUaWNrc2Agc2V0IHRvIHRydWUuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcGF1c2VkIEluZGljYXRlcyB3aGV0aGVyIGEgZ2xvYmFsIHBhdXNlIGlzIGluIGVmZmVjdC4gVHdlZW5zIHdpdGgge3sjY3Jvc3NMaW5rIFwiVHdlZW4vaWdub3JlR2xvYmFsUGF1c2U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogd2lsbCBpZ25vcmUgdGhpcywgYnV0IGFsbCBvdGhlcnMgd2lsbCBwYXVzZSBpZiB0aGlzIGlzIGB0cnVlYC5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VHdlZW4udGljayA9IGZ1bmN0aW9uKGRlbHRhLCBwYXVzZWQpIHtcblx0XHR2YXIgdHdlZW5zID0gVHdlZW4uX3R3ZWVucy5zbGljZSgpOyAvLyB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnMuXG5cdFx0Zm9yICh2YXIgaT10d2VlbnMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdHdlZW5zW2ldO1xuXHRcdFx0aWYgKChwYXVzZWQgJiYgIXR3ZWVuLmlnbm9yZUdsb2JhbFBhdXNlKSB8fCB0d2Vlbi5fcGF1c2VkKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHR0d2Vlbi50aWNrKHR3ZWVuLl91c2VUaWNrcz8xOmRlbHRhKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZSBldmVudHMgdGhhdCByZXN1bHQgZnJvbSBUd2VlbiBiZWluZyB1c2VkIGFzIGFuIGV2ZW50IGhhbmRsZXIuIFRoaXMgaXMgaW5jbHVkZWQgdG8gYWxsb3cgVHdlZW4gdG8gaGFuZGxlXG5cdCAqIHt7I2Nyb3NzTGluayBcIlRpY2tlci90aWNrOmV2ZW50XCJ9fXt7L2Nyb3NzTGlua319IGV2ZW50cyBmcm9tIHRoZSBjcmVhdGVqcyB7eyNjcm9zc0xpbmsgXCJUaWNrZXJcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIE5vIG90aGVyIGV2ZW50cyBhcmUgaGFuZGxlZCBpbiBUd2Vlbi5cblx0ICogQG1ldGhvZCBoYW5kbGVFdmVudFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgQW4gZXZlbnQgb2JqZWN0IHBhc3NlZCBpbiBieSB0aGUge3sjY3Jvc3NMaW5rIFwiRXZlbnREaXNwYXRjaGVyXCJ9fXt7L2Nyb3NzTGlua319LiBXaWxsXG5cdCAqIHVzdWFsbHkgYmUgb2YgdHlwZSBcInRpY2tcIi5cblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKiBAc2luY2UgMC40LjJcblx0ICovXG5cdFR3ZWVuLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRpZiAoZXZlbnQudHlwZSA9PSBcInRpY2tcIikge1xuXHRcdFx0dGhpcy50aWNrKGV2ZW50LmRlbHRhLCBldmVudC5wYXVzZWQpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwgZXhpc3RpbmcgdHdlZW5zIGZvciBhIHRhcmdldC4gVGhpcyBpcyBjYWxsZWQgYXV0b21hdGljYWxseSBieSBuZXcgdHdlZW5zIGlmIHRoZSBgb3ZlcnJpZGVgXG5cdCAqIHByb3BlcnR5IGlzIGB0cnVlYC5cblx0ICogQG1ldGhvZCByZW1vdmVUd2VlbnNcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCB0byByZW1vdmUgZXhpc3RpbmcgdHdlZW5zIGZyb20uXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFR3ZWVuLnJlbW92ZVR3ZWVucyA9IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdGlmICghdGFyZ2V0LnR3ZWVuanNfY291bnQpIHsgcmV0dXJuOyB9XG5cdFx0dmFyIHR3ZWVucyA9IFR3ZWVuLl90d2VlbnM7XG5cdFx0Zm9yICh2YXIgaT10d2VlbnMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdHdlZW5zW2ldO1xuXHRcdFx0aWYgKHR3ZWVuLl90YXJnZXQgPT0gdGFyZ2V0KSB7XG5cdFx0XHRcdHR3ZWVuLl9wYXVzZWQgPSB0cnVlO1xuXHRcdFx0XHR0d2VlbnMuc3BsaWNlKGksIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0YXJnZXQudHdlZW5qc19jb3VudCA9IDA7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3AgYW5kIHJlbW92ZSBhbGwgZXhpc3RpbmcgdHdlZW5zLlxuXHQgKiBAbWV0aG9kIHJlbW92ZUFsbFR3ZWVuc1xuXHQgKiBAc3RhdGljXG5cdCAqIEBzaW5jZSAwLjQuMVxuXHQgKi9cblx0VHdlZW4ucmVtb3ZlQWxsVHdlZW5zID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHR3ZWVucyA9IFR3ZWVuLl90d2VlbnM7XG5cdFx0Zm9yICh2YXIgaT0gMCwgbD10d2VlbnMubGVuZ3RoOyBpPGw7IGkrKykge1xuXHRcdFx0dmFyIHR3ZWVuID0gdHdlZW5zW2ldO1xuXHRcdFx0dHdlZW4uX3BhdXNlZCA9IHRydWU7XG5cdFx0XHR0d2Vlbi50YXJnZXQmJih0d2Vlbi50YXJnZXQudHdlZW5qc19jb3VudCA9IDApO1xuXHRcdH1cblx0XHR0d2VlbnMubGVuZ3RoID0gMDtcblx0fTtcblxuXHQvKipcblx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBhY3RpdmUgdHdlZW5zIChhbmQgaG93IG1hbnkpIG9uIHRoZSB0YXJnZXQgb2JqZWN0IChpZiBzcGVjaWZpZWQpIG9yIGluIGdlbmVyYWwuXG5cdCAqIEBtZXRob2QgaGFzQWN0aXZlVHdlZW5zXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbdGFyZ2V0XSBUaGUgdGFyZ2V0IHRvIGNoZWNrIGZvciBhY3RpdmUgdHdlZW5zLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgaW5kaWNhdGVcblx0ICogaWYgdGhlcmUgYXJlIGFueSBhY3RpdmUgdHdlZW5zIG9uIGFueSB0YXJnZXQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IElmIHRoZXJlIGFyZSBhY3RpdmUgdHdlZW5zLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUd2Vlbi5oYXNBY3RpdmVUd2VlbnMgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRpZiAodGFyZ2V0KSB7IHJldHVybiB0YXJnZXQudHdlZW5qc19jb3VudCAhPSBudWxsICYmICEhdGFyZ2V0LnR3ZWVuanNfY291bnQ7IH1cblx0XHRyZXR1cm4gVHdlZW4uX3R3ZWVucyAmJiAhIVR3ZWVuLl90d2VlbnMubGVuZ3RoO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbnN0YWxscyBhIHBsdWdpbiwgd2hpY2ggY2FuIG1vZGlmeSBob3cgY2VydGFpbiBwcm9wZXJ0aWVzIGFyZSBoYW5kbGVkIHdoZW4gdHdlZW5lZC4gU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJDU1NQbHVnaW5cIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIGFuIGV4YW1wbGUgb2YgaG93IHRvIHdyaXRlIFR3ZWVuSlMgcGx1Z2lucy5cblx0ICogQG1ldGhvZCBpbnN0YWxsUGx1Z2luXG5cdCAqIEBzdGF0aWNcblx0ICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbiBUaGUgcGx1Z2luIGNsYXNzIHRvIGluc3RhbGxcblx0ICogQHBhcmFtIHtBcnJheX0gcHJvcGVydGllcyBBbiBhcnJheSBvZiBwcm9wZXJ0aWVzIHRoYXQgdGhlIHBsdWdpbiB3aWxsIGhhbmRsZS5cblx0ICovXG5cdFR3ZWVuLmluc3RhbGxQbHVnaW4gPSBmdW5jdGlvbihwbHVnaW4sIHByb3BlcnRpZXMpIHtcblx0XHR2YXIgcHJpb3JpdHkgPSBwbHVnaW4ucHJpb3JpdHk7XG5cdFx0aWYgKHByaW9yaXR5ID09IG51bGwpIHsgcGx1Z2luLnByaW9yaXR5ID0gcHJpb3JpdHkgPSAwOyB9XG5cdFx0Zm9yICh2YXIgaT0wLGw9cHJvcGVydGllcy5sZW5ndGgscD1Ud2Vlbi5fcGx1Z2lucztpPGw7aSsrKSB7XG5cdFx0XHR2YXIgbiA9IHByb3BlcnRpZXNbaV07XG5cdFx0XHRpZiAoIXBbbl0pIHsgcFtuXSA9IFtwbHVnaW5dOyB9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dmFyIGFyciA9IHBbbl07XG5cdFx0XHRcdGZvciAodmFyIGo9MCxqbD1hcnIubGVuZ3RoO2o8amw7aisrKSB7XG5cdFx0XHRcdFx0aWYgKHByaW9yaXR5IDwgYXJyW2pdLnByaW9yaXR5KSB7IGJyZWFrOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0cFtuXS5zcGxpY2UoaiwwLHBsdWdpbik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgb3IgdW5yZWdpc3RlcnMgYSB0d2VlbiB3aXRoIHRoZSB0aWNraW5nIHN5c3RlbS5cblx0ICogQG1ldGhvZCBfcmVnaXN0ZXJcblx0ICogQHBhcmFtIHtUd2Vlbn0gdHdlZW4gVGhlIHR3ZWVuIGluc3RhbmNlIHRvIHJlZ2lzdGVyIG9yIHVucmVnaXN0ZXIuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgSWYgYHRydWVgLCB0aGUgdHdlZW4gaXMgcmVnaXN0ZXJlZC4gSWYgYGZhbHNlYCB0aGUgdHdlZW4gaXMgdW5yZWdpc3RlcmVkLlxuXHQgKiBAc3RhdGljXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdFR3ZWVuLl9yZWdpc3RlciA9IGZ1bmN0aW9uKHR3ZWVuLCB2YWx1ZSkge1xuXHRcdHZhciB0YXJnZXQgPSB0d2Vlbi5fdGFyZ2V0O1xuXHRcdHZhciB0d2VlbnMgPSBUd2Vlbi5fdHdlZW5zO1xuXHRcdGlmICh2YWx1ZSAmJiAhdHdlZW4uX3JlZ2lzdGVyZWQpIHtcblx0XHRcdC8vIFRPRE86IHRoaXMgYXBwcm9hY2ggbWlnaHQgZmFpbCBpZiBhIGRldiBpcyB1c2luZyBzZWFsZWQgb2JqZWN0cyBpbiBFUzVcblx0XHRcdGlmICh0YXJnZXQpIHsgdGFyZ2V0LnR3ZWVuanNfY291bnQgPSB0YXJnZXQudHdlZW5qc19jb3VudCA/IHRhcmdldC50d2VlbmpzX2NvdW50KzEgOiAxOyB9XG5cdFx0XHR0d2VlbnMucHVzaCh0d2Vlbik7XG5cdFx0XHRpZiAoIVR3ZWVuLl9pbml0ZWQgJiYgY3JlYXRlanMuVGlja2VyKSB7IGNyZWF0ZWpzLlRpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBUd2Vlbik7IFR3ZWVuLl9pbml0ZWQgPSB0cnVlOyB9XG5cdFx0fSBlbHNlIGlmICghdmFsdWUgJiYgdHdlZW4uX3JlZ2lzdGVyZWQpIHtcblx0XHRcdGlmICh0YXJnZXQpIHsgdGFyZ2V0LnR3ZWVuanNfY291bnQtLTsgfVxuXHRcdFx0dmFyIGkgPSB0d2VlbnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRpZiAodHdlZW5zW2ldID09IHR3ZWVuKSB7XG5cdFx0XHRcdFx0dHdlZW5zLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0d2Vlbi5fcmVnaXN0ZXJlZCA9IHZhbHVlO1xuXHR9O1xuXG5cbi8vIGV2ZW50czpcblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuZXZlciB0aGUgdHdlZW4ncyBwb3NpdGlvbiBjaGFuZ2VzLlxuXHQgKiBAZXZlbnQgY2hhbmdlXG5cdCAqIEBzaW5jZSAwLjQuMFxuXHQgKiovXG5cdFxuXG4vLyBwdWJsaWMgbWV0aG9kczpcblx0LyoqXG5cdCAqIFF1ZXVlcyBhIHdhaXQgKGVzc2VudGlhbGx5IGFuIGVtcHR5IHR3ZWVuKS5cblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKlx0XHQvL1RoaXMgdHdlZW4gd2lsbCB3YWl0IDFzIGJlZm9yZSBhbHBoYSBpcyBmYWRlZCB0byAwLlxuXHQgKlx0XHRjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0KS53YWl0KDEwMDApLnRvKHthbHBoYTowfSwgMTAwMCk7XG5cdCAqXG5cdCAqIEBtZXRob2Qgd2FpdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSB3YWl0IGluIG1pbGxpc2Vjb25kcyAob3IgaW4gdGlja3MgaWYgYHVzZVRpY2tzYCBpcyB0cnVlKS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcGFzc2l2ZV0gVHdlZW4gcHJvcGVydGllcyB3aWxsIG5vdCBiZSB1cGRhdGVkIGR1cmluZyBhIHBhc3NpdmUgd2FpdC4gVGhpc1xuXHQgKiBpcyBtb3N0bHkgdXNlZnVsIGZvciB1c2Ugd2l0aCB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZVwifX17ey9jcm9zc0xpbmt9fSBpbnN0YW5jZXMgdGhhdCBjb250YWluIG11bHRpcGxlIHR3ZWVuc1xuXHQgKiBhZmZlY3RpbmcgdGhlIHNhbWUgdGFyZ2V0IGF0IGRpZmZlcmVudCB0aW1lcy5cblx0ICogQHJldHVybiB7VHdlZW59IFRoaXMgdHdlZW4gaW5zdGFuY2UgKGZvciBjaGFpbmluZyBjYWxscykuXG5cdCAqKi9cblx0cC53YWl0ID0gZnVuY3Rpb24oZHVyYXRpb24sIHBhc3NpdmUpIHtcblx0XHRpZiAoZHVyYXRpb24gPT0gbnVsbCB8fCBkdXJhdGlvbiA8PSAwKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dmFyIG8gPSB0aGlzLl9jbG9uZVByb3BzKHRoaXMuX2N1clF1ZXVlUHJvcHMpO1xuXHRcdHJldHVybiB0aGlzLl9hZGRTdGVwKHtkOmR1cmF0aW9uLCBwMDpvLCBlOnRoaXMuX2xpbmVhckVhc2UsIHAxOm8sIHY6cGFzc2l2ZX0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBRdWV1ZXMgYSB0d2VlbiBmcm9tIHRoZSBjdXJyZW50IHZhbHVlcyB0byB0aGUgdGFyZ2V0IHByb3BlcnRpZXMuIFNldCBkdXJhdGlvbiB0byAwIHRvIGp1bXAgdG8gdGhlc2UgdmFsdWUuXG5cdCAqIE51bWVyaWMgcHJvcGVydGllcyB3aWxsIGJlIHR3ZWVuZWQgZnJvbSB0aGVpciBjdXJyZW50IHZhbHVlIGluIHRoZSB0d2VlbiB0byB0aGUgdGFyZ2V0IHZhbHVlLiBOb24tbnVtZXJpY1xuXHQgKiBwcm9wZXJ0aWVzIHdpbGwgYmUgc2V0IGF0IHRoZSBlbmQgb2YgdGhlIHNwZWNpZmllZCBkdXJhdGlvbi5cblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKlx0XHRjcmVhdGVqcy5Ud2Vlbi5nZXQodGFyZ2V0KS50byh7YWxwaGE6MH0sIDEwMDApO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHRvXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBBbiBvYmplY3Qgc3BlY2lmeWluZyBwcm9wZXJ0eSB0YXJnZXQgdmFsdWVzIGZvciB0aGlzIHR3ZWVuIChFeC4gYHt4OjMwMH1gIHdvdWxkIHR3ZWVuIHRoZSB4XG5cdCAqIHByb3BlcnR5IG9mIHRoZSB0YXJnZXQgdG8gMzAwKS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtkdXJhdGlvbj0wXSBUaGUgZHVyYXRpb24gb2YgdGhlIHdhaXQgaW4gbWlsbGlzZWNvbmRzIChvciBpbiB0aWNrcyBpZiBgdXNlVGlja3NgIGlzIHRydWUpLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZWFzZT1cImxpbmVhclwiXSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSBmb3IgdGhpcyB0d2Vlbi4gU2VlIHRoZSB7eyNjcm9zc0xpbmsgXCJFYXNlXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGNsYXNzIGZvciBhIGxpc3Qgb2YgYnVpbHQtaW4gZWFzZSBmdW5jdGlvbnMuXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBUaGlzIHR3ZWVuIGluc3RhbmNlIChmb3IgY2hhaW5pbmcgY2FsbHMpLlxuXHQgKi9cblx0cC50byA9IGZ1bmN0aW9uKHByb3BzLCBkdXJhdGlvbiwgZWFzZSkge1xuXHRcdGlmIChpc05hTihkdXJhdGlvbikgfHwgZHVyYXRpb24gPCAwKSB7IGR1cmF0aW9uID0gMDsgfVxuXHRcdHJldHVybiB0aGlzLl9hZGRTdGVwKHtkOmR1cmF0aW9ufHwwLCBwMDp0aGlzLl9jbG9uZVByb3BzKHRoaXMuX2N1clF1ZXVlUHJvcHMpLCBlOmVhc2UsIHAxOnRoaXMuX2Nsb25lUHJvcHModGhpcy5fYXBwZW5kUXVldWVQcm9wcyhwcm9wcykpfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFF1ZXVlcyBhbiBhY3Rpb24gdG8gY2FsbCB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqICAgXHQvL3dvdWxkIGNhbGwgbXlGdW5jdGlvbigpIGFmdGVyIDEgc2Vjb25kLlxuXHQgKiAgIFx0bXlUd2Vlbi53YWl0KDEwMDApLmNhbGwobXlGdW5jdGlvbik7XG5cdCAqXG5cdCAqIEBtZXRob2QgY2FsbFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cblx0ICogQHBhcmFtIHtBcnJheX0gW3BhcmFtc10uIFRoZSBwYXJhbWV0ZXJzIHRvIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGguIElmIHRoaXMgaXMgb21pdHRlZCwgdGhlbiB0aGUgZnVuY3Rpb25cblx0ICogICAgICB3aWxsIGJlIGNhbGxlZCB3aXRoIGEgc2luZ2xlIHBhcmFtIHBvaW50aW5nIHRvIHRoaXMgdHdlZW4uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbc2NvcGVdLiBUaGUgc2NvcGUgdG8gY2FsbCB0aGUgZnVuY3Rpb24gaW4uIElmIG9taXR0ZWQsIGl0IHdpbGwgYmUgY2FsbGVkIGluIHRoZSB0YXJnZXQnc1xuXHQgKiAgICAgIHNjb3BlLlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhpcyB0d2VlbiBpbnN0YW5jZSAoZm9yIGNoYWluaW5nIGNhbGxzKS5cblx0ICovXG5cdHAuY2FsbCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZEFjdGlvbih7ZjpjYWxsYmFjaywgcDpwYXJhbXMgPyBwYXJhbXMgOiBbdGhpc10sIG86c2NvcGUgPyBzY29wZSA6IHRoaXMuX3RhcmdldH0pO1xuXHR9O1xuXG5cdC8vIFRPRE86IGFkZCBjbGFyaWZpY2F0aW9uIGJldHdlZW4gdGhpcyBhbmQgYSAwIGR1cmF0aW9uIC50bzpcblx0LyoqXG5cdCAqIFF1ZXVlcyBhbiBhY3Rpb24gdG8gc2V0IHRoZSBzcGVjaWZpZWQgcHJvcHMgb24gdGhlIHNwZWNpZmllZCB0YXJnZXQuIElmIHRhcmdldCBpcyBudWxsLCBpdCB3aWxsIHVzZSB0aGlzIHR3ZWVuJ3Ncblx0ICogdGFyZ2V0LlxuXHQgKiA8aDQ+RXhhbXBsZTwvaDQ+XG5cdCAqXG5cdCAqXHRcdG15VHdlZW4ud2FpdCgxMDAwKS5zZXQoe3Zpc2libGU6ZmFsc2V9LGZvbyk7XG5cdCAqXG5cdCAqIEBtZXRob2Qgc2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBUaGUgcHJvcGVydGllcyB0byBzZXQgKGV4LiBge3Zpc2libGU6ZmFsc2V9YCkuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbdGFyZ2V0XSBUaGUgdGFyZ2V0IHRvIHNldCB0aGUgcHJvcGVydGllcyBvbi4gSWYgb21pdHRlZCwgdGhleSB3aWxsIGJlIHNldCBvbiB0aGUgdHdlZW4ncyB0YXJnZXQuXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBUaGlzIHR3ZWVuIGluc3RhbmNlIChmb3IgY2hhaW5pbmcgY2FsbHMpLlxuXHQgKi9cblx0cC5zZXQgPSBmdW5jdGlvbihwcm9wcywgdGFyZ2V0KSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZEFjdGlvbih7Zjp0aGlzLl9zZXQsIG86dGhpcywgcDpbcHJvcHMsIHRhcmdldCA/IHRhcmdldCA6IHRoaXMuX3RhcmdldF19KTtcblx0fTtcblxuXHQvKipcblx0ICogUXVldWVzIGFuIGFjdGlvbiB0byBwbGF5ICh1bnBhdXNlKSB0aGUgc3BlY2lmaWVkIHR3ZWVuLiBUaGlzIGVuYWJsZXMgeW91IHRvIHNlcXVlbmNlIG11bHRpcGxlIHR3ZWVucy5cblx0ICogPGg0PkV4YW1wbGU8L2g0PlxuXHQgKlxuXHQgKlx0XHRteVR3ZWVuLnRvKHt4OjEwMH0sNTAwKS5wbGF5KG90aGVyVHdlZW4pO1xuXHQgKlxuXHQgKiBAbWV0aG9kIHBsYXlcblx0ICogQHBhcmFtIHtUd2Vlbn0gdHdlZW4gVGhlIHR3ZWVuIHRvIHBsYXkuXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBUaGlzIHR3ZWVuIGluc3RhbmNlIChmb3IgY2hhaW5pbmcgY2FsbHMpLlxuXHQgKi9cblx0cC5wbGF5ID0gZnVuY3Rpb24odHdlZW4pIHtcblx0XHRpZiAoIXR3ZWVuKSB7IHR3ZWVuID0gdGhpczsgfVxuXHRcdHJldHVybiB0aGlzLmNhbGwodHdlZW4uc2V0UGF1c2VkLCBbZmFsc2VdLCB0d2Vlbik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFF1ZXVlcyBhbiBhY3Rpb24gdG8gcGF1c2UgdGhlIHNwZWNpZmllZCB0d2Vlbi5cblx0ICogQG1ldGhvZCBwYXVzZVxuXHQgKiBAcGFyYW0ge1R3ZWVufSB0d2VlbiBUaGUgdHdlZW4gdG8gcGF1c2UuIElmIG51bGwsIGl0IHBhdXNlcyB0aGlzIHR3ZWVuLlxuXHQgKiBAcmV0dXJuIHtUd2Vlbn0gVGhpcyB0d2VlbiBpbnN0YW5jZSAoZm9yIGNoYWluaW5nIGNhbGxzKVxuXHQgKi9cblx0cC5wYXVzZSA9IGZ1bmN0aW9uKHR3ZWVuKSB7XG5cdFx0aWYgKCF0d2VlbikgeyB0d2VlbiA9IHRoaXM7IH1cblx0XHRyZXR1cm4gdGhpcy5jYWxsKHR3ZWVuLnNldFBhdXNlZCwgW3RydWVdLCB0d2Vlbik7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkdmFuY2VzIHRoZSB0d2VlbiB0byBhIHNwZWNpZmllZCBwb3NpdGlvbi5cblx0ICogQG1ldGhvZCBzZXRQb3NpdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVGhlIHBvc2l0aW9uIHRvIHNlZWsgdG8gaW4gbWlsbGlzZWNvbmRzIChvciB0aWNrcyBpZiB1c2VUaWNrcyBpcyB0cnVlKS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFthY3Rpb25zTW9kZT0xXSBTcGVjaWZpZXMgaG93IGFjdGlvbnMgYXJlIGhhbmRsZWQgKGllLiBjYWxsLCBzZXQsIHBsYXksIHBhdXNlKTpcblx0ICogPHVsPlxuXHQgKiAgICAgIDxsaT57eyNjcm9zc0xpbmsgXCJUd2Vlbi9OT05FOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319ICgwKSAtIHJ1biBubyBhY3Rpb25zLjwvbGk+XG5cdCAqICAgICAgPGxpPnt7I2Nyb3NzTGluayBcIlR3ZWVuL0xPT1A6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gKDEpIC0gaWYgbmV3IHBvc2l0aW9uIGlzIGxlc3MgdGhhbiBvbGQsIHRoZW4gcnVuIGFsbFxuXHQgKiAgICAgIGFjdGlvbnMgYmV0d2VlbiBvbGQgYW5kIGR1cmF0aW9uLCB0aGVuIGFsbCBhY3Rpb25zIGJldHdlZW4gMCBhbmQgbmV3LjwvbGk+XG5cdCAqICAgICAgPGxpPnt7I2Nyb3NzTGluayBcIlR3ZWVuL1JFVkVSU0U6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0gKDIpIC0gaWYgbmV3IHBvc2l0aW9uIGlzIGxlc3MgdGhhbiBvbGQsIHJ1biBhbGxcblx0ICogICAgICBhY3Rpb25zIGJldHdlZW4gdGhlbSBpbiByZXZlcnNlLjwvbGk+XG5cdCAqIDwvdWw+XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB0d2VlbiBpcyBjb21wbGV0ZSAoaWUuIHRoZSBmdWxsIHR3ZWVuIGhhcyBydW4gJiB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9sb29wOnByb3BlcnR5XCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqIGlzIGBmYWxzZWApLlxuXHQgKi9cblx0cC5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHZhbHVlLCBhY3Rpb25zTW9kZSkge1xuXHRcdGlmICh2YWx1ZSA8IDApIHsgdmFsdWUgPSAwOyB9XG5cdFx0aWYgKGFjdGlvbnNNb2RlID09IG51bGwpIHsgYWN0aW9uc01vZGUgPSAxOyB9XG5cblx0XHQvLyBub3JtYWxpemUgcG9zaXRpb246XG5cdFx0dmFyIHQgPSB2YWx1ZTtcblx0XHR2YXIgZW5kID0gZmFsc2U7XG5cdFx0aWYgKHQgPj0gdGhpcy5kdXJhdGlvbikge1xuXHRcdFx0aWYgKHRoaXMubG9vcCkgeyB0ID0gdCV0aGlzLmR1cmF0aW9uOyB9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dCA9IHRoaXMuZHVyYXRpb247XG5cdFx0XHRcdGVuZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0ID09IHRoaXMuX3ByZXZQb3MpIHsgcmV0dXJuIGVuZDsgfVxuXG5cblx0XHR2YXIgcHJldlBvcyA9IHRoaXMuX3ByZXZQb3M7XG5cdFx0dGhpcy5wb3NpdGlvbiA9IHRoaXMuX3ByZXZQb3MgPSB0OyAvLyBzZXQgdGhpcyBpbiBhZHZhbmNlIGluIGNhc2UgYW4gYWN0aW9uIG1vZGlmaWVzIHBvc2l0aW9uLlxuXHRcdHRoaXMuX3ByZXZQb3NpdGlvbiA9IHZhbHVlO1xuXG5cdFx0Ly8gaGFuZGxlIHR3ZWVuczpcblx0XHRpZiAodGhpcy5fdGFyZ2V0KSB7XG5cdFx0XHRpZiAoZW5kKSB7XG5cdFx0XHRcdC8vIGFkZHJlc3NlcyBwcm9ibGVtcyB3aXRoIGFuIGVuZGluZyB6ZXJvIGxlbmd0aCBzdGVwLlxuXHRcdFx0XHR0aGlzLl91cGRhdGVUYXJnZXRQcm9wcyhudWxsLDEpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9zdGVwcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdC8vIGZpbmQgb3VyIG5ldyB0d2VlbiBpbmRleDpcblx0XHRcdFx0Zm9yICh2YXIgaT0wLCBsPXRoaXMuX3N0ZXBzLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fc3RlcHNbaV0udCA+IHQpIHsgYnJlYWs7IH1cblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgc3RlcCA9IHRoaXMuX3N0ZXBzW2ktMV07XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVRhcmdldFByb3BzKHN0ZXAsKHRoaXMuX3N0ZXBQb3NpdGlvbiA9IHQtc3RlcC50KS9zdGVwLmQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHJ1biBhY3Rpb25zOlxuXHRcdGlmIChhY3Rpb25zTW9kZSAhPSAwICYmIHRoaXMuX2FjdGlvbnMubGVuZ3RoID4gMCkge1xuXHRcdFx0aWYgKHRoaXMuX3VzZVRpY2tzKSB7XG5cdFx0XHRcdC8vIG9ubHkgcnVuIHRoZSBhY3Rpb25zIHdlIGxhbmRlZCBvbi5cblx0XHRcdFx0dGhpcy5fcnVuQWN0aW9ucyh0LHQpO1xuXHRcdFx0fSBlbHNlIGlmIChhY3Rpb25zTW9kZSA9PSAxICYmIHQ8cHJldlBvcykge1xuXHRcdFx0XHRpZiAocHJldlBvcyAhPSB0aGlzLmR1cmF0aW9uKSB7IHRoaXMuX3J1bkFjdGlvbnMocHJldlBvcywgdGhpcy5kdXJhdGlvbik7IH1cblx0XHRcdFx0dGhpcy5fcnVuQWN0aW9ucygwLCB0LCB0cnVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3J1bkFjdGlvbnMocHJldlBvcywgdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGVuZCkgeyB0aGlzLnNldFBhdXNlZCh0cnVlKTsgfVxuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcImNoYW5nZVwiKTtcblx0XHRyZXR1cm4gZW5kO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZHZhbmNlcyB0aGlzIHR3ZWVuIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50IG9mIHRpbWUgaW4gbWlsbGlzZWNvbmRzIChvciB0aWNrcyBpZmB1c2VUaWNrc2AgaXMgYHRydWVgKS5cblx0ICogVGhpcyBpcyBub3JtYWxseSBjYWxsZWQgYXV0b21hdGljYWxseSBieSB0aGUgVHdlZW4gZW5naW5lICh2aWEge3sjY3Jvc3NMaW5rIFwiVHdlZW4vdGlja1wifX17ey9jcm9zc0xpbmt9fSksIGJ1dCBpc1xuXHQgKiBleHBvc2VkIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIHRpY2tcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhIFRoZSB0aW1lIHRvIGFkdmFuY2UgaW4gbWlsbGlzZWNvbmRzIChvciB0aWNrcyBpZiBgdXNlVGlja3NgIGlzIGB0cnVlYCkuXG5cdCAqL1xuXHRwLnRpY2sgPSBmdW5jdGlvbihkZWx0YSkge1xuXHRcdGlmICh0aGlzLl9wYXVzZWQpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5zZXRQb3NpdGlvbih0aGlzLl9wcmV2UG9zaXRpb24rZGVsdGEpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXVzZXMgb3IgcGxheXMgdGhpcyB0d2Vlbi5cblx0ICogQG1ldGhvZCBzZXRQYXVzZWRcblx0ICogQHBhcmFtIHtCb29sZWFufSBbdmFsdWU9dHJ1ZV0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHR3ZWVuIHNob3VsZCBiZSBwYXVzZWQgKGB0cnVlYCkgb3IgcGxheWVkIChgZmFsc2VgKS5cblx0ICogQHJldHVybiB7VHdlZW59IFRoaXMgdHdlZW4gaW5zdGFuY2UgKGZvciBjaGFpbmluZyBjYWxscylcblx0ICovXG5cdHAuc2V0UGF1c2VkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAodGhpcy5fcGF1c2VkID09PSAhIXZhbHVlKSB7IHJldHVybiB0aGlzOyB9XG5cdFx0dGhpcy5fcGF1c2VkID0gISF2YWx1ZTtcblx0XHRUd2Vlbi5fcmVnaXN0ZXIodGhpcywgIXZhbHVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvLyB0aW55IGFwaSAocHJpbWFyaWx5IGZvciB0b29sIG91dHB1dCk6XG5cdHAudyA9IHAud2FpdDtcblx0cC50ID0gcC50bztcblx0cC5jID0gcC5jYWxsO1xuXHRwLnMgPSBwLnNldDtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cblx0ICogQG1ldGhvZCB0b1N0cmluZ1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0ICovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbVHdlZW5dXCI7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0cC5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRocm93KFwiVHdlZW4gY2FuIG5vdCBiZSBjbG9uZWQuXCIpXG5cdH07XG5cbi8vIHByaXZhdGUgbWV0aG9kczpcblx0LyoqXG5cdCAqIEBtZXRob2QgX3VwZGF0ZVRhcmdldFByb3BzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdGVwXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSByYXRpb1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl91cGRhdGVUYXJnZXRQcm9wcyA9IGZ1bmN0aW9uKHN0ZXAsIHJhdGlvKSB7XG5cdFx0dmFyIHAwLHAxLHYsdjAsdjEsYXJyO1xuXHRcdGlmICghc3RlcCAmJiByYXRpbyA9PSAxKSB7XG5cdFx0XHQvLyBHRFM6IHdoZW4gZG9lcyB0aGlzIHJ1bj8gSnVzdCBhdCB0aGUgdmVyeSBlbmQ/IFNob3VsZG4ndC5cblx0XHRcdHRoaXMucGFzc2l2ZSA9IGZhbHNlO1xuXHRcdFx0cDAgPSBwMSA9IHRoaXMuX2N1clF1ZXVlUHJvcHM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucGFzc2l2ZSA9ICEhc3RlcC52O1xuXHRcdFx0aWYgKHRoaXMucGFzc2l2ZSkgeyByZXR1cm47IH0gLy8gZG9uJ3QgdXBkYXRlIHByb3BzLlxuXHRcdFx0Ly8gYXBwbHkgZWFzZSB0byByYXRpby5cblx0XHRcdGlmIChzdGVwLmUpIHsgcmF0aW8gPSBzdGVwLmUocmF0aW8sMCwxLDEpOyB9XG5cdFx0XHRwMCA9IHN0ZXAucDA7XG5cdFx0XHRwMSA9IHN0ZXAucDE7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgbiBpbiB0aGlzLl9pbml0UXVldWVQcm9wcykge1xuXHRcdFx0aWYgKCh2MCA9IHAwW25dKSA9PSBudWxsKSB7IHAwW25dID0gdjAgPSB0aGlzLl9pbml0UXVldWVQcm9wc1tuXTsgfVxuXHRcdFx0aWYgKCh2MSA9IHAxW25dKSA9PSBudWxsKSB7IHAxW25dID0gdjEgPSB2MDsgfVxuXHRcdFx0aWYgKHYwID09IHYxIHx8IHJhdGlvID09IDAgfHwgcmF0aW8gPT0gMSB8fCAodHlwZW9mKHYwKSAhPSBcIm51bWJlclwiKSkge1xuXHRcdFx0XHQvLyBubyBpbnRlcnBvbGF0aW9uIC0gZWl0aGVyIGF0IHN0YXJ0LCBlbmQsIHZhbHVlcyBkb24ndCBjaGFuZ2UsIG9yIHRoZSB2YWx1ZSBpcyBub24tbnVtZXJpYy5cblx0XHRcdFx0diA9IHJhdGlvID09IDEgPyB2MSA6IHYwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0diA9IHYwKyh2MS12MCkqcmF0aW87XG5cdFx0XHR9XG5cblx0XHRcdHZhciBpZ25vcmUgPSBmYWxzZTtcblx0XHRcdGlmIChhcnIgPSBUd2Vlbi5fcGx1Z2luc1tuXSkge1xuXHRcdFx0XHRmb3IgKHZhciBpPTAsbD1hcnIubGVuZ3RoO2k8bDtpKyspIHtcblx0XHRcdFx0XHR2YXIgdjIgPSBhcnJbaV0udHdlZW4odGhpcywgbiwgdiwgcDAsIHAxLCByYXRpbywgISFzdGVwJiZwMD09cDEsICFzdGVwKTtcblx0XHRcdFx0XHRpZiAodjIgPT0gVHdlZW4uSUdOT1JFKSB7IGlnbm9yZSA9IHRydWU7IH1cblx0XHRcdFx0XHRlbHNlIHsgdiA9IHYyOyB9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghaWdub3JlKSB7IHRoaXMuX3RhcmdldFtuXSA9IHY7IH1cblx0XHR9XG5cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfcnVuQWN0aW9uc1xuXHQgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRQb3Ncblx0ICogQHBhcmFtIHtOdW1iZXJ9IGVuZFBvc1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGluY2x1ZGVTdGFydFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9ydW5BY3Rpb25zID0gZnVuY3Rpb24oc3RhcnRQb3MsIGVuZFBvcywgaW5jbHVkZVN0YXJ0KSB7XG5cdFx0dmFyIHNQb3MgPSBzdGFydFBvcztcblx0XHR2YXIgZVBvcyA9IGVuZFBvcztcblx0XHR2YXIgaSA9IC0xO1xuXHRcdHZhciBqID0gdGhpcy5fYWN0aW9ucy5sZW5ndGg7XG5cdFx0dmFyIGsgPSAxO1xuXHRcdGlmIChzdGFydFBvcyA+IGVuZFBvcykge1xuXHRcdFx0Ly8gcnVubmluZyBiYWNrd2FyZHMsIGZsaXAgZXZlcnl0aGluZzpcblx0XHRcdHNQb3MgPSBlbmRQb3M7XG5cdFx0XHRlUG9zID0gc3RhcnRQb3M7XG5cdFx0XHRpID0gajtcblx0XHRcdGogPSBrID0gLTE7XG5cdFx0fVxuXHRcdHdoaWxlICgoaSs9aykgIT0gaikge1xuXHRcdFx0dmFyIGFjdGlvbiA9IHRoaXMuX2FjdGlvbnNbaV07XG5cdFx0XHR2YXIgcG9zID0gYWN0aW9uLnQ7XG5cdFx0XHRpZiAocG9zID09IGVQb3MgfHwgKHBvcyA+IHNQb3MgJiYgcG9zIDwgZVBvcykgfHwgKGluY2x1ZGVTdGFydCAmJiBwb3MgPT0gc3RhcnRQb3MpICkge1xuXHRcdFx0XHRhY3Rpb24uZi5hcHBseShhY3Rpb24ubywgYWN0aW9uLnApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfYXBwZW5kUXVldWVQcm9wc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9hcHBlbmRRdWV1ZVByb3BzID0gZnVuY3Rpb24obykge1xuXHRcdHZhciBhcnIsb2xkVmFsdWUsaSwgbCwgaW5qZWN0UHJvcHM7XG5cdFx0Zm9yICh2YXIgbiBpbiBvKSB7XG5cdFx0XHRpZiAodGhpcy5faW5pdFF1ZXVlUHJvcHNbbl0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRvbGRWYWx1ZSA9IHRoaXMuX3RhcmdldFtuXTtcblxuXHRcdFx0XHQvLyBpbml0IHBsdWdpbnM6XG5cdFx0XHRcdGlmIChhcnIgPSBUd2Vlbi5fcGx1Z2luc1tuXSkge1xuXHRcdFx0XHRcdGZvciAoaT0wLGw9YXJyLmxlbmd0aDtpPGw7aSsrKSB7XG5cdFx0XHRcdFx0XHRvbGRWYWx1ZSA9IGFycltpXS5pbml0KHRoaXMsIG4sIG9sZFZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5faW5pdFF1ZXVlUHJvcHNbbl0gPSB0aGlzLl9jdXJRdWV1ZVByb3BzW25dID0gKG9sZFZhbHVlPT09dW5kZWZpbmVkKSA/IG51bGwgOiBvbGRWYWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9sZFZhbHVlID0gdGhpcy5fY3VyUXVldWVQcm9wc1tuXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBuIGluIG8pIHtcblx0XHRcdG9sZFZhbHVlID0gdGhpcy5fY3VyUXVldWVQcm9wc1tuXTtcblx0XHRcdGlmIChhcnIgPSBUd2Vlbi5fcGx1Z2luc1tuXSkge1xuXHRcdFx0XHRpbmplY3RQcm9wcyA9IGluamVjdFByb3BzfHx7fTtcblx0XHRcdFx0Zm9yIChpPTAsIGw9YXJyLmxlbmd0aDtpPGw7aSsrKSB7XG5cdFx0XHRcdFx0Ly8gVE9ETzogcmVtb3ZlIHRoZSBjaGVjayBmb3IgLnN0ZXAgaW4gdGhlIG5leHQgdmVyc2lvbi4gSXQncyBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblx0XHRcdFx0XHRpZiAoYXJyW2ldLnN0ZXApIHsgYXJyW2ldLnN0ZXAodGhpcywgbiwgb2xkVmFsdWUsIG9bbl0sIGluamVjdFByb3BzKTsgfVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jdXJRdWV1ZVByb3BzW25dID0gb1tuXTtcblx0XHR9XG5cdFx0aWYgKGluamVjdFByb3BzKSB7IHRoaXMuX2FwcGVuZFF1ZXVlUHJvcHMoaW5qZWN0UHJvcHMpOyB9XG5cdFx0cmV0dXJuIHRoaXMuX2N1clF1ZXVlUHJvcHM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgX2Nsb25lUHJvcHNcblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2Nsb25lUHJvcHMgPSBmdW5jdGlvbihwcm9wcykge1xuXHRcdHZhciBvID0ge307XG5cdFx0Zm9yICh2YXIgbiBpbiBwcm9wcykge1xuXHRcdFx0b1tuXSA9IHByb3BzW25dO1xuXHRcdH1cblx0XHRyZXR1cm4gbztcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfYWRkU3RlcFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9hZGRTdGVwID0gZnVuY3Rpb24obykge1xuXHRcdGlmIChvLmQgPiAwKSB7XG5cdFx0XHR0aGlzLl9zdGVwcy5wdXNoKG8pO1xuXHRcdFx0by50ID0gdGhpcy5kdXJhdGlvbjtcblx0XHRcdHRoaXMuZHVyYXRpb24gKz0gby5kO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfYWRkQWN0aW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHAuX2FkZEFjdGlvbiA9IGZ1bmN0aW9uKG8pIHtcblx0XHRvLnQgPSB0aGlzLmR1cmF0aW9uO1xuXHRcdHRoaXMuX2FjdGlvbnMucHVzaChvKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBfc2V0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRwLl9zZXQgPSBmdW5jdGlvbihwcm9wcywgbykge1xuXHRcdGZvciAodmFyIG4gaW4gcHJvcHMpIHtcblx0XHRcdG9bbl0gPSBwcm9wc1tuXTtcblx0XHR9XG5cdH07XG5cblx0Y3JlYXRlanMuVHdlZW4gPSBjcmVhdGVqcy5wcm9tb3RlKFR3ZWVuLCBcIkV2ZW50RGlzcGF0Y2hlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIFRpbWVsaW5lLmpzXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuXG50aGlzLmNyZWF0ZWpzID0gdGhpcy5jcmVhdGVqc3x8e307XG5cblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0XG5cbi8vIGNvbnN0cnVjdG9yXHRcblx0LyoqXG5cdCAqIFRoZSBUaW1lbGluZSBjbGFzcyBzeW5jaHJvbml6ZXMgbXVsdGlwbGUgdHdlZW5zIGFuZCBhbGxvd3MgdGhlbSB0byBiZSBjb250cm9sbGVkIGFzIGEgZ3JvdXAuIFBsZWFzZSBub3RlIHRoYXQgaWYgYVxuXHQgKiB0aW1lbGluZSBpcyBsb29waW5nLCB0aGUgdHdlZW5zIG9uIGl0IG1heSBhcHBlYXIgdG8gbG9vcCBldmVuIGlmIHRoZSBcImxvb3BcIiBwcm9wZXJ0eSBvZiB0aGUgdHdlZW4gaXMgZmFsc2UuXG5cdCAqIEBjbGFzcyBUaW1lbGluZVxuXHQgKiBAcGFyYW0ge0FycmF5fSB0d2VlbnMgQW4gYXJyYXkgb2YgVHdlZW5zIHRvIGFkZCB0byB0aGlzIHRpbWVsaW5lLiBTZWUge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvYWRkVHdlZW5cIn19e3svY3Jvc3NMaW5rfX1cblx0ICogZm9yIG1vcmUgaW5mby5cblx0ICogQHBhcmFtIHtPYmplY3R9IGxhYmVscyBBbiBvYmplY3QgZGVmaW5pbmcgbGFiZWxzIGZvciB1c2luZyB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9nb3RvQW5kUGxheVwifX17ey9jcm9zc0xpbmt9fS97eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9nb3RvQW5kU3RvcFwifX17ey9jcm9zc0xpbmt9fS5cblx0ICogU2VlIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL3NldExhYmVsc1wifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBmb3IgZGV0YWlscy5cblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFRoZSBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMgdG8gYXBwbHkgdG8gdGhpcyB0d2VlbiBpbnN0YW5jZSAoZXguIGB7bG9vcDp0cnVlfWApLiBBbGwgcHJvcGVydGllc1xuXHQgKiBkZWZhdWx0IHRvIGZhbHNlLiBTdXBwb3J0ZWQgcHJvcHMgYXJlOjxVTD5cblx0ICogICAgPExJPiBsb29wOiBzZXRzIHRoZSBsb29wIHByb3BlcnR5IG9uIHRoaXMgdHdlZW4uPC9MST5cblx0ICogICAgPExJPiB1c2VUaWNrczogdXNlcyB0aWNrcyBmb3IgYWxsIGR1cmF0aW9ucyBpbnN0ZWFkIG9mIG1pbGxpc2Vjb25kcy48L0xJPlxuXHQgKiAgICA8TEk+IGlnbm9yZUdsb2JhbFBhdXNlOiBzZXRzIHRoZSBpZ25vcmVHbG9iYWxQYXVzZSBwcm9wZXJ0eSBvbiB0aGlzIHR3ZWVuLjwvTEk+XG5cdCAqICAgIDxMST4gcGF1c2VkOiBpbmRpY2F0ZXMgd2hldGhlciB0byBzdGFydCB0aGUgdHdlZW4gcGF1c2VkLjwvTEk+XG5cdCAqICAgIDxMST4gcG9zaXRpb246IGluZGljYXRlcyB0aGUgaW5pdGlhbCBwb3NpdGlvbiBmb3IgdGhpcyB0aW1lbGluZS48L0xJPlxuXHQgKiAgICA8TEk+IG9uQ2hhbmdlOiBzcGVjaWZpZXMgYSBsaXN0ZW5lciB0byBhZGQgZm9yIHRoZSB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZS9jaGFuZ2U6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnQuPC9MST5cblx0ICogPC9VTD5cblx0ICogQGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiovXG5cdGZ1bmN0aW9uIFRpbWVsaW5lKHR3ZWVucywgbGFiZWxzLCBwcm9wcykge1xuXHRcdHRoaXMuRXZlbnREaXNwYXRjaGVyX2NvbnN0cnVjdG9yKCk7XG5cblx0Ly8gcHVibGljIHByb3BlcnRpZXM6XG5cdFx0LyoqXG5cdFx0ICogQ2F1c2VzIHRoaXMgdGltZWxpbmUgdG8gY29udGludWUgcGxheWluZyB3aGVuIGEgZ2xvYmFsIHBhdXNlIGlzIGFjdGl2ZS5cblx0XHQgKiBAcHJvcGVydHkgaWdub3JlR2xvYmFsUGF1c2Vcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICoqL1xuXHRcdHRoaXMuaWdub3JlR2xvYmFsUGF1c2UgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0b3RhbCBkdXJhdGlvbiBvZiB0aGlzIHRpbWVsaW5lIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzIGBpcyBgdHJ1ZWApLiBUaGlzIHZhbHVlIGlzIHVzdWFsbHlcblx0XHQgKiBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgYXMgeW91IG1vZGlmeSB0aGUgdGltZWxpbmUuIFNlZSB7eyNjcm9zc0xpbmsgXCJUaW1lbGluZS91cGRhdGVEdXJhdGlvblwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXHRcdCAqIEBwcm9wZXJ0eSBkdXJhdGlvblxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcmVhZG9ubHlcblx0XHQgKiovXG5cdFx0dGhpcy5kdXJhdGlvbiA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBJZiB0cnVlLCB0aGUgdGltZWxpbmUgd2lsbCBsb29wIHdoZW4gaXQgcmVhY2hlcyB0aGUgZW5kLiBDYW4gYmUgc2V0IHZpYSB0aGUgcHJvcHMgcGFyYW0uXG5cdFx0ICogQHByb3BlcnR5IGxvb3Bcblx0XHQgKiBAdHlwZSBCb29sZWFuXG5cdFx0ICoqL1xuXHRcdHRoaXMubG9vcCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgbm9ybWFsaXplZCBwb3NpdGlvbiBvZiB0aGUgdGltZWxpbmUuIFRoaXMgd2lsbCBhbHdheXMgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kXG5cdFx0ICoge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvZHVyYXRpb246cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX0uXG5cdFx0ICogQ2hhbmdpbmcgdGhpcyBwcm9wZXJ0eSBkaXJlY3RseSB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuXHRcdCAqIEBwcm9wZXJ0eSBwb3NpdGlvblxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqIEByZWFkb25seVxuXHRcdCAqKi9cblx0XHR0aGlzLnBvc2l0aW9uID0gbnVsbDtcblxuXHRcdC8vIHByaXZhdGUgcHJvcGVydGllczpcblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3BhdXNlZFxuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF90d2VlbnNcblx0XHQgKiBAdHlwZSBBcnJheVtUd2Vlbl1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3R3ZWVucyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF9sYWJlbHNcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2xhYmVscyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX2xhYmVsTGlzdFxuXHRcdCAqIEB0eXBlIEFycmF5W09iamVjdF1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX2xhYmVsTGlzdCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3ByZXZQb3NpdGlvblxuXHRcdCAqIEB0eXBlIE51bWJlclxuXHRcdCAqIEBkZWZhdWx0IDBcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICoqL1xuXHRcdHRoaXMuX3ByZXZQb3NpdGlvbiA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBAcHJvcGVydHkgX3ByZXZQb3Ncblx0XHQgKiBAdHlwZSBOdW1iZXJcblx0XHQgKiBAZGVmYXVsdCAtMVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5fcHJldlBvcyA9IC0xO1xuXG5cdFx0LyoqXG5cdFx0ICogQHByb3BlcnR5IF91c2VUaWNrc1xuXHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiovXG5cdFx0dGhpcy5fdXNlVGlja3MgPSBmYWxzZTtcblx0XHRcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGltZWxpbmUgaXMgY3VycmVudGx5IHJlZ2lzdGVyZWQgd2l0aCBUd2Vlbi5cblx0XHQgKiBAcHJvcGVydHkgX3JlZ2lzdGVyZWRcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9yZWdpc3RlcmVkID0gZmFsc2U7XG5cblxuXHRcdGlmIChwcm9wcykge1xuXHRcdFx0dGhpcy5fdXNlVGlja3MgPSBwcm9wcy51c2VUaWNrcztcblx0XHRcdHRoaXMubG9vcCA9IHByb3BzLmxvb3A7XG5cdFx0XHR0aGlzLmlnbm9yZUdsb2JhbFBhdXNlID0gcHJvcHMuaWdub3JlR2xvYmFsUGF1c2U7XG5cdFx0XHRwcm9wcy5vbkNoYW5nZSYmdGhpcy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHByb3BzLm9uQ2hhbmdlKTtcblx0XHR9XG5cdFx0aWYgKHR3ZWVucykgeyB0aGlzLmFkZFR3ZWVuLmFwcGx5KHRoaXMsIHR3ZWVucyk7IH1cblx0XHR0aGlzLnNldExhYmVscyhsYWJlbHMpO1xuXHRcdGlmIChwcm9wcyYmcHJvcHMucGF1c2VkKSB7IHRoaXMuX3BhdXNlZD10cnVlOyB9XG5cdFx0ZWxzZSB7IGNyZWF0ZWpzLlR3ZWVuLl9yZWdpc3Rlcih0aGlzLHRydWUpOyB9XG5cdFx0aWYgKHByb3BzJiZwcm9wcy5wb3NpdGlvbiE9bnVsbCkgeyB0aGlzLnNldFBvc2l0aW9uKHByb3BzLnBvc2l0aW9uLCBjcmVhdGVqcy5Ud2Vlbi5OT05FKTsgfVxuXHRcdFxuXHR9O1xuXHRcblx0dmFyIHAgPSBjcmVhdGVqcy5leHRlbmQoVGltZWxpbmUsIGNyZWF0ZWpzLkV2ZW50RGlzcGF0Y2hlcik7XG5cblx0Ly8gVE9ETzogZGVwcmVjYXRlZFxuXHQvLyBwLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHt9OyAvLyBzZWFyY2hhYmxlIGZvciBkZXZzIHdvbmRlcmluZyB3aGVyZSBpdCBpcy4gUkVNT1ZFRC4gU2VlIGRvY3MgZm9yIGRldGFpbHMuXG5cblx0XG4vLyBldmVudHM6XG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIHRpbWVsaW5lJ3MgcG9zaXRpb24gY2hhbmdlcy5cblx0ICogQGV2ZW50IGNoYW5nZVxuXHQgKiBAc2luY2UgMC41LjBcblx0ICoqL1xuXG5cbi8vIHB1YmxpYyBtZXRob2RzOlxuXHQvKipcblx0ICogQWRkcyBvbmUgb3IgbW9yZSB0d2VlbnMgKG9yIHRpbWVsaW5lcykgdG8gdGhpcyB0aW1lbGluZS4gVGhlIHR3ZWVucyB3aWxsIGJlIHBhdXNlZCAodG8gcmVtb3ZlIHRoZW0gZnJvbSB0aGVcblx0ICogbm9ybWFsIHRpY2tpbmcgc3lzdGVtKSBhbmQgbWFuYWdlZCBieSB0aGlzIHRpbWVsaW5lLiBBZGRpbmcgYSB0d2VlbiB0byBtdWx0aXBsZSB0aW1lbGluZXMgd2lsbCByZXN1bHQgaW5cblx0ICogdW5leHBlY3RlZCBiZWhhdmlvdXIuXG5cdCAqIEBtZXRob2QgYWRkVHdlZW5cblx0ICogQHBhcmFtIHtUd2Vlbn0gLi4udHdlZW4gVGhlIHR3ZWVuKHMpIHRvIGFkZC4gQWNjZXB0cyBtdWx0aXBsZSBhcmd1bWVudHMuXG5cdCAqIEByZXR1cm4ge1R3ZWVufSBUaGUgZmlyc3QgdHdlZW4gdGhhdCB3YXMgcGFzc2VkIGluLlxuXHQgKiovXG5cdHAuYWRkVHdlZW4gPSBmdW5jdGlvbih0d2Vlbikge1xuXHRcdHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRpZiAobCA+IDEpIHtcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKyspIHsgdGhpcy5hZGRUd2Vlbihhcmd1bWVudHNbaV0pOyB9XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzWzBdO1xuXHRcdH0gZWxzZSBpZiAobCA9PSAwKSB7IHJldHVybiBudWxsOyB9XG5cdFx0dGhpcy5yZW1vdmVUd2Vlbih0d2Vlbik7XG5cdFx0dGhpcy5fdHdlZW5zLnB1c2godHdlZW4pO1xuXHRcdHR3ZWVuLnNldFBhdXNlZCh0cnVlKTtcblx0XHR0d2Vlbi5fcGF1c2VkID0gZmFsc2U7XG5cdFx0dHdlZW4uX3VzZVRpY2tzID0gdGhpcy5fdXNlVGlja3M7XG5cdFx0aWYgKHR3ZWVuLmR1cmF0aW9uID4gdGhpcy5kdXJhdGlvbikgeyB0aGlzLmR1cmF0aW9uID0gdHdlZW4uZHVyYXRpb247IH1cblx0XHRpZiAodGhpcy5fcHJldlBvcyA+PSAwKSB7IHR3ZWVuLnNldFBvc2l0aW9uKHRoaXMuX3ByZXZQb3MsIGNyZWF0ZWpzLlR3ZWVuLk5PTkUpOyB9XG5cdFx0cmV0dXJuIHR3ZWVuO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIG9uZSBvciBtb3JlIHR3ZWVucyBmcm9tIHRoaXMgdGltZWxpbmUuXG5cdCAqIEBtZXRob2QgcmVtb3ZlVHdlZW5cblx0ICogQHBhcmFtIHtUd2Vlbn0gLi4udHdlZW4gVGhlIHR3ZWVuKHMpIHRvIHJlbW92ZS4gQWNjZXB0cyBtdWx0aXBsZSBhcmd1bWVudHMuXG5cdCAqIEByZXR1cm4gQm9vbGVhbiBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgb2YgdGhlIHR3ZWVucyB3ZXJlIHN1Y2Nlc3NmdWxseSByZW1vdmVkLlxuXHQgKiovXG5cdHAucmVtb3ZlVHdlZW4gPSBmdW5jdGlvbih0d2Vlbikge1xuXHRcdHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRpZiAobCA+IDEpIHtcblx0XHRcdHZhciBnb29kID0gdHJ1ZTtcblx0XHRcdGZvciAodmFyIGk9MDsgaTxsOyBpKyspIHsgZ29vZCA9IGdvb2QgJiYgdGhpcy5yZW1vdmVUd2Vlbihhcmd1bWVudHNbaV0pOyB9XG5cdFx0XHRyZXR1cm4gZ29vZDtcblx0XHR9IGVsc2UgaWYgKGwgPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRcdHZhciB0d2VlbnMgPSB0aGlzLl90d2VlbnM7XG5cdFx0dmFyIGkgPSB0d2VlbnMubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGlmICh0d2VlbnNbaV0gPT0gdHdlZW4pIHtcblx0XHRcdFx0dHdlZW5zLnNwbGljZShpLCAxKTtcblx0XHRcdFx0aWYgKHR3ZWVuLmR1cmF0aW9uID49IHRoaXMuZHVyYXRpb24pIHsgdGhpcy51cGRhdGVEdXJhdGlvbigpOyB9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBsYWJlbCB0aGF0IGNhbiBiZSB1c2VkIHdpdGgge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX0ve3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvZ290b0FuZFN0b3BcIn19e3svY3Jvc3NMaW5rfX0uXG5cdCAqIEBtZXRob2QgYWRkTGFiZWxcblx0ICogQHBhcmFtIHtTdHJpbmd9IGxhYmVsIFRoZSBsYWJlbCBuYW1lLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRoaXMgbGFiZWwgcmVwcmVzZW50cy5cblx0ICoqL1xuXHRwLmFkZExhYmVsID0gZnVuY3Rpb24obGFiZWwsIHBvc2l0aW9uKSB7XG5cdFx0dGhpcy5fbGFiZWxzW2xhYmVsXSA9IHBvc2l0aW9uO1xuXHRcdHZhciBsaXN0ID0gdGhpcy5fbGFiZWxMaXN0O1xuXHRcdGlmIChsaXN0KSB7XG5cdFx0XHRmb3IgKHZhciBpPSAwLGw9bGlzdC5sZW5ndGg7IGk8bDsgaSsrKSB7IGlmIChwb3NpdGlvbiA8IGxpc3RbaV0ucG9zaXRpb24pIHsgYnJlYWs7IH0gfVxuXHRcdFx0bGlzdC5zcGxpY2UoaSwgMCwge2xhYmVsOmxhYmVsLCBwb3NpdGlvbjpwb3NpdGlvbn0pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRGVmaW5lcyBsYWJlbHMgZm9yIHVzZSB3aXRoIGdvdG9BbmRQbGF5L1N0b3AuIE92ZXJ3cml0ZXMgYW55IHByZXZpb3VzbHkgc2V0IGxhYmVscy5cblx0ICogQG1ldGhvZCBzZXRMYWJlbHNcblx0ICogQHBhcmFtIHtPYmplY3R9IG8gQW4gb2JqZWN0IGRlZmluaW5nIGxhYmVscyBmb3IgdXNpbmcge3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvZ290b0FuZFBsYXlcIn19e3svY3Jvc3NMaW5rfX0ve3sjY3Jvc3NMaW5rIFwiVGltZWxpbmUvZ290b0FuZFN0b3BcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaW4gdGhlIGZvcm0gYHtsYWJlbE5hbWU6dGltZX1gIHdoZXJlIHRpbWUgaXMgaW4gbWlsbGlzZWNvbmRzIChvciB0aWNrcyBpZiBgdXNlVGlja3NgIGlzIGB0cnVlYCkuXG5cdCAqKi9cblx0cC5zZXRMYWJlbHMgPSBmdW5jdGlvbihvKSB7XG5cdFx0dGhpcy5fbGFiZWxzID0gbyA/ICBvIDoge307XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzb3J0ZWQgbGlzdCBvZiB0aGUgbGFiZWxzIGRlZmluZWQgb24gdGhpcyB0aW1lbGluZS5cblx0ICogQG1ldGhvZCBnZXRMYWJlbHNcblx0ICogQHJldHVybiB7QXJyYXlbT2JqZWN0XX0gQSBzb3J0ZWQgYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGxhYmVsIGFuZCBwb3NpdGlvbiBwcm9wZXJ0aWVzLlxuXHQgKiovXG5cdHAuZ2V0TGFiZWxzID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxpc3QgPSB0aGlzLl9sYWJlbExpc3Q7XG5cdFx0aWYgKCFsaXN0KSB7XG5cdFx0XHRsaXN0ID0gdGhpcy5fbGFiZWxMaXN0ID0gW107XG5cdFx0XHR2YXIgbGFiZWxzID0gdGhpcy5fbGFiZWxzO1xuXHRcdFx0Zm9yICh2YXIgbiBpbiBsYWJlbHMpIHtcblx0XHRcdFx0bGlzdC5wdXNoKHtsYWJlbDpuLCBwb3NpdGlvbjpsYWJlbHNbbl19KTtcblx0XHRcdH1cblx0XHRcdGxpc3Quc29ydChmdW5jdGlvbiAoYSxiKSB7IHJldHVybiBhLnBvc2l0aW9uLSBiLnBvc2l0aW9uOyB9KTtcblx0XHR9XG5cdFx0cmV0dXJuIGxpc3Q7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGxhYmVsIG9uIG9yIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY3VycmVudCBwb3NpdGlvbi4gRm9yIGV4YW1wbGUsIGdpdmVuIGEgdGltZWxpbmUgd2l0aFxuXHQgKiB0d28gbGFiZWxzLCBcImZpcnN0XCIgb24gZnJhbWUgaW5kZXggNCwgYW5kIFwic2Vjb25kXCIgb24gZnJhbWUgOCwgZ2V0Q3VycmVudExhYmVsIHdvdWxkIHJldHVybjpcblx0ICogPFVMPlxuXHQgKiBcdFx0PExJPm51bGwgaWYgdGhlIGN1cnJlbnQgcG9zaXRpb24gaXMgMi48L0xJPlxuXHQgKiBcdFx0PExJPlwiZmlyc3RcIiBpZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpcyA0LjwvTEk+XG5cdCAqIFx0XHQ8TEk+XCJmaXJzdFwiIGlmIHRoZSBjdXJyZW50IHBvc2l0aW9uIGlzIDcuPC9MST5cblx0ICogXHRcdDxMST5cInNlY29uZFwiIGlmIHRoZSBjdXJyZW50IHBvc2l0aW9uIGlzIDE1LjwvTEk+XG5cdCAqIDwvVUw+XG5cdCAqIEBtZXRob2QgZ2V0Q3VycmVudExhYmVsXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgbGFiZWwgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBsYWJlbFxuXHQgKiovXG5cdHAuZ2V0Q3VycmVudExhYmVsID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG5cdFx0dmFyIHBvcyA9IHRoaXMucG9zaXRpb247XG5cdFx0dmFyIGwgPSBsYWJlbHMubGVuZ3RoO1xuXHRcdGlmIChsKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaTxsOyBpKyspIHsgaWYgKHBvcyA8IGxhYmVsc1tpXS5wb3NpdGlvbikgeyBicmVhazsgfSB9XG5cdFx0XHRyZXR1cm4gKGk9PTApID8gbnVsbCA6IGxhYmVsc1tpLTFdLmxhYmVsO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogVW5wYXVzZXMgdGhpcyB0aW1lbGluZSBhbmQganVtcHMgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBvciBsYWJlbC5cblx0ICogQG1ldGhvZCBnb3RvQW5kUGxheVxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHBvc2l0aW9uT3JMYWJlbCBUaGUgcG9zaXRpb24gaW4gbWlsbGlzZWNvbmRzIChvciB0aWNrcyBpZiBgdXNlVGlja3NgIGlzIGB0cnVlYClcblx0ICogb3IgbGFiZWwgdG8ganVtcCB0by5cblx0ICoqL1xuXHRwLmdvdG9BbmRQbGF5ID0gZnVuY3Rpb24ocG9zaXRpb25PckxhYmVsKSB7XG5cdFx0dGhpcy5zZXRQYXVzZWQoZmFsc2UpO1xuXHRcdHRoaXMuX2dvdG8ocG9zaXRpb25PckxhYmVsKTtcblx0fTtcblxuXHQvKipcblx0ICogUGF1c2VzIHRoaXMgdGltZWxpbmUgYW5kIGp1bXBzIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gb3IgbGFiZWwuXG5cdCAqIEBtZXRob2QgZ290b0FuZFN0b3Bcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBwb3NpdGlvbk9yTGFiZWwgVGhlIHBvc2l0aW9uIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzYCBpcyBgdHJ1ZWApIG9yIGxhYmVsXG5cdCAqIHRvIGp1bXAgdG8uXG5cdCAqKi9cblx0cC5nb3RvQW5kU3RvcCA9IGZ1bmN0aW9uKHBvc2l0aW9uT3JMYWJlbCkge1xuXHRcdHRoaXMuc2V0UGF1c2VkKHRydWUpO1xuXHRcdHRoaXMuX2dvdG8ocG9zaXRpb25PckxhYmVsKTtcblx0fTtcblxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhlIHRpbWVsaW5lIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uXG5cdCAqIEBtZXRob2Qgc2V0UG9zaXRpb25cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFRoZSBwb3NpdGlvbiB0byBzZWVrIHRvIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzYCBpcyBgdHJ1ZWApLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2FjdGlvbnNNb2RlXSBwYXJhbWV0ZXIgc3BlY2lmeWluZyBob3cgYWN0aW9ucyBhcmUgaGFuZGxlZC4gU2VlIHRoZSBUd2VlbiB7eyNjcm9zc0xpbmsgXCJUd2Vlbi9zZXRQb3NpdGlvblwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBtZXRob2QgZm9yIG1vcmUgZGV0YWlscy5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRpbWVsaW5lIGlzIGNvbXBsZXRlIChpZS4gdGhlIGZ1bGwgdGltZWxpbmUgaGFzIHJ1biAmIHt7I2Nyb3NzTGluayBcIlRpbWVsaW5lL2xvb3A6cHJvcGVydHlcIn19e3svY3Jvc3NMaW5rfX1cblx0ICogaXMgYGZhbHNlYCkuXG5cdCAqKi9cblx0cC5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHZhbHVlLCBhY3Rpb25zTW9kZSkge1xuXHRcdHZhciB0ID0gdGhpcy5fY2FsY1Bvc2l0aW9uKHZhbHVlKTtcblx0XHR2YXIgZW5kID0gIXRoaXMubG9vcCAmJiB2YWx1ZSA+PSB0aGlzLmR1cmF0aW9uO1xuXHRcdGlmICh0ID09IHRoaXMuX3ByZXZQb3MpIHsgcmV0dXJuIGVuZDsgfVxuXHRcdHRoaXMuX3ByZXZQb3NpdGlvbiA9IHZhbHVlO1xuXHRcdHRoaXMucG9zaXRpb24gPSB0aGlzLl9wcmV2UG9zID0gdDsgLy8gaW4gY2FzZSBhbiBhY3Rpb24gY2hhbmdlcyB0aGUgY3VycmVudCBmcmFtZS5cblx0XHRmb3IgKHZhciBpPTAsIGw9dGhpcy5fdHdlZW5zLmxlbmd0aDsgaTxsOyBpKyspIHtcblx0XHRcdHRoaXMuX3R3ZWVuc1tpXS5zZXRQb3NpdGlvbih0LCBhY3Rpb25zTW9kZSk7XG5cdFx0XHRpZiAodCAhPSB0aGlzLl9wcmV2UG9zKSB7IHJldHVybiBmYWxzZTsgfSAvLyBhbiBhY3Rpb24gY2hhbmdlZCB0aGlzIHRpbWVsaW5lJ3MgcG9zaXRpb24uXG5cdFx0fVxuXHRcdGlmIChlbmQpIHsgdGhpcy5zZXRQYXVzZWQodHJ1ZSk7IH1cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoXCJjaGFuZ2VcIik7XG5cdFx0cmV0dXJuIGVuZDtcblx0fTtcblxuXHQvKipcblx0ICogUGF1c2VzIG9yIHBsYXlzIHRoaXMgdGltZWxpbmUuXG5cdCAqIEBtZXRob2Qgc2V0UGF1c2VkXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHR3ZWVuIHNob3VsZCBiZSBwYXVzZWQgKGB0cnVlYCkgb3IgcGxheWVkIChgZmFsc2VgKS5cblx0ICoqL1xuXHRwLnNldFBhdXNlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dGhpcy5fcGF1c2VkID0gISF2YWx1ZTsgXG5cdFx0Y3JlYXRlanMuVHdlZW4uX3JlZ2lzdGVyKHRoaXMsICF2YWx1ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlY2FsY3VsYXRlcyB0aGUgZHVyYXRpb24gb2YgdGhlIHRpbWVsaW5lLiBUaGUgZHVyYXRpb24gaXMgYXV0b21hdGljYWxseSB1cGRhdGVkIHdoZW4gdHdlZW5zIGFyZSBhZGRlZCBvciByZW1vdmVkLFxuXHQgKiBidXQgdGhpcyBtZXRob2QgaXMgdXNlZnVsIGlmIHlvdSBtb2RpZnkgYSB0d2VlbiBhZnRlciBpdCB3YXMgYWRkZWQgdG8gdGhlIHRpbWVsaW5lLlxuXHQgKiBAbWV0aG9kIHVwZGF0ZUR1cmF0aW9uXG5cdCAqKi9cblx0cC51cGRhdGVEdXJhdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZHVyYXRpb24gPSAwO1xuXHRcdGZvciAodmFyIGk9MCxsPXRoaXMuX3R3ZWVucy5sZW5ndGg7IGk8bDsgaSsrKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLl90d2VlbnNbaV07XG5cdFx0XHRpZiAodHdlZW4uZHVyYXRpb24gPiB0aGlzLmR1cmF0aW9uKSB7IHRoaXMuZHVyYXRpb24gPSB0d2Vlbi5kdXJhdGlvbjsgfVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhpcyB0aW1lbGluZSBieSB0aGUgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lIGluIG1pbGxpc2Vjb25kcyAob3IgdGlja3MgaWYgYHVzZVRpY2tzYCBpcyBgdHJ1ZWApLlxuXHQgKiBUaGlzIGlzIG5vcm1hbGx5IGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBUd2VlbiBlbmdpbmUgKHZpYSB0aGUge3sjY3Jvc3NMaW5rIFwiVHdlZW4vdGljazpldmVudFwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBldmVudCksIGJ1dCBpcyBleHBvc2VkIGZvciBhZHZhbmNlZCB1c2VzLlxuXHQgKiBAbWV0aG9kIHRpY2tcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhIFRoZSB0aW1lIHRvIGFkdmFuY2UgaW4gbWlsbGlzZWNvbmRzIChvciB0aWNrcyBpZiB1c2VUaWNrcyBpcyB0cnVlKS5cblx0ICoqL1xuXHRwLnRpY2sgPSBmdW5jdGlvbihkZWx0YSkge1xuXHRcdHRoaXMuc2V0UG9zaXRpb24odGhpcy5fcHJldlBvc2l0aW9uK2RlbHRhKTtcblx0fTtcblxuXHQvKipcblx0ICogSWYgYSBudW1lcmljIHBvc2l0aW9uIGlzIHBhc3NlZCwgaXQgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLiBJZiBhIHN0cmluZyBpcyBwYXNzZWQsIHRoZSBwb3NpdGlvbiBvZiB0aGVcblx0ICogY29ycmVzcG9uZGluZyBmcmFtZSBsYWJlbCB3aWxsIGJlIHJldHVybmVkLCBvciBgbnVsbGAgaWYgYSBtYXRjaGluZyBsYWJlbCBpcyBub3QgZGVmaW5lZC5cblx0ICogQG1ldGhvZCByZXNvbHZlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gcG9zaXRpb25PckxhYmVsIEEgbnVtZXJpYyBwb3NpdGlvbiB2YWx1ZSBvciBsYWJlbCBzdHJpbmcuXG5cdCAqKi9cblx0cC5yZXNvbHZlID0gZnVuY3Rpb24ocG9zaXRpb25PckxhYmVsKSB7XG5cdFx0dmFyIHBvcyA9IE51bWJlcihwb3NpdGlvbk9yTGFiZWwpO1xuXHRcdGlmIChpc05hTihwb3MpKSB7IHBvcyA9IHRoaXMuX2xhYmVsc1twb3NpdGlvbk9yTGFiZWxdOyB9XG5cdFx0cmV0dXJuIHBvcztcblx0fTtcblxuXHQvKipcblx0KiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuXHQqIEBtZXRob2QgdG9TdHJpbmdcblx0KiBAcmV0dXJuIHtTdHJpbmd9IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnN0YW5jZS5cblx0KiovXG5cdHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJbVGltZWxpbmVdXCI7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgY2xvbmVcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuY2xvbmUgPSBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyhcIlRpbWVsaW5lIGNhbiBub3QgYmUgY2xvbmVkLlwiKVxuXHR9O1xuXG4vLyBwcml2YXRlIG1ldGhvZHM6XG5cdC8qKlxuXHQgKiBAbWV0aG9kIF9nb3RvXG5cdCAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBwb3NpdGlvbk9yTGFiZWxcblx0ICogQHByb3RlY3RlZFxuXHQgKiovXG5cdHAuX2dvdG8gPSBmdW5jdGlvbihwb3NpdGlvbk9yTGFiZWwpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5yZXNvbHZlKHBvc2l0aW9uT3JMYWJlbCk7XG5cdFx0aWYgKHBvcyAhPSBudWxsKSB7IHRoaXMuc2V0UG9zaXRpb24ocG9zKTsgfVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIEBtZXRob2QgX2NhbGNQb3NpdGlvblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqKi9cblx0cC5fY2FsY1Bvc2l0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPCAwKSB7IHJldHVybiAwOyB9XG5cdFx0aWYgKHZhbHVlIDwgdGhpcy5kdXJhdGlvbikgeyByZXR1cm4gdmFsdWU7IH1cblx0XHRyZXR1cm4gdGhpcy5sb29wID8gdmFsdWUldGhpcy5kdXJhdGlvbiA6IHRoaXMuZHVyYXRpb247XG5cdH07XG5cblx0Y3JlYXRlanMuVGltZWxpbmUgPSBjcmVhdGVqcy5wcm9tb3RlKFRpbWVsaW5lLCBcIkV2ZW50RGlzcGF0Y2hlclwiKTtcblxufSgpKTtcblxuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbi8vIEVhc2UuanNcbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG5cbnRoaXMuY3JlYXRlanMgPSB0aGlzLmNyZWF0ZWpzfHx7fTtcblxuKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKipcblx0ICogVGhlIEVhc2UgY2xhc3MgcHJvdmlkZXMgYSBjb2xsZWN0aW9uIG9mIGVhc2luZyBmdW5jdGlvbnMgZm9yIHVzZSB3aXRoIFR3ZWVuSlMuIEl0IGRvZXMgbm90IHVzZSB0aGUgc3RhbmRhcmQgNCBwYXJhbVxuXHQgKiBlYXNpbmcgc2lnbmF0dXJlLiBJbnN0ZWFkIGl0IHVzZXMgYSBzaW5nbGUgcGFyYW0gd2hpY2ggaW5kaWNhdGVzIHRoZSBjdXJyZW50IGxpbmVhciByYXRpbyAoMCB0byAxKSBvZiB0aGUgdHdlZW4uXG5cdCAqXG5cdCAqIE1vc3QgbWV0aG9kcyBvbiBFYXNlIGNhbiBiZSBwYXNzZWQgZGlyZWN0bHkgYXMgZWFzaW5nIGZ1bmN0aW9uczpcblx0ICpcblx0ICogICAgICBUd2Vlbi5nZXQodGFyZ2V0KS50byh7eDoxMDB9LCA1MDAsIEVhc2UubGluZWFyKTtcblx0ICpcblx0ICogSG93ZXZlciwgbWV0aG9kcyBiZWdpbm5pbmcgd2l0aCBcImdldFwiIHdpbGwgcmV0dXJuIGFuIGVhc2luZyBmdW5jdGlvbiBiYXNlZCBvbiBwYXJhbWV0ZXIgdmFsdWVzOlxuXHQgKlxuXHQgKiAgICAgIFR3ZWVuLmdldCh0YXJnZXQpLnRvKHt5OjIwMH0sIDUwMCwgRWFzZS5nZXRQb3dJbigyLjIpKTtcblx0ICpcblx0ICogUGxlYXNlIHNlZSB0aGUgPGEgaHJlZj1cImh0dHA6Ly93d3cuY3JlYXRlanMuY29tL0RlbW9zL1R3ZWVuSlMvVHdlZW5fU3BhcmtUYWJsZVwiPnNwYXJrIHRhYmxlIGRlbW88L2E+IGZvciBhblxuXHQgKiBvdmVydmlldyBvZiB0aGUgZGlmZmVyZW50IGVhc2UgdHlwZXMgb24gPGEgaHJlZj1cImh0dHA6Ly90d2VlbmpzLmNvbVwiPlR3ZWVuSlMuY29tPC9hPi5cblx0ICpcblx0ICogPGVtPkVxdWF0aW9ucyBkZXJpdmVkIGZyb20gd29yayBieSBSb2JlcnQgUGVubmVyLjwvZW0+XG5cdCAqIEBjbGFzcyBFYXNlXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRmdW5jdGlvbiBFYXNlKCkge1xuXHRcdHRocm93IFwiRWFzZSBjYW5ub3QgYmUgaW5zdGFudGlhdGVkLlwiO1xuXHR9XG5cblxuLy8gc3RhdGljIG1ldGhvZHMgYW5kIHByb3BlcnRpZXNcblx0LyoqXG5cdCAqIEBtZXRob2QgbGluZWFyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UubGluZWFyID0gZnVuY3Rpb24odCkgeyByZXR1cm4gdDsgfTtcblxuXHQvKipcblx0ICogSWRlbnRpY2FsIHRvIGxpbmVhci5cblx0ICogQG1ldGhvZCBub25lXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2Uubm9uZSA9IEVhc2UubGluZWFyO1xuXG5cdC8qKlxuXHQgKiBNaW1pY3MgdGhlIHNpbXBsZSAtMTAwIHRvIDEwMCBlYXNpbmcgaW4gRmxhc2ggUHJvLlxuXHQgKiBAbWV0aG9kIGdldFxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IEEgdmFsdWUgZnJvbSAtMSAoZWFzZSBpbikgdG8gMSAoZWFzZSBvdXQpIGluZGljYXRpbmcgdGhlIHN0cmVuZ3RoIGFuZCBkaXJlY3Rpb24gb2YgdGhlIGVhc2UuXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXQgPSBmdW5jdGlvbihhbW91bnQpIHtcblx0XHRpZiAoYW1vdW50IDwgLTEpIHsgYW1vdW50ID0gLTE7IH1cblx0XHRpZiAoYW1vdW50ID4gMSkgeyBhbW91bnQgPSAxOyB9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdGlmIChhbW91bnQ9PTApIHsgcmV0dXJuIHQ7IH1cblx0XHRcdGlmIChhbW91bnQ8MCkgeyByZXR1cm4gdCoodCotYW1vdW50KzErYW1vdW50KTsgfVxuXHRcdFx0cmV0dXJuIHQqKCgyLXQpKmFtb3VudCsoMS1hbW91bnQpKTtcblx0XHR9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgZXhwb25lbnRpYWwgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRQb3dJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG93IFRoZSBleHBvbmVudCB0byB1c2UgKGV4LiAzIHdvdWxkIHJldHVybiBhIGN1YmljIGVhc2UpLlxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0UG93SW4gPSBmdW5jdGlvbihwb3cpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0cmV0dXJuIE1hdGgucG93KHQscG93KTtcblx0XHR9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgZXhwb25lbnRpYWwgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRQb3dPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvdyBUaGUgZXhwb25lbnQgdG8gdXNlIChleC4gMyB3b3VsZCByZXR1cm4gYSBjdWJpYyBlYXNlKS5cblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldFBvd091dCA9IGZ1bmN0aW9uKHBvdykge1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRyZXR1cm4gMS1NYXRoLnBvdygxLXQscG93KTtcblx0XHR9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgZXhwb25lbnRpYWwgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRQb3dJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG93IFRoZSBleHBvbmVudCB0byB1c2UgKGV4LiAzIHdvdWxkIHJldHVybiBhIGN1YmljIGVhc2UpLlxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0UG93SW5PdXQgPSBmdW5jdGlvbihwb3cpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0aWYgKCh0Kj0yKTwxKSByZXR1cm4gMC41Kk1hdGgucG93KHQscG93KTtcblx0XHRcdHJldHVybiAxLTAuNSpNYXRoLmFicyhNYXRoLnBvdygyLXQscG93KSk7XG5cdFx0fTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBxdWFkSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWFkSW4gPSBFYXNlLmdldFBvd0luKDIpO1xuXHQvKipcblx0ICogQG1ldGhvZCBxdWFkT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVhZE91dCA9IEVhc2UuZ2V0UG93T3V0KDIpO1xuXHQvKipcblx0ICogQG1ldGhvZCBxdWFkSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWFkSW5PdXQgPSBFYXNlLmdldFBvd0luT3V0KDIpO1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGN1YmljSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5jdWJpY0luID0gRWFzZS5nZXRQb3dJbigzKTtcblx0LyoqXG5cdCAqIEBtZXRob2QgY3ViaWNPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5jdWJpY091dCA9IEVhc2UuZ2V0UG93T3V0KDMpO1xuXHQvKipcblx0ICogQG1ldGhvZCBjdWJpY0luT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuY3ViaWNJbk91dCA9IEVhc2UuZ2V0UG93SW5PdXQoMyk7XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgcXVhcnRJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1YXJ0SW4gPSBFYXNlLmdldFBvd0luKDQpO1xuXHQvKipcblx0ICogQG1ldGhvZCBxdWFydE91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1YXJ0T3V0ID0gRWFzZS5nZXRQb3dPdXQoNCk7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1YXJ0SW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5xdWFydEluT3V0ID0gRWFzZS5nZXRQb3dJbk91dCg0KTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBxdWludEluXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVpbnRJbiA9IEVhc2UuZ2V0UG93SW4oNSk7XG5cdC8qKlxuXHQgKiBAbWV0aG9kIHF1aW50T3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UucXVpbnRPdXQgPSBFYXNlLmdldFBvd091dCg1KTtcblx0LyoqXG5cdCAqIEBtZXRob2QgcXVpbnRJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnF1aW50SW5PdXQgPSBFYXNlLmdldFBvd0luT3V0KDUpO1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHNpbmVJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnNpbmVJbiA9IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gMS1NYXRoLmNvcyh0Kk1hdGguUEkvMik7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2Qgc2luZU91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLnNpbmVPdXQgPSBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIE1hdGguc2luKHQqTWF0aC5QSS8yKTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBzaW5lSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5zaW5lSW5PdXQgPSBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIC0wLjUqKE1hdGguY29zKE1hdGguUEkqdCkgLSAxKTtcblx0fTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIFwiYmFjayBpblwiIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0QmFja0luXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgVGhlIHN0cmVuZ3RoIG9mIHRoZSBlYXNlLlxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0QmFja0luID0gZnVuY3Rpb24oYW1vdW50KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdHJldHVybiB0KnQqKChhbW91bnQrMSkqdC1hbW91bnQpO1xuXHRcdH07XG5cdH07XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGJhY2tJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmJhY2tJbiA9IEVhc2UuZ2V0QmFja0luKDEuNyk7XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBcImJhY2sgb3V0XCIgZWFzZS5cblx0ICogQG1ldGhvZCBnZXRCYWNrT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgVGhlIHN0cmVuZ3RoIG9mIHRoZSBlYXNlLlxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0QmFja091dCA9IGZ1bmN0aW9uKGFtb3VudCkge1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRyZXR1cm4gKC0tdCp0KigoYW1vdW50KzEpKnQgKyBhbW91bnQpICsgMSk7XG5cdFx0fTtcblx0fTtcblx0LyoqXG5cdCAqIEBtZXRob2QgYmFja091dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmJhY2tPdXQgPSBFYXNlLmdldEJhY2tPdXQoMS43KTtcblxuXHQvKipcblx0ICogQ29uZmlndXJhYmxlIFwiYmFjayBpbiBvdXRcIiBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldEJhY2tJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IFRoZSBzdHJlbmd0aCBvZiB0aGUgZWFzZS5cblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldEJhY2tJbk91dCA9IGZ1bmN0aW9uKGFtb3VudCkge1xuXHRcdGFtb3VudCo9MS41MjU7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdGlmICgodCo9Mik8MSkgcmV0dXJuIDAuNSoodCp0KigoYW1vdW50KzEpKnQtYW1vdW50KSk7XG5cdFx0XHRyZXR1cm4gMC41KigodC09MikqdCooKGFtb3VudCsxKSp0K2Ftb3VudCkrMik7XG5cdFx0fTtcblx0fTtcblx0LyoqXG5cdCAqIEBtZXRob2QgYmFja0luT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuYmFja0luT3V0ID0gRWFzZS5nZXRCYWNrSW5PdXQoMS43KTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBjaXJjSW5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5jaXJjSW4gPSBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIC0oTWF0aC5zcXJ0KDEtdCp0KS0gMSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgY2lyY091dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmNpcmNPdXQgPSBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydCgxLSgtLXQpKnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGNpcmNJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmNpcmNJbk91dCA9IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAoKHQqPTIpIDwgMSkgcmV0dXJuIC0wLjUqKE1hdGguc3FydCgxLXQqdCktMSk7XG5cdFx0cmV0dXJuIDAuNSooTWF0aC5zcXJ0KDEtKHQtPTIpKnQpKzEpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGJvdW5jZUluXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuYm91bmNlSW4gPSBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIDEtRWFzZS5ib3VuY2VPdXQoMS10KTtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCBib3VuY2VPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5ib3VuY2VPdXQgPSBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKHQgPCAxLzIuNzUpIHtcblx0XHRcdHJldHVybiAoNy41NjI1KnQqdCk7XG5cdFx0fSBlbHNlIGlmICh0IDwgMi8yLjc1KSB7XG5cdFx0XHRyZXR1cm4gKDcuNTYyNSoodC09MS41LzIuNzUpKnQrMC43NSk7XG5cdFx0fSBlbHNlIGlmICh0IDwgMi41LzIuNzUpIHtcblx0XHRcdHJldHVybiAoNy41NjI1Kih0LT0yLjI1LzIuNzUpKnQrMC45Mzc1KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuICg3LjU2MjUqKHQtPTIuNjI1LzIuNzUpKnQgKzAuOTg0Mzc1KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgYm91bmNlSW5PdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqKi9cblx0RWFzZS5ib3VuY2VJbk91dCA9IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodDwwLjUpIHJldHVybiBFYXNlLmJvdW5jZUluICh0KjIpICogLjU7XG5cdFx0cmV0dXJuIEVhc2UuYm91bmNlT3V0KHQqMi0xKSowLjUrMC41O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgZWxhc3RpYyBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldEVsYXN0aWNJblxuXHQgKiBAcGFyYW0ge051bWJlcn0gYW1wbGl0dWRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwZXJpb2Rcblx0ICogQHN0YXRpY1xuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0ICoqL1xuXHRFYXNlLmdldEVsYXN0aWNJbiA9IGZ1bmN0aW9uKGFtcGxpdHVkZSxwZXJpb2QpIHtcblx0XHR2YXIgcGkyID0gTWF0aC5QSSoyO1xuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHRpZiAodD09MCB8fCB0PT0xKSByZXR1cm4gdDtcblx0XHRcdHZhciBzID0gcGVyaW9kL3BpMipNYXRoLmFzaW4oMS9hbXBsaXR1ZGUpO1xuXHRcdFx0cmV0dXJuIC0oYW1wbGl0dWRlKk1hdGgucG93KDIsMTAqKHQtPTEpKSpNYXRoLnNpbigodC1zKSpwaTIvcGVyaW9kKSk7XG5cdFx0fTtcblx0fTtcblx0LyoqXG5cdCAqIEBtZXRob2QgZWxhc3RpY0luXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuZWxhc3RpY0luID0gRWFzZS5nZXRFbGFzdGljSW4oMSwwLjMpO1xuXG5cdC8qKlxuXHQgKiBDb25maWd1cmFibGUgZWxhc3RpYyBlYXNlLlxuXHQgKiBAbWV0aG9kIGdldEVsYXN0aWNPdXRcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGFtcGxpdHVkZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gcGVyaW9kXG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqKi9cblx0RWFzZS5nZXRFbGFzdGljT3V0ID0gZnVuY3Rpb24oYW1wbGl0dWRlLHBlcmlvZCkge1xuXHRcdHZhciBwaTIgPSBNYXRoLlBJKjI7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdGlmICh0PT0wIHx8IHQ9PTEpIHJldHVybiB0O1xuXHRcdFx0dmFyIHMgPSBwZXJpb2QvcGkyICogTWF0aC5hc2luKDEvYW1wbGl0dWRlKTtcblx0XHRcdHJldHVybiAoYW1wbGl0dWRlKk1hdGgucG93KDIsLTEwKnQpKk1hdGguc2luKCh0LXMpKnBpMi9wZXJpb2QgKSsxKTtcblx0XHR9O1xuXHR9O1xuXHQvKipcblx0ICogQG1ldGhvZCBlbGFzdGljT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0XG5cdCAqIEBzdGF0aWNcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiovXG5cdEVhc2UuZWxhc3RpY091dCA9IEVhc2UuZ2V0RWxhc3RpY091dCgxLDAuMyk7XG5cblx0LyoqXG5cdCAqIENvbmZpZ3VyYWJsZSBlbGFzdGljIGVhc2UuXG5cdCAqIEBtZXRob2QgZ2V0RWxhc3RpY0luT3V0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBhbXBsaXR1ZGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBlcmlvZFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiovXG5cdEVhc2UuZ2V0RWxhc3RpY0luT3V0ID0gZnVuY3Rpb24oYW1wbGl0dWRlLHBlcmlvZCkge1xuXHRcdHZhciBwaTIgPSBNYXRoLlBJKjI7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdHZhciBzID0gcGVyaW9kL3BpMiAqIE1hdGguYXNpbigxL2FtcGxpdHVkZSk7XG5cdFx0XHRpZiAoKHQqPTIpPDEpIHJldHVybiAtMC41KihhbXBsaXR1ZGUqTWF0aC5wb3coMiwxMCoodC09MSkpKk1hdGguc2luKCAodC1zKSpwaTIvcGVyaW9kICkpO1xuXHRcdFx0cmV0dXJuIGFtcGxpdHVkZSpNYXRoLnBvdygyLC0xMCoodC09MSkpKk1hdGguc2luKCh0LXMpKnBpMi9wZXJpb2QpKjAuNSsxO1xuXHRcdH07XG5cdH07XG5cdC8qKlxuXHQgKiBAbWV0aG9kIGVsYXN0aWNJbk91dFxuXHQgKiBAcGFyYW0ge051bWJlcn0gdFxuXHQgKiBAc3RhdGljXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICoqL1xuXHRFYXNlLmVsYXN0aWNJbk91dCA9IEVhc2UuZ2V0RWxhc3RpY0luT3V0KDEsMC4zKjEuNSk7XG5cblx0Y3JlYXRlanMuRWFzZSA9IEVhc2U7XG5cbn0oKSk7XG5cbi8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4vLyBNb3Rpb25HdWlkZVBsdWdpbi5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanN8fHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKlxuXHQgKiBBIFR3ZWVuSlMgcGx1Z2luIGZvciB3b3JraW5nIHdpdGggbW90aW9uIGd1aWRlcy5cblx0ICpcblx0ICogVG8gdXNlLCBpbnN0YWxsIHRoZSBwbHVnaW4gYWZ0ZXIgVHdlZW5KUyBoYXMgbG9hZGVkLiBOZXh0IHR3ZWVuIHRoZSAnZ3VpZGUnIHByb3BlcnR5IHdpdGggYW4gb2JqZWN0IGFzIGRldGFpbGVkIGJlbG93LlxuXHQgKlxuXHQgKiAgICAgICBjcmVhdGVqcy5Nb3Rpb25HdWlkZVBsdWdpbi5pbnN0YWxsKCk7XG5cdCAqXG5cdCAqIDxoND5FeGFtcGxlPC9oND5cblx0ICpcblx0ICogICAgICAvLyBVc2luZyBhIE1vdGlvbiBHdWlkZVxuXHQgKlx0ICAgIGNyZWF0ZWpzLlR3ZWVuLmdldCh0YXJnZXQpLnRvKHtndWlkZTp7IHBhdGg6WzAsMCwgMCwyMDAsMjAwLDIwMCwgMjAwLDAsMCwwXSB9fSw3MDAwKTtcblx0ICpcdCAgICAvLyBWaXN1YWxpemluZyB0aGUgbGluZVxuXHQgKlx0ICAgIGdyYXBoaWNzLm1vdmVUbygwLDApLmN1cnZlVG8oMCwyMDAsMjAwLDIwMCkuY3VydmVUbygyMDAsMCwwLDApO1xuXHQgKlxuXHQgKiBFYWNoIHBhdGggbmVlZHMgcHJlLWNvbXB1dGF0aW9uIHRvIGVuc3VyZSB0aGVyZSdzIGZhc3QgcGVyZm9ybWFuY2UuIEJlY2F1c2Ugb2YgdGhlIHByZS1jb21wdXRhdGlvbiB0aGVyZSdzIG5vXG5cdCAqIGJ1aWx0IGluIHN1cHBvcnQgZm9yIHBhdGggY2hhbmdlcyBtaWQgdHdlZW4uIFRoZXNlIGFyZSB0aGUgR3VpZGUgT2JqZWN0J3MgcHJvcGVydGllczo8VUw+XG5cdCAqICAgICAgPExJPiBwYXRoOiBSZXF1aXJlZCwgQXJyYXkgOiBUaGUgeC95IHBvaW50cyB1c2VkIHRvIGRyYXcgdGhlIHBhdGggd2l0aCBhIG1vdmVUbyBhbmQgMSB0byBuIGN1cnZlVG8gY2FsbHMuPC9MST5cblx0ICogICAgICA8TEk+IHN0YXJ0OiBPcHRpb25hbCwgMC0xIDogSW5pdGlhbCBwb3NpdGlvbiwgZGVmYXVsdCAwIGV4Y2VwdCBmb3Igd2hlbiBjb250aW51aW5nIGFsb25nIHRoZSBzYW1lIHBhdGguPC9MST5cblx0ICogICAgICA8TEk+IGVuZDogT3B0aW9uYWwsIDAtMSA6IEZpbmFsIHBvc2l0aW9uLCBkZWZhdWx0IDEgaWYgbm90IHNwZWNpZmllZC48L0xJPlxuXHQgKiAgICAgIDxMST4gb3JpZW50OiBPcHRpb25hbCwgc3RyaW5nIDogXCJmaXhlZFwiL1wiYXV0b1wiL1wiY3dcIi9cImNjd1wiPFVMPlxuXHQgKlx0XHRcdFx0PExJPlwiZml4ZWRcIiBmb3JjZXMgdGhlIG9iamVjdCB0byBmYWNlIGRvd24gdGhlIHBhdGggYWxsIG1vdmVtZW50IChyZWxhdGl2ZSB0byBzdGFydCByb3RhdGlvbiksPC9MST5cblx0ICogICAgICBcdFx0PExJPlwiYXV0b1wiIHJvdGF0ZXMgdGhlIG9iamVjdCBhbG9uZyB0aGUgcGF0aCByZWxhdGl2ZSB0byB0aGUgbGluZS48L0xJPlxuXHQgKiAgICAgIFx0XHQ8TEk+XCJjd1wiL1wiY2N3XCIgZm9yY2UgY2xvY2t3aXNlIG9yIGNvdW50ZXIgY2xvY2t3aXNlIHJvdGF0aW9ucyBpbmNsdWRpbmcgZmxhc2ggbGlrZSBiZWhhdmlvdXI8L0xJPlxuXHQgKiBcdFx0PC9VTD48L0xJPlxuXHQgKiA8L1VMPlxuXHQgKiBHdWlkZSBvYmplY3RzIHNob3VsZCBub3QgYmUgc2hhcmVkIGJldHdlZW4gdHdlZW5zIGV2ZW4gaWYgYWxsIHByb3BlcnRpZXMgYXJlIGlkZW50aWNhbCwgdGhlIGxpYnJhcnkgc3RvcmVzXG5cdCAqIGluZm9ybWF0aW9uIG9uIHRoZXNlIG9iamVjdHMgaW4gdGhlIGJhY2tncm91bmQgYW5kIHNoYXJpbmcgdGhlbSBjYW4gY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvdXIuIFZhbHVlc1xuXHQgKiBvdXRzaWRlIDAtMSByYW5nZSBvZiB0d2VlbnMgd2lsbCBiZSBhIFwiYmVzdCBndWVzc1wiIGZyb20gdGhlIGFwcHJvcHJpYXRlIHBhcnQgb2YgdGhlIGRlZmluZWQgY3VydmUuXG5cdCAqXG5cdCAqIEBjbGFzcyBNb3Rpb25HdWlkZVBsdWdpblxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICoqL1xuXHRmdW5jdGlvbiBNb3Rpb25HdWlkZVBsdWdpbigpIHtcblx0XHR0aHJvdyhcIk1vdGlvbkd1aWRlUGx1Z2luIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWQuXCIpXG5cdH07XG5cblxuLy8gc3RhdGljIHByb3BlcnRpZXM6XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgcHJpb3JpdHlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0TW90aW9uR3VpZGVQbHVnaW4ucHJpb3JpdHkgPSAwOyAvLyBoaWdoIHByaW9yaXR5LCBzaG91bGQgcnVuIHNvb25lclxuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgdGVtcG9yYXJ5IHZhcmlhYmxlIHN0b3JhZ2Vcblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uX3JvdE9mZlM7XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgdGVtcG9yYXJ5IHZhcmlhYmxlIHN0b3JhZ2Vcblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uX3JvdE9mZkU7XG5cdC8qKlxuXHQgKiBAcHJvcGVydHkgdGVtcG9yYXJ5IHZhcmlhYmxlIHN0b3JhZ2Vcblx0ICogQHByaXZhdGVcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uX3JvdE5vcm1TO1xuXHQvKipcblx0ICogQHByb3BlcnR5IHRlbXBvcmFyeSB2YXJpYWJsZSBzdG9yYWdlXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdE1vdGlvbkd1aWRlUGx1Z2luLl9yb3ROb3JtRTtcblxuXG4vLyBzdGF0aWMgbWV0aG9kc1xuXHQvKipcblx0ICogSW5zdGFsbHMgdGhpcyBwbHVnaW4gZm9yIHVzZSB3aXRoIFR3ZWVuSlMuIENhbGwgdGhpcyBvbmNlIGFmdGVyIFR3ZWVuSlMgaXMgbG9hZGVkIHRvIGVuYWJsZSB0aGlzIHBsdWdpbi5cblx0ICogQG1ldGhvZCBpbnN0YWxsXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRNb3Rpb25HdWlkZVBsdWdpbi5pbnN0YWxsID0gZnVuY3Rpb24oKSB7XG5cdFx0Y3JlYXRlanMuVHdlZW4uaW5zdGFsbFBsdWdpbihNb3Rpb25HdWlkZVBsdWdpbiwgW1wiZ3VpZGVcIiwgXCJ4XCIsIFwieVwiLCBcInJvdGF0aW9uXCJdKTtcblx0XHRyZXR1cm4gY3JlYXRlanMuVHdlZW4uSUdOT1JFO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIGluaXRcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uaW5pdCA9IGZ1bmN0aW9uKHR3ZWVuLCBwcm9wLCB2YWx1ZSkge1xuXHRcdHZhciB0YXJnZXQgPSB0d2Vlbi50YXJnZXQ7XG5cdFx0aWYoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShcInhcIikpeyB0YXJnZXQueCA9IDA7IH1cblx0XHRpZighdGFyZ2V0Lmhhc093blByb3BlcnR5KFwieVwiKSl7IHRhcmdldC55ID0gMDsgfVxuXHRcdGlmKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoXCJyb3RhdGlvblwiKSl7IHRhcmdldC5yb3RhdGlvbiA9IDA7IH1cblxuXHRcdGlmKHByb3A9PVwicm90YXRpb25cIil7IHR3ZWVuLl9fbmVlZHNSb3QgPSB0cnVlOyB9XG5cdFx0cmV0dXJuIHByb3A9PVwiZ3VpZGVcIj9udWxsOnZhbHVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAbWV0aG9kIHN0ZXBcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0TW90aW9uR3VpZGVQbHVnaW4uc3RlcCA9IGZ1bmN0aW9uKHR3ZWVuLCBwcm9wLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgaW5qZWN0UHJvcHMpIHtcblx0XHQvLyBvdGhlciBwcm9wc1xuXHRcdGlmKHByb3AgPT0gXCJyb3RhdGlvblwiKXtcblx0XHRcdHR3ZWVuLl9fcm90R2xvYmFsUyA9IHN0YXJ0VmFsdWU7XG5cdFx0XHR0d2Vlbi5fX3JvdEdsb2JhbEUgPSBlbmRWYWx1ZTtcblx0XHRcdE1vdGlvbkd1aWRlUGx1Z2luLnRlc3RSb3REYXRhKHR3ZWVuLCBpbmplY3RQcm9wcyk7XG5cdFx0fVxuXHRcdGlmKHByb3AgIT0gXCJndWlkZVwiKXsgcmV0dXJuIGVuZFZhbHVlOyB9XG5cblx0XHQvLyBndWlkZSBvbmx5IGluZm9ybWF0aW9uIC0gU3RhcnQgLVxuXHRcdHZhciB0ZW1wLCBkYXRhID0gZW5kVmFsdWU7XG5cdFx0aWYoIWRhdGEuaGFzT3duUHJvcGVydHkoXCJwYXRoXCIpKXsgZGF0YS5wYXRoID0gW107IH1cblx0XHR2YXIgcGF0aCA9IGRhdGEucGF0aDtcblx0XHRpZighZGF0YS5oYXNPd25Qcm9wZXJ0eShcImVuZFwiKSl7IGRhdGEuZW5kID0gMTsgfVxuXHRcdGlmKCFkYXRhLmhhc093blByb3BlcnR5KFwic3RhcnRcIikpe1xuXHRcdFx0ZGF0YS5zdGFydCA9IChzdGFydFZhbHVlJiZzdGFydFZhbHVlLmhhc093blByb3BlcnR5KFwiZW5kXCIpJiZzdGFydFZhbHVlLnBhdGg9PT1wYXRoKT9zdGFydFZhbHVlLmVuZDowO1xuXHRcdH1cblxuXHRcdC8vIEZpZ3VyZSBvdXQgc3VibGluZSBpbmZvcm1hdGlvblxuXHRcdGlmKGRhdGEuaGFzT3duUHJvcGVydHkoXCJfc2VnbWVudHNcIikgJiYgZGF0YS5fbGVuZ3RoKXsgcmV0dXJuIGVuZFZhbHVlOyB9XG5cdFx0dmFyIGwgPSBwYXRoLmxlbmd0aDtcblx0XHR2YXIgYWNjdXJhY3kgPSAxMDtcdFx0Ly8gQWRqdXN0IHRvIGltcHJvdmUgbGluZSBmb2xsb3dpbmcgcHJlY2lzaW9uIGJ1dCBzYWNyaWZpY2UgcGVyZm9ybWFuY2UgKCMgb2Ygc2VnKVxuXHRcdGlmKGwgPj0gNiAmJiAobC0yKSAlIDQgPT0gMCl7XHQvLyBFbm91Z2ggcG9pbnRzICYmIGNvbnRhaW5zIGNvcnJlY3QgbnVtYmVyIHBlciBlbnRyeSBpZ25vcmluZyBzdGFydFxuXHRcdFx0ZGF0YS5fc2VnbWVudHMgPSBbXTtcblx0XHRcdGRhdGEuX2xlbmd0aCA9IDA7XG5cdFx0XHRmb3IodmFyIGk9MjsgaTxsOyBpKz00KXtcblx0XHRcdFx0dmFyIHN4ID0gcGF0aFtpLTJdLCBzeSA9IHBhdGhbaS0xXTtcblx0XHRcdFx0dmFyIGN4ID0gcGF0aFtpKzBdLCBjeSA9IHBhdGhbaSsxXTtcblx0XHRcdFx0dmFyIGV4ID0gcGF0aFtpKzJdLCBleSA9IHBhdGhbaSszXTtcblx0XHRcdFx0dmFyIG9sZFggPSBzeCwgb2xkWSA9IHN5O1xuXHRcdFx0XHR2YXIgdGVtcFgsIHRlbXBZLCB0b3RhbCA9IDA7XG5cdFx0XHRcdHZhciBzdWJsaW5lcyA9IFtdO1xuXHRcdFx0XHRmb3IodmFyIGo9MTsgajw9YWNjdXJhY3k7IGorKyl7XG5cdFx0XHRcdFx0dmFyIHQgPSBqL2FjY3VyYWN5O1xuXHRcdFx0XHRcdHZhciBpbnYgPSAxIC0gdDtcblx0XHRcdFx0XHR0ZW1wWCA9IGludippbnYgKiBzeCArIDIgKiBpbnYgKiB0ICogY3ggKyB0KnQgKiBleDtcblx0XHRcdFx0XHR0ZW1wWSA9IGludippbnYgKiBzeSArIDIgKiBpbnYgKiB0ICogY3kgKyB0KnQgKiBleTtcblx0XHRcdFx0XHR0b3RhbCArPSBzdWJsaW5lc1tzdWJsaW5lcy5wdXNoKE1hdGguc3FydCgodGVtcD10ZW1wWC1vbGRYKSp0ZW1wICsgKHRlbXA9dGVtcFktb2xkWSkqdGVtcCkpLTFdO1xuXHRcdFx0XHRcdG9sZFggPSB0ZW1wWDtcblx0XHRcdFx0XHRvbGRZID0gdGVtcFk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YS5fc2VnbWVudHMucHVzaCh0b3RhbCk7XG5cdFx0XHRcdGRhdGEuX3NlZ21lbnRzLnB1c2goc3VibGluZXMpO1xuXHRcdFx0XHRkYXRhLl9sZW5ndGggKz0gdG90YWw7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93KFwiaW52YWxpZCAncGF0aCcgZGF0YSwgcGxlYXNlIHNlZSBkb2N1bWVudGF0aW9uIGZvciB2YWxpZCBwYXRoc1wiKTtcblx0XHR9XG5cblx0XHQvLyBTZXR1cCB4L3kgdHdlZW5zXG5cdFx0dGVtcCA9IGRhdGEub3JpZW50O1xuXHRcdGRhdGEub3JpZW50ID0gdHJ1ZTtcblx0XHR2YXIgbyA9IHt9O1xuXHRcdE1vdGlvbkd1aWRlUGx1Z2luLmNhbGMoZGF0YSwgZGF0YS5zdGFydCwgbyk7XG5cdFx0dHdlZW4uX19yb3RQYXRoUyA9IE51bWJlcihvLnJvdGF0aW9uLnRvRml4ZWQoNSkpO1xuXHRcdE1vdGlvbkd1aWRlUGx1Z2luLmNhbGMoZGF0YSwgZGF0YS5lbmQsIG8pO1xuXHRcdHR3ZWVuLl9fcm90UGF0aEUgPSBOdW1iZXIoby5yb3RhdGlvbi50b0ZpeGVkKDUpKTtcblx0XHRkYXRhLm9yaWVudCA9IGZhbHNlO1x0Ly9oZXJlIGFuZCBub3cgd2UgZG9uJ3Qga25vdyBpZiB3ZSBuZWVkIHRvXG5cdFx0TW90aW9uR3VpZGVQbHVnaW4uY2FsYyhkYXRhLCBkYXRhLmVuZCwgaW5qZWN0UHJvcHMpO1xuXHRcdGRhdGEub3JpZW50ID0gdGVtcDtcblxuXHRcdC8vIFNldHVwIHJvdGF0aW9uIHByb3BlcnRpZXNcblx0XHRpZighZGF0YS5vcmllbnQpeyByZXR1cm4gZW5kVmFsdWU7IH1cblx0XHR0d2Vlbi5fX2d1aWRlRGF0YSA9IGRhdGE7XG5cdFx0TW90aW9uR3VpZGVQbHVnaW4udGVzdFJvdERhdGEodHdlZW4sIGluamVjdFByb3BzKTtcblx0XHRyZXR1cm4gZW5kVmFsdWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBtZXRob2QgdGVzdFJvdERhdGFcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc3RhdGljXG5cdCAqKi9cblx0TW90aW9uR3VpZGVQbHVnaW4udGVzdFJvdERhdGEgPSBmdW5jdGlvbih0d2VlbiwgaW5qZWN0UHJvcHMpe1xuXG5cdFx0Ly8gbm8gcm90YXRpb24gaW5mb3JtYXQ/IGlmIHdlIG5lZWQgaXQgY29tZSBiYWNrLCBpZiB3ZSBkb24ndCB1c2UgMCAmIGVuc3VyZSB3ZSBoYXZlIGd1aWRlIGRhdGFcblx0XHRpZih0d2Vlbi5fX3JvdEdsb2JhbFMgPT09IHVuZGVmaW5lZCB8fCB0d2Vlbi5fX3JvdEdsb2JhbEUgPT09IHVuZGVmaW5lZCl7XG5cdFx0XHRpZih0d2Vlbi5fX25lZWRzUm90KXsgcmV0dXJuOyB9XG5cdFx0XHRpZih0d2Vlbi5fY3VyUXVldWVQcm9wcy5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkKXtcblx0XHRcdFx0dHdlZW4uX19yb3RHbG9iYWxTID0gdHdlZW4uX19yb3RHbG9iYWxFID0gdHdlZW4uX2N1clF1ZXVlUHJvcHMucm90YXRpb247XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5fX3JvdEdsb2JhbFMgPSB0d2Vlbi5fX3JvdEdsb2JhbEUgPSBpbmplY3RQcm9wcy5yb3RhdGlvbiA9IHR3ZWVuLnRhcmdldC5yb3RhdGlvbiB8fCAwO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZih0d2Vlbi5fX2d1aWRlRGF0YSA9PT0gdW5kZWZpbmVkKXsgcmV0dXJuOyB9XG5cblx0XHQvLyBQcm9jZXNzIHJvdGF0aW9uIHByb3BlcnRpZXNcblx0XHR2YXIgZGF0YSA9IHR3ZWVuLl9fZ3VpZGVEYXRhO1xuXHRcdHZhciByb3RHbG9iYWxEID0gdHdlZW4uX19yb3RHbG9iYWxFIC0gdHdlZW4uX19yb3RHbG9iYWxTO1xuXHRcdHZhciByb3RQYXRoRCA9IHR3ZWVuLl9fcm90UGF0aEUgLSB0d2Vlbi5fX3JvdFBhdGhTO1xuXHRcdHZhciByb3QgPSByb3RHbG9iYWxEIC0gcm90UGF0aEQ7XG5cblx0XHRpZihkYXRhLm9yaWVudCA9PSBcImF1dG9cIil7XG5cdFx0XHRpZihyb3QgPiAxODApe1x0XHRcdHJvdCAtPSAzNjA7IH1cblx0XHRcdGVsc2UgaWYocm90IDwgLTE4MCl7XHRyb3QgKz0gMzYwOyB9XG5cblx0XHR9IGVsc2UgaWYoZGF0YS5vcmllbnQgPT0gXCJjd1wiKXtcblx0XHRcdHdoaWxlKHJvdCA8IDApeyByb3QgKz0gMzYwOyB9XG5cdFx0XHRpZihyb3QgPT0gMCAmJiByb3RHbG9iYWxEID4gMCAmJiByb3RHbG9iYWxEICE9IDE4MCl7IHJvdCArPSAzNjA7IH1cblxuXHRcdH0gZWxzZSBpZihkYXRhLm9yaWVudCA9PSBcImNjd1wiKXtcblx0XHRcdHJvdCA9IHJvdEdsb2JhbEQgLSAoKHJvdFBhdGhEID4gMTgwKT8oMzYwLXJvdFBhdGhEKToocm90UGF0aEQpKTtcdC8vIHNpZ24gZmxpcHBpbmcgb24gcGF0aFxuXHRcdFx0d2hpbGUocm90ID4gMCl7IHJvdCAtPSAzNjA7IH1cblx0XHRcdGlmKHJvdCA9PSAwICYmIHJvdEdsb2JhbEQgPCAwICYmIHJvdEdsb2JhbEQgIT0gLTE4MCl7IHJvdCAtPSAzNjA7IH1cblx0XHR9XG5cblx0XHRkYXRhLnJvdERlbHRhID0gcm90O1xuXHRcdGRhdGEucm90T2ZmUyA9IHR3ZWVuLl9fcm90R2xvYmFsUyAtIHR3ZWVuLl9fcm90UGF0aFM7XG5cblx0XHQvLyByZXNldFxuXHRcdHR3ZWVuLl9fcm90R2xvYmFsUyA9IHR3ZWVuLl9fcm90R2xvYmFsRSA9IHR3ZWVuLl9fZ3VpZGVEYXRhID0gdHdlZW4uX19uZWVkc1JvdCA9IHVuZGVmaW5lZDtcblx0fTtcblxuXHQvKipcblx0ICogQG1ldGhvZCB0d2VlblxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRNb3Rpb25HdWlkZVBsdWdpbi50d2VlbiA9IGZ1bmN0aW9uKHR3ZWVuLCBwcm9wLCB2YWx1ZSwgc3RhcnRWYWx1ZXMsIGVuZFZhbHVlcywgcmF0aW8sIHdhaXQsIGVuZCkge1xuXHRcdHZhciBkYXRhID0gZW5kVmFsdWVzLmd1aWRlO1xuXHRcdGlmKGRhdGEgPT0gdW5kZWZpbmVkIHx8IGRhdGEgPT09IHN0YXJ0VmFsdWVzLmd1aWRlKXsgcmV0dXJuIHZhbHVlOyB9XG5cdFx0aWYoZGF0YS5sYXN0UmF0aW8gIT0gcmF0aW8pe1xuXHRcdFx0Ly8gZmlyc3QgdGltZSB0aHJvdWdoIHNvIGNhbGN1bGF0ZSB3aGF0IEkgbmVlZCB0b1xuXHRcdFx0dmFyIHQgPSAoKGRhdGEuZW5kLWRhdGEuc3RhcnQpKih3YWl0P2RhdGEuZW5kOnJhdGlvKStkYXRhLnN0YXJ0KTtcblx0XHRcdE1vdGlvbkd1aWRlUGx1Z2luLmNhbGMoZGF0YSwgdCwgdHdlZW4udGFyZ2V0KTtcblx0XHRcdHN3aXRjaChkYXRhLm9yaWVudCl7XG5cdFx0XHRcdGNhc2UgXCJjd1wiOlx0XHQvLyBtaXggaW4gdGhlIG9yaWdpbmFsIHJvdGF0aW9uXG5cdFx0XHRcdGNhc2UgXCJjY3dcIjpcblx0XHRcdFx0Y2FzZSBcImF1dG9cIjogdHdlZW4udGFyZ2V0LnJvdGF0aW9uICs9IGRhdGEucm90T2ZmUyArIGRhdGEucm90RGVsdGEqcmF0aW87IGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZml4ZWRcIjpcdC8vIGZvbGxvdyBmaXhlZCBiZWhhdmlvdXIgdG8gc29sdmUgcG90ZW50aWFsIGlzc3Vlc1xuXHRcdFx0XHRkZWZhdWx0OiB0d2Vlbi50YXJnZXQucm90YXRpb24gKz0gZGF0YS5yb3RPZmZTOyBicmVhaztcblx0XHRcdH1cblx0XHRcdGRhdGEubGFzdFJhdGlvID0gcmF0aW87XG5cdFx0fVxuXHRcdGlmKHByb3AgPT0gXCJyb3RhdGlvblwiICYmICgoIWRhdGEub3JpZW50KSB8fCBkYXRhLm9yaWVudCA9PSBcImZhbHNlXCIpKXsgcmV0dXJuIHZhbHVlOyB9XG5cdFx0cmV0dXJuIHR3ZWVuLnRhcmdldFtwcm9wXTtcblx0fTtcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSB4L3kvcm90YXRpb24gaW5mb3JtYXRpb24gYWJvdXQgYSBwYXRoIGZvciBhIGdpdmVuIHJhdGlvIGFsb25nIHRoZSBwYXRoLlxuXHQgKiBBc3N1bWVzIGEgcGF0aCBvYmplY3Qgd2l0aCBhbGwgb3B0aW9uYWwgcGFyYW1ldGVycyBzcGVjaWZpZWQuXG5cdCAqIEBwYXJhbSBkYXRhIERhdGEgb2JqZWN0IHlvdSB3b3VsZCBwYXNzIHRvIHRoZSBcImd1aWRlOlwiIHByb3BlcnR5IGluIGEgVHdlZW5cblx0ICogQHBhcmFtIHJhdGlvIDAtMSBEaXN0YW5jZSBhbG9uZyBwYXRoLCB2YWx1ZXMgb3V0c2lkZSAwLTEgYXJlIFwiYmVzdCBndWVzc1wiXG5cdCAqIEBwYXJhbSB0YXJnZXQgT2JqZWN0IHRvIGNvcHkgdGhlIHJlc3VsdHMgb250bywgd2lsbCB1c2UgYSBuZXcgb2JqZWN0IGlmIG5vdCBzdXBwbGllZC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgdGFyZ2V0IG9iamVjdCBvciBhIG5ldyBvYmplY3Qgdy8gdGhlIHR3ZWVuZWQgcHJvcGVydGllc1xuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRNb3Rpb25HdWlkZVBsdWdpbi5jYWxjID0gZnVuY3Rpb24oZGF0YSwgcmF0aW8sIHRhcmdldCkge1xuXHRcdGlmKGRhdGEuX3NlZ21lbnRzID09IHVuZGVmaW5lZCl7IE1vdGlvbkd1aWRlUGx1Z2luLnZhbGlkYXRlKGRhdGEpOyB9XG5cdFx0aWYodGFyZ2V0ID09IHVuZGVmaW5lZCl7IHRhcmdldCA9IHt4OjAsIHk6MCwgcm90YXRpb246MH07IH1cblx0XHR2YXIgc2VnID0gZGF0YS5fc2VnbWVudHM7XG5cdFx0dmFyIHBhdGggPSBkYXRhLnBhdGg7XG5cblx0XHQvLyBmaW5kIHNlZ21lbnRcblx0XHR2YXIgcG9zID0gZGF0YS5fbGVuZ3RoICogcmF0aW87XG5cdFx0dmFyIGNhcCA9IHNlZy5sZW5ndGggLSAyO1xuXHRcdHZhciBuID0gMDtcblx0XHR3aGlsZShwb3MgPiBzZWdbbl0gJiYgbiA8IGNhcCl7XG5cdFx0XHRwb3MgLT0gc2VnW25dO1xuXHRcdFx0bis9Mjtcblx0XHR9XG5cblx0XHQvLyBmaW5kIHN1YmxpbmVcblx0XHR2YXIgc3VibGluZXMgPSBzZWdbbisxXTtcblx0XHR2YXIgaSA9IDA7XG5cdFx0Y2FwID0gc3VibGluZXMubGVuZ3RoLTE7XG5cdFx0d2hpbGUocG9zID4gc3VibGluZXNbaV0gJiYgaSA8IGNhcCl7XG5cdFx0XHRwb3MgLT0gc3VibGluZXNbaV07XG5cdFx0XHRpKys7XG5cdFx0fVxuXHRcdHZhciB0ID0gKGkvKytjYXApKyhwb3MvKGNhcCpzdWJsaW5lc1tpXSkpO1xuXG5cdFx0Ly8gZmluZCB4L3lcblx0XHRuID0gKG4qMikrMjtcblx0XHR2YXIgaW52ID0gMSAtIHQ7XG5cdFx0dGFyZ2V0LnggPSBpbnYqaW52ICogcGF0aFtuLTJdICsgMiAqIGludiAqIHQgKiBwYXRoW24rMF0gKyB0KnQgKiBwYXRoW24rMl07XG5cdFx0dGFyZ2V0LnkgPSBpbnYqaW52ICogcGF0aFtuLTFdICsgMiAqIGludiAqIHQgKiBwYXRoW24rMV0gKyB0KnQgKiBwYXRoW24rM107XG5cblx0XHQvLyBvcmllbnRhdGlvblxuXHRcdGlmKGRhdGEub3JpZW50KXtcblx0XHRcdHRhcmdldC5yb3RhdGlvbiA9IDU3LjI5NTc3OTUgKiBNYXRoLmF0YW4yKFxuXHRcdFx0XHQocGF0aFtuKzFdLXBhdGhbbi0xXSkqaW52ICsgKHBhdGhbbiszXS1wYXRoW24rMV0pKnQsXG5cdFx0XHRcdChwYXRoW24rMF0tcGF0aFtuLTJdKSppbnYgKyAocGF0aFtuKzJdLXBhdGhbbiswXSkqdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fTtcblxuXHRjcmVhdGVqcy5Nb3Rpb25HdWlkZVBsdWdpbiA9IE1vdGlvbkd1aWRlUGx1Z2luO1xuXG59KCkpO1xuXG4vLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuLy8gdmVyc2lvbi5qc1xuLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcblxudGhpcy5jcmVhdGVqcyA9IHRoaXMuY3JlYXRlanMgfHwge307XG5cbihmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0LyoqXG5cdCAqIFN0YXRpYyBjbGFzcyBob2xkaW5nIGxpYnJhcnkgc3BlY2lmaWMgaW5mb3JtYXRpb24gc3VjaCBhcyB0aGUgdmVyc2lvbiBhbmQgYnVpbGREYXRlIG9mXG5cdCAqIHRoZSBsaWJyYXJ5LlxuXHQgKiBAY2xhc3MgVHdlZW5KU1xuXHQgKiovXG5cdHZhciBzID0gY3JlYXRlanMuVHdlZW5KUyA9IGNyZWF0ZWpzLlR3ZWVuSlMgfHwge307XG5cblx0LyoqXG5cdCAqIFRoZSB2ZXJzaW9uIHN0cmluZyBmb3IgdGhpcyByZWxlYXNlLlxuXHQgKiBAcHJvcGVydHkgdmVyc2lvblxuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICogQHN0YXRpY1xuXHQgKiovXG5cdHMudmVyc2lvbiA9IC8qPXZlcnNpb24qL1wiMC42LjFcIjsgLy8gaW5qZWN0ZWQgYnkgYnVpbGQgcHJvY2Vzc1xuXG5cdC8qKlxuXHQgKiBUaGUgYnVpbGQgZGF0ZSBmb3IgdGhpcyByZWxlYXNlIGluIFVUQyBmb3JtYXQuXG5cdCAqIEBwcm9wZXJ0eSBidWlsZERhdGVcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqIEBzdGF0aWNcblx0ICoqL1xuXHRzLmJ1aWxkRGF0ZSA9IC8qPWRhdGUqL1wiVGh1LCAyMSBNYXkgMjAxNSAxNjoxNzozNyBHTVRcIjsgLy8gaW5qZWN0ZWQgYnkgYnVpbGQgcHJvY2Vzc1xuXG59KSgpO1xuaWYodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIG1vZHVsZS5leHBvcnRzID0gdGhpcy5jcmVhdGVqczsiLCIndXNlIHN0cmljdCdcclxuXHJcbi8vIFRPRE86IHJlc2l6ZSBvciByZXBvc2l0aW9uIHNoYXBlcyBiYXNlZCBvbiBtZWRpYSBzaXplXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpIHtcclxuXHJcblx0dmFyIGNyZWF0ZWpzID0gcmVxdWlyZSgnY3JlYXRlanMtY29sbGVjdGlvbicpO1xyXG5cclxuXHR2YXIgc3RhZ2UgPSBuZXcgY3JlYXRlanMuU3RhZ2UoXCJnYW1lQ2FudmFzXCIpO1xyXG5cclxuXHR2YXIgc3F1YXJlT25lID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCksXHJcblx0XHRzcXVhcmVUd28gPSBuZXcgY3JlYXRlanMuU2hhcGUoKSxcclxuXHRcdHNxdWFyZVRocmVlID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCksXHJcblx0XHRzcXVhcmVGb3VyID0gbmV3IGNyZWF0ZWpzLlNoYXBlKCk7XHJcblxyXG5cdC8vIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBzcXVhcmVzXHJcblx0dmFyIHNxdWFyZVdpZHRoID0gY2FudmFzV2lkdGggKiAwLjQsXHJcblx0XHRzcXVhcmVIZWlnaHQgPSBjYW52YXNIZWlnaHQgKiAwLjQsXHJcblx0XHRjZW50ZXJXaWR0aCA9IGNhbnZhc1dpZHRoIC8gMixcclxuXHRcdGNlbnRlckhlaWdodCA9IGNhbnZhc0hlaWdodCAvIDI7XHJcblxyXG5cdC8vIHN0YXJ0aW5nIHBvc2l0aW9uIChzcXVhcmUgb25lKSBhbmQgb2Zmc2V0cyAoYWxsIG90aGVyIHNxdWFyZXMpXHJcblx0dmFyIHhPZmZzZXQgPSBjZW50ZXJXaWR0aCAtIHNxdWFyZVdpZHRoIC0gNSxcclxuXHRcdHlPZmZzZXQgPSBjZW50ZXJIZWlnaHQgLSBzcXVhcmVIZWlnaHQgLSA1O1xyXG5cclxuXHQvLyBzcGFjaW5nIGJldHdlZW4gc3F1YXJlc1xyXG5cdHZhciBzcGFjaW5nID0gMTA7XHJcblxyXG5cdC8vIHJlY3RhbmdsZSBwYXJhbXMgLSB4LCB5LCB3aWR0aCwgaGVpZ2h0XHJcblx0c3F1YXJlT25lLmdyYXBoaWNzLmJlZ2luRmlsbChcInJlZFwiKS5kcmF3UmVjdCh4T2Zmc2V0LCB5T2Zmc2V0LCBzcXVhcmVXaWR0aCwgc3F1YXJlSGVpZ2h0KTtcclxuXHRzdGFnZS5hZGRDaGlsZChzcXVhcmVPbmUpO1xyXG5cclxuXHRzcXVhcmVUd28uZ3JhcGhpY3MuYmVnaW5GaWxsKFwiZ3JlZW5cIikuZHJhd1JlY3QoMCwgeU9mZnNldCwgc3F1YXJlV2lkdGgsIHNxdWFyZUhlaWdodCk7XHJcblx0c3F1YXJlVHdvLnggPSB4T2Zmc2V0ICsgc3F1YXJlV2lkdGggKyBzcGFjaW5nOyAvLyBzcXVhcmUgMiBwb3NpdGlvbmluZ1xyXG5cdHN0YWdlLmFkZENoaWxkKHNxdWFyZVR3byk7XHJcblxyXG5cdHNxdWFyZVRocmVlLmdyYXBoaWNzLmJlZ2luRmlsbChcImJsdWVcIikuZHJhd1JlY3QoeE9mZnNldCwgMCwgc3F1YXJlV2lkdGgsIHNxdWFyZUhlaWdodCk7XHJcblx0c3F1YXJlVGhyZWUueSA9IHlPZmZzZXQgKyBzcXVhcmVIZWlnaHQgKyBzcGFjaW5nOyAvLyBzcXVhcmUgMyBwb3NpdGlvbmluZ1xyXG5cdHN0YWdlLmFkZENoaWxkKHNxdWFyZVRocmVlKTtcclxuXHJcblx0c3F1YXJlRm91ci5ncmFwaGljcy5iZWdpbkZpbGwoXCJ5ZWxsb3dcIikuZHJhd1JlY3QoMCwgMCwgc3F1YXJlV2lkdGgsIHNxdWFyZUhlaWdodCk7XHJcblx0c3F1YXJlRm91ci54ID0geE9mZnNldCArIHNxdWFyZVdpZHRoICsgc3BhY2luZzsgLy8gc3F1YXJlIDQgcG9zaXRpb25pbmdcclxuXHRzcXVhcmVGb3VyLnkgPSB5T2Zmc2V0ICsgc3F1YXJlSGVpZ2h0ICsgc3BhY2luZzsgLy8gc3F1YXJlIDQgcG9zaXRpb25pbmdcclxuXHRzdGFnZS5hZGRDaGlsZChzcXVhcmVGb3VyKTtcclxuXHRcclxuXHJcblx0LyogXHJcblx0XHQtQ2hhbmdpbmcgeCBtb3ZlcyB0aGUgc2hhcGUgaG9yaXpvbmF0YWxseVxyXG5cdFx0LUNoYW5naW5nIHkgbW92ZXMgdGhlIHNoYXBlIHZlcnRpY2FsbHlcclxuXHRcdC1DaGFuZ2luZyBhbHBoYSB3aWxsIGZhZGUgdGhlIHNoYXBlIGluIGFuZCBvdXRcclxuXHQqL1xyXG5cclxuXHQvKlxyXG5cdFx0Y3JlYXRlanMuVHdlZW4uZ2V0KGNpcmNsZSwgeyBsb29wOiB0cnVlIH0pXHJcblx0XHRcdC50byh7IHg6IDQwMCB9LCAxMDAwLCBjcmVhdGVqcy5FYXNlLmdldFBvd0luT3V0KDQpKVxyXG5cdFx0XHQudG8oeyBhbHBoYTogMCwgeTogMTc1IH0sIDUwMCwgY3JlYXRlanMuRWFzZS5nZXRQb3dJbk91dCgyKSlcclxuXHRcdFx0LnRvKHsgYWxwaGE6IDAsIHk6IDIyNSB9LCAxMDApXHJcblx0XHRcdC50byh7IGFscGhhOiAxLCB5OiAyMDAgfSwgNTAwLCBjcmVhdGVqcy5FYXNlLmdldFBvd0luT3V0KDIpKVxyXG5cdFx0XHQudG8oeyB4OiAxMDAgfSwgODAwLCBjcmVhdGVqcy5FYXNlLmdldFBvd0luT3V0KDIpKTtcclxuXHJcblx0XHRjcmVhdGVqcy5UaWNrZXIuc2V0RlBTKDYwKTtcclxuXHRcdGNyZWF0ZWpzLlRpY2tlci5hZGRFdmVudExpc3RlbmVyKFwidGlja1wiLCBzdGFnZSk7XHJcblx0Ki9cclxuXHJcblx0c3RhZ2UudXBkYXRlKCk7IC8vIGNhbid0IGJlIHVzZWQgd2hlbiB1c2luZyB0d2VlblxyXG5cdFx0XHRcclxufTsiLCIoZnVuY3Rpb24oKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0J1xyXG5cclxuXHR2YXIgcmVzaXplID0gcmVxdWlyZSgnLi9yZXNpemVDYW52YXMnKTtcclxuXHJcblx0cmVzaXplKCk7XHJcblxyXG5cdHZhciByYW5kb21JbnQgPSByZXF1aXJlKCcuL3JhbmRvbUludEZyb21JbnRlcnZhbCcpO1xyXG5cclxuXHR2YXIgcmFuZG9tU3F1YXJlID0gcmFuZG9tSW50KDEsIDQpO1xyXG5cclxufSkoKTsiLCIndXNlIHN0cmljdCdcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1pbiwgbWF4KSB7XHJcblxyXG5cdHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4LW1pbisxKSArIG1pbik7XHJcblxyXG59IiwiJ3VzZSBzdHJpY3QnXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGRyYXcgPSByZXF1aXJlKCcuL2RyYXcnKVxyXG5cclxuXHR2YXIgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2dhbWVDYW52YXMnKSxcclxuXHRcdGdhbWVTZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2dhbWVTZWN0aW9uJyk7XHJcblxyXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVDYW52YXMsIGZhbHNlKTtcclxuXHJcblx0ZnVuY3Rpb24gcmVzaXplQ2FudmFzKCkge1xyXG5cclxuXHRcdHZhciB3aWR0aCA9IGdhbWVTZWN0aW9uLm9mZnNldFdpZHRoLFxyXG5cdFx0XHRoZWlnaHQgPSBnYW1lU2VjdGlvbi5vZmZzZXRIZWlnaHQ7XHJcblxyXG5cdFx0aWYgKHdpZHRoID4gaGVpZ2h0KSB7XHJcblx0XHRcdGNhbnZhcy53aWR0aCA9IGhlaWdodDtcclxuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gd2lkdGg7XHJcblx0XHR9XHJcblxyXG5cdFx0ZHJhdyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG5cclxuXHR9XHJcblxyXG5cdHJlc2l6ZUNhbnZhcygpO1xyXG5cclxufTsiXX0=
